diff -r 6de576aeff11 accessible/src/base/nsAccessibilityAtomList.h
--- a/accessible/src/base/nsAccessibilityAtomList.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/base/nsAccessibilityAtomList.h	Thu Aug 28 21:06:41 2008 +0300
@@ -186,10 +186,11 @@ ACCESSIBILITY_ATOM(tooltiptext, "tooltip
 ACCESSIBILITY_ATOM(tooltiptext, "tooltiptext")
 ACCESSIBILITY_ATOM(type, "type")
 ACCESSIBILITY_ATOM(value, "value")
 
   // Alphabetical list of text attributes (AT API)
+ACCESSIBILITY_ATOM(backgroundColor, "background-color")
 ACCESSIBILITY_ATOM(invalid, "invalid")
 ACCESSIBILITY_ATOM(language, "language")
 
   // ARIA (DHTML accessibility) attributes
   // Also add to nsARIAMap.cpp and nsARIAMap.h
diff -r 6de576aeff11 accessible/src/base/nsAccessibilityUtils.cpp
--- a/accessible/src/base/nsAccessibilityUtils.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/base/nsAccessibilityUtils.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -799,10 +799,24 @@ nsAccUtils::GetDocShellTreeItemFor(nsIDO
     CallQueryInterface(container, &docShellTreeItem);
 
   return docShellTreeItem;
 }
 
+nsIFrame*
+nsAccUtils::GetFrameFor(nsIDOMElement *aElm)
+{
+  nsCOMPtr<nsIPresShell> shell = nsAccessNode::GetPresShellFor(aElm);
+  if (!shell)
+    return nsnull;
+  
+  nsCOMPtr<nsIContent> content(do_QueryInterface(aElm));
+  if (!content)
+    return nsnull;
+  
+  return shell->GetPrimaryFrameFor(content);
+}
+
 PRBool
 nsAccUtils::GetID(nsIContent *aContent, nsAString& aID)
 {
   nsIAtom *idAttribute = aContent->GetIDAttributeName();
   return idAttribute ? aContent->GetAttr(kNameSpaceID_None, idAttribute, aID) : PR_FALSE;
diff -r 6de576aeff11 accessible/src/base/nsAccessibilityUtils.h
--- a/accessible/src/base/nsAccessibilityUtils.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/base/nsAccessibilityUtils.h	Thu Aug 28 21:06:41 2008 +0300
@@ -306,10 +306,15 @@ public:
    */
   static already_AddRefed<nsIDocShellTreeItem>
     GetDocShellTreeItemFor(nsIDOMNode *aNode);
 
   /**
+   * Retrun frame for the given DOM element.
+   */
+  static nsIFrame* GetFrameFor(nsIDOMElement *aElm);
+
+  /**
    * Get the ID for an element, in some types of XML this may not be the ID attribute
    * @param aContent  Node to get the ID for
    * @param aID       Where to put ID string
    * @return          PR_TRUE if there is an ID set for this node
    */
diff -r 6de576aeff11 accessible/src/base/nsTextUtils.cpp
--- a/accessible/src/base/nsTextUtils.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/base/nsTextUtils.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -37,16 +37,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsTextUtils.h"
 
 #include "nsAccessNode.h"
+#include "nsAccessibilityUtils.h"
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsLangTextAttr
 
 PRBool
-nsLangTextAttr::equal(nsIDOMElement *aElm)
+nsLangTextAttr::Equal(nsIDOMElement *aElm)
 {
   nsCOMPtr<nsIContent> content(do_QueryInterface(aElm));
   if (!content)
     return PR_FALSE;
 
@@ -78,11 +79,10 @@ const char* const kCopyName = nsnull;
 const char* const kCopyName = nsnull;
 const char* const kCopyValue = nsnull;
 
 static nsCSSTextAttrMapItem gCSSTextAttrsMap[] = {
   // CSS name            CSS value        Attribute name              Attribute name
-  { "background-color",  kAnyValue,       kCopyName,                  kCopyValue },
   { "color",             kAnyValue,       kCopyName,                  kCopyValue },
   { "font-family",       kAnyValue,       kCopyName,                  kCopyValue },
   { "font-size",         kAnyValue,       kCopyName,                  kCopyValue },
   { "font-style",        kAnyValue,       kCopyName,                  kCopyValue },
   { "font-weight",       kAnyValue,       kCopyName,                  kCopyValue },
@@ -104,11 +104,11 @@ nsCSSTextAttr::nsCSSTextAttr(PRBool aInc
     nsAccessNode::GetComputedStyleDeclaration(EmptyString(), aRootElm,
                                               getter_AddRefs(mDefStyleDecl));
 }
 
 PRBool
-nsCSSTextAttr::equal(nsIDOMElement *aElm)
+nsCSSTextAttr::Equal(nsIDOMElement *aElm)
 {
   if (!aElm || !mStyleDecl)
     return PR_FALSE;
 
   nsCOMPtr<nsIDOMCSSStyleDeclaration> currStyleDecl;
@@ -128,17 +128,17 @@ nsCSSTextAttr::equal(nsIDOMElement *aElm
   rv = mStyleDecl->GetPropertyValue(cssName, value);
   return NS_SUCCEEDED(rv) && value == currValue;
 }
 
 PRBool
-nsCSSTextAttr::iterate()
+nsCSSTextAttr::Iterate()
 {
   return ++mIndex < static_cast<PRInt32>(NS_ARRAY_LENGTH(gCSSTextAttrsMap));
 }
 
 PRBool
-nsCSSTextAttr::get(nsACString& aName, nsAString& aValue)
+nsCSSTextAttr::Get(nsACString& aName, nsAString& aValue)
 {
   if (!mStyleDecl)
     return PR_FALSE;
 
   NS_ConvertASCIItoUTF16 cssName(gCSSTextAttrsMap[mIndex].mCSSName);
@@ -177,5 +177,67 @@ nsCSSTextAttr::get(nsACString& aName, ns
     AppendASCIItoUTF16(attrValue, aValue);
 
   return PR_TRUE;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+// nsBackgroundTextAttr
+
+nsBackgroundTextAttr::nsBackgroundTextAttr(nsIFrame *aFrame,
+                                           nsIFrame *aRootFrame) :
+  mFrame(aFrame), mRootFrame(aRootFrame)
+{
+}
+
+PRBool
+nsBackgroundTextAttr::Equal(nsIDOMElement *aElm)
+{
+  nsIFrame *frame = nsAccUtils::GetFrameFor(aElm);
+  if (!frame)
+    return PR_FALSE;
+
+  return GetColor(mFrame) == GetColor(frame);    
+}
+
+PRBool
+nsBackgroundTextAttr::Get(nsAString& aValue)
+{
+  // Do not expose "background-color" text attribute if its value is matched
+  // with the default value.
+  nscolor color = GetColor(mFrame);
+  if (mRootFrame && color == GetColor(mRootFrame))
+    return PR_FALSE;
+
+  // Combine the string like rgb(R, G, B) from nscolor.
+  nsAutoString value;
+  value.AppendLiteral("rgb(");
+  value.AppendInt(NS_GET_R(color));
+  value.AppendLiteral(", ");
+  value.AppendInt(NS_GET_G(color));
+  value.AppendLiteral(", ");
+  value.AppendInt(NS_GET_B(color));
+  value.Append(')');
+
+  aValue = value;
+  return PR_TRUE;
+}
+
+nscolor
+nsBackgroundTextAttr::GetColor(nsIFrame *aFrame)
+{
+  const nsStyleBackground *styleBackground = aFrame->GetStyleBackground();
+
+  if (!styleBackground->IsTransparent())
+    return styleBackground->mBackgroundColor;
+
+  nsIFrame *parentFrame = aFrame->GetParent();
+  if (!parentFrame)
+    return styleBackground->mBackgroundColor;
+
+  // Each frame of parents chain for the initially passed 'aFrame' has
+  // transparent background color. So background color isn't changed from
+  // 'mRootFrame' to initially passed 'aFrame'.
+  if (parentFrame == mRootFrame)
+    return GetColor(mRootFrame);
+
+  return GetColor(parentFrame);
+}
diff -r 6de576aeff11 accessible/src/base/nsTextUtils.h
--- a/accessible/src/base/nsTextUtils.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/base/nsTextUtils.h	Thu Aug 28 21:06:41 2008 +0300
@@ -41,10 +41,11 @@
 
 #include "nsIDOMElement.h"
 #include "nsIDOMCSSStyleDeclaration.h"
 
 #include "nsIContent.h"
+#include "nsIFrame.h"
 
 #include "nsCOMPtr.h"
 #include "nsString.h"
 
 /**
@@ -55,11 +56,11 @@ public:
 public:
   /**
    * Return true if the text attribute for the given element equals with
    * predefined attribute.
    */
-  virtual PRBool equal(nsIDOMElement *aElm) = 0;
+  virtual PRBool Equal(nsIDOMElement *aElm) = 0;
 };
 
 /**
  * Class is used for the work with 'lang' text attributes. Used in
  * nsHyperTextAccessible.
@@ -68,11 +69,11 @@ class nsLangTextAttr : public nsTextAttr
 {
 public:
   nsLangTextAttr(nsAString& aLang, nsIContent *aRootContent) :
     mLang(aLang), mRootContent(aRootContent) { }
 
-  virtual PRBool equal(nsIDOMElement *aElm);
+  virtual PRBool Equal(nsIDOMElement *aElm);
 
 private:
   nsString mLang;
   nsCOMPtr<nsIContent> mRootContent;
 };
@@ -86,27 +87,63 @@ public:
 public:
   nsCSSTextAttr(PRBool aIncludeDefAttrValue, nsIDOMElement *aElm,
                 nsIDOMElement *aRootElm);
 
   // nsTextAttr
-  virtual PRBool equal(nsIDOMElement *aElm);
+  virtual PRBool Equal(nsIDOMElement *aElm);
 
   // nsCSSTextAttr
   /**
    * Interates through attributes.
    */
-  PRBool iterate();
+  PRBool Iterate();
 
   /**
    * Get name and value of attribute.
    */
-  PRBool get(nsACString& aName, nsAString& aValue);
+  PRBool Get(nsACString& aName, nsAString& aValue);
 
 private:
   PRInt32 mIndex;
   PRBool mIncludeDefAttrValue;
 
   nsCOMPtr<nsIDOMCSSStyleDeclaration> mStyleDecl;
   nsCOMPtr<nsIDOMCSSStyleDeclaration> mDefStyleDecl;
 };
 
+/**
+ * Class is used for the work with "background-color" text attribute. It is
+ * used in nsHyperTextAccessible.
+ */
+class nsBackgroundTextAttr : public nsTextAttr
+{
+public:
+  nsBackgroundTextAttr(nsIFrame *aFrame, nsIFrame *aRootFrame);
+  
+  // nsTextAttr
+  virtual PRBool Equal(nsIDOMElement *aElm);
+
+  /**
+   * Returns true and background color value if "background-color" text
+   * attribute should be exposed.
+   */
+  virtual PRBool Get(nsAString& aValue);
+
+private:
+  /**
+   * Return background color for the given frame.
+   *
+   * @note  If background color for the given frame is transparent then walk
+   *        trhough the frame parents chain until we'll got either a frame with
+   *        not transparent background color or the given root frame. In the
+   *        last case return background color for the root frame.
+   *
+   * @param aFrame      [in] the given frame to calculate background-color
+   * @return            background color
+   */
+  nscolor GetColor(nsIFrame *aFrame);
+
+  nsIFrame *mFrame;
+  nsIFrame *mRootFrame;
+};
+
 #endif
diff -r 6de576aeff11 accessible/src/html/nsHyperTextAccessible.cpp
--- a/accessible/src/html/nsHyperTextAccessible.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/html/nsHyperTextAccessible.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -733,10 +733,34 @@ nsHyperTextAccessible::HypertextOffsetsT
   *aEndNode = nsnull;
 
   NS_ENSURE_ARG_POINTER(aEndOffset);
   *aEndOffset = -1;
 
+  // If the given offsets are 0 and associated editor is empty then return
+  // collapsed range with editor root element as range container.
+  if (aStartHTOffset == 0 && aEndHTOffset == 0) {
+    nsCOMPtr<nsIEditor> editor;
+    GetAssociatedEditor(getter_AddRefs(editor));
+    if (editor) {
+      PRBool isEmpty = PR_FALSE;
+      editor->GetDocumentIsEmpty(&isEmpty);
+      if (isEmpty) {
+        nsCOMPtr<nsIDOMElement> editorRootElm;
+        editor->GetRootElement(getter_AddRefs(editorRootElm));
+
+        nsCOMPtr<nsIDOMNode> editorRoot(do_QueryInterface(editorRootElm));
+        if (editorRoot) {
+          *aStartOffset = *aEndOffset = 0;
+          NS_ADDREF(*aStartNode = editorRoot);
+          NS_ADDREF(*aEndNode = editorRoot);
+
+          return NS_OK;
+        }
+      }
+    }
+  }
+
   nsCOMPtr<nsIAccessible> startAcc, endAcc;
   PRInt32 startOffset = aStartHTOffset, endOffset = aEndHTOffset;
   nsIFrame *startFrame = nsnull, *endFrame = nsnull;
 
   startFrame = GetPosAndText(startOffset, endOffset, nsnull, &endFrame, nsnull,
@@ -1178,16 +1202,28 @@ nsHyperTextAccessible::GetDefaultTextAtt
     return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIDOMElement> element = nsAccUtils::GetDOMElementFor(mDOMNode);
 
   nsCSSTextAttr textAttr(PR_TRUE, element, nsnull);
-  while (textAttr.iterate()) {
+  while (textAttr.Iterate()) {
     nsCAutoString name;
     nsAutoString value, oldValue;
-    if (textAttr.get(name, value))
+    if (textAttr.Get(name, value))
       attributes->SetStringProperty(name, value, oldValue);
   }
+
+  nsIFrame *sourceFrame = nsAccUtils::GetFrameFor(element);
+  if (sourceFrame) {
+    nsBackgroundTextAttr backgroundTextAttr(sourceFrame, nsnull);
+
+    nsAutoString value;
+    if (backgroundTextAttr.Get(value)) {
+      nsAccUtils::SetAccAttr(attributes,
+                             nsAccessibilityAtoms::backgroundColor, value);
+    }
+  }
+
   return NS_OK;
 }
 
 nsresult
 nsHyperTextAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
@@ -2286,19 +2322,38 @@ nsHyperTextAccessible::GetCSSTextAttribu
 {
   nsCOMPtr<nsIDOMElement> sourceElm(nsAccUtils::GetDOMElementFor(aSourceNode));
   nsCOMPtr<nsIDOMElement> rootElm(nsAccUtils::GetDOMElementFor(mDOMNode));
 
   nsCSSTextAttr textAttr(aIncludeDefAttrs, sourceElm, rootElm);
-  while (textAttr.iterate()) {
+  while (textAttr.Iterate()) {
     nsCAutoString name;
     nsAutoString value, oldValue;
-    if (aAttributes && textAttr.get(name, value))
+    if (aAttributes && textAttr.Get(name, value))
       aAttributes->SetStringProperty(name, value, oldValue);
 
     nsresult rv = GetRangeForTextAttr(aSourceNode, &textAttr,
                                       aStartHTOffset, aEndHTOffset);
     NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  nsIFrame *sourceFrame = nsAccUtils::GetFrameFor(sourceElm);
+  if (sourceFrame) {
+    nsIFrame *rootFrame = nsnull;
+
+    if (!aIncludeDefAttrs)
+      rootFrame = nsAccUtils::GetFrameFor(rootElm);
+
+    nsBackgroundTextAttr backgroundTextAttr(sourceFrame, rootFrame);
+    nsAutoString value;
+    if (backgroundTextAttr.Get(value)) {
+      nsAccUtils::SetAccAttr(aAttributes,
+                             nsAccessibilityAtoms::backgroundColor, value);
+    }
+
+    nsresult rv = GetRangeForTextAttr(aSourceNode, &backgroundTextAttr,
+                                      aStartHTOffset, aEndHTOffset);
+    return rv;
   }
 
   return NS_OK;
 }
 
@@ -2326,11 +2381,11 @@ nsHyperTextAccessible::GetRangeForTextAt
   // Navigate backwards (find the start offset).
   while (currNode && currNode != rootElm) {
     nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(currNode));
     NS_ENSURE_STATE(currElm);
 
-    if (currNode != aNode && !aComparer->equal(currElm)) {
+    if (currNode != aNode && !aComparer->Equal(currElm)) {
       PRInt32 startHTOffset = 0;
       nsCOMPtr<nsIAccessible> startAcc;
       nsresult rv = DOMPointToHypertextOffset(tmpNode, -1, &startHTOffset,
                                               getter_AddRefs(startAcc));
       NS_ENSURE_SUCCESS(rv, rv);
@@ -2362,11 +2417,11 @@ nsHyperTextAccessible::GetRangeForTextAt
     nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(currNode));
     NS_ENSURE_STATE(currElm);
 
     // Stop new end offset searching if the given text attribute changes its
     // value.
-    if (!aComparer->equal(currElm)) {
+    if (!aComparer->Equal(currElm)) {
       PRInt32 endHTOffset = 0;
       nsresult rv = DOMPointToHypertextOffset(currNode, -1, &endHTOffset);
       NS_ENSURE_SUCCESS(rv, rv);
 
       if (endHTOffset < *aEndHTOffset)
@@ -2408,11 +2463,11 @@ nsHyperTextAccessible::FindEndOffsetInSu
   nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(aCurrNode));
   NS_ENSURE_STATE(currElm);
 
   // If the given text attribute (pointed by nsTextAttr object) changes its
   // value on the traversed element then fit the end of range.
-  if (!aComparer->equal(currElm)) {
+  if (!aComparer->Equal(currElm)) {
     PRInt32 endHTOffset = 0;
     nsresult rv = DOMPointToHypertextOffset(aCurrNode, -1, &endHTOffset);
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (endHTOffset < *aHTOffset)
@@ -2459,11 +2514,11 @@ nsHyperTextAccessible::FindStartOffsetIn
   nsCOMPtr<nsIDOMElement> currElm(nsAccUtils::GetDOMElementFor(aCurrNode));
   NS_ENSURE_STATE(currElm);
 
   // If the given text attribute (pointed by nsTextAttr object) changes its
   // value on the traversed element then fit the start of range.
-  if (!aComparer->equal(currElm)) {
+  if (!aComparer->Equal(currElm)) {
     PRInt32 startHTOffset = 0;
     nsCOMPtr<nsIAccessible> startAcc;
     nsresult rv = DOMPointToHypertextOffset(aPrevNode, -1, &startHTOffset,
                                             getter_AddRefs(startAcc));
     NS_ENSURE_SUCCESS(rv, rv);
diff -r 6de576aeff11 accessible/src/msaa/nsAccessNodeWrap.cpp
--- a/accessible/src/msaa/nsAccessNodeWrap.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/msaa/nsAccessNodeWrap.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -593,11 +593,11 @@ void nsAccessNodeWrap::InitAccessibility
   if (prefBranch) {
     prefBranch->GetBoolPref("accessibility.disableenumvariant", &gIsEnumVariantSupportDisabled);
   }
 
   if (!gmUserLib) {
-    gmUserLib =::LoadLibrary("USER32.DLL");
+    gmUserLib =::LoadLibraryW(L"USER32.DLL");
   }
 
   if (gmUserLib) {
     if (!gmNotifyWinEvent)
       gmNotifyWinEvent = (LPFNNOTIFYWINEVENT)GetProcAddress(gmUserLib,"NotifyWinEvent");
diff -r 6de576aeff11 accessible/src/msaa/nsAccessibleWrap.cpp
--- a/accessible/src/msaa/nsAccessibleWrap.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/src/msaa/nsAccessibleWrap.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -156,11 +156,11 @@ STDMETHODIMP nsAccessibleWrap::Accessibl
                                                           REFIID riid,
                                                           void **ppvObject)
 {
   // open the dll dynamically
   if (!gmAccLib)
-    gmAccLib =::LoadLibrary("OLEACC.DLL");
+    gmAccLib =::LoadLibraryW(L"OLEACC.DLL");
 
   if (gmAccLib) {
     if (!gmAccessibleObjectFromWindow)
       gmAccessibleObjectFromWindow = (LPFNACCESSIBLEOBJECTFROMWINDOW)GetProcAddress(gmAccLib,"AccessibleObjectFromWindow");
 
diff -r 6de576aeff11 accessible/tests/mochitest/Makefile.in
--- a/accessible/tests/mochitest/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/tests/mochitest/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -46,13 +46,15 @@ include $(topsrcdir)/config/rules.mk
 include $(topsrcdir)/config/rules.mk
 
 _TEST_FILES =\
 		moz.png \
 		longdesc_src.html \
+		common.js \
 		nsIAccessible_actions.js \
 		nsIAccessible_name.css \
 		nsIAccessible_name.xbl \
+		nsIAccessibleEditableText.js \
 		test_aria_activedescendant.html \
 		test_aria_role_article.html \
 		test_bug368835.xul \
 		test_bug420863.html \
 		test_cssattrs.html \
@@ -60,20 +62,21 @@ _TEST_FILES =\
 	$(warning test_table_indexes.html temporarily disabled) \
 		test_nsIAccessible_actions.html \
 		test_nsIAccessible_actions.xul \
 		test_nsIAccessible_name.html \
 		test_nsIAccessible_name.xul \
+		test_nsIAccessibleDocument.html \
+		test_nsIAccessibleEditableText.html \
+		test_nsIAccessibleHyperLink.html \
+		test_nsIAccessibleHyperLink.xul \
+		test_nsIAccessibleHyperText.html \
+		test_nsIAccessibleImage.html \
 		test_nsIAccessibleTable_1.html \
 		test_nsIAccessibleTable_2.html \
 		test_nsIAccessibleTable_3.html \
 		test_nsIAccessibleTable_4.html \
 		test_nsIAccessibleTable_listboxes.xul \
-		test_nsIAccessibleDocument.html \
-		test_nsIAccessibleHyperLink.html \
-		test_nsIAccessibleHyperLink.xul \
-		test_nsIAccessibleHyperText.html \
-		test_nsIAccessibleImage.html \
 		test_nsOuterDocAccessible.html \
 		test_textattrs.html \
 		test_textboxes.html \
 		test_textboxes.xul \
 		testTextboxes.js \
diff -r 6de576aeff11 accessible/tests/mochitest/common.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/tests/mochitest/common.js	Thu Aug 28 21:06:41 2008 +0300
@@ -0,0 +1,118 @@
+////////////////////////////////////////////////////////////////////////////////
+// Interfaces
+
+const nsIAccessibleRetrieval = Components.interfaces.nsIAccessibleRetrieval;
+
+const nsIAccessibleEvent = Components.interfaces.nsIAccessibleEvent;
+const nsIAccessibleStates = Components.interfaces.nsIAccessibleStates;
+const nsIAccessibleRole = Components.interfaces.nsIAccessibleRole;
+const nsIAccessibleTypes = Components.interfaces.nsIAccessibleTypes;
+
+const nsIAccessibleRelation = Components.interfaces.nsIAccessibleRelation;
+
+const nsIAccessNode = Components.interfaces.nsIAccessNode;
+const nsIAccessible = Components.interfaces.nsIAccessible;
+
+const nsIAccessibleDocument = Components.interfaces.nsIAccessibleDocument;
+
+const nsIAccessibleText = Components.interfaces.nsIAccessibleText;
+const nsIAccessibleEditableText = Components.interfaces.nsIAccessibleEditableText;
+
+const nsIAccessibleHyperLink = Components.interfaces.nsIAccessibleHyperLink;
+const nsIAccessibleHyperText = Components.interfaces.nsIAccessibleHyperText;
+
+const nsIAccessibleImage = Components.interfaces.nsIAccessibleImage;
+const nsIAccessibleSelectable = Components.interfaces.nsIAccessibleSelectable;
+const nsIAccessibleTable = Components.interfaces.nsIAccessibleTable;
+const nsIAccessibleValue = Components.interfaces.nsIAccessibleValue;
+
+const nsIObserverService = Components.interfaces.nsIObserverService;
+
+const nsIDOMNode = Components.interfaces.nsIDOMNode;
+
+////////////////////////////////////////////////////////////////////////////////
+// General
+
+/**
+ * nsIAccessibleRetrieval, initialized when test is loaded.
+ */
+var gAccRetrieval = null;
+
+/**
+ * Return accessible for the given ID attribute or DOM element.
+ *
+ * @param aElmOrID     [in] the ID attribute or DOM element to get an accessible
+ *                     for
+ * @param aInterfaces  [in, optional] the accessible interface or the array of
+ *                     accessible interfaces to query it/them from obtained
+ *                     accessible
+ * @param aElmObj      [out, optional] object to store DOM element which
+ *                     accessible is created for
+ */
+function getAccessible(aElmOrID, aInterfaces, aElmObj)
+{
+  var elm = null;
+
+  if (aElmOrID instanceof nsIDOMNode) {
+    elm = aElmOrID;
+  } else {
+    var elm = document.getElementById(aElmOrID);
+    if (!elm) {
+      ok(false, "Can't get DOM element for " + aID);
+      return null;
+    }
+  }
+
+  if (aElmObj && (typeof aElmObj == "object"))
+    aElmObj.value = elm;
+
+  var acc = null;
+  try {
+    acc = gAccRetrieval.getAccessibleFor(elm);
+  } catch (e) {
+  }
+  
+  if (!acc) {
+    ok(false, "Can't get accessible for " + aID);
+    return null;
+  }
+  
+  if (!aInterfaces)
+    return acc;
+  
+  if (aInterfaces instanceof Array) {
+    for (var index = 0; index < aInterfaces.length; index++) {
+      try {
+        acc.QueryInterface(aInterfaces[index]);
+      } catch (e) {
+        ok(false, "Can't query " + aInterfaces[index] + " for " + aID);
+        return null;
+      }
+    }
+    return acc;
+  }
+  
+  try {
+    acc.QueryInterface(aInterfaces);
+  } catch (e) {
+    ok(false, "Can't query " + aInterfaces + " for " + aID);
+    return null;
+  }
+  
+  return acc;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// Private
+////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////
+// General
+
+function initialize()
+{
+  gAccRetrieval = Components.classes["@mozilla.org/accessibleRetrieval;1"].
+  getService(nsIAccessibleRetrieval);
+}
+
+addLoadEvent(initialize);
diff -r 6de576aeff11 accessible/tests/mochitest/nsIAccessibleEditableText.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/tests/mochitest/nsIAccessibleEditableText.js	Thu Aug 28 21:06:41 2008 +0300
@@ -0,0 +1,105 @@
+function nsEditableText(aElmOrID)
+{
+  this.setTextContents = function setTextContents(aStr)
+  {
+    try {
+      this.mAcc.setTextContents(aStr);
+      
+      is(this.getValue(), aStr,
+         "setTextContents: Can't set " + aStr +
+         " to element with ID '" + this.mID + "'");
+    } catch (e) {
+      ok(false,
+         "setTextContents: Can't set " + aStr +
+         "to element with ID '" + this.mID +
+         "', value '" + this.getValue() + "', exception" + e);
+    }
+  }
+  
+  this.insertText = function insertText(aStr, aPos, aResStr)
+  {
+    try {
+      this.mAcc.insertText(aStr, aPos);
+      
+      is(this.getValue(), aResStr,
+         "insertText: Can't insert " + aStr + " at " + aPos +
+         " to element with ID '" + this.mID + "'");
+    } catch (e) {
+      ok(false,
+         "insertText: Can't insert " + aStr + " at " + aPos +
+         " to element with ID '" + this.mID +
+         "', value '" + this.getValue() + "', exception " + e);
+    }
+  }
+  
+  this.copyNPasteText = function copyNPasteText(aStartPos, aEndPos,
+                                                aPos, aResStr)
+  {
+    try {
+      this.mAcc.copyText(aStartPos, aEndPos);
+      this.mAcc.pasteText(aPos);
+      
+      is(this.getValue(), aResStr,
+         "copyText & pasteText: Can't copy text from " + aStartPos +
+         " to " + aEndPos + " and paste to " + aPos +
+         " for element with ID '" + this.mID + "'");
+    } catch (e) {
+      ok(false,
+         "copyText & pasteText: Can't copy text from " + aStartPos +
+         " to " + aEndPos + " and paste to " + aPos +
+         " for element with ID '" + this.mID +
+         "', value '" + this.getValue() + "', exception " + e);
+    }
+  }
+  
+  this.cutNPasteText = function copyNPasteText(aStartPos, aEndPos,
+                                               aPos, aResStr)
+  {
+    try {
+      this.mAcc.cutText(aStartPos, aEndPos);
+      this.mAcc.pasteText(aPos);
+      
+      is(this.getValue(), aResStr,
+         "cutText & pasteText: Can't cut text from " + aStartPos +
+         " to " + aEndPos + " and paste to " + aPos +
+         " for element with ID '" + this.mID + "'");
+    } catch (e) {
+      ok(false,
+         "cutText & pasteText: Can't cut text from " + aStartPos +
+         " to " + aEndPos + " and paste to " + aPos +
+         " for element with ID '" + this.mID +
+         "', value '" + this.getValue() + "', exception " + e);
+    }
+  }
+  
+  this.deleteText = function deleteText(aStartPos, aEndPos, aResStr)
+  {
+    try {
+      this.mAcc.deleteText(aStartPos, aEndPos);
+      
+      is(this.getValue(), aResStr,
+         "deleteText: Can't delete text from " + aStartPos +
+         " to " + aEndPos + " for element with ID '" + this.mID + "'");
+    } catch (e) {
+      ok(false,
+         "deleteText: Can't delete text from " + aStartPos +
+         " to " + aEndPos + " for element with ID '" + this.mID +
+         "', value " + this.getValue() + ", exception " + e);
+    }
+  }
+
+  this.getValue = function getValue()
+  {
+    if (this.mElm instanceof Components.interfaces.nsIDOMNSEditableElement)
+      return this.mElm.value;
+    if (this.mElm instanceof Components.interfaces.nsIDOMHTMLDocument)
+      return this.mElm.body.textContent;
+    return this.mElm.textContent;
+  }
+
+  var elmObj = { value: null };
+  this.mAcc = getAccessible(aElmOrID, nsIAccessibleEditableText, elmObj);
+
+  this.mElm = elmObj.value;
+  this.mID = aElmOrID;
+}
diff -r 6de576aeff11 accessible/tests/mochitest/test_nsIAccessibleEditableText.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/accessible/tests/mochitest/test_nsIAccessibleEditableText.html	Thu Aug 28 21:06:41 2008 +0300
@@ -0,0 +1,95 @@
+<!DOCTYPE html>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=452161
+-->
+<head>
+  <title>nsIAccessibleEditableText chrome tests</title>
+  <link rel="stylesheet" type="text/css" href="chrome://mochikit/content/tests/SimpleTest/test.css" />
+
+  <script type="application/javascript"
+          src="chrome://mochikit/content/MochiKit/packed.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/common.js"></script>
+  <script type="application/javascript"
+          src="chrome://mochikit/content/a11y/accessible/nsIAccessibleEditableText.js"></script>
+
+  <script type="application/javascript">
+    var gParagraphAcc;
+
+    function testEditable(aID)
+    {
+      var et = new nsEditableText(aID);
+
+      //////////////////////////////////////////////////////////////////////////
+      // insertText
+      et.insertText("hello", 0, "hello");
+      et.insertText("ma ", 0, "ma hello");
+      et.insertText("ma", 2, "mama hello");
+      et.insertText(" hello", 10, "mama hello hello");
+
+      // XXX: bug 452584
+
+      //////////////////////////////////////////////////////////////////////////
+      // setTextContents
+//      et.setTextContents("hello", "hello");
+//      et.setTextContents("olleh", "olleh");
+//      et.setTextContents("", "");
+
+      //////////////////////////////////////////////////////////////////////////
+      // deleteText
+//      et.deleteText(0, 5, "hello hello");
+//      et.deleteText(5, 6, "hellohello");
+//      et.deleteText(5, 10, "hello");
+//      et.deleteText(0, 5, "");
+
+      //////////////////////////////////////////////////////////////////////////
+      // copyNPasteText
+//      et.copyNPasteText(0, 0, 0, "");
+//      et.insertText("hello", 0, "hello");
+//      et.copyNPasteText(0, 1, 0, "hhello");
+//      et.copyNPasteText(5, 6, 6, "hhelloo");
+//      et.copyNPasteText(3, 4, 1, "hehelloo");
+
+      //////////////////////////////////////////////////////////////////////////
+//      // cutNPasteText
+//      et.cutNPasteText(0, 1, 1, "ehhelloo");
+//      et.cutNPasteText(1, 2, 0, "hehelloo");
+//      et.cutNPasteText(7, 8, 8, "hehelloo");
+    }
+
+    function doTest()
+    {
+      testEditable("input");
+      // testEditable("div"); XXX: bug 452599
+
+      var frame = document.getElementById("frame");
+      frame.contentDocument.designMode = "on";
+      testEditable(frame.contentDocument);
+      
+      SimpleTest.finish();
+    }
+
+    SimpleTest.waitForExplicitFinish();
+    addLoadEvent(doTest);
+  </script>
+</head>
+<body>
+
+  <a target="_blank"
+     title="nsIAccessibleEditableText chrome tests"
+     href="https://bugzilla.mozilla.org/show_bug.cgi?id=452161">Mozilla Bug 452161</a>
+  <p id="display"></p>
+  <div id="content" style="display: none"></div>
+  <pre id="test">
+  </pre>
+
+  <input id="input"/>
+
+  <div id="div" contentEditable="true"/>
+
+  <iframe id="frame"/>
+</body>
+</html>
diff -r 6de576aeff11 accessible/tests/mochitest/test_textattrs.html
--- a/accessible/tests/mochitest/test_textattrs.html	Wed Aug 27 08:11:51 2008 -0400
+++ b/accessible/tests/mochitest/test_textattrs.html	Thu Aug 28 21:06:41 2008 +0300
@@ -26,33 +26,17 @@
      *                          text attributes
      * @param aAttrs            the map of text attributes (name/value pairs)
      * @param aStartOffset      the start offset where text attributes are
      *                          applied
      * @param aEndOffset        the end offset where text attribute are applied
-     * @param aDefAttrs         the list of default text attributes (name/value
-     *                          pairs)
      */
     function testTextAttrs(aID, aOffset,
-                           aAttrs, aStartOffset, aEndOffset, aDefAttrs)
+                           aAttrs, aStartOffset, aEndOffset)
     {
-      var node = document.getElementById(aID);
-      if (!node) {
-        ok(false, "Can't get the element with ID " + aID);
+      var accessible = getTextAccessible(aID);
+      if (!accessible)
         return;
-      }
-
-      var accessible = null;
-      try {
-        accessible = gAccRetrieval.getAccessibleFor(node);
-        accessible.QueryInterface(nsIAccessibleText);
-      } catch (e) {
-      }
-
-      if (!accessible) {
-        ok(false, "Can't query nsIAccessibleText interface for " + aID);
-        return;
-      }
 
       var startOffset = { value: -1 };
       var endOffset = { value: -1 };
       var attrs = null;
       try {
@@ -72,10 +56,24 @@
          "Wrong start offset" + errorMsg);
       is(endOffset.value, aEndOffset,
           "Wrong end offset" + errorMsg);
 
       compareTextAttrs(errorMsg, attrs, aAttrs);
+   }
+
+   /**
+    * Test default text attributes.
+    *
+    * @param aID               the ID of DOM element having text accessible
+    * @param aDefAttrs         the list of default text attributes (name/value
+    *                          pairs)
+    */
+   function testDefaultTextAttrs(aID, aDefAttrs)
+   {
+     var accessible = getTextAccessible(aID);
+     if (!accessible)
+       return;
 
       var defAttrs = null;
       try{
         defAttrs = accessible.defaultTextAttributes;
       } catch (e) {
@@ -84,11 +82,33 @@
       if (!defAttrs) {
         ok(false, "Can't get default attributes for " + aID);
         return;
       }
 
+      var errorMsg = ". Getting default attributes for " + aID;
       compareTextAttrs(errorMsg, defAttrs, aDefAttrs);
+    }
+
+    function getTextAccessible(aID)
+    {
+      var node = document.getElementById(aID);
+      if (!node) {
+        ok(false, "Can't get the element with ID " + aID);
+        return;
+      }
+
+      var accessible = null;
+      try {
+        accessible = gAccRetrieval.getAccessibleFor(node);
+        accessible.QueryInterface(nsIAccessibleText);
+      } catch (e) {
+      }
+
+      if (!accessible)
+        ok(false, "Can't query nsIAccessibleText interface for " + aID);
+
+      return accessible;
     }
 
     function compareTextAttrs(aErrorMsg, aAttrs, aExpectedAttrs)
     {
       var enumerate = aAttrs.enumerate();
@@ -96,11 +116,11 @@
         var prop = enumerate.getNext().
           QueryInterface(Components.interfaces.nsIPropertyElement);
 
         if (!(prop.key in aExpectedAttrs))
           ok(false,
-             "Unexpected attribute '" + prop.key + "' " + aErrorMsg);
+             "Unexpected attribute '" + prop.key + "' having '" + prop.value + "'" + aErrorMsg);
         else
           is(prop.value, aExpectedAttrs[prop.key],
              "Attribute '" + prop.key + " 'has wrong value" + aErrorMsg);
       }
 
@@ -165,21 +185,21 @@
             "text-indent": "0px",
             "color": "rgb(0, 0, 0)",
             "font-family": "Lucida Grande",
             "text-position": "baseline"
           };
+          testDefaultTextAttrs(ID, defAttrs);
 
-          var attrs = { "background-color": "transparent" };
+          var attrs = { };
           var misspelledAttrs = {
-            "background-color": "transparent",
             "invalid": "spelling"
           };
 
-          testTextAttrs(ID, 0, attrs, 0, 11, defAttrs);
-          testTextAttrs(ID, 11, misspelledAttrs, 11, 17, defAttrs);
-          testTextAttrs(ID, 17, attrs, 17, 18, defAttrs);
-          testTextAttrs(ID, 18, misspelledAttrs, 18, 22, defAttrs);
+          testTextAttrs(ID, 0, attrs, 0, 11);
+          testTextAttrs(ID, 11, misspelledAttrs, 11, 17);
+          testTextAttrs(ID, 17, attrs, 17, 18);
+          testTextAttrs(ID, 18, misspelledAttrs, 18, 22);
 
           is(gA11yEventObserver.mTextAttrChangedEventCounter, 2,
              "Wrong count of 'text attribute changed' events for " + ID);
 
           // Remove a11y events listener
@@ -200,215 +220,232 @@
       var ID = "area1";
       var defAttrs = {
         "font-style": "normal",
         "text-align": "start",
         "font-size": "16px",
-        "background-color": "transparent",
+        "background-color": "rgb(255, 255, 255)",
         "font-weight": "400",
         "text-indent": "0px",
         "color": "rgb(0, 0, 0)",
         "font-family": "serif",
         "text-position": "baseline"
       };
 
+      testDefaultTextAttrs(ID, defAttrs);
+
       var attrs = {};
-      testTextAttrs(ID, 0, attrs, 0, 7, defAttrs);
+      testTextAttrs(ID, 0, attrs, 0, 7);
 
       attrs = {"font-weight": "401"};
-      testTextAttrs(ID, 7, attrs, 7, 11, defAttrs);
+      testTextAttrs(ID, 7, attrs, 7, 11);
 
       attrs = {};
-      testTextAttrs(ID, 12, attrs, 11, 18, defAttrs);
+      testTextAttrs(ID, 12, attrs, 11, 18);
 
       //////////////////////////////////////////////////////////////////////////
       // area2
       ID = "area2";
       defAttrs = {
         "font-style": "normal",
         "text-align": "start",
         "font-size": "16px",
-        "background-color": "transparent",
+        "background-color": "rgb(255, 255, 255)",
         "font-weight": "400",
         "text-indent": "0px",
         "color": "rgb(0, 0, 0)",
         "font-family": "serif",
         "text-position": "baseline"
       };
 
+      testDefaultTextAttrs(ID, defAttrs);
+
       attrs = {};
-      testTextAttrs(ID, 0, attrs, 0, 7, defAttrs);
+      testTextAttrs(ID, 0, attrs, 0, 7);
 
       attrs = {"font-weight": "401"};
-      testTextAttrs(ID, 7, attrs, 7, 12, defAttrs);
+      testTextAttrs(ID, 7, attrs, 7, 12);
 
       attrs = {"font-style": "italic", "font-weight": "401"};
-      testTextAttrs(ID, 13, attrs, 12, 19, defAttrs);
+      testTextAttrs(ID, 13, attrs, 12, 19);
 
       attrs = {"font-weight": "401"};
-      testTextAttrs(ID, 20, attrs, 19, 23, defAttrs);
+      testTextAttrs(ID, 20, attrs, 19, 23);
 
       attrs = {};
-      testTextAttrs(ID, 24, attrs, 23, 30, defAttrs);
+      testTextAttrs(ID, 24, attrs, 23, 30);
 
       //////////////////////////////////////////////////////////////////////////
       // area3
       ID = "area3";
       defAttrs = {
         "font-style": "normal",
         "text-align": "start",
         "font-size": "16px",
-        "background-color": "transparent",
+        "background-color": "rgb(0, 0, 255)",
         "font-weight": "400",
         "text-indent": "0px",
         "color": "rgb(0, 0, 0)",
         "font-family": "serif",
         "text-position": "baseline"
       };
 
+      testDefaultTextAttrs(ID, defAttrs);
+
       attrs = {"color": "rgb(0, 128, 0)"};
-      testTextAttrs(ID, 0, attrs, 0, 6, defAttrs);
+      testTextAttrs(ID, 0, attrs, 0, 6);
 
       attrs = {"color": "rgb(255, 0, 0)"};
-      testTextAttrs(ID, 6, attrs, 6, 26, defAttrs);
+      testTextAttrs(ID, 6, attrs, 6, 26);
 
       attrs = {"color": "rgb(0, 128, 0)"};
-      testTextAttrs(ID, 26, attrs, 26, 50, defAttrs);
+      testTextAttrs(ID, 26, attrs, 26, 27);
+
+      attrs = {"color": "rgb(0, 128, 0)", "background-color": "rgb(255, 255, 0)"};
+      testTextAttrs(ID, 27, attrs, 27, 50);
 
       //////////////////////////////////////////////////////////////////////////
       // area4
       ID = "area4";
       defAttrs = {
         "font-style": "normal",
         "text-align": "start",
         "font-size": "16px",
-        "background-color": "transparent",
+        "background-color": "rgb(255, 255, 255)",
         "font-weight": "400",
         "text-indent": "0px",
         "color": "rgb(0, 0, 0)",
         "font-family": "serif",
         "text-position": "baseline"
       };
 
+      testDefaultTextAttrs(ID, defAttrs);
+
       attrs = {"color": "rgb(0, 128, 0)"};
-      testTextAttrs(ID, 0, attrs, 0, 16, defAttrs);
+      testTextAttrs(ID, 0, attrs, 0, 16);
 
       attrs = {"color": "rgb(255, 0, 0)"};
-      testTextAttrs(ID, 16, attrs, 16, 33, defAttrs);
+      testTextAttrs(ID, 16, attrs, 16, 33);
 
       attrs = {"color": "rgb(0, 128, 0)"};
-      testTextAttrs(ID, 34, attrs, 33, 46, defAttrs);
+      testTextAttrs(ID, 34, attrs, 33, 46);
 
       //////////////////////////////////////////////////////////////////////////
       // area5
       ID = "area5";
       defAttrs = {
         "font-style": "normal",
         "text-align": "start",
         "font-size": "16px",
-        "background-color": "transparent",
+        "background-color": "rgb(255, 255, 255)",
         "font-weight": "400",
         "text-indent": "0px",
         "color": "rgb(0, 0, 0)",
         "font-family": "serif",
         "text-position": "baseline"
       };
 
+      testDefaultTextAttrs(ID, defAttrs);
+
       attrs = {"color": "rgb(0, 128, 0)"};
-      testTextAttrs(ID, 0, attrs, 0, 5, defAttrs);
+      testTextAttrs(ID, 0, attrs, 0, 5);
 
       attrs = {};
-      testTextAttrs(ID, 7, attrs, 5, 8, defAttrs);
+      testTextAttrs(ID, 7, attrs, 5, 8);
 
       attrs = {"color": "rgb(255, 0, 0)"};
-      testTextAttrs(ID, 9, attrs, 8, 11, defAttrs);
+      testTextAttrs(ID, 9, attrs, 8, 11);
 
       attrs = {};
-      testTextAttrs(ID, 11, attrs, 11, 18, defAttrs);
+      testTextAttrs(ID, 11, attrs, 11, 18);
 
       //////////////////////////////////////////////////////////////////////////
       // area6 (CSS vertical-align property, bug 445938)
       ID = "area6";
       defAttrs = {
         "font-style": "normal",
         "text-align": "start",
         "font-size": "16px",
-        "background-color": "transparent",
+        "background-color": "rgb(255, 255, 255)",
         "font-weight": "400",
         "text-indent": "0px",
         "color": "rgb(0, 0, 0)",
         "font-family": "serif",
         "text-position": "baseline"
       };
 
+      testDefaultTextAttrs(ID, defAttrs);
+
       attrs = {};
-      testTextAttrs(ID, 0, attrs, 0, 5, defAttrs);
+      testTextAttrs(ID, 0, attrs, 0, 5);
 
       attrs = {"text-position": "super", "font-size": "13px" };
-      testTextAttrs(ID, 5, attrs, 5, 13, defAttrs);
+      testTextAttrs(ID, 5, attrs, 5, 13);
 
       attrs = {};
-      testTextAttrs(ID, 13, attrs, 13, 27, defAttrs);
+      testTextAttrs(ID, 13, attrs, 13, 27);
 
       attrs = {"text-position": "super" };
-      testTextAttrs(ID, 27, attrs, 27, 35, defAttrs);
+      testTextAttrs(ID, 27, attrs, 27, 35);
 
       attrs = {};
-      testTextAttrs(ID, 35, attrs, 35, 39, defAttrs);
+      testTextAttrs(ID, 35, attrs, 35, 39);
 
       attrs = {"text-position": "sub", "font-size": "13px" };
-      testTextAttrs(ID, 39, attrs, 39, 50, defAttrs);
+      testTextAttrs(ID, 39, attrs, 39, 50);
 
       attrs = {};
-      testTextAttrs(ID, 50, attrs, 50, 55, defAttrs);
+      testTextAttrs(ID, 50, attrs, 50, 55);
 
       attrs = {"text-position": "sub" };
-      testTextAttrs(ID, 55, attrs, 55, 64, defAttrs);
+      testTextAttrs(ID, 55, attrs, 55, 64);
 
       //////////////////////////////////////////////////////////////////////////
       // area7
       ID = "area7";
       defAttrs = {
         "font-style": "normal",
         "text-align": "start",
         "font-size": "16px",
-        "background-color": "transparent",
+        "background-color": "rgb(255, 255, 255)",
         "font-weight": "400",
         "text-indent": "0px",
         "color": "rgb(0, 0, 0)",
         "font-family": "serif",
         "text-position": "baseline"
       };
 
+      testDefaultTextAttrs(ID, defAttrs);
+
       attrs = {"language": "ru"};
-      testTextAttrs(ID, 0, attrs, 0, 12, defAttrs);
+      testTextAttrs(ID, 0, attrs, 0, 12);
 
       attrs = {"language": "en"};
-      testTextAttrs(ID, 12, attrs, 12, 13, defAttrs);
+      testTextAttrs(ID, 12, attrs, 12, 13);
 
       attrs = {"language" :"en", "background-color": "rgb(0, 0, 255)"};
-      testTextAttrs(ID, 13, attrs, 13, 26, defAttrs);
+      testTextAttrs(ID, 13, attrs, 13, 26);
 
       attrs = {"language": "en" };
-      testTextAttrs(ID, 26, attrs, 26, 27, defAttrs);
+      testTextAttrs(ID, 26, attrs, 26, 27);
 
       attrs = {"language": "de"};
-      testTextAttrs(ID, 27, attrs, 27, 42, defAttrs);
+      testTextAttrs(ID, 27, attrs, 27, 42);
 
       attrs = {"language": "en"};
-      testTextAttrs(ID, 42, attrs, 42, 43, defAttrs);
+      testTextAttrs(ID, 42, attrs, 42, 43);
 
       attrs = {};
-      testTextAttrs(ID, 43, attrs, 43, 50, defAttrs);
+      testTextAttrs(ID, 43, attrs, 43, 50);
 
       attrs = {"color": "rgb(255, 0, 255)"};
-      testTextAttrs(ID, 50, attrs, 50, 57, defAttrs);
+      testTextAttrs(ID, 50, attrs, 50, 57);
 
       attrs = {"font-weight": "401", "color": "rgb(255, 0, 255)" };
-      testTextAttrs(ID, 57, attrs, 57, 61, defAttrs);
+      testTextAttrs(ID, 57, attrs, 57, 61);
 
       attrs = {"color": "rgb(255, 0, 255)"};
-      testTextAttrs(ID, 61, attrs, 61, 68, defAttrs);
+      testTextAttrs(ID, 61, attrs, 61, 68);
 
       //////////////////////////////////////////////////////////////////////////
       // test spelling text attributes
       testSpellTextAttrs(); // Will call SimpleTest.finish();
     }
@@ -429,15 +466,15 @@
   <pre id="test">
   </pre>
 
   <p id="area1">Normal <b>Bold</b> Normal</p>
   <p id="area2">Normal <b>Bold <i>Italic </i>Bold</b> Normal</p>
-  <p id="area3">
-    <span style="color: green">
+  <p id="area3" style="background-color: blue;">
+    <span style="color: green; background-color: rgb(0, 0, 255)">
       Green
       <span style="color: red">but children are red</span>
-    </span><span style="color: green">
+    </span><span style="color: green; background-color: rgb(255, 255, 0);">
       Another green section.
     </span>
   </p>
   <p id="area4">
     <span style="color: green">
diff -r 6de576aeff11 aclocal.m4
--- a/aclocal.m4	Wed Aug 27 08:11:51 2008 -0400
+++ b/aclocal.m4	Thu Aug 28 21:06:41 2008 +0300
@@ -11,9 +11,12 @@ builtin(include, build/autoconf/nss.m4)d
 builtin(include, build/autoconf/nss.m4)dnl
 builtin(include, build/autoconf/libart.m4)dnl
 builtin(include, build/autoconf/pkg.m4)dnl
 builtin(include, build/autoconf/freetype2.m4)dnl
 builtin(include, build/autoconf/codeset.m4)dnl
-dnl
-define(MOZ_TOPSRCDIR,.)dnl MOZ_TOPSRCDIR is used in altoptions.m4
 builtin(include, build/autoconf/altoptions.m4)dnl
 
+# Read the user's .mozconfig script.  We can't do this in
+# configure.in: autoconf puts the argument parsing code above anything
+# expanded from configure.in, and we need to get the configure options
+# from .mozconfig in place before that argument parsing code.
+MOZ_READ_MOZCONFIG(.)
diff -r 6de576aeff11 browser/app/nsBrowserApp.cpp
--- a/browser/app/nsBrowserApp.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/browser/app/nsBrowserApp.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -62,15 +62,13 @@ static void Output(const char *fmt, ... 
 {
   va_list ap;
   va_start(ap, fmt);
 
 #if defined(XP_WIN) && !MOZ_WINCONSOLE
-  char msg[2048];
-
-  _vsnprintf(msg, sizeof(msg), fmt, ap);
-
-  MessageBox(NULL, msg, "XULRunner", MB_OK | MB_ICONERROR);
+  PRUnichar msg[2048];
+  _vsnwprintf(msg, sizeof(msg)/sizeof(msg[0]), NS_ConvertUTF8toUTF16(fmt).get(), ap);
+  MessageBoxW(NULL, msg, L"XULRunner", MB_OK | MB_ICONERROR);
 #else
   vfprintf(stderr, fmt, ap);
 #endif
 
   va_end(ap);
diff -r 6de576aeff11 browser/components/migration/src/nsIEProfileMigrator.cpp
--- a/browser/components/migration/src/nsIEProfileMigrator.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/browser/components/migration/src/nsIEProfileMigrator.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -865,11 +865,11 @@ nsIEProfileMigrator::CopyPasswords(PRBoo
 {
   HRESULT hr;
   nsresult rv;
   nsVoidArray signonsFound;
 
-  HMODULE pstoreDLL = ::LoadLibrary("pstorec.dll");
+  HMODULE pstoreDLL = ::LoadLibraryW(L"pstorec.dll");
   if (!pstoreDLL) {
     // XXXben TODO
     // Need to figure out what to do here on Windows 98 etc... it may be that the key is universal read
     // and we can just blunder into the registry and use CryptUnprotect to get the data out. 
     return NS_ERROR_FAILURE;
@@ -1189,11 +1189,11 @@ nsresult
 nsresult
 nsIEProfileMigrator::CopyFormData(PRBool aReplace)
 {
   HRESULT hr;
 
-  HMODULE pstoreDLL = ::LoadLibrary("pstorec.dll");
+  HMODULE pstoreDLL = ::LoadLibraryW(L"pstorec.dll");
   if (!pstoreDLL) {
     // XXXben TODO
     // Need to figure out what to do here on Windows 98 etc... it may be that the key is universal read
     // and we can just blunder into the registry and use CryptUnprotect to get the data out. 
     return NS_ERROR_FAILURE;
@@ -1422,24 +1422,23 @@ void
 void 
 nsIEProfileMigrator::ResolveShortcut(const nsString &aFileName, char** aOutURL) 
 {
   HRESULT result;
 
-  IUniformResourceLocator* urlLink = nsnull;
+  IUniformResourceLocatorW* urlLink = nsnull;
   result = ::CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
-                              IID_IUniformResourceLocator, (void**)&urlLink);
+                              IID_IUniformResourceLocatorW, (void**)&urlLink);
   if (SUCCEEDED(result) && urlLink) {
     IPersistFile* urlFile = nsnull;
     result = urlLink->QueryInterface(IID_IPersistFile, (void**)&urlFile);
     if (SUCCEEDED(result) && urlFile) {
       result = urlFile->Load(aFileName.get(), STGM_READ);
       if (SUCCEEDED(result) ) {
-        LPSTR lpTemp = nsnull;
+        LPWSTR lpTemp = nsnull;
         result = urlLink->GetURL(&lpTemp);
         if (SUCCEEDED(result) && lpTemp) {
-          *aOutURL = PL_strdup(lpTemp);
-
+          *aOutURL = (char*)ToNewUTF8String(nsDependentString(lpTemp));
           // free the string that GetURL alloc'd
           ::CoTaskMemFree(lpTemp);
         }
       }
       urlFile->Release();
diff -r 6de576aeff11 browser/locales/Makefile.in
--- a/browser/locales/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/browser/locales/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -317,5 +317,25 @@ endif
 
 ifdef MOZ_CRASHREPORTER
 libs:: $(addprefix $(LOCALE_SRCDIR)/,crashreporter/crashreporter-override.ini)
 	$(SYSINSTALL) $(IFLAGS1) $^ $(FINAL_TARGET)
 endif
+
+# This variable is to allow the wget-en-US target to know which ftp server to download from
+ifndef EN_US_BINARY_URL 
+EN_US_BINARY_URL = $(error You must set EN_US_BINARY_URL)
+endif
+
+# This make target allows us to wget the latest en-US binary from a specified website
+# The make installers-% target needs the en-US binary in dist/
+# and for the windows repackages we need the .installer.exe in dist/sea
+wget-en-US:
+ifndef WGET
+	$(error Wget not installed)
+endif
+	@$(WGET) -nv --output-document $(_ABS_DIST)/$(PACKAGE) $(EN_US_BINARY_URL)/$(PACKAGE)
+	@echo "Downloaded $(EN_US_BINARY_URL)/$(PACKAGE) to $(_ABS_DIST)/$(PACKAGE)"
+ifeq ($(OS_ARCH), WINNT)
+	$(NSINSTALL) -D $(_ABS_DIST)/install/sea
+	@$(WGET) -nv --output-document $(_ABS_DIST)/install/sea/$(PKG_BASENAME).installer.exe $(EN_US_BINARY_URL)/$(PKG_BASENAME).installer.exe
+	@echo "Downloaded $(EN_US_BINARY_URL)/$(PKG_BASENAME).installer.exe to $(_ABS_DIST)/install/sea/$(PKG_BASENAME)"
+endif
diff -r 6de576aeff11 build/autoconf/altoptions.m4
--- a/build/autoconf/altoptions.m4	Wed Aug 27 08:11:51 2008 -0400
+++ b/build/autoconf/altoptions.m4	Thu Aug 28 21:06:41 2008 +0300
@@ -150,8 +150,5 @@ AC_DEFUN([MOZ_READ_MOZCONFIG],
 [AC_REQUIRE([AC_INIT_BINSH])dnl
 # Read in '.mozconfig' script to set the initial options.
 # See the mozconfig2configure script for more details.
 _AUTOCONF_TOOLS_DIR=`dirname [$]0`/[$1]/build/autoconf
 . $_AUTOCONF_TOOLS_DIR/mozconfig2configure])
-
-dnl This gets inserted at the top of the configure script
-MOZ_READ_MOZCONFIG(MOZ_TOPSRCDIR)
diff -r 6de576aeff11 build/package/mac_osx/installdmg.ex
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/build/package/mac_osx/installdmg.ex	Thu Aug 28 21:06:41 2008 +0300
@@ -0,0 +1,44 @@
+#!/usr/bin/expect
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Corporation Code.
+#
+# The Initial Developer of the Original Code is
+# Clint Talbert.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Armen Zambrano Gasparnian <armenzg@mozilla.com>
+#  Axel Hecht <l10n@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+spawn hdiutil attach -readonly -mountroot /tmp -private -noautoopen $argv
+expect {
+"byte" {send "G"; exp_continue}
+"END" {send "\r"; exp_continue}
+"Y/N?" {send "Y\r"; exp_continue}
+}
diff -r 6de576aeff11 caps/src/Makefile.in
--- a/caps/src/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/caps/src/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -71,10 +71,11 @@ REQUIRES	= xpcom \
 
 CPPSRCS		= \
 		nsPrincipal.cpp \
 		nsSystemPrincipal.cpp \
 		nsNullPrincipal.cpp \
+		nsNullPrincipalURI.cpp \
 		nsJSPrincipals.cpp \
 		nsScriptSecurityManager.cpp \
 		nsSecurityManagerFactory.cpp \
 		$(NULL)
 
diff -r 6de576aeff11 caps/src/nsNullPrincipal.cpp
--- a/caps/src/nsNullPrincipal.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/caps/src/nsNullPrincipal.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -41,20 +41,19 @@
  * anything other than itself and chrome; null principals are not
  * same-origin with anything but themselves.
  */
 
 #include "nsNullPrincipal.h"
+#include "nsNullPrincipalURI.h"
 #include "nsMemory.h"
 #include "nsIUUIDGenerator.h"
 #include "nsID.h"
 #include "nsNetUtil.h"
 #include "nsIClassInfoImpl.h"
 #include "nsNetCID.h"
 #include "nsDOMError.h"
 #include "nsScriptSecurityManager.h"
-
-static NS_DEFINE_CID(kSimpleURICID, NS_SIMPLEURI_CID);
 
 NS_IMPL_QUERY_INTERFACE2_CI(nsNullPrincipal,
                             nsIPrincipal,
                             nsISerializable)
 NS_IMPL_CI_INTERFACE_GETTER2(nsNullPrincipal,
@@ -117,26 +116,18 @@ nsNullPrincipal::Init()
   nsCString str;
   str.SetCapacity(prefixLen + suffixLen);
 
   str.Append(NS_NULLPRINCIPAL_PREFIX);
   str.Append(chars);
-  
+
   if (str.Length() != prefixLen + suffixLen) {
     NS_WARNING("Out of memory allocating null-principal URI");
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
-  // Use CID so we're sure we get the impl we want.  Note that creating the URI
-  // directly is ok because we have our own private URI scheme.  In effect,
-  // we're being a protocol handler.
-  mURI = do_CreateInstance(kSimpleURICID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  rv = mURI->SetSpec(str);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  NS_TryToSetImmutable(mURI);
+  mURI = new nsNullPrincipalURI(str);
+  NS_ENSURE_TRUE(mURI, NS_ERROR_OUT_OF_MEMORY);
 
   return mJSPrincipals.Init(this, str);
 }
 
 /**
diff -r 6de576aeff11 caps/src/nsNullPrincipalURI.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/caps/src/nsNullPrincipalURI.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -0,0 +1,262 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is the
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsNullPrincipalURI.h"
+#include "nsNetUtil.h"
+#include "nsEscape.h"
+#include "nsCRT.h"
+
+////////////////////////////////////////////////////////////////////////////////
+//// nsNullPrincipalURI
+
+nsNullPrincipalURI::nsNullPrincipalURI(const nsCString &aSpec)
+{
+  PRInt32 dividerPosition = aSpec.FindChar(':');
+  NS_ASSERTION(dividerPosition != -1, "Malformed URI!");
+
+  PRInt32 n = aSpec.Left(mScheme, dividerPosition);
+  NS_ASSERTION(n == dividerPosition, "Storing the scheme failed!");
+
+  PRInt32 count = aSpec.Length() - dividerPosition - 1;
+  n = aSpec.Mid(mPath, dividerPosition + 1, count);
+  NS_ASSERTION(n == count, "Storing the path failed!");
+
+  ToLowerCase(mScheme);
+}
+
+static NS_DEFINE_CID(kNullPrincipalURIImplementationCID,
+                     NS_NULLPRINCIPALURI_IMPLEMENTATION_CID);
+
+NS_IMPL_THREADSAFE_ADDREF(nsNullPrincipalURI)
+NS_IMPL_THREADSAFE_RELEASE(nsNullPrincipalURI)
+
+NS_INTERFACE_MAP_BEGIN(nsNullPrincipalURI)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  if (aIID.Equals(kNullPrincipalURIImplementationCID))
+    foundInterface = static_cast<nsIURI *>(this);
+  else
+  NS_INTERFACE_MAP_ENTRY(nsIURI)
+NS_INTERFACE_MAP_END
+
+////////////////////////////////////////////////////////////////////////////////
+//// nsIURI
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetAsciiHost(nsACString &_host)
+{
+  _host.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetAsciiSpec(nsACString &_spec)
+{
+  nsCAutoString buffer;
+  (void)GetSpec(buffer);
+  NS_EscapeURL(buffer, esc_OnlyNonASCII | esc_AlwaysCopy, _spec);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetHost(nsACString &_host)
+{
+  _host.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetHost(const nsACString &aHost)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetHostPort(nsACString &_host)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetHostPort(const nsACString &aHost)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetOriginCharset(nsACString &_charset)
+{
+  _charset.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetPassword(nsACString &_password)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetPassword(const nsACString &aPassword)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetPath(nsACString &_path)
+{
+  // We want to give a full copy of the string and not share a string buffer
+  _path = nsDependentCString(mPath);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetPath(const nsACString &aPath)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetPrePath(nsACString &_prePath)
+{
+  _prePath = mScheme + NS_LITERAL_CSTRING(":");
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetPort(PRInt32 *_port)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetPort(PRInt32 aPort)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetScheme(nsACString &_scheme)
+{
+  // We want to give a full copy of the string and not share a string buffer
+  _scheme = nsDependentCString(mScheme);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetScheme(const nsACString &aScheme)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetSpec(nsACString &_spec)
+{
+  _spec = mScheme + NS_LITERAL_CSTRING(":") + mPath;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetSpec(const nsACString &aSpec)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetUsername(nsACString &_username)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetUsername(const nsACString &aUsername)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::GetUserPass(nsACString &_userPass)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SetUserPass(const nsACString &aUserPass)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::Clone(nsIURI **_newURI)
+{
+  nsCOMPtr<nsIURI> uri =
+    new nsNullPrincipalURI(mScheme + NS_LITERAL_CSTRING(":") + mPath);
+  NS_ENSURE_TRUE(uri, NS_ERROR_OUT_OF_MEMORY);
+  uri.forget(_newURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::Equals(nsIURI *aOther, PRBool *_equals)
+{
+  *_equals = PR_FALSE;
+  nsNullPrincipalURI *otherURI;
+  nsresult rv = aOther->QueryInterface(kNullPrincipalURIImplementationCID,
+                                       (void **)&otherURI);
+  if (NS_SUCCEEDED(rv)) {
+    *_equals = (0 == strcmp(mScheme.get(), otherURI->mScheme.get()) &&
+                0 == strcmp(mPath.get(), otherURI->mPath.get()));
+    NS_RELEASE(otherURI);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::Resolve(const nsACString &aRelativePath,
+                            nsACString &_resolvedURI)
+{
+  _resolvedURI = aRelativePath;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNullPrincipalURI::SchemeIs(const char *aScheme, PRBool *_schemeIs)
+{
+  *_schemeIs = (0 == nsCRT::strcasecmp(mScheme.get(), aScheme));
+  return NS_OK;
+}
diff -r 6de576aeff11 caps/src/nsNullPrincipalURI.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/caps/src/nsNullPrincipalURI.h	Thu Aug 28 21:06:41 2008 +0300
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is the
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This wraps nsSimpleURI so that all calls to it are done on the main thread.
+ */
+
+#ifndef __nsNullPrincipalURI_h__
+#define __nsNullPrincipalURI_h__
+
+#include "nsIURI.h"
+#include "nsAutoPtr.h"
+#include "nsString.h"
+
+// {51fcd543-3b52-41f7-b91b-6b54102236e6}
+#define NS_NULLPRINCIPALURI_IMPLEMENTATION_CID \
+  {0x51fcd543, 0x3b52, 0x41f7, \
+    {0xb9, 0x1b, 0x6b, 0x54, 0x10, 0x22, 0x36, 0xe6} }
+
+class nsNullPrincipalURI : public nsIURI
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIURI
+
+  nsNullPrincipalURI(const nsCString &aSpec);
+
+private:
+  nsCString mScheme;
+  nsCString mPath;
+};
+
+#endif // __nsNullPrincipalURI_h__
diff -r 6de576aeff11 caps/src/nsScriptSecurityManager.cpp
--- a/caps/src/nsScriptSecurityManager.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/caps/src/nsScriptSecurityManager.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -314,122 +314,11 @@ nsScriptSecurityManager::GetSafeJSContex
 /* static */
 PRBool
 nsScriptSecurityManager::SecurityCompareURIs(nsIURI* aSourceURI,
                                              nsIURI* aTargetURI)
 {
-    // Note that this is not an Equals() test on purpose -- for URIs that don't
-    // support host/port, we want equality to basically be object identity, for
-    // security purposes.  Otherwise, for example, two javascript: URIs that
-    // are otherwise unrelated could end up "same origin", which would be
-    // unfortunate.
-    if (aSourceURI && aSourceURI == aTargetURI)
-    {
-        return PR_TRUE;
-    }
-
-    if (!aTargetURI || !aSourceURI) 
-    {
-        return PR_FALSE;
-    }
-
-    // If either URI is a nested URI, get the base URI
-    nsCOMPtr<nsIURI> sourceBaseURI = NS_GetInnermostURI(aSourceURI);
-    nsCOMPtr<nsIURI> targetBaseURI = NS_GetInnermostURI(aTargetURI);
-
-    if (!sourceBaseURI || !targetBaseURI)
-        return PR_FALSE;
-
-    // Compare schemes
-    nsCAutoString targetScheme;
-    PRBool sameScheme = PR_FALSE;
-    if (NS_FAILED( targetBaseURI->GetScheme(targetScheme) ) ||
-        NS_FAILED( sourceBaseURI->SchemeIs(targetScheme.get(), &sameScheme) ) ||
-        !sameScheme)
-    {
-        // Not same-origin if schemes differ
-        return PR_FALSE;
-    }
-
-    // special handling for file: URIs
-    if (targetScheme.EqualsLiteral("file"))
-    {
-        // in traditional unsafe behavior all files are the same origin
-        if (!sStrictFileOriginPolicy)
-            return PR_TRUE;
-
-        nsCOMPtr<nsIFileURL> sourceFileURL(do_QueryInterface(sourceBaseURI));
-        nsCOMPtr<nsIFileURL> targetFileURL(do_QueryInterface(targetBaseURI));
-
-        if (!sourceFileURL || !targetFileURL)
-            return PR_FALSE;
-
-        nsCOMPtr<nsIFile> sourceFile, targetFile;
-
-        sourceFileURL->GetFile(getter_AddRefs(sourceFile));
-        targetFileURL->GetFile(getter_AddRefs(targetFile));
-
-        if (!sourceFile || !targetFile)
-            return PR_FALSE;
-
-        // Otherwise they had better match
-        PRBool filesAreEqual = PR_FALSE;
-        nsresult rv = sourceFile->Equals(targetFile, &filesAreEqual);
-        return NS_SUCCEEDED(rv) && filesAreEqual;
-    }
-
-    // Special handling for mailnews schemes
-    if (targetScheme.EqualsLiteral("imap") ||
-        targetScheme.EqualsLiteral("mailbox") ||
-        targetScheme.EqualsLiteral("news"))
-    {
-        // Each message is a distinct trust domain; use the 
-        // whole spec for comparison
-        nsCAutoString targetSpec;
-        nsCAutoString sourceSpec;
-        return ( NS_SUCCEEDED( targetBaseURI->GetSpec(targetSpec) ) &&
-                 NS_SUCCEEDED( sourceBaseURI->GetSpec(sourceSpec) ) &&
-                 targetSpec.Equals(sourceSpec) );
-    }
-
-    // Compare hosts
-    nsCAutoString targetHost;
-    nsCAutoString sourceHost;
-    if (NS_FAILED( targetBaseURI->GetHost(targetHost) ) ||
-        NS_FAILED( sourceBaseURI->GetHost(sourceHost) ) ||
-        !targetHost.Equals(sourceHost, nsCaseInsensitiveCStringComparator()))
-    {
-        // Not same-origin if hosts differ
-        return PR_FALSE;
-    }
-
-    // Compare ports
-    PRInt32 targetPort;
-    nsresult rv = targetBaseURI->GetPort(&targetPort);
-    PRInt32 sourcePort;
-    if (NS_SUCCEEDED(rv))
-        rv = sourceBaseURI->GetPort(&sourcePort);
-    PRBool result = NS_SUCCEEDED(rv) && targetPort == sourcePort;
-    // If the port comparison failed, see if either URL has a
-    // port of -1. If so, replace -1 with the default port
-    // for that scheme.
-    if (NS_SUCCEEDED(rv) && !result &&
-        (sourcePort == -1 || targetPort == -1))
-    {
-        NS_ENSURE_TRUE(sIOService, PR_FALSE);
-
-        PRInt32 defaultPort = NS_GetDefaultPort(targetScheme.get());
-        if (defaultPort == -1)
-            return PR_FALSE; // No default port for this scheme
-
-        if (sourcePort == -1)
-            sourcePort = defaultPort;
-        else if (targetPort == -1)
-            targetPort = defaultPort;
-        result = targetPort == sourcePort;
-    }
-
-    return result;
+    return NS_SecurityCompareURIs(aSourceURI, aTargetURI, sStrictFileOriginPolicy);
 }
 
 NS_IMETHODIMP
 nsScriptSecurityManager::GetChannelPrincipal(nsIChannel* aChannel,
                                              nsIPrincipal** aPrincipal)
diff -r 6de576aeff11 client.mk
--- a/client.mk	Wed Aug 27 08:11:51 2008 -0400
+++ b/client.mk	Thu Aug 28 21:06:41 2008 +0300
@@ -160,10 +160,11 @@ else
   MOZ_MAKE := $(MAKE) $(MOZ_MAKE_FLAGS)
 endif
 
 endif # MOZ_BUILD_PROJECTS
 
+# 'configure' scripts generated by autoconf.
 CONFIGURES := $(TOPSRCDIR)/configure
 CONFIGURES += $(TOPSRCDIR)/nsprpub/configure
 
 #######################################################################
 # Rules
@@ -272,24 +273,19 @@ EXTRA_CONFIG_DEPS := \
 EXTRA_CONFIG_DEPS := \
 	$(TOPSRCDIR)/aclocal.m4 \
 	$(wildcard $(TOPSRCDIR)/build/autoconf/*.m4) \
 	$(NULL)
 
-$(TOPSRCDIR)/configure: $(TOPSRCDIR)/configure.in $(EXTRA_CONFIG_DEPS)
+$(CONFIGURES): %: %.in $(EXTRA_CONFIG_DEPS)
 	@echo Generating $@ using autoconf
-	cd $(TOPSRCDIR); $(AUTOCONF)
-
-$(TOPSRCDIR)/nsprpub/configure: $(TOPSRCDIR)/nsprpub/configure.in $(EXTRA_CONFIG_DEPS)
-	@echo Generating $@ using autoconf
-	cd $(TOPSRCDIR)/nsprpub; $(AUTOCONF)
+	cd $(@D); $(AUTOCONF)
 endif
 
 CONFIG_STATUS_DEPS := \
-	$(TOPSRCDIR)/configure \
+	$(wildcard $(CONFIGURES)) \
 	$(TOPSRCDIR)/allmakefiles.sh \
 	$(TOPSRCDIR)/.mozconfig.mk \
-	$(wildcard $(TOPSRCDIR)/nsprpub/configure) \
 	$(wildcard $(TOPSRCDIR)/directory/c-sdk/configure) \
 	$(wildcard $(TOPSRCDIR)/config/milestone.txt) \
 	$(wildcard $(TOPSRCDIR)/config/chrome-versions.sh) \
   $(wildcard $(addsuffix confvars.sh,$(wildcard $(TOPSRCDIR)/*/))) \
 	$(NULL)
@@ -305,11 +301,13 @@ endif
 
 ifdef MOZ_TOOLS
   CONFIGURE = $(TOPSRCDIR)/configure
 endif
 
-configure:: $(CONFIGURES)
+configure-files: $(CONFIGURES)
+
+configure:: configure-files
 ifdef MOZ_BUILD_PROJECTS
 	@if test ! -d $(MOZ_OBJDIR); then $(MKDIR) $(MOZ_OBJDIR); else true; fi
 endif
 	@if test ! -d $(OBJDIR); then $(MKDIR) $(OBJDIR); else true; fi
 	@echo cd $(OBJDIR);
diff -r 6de576aeff11 config/autoconf.mk.in
--- a/config/autoconf.mk.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/config/autoconf.mk.in	Thu Aug 28 21:06:41 2008 +0300
@@ -393,10 +393,11 @@ DOXYGEN		= @DOXYGEN@
 DOXYGEN		= @DOXYGEN@
 MAKE		= @MAKE@
 PBBUILD_BIN	= @PBBUILD@
 SDP		= @SDP@
 NSINSTALL_BIN	= @NSINSTALL_BIN@
+WGET		= @WGET@
 
 ifdef MOZ_NATIVE_JPEG
 JPEG_CFLAGS	= @JPEG_CFLAGS@
 JPEG_LIBS	= @JPEG_LIBS@
 JPEG_REQUIRES	=
diff -r 6de576aeff11 config/rules.mk
--- a/config/rules.mk	Wed Aug 27 08:11:51 2008 -0400
+++ b/config/rules.mk	Thu Aug 28 21:06:41 2008 +0300
@@ -1131,11 +1131,11 @@ ifdef IS_COMPONENT
 	@if test ! -f $(VMS_SYMVEC_FILE); then \
 	  echo Creating generic component options file $(VMS_SYMVEC_FILE); \
 	  cp $(VMS_SYMVEC_FILE_COMP) $(VMS_SYMVEC_FILE); \
 	fi
 endif
-endif
+endif # OpenVMS
 ifdef NO_LD_ARCHIVE_FLAGS
 ifdef SHARED_LIBRARY_LIBS
 	@rm -f $(SUB_SHLOBJS)
 	@for lib in $(SHARED_LIBRARY_LIBS); do $(AR_EXTRACT) $${lib}; $(CLEANUP2); done
 ifeq ($(OS_ARCH),Darwin)
@@ -1169,11 +1169,11 @@ endif
 	@for lib in $(MOZILLA_PROBE_LIBS); do \
 		if [ -L $${lib} ]; then rm -f `readlink $${lib}`; fi; \
 	done
 	@rm -f $(MOZILLA_PROBE_LIBS)
 
-else
+else # ! DTRACE_LIB_DEPENDENT
 	$(MKSHLIB) $(SHLIB_LDSTARTFILE) $(OBJS) $(DTRACE_PROBE_OBJ) $(LOBJS) $(SUB_SHLOBJS) $(RESFILE) $(LDFLAGS) $(EXTRA_DSO_LDOPTS) $(OS_LIBS) $(EXTRA_LIBS) $(DEF_FILE) $(SHLIB_LDENDFILE)
 endif # DTRACE_LIB_DEPENDENT
 
 ifeq (_WINNT,$(GNU_CC)_$(OS_ARCH))
 ifdef MSMANIFEST_TOOL
diff -r 6de576aeff11 configure.in
--- a/configure.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/configure.in	Thu Aug 28 21:06:41 2008 +0300
@@ -1372,10 +1372,28 @@ if test "$GNU_CXX"; then
        esac
     fi
 
     _DEFINES_CXXFLAGS='-DMOZILLA_CLIENT -include $(DEPTH)/mozilla-config.h'
     _USE_CPP_INCLUDE_FLAG=1
+
+    AC_CACHE_CHECK(whether the compiler supports -Wno-invalid-offsetof,
+                   ac_has_wno_invalid_offsetof,
+        [
+            AC_LANG_SAVE
+            AC_LANG_CPLUSPLUS
+            _SAVE_CXXFLAGS="$CXXFLAGS"
+            CXXFLAGS="$CXXFLAGS ${_COMPILER_PREFIX}-Wno-invalid-offsetof"
+            AC_TRY_COMPILE([],
+                           [return(0);],
+                           ac_has_wno_invalid_offsetof="yes",
+                           ac_has_wno_invalid_offsetof="no")
+            CXXFLAGS="$_SAVE_CXXFLAGS"
+            AC_LANG_RESTORE
+        ])
+    if test "$ac_has_wno_invalid_offsetof" = "yes"; then
+        _WARNINGS_CXXFLAGS="${_WARNINGS_CXXFLAGS} ${_COMPILER_PREFIX}-Wno-invalid-offsetof"
+    fi
 else
     _DEFINES_CXXFLAGS='-DMOZILLA_CLIENT -D_MOZILLA_CONFIG_H_ $(ACDEFINES)'
 fi
 
 dnl gcc can come with its own linker so it is better to use the pass-thru calls
@@ -1456,11 +1474,10 @@ AC_CACHE_VAL(ac_cv_static_assertion_macr
  ])
 AC_MSG_RESULT("$ac_cv_static_assertion_macros_work")
 if test "$ac_cv_static_assertion_macros_work" = "no"; then
     AC_MSG_ERROR([Compiler cannot compile macros used in autoconf tests.])
 fi
-
 fi # COMPILE_ENVIRONMENT
 
 dnl ========================================================
 dnl Checking for 64-bit OS
 dnl ========================================================
@@ -5777,10 +5794,15 @@ if test -z "$TAR"; then
     AC_MSG_ERROR([no tar archiver found in \$PATH])
 fi
 AC_MSG_RESULT([$TAR])
 AC_SUBST(TAR)
 
+AC_MSG_CHECKING([for wget])
+AC_CHECK_PROGS(WGET, wget, "")
+AC_MSG_RESULT([$WGET])
+AC_SUBST(WGET)
+
 dnl ========================================================
 dnl Updater
 dnl ========================================================
 
 MOZ_ARG_DISABLE_BOOL(updater,
diff -r 6de576aeff11 content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/base/public/nsContentUtils.h	Thu Aug 28 21:06:41 2008 +0300
@@ -1249,10 +1249,15 @@ public:
    * Check whether an application should be allowed to use offline APIs.
    */
   static PRBool OfflineAppAllowed(nsIURI *aURI);
 
   /**
+   * Check whether an application should be allowed to use offline APIs.
+   */
+  static PRBool OfflineAppAllowed(nsIPrincipal *aPrincipal);
+
+  /**
    * Increases the count of blockers preventing scripts from running.
    * NOTE: You might want to use nsAutoScriptBlocker rather than calling
    * this directly
    */
   static void AddScriptBlocker();
diff -r 6de576aeff11 content/base/src/Makefile.in
--- a/content/base/src/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/base/src/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -57,10 +57,11 @@ REQUIRES	= xpcom \
 		  locale \
 		  htmlparser \
 		  js \
 		  webshell \
 		  necko \
+		  nkcache \
 		  mimetype \
 		  exthandler \
 		  chardet \
 		  caps \
 		  lwbrk \
diff -r 6de576aeff11 content/base/src/nsContentSink.cpp
--- a/content/base/src/nsContentSink.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/base/src/nsContentSink.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -71,10 +71,11 @@
 #include "nsIScriptGlobalObject.h"
 #include "nsNetCID.h"
 #include "nsIOfflineCacheUpdate.h"
 #include "nsIApplicationCache.h"
 #include "nsIApplicationCacheContainer.h"
+#include "nsIApplicationCacheService.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIDOMLoadStatus.h"
 #include "nsICookieService.h"
 #include "nsIPrompt.h"
 #include "nsServiceManagerUtils.h"
@@ -94,10 +95,14 @@
 #include "nsIDOMNode.h"
 #include "nsThreadUtils.h"
 #include "nsPresShellIterator.h"
 #include "nsPIDOMWindow.h"
 #include "mozAutoDocUpdate.h"
+#include "nsIWebNavigation.h"
+#include "nsIDocumentLoader.h"
+#include "nsICachingChannel.h"
+#include "nsICacheEntryDescriptor.h"
 
 PRLogModuleInfo* gContentSinkLogModuleInfo;
 
 class nsScriptLoaderObserverProxy : public nsIScriptLoaderObserver
 {
@@ -845,83 +850,308 @@ nsContentSink::PrefetchHref(const nsAStr
       prefetchService->PrefetchURI(uri, mDocumentURI, domNode, aExplicit);
     }
   }
 }
 
+nsresult
+nsContentSink::GetChannelCacheKey(nsIChannel* aChannel, nsACString& aCacheKey)
+{
+  aCacheKey.Truncate();
+
+  nsresult rv;
+  nsCOMPtr<nsICachingChannel> cachingChannel = do_QueryInterface(aChannel, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsISupports> token;
+  rv = cachingChannel->GetCacheToken(getter_AddRefs(token));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsICacheEntryDescriptor> descriptor = do_QueryInterface(token, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = descriptor->GetKey(aCacheKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+nsresult
+nsContentSink::SelectDocAppCache(nsIApplicationCache *aLoadApplicationCache,
+                                 nsIURI *aManifestURI,
+                                 PRBool aIsTopDocument,
+                                 PRBool aFetchedWithHTTPGetOrEquiv,
+                                 CacheSelectionAction *aAction)
+{
+  *aAction = CACHE_SELECTION_NONE;
+
+  nsCOMPtr<nsIApplicationCacheContainer> applicationCacheDocument =
+    do_QueryInterface(mDocument);
+  NS_ASSERTION(applicationCacheDocument,
+               "mDocument must implement nsIApplicationCacheContainer.");
+
+  nsresult rv;
+
+  // We might decide on a new application cache...
+  nsCOMPtr<nsIApplicationCache> applicationCache = aLoadApplicationCache;
+
+  if (applicationCache) {
+    nsCAutoString groupID;
+    rv = applicationCache->GetGroupID(groupID);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIURI> groupURI;
+    rv = NS_NewURI(getter_AddRefs(groupURI), groupID);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    PRBool equal = PR_FALSE;
+    rv = groupURI->Equals(aManifestURI, &equal);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (!equal) {
+      // This is a foreign entry, mark it as such.  If this is a
+      // toplevel load, force a reload to avoid loading the foreign
+      // entry.  The next attempt will not choose this cache entry
+      // (because it has been marked foreign).
+
+      nsCAutoString cachekey;
+      rv = GetChannelCacheKey(mDocument->GetChannel(), cachekey);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = applicationCache->MarkEntry(cachekey,
+                                       nsIApplicationCache::ITEM_FOREIGN);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (aIsTopDocument) {
+        *aAction = CACHE_SELECTION_RELOAD;
+      }
+
+      return NS_OK;
+    }
+
+    if (aIsTopDocument) {
+      // This is a top level document and the http manifest attribute
+      // URI is equal to the manifest URI of the cache the document
+      // was loaded from - associate the document with that cache and
+      // invoke the cache update process.
+      rv = applicationCacheDocument->SetApplicationCache(applicationCache);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      *aAction = CACHE_SELECTION_UPDATE;
+    }
+  }
+  else {
+    // The document was not loaded from an application cache
+    // Here we know the manifest has the same origin as the
+    // document. There is call to CheckMayLoad() on it above.
+
+    if (!aFetchedWithHTTPGetOrEquiv) {
+      // The document was not loaded using HTTP GET or equivalent
+      // method. The spec says to run the cache selection algorithm w/o
+      // the manifest specified but we can just do return NS_OK here.
+
+      return NS_OK;
+    }
+
+    // If there is an existing application cache for this manifest,
+    // associate it with the document.
+    nsCAutoString manifestURISpec;
+    rv = aManifestURI->GetAsciiSpec(manifestURISpec);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIApplicationCacheService> appCacheService =
+      do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
+    if (!appCacheService) {
+      // No application cache service, nothing to do here.
+      return NS_OK;
+    }
+
+    rv = appCacheService->GetActiveCache(manifestURISpec,
+                                         getter_AddRefs(applicationCache));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (applicationCache) {
+      rv = applicationCacheDocument->SetApplicationCache(applicationCache);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+    else {
+      // XXX bug 443023: if there is already a scheduled update or
+      // update in progress we have to add this document as
+      // an implicit entry.
+    }
+
+    // Always do an update in this case
+    *aAction = CACHE_SELECTION_UPDATE;
+  }
+
+  if (applicationCache) {
+    // We are now associated with an application cache.  This item
+    // should be marked as an implicit entry.
+    nsCAutoString cachekey;
+    rv = GetChannelCacheKey(mDocument->GetChannel(), cachekey);
+    if (NS_SUCCEEDED(rv)) {
+      rv = applicationCache->MarkEntry(cachekey,
+                                       nsIApplicationCache::ITEM_IMPLICIT);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsContentSink::SelectDocAppCacheNoManifest(nsIApplicationCache *aLoadApplicationCache,
+                                           PRBool aIsTopDocument,
+                                           nsIURI **aManifestURI,
+                                           CacheSelectionAction *aAction)
+{
+  *aManifestURI = nsnull;
+  *aAction = CACHE_SELECTION_NONE;
+
+  if (!aIsTopDocument || !aLoadApplicationCache) {
+    return NS_OK;
+  }
+
+  nsresult rv;
+
+  // The document was loaded from an application cache, use that
+  // application cache as the document's application cache.
+  nsCOMPtr<nsIApplicationCacheContainer> applicationCacheDocument =
+    do_QueryInterface(mDocument);
+  NS_ASSERTION(applicationCacheDocument,
+               "mDocument must implement nsIApplicationCacheContainer.");
+
+  rv = applicationCacheDocument->SetApplicationCache(aLoadApplicationCache);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Return the uri and invoke the update process for the selected
+  // application cache.
+  nsCAutoString groupID;
+  rv = aLoadApplicationCache->GetGroupID(groupID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = NS_NewURI(aManifestURI, groupID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  *aAction = CACHE_SELECTION_UPDATE;
+
+  return NS_OK;
+}
+
 void
 nsContentSink::ProcessOfflineManifest(nsIContent *aElement)
 {
+  // Only check the manifest for root document nodes.
+  if (aElement != mDocument->GetRootContent()) {
+    return;
+  }
+
+  nsresult rv;
+
   // Check for a manifest= attribute.
   nsAutoString manifestSpec;
   aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::manifest, manifestSpec);
 
-  if (manifestSpec.IsEmpty() ||
-      manifestSpec.FindChar('#') != kNotFound) {
+  // Grab the application cache the document was loaded from, if any.
+  nsCOMPtr<nsIApplicationCache> applicationCache;
+
+  nsCOMPtr<nsIApplicationCacheContainer> applicationCacheChannel =
+    do_QueryInterface(mDocument->GetChannel());
+  if (applicationCacheChannel) {
+    rv = applicationCacheChannel->GetApplicationCache(
+      getter_AddRefs(applicationCache));
+    if (NS_FAILED(rv)) {
+      return;
+    }
+  }
+
+  if (manifestSpec.IsEmpty() && !applicationCache) {
+    // Not loaded from an application cache, and no manifest
+    // attribute.  Nothing to do here.
     return;
   }
 
-  // We only care about manifests in toplevel windows.
-  nsCOMPtr<nsPIDOMWindow> pwindow =
-    do_QueryInterface(mDocument->GetScriptGlobalObject());
-  if (!pwindow) {
+  // The manifest attribute is handled differently if the document is
+  // not toplevel.
+  nsCOMPtr<nsIDOMWindow> window = mDocument->GetWindow();
+  if (!window)
     return;
+  nsCOMPtr<nsIDOMWindow> parent;
+  window->GetParent(getter_AddRefs(parent));
+  PRBool isTop = (parent == window);
+
+  CacheSelectionAction action = CACHE_SELECTION_NONE;
+  nsCOMPtr<nsIURI> manifestURI;
+
+  if (manifestSpec.IsEmpty()) {
+    rv = SelectDocAppCacheNoManifest(applicationCache,
+                                     isTop,
+                                     getter_AddRefs(manifestURI),
+                                     &action);
+    if (NS_FAILED(rv)) {
+      return;
+    }
+  }
+  else {
+    nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(manifestURI),
+                                              manifestSpec, mDocument,
+                                              mDocumentURI);
+    if (!manifestURI) {
+      return;
+    }
+
+    // Documents must list a manifest from the same origin
+    rv = mDocument->NodePrincipal()->CheckMayLoad(manifestURI, PR_TRUE);
+    if (NS_FAILED(rv)) {
+      return;
+    }
+
+    // Only continue if the document has permission to use offline APIs.
+    if (!nsContentUtils::OfflineAppAllowed(mDocument->NodePrincipal())) {
+      return;
+    }
+
+    PRBool fetchedWithHTTPGetOrEquiv = PR_FALSE;
+    nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mDocument->GetChannel()));
+    if (httpChannel) {
+      nsCAutoString method;
+      rv = httpChannel->GetRequestMethod(method);
+      if (NS_SUCCEEDED(rv))
+        fetchedWithHTTPGetOrEquiv = method.Equals("GET");
+    }
+
+    rv = SelectDocAppCache(applicationCache, manifestURI, isTop,
+                           fetchedWithHTTPGetOrEquiv, &action);
+    if (NS_FAILED(rv)) {
+      return;
+    }
   }
 
-  nsCOMPtr<nsIDOMWindow> window =
-    do_QueryInterface(pwindow->GetOuterWindow());
-  if (!window) {
+  switch (action)
+  {
+  case CACHE_SELECTION_NONE:
     return;
+  case CACHE_SELECTION_UPDATE: {
+    nsCOMPtr<nsIOfflineCacheUpdateService> updateService =
+      do_GetService(NS_OFFLINECACHEUPDATESERVICE_CONTRACTID);
+
+    if (updateService) {
+      nsCOMPtr<nsIDOMDocument> domdoc = do_QueryInterface(mDocument);
+      updateService->ScheduleOnDocumentStop(manifestURI, mDocumentURI, domdoc);
+    }
+    break;
   }
+  case CACHE_SELECTION_RELOAD: {
+    // This situation occurs only for toplevel documents, see bottom
+    // of SelectDocAppCache method.
+    NS_ASSERTION(isTop, "Should only reload toplevel documents!");
+    nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(mDocShell);
 
-  nsCOMPtr<nsIDOMWindow> parent;
-  window->GetParent(getter_AddRefs(parent));
-  if (parent.get() != window.get()) {
-    return;
+    webNav->Stop(nsIWebNavigation::STOP_ALL);
+    webNav->Reload(nsIWebNavigation::LOAD_FLAGS_NONE);
+    break;
   }
-
-  // Only update if the document has permission to use offline APIs.
-  if (!nsContentUtils::OfflineAppAllowed(mDocumentURI)) {
-    return;
   }
-
-  // XXX: at this point in the spec there is an algorithm for
-  // confirming whether the cache that was selected at load time was
-  // the proper application cache for this document.  This will
-  // be implemented in a separate patch;  For now just assume that we
-  // chose an acceptable application cache.
-
-  nsCOMPtr<nsIApplicationCacheContainer> channelContainer =
-    do_QueryInterface(mDocument->GetChannel());
-
-  nsCOMPtr<nsIApplicationCacheContainer> docContainer =
-    do_QueryInterface(mDocument);
-
-  if (channelContainer && docContainer) {
-    nsCOMPtr<nsIApplicationCache> appCache;
-    channelContainer->GetApplicationCache(getter_AddRefs(appCache));
-    docContainer->SetApplicationCache(appCache);
-  }
-
-  nsCOMPtr<nsIURI> manifestURI;
-  nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(manifestURI),
-                                            manifestSpec, mDocument,
-                                            mDocumentURI);
-  if (!manifestURI) {
-    return;
-  }
-
-  // Documents must list a manifest from the same origin
-  nsresult rv = mDocument->NodePrincipal()->CheckMayLoad(manifestURI, PR_TRUE);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  // Start the update
-  nsCOMPtr<nsIDOMDocument> domdoc = do_QueryInterface(mDocument);
-  nsCOMPtr<nsIOfflineCacheUpdateService> updateService =
-    do_GetService(NS_OFFLINECACHEUPDATESERVICE_CONTRACTID);
-  updateService->ScheduleOnDocumentStop(manifestURI, mDocumentURI, domdoc);
 }
 
 void
 nsContentSink::ScrollToRef()
 {
diff -r 6de576aeff11 content/base/src/nsContentSink.h
--- a/content/base/src/nsContentSink.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/base/src/nsContentSink.h	Thu Aug 28 21:06:41 2008 +0300
@@ -74,10 +74,11 @@ class nsIChannel;
 class nsIChannel;
 class nsIContent;
 class nsIViewManager;
 class nsNodeInfoManager;
 class nsScriptLoader;
+class nsIApplicationCache;
 
 #ifdef NS_DEBUG
 
 extern PRLogModuleInfo* gContentSinkLogModuleInfo;
 
@@ -148,10 +149,29 @@ class nsContentSink : public nsICSSLoade
 
 protected:
   nsContentSink();
   virtual ~nsContentSink();
 
+  enum CacheSelectionAction {
+    // There is no offline cache manifest specified by the document,
+    // or the document was loaded from a cache other than the one it
+    // specifies via its manifest attribute and IS NOT a top-level
+    // document, or an error occurred during the cache selection
+    // algorithm.
+    CACHE_SELECTION_NONE = 0,
+
+    // The offline cache manifest must be updated.
+    CACHE_SELECTION_UPDATE = 1,
+
+    // The document was loaded from a cache other than the one it
+    // specifies via its manifest attribute and IS a top-level
+    // document.  In this case, the document is marked as foreign in
+    // the cache it was loaded from and must be reloaded from the
+    // correct cache (the one it specifies).
+    CACHE_SELECTION_RELOAD = 2
+  };
+
   nsresult Init(nsIDocument* aDoc, nsIURI* aURI,
                 nsISupports* aContainer, nsIChannel* aChannel);
 
   nsresult ProcessHTTPHeaders(nsIChannel* aChannel);
   nsresult ProcessHeaderData(nsIAtom* aHeader, const nsAString& aValue,
@@ -169,10 +189,64 @@ protected:
                                     const nsSubstring& aType,
                                     const nsSubstring& aMedia);
 
   void PrefetchHref(const nsAString &aHref, nsIContent *aSource,
                     PRBool aExplicit);
+
+  // Gets the cache key (used to identify items in a cache) of the channel.
+  nsresult GetChannelCacheKey(nsIChannel* aChannel, nsACString& aCacheKey);
+
+  // There is an offline cache manifest attribute specified and the
+  // document is allowed to use the offline cache.  Process the cache
+  // selection algorithm for this document and the manifest. Result is
+  // an action that must be taken on the manifest, see
+  // CacheSelectionAction enum above.
+  //
+  // @param aLoadApplicationCache
+  //        The application cache from which the load originated, if
+  //        any.
+  // @param aManifestURI
+  //        The manifest URI listed in the document.
+  // @param aIsTopDocument
+  //        TRUE if this is a toplevel document.
+  // @param aFetchedWithHTTPGetOrEquiv
+  //        TRUE if this was fetched using the HTTP GET method.
+  // @param aAction
+  //        Out parameter, returns the action that should be performed
+  //        by the calling function.
+  nsresult SelectDocAppCache(nsIApplicationCache *aLoadApplicationCache,
+                             nsIURI *aManifestURI,
+                             PRBool aIsTopDocument,
+                             PRBool aFetchedWithHTTPGetOrEquiv,
+                             CacheSelectionAction *aAction);
+
+  // There is no offline cache manifest attribute specified.  Process
+  // the cache selection algorithm w/o the manifest. Result is an
+  // action that must be taken, see CacheSelectionAction enum
+  // above. In case the offline cache manifest has to be updated the
+  // manifest URI is returned in aManifestURI.
+  //
+  // @param aLoadApplicationCache
+  //        The application cache from which the load originated, if
+  //        any.
+  // @param aIsTopDocument
+  //        TRUE if this is a toplevel document.
+  // @param aManifestURI
+  //        Out parameter, returns the manifest URI of the cache that
+  //        was selected.
+  // @param aAction
+  //        Out parameter, returns the action that should be performed
+  //        by the calling function.
+  nsresult SelectDocAppCacheNoManifest(nsIApplicationCache *aLoadApplicationCache,
+                                       PRBool aIsTopDocument,
+                                       nsIURI **aManifestURI,
+                                       CacheSelectionAction *aAction);
+
+  // Searches for the offline cache manifest attribute and calls one
+  // of the above defined methods to select the document's application
+  // cache, let it be associated with the document and eventually
+  // schedule the cache update process.
   void ProcessOfflineManifest(nsIContent *aElement);
 
   // Tries to scroll to the URI's named anchor. Once we've successfully
   // done that, further calls to this method will be ignored.
   void ScrollToRef();
diff -r 6de576aeff11 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/base/src/nsContentUtils.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -809,10 +809,20 @@ nsContentUtils::OfflineAppAllowed(nsIURI
 nsContentUtils::OfflineAppAllowed(nsIURI *aURI)
 {
   return NS_OfflineAppAllowed(aURI, sPrefBranch);
 }
 
+/* static */
+PRBool
+nsContentUtils::OfflineAppAllowed(nsIPrincipal *aPrincipal)
+{
+  nsCOMPtr<nsIURI> codebaseURI;
+  aPrincipal->GetURI(getter_AddRefs(codebaseURI));
+
+  return OfflineAppAllowed(codebaseURI);
+}
+
 // static
 void
 nsContentUtils::Shutdown()
 {
   sInitialized = PR_FALSE;
diff -r 6de576aeff11 content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/base/src/nsXMLHttpRequest.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -883,19 +883,13 @@ nsXMLHttpRequest::ConvertBodyToText(nsAS
     return NS_OK;
 
   nsresult rv = NS_OK;
 
   nsCAutoString dataCharset;
-  nsCOMPtr<nsIDOM3Document> document(do_QueryInterface(mDocument));
+  nsCOMPtr<nsIDocument> document(do_QueryInterface(mDocument));
   if (document) {
-    nsAutoString inputEncoding;
-    document->GetInputEncoding(inputEncoding);
-    if (DOMStringIsNull(inputEncoding)) {
-      dataCharset.AssignLiteral("UTF-8");
-    } else {
-      CopyUTF16toUTF8(inputEncoding, dataCharset);
-    }
+    dataCharset = document->GetDocumentCharacterSet();
   } else {
     if (NS_FAILED(DetectCharset(dataCharset)) || dataCharset.IsEmpty()) {
       // MS documentation states UTF-8 is default for responseText
       dataCharset.AssignLiteral("UTF-8");
     }
@@ -1938,13 +1932,19 @@ nsXMLHttpRequest::Send(nsIVariant *aBody
         nsCOMPtr<nsIDOMDocument> doc(do_QueryInterface(supports));
         if (doc) {
           nsCOMPtr<nsIDOMSerializer> serializer(do_CreateInstance(NS_XMLSERIALIZER_CONTRACTID, &rv));
           if (NS_FAILED(rv)) return rv;
 
-          nsCOMPtr<nsIDocument> baseDoc(do_QueryInterface(doc));
-          if (baseDoc) {
-            charset = baseDoc->GetDocumentCharacterSet();
+          nsCOMPtr<nsIDOM3Document> dom3doc(do_QueryInterface(doc));
+          if (dom3doc) {
+            nsAutoString inputEncoding;
+            dom3doc->GetInputEncoding(inputEncoding);
+            if (DOMStringIsNull(inputEncoding)) {
+              charset.AssignLiteral("UTF-8");
+            } else {
+              CopyUTF16toUTF8(inputEncoding, charset);
+            }
           }
 
           // Serialize to a stream so that the encoding used will
           // match the document's.
           nsCOMPtr<nsIStorageStream> storStream;
diff -r 6de576aeff11 content/base/test/Makefile.in
--- a/content/base/test/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/base/test/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -182,10 +182,11 @@ _TEST_FILES = 	test_bug5141.html \
 		file_XHR_fail1.txt^headers^ \
 		test_bug428847.html \
 		file_bug428847-1.xhtml \
 		file_bug428847-2.xhtml \
 		test_bug425201.html \
+		test_bug431701.html \
 		test_bug431833.html \
 		test_bug435425.html \
 		bug435425.sjs \
 		bug435425_redirect.sjs \
 		test_bug438519.html \
diff -r 6de576aeff11 content/base/test/test_bug431701.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/test_bug431701.html	Thu Aug 28 21:06:41 2008 +0300
@@ -0,0 +1,120 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=431701
+-->
+<head>
+  <title>Test for Bug 431701</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=431701">Mozilla Bug 431701</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+  <iframe id="one"></iframe>
+  <iframe id="two"></iframe>
+  <iframe id="three"></iframe>
+  <iframe id="four"></iframe>
+  <iframe id="five"></iframe>
+  <iframe id="six"></iframe>
+  <iframe id="seven"></iframe>
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 431701 **/
+SimpleTest.waitForExplicitFinish();
+
+var docSources = [
+  "data:text/html,<html></html>",
+  "data:text/html;charset=UTF-8,<html></html>",
+  "data:text/html;charset=ISO-8859-1,<html></html>",
+  "data:text/xml,<html></html>",
+  "data:text/xml,<?xml version='1.0'?><html></html>",
+  "data:text/xml,<?xml version='1.0' encoding='UTF-8'?><html></html>",
+  "data:text/xml,<?xml version='1.0' encoding='ISO-8859-1'?><html></html>",
+];
+
+for (var i = 0; i < docSources.length; ++i) {
+  document.getElementsByTagName("iframe")[i].src = docSources[i];
+}
+
+function frameDoc(id) {
+  return function() { return $(id).contentDocument; };
+}
+
+function createDoc() {
+  return document.implementation.createDocument('', 'html', null);
+}
+
+function xhrDoc(idx) {
+  return function() {
+    // Defy same-origin restrictions!
+    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+    var xhr = new XMLHttpRequest();
+    xhr.open("GET", docSources[idx], false);
+    xhr.send();
+    return xhr.responseXML;
+  };
+}
+
+// Each row has the document getter function, then the characterSet,
+// inputEncoding, xmlEncoding expected for that document.
+
+var tests = [
+ [ frameDoc("one"), "ISO-8859-1", "ISO-8859-1", null ],
+ [ frameDoc("two"), "UTF-8", "UTF-8", null ],
+ [ frameDoc("three"), "ISO-8859-1", "ISO-8859-1", null ],
+ [ frameDoc("four"), "UTF-8", "UTF-8", null ],
+ [ frameDoc("five"), "UTF-8", "UTF-8", null ],
+ [ frameDoc("six"), "UTF-8", "UTF-8", "UTF-8"],
+ [ frameDoc("seven"), "ISO-8859-1", "ISO-8859-1", "ISO-8859-1" ],
+ [ createDoc, "UTF-8", null, null ],
+ [ xhrDoc(4), "UTF-8", "UTF-8", null ],
+ [ xhrDoc(5), "UTF-8", "UTF-8", "UTF-8" ],
+ [ xhrDoc(6), "ISO-8859-1", "ISO-8859-1", "ISO-8859-1" ],
+];
+
+function doTest(idx) {
+  var [docGetter, expectedCharacterSet,
+       expectedInputEncoding, expectedXMLEncoding] = tests[idx];
+  var doc = docGetter();
+
+  // Have to be careful here to catch null vs ""
+  is(doc.characterSet, expectedCharacterSet, "Test " + idx + " characterSet");
+  is(doc.inputEncoding, expectedInputEncoding,
+     "Test " + idx + " inputEncoding");
+  is(doc.xmlEncoding, expectedXMLEncoding, "Test " + idx + " xmlEncoding");
+}
+
+addLoadEvent(function() {
+  // sanity check
+  isnot("", null, "Shouldn't be equal!");
+
+  for (var i = 0; i < tests.length; ++i) {
+    doTest(i);
+  }
+
+  // Now check what xhr does
+  var xhr = new XMLHttpRequest();
+  xhr.open("POST", document.location.href);
+  xhr.send(createDoc());
+  netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+  is(xhr.channel.QueryInterface(Components.interfaces.nsIHttpChannel)
+                .getRequestHeader("Content-Type"),
+     "application/xml; charset=UTF-8", "Testing correct type on the wire");
+  xhr.abort();
+                     
+  SimpleTest.finish();
+});
+
+
+
+
+</script>
+</pre>
+</body>
+</html>
+
diff -r 6de576aeff11 content/xml/document/src/nsXMLDocument.cpp
--- a/content/xml/document/src/nsXMLDocument.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/content/xml/document/src/nsXMLDocument.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -131,10 +131,13 @@ NS_NewDOMDocument(nsIDOMDocument** aInst
   doc->nsDocument::SetDocumentURI(aDocumentURI);
   // Must set the principal first, since SetBaseURI checks it.
   doc->SetPrincipal(aPrincipal);
   doc->SetBaseURI(aBaseURI);
 
+  // XMLDocuments get to be UTF-8 by default, unlike the legacy HTML mess
+  doc->SetDocumentCharacterSet(NS_LITERAL_CSTRING("UTF-8"));
+  
   if (aDoctype) {
     nsCOMPtr<nsIDOMNode> tmpNode;
     rv = doc->AppendChild(aDoctype, getter_AddRefs(tmpNode));
     NS_ENSURE_SUCCESS(rv, rv);
   }
diff -r 6de576aeff11 docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/docshell/base/nsDocShell.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -7474,11 +7474,21 @@ nsDocShell::DoURILoad(nsIURI * aURI,
     // based on its own codebase later.
     //
     nsCOMPtr<nsIPrincipal> ownerPrincipal(do_QueryInterface(aOwner));
     if (URIIsLocalFile(aURI) && ownerPrincipal &&
         NS_SUCCEEDED(ownerPrincipal->CheckMayLoad(aURI, PR_FALSE))) {
-        channel->SetOwner(aOwner);
+        // One more check here.  CheckMayLoad will always return true for the
+        // system principal, but we do NOT want to inherit in that case.
+        PRBool isSystem;
+        nsCOMPtr<nsIScriptSecurityManager> secMan =
+            do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
+        if (secMan &&
+            NS_SUCCEEDED(secMan->IsSystemPrincipal(ownerPrincipal,
+                                                   &isSystem)) &&
+            !isSystem) {
+            channel->SetOwner(aOwner);
+        }
     }
 
     nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(channel);
     if (scriptChannel) {
         // Allow execution against our context if the principals match
diff -r 6de576aeff11 dom/locales/en-US/chrome/dom/dom.properties
--- a/dom/locales/en-US/chrome/dom/dom.properties	Wed Aug 27 08:11:51 2008 -0400
+++ b/dom/locales/en-US/chrome/dom/dom.properties	Thu Aug 28 21:06:41 2008 +0300
@@ -56,5 +56,7 @@ UseOfPreventBubbleWarning=Event=%S, use 
 UseOfPreventBubbleWarning=Event=%S, use of preventBubble() is deprecated. Use W3C standard stopPropagation() instead.
 UseOfPreventCaptureWarning=Event=%S, use of preventCapture() is deprecated. Use W3C standard stopPropagation() instead.
 UseOfGetBoxObjectForWarning=Use of getBoxObjectFor() is deprecated. Try to use element.getBoundingClientRect() if possible.
 UnexpectedCanvasVariantStyle=canvas: an attempt to set strokeStyle or fillStyle to a value that is neither a string, a CanvasGradient, or a CanvasPattern was ignored.
 EmptyGetElementByIdParam=Empty string passed to getElementById().
+LowMemoryTitle=Warning: Low memory
+LowMemoryMessage=A script on this page has been stopped due to a low memory condition.
diff -r 6de576aeff11 dom/public/idl/base/nsIDOMWindowUtils.idl
--- a/dom/public/idl/base/nsIDOMWindowUtils.idl	Wed Aug 27 08:11:51 2008 -0400
+++ b/dom/public/idl/base/nsIDOMWindowUtils.idl	Thu Aug 28 21:06:41 2008 +0300
@@ -231,6 +231,12 @@ interface nsIDOMWindowUtils : nsISupport
    *
    * Will throw a DOM security error if called without UniversalXPConnect
    * privileges in non-debug builds. Available to all callers in debug builds.
    */
   void garbageCollect();
+
+  /**
+   * Force processing of any queued paints
+   */
+
+  void processUpdates();
 };
diff -r 6de576aeff11 dom/src/base/nsDOMWindowUtils.cpp
--- a/dom/src/base/nsDOMWindowUtils.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/dom/src/base/nsDOMWindowUtils.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -52,10 +52,12 @@
 #include "nsIFrame.h"
 #include "nsIWidget.h"
 #include "nsGUIEvent.h"
 #include "nsIParser.h"
 #include "nsJSEnvironment.h"
+
+#include "nsIViewManager.h"
 
 #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2)
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 #endif
@@ -464,5 +466,28 @@ nsDOMWindowUtils::GarbageCollect()
   nsJSContext::CC();
   nsJSContext::CC();
 
   return NS_OK;
 }
+
+
+NS_IMETHODIMP
+nsDOMWindowUtils::ProcessUpdates()
+{
+  nsCOMPtr<nsIDocShell> docShell = mWindow->GetDocShell();
+  if (!docShell) 
+    return NS_ERROR_UNEXPECTED;
+  nsCOMPtr<nsIPresShell> presShell;
+  
+  nsresult rv = docShell->GetPresShell(getter_AddRefs(presShell));
+  if (!NS_SUCCEEDED(rv) || !presShell) 
+    return NS_ERROR_UNEXPECTED;
+  
+  nsIViewManager *viewManager = presShell->GetViewManager();
+  if (!viewManager)
+    return NS_ERROR_UNEXPECTED;
+  
+  nsIViewManager::UpdateViewBatch batch;
+  batch.BeginUpdateViewBatch(viewManager);
+  batch.EndUpdateViewBatch(NS_VMREFRESH_IMMEDIATE);
+  return NS_OK;
+}
diff -r 6de576aeff11 dom/src/base/nsJSEnvironment.cpp
--- a/dom/src/base/nsJSEnvironment.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/dom/src/base/nsJSEnvironment.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -106,13 +106,10 @@
 #endif
 
 #ifdef MOZ_JSDEBUGGER
 #include "jsdIDebuggerService.h"
 #endif
-
-#include "nsIStringBundle.h"
-
 #ifdef MOZ_LOGGING
 // Force PR_LOGGING so we can get JS strict warnings even in release builds
 #define FORCE_PR_LOG 1
 #endif
 #include "prlog.h"
@@ -203,13 +200,10 @@ JSRuntime *nsJSRuntime::sRuntime;
 JSRuntime *nsJSRuntime::sRuntime;
 
 static const char kJSRuntimeServiceContractID[] =
   "@mozilla.org/js/xpc/RuntimeService;1";
 
-static const char kDOMStringBundleURL[] =
-  "chrome://global/locale/dom/dom.properties";
-
 static JSGCCallback gOldJSGCCallback;
 
 static PRBool sIsInitialized;
 static PRBool sDidShutdown;
 
@@ -856,13 +850,33 @@ MaybeGC(JSContext *cx)
     ++sGCCount;
     JS_GC(cx);
   }
 }
 
+static already_AddRefed<nsIPrompt>
+GetPromptFromContext(nsJSContext* ctx)
+{
+  nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(ctx->GetGlobalObject()));
+  NS_ENSURE_TRUE(win, nsnull);
+
+  nsIDocShell *docShell = win->GetDocShell();
+  NS_ENSURE_TRUE(docShell, nsnull);
+
+  nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(docShell));
+  NS_ENSURE_TRUE(ireq, nsnull);
+
+  // Get the nsIPrompt interface from the docshell
+  nsIPrompt* prompt;
+  ireq->GetInterface(NS_GET_IID(nsIPrompt), (void**)&prompt);
+  return prompt;
+}
+
 JSBool JS_DLL_CALLBACK
 nsJSContext::DOMOperationCallback(JSContext *cx)
 {
+  nsresult rv;
+
   // Get the native context
   nsJSContext *ctx = static_cast<nsJSContext *>(::JS_GetContextPrivate(cx));
 
   if (!ctx) {
     // Can happen; see bug 355811
@@ -877,10 +891,48 @@ nsJSContext::DOMOperationCallback(JSCont
 
   MaybeGC(cx);
 
   // Now restore the callback time and count, in case they got reset.
   ctx->mOperationCallbackTime = callbackTime;
+
+  // Check to see if we are running OOM
+  nsCOMPtr<nsIMemory> mem;
+  NS_GetMemoryManager(getter_AddRefs(mem));
+  if (!mem)
+    return JS_FALSE;
+
+  PRBool lowMemory;
+  mem->IsLowMemory(&lowMemory);
+  if (lowMemory) {
+    // try to clean up:
+    nsJSContext::CC();
+
+    // if that didn't work, warn the user
+    mem->IsLowMemory(&lowMemory);
+    if (lowMemory) {
+      nsCOMPtr<nsIPrompt> prompt = GetPromptFromContext(ctx);
+      
+      nsXPIDLString title, msg;
+      rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                              "LowMemoryTitle",
+                                              title);
+
+      rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                               "LowMemoryMessage",
+                                               msg);
+
+      //GetStringFromName can return NS_OK and still give NULL string
+      if (NS_FAILED(rv) || !title || !msg) {
+        NS_ERROR("Failed to get localized strings.");
+        return JS_FALSE;
+      }
+
+      prompt->Alert(title, msg);
+      return JS_FALSE;
+    }
+  }
+
 
   PRTime now = PR_Now();
 
   if (LL_IS_ZERO(callbackTime)) {
     // Initialize mOperationCallbackTime to start timing how long the
@@ -902,25 +954,12 @@ nsJSContext::DOMOperationCallback(JSCont
   }
 
   // If we get here we're most likely executing an infinite loop in JS,
   // we'll tell the user about this and we'll give the user the option
   // of stopping the execution of the script.
-  nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(ctx->GetGlobalObject()));
-  NS_ENSURE_TRUE(win, JS_TRUE);
-
-  nsIDocShell *docShell = win->GetDocShell();
-  NS_ENSURE_TRUE(docShell, JS_TRUE);
-
-  nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(docShell));
-  NS_ENSURE_TRUE(ireq, JS_TRUE);
-
-  // Get the nsIPrompt interface from the docshell
-  nsCOMPtr<nsIPrompt> prompt;
-  ireq->GetInterface(NS_GET_IID(nsIPrompt), getter_AddRefs(prompt));
+  nsCOMPtr<nsIPrompt> prompt = GetPromptFromContext(ctx);
   NS_ENSURE_TRUE(prompt, JS_TRUE);
-
-  nsresult rv;
 
   // Check if we should offer the option to debug
   JSStackFrame* fp = ::JS_GetScriptedCaller(cx, NULL);
   PRBool debugPossible = (fp != nsnull &&
                           cx->debugHooks->debuggerHandler != nsnull);
@@ -948,41 +987,42 @@ nsJSContext::DOMOperationCallback(JSCont
     debugPossible = ((jsds_IsOn && (jsdHook != nsnull)) || !jsds_IsOn);
   }
 #endif
 
   // Get localizable strings
-  nsCOMPtr<nsIStringBundleService>
-    stringService(do_GetService(NS_STRINGBUNDLE_CONTRACTID));
-  if (!stringService)
-    return JS_TRUE;
-
-  nsCOMPtr<nsIStringBundle> bundle;
-  stringService->CreateBundle(kDOMStringBundleURL, getter_AddRefs(bundle));
-  if (!bundle)
-    return JS_TRUE;
-
   nsXPIDLString title, msg, stopButton, waitButton, debugButton, neverShowDlg;
 
-  rv = bundle->GetStringFromName(NS_LITERAL_STRING("KillScriptTitle").get(),
-                                  getter_Copies(title));
-  rv |= bundle->GetStringFromName(NS_LITERAL_STRING("StopScriptButton").get(),
-                                  getter_Copies(stopButton));
-  rv |= bundle->GetStringFromName(NS_LITERAL_STRING("WaitForScriptButton").get(),
-                                  getter_Copies(waitButton));
-  rv |= bundle->GetStringFromName(NS_LITERAL_STRING("DontAskAgain").get(),
-                                  getter_Copies(neverShowDlg));
+  rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                          "KillScriptTitle",
+                                          title);
+
+  rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                           "StopScriptButton",
+                                           stopButton);
+
+  rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                           "WaitForScriptButton",
+                                           waitButton);
+
+  rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                           "DontAskAgain",
+                                           neverShowDlg);
 
 
   if (debugPossible) {
-    rv |= bundle->GetStringFromName(NS_LITERAL_STRING("DebugScriptButton").get(),
-                                    getter_Copies(debugButton));
-    rv |= bundle->GetStringFromName(NS_LITERAL_STRING("KillScriptWithDebugMessage").get(),
-                                   getter_Copies(msg));
+    rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                             "DebugScriptButton",
+                                             debugButton);
+
+    rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                             "KillScriptWithDebugMessage",
+                                             msg);
   }
   else {
-    rv |= bundle->GetStringFromName(NS_LITERAL_STRING("KillScriptMessage").get(),
-                                   getter_Copies(msg));
+    rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                             "KillScriptMessage",
+                                             msg);
   }
 
   //GetStringFromName can return NS_OK and still give NULL string
   if (NS_FAILED(rv) || !title || !msg || !stopButton || !waitButton ||
       (!debugButton && debugPossible) || !neverShowDlg) {
@@ -996,13 +1036,14 @@ nsJSContext::DOMOperationCallback(JSCont
     const char *filename = ::JS_GetScriptFilename(cx, script);
     if (filename) {
       nsXPIDLString scriptLocation;
       NS_ConvertUTF8toUTF16 filenameUTF16(filename);
       const PRUnichar *formatParams[] = { filenameUTF16.get() };
-      rv = bundle->FormatStringFromName(NS_LITERAL_STRING("KillScriptLocation").get(),
-                                        formatParams, 1,
-                                        getter_Copies(scriptLocation));
+      rv = nsContentUtils::FormatLocalizedString(nsContentUtils::eDOM_PROPERTIES,
+                                                 "KillScriptLocation",
+                                                 formatParams, 1,
+                                                 scriptLocation);
 
       if (NS_SUCCEEDED(rv) && scriptLocation) {
         msg.AppendLiteral("\n\n");
         msg.Append(scriptLocation);
 
diff -r 6de576aeff11 dom/src/offline/nsDOMOfflineResourceList.cpp
--- a/dom/src/offline/nsDOMOfflineResourceList.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/dom/src/offline/nsDOMOfflineResourceList.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -336,11 +336,15 @@ nsDOMOfflineResourceList::Add(const nsAS
 
   nsCOMPtr<nsIOfflineCacheUpdate> update =
     do_CreateInstance(NS_OFFLINECACHEUPDATE_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = update->Init(PR_TRUE, mManifestURI, mDocumentURI);
+  nsCAutoString clientID;
+  rv = appCache->GetClientID(clientID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = update->InitPartial(mManifestURI, clientID, mDocumentURI);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = update->AddDynamicURI(requestedURI);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1066,12 +1070,12 @@ nsDOMOfflineResourceList::CacheKeys()
 
   if (!appCache) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
-  nsresult rv = appCache->GatherEntries(nsIApplicationCache::ITEM_DYNAMIC,
-                                        &mCachedKeysCount, &mCachedKeys);
+  return appCache->GatherEntries(nsIApplicationCache::ITEM_DYNAMIC,
+                                 &mCachedKeysCount, &mCachedKeys);
 }
 
 void
 nsDOMOfflineResourceList::ClearCachedKeys()
 {
diff -r 6de576aeff11 embedding/browser/activex/src/plugin/LegacyPlugin.cpp
--- a/embedding/browser/activex/src/plugin/LegacyPlugin.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/embedding/browser/activex/src/plugin/LegacyPlugin.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -301,12 +301,11 @@ ShowError(MozAxPluginErrors errorCode, c
         {
             USES_CONVERSION;
             LPOLESTR szClsid;
             StringFromCLSID(clsid, &szClsid);
             _sntprintf(szBuffer, kBufSize - 1,
-                _T("Could not create the control %s. Check that it has been installed on your computer "
-                   "and that this page correctly references it."), OLE2T(szClsid));
+                _T("Could not create the control %s. Check that it has been installed on your computer and that this page correctly references it."), OLE2T(szClsid));
             CoTaskMemFree(szClsid);
             szMsg = szBuffer;
         }
         break;
     }
diff -r 6de576aeff11 embedding/browser/activex/src/plugin/XPCDocument.cpp
--- a/embedding/browser/activex/src/plugin/XPCDocument.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/embedding/browser/activex/src/plugin/XPCDocument.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -1913,11 +1913,11 @@ END_COM_MAP()
             nsCAutoString spec;
             if (baseURI &&
                 NS_SUCCEEDED(baseURI->GetSpec(spec)))
             {
                 USES_CONVERSION;
-                if (FAILED(CreateURLMoniker(NULL, T2CW(spec.get()), &baseURLMoniker)))
+                if (FAILED(CreateURLMoniker(NULL, A2CW(spec.get()), &baseURLMoniker)))
                     return E_UNEXPECTED;
             }
         }
 
         // Make the moniker
diff -r 6de576aeff11 embedding/browser/activex/src/plugin/XPConnect.cpp
--- a/embedding/browser/activex/src/plugin/XPConnect.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/embedding/browser/activex/src/plugin/XPConnect.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -370,11 +370,11 @@ nsScriptablePeer::ConvertVariants(VARIAN
     // DO NOT TAUNT THE HACK
     if (NS_FAILED(rv))
     {
         // do_CreateInstance macro is broken so load the component manager by
         // hand and get it to create the component.
-        HMODULE hlib = ::LoadLibrary("xpcom.dll");
+        HMODULE hlib = ::LoadLibraryW(L"xpcom.dll");
         if (hlib)
         {
             nsIComponentManager *pManager = nsnull; // A frozen interface, even in 1.0.x
             typedef nsresult (PR_CALLBACK *Moz1XGetComponentManagerFunc)(nsIComponentManager* *result);
             Moz1XGetComponentManagerFunc compMgr = (Moz1XGetComponentManagerFunc)
diff -r 6de576aeff11 extensions/auth/nsAuthSSPI.cpp
--- a/extensions/auth/nsAuthSSPI.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/extensions/auth/nsAuthSSPI.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -50,10 +50,12 @@
 #include "nsIDNSService.h"
 #include "nsIDNSRecord.h"
 #include "nsNetCID.h"
 #include "nsCOMPtr.h"
 
+#include <windows.h>
+
 #define SEC_SUCCESS(Status) ((Status) >= 0)
 
 #ifndef KERB_WRAP_NO_ENCRYPT
 #define KERB_WRAP_NO_ENCRYPT 0x80000001
 #endif
@@ -101,38 +103,38 @@ static const char *MapErrorCode(int rc)
 #endif
 
 //-----------------------------------------------------------------------------
 
 static HINSTANCE                 sspi_lib; 
-static PSecurityFunctionTable    sspi;
+static PSecurityFunctionTableW   sspi;
 
 static nsresult
 InitSSPI()
 {
-    PSecurityFunctionTable (*initFun)(void);
+    PSecurityFunctionTableW (*initFun)(void);
 
     LOG(("  InitSSPI\n"));
 
-    sspi_lib = LoadLibrary("secur32.dll");
+    sspi_lib = LoadLibraryW(L"secur32.dll");
     if (!sspi_lib) {
-        sspi_lib = LoadLibrary("security.dll");
+        sspi_lib = LoadLibraryW(L"security.dll");
         if (!sspi_lib) {
             LOG(("SSPI library not found"));
             return NS_ERROR_UNEXPECTED;
         }
     }
 
-    initFun = (PSecurityFunctionTable (*)(void))
-            GetProcAddress(sspi_lib, "InitSecurityInterfaceA");
+    initFun = (PSecurityFunctionTableW (*)(void))
+            GetProcAddress(sspi_lib, "InitSecurityInterfaceW");
     if (!initFun) {
-        LOG(("InitSecurityInterfaceA not found"));
+        LOG(("InitSecurityInterfaceW not found"));
         return NS_ERROR_UNEXPECTED;
     }
 
     sspi = initFun();
     if (!sspi) {
-        LOG(("InitSecurityInterfaceA failed"));
+        LOG(("InitSecurityInterfaceW failed"));
         return NS_ERROR_UNEXPECTED;
     }
 
     return NS_OK;
 }
@@ -240,37 +242,35 @@ nsAuthSSPI::Init(const char *serviceName
     if (!sspi) {
         rv = InitSSPI();
         if (NS_FAILED(rv))
             return rv;
     }
+    SEC_WCHAR *package;
 
-    SEC_CHAR *package;
-
-    package = (SEC_CHAR *) pTypeName[(int)mPackage];
-
+    package = (SEC_WCHAR *) pTypeName[(int)mPackage];
     if (mPackage != PACKAGE_TYPE_NTLM)
     {
         rv = MakeSN(serviceName, mServiceName);
         if (NS_FAILED(rv))
             return rv;
         mServiceFlags = serviceFlags;
     }
 
     SECURITY_STATUS rc;
 
-    PSecPkgInfo pinfo;
-    rc = (sspi->QuerySecurityPackageInfo)(package, &pinfo);
+    PSecPkgInfoW pinfo;
+    rc = (sspi->QuerySecurityPackageInfoW)(package, &pinfo);
     if (rc != SEC_E_OK) {
         LOG(("%s package not found\n", package));
         return NS_ERROR_UNEXPECTED;
     }
     mMaxTokenLen = pinfo->cbMaxToken;
     (sspi->FreeContextBuffer)(pinfo);
 
     TimeStamp useBefore;
 
-    rc = (sspi->AcquireCredentialsHandle)(NULL,
+    rc = (sspi->AcquireCredentialsHandleW)(NULL,
                                           package,
                                           SECPKG_CRED_OUTBOUND,
                                           NULL,
                                           NULL,
                                           NULL,
@@ -334,19 +334,17 @@ nsAuthSSPI::GetNextToken(const void *inT
     ob.cbBuffer = mMaxTokenLen;
     ob.pvBuffer = nsMemory::Alloc(ob.cbBuffer);
     if (!ob.pvBuffer)
         return NS_ERROR_OUT_OF_MEMORY;
     memset(ob.pvBuffer, 0, ob.cbBuffer);
-
-    SEC_CHAR *sn;
-
+    SEC_WCHAR *sn;
     if (mPackage == PACKAGE_TYPE_NTLM)
         sn = NULL;
     else
-        sn = (SEC_CHAR *) mServiceName.get();
+        sn = (SEC_WCHAR *) mServiceName.get();
 
-    rc = (sspi->InitializeSecurityContext)(&mCred,
+    rc = (sspi->InitializeSecurityContextW)(&mCred,
                                            ctxIn,
                                            sn,
                                            ctxReq,
                                            0,
                                            SECURITY_NATIVE_DREP,
@@ -459,11 +457,11 @@ nsAuthSSPI::Wrap(const void *inToken,
 
     SecBufferDesc ibd;
     secBuffers bufs;
     SecPkgContext_Sizes sizes;
 
-    rc = (sspi->QueryContextAttributes)(
+    rc = (sspi->QueryContextAttributesW)(
          &mCtxt,
          SECPKG_ATTR_SIZES,
          &sizes);
 
     if (!SEC_SUCCESS(rc))  
diff -r 6de576aeff11 gfx/src/thebes/nsSystemFontsWin.cpp
--- a/gfx/src/thebes/nsSystemFontsWin.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/src/thebes/nsSystemFontsWin.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -41,23 +41,17 @@
 #include "gfxWindowsSurface.h"
 
 #include "nsSystemFontsWin.h"
 
 
-nsresult nsSystemFontsWin::CopyLogFontToNSFont(HDC* aHDC, const LOGFONT* ptrLogFont,
-					       nsString *aFontName,
-                                               gfxFontStyle *aFontStyle,
-                                               PRBool aIsWide) const
+nsresult nsSystemFontsWin::CopyLogFontToNSFont(HDC* aHDC, const LOGFONTW* ptrLogFont,
+                                               nsString *aFontName,
+                                               gfxFontStyle *aFontStyle) const
 {
   PRUnichar name[LF_FACESIZE];
   name[0] = 0;
-  if (aIsWide)
-    memcpy(name, ptrLogFont->lfFaceName, LF_FACESIZE*2);
-  else {
-    MultiByteToWideChar(CP_ACP, 0, ptrLogFont->lfFaceName,
-      strlen(ptrLogFont->lfFaceName) + 1, name, sizeof(name)/sizeof(name[0]));
-  }
+  memcpy(name, ptrLogFont->lfFaceName, LF_FACESIZE*sizeof(PRUnichar));
   *aFontName = name;
 
   // Do Style
   aFontStyle->style = FONT_STYLE_NORMAL;
   if (ptrLogFont->lfItalic)
@@ -83,11 +77,11 @@ nsresult nsSystemFontsWin::CopyLogFontTo
   // any value when going to a printer, for example mPixleScale is
   // 6.25 when going to a 600dpi printer.
   // round, but take into account whether it is negative
   float pixelHeight = -ptrLogFont->lfHeight;
   if (pixelHeight < 0) {
-    HFONT hFont = ::CreateFontIndirect(ptrLogFont);
+    HFONT hFont = ::CreateFontIndirectW(ptrLogFont);
     if (!hFont)
       return NS_ERROR_OUT_OF_MEMORY;
     HGDIOBJ hObject = ::SelectObject(*aHDC, hFont);
     TEXTMETRIC tm;
     ::GetTextMetrics(*aHDC, &tm);
@@ -114,36 +108,36 @@ nsresult nsSystemFontsWin::GetSysFontInf
                                           nsString *aFontName,
                                           gfxFontStyle *aFontStyle) const
 {
   HGDIOBJ hGDI;
 
-  LOGFONT logFont;
-  LOGFONT* ptrLogFont = NULL;
+  LOGFONTW logFont;
+  LOGFONTW* ptrLogFont = NULL;
 
 #ifdef WINCE
   hGDI = ::GetStockObject(SYSTEM_FONT);
   if (hGDI == NULL)
     return NS_ERROR_UNEXPECTED;
   
-  if (::GetObject(hGDI, sizeof(logFont), &logFont) > 0)
+  if (::GetObjectW(hGDI, sizeof(logFont), &logFont) > 0)
     ptrLogFont = &logFont;
 #else
 
-  NONCLIENTMETRICS ncm;
+  NONCLIENTMETRICSW ncm;
 
   BOOL status;
   if (anID == eSystemFont_Icon) 
   {
-    status = ::SystemParametersInfo(SPI_GETICONTITLELOGFONT,
-                                  sizeof(logFont),
-                                  (PVOID)&logFont,
-                                  0);
+    status = ::SystemParametersInfoW(SPI_GETICONTITLELOGFONT,
+                                     sizeof(logFont),
+                                     (PVOID)&logFont,
+                                     0);
   }
   else
   {
-    ncm.cbSize = sizeof(NONCLIENTMETRICS);
-    status = ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 
+    ncm.cbSize = sizeof(NONCLIENTMETRICSW);
+    status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
                                      sizeof(ncm),  
                                      (PVOID)&ncm, 
                                      0);
   }
 
@@ -194,11 +188,11 @@ nsresult nsSystemFontsWin::GetSysFontInf
     case eSystemFont_Field:
     case eSystemFont_Caption: 
       hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
       if (hGDI != NULL)
       {
-        if (::GetObject(hGDI, sizeof(logFont), &logFont) > 0)
+        if (::GetObjectW(hGDI, sizeof(logFont), &logFont) > 0)
         { 
           ptrLogFont = &logFont;
         }
       }
       break;
diff -r 6de576aeff11 gfx/src/thebes/nsSystemFontsWin.h
--- a/gfx/src/thebes/nsSystemFontsWin.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/src/thebes/nsSystemFontsWin.h	Thu Aug 28 21:06:41 2008 +0300
@@ -48,13 +48,12 @@ public:
     nsSystemFontsWin();
 
     nsresult GetSystemFont(nsSystemFontID anID, nsString *aFontName,
                            gfxFontStyle *aFontStyle) const;
 private:
-    nsresult CopyLogFontToNSFont(HDC* aHDC, const LOGFONT* ptrLogFont,
-                                 nsString *aFontName, gfxFontStyle *aFontStyle,
-				 PRBool aIsWide = PR_FALSE) const;
+    nsresult CopyLogFontToNSFont(HDC* aHDC, const LOGFONTW* ptrLogFont,
+                                 nsString *aFontName, gfxFontStyle *aFontStyle) const;
     nsresult GetSysFontInfo(HDC aHDC, nsSystemFontID anID,
                             nsString *aFontName,
                             gfxFontStyle *aFontStyle) const;
 };
 
diff -r 6de576aeff11 gfx/thebes/public/Makefile.in
--- a/gfx/thebes/public/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/thebes/public/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -77,11 +77,11 @@ endif
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),qt)
 EXPORTS += gfxQtPlatform.h gfxQPainterSurface.h
 EXPORTS += gfxXlibSurface.h gfxQtNativeRenderer.h
-EXPORTS += gfxQtFonts.h
+EXPORTS += gfxFT2Fonts.h
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),os2)
 EXPORTS	+=	gfxOS2Surface.h \
 		gfxOS2Platform.h \
diff -r 6de576aeff11 gfx/thebes/public/gfxFT2Fonts.h
--- a/gfx/thebes/public/gfxFT2Fonts.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/thebes/public/gfxFT2Fonts.h	Thu Aug 28 21:06:41 2008 +0300
@@ -51,33 +51,34 @@ typedef struct FT_FaceRec_* FT_Face;
  * FontFamily is a class that describes one of the fonts on the users system.  It holds
  * each FontEntry (maps more directly to a font face) which holds font type, charset info
  * and character map info.
  */
 class FontEntry;
-class FontFamily
+class FontFamily : public gfxFontFamily
 {
 public:
-    THEBES_INLINE_DECL_REFCOUNTING(FontFamily)
-
     FontFamily(const nsAString& aName) :
-        mName(aName) { }
+        gfxFontFamily(aName) { }
 
     FontEntry *FindFontEntry(const gfxFontStyle& aFontStyle);
 
 public:
     nsTArray<nsRefPtr<FontEntry> > mFaces;
     nsString mName;
 };
 
-class FontEntry
+class FontEntry : public gfxFontEntry
 {
 public:
-    THEBES_INLINE_DECL_REFCOUNTING(FontEntry)
-
-    FontEntry(const nsString& aFaceName) : 
-        mFontFace(nsnull), mFaceName(aFaceName), mFTFontIndex(0), mUnicodeFont(PR_FALSE), mSymbolFont(PR_FALSE)
-    { }
+    FontEntry(const nsAString& aFaceName) :
+        gfxFontEntry(aFaceName)
+    {
+        mFontFace = nsnull;
+        mFTFontIndex = 0;
+        mUnicodeFont = PR_FALSE;
+        mSymbolFont = PR_FALSE;
+    }
 
     FontEntry(const FontEntry& aFontEntry);
     ~FontEntry();
 
     const nsString& GetName() const {
@@ -90,18 +91,12 @@ public:
 
     nsString mFaceName;
     nsCString mFilename;
     PRUint8 mFTFontIndex;
 
-    PRPackedBool mUnicodeFont : 1;
-    PRPackedBool mSymbolFont  : 1;
     PRPackedBool mTrueType    : 1;
     PRPackedBool mIsType1     : 1;
-    PRPackedBool mItalic      : 1;
-    PRUint16 mWeight;
-
-    gfxSparseBitSet mCharacterMap;
 };
 
 
 
 class gfxFT2Font : public gfxFont {
@@ -117,21 +112,19 @@ public: // new functions
 
     virtual PRBool SetupCairoFont(gfxContext *aContext);
     virtual nsString GetUniqueName();
     virtual PRUint32 GetSpaceGlyph();
 
-    FontEntry *GetFontEntry() { return mFontEntry; }
+    FontEntry *GetFontEntry();
 private:
     cairo_scaled_font_t *mScaledFont;
 
     PRBool mHasSpaceGlyph;
     PRUint32 mSpaceGlyph;
     PRBool mHasMetrics;
     Metrics mMetrics;
     gfxFloat mAdjustedSize;
-
-    nsRefPtr<FontEntry> mFontEntry;
 };
 
 class THEBES_API gfxFT2FontGroup : public gfxFontGroup {
 public: // new functions
     gfxFT2FontGroup (const nsAString& families,
diff -r 6de576aeff11 gfx/thebes/public/gfxQtFonts.h
--- a/gfx/thebes/public/gfxQtFonts.h	Wed Aug 27 08:11:51 2008 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,178 +0,0 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Foundation code.
- *
- * The Initial Developer of the Original Code is Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2005
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Vladimir Vukicevic <vladimir@mozilla.com>
- *   Masayuki Nakano <masayuki@d-toybox.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef GFX_QTFONTS_H
-#define GFX_QTFONTS_H
-
-#include "cairo.h"
-#include "gfxTypes.h"
-#include "gfxFont.h"
-#include "gfxContext.h"
-#include "gfxFontUtils.h"
-
-typedef struct FT_FaceRec_* FT_Face;
-
-/**
- * FontFamily is a class that describes one of the fonts on the users system.  It holds
- * each FontEntry (maps more directly to a font face) which holds font type, charset info
- * and character map info.
- */
-class FontEntry;
-class FontFamily : public gfxFontFamily
-{
-public:
-    FontFamily(const nsAString& aName) :
-        gfxFontFamily(aName) { }
-
-    FontEntry *FindFontEntry(const gfxFontStyle& aFontStyle);
-
-public:
-    nsTArray<nsRefPtr<FontEntry> > mFaces;
-};
-
-class FontEntry : public gfxFontEntry
-{
-public:
-    FontEntry(const nsAString& aFaceName) :
-        gfxFontEntry(aFaceName)
-    {
-        mFontFace = nsnull;
-        mFTFontIndex = 0;
-        mUnicodeFont = PR_FALSE;
-        mSymbolFont = PR_FALSE;
-    }
-
-    FontEntry(const FontEntry& aFontEntry);
-    ~FontEntry();
-
-    const nsString& GetName() const {
-        return mFaceName;
-    }
-
-    cairo_font_face_t *CairoFontFace();
-
-    cairo_font_face_t *mFontFace;
-
-    nsString mFaceName;
-    nsCString mFilename;
-    PRUint8 mFTFontIndex;
-
-    PRPackedBool mTrueType    : 1;
-    PRPackedBool mIsType1     : 1;
-};
-
-
-
-class gfxQtFont : public gfxFont {
-public: // new functions
-    gfxQtFont(FontEntry *aFontEntry,
-               const gfxFontStyle *aFontStyle);
-    virtual ~gfxQtFont ();
-
-    virtual const gfxFont::Metrics& GetMetrics();
-
-    cairo_font_face_t *CairoFontFace();
-    cairo_scaled_font_t *CairoScaledFont();
-
-    virtual PRBool SetupCairoFont(gfxContext *aContext);
-    virtual nsString GetUniqueName();
-    virtual PRUint32 GetSpaceGlyph();
-
-    FontEntry *GetFontEntry();
-private:
-    cairo_scaled_font_t *mScaledFont;
-
-    PRBool mHasSpaceGlyph;
-    PRUint32 mSpaceGlyph;
-    PRBool mHasMetrics;
-    Metrics mMetrics;
-    gfxFloat mAdjustedSize;
-
-};
-
-class THEBES_API gfxQtFontGroup : public gfxFontGroup {
-public: // new functions
-    gfxQtFontGroup (const nsAString& families,
-                    const gfxFontStyle *aStyle);
-    virtual ~gfxQtFontGroup ();
-
-    inline gfxQtFont *GetFontAt (PRInt32 i) {
-        return static_cast <gfxQtFont *>(static_cast <gfxFont *>(mFonts[i]));
-    }
-
-protected: // from gfxFontGroup
-    virtual gfxTextRun *MakeTextRun(const PRUnichar *aString, 
-                                    PRUint32 aLength,
-                                    const Parameters *aParams, 
-                                    PRUint32 aFlags);
-
-    virtual gfxTextRun *MakeTextRun(const PRUint8 *aString, 
-                                    PRUint32 aLength,
-                                    const Parameters *aParams, 
-                                    PRUint32 aFlags);
-
-    virtual gfxFontGroup *Copy(const gfxFontStyle *aStyle);
-
-
-protected: // new functions
-    void InitTextRun(gfxTextRun *aTextRun);
-
-    void CreateGlyphRunsFT(gfxTextRun *aTextRun);
-    void AddRange(gfxTextRun *aTextRun, gfxQtFont *font, const PRUnichar *str, PRUint32 len);
-
-    static PRBool FontCallback (const nsAString & fontName, 
-                                const nsACString & genericName, 
-                                void *closure);
-    PRBool mEnableKerning;
-
-    gfxQtFont *FindFontForChar(PRUint32 ch, PRUint32 prevCh, PRUint32 nextCh, gfxQtFont *aFont);
-    PRUint32 ComputeRanges();
-
-    struct TextRange {
-        TextRange(PRUint32 aStart,  PRUint32 aEnd) : start(aStart), end(aEnd) { }
-        PRUint32 Length() const { return end - start; }
-        nsRefPtr<gfxQtFont> font;
-        PRUint32 start, end;
-    };
-
-    nsTArray<TextRange> mRanges;
-    nsString mString;
-};
-
-#endif /* GFX_QTFONTS_H */
-
diff -r 6de576aeff11 gfx/thebes/src/Makefile.in
--- a/gfx/thebes/src/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/thebes/src/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -112,11 +112,11 @@ endif
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),qt)
 CPPSRCS += gfxQtPlatform.cpp gfxQPainterSurface.cpp
 CPPSRCS += gfxXlibSurface.cpp gfxQtNativeRenderer.cpp
-CPPSRCS += gfxQtFonts.cpp
+CPPSRCS +=	gfxFT2Fonts.cpp
 CPPSRCS +=	gfxFontconfigUtils.cpp
 CPPSRCS +=	nsUnicodeRange.cpp
 #CSRCS = cairo-xlib-utils.c
 EXTRA_DSO_LDOPTS += $(ZLIB_LIBS) $(MOZ_XFT_LIBS) $(XLDFLAGS) $(XLIBS) $(CAIRO_FT_LIBS)
 endif
diff -r 6de576aeff11 gfx/thebes/src/gfxFT2Fonts.cpp
--- a/gfx/thebes/src/gfxFT2Fonts.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/thebes/src/gfxFT2Fonts.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -32,11 +32,18 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+#if defined(MOZ_WIDGET_GTK2)
 #include "gfxPlatformGtk.h"
+#define gfxToolkitPlatform gfxPlatformGtk
+#elif defined(MOZ_WIDGET_QT)
+#include "gfxQtPlatform.h"
+#include <qfontinfo.h>
+#define gfxToolkitPlatform gfxQtPlatform
+#endif
 #include "gfxTypes.h"
 #include "gfxFT2Fonts.h"
 #include <locale.h>
 #include "cairo-ft.h"
 #include <freetype/tttables.h>
@@ -45,16 +52,11 @@
 /**
  * FontEntry
  */
 
 FontEntry::FontEntry(const FontEntry& aFontEntry) :
-    mFaceName(aFontEntry.mFaceName),
-    mUnicodeFont(aFontEntry.mUnicodeFont),
-    mSymbolFont(aFontEntry.mSymbolFont),
-    mItalic(aFontEntry.mItalic),
-    mWeight(aFontEntry.mWeight),
-    mCharacterMap(aFontEntry.mCharacterMap)
+    gfxFontEntry(aFontEntry)
 {
     if (aFontEntry.mFontFace)
         mFontFace = cairo_font_face_reference(aFontEntry.mFontFace);
     else
         mFontFace = nsnull;
@@ -73,18 +75,24 @@ FTFontDestroyFunc(void *data)
 {
     FT_Face face = (FT_Face)data;
     FT_Done_Face(face);
 }
 
+FontEntry*
+gfxFT2Font::GetFontEntry()
+{
+    return static_cast<FontEntry*> (mFontEntry.get());
+}
+
 cairo_font_face_t *
 FontEntry::CairoFontFace()
 {
     static cairo_user_data_key_t key;
 
     if (!mFontFace) {
         FT_Face face;
-        FT_New_Face(gfxPlatformGtk::GetPlatform()->GetFTLibrary(), mFilename.get(), mFTFontIndex, &face);
+        FT_New_Face(gfxToolkitPlatform::GetPlatform()->GetFTLibrary(), mFilename.get(), mFTFontIndex, &face);
         mFontFace = cairo_ft_font_face_create_for_ft_face(face, 0);
         cairo_font_face_set_user_data(mFontFace, &key, face, FTFontDestroyFunc);
     }
     return mFontFace;
 }
@@ -189,11 +197,11 @@ static already_AddRefed<gfxFT2Font>
 static already_AddRefed<gfxFT2Font>
 GetOrMakeFont(const nsAString& aName, const gfxFontStyle *aStyle)
 {
     nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(aName, aStyle);
     if (!font) {
-        FontEntry *fe = gfxPlatformGtk::GetPlatform()->FindFontEntry(aName, *aStyle);
+        FontEntry *fe = gfxToolkitPlatform::GetPlatform()->FindFontEntry(aName, *aStyle);
         if (!fe) {
             printf("Failed to find font entry for %s\n", NS_ConvertUTF16toUTF8(aName).get());
             return nsnull;
         }
 
@@ -218,16 +226,16 @@ gfxFT2FontGroup::gfxFT2FontGroup(const n
     nsStringArray familyArray;
     ForEachFont(FontCallback, &familyArray);
 
     if (familyArray.Count() == 0) {
         nsAutoString prefFamilies;
-        gfxPlatformGtk::GetPlatform()->GetPrefFonts(aStyle->langGroup.get(), prefFamilies, nsnull);
+        gfxToolkitPlatform::GetPlatform()->GetPrefFonts(aStyle->langGroup.get(), prefFamilies, nsnull);
         if (!prefFamilies.IsEmpty()) {
             ForEachFont(prefFamilies, aStyle->langGroup, FontCallback, &familyArray);
         }
     }
-#if 0 /* FIXME DFB */
+#if defined(MOZ_WIDGET_QT) /* FIXME DFB */
     if (familyArray.Count() == 0) {
         printf("failde to find a font. sadface\n");
         // We want to get rid of this entirely at some point, but first we need real lists of fonts.
         QFont defaultFont;
         QFontInfo fi (defaultFont);
@@ -619,13 +627,14 @@ gfxFT2Font::gfxFT2Font(FontEntry *aFontE
     : gfxFont(aFontEntry, aFontStyle),
     mScaledFont(nsnull),
     mHasSpaceGlyph(PR_FALSE),
     mSpaceGlyph(0),
     mHasMetrics(PR_FALSE),
-    mAdjustedSize(0),
-    mFontEntry(aFontEntry)
+    mAdjustedSize(0)
 {
+    mFontEntry = aFontEntry;
+    NS_ASSERTION(mFontEntry, "Unable to find font entry for font.  Something is whack.");
 }
 
 gfxFT2Font::~gfxFT2Font()
 {
     if (mScaledFont) {
@@ -801,11 +810,11 @@ gfxFT2Font::CairoFontFace()
 gfxFT2Font::CairoFontFace()
 {
     // XXX we need to handle fake bold here (or by having a sepaerate font entry)
     if (mStyle.weight >= 600 && mFontEntry->mWeight < 600)
         printf("** We want fake weight\n");
-    return mFontEntry->CairoFontFace();
+    return GetFontEntry()->CairoFontFace();
 }
 
 cairo_scaled_font_t *
 gfxFT2Font::CairoScaledFont()
 {
diff -r 6de576aeff11 gfx/thebes/src/gfxQtFonts.cpp
--- a/gfx/thebes/src/gfxQtFonts.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,955 +0,0 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Foundation code.
- *
- * The Initial Developer of the Original Code is Mozilla Foundation.
- * Portions created by the Initial Developer are Copyright (C) 2005
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "gfxQtPlatform.h"
-#include "gfxTypes.h"
-#include "gfxQtFonts.h"
-#include "qrect.h"
-#include <locale.h>
-#include <qfontinfo.h>
-#include "cairo-ft.h"
-#include <freetype/tttables.h>
-#include "gfxFontUtils.h"
-
-/**
- * FontEntry
- */
-
-FontEntry::FontEntry(const FontEntry& aFontEntry) :
-    gfxFontEntry(aFontEntry)
-{
-    if (aFontEntry.mFontFace)
-        mFontFace = cairo_font_face_reference(aFontEntry.mFontFace);
-    else
-        mFontFace = nsnull;
-}
-
-FontEntry::~FontEntry()
-{
-    if (mFontFace) {
-        cairo_font_face_destroy(mFontFace);
-        mFontFace = nsnull;
-    }
-}
-
-static void
-FTFontDestroyFunc(void *data)
-{
-    FT_Face face = (FT_Face)data;
-    FT_Done_Face(face);
-}
-
-cairo_font_face_t *
-FontEntry::CairoFontFace()
-{
-    static cairo_user_data_key_t key;
-
-    if (!mFontFace) {
-        FT_Face face;
-        FT_New_Face(gfxQtPlatform::GetPlatform()->GetFTLibrary(), mFilename.get(), mFTFontIndex, &face);
-        mFontFace = cairo_ft_font_face_create_for_ft_face(face, 0);
-        cairo_font_face_set_user_data(mFontFace, &key, face, FTFontDestroyFunc);
-    }
-    return mFontFace;
-}
-
-FontEntry *
-FontFamily::FindFontEntry(const gfxFontStyle& aFontStyle)
-{
-    PRBool italic = (aFontStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
-
-    FontEntry *weightList[10] = { 0 };
-    for (PRUint32 j = 0; j < 2; j++) {
-        PRBool matchesSomething = PR_FALSE;
-        // build up an array of weights that match the italicness we're looking for
-        for (PRUint32 i = 0; i < mFaces.Length(); i++) {
-            FontEntry *fe = mFaces[i];
-            const PRUint8 weight = (fe->mWeight / 100);
-            if (fe->mItalic == italic) {
-                weightList[weight] = fe;
-                matchesSomething = PR_TRUE;
-            }
-        }
-        if (matchesSomething)
-            break;
-        italic = !italic;
-    }
-
-    PRInt8 baseWeight, weightDistance;
-    aFontStyle.ComputeWeightAndOffset(&baseWeight, &weightDistance);
-
-    // 500 isn't quite bold so we want to treat it as 400 if we don't
-    // have a 500 weight
-    if (baseWeight == 5 && weightDistance == 0) {
-        // If we have a 500 weight then use it
-        if (weightList[5])
-            return weightList[5];
-
-        // Otherwise treat as 400
-        baseWeight = 4;
-    }
-
-    PRInt8 matchBaseWeight = 0;
-    PRInt8 direction = (baseWeight > 5) ? 1 : -1;
-    for (PRInt8 i = baseWeight; ; i += direction) {
-        if (weightList[i]) {
-            matchBaseWeight = i;
-            break;
-        }
-
-        // if we've reached one side without finding a font,
-        // go the other direction until we find a match
-        if (i == 1 || i == 9)
-            direction = -direction;
-    }
-
-    FontEntry *matchFE;
-    const PRInt8 absDistance = abs(weightDistance);
-    direction = (weightDistance >= 0) ? 1 : -1;
-    for (PRInt8 i = matchBaseWeight, k = 0; i < 10 && i > 0; i += direction) {
-        if (weightList[i]) {
-            matchFE = weightList[i];
-            k++;
-        }
-        if (k > absDistance)
-            break;
-    }
-
-    if (!matchFE)
-        matchFE = weightList[matchBaseWeight];
-
-    NS_ASSERTION(matchFE, "we should always be able to return something here");
-    return matchFE;
-}
-
-
-
-/**
- * gfxQtFontGroup
- */
-
-PRBool
-gfxQtFontGroup::FontCallback(const nsAString& fontName,
-                             const nsACString& genericName,
-                             void *closure)
-{
-    nsStringArray *sa = static_cast<nsStringArray*>(closure);
-
-    if (!fontName.IsEmpty() && sa->IndexOf(fontName) < 0) {
-        sa->AppendString(fontName);
-#ifdef DEBUG_pavlov
-        printf(" - %s\n", NS_ConvertUTF16toUTF8(fontName).get());
-#endif
-    }
-
-    return PR_TRUE;
-}
-
-/**
- * Look up the font in the gfxFont cache. If we don't find it, create one.
- * In either case, add a ref, append it to the aFonts array, and return it ---
- * except for OOM in which case we do nothing and return null.
- */
-static already_AddRefed<gfxQtFont>
-GetOrMakeFont(const nsAString& aName, const gfxFontStyle *aStyle)
-{
-    nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(aName, aStyle);
-    if (!font) {
-        FontEntry *fe = gfxQtPlatform::GetPlatform()->FindFontEntry(aName, *aStyle);
-        if (!fe) {
-            printf("Failed to find font entry for %s\n", NS_ConvertUTF16toUTF8(aName).get());
-            return nsnull;
-        }
-
-        font = new gfxQtFont(fe, aStyle);
-        if (!font)
-            return nsnull;
-        gfxFontCache::GetCache()->AddNew(font);
-    }
-    gfxFont *f = nsnull;
-    font.swap(f);
-    return static_cast<gfxQtFont *>(f);
-}
-
-
-gfxQtFontGroup::gfxQtFontGroup(const nsAString& families,
-                               const gfxFontStyle *aStyle)
-    : gfxFontGroup(families, aStyle)
-{
-#ifdef DEBUG_pavlov
-    printf("Looking for %s\n", NS_ConvertUTF16toUTF8(families).get());
-#endif
-    nsStringArray familyArray;
-    ForEachFont(FontCallback, &familyArray);
-
-    if (familyArray.Count() == 0) {
-        nsAutoString prefFamilies;
-        gfxQtPlatform::GetPlatform()->GetPrefFonts(aStyle->langGroup.get(), prefFamilies, nsnull);
-        if (!prefFamilies.IsEmpty()) {
-            ForEachFont(prefFamilies, aStyle->langGroup, FontCallback, &familyArray);
-        }
-    }
-    if (familyArray.Count() == 0) {
-        printf("failde to find a font. sadface\n");
-        // We want to get rid of this entirely at some point, but first we need real lists of fonts.
-        QFont defaultFont;
-        QFontInfo fi (defaultFont);
-        familyArray.AppendString(nsDependentString(static_cast<const PRUnichar *>(fi.family().utf16())));
-    }
-
-    for (int i = 0; i < familyArray.Count(); i++) {
-        nsRefPtr<gfxQtFont> font = GetOrMakeFont(*familyArray[i], &mStyle);
-        if (font) {
-            mFonts.AppendElement(font);
-        }
-    }
-}
-
-gfxQtFontGroup::~gfxQtFontGroup()
-{
-}
-
-gfxFontGroup *
-gfxQtFontGroup::Copy(const gfxFontStyle *aStyle)
-{
-     return new gfxQtFontGroup(mFamilies, aStyle);
-}
-
-/**
- * We use this to append an LTR or RTL Override character to the start of the
- * string. This forces Pango to honour our direction even if there are neutral
- * characters in the string.
- */
-static PRInt32 AppendDirectionalIndicatorUTF8(PRBool aIsRTL, nsACString& aString)
-{
-    static const PRUnichar overrides[2][2] = { { 0x202d, 0 }, { 0x202e, 0 }}; // LRO, RLO
-    AppendUTF16toUTF8(overrides[aIsRTL], aString);
-    return 3; // both overrides map to 3 bytes in UTF8
-}
-
-gfxTextRun *gfxQtFontGroup::MakeTextRun(const PRUnichar* aString, PRUint32 aLength,
-                                        const Parameters* aParams, PRUint32 aFlags)
-{
-    gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
-    if (!textRun)
-        return nsnull;
-
-    textRun->RecordSurrogates(aString);
-
-    mString.Assign(nsDependentSubstring(aString, aString + aLength));
-
-    InitTextRun(textRun);
-
-    textRun->FetchGlyphExtents(aParams->mContext);
-
-    return textRun;
-}
-
-gfxTextRun *gfxQtFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
-                                        const Parameters *aParams, PRUint32 aFlags)
-{
-    NS_ASSERTION(aFlags & TEXT_IS_8BIT, "8bit should have been set");
-    gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
-    if (!textRun)
-        return nsnull;
-
-    const char *chars = reinterpret_cast<const char *>(aString);
-
-    mString.Assign(NS_ConvertASCIItoUTF16(nsDependentCSubstring(chars, chars + aLength)));
-
-    InitTextRun(textRun);
-
-    textRun->FetchGlyphExtents(aParams->mContext);
-
-    return textRun;
-}
-
-void gfxQtFontGroup::InitTextRun(gfxTextRun *aTextRun)
-{
-    CreateGlyphRunsFT(aTextRun);
-}
-
-
-// Helper function to return the leading UTF-8 character in a char pointer
-// as 32bit number. Also sets the length of the current character (i.e. the
-// offset to the next one) in the second argument
-PRUint32 getUTF8CharAndNext(const PRUint8 *aString, PRUint8 *aLength)
-{
-    *aLength = 1;
-    if (aString[0] < 0x80) { // normal 7bit ASCII char
-        return aString[0];
-    }
-    if ((aString[0] >> 5) == 6) { // two leading ones -> two bytes
-        *aLength = 2;
-        return ((aString[0] & 0x1F) << 6) + (aString[1] & 0x3F);
-    }
-    if ((aString[0] >> 4) == 14) { // three leading ones -> three bytes
-        *aLength = 3;
-        return ((aString[0] & 0x0F) << 12) + ((aString[1] & 0x3F) << 6) +
-               (aString[2] & 0x3F);
-    }
-    if ((aString[0] >> 4) == 15) { // four leading ones -> four bytes
-        *aLength = 4;
-        return ((aString[0] & 0x07) << 18) + ((aString[1] & 0x3F) << 12) +
-               ((aString[2] & 0x3F) <<  6) + (aString[3] & 0x3F);
-    }
-    return aString[0];
-}
-
-
-
-
-
-
-
-
-PRBool
-HasCharacter(gfxQtFont *aFont, PRUint32 ch)
-{
-    if (aFont->GetFontEntry()->mCharacterMap.test(ch))
-        return PR_TRUE;
-
-    // XXX move this lock way way out
-    FT_Face face = cairo_ft_scaled_font_lock_face(aFont->CairoScaledFont());
-    FT_UInt gid = FT_Get_Char_Index(face, ch);
-    cairo_ft_scaled_font_unlock_face(aFont->CairoScaledFont());
-
-    if (gid != 0) {
-        aFont->GetFontEntry()->mCharacterMap.set(ch);
-        return PR_TRUE;
-    }
-    return PR_FALSE;
-}
-
-#if 0
-inline FontEntry *
-gfxQtFontGroup::WhichFontSupportsChar(const nsTArray<>& foo, PRUint32 ch)
-{
-    for (int i = 0; i < aGroup->FontListLength(); i++) {
-        nsRefPtr<gfxQtFont> font = aGroup->GetFontAt(i);
-        if (HasCharacter(font, ch))
-            return font;
-    }
-    return nsnull;
-}
-#endif
-
-inline gfxQtFont *
-gfxQtFontGroup::FindFontForChar(PRUint32 ch, PRUint32 prevCh, PRUint32 nextCh, gfxQtFont *aFont)
-{
-    gfxQtFont *selectedFont;
-
-    // if this character or the next one is a joiner use the
-    // same font as the previous range if we can
-    if (gfxFontUtils::IsJoiner(ch) || gfxFontUtils::IsJoiner(prevCh) || gfxFontUtils::IsJoiner(nextCh)) {
-        if (aFont && HasCharacter(aFont, ch))
-            return aFont;
-    }
-
-    for (PRUint32 i = 0; i < FontListLength(); i++) {
-        nsRefPtr<gfxQtFont> font = GetFontAt(i);
-        if (HasCharacter(font, ch))
-            return font;
-    }
-    return nsnull;
-
-#if 0
-    // check the list of fonts
-    selectedFont = WhichFontSupportsChar(mGroup->GetFontList(), ch);
-
-
-    // don't look in other fonts if the character is in a Private Use Area
-    if ((ch >= 0xE000  && ch <= 0xF8FF) || 
-        (ch >= 0xF0000 && ch <= 0x10FFFD))
-        return selectedFont;
-
-    // check out the style's language group
-    if (!selectedFont) {
-        nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
-        this->GetPrefFonts(mGroup->GetStyle()->langGroup.get(), fonts);
-        selectedFont = WhichFontSupportsChar(fonts, ch);
-    }
-
-    // otherwise search prefs
-    if (!selectedFont) {
-        /* first check with the script properties to see what they think */
-        if (ch <= 0xFFFF) {
-            PRUint32 unicodeRange = FindCharUnicodeRange(ch);
-            
-            /* special case CJK */
-            if (unicodeRange == kRangeSetCJK) {
-                if (PR_LOG_TEST(gFontLog, PR_LOG_DEBUG))
-                    PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: CJK"));
-
-                nsAutoTArray<nsRefPtr<FontEntry>, 15> fonts;
-                this->GetCJKPrefFonts(fonts);
-                selectedFont = WhichFontSupportsChar(fonts, ch);
-            } else {
-                const char *langGroup = LangGroupFromUnicodeRange(unicodeRange);
-                if (langGroup) {
-                    PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: %s", langGroup));
-
-                    nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
-                    this->GetPrefFonts(langGroup, fonts);
-                    selectedFont = WhichFontSupportsChar(fonts, ch);
-                }
-            }
-        }
-    }
-
-    // before searching for something else check the font used for the previous character
-    if (!selectedFont && aFont && HasCharacter(aFont, ch))
-        selectedFont = aFont;
-
-    // otherwise look for other stuff
-    if (!selectedFont) {
-        PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Looking for best match"));
-        
-        nsRefPtr<gfxWindowsFont> refFont = mGroup->GetFontAt(0);
-        gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
-        selectedFont = platform->FindFontForChar(ch, refFont);
-    }
-
-    return selectedFont;
-#endif
-}
-
-PRUint32
-gfxQtFontGroup::ComputeRanges()
-{
-    const PRUnichar *str = mString.get();
-    PRUint32 len = mString.Length();
-
-    mRanges.Clear();
-
-    PRUint32 prevCh = 0;
-    for (PRUint32 i = 0; i < len; i++) {
-        const PRUint32 origI = i; // save off incase we increase for surrogate
-        PRUint32 ch = str[i];
-        if ((i+1 < len) && NS_IS_HIGH_SURROGATE(ch) && NS_IS_LOW_SURROGATE(str[i+1])) {
-            i++;
-            ch = SURROGATE_TO_UCS4(ch, str[i]);
-        }
-
-        PRUint32 nextCh = 0;
-        if (i+1 < len) {
-            nextCh = str[i+1];
-            if ((i+2 < len) && NS_IS_HIGH_SURROGATE(ch) && NS_IS_LOW_SURROGATE(str[i+2]))
-                nextCh = SURROGATE_TO_UCS4(nextCh, str[i+2]);
-        }
-        gfxQtFont *fe = FindFontForChar(ch,
-                                        prevCh,
-                                        nextCh,
-                                        (mRanges.Length() == 0) ? nsnull : mRanges[mRanges.Length() - 1].font);
-
-        prevCh = ch;
-
-        if (mRanges.Length() == 0) {
-            TextRange r(0,1);
-            r.font = fe;
-            mRanges.AppendElement(r);
-        } else {
-            TextRange& prevRange = mRanges[mRanges.Length() - 1];
-            if (prevRange.font != fe) {
-                // close out the previous range
-                prevRange.end = origI;
-
-                TextRange r(origI, i+1);
-                r.font = fe;
-                mRanges.AppendElement(r);
-            }
-        }
-    }
-    mRanges[mRanges.Length()-1].end = len;
-
-    PRUint32 nranges = mRanges.Length();
-    return nranges;
-}
-
-void gfxQtFontGroup::CreateGlyphRunsFT(gfxTextRun *aTextRun)
-{
-#if 0
-    QString str(aUTF8, aUTF8Length);
-    QStackTextEngine engine(str, mQFont);
-    const Qt::LayoutDirection dir = aTextRun->IsRightToLeft() ? Qt::RightToLeft : Qt::LeftTRight;
-    engine.option.setTextDirection(dir);
-    engine.ignoreBidi = true;
-
-    // itemize
-    engine.itemize();
-
-
-    // XXX i think at this point we want to create a new textengine for each item
-    
-    // ...
-    QScriptLine line;
-    line.length = str.length();
-    engine.shapeLine(line);
-
-    int nItems = engine.layoutData->items.size();
-    QVarLengthArray<int> visualOrder(nItems);
-    QVarLengthArray<uchar> levels(nItems);
-    for (int i = 0; i < nItems; ++i)
-        levels[i] = engine.layoutData->items[i].analysis.bidiLevel;
-    QTextEngine::bidiReorder(nItems, levels.data(), visualOrder.data());
-
-    QFixed x = QFixed::fromReal(p.x());
-    QFixed ox = x;
-
-    for (int i = 0; i < nItems; ++i) {
-        int item = visualOrder[i];
-        const QScriptItem &si = engine.layoutData->items.at(item);
-        if (si.analysis.flags >= QScriptAnalysis::TabOrObject) {
-            x += si.width;
-            continue;
-        }
-        QFont f = engine.font(si);
-        /*
-          QTextItemInt gf(si, &f);
-          gf.num_glyphs = si.num_glyphs;
-          gf.glyphs = engine.glyphs(&si);
-          gf.chars = engine.layoutData->string.unicode() + si.position;
-          gf.num_chars = engine.length(item);
-          gf.width = si.width;
-          gf.logClusters = engine.logClusters(&si);
-
-          // drawTextItem(QPointF(x.toReal(), p.y()), gf);
-        */
-
-        const PRUint8 *p = aUTF8;
-        PRUint32 utf16Offset = 0;
-        gfxTextRun::CompressedGlyph g;
-
-        aTextRun->AddGlyphRun(font, 0);
-        // a textRun likely has the same font for most of the characters, so we can
-        // lock it before the loop for efficiency
-        FT_Face face =  font->GetQFont().freetypeFace();
-        while (p < aUTF8 + aUTF8Length) {
-            // convert UTF-8 character and step to the next one in line
-            PRUint8 chLen;
-        }
-        if (advance >= 0 &&
-            gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
-            gfxTextRun::CompressedGlyph::IsSimpleGlyphID(gid))
-            {
-                aTextRun->SetSimpleGlyph(utf16Offset,
-                                         g.SetSimpleGlyph(advance, gid));
-                glyphFound = PR_TRUE;
-            } else if (gid == 0) {
-            // gid = 0 only happens when the glyph is missing from the font
-            if (i == fontlistLast) {
-                // set the missing glyph only when it's missing from the very
-                // last font
-                aTextRun->SetMissingGlyph(utf16Offset, ch);
-            }
-            glyphFound = PR_FALSE;
-        } else {
-            gfxTextRun::DetailedGlyph details;
-            details.mGlyphID = gid;
-            NS_ASSERTION(details.mGlyphID == gid, "Seriously weird glyph ID detected!");
-            details.mAdvance = advance;
-            details.mXOffset = 0;
-            details.mYOffset = 0;
-            g.SetComplex(aTextRun->IsClusterStart(utf16Offset), PR_TRUE, 1);
-            aTextRun->SetGlyphs(utf16Offset, g, &details);
-            glyphFound = PR_TRUE;
-        }
-
-        x += si.width;
-    }
-#endif
-
-    ComputeRanges();
-
-    const PRUnichar *strStart = mString.get();
-    for (PRUint32 i = 0; i < mRanges.Length(); ++i) {
-        const TextRange& range = mRanges[i];
-        const PRUnichar *rangeString = strStart + range.start;
-        PRUint32 rangeLength = range.Length();
-
-        gfxQtFont *font = range.font ? range.font.get() : GetFontAt(0);
-        AddRange(aTextRun, font, rangeString, rangeLength);
-    }
-    
-}
-
-void
-gfxQtFontGroup::AddRange(gfxTextRun *aTextRun, gfxQtFont *font, const PRUnichar *str, PRUint32 len)
-{
-    const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
-    // we'll pass this in/figure it out dynamically, but at this point there can be only one face.
-    FT_Face face = cairo_ft_scaled_font_lock_face(font->CairoScaledFont());
-
-    gfxTextRun::CompressedGlyph g;
-
-    aTextRun->AddGlyphRun(font, 0);
-    for (PRUint32 i = 0; i < len; i++) {
-        PRUint32 ch = str[i];
-
-        if (ch == 0) {
-            // treat this null byte as a missing glyph, don't create a glyph for it
-            aTextRun->SetMissingGlyph(i, 0);
-            continue;
-        }
-
-        NS_ASSERTION(!IsInvalidChar(ch), "Invalid char detected");
-        FT_UInt gid = FT_Get_Char_Index(face, ch); // find the glyph id
-        PRInt32 advance = 0;
-
-        if (gid == font->GetSpaceGlyph()) {
-            advance = (int)(font->GetMetrics().spaceWidth * appUnitsPerDevUnit);
-        } else if (gid == 0) {
-            advance = -1; // trigger the missing glyphs case below
-        } else {
-            // find next character and its glyph -- in case they exist
-            // and exist in the current font face -- to compute kerning
-            PRUint32 chNext = 0;
-            FT_UInt gidNext = 0;
-            FT_Pos lsbDeltaNext = 0;
-
-            if (FT_HAS_KERNING(face) && i + 1 < len) {
-                chNext = str[i+1];
-                if (chNext != 0) {
-                    gidNext = FT_Get_Char_Index(face, chNext);
-                    if (gidNext && gidNext != font->GetSpaceGlyph()) {
-                        FT_Load_Glyph(face, gidNext, FT_LOAD_DEFAULT);
-                        lsbDeltaNext = face->glyph->lsb_delta;
-                    }
-                }
-            }
-
-            // now load the current glyph
-            FT_Load_Glyph(face, gid, FT_LOAD_DEFAULT); // load glyph into the slot
-            advance = face->glyph->advance.x;
-
-            // now add kerning to the current glyph's advance
-            if (chNext && gidNext) {
-                FT_Vector kerning; kerning.x = 0;
-                FT_Get_Kerning(face, gid, gidNext, FT_KERNING_DEFAULT, &kerning);
-                advance += kerning.x;
-                if (face->glyph->rsb_delta - lsbDeltaNext >= 32) {
-                    advance -= 64;
-                } else if (face->glyph->rsb_delta - lsbDeltaNext < -32) {
-                    advance += 64;
-                }
-            }
-
-            // now apply unit conversion and scaling
-            advance = (advance >> 6) * appUnitsPerDevUnit;
-        }
-#ifdef DEBUG_thebes_2
-        printf(" gid=%d, advance=%d (%s)\n", gid, advance,
-               NS_LossyConvertUTF16toASCII(font->GetName()).get());
-#endif
-
-        if (advance >= 0 &&
-            gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
-            gfxTextRun::CompressedGlyph::IsSimpleGlyphID(gid)) {
-            aTextRun->SetSimpleGlyph(i, g.SetSimpleGlyph(advance, gid));
-        } else if (gid == 0) {
-            // gid = 0 only happens when the glyph is missing from the font
-            aTextRun->SetMissingGlyph(i, ch);
-        } else {
-            gfxTextRun::DetailedGlyph details;
-            details.mGlyphID = gid;
-            NS_ASSERTION(details.mGlyphID == gid, "Seriously weird glyph ID detected!");
-            details.mAdvance = advance;
-            details.mXOffset = 0;
-            details.mYOffset = 0;
-            g.SetComplex(aTextRun->IsClusterStart(i), PR_TRUE, 1);
-            aTextRun->SetGlyphs(i, g, &details);
-        }
-    }
-
-    cairo_ft_scaled_font_unlock_face(font->CairoScaledFont());
-}
-
-/**
- * gfxQtFont
- */
-gfxQtFont::gfxQtFont(FontEntry *aFontEntry,
-                     const gfxFontStyle *aFontStyle)
-    : gfxFont(aFontEntry, aFontStyle),
-    mScaledFont(nsnull),
-    mHasSpaceGlyph(PR_FALSE),
-    mSpaceGlyph(0),
-    mHasMetrics(PR_FALSE),
-    mAdjustedSize(0)
-{
-    mFontEntry = aFontEntry;
-    NS_ASSERTION(mFontEntry, "Unable to find font entry for font.  Something is whack.");
-}
-
-gfxQtFont::~gfxQtFont()
-{
-    if (mScaledFont) {
-        cairo_scaled_font_destroy(mScaledFont);
-        mScaledFont = nsnull;
-    }
-}
-
-// rounding and truncation functions for a Freetype floating point number 
-// (FT26Dot6) stored in a 32bit integer with high 26 bits for the integer
-// part and low 6 bits for the fractional part. 
-#define MOZ_FT_ROUND(x) (((x) + 32) & ~63) // 63 = 2^6 - 1
-#define MOZ_FT_TRUNC(x) ((x) >> 6)
-#define CONVERT_DESIGN_UNITS_TO_PIXELS(v, s) \
-        MOZ_FT_TRUNC(MOZ_FT_ROUND(FT_MulFix((v) , (s))))
-
-const gfxFont::Metrics&
-gfxQtFont::GetMetrics()
-{
-    if (mHasMetrics)
-        return mMetrics;
-
-    mMetrics.emHeight = GetStyle()->size;
-
-    FT_Face face = cairo_ft_scaled_font_lock_face(CairoScaledFont());
-
-    if (!face) {
-        // Abort here already, otherwise we crash in the following
-        // this can happen if the font-size requested is zero.
-        // The metrics will be incomplete, but then we don't care.
-        return mMetrics;
-    }
-
-    mMetrics.emHeight = GetStyle()->size;
-
-    FT_UInt gid; // glyph ID
-
-    const double emUnit = 1.0 * face->units_per_EM;
-    const double xScale = face->size->metrics.x_ppem / emUnit;
-    const double yScale = face->size->metrics.y_ppem / emUnit;
-
-    // properties of space
-    gid = FT_Get_Char_Index(face, ' ');
-    if (gid) {
-        FT_Load_Glyph(face, gid, FT_LOAD_DEFAULT);
-        // face->glyph->metrics.width doesn't work for spaces, use advance.x instead
-        mMetrics.spaceWidth = face->glyph->advance.x >> 6;
-        // save the space glyph
-        mSpaceGlyph = gid;
-    } else {
-        NS_ASSERTION(0, "blah");
-    }
-            
-    // properties of 'x', also use its width as average width
-    gid = FT_Get_Char_Index(face, 'x'); // select the glyph
-    if (gid) {
-        // Load glyph into glyph slot. Here, use no_scale to get font units.
-        FT_Load_Glyph(face, gid, FT_LOAD_NO_SCALE);
-        mMetrics.xHeight = face->glyph->metrics.height * yScale;
-        mMetrics.aveCharWidth = face->glyph->metrics.width * xScale;
-    } else {
-        // this font doesn't have an 'x'...
-        // fake these metrics using a fraction of the font size
-        mMetrics.xHeight = mMetrics.emHeight * 0.5;
-        mMetrics.aveCharWidth = mMetrics.emHeight * 0.5;
-    }
-
-    // compute an adjusted size if we need to
-    if (mAdjustedSize == 0 && GetStyle()->sizeAdjust != 0) {
-        gfxFloat aspect = mMetrics.xHeight / GetStyle()->size;
-        mAdjustedSize = GetStyle()->GetAdjustedSize(aspect);
-        mMetrics.emHeight = mAdjustedSize;
-    }
-
-    // now load the OS/2 TrueType table to load access some more properties
-    TT_OS2 *os2 = (TT_OS2 *)FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-    if (os2 && os2->version != 0xFFFF) { // should be there if not old Mac font
-        // if we are here we can improve the avgCharWidth
-        mMetrics.aveCharWidth = os2->xAvgCharWidth * xScale;
-
-        mMetrics.superscriptOffset = os2->ySuperscriptYOffset * yScale;
-        mMetrics.superscriptOffset = PR_MAX(1, mMetrics.superscriptOffset);
-        // some fonts have the incorrect sign (from gfxPangoFonts)
-        mMetrics.subscriptOffset   = fabs(os2->ySubscriptYOffset * yScale);
-        mMetrics.subscriptOffset   = PR_MAX(1, fabs(mMetrics.subscriptOffset));
-        mMetrics.strikeoutOffset   = os2->yStrikeoutPosition * yScale;
-        mMetrics.strikeoutSize     = os2->yStrikeoutSize * yScale;
-    } else {
-        // use fractions of emHeight instead of xHeight for these to be more robust
-        mMetrics.superscriptOffset = mMetrics.emHeight * 0.5;
-        mMetrics.subscriptOffset   = mMetrics.emHeight * 0.2;
-        mMetrics.strikeoutOffset   = mMetrics.emHeight * 0.3;
-        mMetrics.strikeoutSize     = face->underline_thickness * yScale;
-    }
-    // seems that underlineOffset really has to be negative
-    mMetrics.underlineOffset = face->underline_position * yScale;
-    mMetrics.underlineSize   = face->underline_thickness * yScale;
-
-    // descents are negative in FT but Thebes wants them positive
-    mMetrics.emAscent        = face->ascender * yScale;
-    mMetrics.emDescent       = -face->descender * yScale;
-    mMetrics.maxHeight       = face->height * yScale;
-    mMetrics.maxAscent       = face->bbox.yMax * yScale;
-    mMetrics.maxDescent      = -face->bbox.yMin * yScale;
-    mMetrics.maxAdvance      = face->max_advance_width * xScale;
-    // leading are not available directly (only for WinFNTs)
-    double lineHeight = mMetrics.maxAscent + mMetrics.maxDescent;
-    if (lineHeight > mMetrics.emHeight) {
-        mMetrics.internalLeading = lineHeight - mMetrics.emHeight;
-    } else {
-        mMetrics.internalLeading = 0;
-    }
-    mMetrics.externalLeading = 0; // normal value for OS/2 fonts, too
-
-    SanitizeMetrics(&mMetrics, PR_FALSE);
-
-    /*
-    printf("gfxOS2Font[%#x]::GetMetrics():\n"
-           "  emHeight=%f == %f=gfxFont::style.size == %f=adjSz\n"
-           "  maxHeight=%f  xHeight=%f\n"
-           "  aveCharWidth=%f==xWidth  spaceWidth=%f\n"
-           "  supOff=%f SubOff=%f   strOff=%f strSz=%f\n"
-           "  undOff=%f undSz=%f    intLead=%f extLead=%f\n"
-           "  emAsc=%f emDesc=%f maxH=%f\n"
-           "  maxAsc=%f maxDes=%f maxAdv=%f\n",
-           (unsigned)this,
-           mMetrics.emHeight, GetStyle()->size, mAdjustedSize,
-           mMetrics.maxHeight, mMetrics.xHeight,
-           mMetrics.aveCharWidth, mMetrics.spaceWidth,
-           mMetrics.superscriptOffset, mMetrics.subscriptOffset,
-           mMetrics.strikeoutOffset, mMetrics.strikeoutSize,
-           mMetrics.underlineOffset, mMetrics.underlineSize,
-           mMetrics.internalLeading, mMetrics.externalLeading,
-           mMetrics.emAscent, mMetrics.emDescent, mMetrics.maxHeight,
-           mMetrics.maxAscent, mMetrics.maxDescent, mMetrics.maxAdvance
-          );
-    */
-
-    // XXX mMetrics.height needs to be set.
-    cairo_ft_scaled_font_unlock_face(CairoScaledFont());
-
-    mHasMetrics = PR_TRUE;
-    return mMetrics;
-}
-
-
-nsString
-gfxQtFont::GetUniqueName()
-{
-    return GetFontEntry()->Name();
-}
-
-PRUint32
-gfxQtFont::GetSpaceGlyph()
-{
-    NS_ASSERTION (GetStyle ()->size != 0,
-    "forgot to short-circuit a text run with zero-sized font?");
-
-    if(!mHasSpaceGlyph)
-    {
-        FT_UInt gid = 0; // glyph ID
-        FT_Face face = cairo_ft_scaled_font_lock_face(CairoScaledFont());
-        gid = FT_Get_Char_Index(face, ' ');
-        FT_Load_Glyph(face, gid, FT_LOAD_DEFAULT);
-        mSpaceGlyph = gid;
-        mHasSpaceGlyph = PR_TRUE;
-        cairo_ft_scaled_font_unlock_face(CairoScaledFont());
-    }
-    return mSpaceGlyph;
-}
-
-FontEntry*
-gfxQtFont::GetFontEntry()
-{
-    return static_cast<FontEntry*> (mFontEntry.get());
-}
-
-cairo_font_face_t *
-gfxQtFont::CairoFontFace()
-{
-    // XXX we need to handle fake bold here (or by having a sepaerate font entry)
-    if (mStyle.weight >= 600 && GetFontEntry()->mWeight < 600)
-        printf("** We want fake weight\n");
-    return GetFontEntry()->CairoFontFace();
-}
-
-cairo_scaled_font_t *
-gfxQtFont::CairoScaledFont()
-{
-    if (!mScaledFont) {
-        cairo_matrix_t sizeMatrix;
-        cairo_matrix_t identityMatrix;
-
-        // XXX deal with adjusted size
-        cairo_matrix_init_scale(&sizeMatrix, mStyle.size, mStyle.size);
-        cairo_matrix_init_identity(&identityMatrix);
-
-        // synthetic oblique by skewing via the font matrix
-        PRBool needsOblique = (!GetFontEntry()->mItalic && (mStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)));
-
-        if (needsOblique) {
-            const double kSkewFactor = 0.25;
-
-            cairo_matrix_t style;
-            cairo_matrix_init(&style,
-                              1,                //xx
-                              0,                //yx
-                              -1 * kSkewFactor,  //xy
-                              1,                //yy
-                              0,                //x0
-                              0);               //y0
-            cairo_matrix_multiply(&sizeMatrix, &sizeMatrix, &style);
-        }
-
-        cairo_font_options_t *fontOptions = cairo_font_options_create();
-        mScaledFont = cairo_scaled_font_create(CairoFontFace(), &sizeMatrix,
-                                               &identityMatrix, fontOptions);
-        cairo_font_options_destroy(fontOptions);
-    }
-
-    NS_ASSERTION(mAdjustedSize == 0.0 ||
-                 cairo_scaled_font_status(mScaledFont) == CAIRO_STATUS_SUCCESS,
-                 "Failed to make scaled font");
-
-    return mScaledFont;
-}
-
-PRBool
-gfxQtFont::SetupCairoFont(gfxContext *aContext)
-{
-    cairo_scaled_font_t *scaledFont = CairoScaledFont();
-
-    if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {
-        // Don't cairo_set_scaled_font as that would propagate the error to
-        // the cairo_t, precluding any further drawing.
-        return PR_FALSE;
-    }
-    cairo_set_scaled_font(aContext->GetCairo(), scaledFont);
-    return PR_TRUE;
-}
diff -r 6de576aeff11 gfx/thebes/src/gfxQtPlatform.cpp
--- a/gfx/thebes/src/gfxQtPlatform.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/thebes/src/gfxQtPlatform.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -48,11 +48,11 @@
 #include "cairo.h"
 
 #include "gfxImageSurface.h"
 #include "gfxQPainterSurface.h"
 
-#include "gfxQtFonts.h"
+#include "gfxFT2Fonts.h"
 
 #include "nsUnicharUtils.h"
 
 #include <fontconfig/fontconfig.h>
 
@@ -337,11 +337,11 @@ gfxQtPlatform::GetStandardFamilyName(con
 
 gfxFontGroup *
 gfxQtPlatform::CreateFontGroup(const nsAString &aFamilies,
                                const gfxFontStyle *aStyle)
 {
-    return new gfxQtFontGroup(aFamilies, aStyle);
+    return new gfxFT2FontGroup(aFamilies, aStyle);
 }
 
 /* static */
 void
 gfxQtPlatform::InitDPI()
diff -r 6de576aeff11 gfx/thebes/src/gfxWindowsFonts.cpp
--- a/gfx/thebes/src/gfxWindowsFonts.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/thebes/src/gfxWindowsFonts.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -640,11 +640,11 @@ gfxWindowsFont::ComputeMetrics()
       mMetrics->maxAdvance = mMetrics->aveCharWidth;
     }
 
     // Cache the width of a single space.
     SIZE size;
-    GetTextExtentPoint32(dc, " ", 1, &size);
+    GetTextExtentPoint32W(dc, L" ", 1, &size);
     mMetrics->spaceWidth = ROUND(size.cx);
 
     // Cache the width of digit zero.
     // XXX MSDN (http://msdn.microsoft.com/en-us/library/ms534223.aspx)
     // does not say what the failure modes for GetTextExtentPoint32 are -
@@ -655,11 +655,11 @@ gfxWindowsFont::ComputeMetrics()
         mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
 
     mSpaceGlyph = 0;
     if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
         WORD glyph;
-        DWORD ret = GetGlyphIndicesA(dc, " ", 1, &glyph,
+        DWORD ret = GetGlyphIndicesW(dc, L" ", 1, &glyph,
                                      GGI_MARK_NONEXISTING_GLYPHS);
         if (ret != GDI_ERROR && glyph != 0xFFFF) {
             mSpaceGlyph = glyph;
         }
     }
diff -r 6de576aeff11 gfx/thebes/src/gfxWindowsSurface.cpp
--- a/gfx/thebes/src/gfxWindowsSurface.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/gfx/thebes/src/gfxWindowsSurface.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -166,58 +166,30 @@ gfxWindowsSurface::OptimizeToDDB(HDC dc,
     gfxWindowsSurface *raw = (gfxWindowsSurface*) (wsurf.get());
     NS_ADDREF(raw);
     return raw;
 }
 
-static char*
-GetACPString(const nsAString& aStr)
-{
-    int acplen = aStr.Length() * 2 + 1;
-    char * acp = new char[acplen];
-    if(acp) {
-        int outlen = ::WideCharToMultiByte(CP_ACP, 0, 
-                                           PromiseFlatString(aStr).get(),
-                                           aStr.Length(),
-                                           acp, acplen, NULL, NULL);
-        if (outlen > 0)
-            acp[outlen] = '\0';  // null terminate
-    }
-    return acp;
-}
-
 nsresult gfxWindowsSurface::BeginPrinting(const nsAString& aTitle,
                                           const nsAString& aPrintToFileName)
 {
 #define DOC_TITLE_LENGTH 30
-    DOCINFO docinfo;
+    DOCINFOW docinfo;
 
-    nsString titleStr;
-    titleStr = aTitle;
+    nsString titleStr(aTitle);
     if (titleStr.Length() > DOC_TITLE_LENGTH) {
         titleStr.SetLength(DOC_TITLE_LENGTH-3);
         titleStr.AppendLiteral("...");
     }
-    char *title = GetACPString(titleStr);
 
-    char *docName = nsnull;
-    if (!aPrintToFileName.IsEmpty()) {
-        docName = ToNewCString(aPrintToFileName);
-    }
-
+    nsString docName(aPrintToFileName);
     docinfo.cbSize = sizeof(docinfo);
-    docinfo.lpszDocName = title ? title : "Mozilla Document";
-    docinfo.lpszOutput = docName;
+    docinfo.lpszDocName = titleStr.Length() > 0 ? titleStr.get() : L"Mozilla Document";
+    docinfo.lpszOutput = docName.Length() > 0 ? docName.get() : nsnull;
     docinfo.lpszDatatype = NULL;
     docinfo.fwType = 0;
 
-    int result = ::StartDoc(mDC, &docinfo);
-        
-    delete [] title;
-    if (docName != nsnull) nsMemory::Free(docName);
-
-    if (result <= 0)
-        return NS_ERROR_FAILURE;
+    ::StartDocW(mDC, &docinfo);
 
     return NS_OK;
 }
 
 nsresult gfxWindowsSurface::EndPrinting()
diff -r 6de576aeff11 js/src/Makefile.in
--- a/js/src/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/Makefile.in	Thu Aug 28 21:06:41 2008 +0300
@@ -373,15 +373,13 @@ CXXFLAGS += -IC:/Program\ Files/Intel/VT
 CXXFLAGS += -IC:/Program\ Files/Intel/VTune/Analyzer/Include
 EXTRA_DSO_LDOPTS += C:/Program\ Files/Intel/VTune/Analyzer/Lib/VtuneApi.lib
 LIBS +=  C:/Program\ Files/Intel/VTune/Analyzer/Lib/VtuneApi.lib
 endif
 
-LDFLAGS		+= $(pathsubst -l%,$(NSPR_STATIC_PATH)/%.a,$(NSPR_LIBS))
-
 # BeOS and HP-UX do not require the extra linking of "-lm"
 ifeq (,$(filter BeOS HP-UX WINNT WINCE OpenVMS,$(OS_ARCH)))
-LDFLAGS		+= -lm
+EXTRA_LIBS	+= -lm
 endif
 
 # Prevent floating point errors caused by VC++ optimizations
 ifeq ($(OS_ARCH)_$(GNU_CC),WINNT_)
 ifeq (,$(filter-out 1200 1300 1310,$(_MSC_VER)))
@@ -390,22 +388,22 @@ CFLAGS += -fp:precise
 CFLAGS += -fp:precise
 endif
 endif # WINNT
 
 ifeq ($(OS_ARCH),FreeBSD)
-LDFLAGS		+= -pthread
+EXTRA_LIBS	+= -pthread
 endif
 ifeq ($(OS_ARCH),IRIX)
 ifdef USE_N32
 DASH_R		+= -n32
 endif
 endif
 ifeq ($(OS_ARCH),Linux)
-LDFLAGS		+= -ldl
+EXTRA_LIBS	+= -ldl
 endif
 ifeq ($(OS_ARCH),OSF1)
-LDFLAGS		+= -lc_r
+EXTRA_LIBS	+= -lc_r
 endif
 ifeq ($(OS_ARCH),SunOS)
 ifeq ($(TARGET_CPU),sparc)
 
 ifdef JS_ULTRASPARC_OPTS
@@ -418,13 +416,13 @@ endif # GNU_CC
 endif # GNU_CC
 endif # JS_ULTRASPARC_OPTS
 
 endif
 ifeq ($(OS_RELEASE),4.1)
-LDFLAGS		+= -ldl -lnsl
+EXTRA_LIBS	+= -ldl -lnsl
 else
-LDFLAGS		+= -lposix4 -ldl -lnsl -lsocket
+EXTRA_LIBS	+= -lposix4 -ldl -lnsl -lsocket
 endif
 endif
 
 ifdef MOZ_MEMORY
 ifeq ($(OS_ARCH),Darwin)
diff -r 6de576aeff11 js/src/builtins.tbl
--- a/js/src/builtins.tbl	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/builtins.tbl	Thu Aug 28 21:06:41 2008 +0300
@@ -74,10 +74,11 @@ BUILTIN2(FastCallIteratorNext,  LO,     
 BUILTIN2(FastCallIteratorNext,  LO,     LO, P,  JSObject*, JSContext*, JSObject*, 0, 0)
 BUILTIN2(CloseIterator,         LO,     LO, LO, bool,      JSContext*, jsval, 0, 0)
 BUILTIN2(CallTree,              LO, LO, P,      nanojit::GuardRecord*, avmplus::InterpState*, nanojit::Fragment*, 0, 0)
 BUILTIN2(FastNewObject,         LO,     LO, P,  JSObject*, JSContext*, JSObject*, 0, 0)
 BUILTIN3(AddProperty,           LO, LO, LO, LO, bool,      JSContext*, JSObject*, JSScopeProperty*, 0, 0)
+BUILTIN3(HasNamedProperty,      LO, LO, LO, LO, bool,      JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN3(CallGetter,            LO, LO, LO, P,  jsval,     JSContext*, JSObject*, JSScopeProperty*, 0, 0)
 BUILTIN2(TypeOfObject,          LO,     LO, P,  JSString*, JSContext*, JSObject*, 1, 1)
 BUILTIN2(TypeOfBoolean,         LO,     LO, P,  JSString*, JSContext*, jsint, 1, 1)
 BUILTIN2(NumberToString,        LO,     F,  P,  JSString*, JSContext*, jsdouble, 1, 1)
 BUILTIN3(Object_p_hasOwnProperty,
diff -r 6de576aeff11 js/src/dtoa.c
--- a/js/src/dtoa.c	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/dtoa.c	Thu Aug 28 21:06:41 2008 +0300
@@ -2542,11 +2542,11 @@ rv_alloc(int i)
 {
 	int j, k, *r;
 
 	j = sizeof(ULong);
 	for(k = 0;
-		sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= sizeof(i);
+		sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= (unsigned) i;
 		j <<= 1)
 			k++;
 	r = (int*)Balloc(k);
 	*r = k;
 	return
diff -r 6de576aeff11 js/src/jsapi.cpp
--- a/js/src/jsapi.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsapi.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -5049,12 +5049,14 @@ JS_EvaluateUCScriptForPrincipals(JSConte
     script = js_CompileScript(cx, obj, principals,
                               !rval
                               ? TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL
                               : TCF_COMPILE_N_GO,
                               chars, length, NULL, filename, lineno);
-    if (!script)
-        return JS_FALSE;
+    if (!script) {
+        LAST_FRAME_CHECKS(cx, script);
+        return JS_FALSE;
+    }
     ok = js_Execute(cx, obj, script, NULL, 0, rval);
     LAST_FRAME_CHECKS(cx, ok);
     JS_DestroyScript(cx, script);
     return ok;
 }
diff -r 6de576aeff11 js/src/jsbuiltins.cpp
--- a/js/src/jsbuiltins.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsbuiltins.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -528,10 +528,26 @@ js_AddProperty(JSContext* cx, JSObject* 
     js_FreeSlot(cx, obj, slot);
     JS_UNLOCK_SCOPE(cx, scope);
     return false;
 }
 
+bool FASTCALL
+js_HasNamedProperty(JSContext* cx, JSObject* obj, JSString* idstr)
+{
+    jsid id;
+    if (!js_ValueToStringId(cx, STRING_TO_JSVAL(idstr), &id))
+        return JSVAL_ERROR_COOKIE;
+
+    JSObject* obj2;
+    JSProperty* prop;
+    if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
+        return JSVAL_TO_BOOLEAN(JSVAL_VOID);
+    if (prop)
+        OBJ_DROP_PROPERTY(cx, obj2, prop);
+    return prop != NULL;
+}
+
 jsval FASTCALL
 js_CallGetter(JSContext* cx, JSObject* obj, JSScopeProperty* sprop)
 {
     JS_ASSERT(!SPROP_HAS_STUB_GETTER(sprop));
     jsval v;
diff -r 6de576aeff11 js/src/jscntxt.h
--- a/js/src/jscntxt.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jscntxt.h	Thu Aug 28 21:06:41 2008 +0300
@@ -97,11 +97,11 @@ namespace nanojit {
 namespace nanojit {
     class Fragment;
     class Fragmento;
 }
 class TraceRecorder;
-extern "C++" template<typename T> class Queue;
+extern "C++" { template<typename T> class Queue; }
 typedef Queue<uint16> SlotList;
 class TypeMap;
 
 # define CLS(T)  T*
 #else
diff -r 6de576aeff11 js/src/jsdbgapi.cpp
--- a/js/src/jsdbgapi.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsdbgapi.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -1265,11 +1265,13 @@ JS_EvaluateUCInStackFrame(JSContext *cx,
      * flags to the code generator.
      */
     flags = fp->flags;
     fp->flags |= JSFRAME_DEBUGGER | JSFRAME_EVAL;
     script = js_CompileScript(cx, scobj, JS_StackFramePrincipals(cx, fp),
-                              TCF_COMPILE_N_GO, chars, length, NULL,
+                              TCF_COMPILE_N_GO |
+                              TCF_PUT_STATIC_DEPTH(fp->script->staticDepth + 1),
+                              chars, length, NULL,
                               filename, lineno);
     fp->flags = flags;
     if (!script)
         return JS_FALSE;
 
diff -r 6de576aeff11 js/src/jsemit.cpp
--- a/js/src/jsemit.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsemit.cpp	Thu Aug 28 21:06:41 2008 +0300
@@ -1876,10 +1876,13 @@ BindNameToSlot(JSContext *cx, JSCodeGene
     if (tc->flags & TCF_FUN_CLOSURE_VS_VAR)
         return JS_TRUE;
 
     if (!(tc->flags & TCF_IN_FUNCTION)) {
         if ((cx->fp->flags & JSFRAME_SPECIAL) && cx->fp->fun) {
+            if (cg->staticDepth > JS_DISPLAY_SIZE)
+                goto out;
+
             localKind = js_LookupLocal(cx, cx->fp->fun, atom, &index);
             if (localKind != JSLOCAL_NONE) {
                 if (PN_OP(pn) == JSOP_NAME) {
                     ATOM_LIST_SEARCH(ale, &cg->upvarList, atom);
                     if (!ale) {
diff -r 6de576aeff11 js/src/jsemit.h
--- a/js/src/jsemit.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsemit.h	Thu Aug 28 21:06:42 2008 +0300
@@ -206,10 +206,18 @@ struct JSTreeContext {              /* t
  */
 #define TCF_FUN_FLAGS           (TCF_FUN_IS_GENERATOR   |                     \
                                  TCF_FUN_HEAVYWEIGHT    |                     \
                                  TCF_FUN_USES_NONLOCALS |                     \
                                  TCF_FUN_CLOSURE_VS_VAR)
+
+/*
+ * Flags field, not stored in JSTreeContext.flags, for passing staticDepth
+ * into js_CompileScript.
+ */
+#define TCF_STATIC_DEPTH_MASK   0xffff0000
+#define TCF_GET_STATIC_DEPTH(f) ((uint32)(f) >> 16)
+#define TCF_PUT_STATIC_DEPTH(d) ((uint16)(d) << 16)
 
 #ifdef JS_SCOPE_DEPTH_METER
 # define JS_SCOPE_DEPTH_METERING(code) ((void) (code))
 #else
 # define JS_SCOPE_DEPTH_METERING(code) ((void) 0)
diff -r 6de576aeff11 js/src/jsinterp.cpp
--- a/js/src/jsinterp.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsinterp.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -3125,24 +3125,43 @@ js_Interpret(JSContext *cx)
                 goto error;                                                   \
             regs.sp[n] = ID_TO_VALUE(id);                                     \
         }                                                                     \
     JS_END_MACRO
 
+#define TRY_BRANCH_AFTER_COND(cond,spdec)                                     \
+    JS_BEGIN_MACRO                                                            \
+        uintN diff_;                                                          \
+        JS_ASSERT(js_CodeSpec[op].length == 1);                               \
+        diff_ = (uintN) regs.pc[1] - (uintN) JSOP_IFEQ;                       \
+        if (diff_ <= 1) {                                                     \
+            regs.sp -= spdec;                                                 \
+            if (cond == (diff_ != 0)) {                                       \
+                ++regs.pc;                                                    \
+                len = GET_JUMP_OFFSET(regs.pc);                               \
+                BRANCH(len);                                                  \
+            }                                                                 \
+            len = 1 + JSOP_IFEQ_LENGTH;                                       \
+            DO_NEXT_OP(len);                                                  \
+        }                                                                     \
+    JS_END_MACRO
+
           BEGIN_CASE(JSOP_IN)
             rval = FETCH_OPND(-1);
             if (JSVAL_IS_PRIMITIVE(rval)) {
                 js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rval, NULL);
                 goto error;
             }
             obj = JSVAL_TO_OBJECT(rval);
             FETCH_ELEMENT_ID(obj, -2, id);
             if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
                 goto error;
-            regs.sp--;
-            STORE_OPND(-1, BOOLEAN_TO_JSVAL(prop != NULL));
+            cond = prop != NULL;
             if (prop)
                 OBJ_DROP_PROPERTY(cx, obj2, prop);
+            TRY_BRANCH_AFTER_COND(cond, 2);
+            regs.sp--;
+            STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));
           END_CASE(JSOP_IN)
 
           BEGIN_CASE(JSOP_ITER)
             flags = regs.pc[1];
             JS_ASSERT(regs.sp > StackBase(fp));
@@ -3481,27 +3500,10 @@ js_Interpret(JSContext *cx)
           END_CASE(JSOP_BITXOR)
 
           BEGIN_CASE(JSOP_BITAND)
             BITWISE_OP(&);
           END_CASE(JSOP_BITAND)
-
-#define TRY_BRANCH_AFTER_COND(cond,spdec)                                     \
-    JS_BEGIN_MACRO                                                            \
-        uintN diff_;                                                          \
-        JS_ASSERT(js_CodeSpec[op].length == 1);                               \
-        diff_ = (uintN) regs.pc[1] - (uintN) JSOP_IFEQ;                       \
-        if (diff_ <= 1) {                                                     \
-            regs.sp -= spdec;                                                 \
-            if (cond == (diff_ != 0)) {                                       \
-                ++regs.pc;                                                    \
-                len = GET_JUMP_OFFSET(regs.pc);                               \
-                BRANCH(len);                                                  \
-            }                                                                 \
-            len = 1 + JSOP_IFEQ_LENGTH;                                       \
-            DO_NEXT_OP(len);                                                  \
-        }                                                                     \
-    JS_END_MACRO
 
 #define RELATIONAL_OP(OP)                                                     \
     JS_BEGIN_MACRO                                                            \
         rval = FETCH_OPND(-1);                                                \
         lval = FETCH_OPND(-2);                                                \
diff -r 6de576aeff11 js/src/jsobj.cpp
--- a/js/src/jsobj.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsobj.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -1145,12 +1145,14 @@ js_ComputeFilename(JSContext *cx, JSStac
 js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
                    JSPrincipals *principals, uintN *linenop)
 {
     uint32 flags;
 
+    JS_ASSERT(principals || !cx->runtime->findObjectPrincipals);
     flags = JS_GetScriptFilenameFlags(caller->script);
     if ((flags & JSFILENAME_PROTECTED) &&
+        principals &&
         strcmp(principals->codebase, "[System Principal]")) {
         *linenop = 0;
         return principals->codebase;
     }
 
@@ -1314,18 +1316,19 @@ js_obj_eval(JSContext *cx, JSObject *obj
      */
     do {
         fp->flags |= JSFRAME_EVAL;
     } while ((fp = fp->down) != caller);
 
-    script = js_CompileScript(cx, scopeobj, principals, TCF_COMPILE_N_GO,
+    script = js_CompileScript(cx, scopeobj, principals,
+                              TCF_COMPILE_N_GO |
+                              TCF_PUT_STATIC_DEPTH(caller->script->staticDepth + 1),
                               JSSTRING_CHARS(str), JSSTRING_LENGTH(str),
                               NULL, file, line);
     if (!script) {
         ok = JS_FALSE;
         goto out;
     }
-    script->staticDepth = caller->script->staticDepth + 1;
 
     if (argc < 2) {
         /* Execute using caller's new scope object (might be a Call object). */
         if (caller)
             scopeobj = caller->scopeChain;
diff -r 6de576aeff11 js/src/jsopcode.cpp
--- a/js/src/jsopcode.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsopcode.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -2694,10 +2694,29 @@ Decompile(SprintStack *ss, jsbytecode *p
               }
 
               case JSOP_CALLUPVAR:
               case JSOP_GETUPVAR:
                 i = JS_UPVAR_LOCAL_NAME_START(jp->fun) + GET_UINT16(pc);
+                if (i >= JS_GET_LOCAL_NAME_COUNT(jp->fun)) {
+                    JSUpvarArray *uva;
+
+                    /*
+                     * We must be in an eval called from jp->fun, where
+                     * jp->script is the eval-compiled script.
+                     */
+                    JS_ASSERT(cx->fp->flags & JSFRAME_EVAL);
+                    JS_ASSERT(cx->fp->script == jp->script);
+                    JS_ASSERT(cx->fp->down->fun == jp->fun);
+                    JS_ASSERT(FUN_INTERPRETED(jp->fun));
+                    JS_ASSERT(jp->script != jp->fun->u.i.script);
+                    JS_ASSERT(jp->script->upvarsOffset != 0);
+
+                    uva = JS_SCRIPT_UPVARS(jp->script);
+                    i = GET_UINT16(pc);
+                    JS_ASSERT(UPVAR_FRAME_SKIP(uva->vector[i]) == 1);
+                    i = UPVAR_FRAME_SLOT(uva->vector[i]);
+                }
                 atom = GetArgOrVarAtom(jp, i);
                 goto do_name;
 
               case JSOP_CALLLOCAL:
               case JSOP_GETLOCAL:
diff -r 6de576aeff11 js/src/jsparse.cpp
--- a/js/src/jsparse.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsparse.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -564,11 +564,11 @@ js_CompileScript(JSContext *cx, JSObject
     JSScript *script;
 #ifdef METER_PARSENODES
     void *sbrk(ptrdiff_t), *before = sbrk(0);
 #endif
 
-    JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL)));
+    JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL | TCF_STATIC_DEPTH_MASK)));
 
     if (!js_InitParseContext(cx, &pc, principals, chars, length, file,
                              filename, lineno)) {
         return NULL;
     }
@@ -589,11 +589,12 @@ js_CompileScript(JSContext *cx, JSObject
                        &cx->scriptStackQuota);
     js_InitCodeGenerator(cx, &cg, &pc, &codePool, &notePool,
                          pc.tokenStream.lineno);
 
     /* From this point the control must flow via the label out. */
-    cg.treeContext.flags |= tcflags;
+    cg.treeContext.flags |= (uint16) tcflags;
+    cg.staticDepth = TCF_GET_STATIC_DEPTH(tcflags);
 
     /*
      * Inline Statements() to emit as we go to save space.
      */
     for (;;) {
@@ -1992,10 +1993,18 @@ CheckDestructuring(JSContext *cx, BindDa
         js_ReportCompileErrorNumber(cx, TS(tc->parseContext), left,
                                     JSREPORT_ERROR, JSMSG_ARRAY_COMP_LEFTSIDE);
         return JS_FALSE;
     }
 
+#if JS_HAS_DESTRUCTURING_SHORTHAND
+    if (right && (right->pn_extra & PNX_SHORTHAND)) {
+        js_ReportCompileErrorNumber(cx, TS(tc->parseContext), right,
+                                    JSREPORT_ERROR, JSMSG_BAD_OBJECT_INIT);
+        return JS_FALSE;
+    }
+#endif
+
     fpvd.table.ops = NULL;
     lhs = left->pn_head;
     if (lhs && lhs->pn_type == TOK_DEFSHARP) {
         pn = lhs;
         goto no_var_name;
diff -r 6de576aeff11 js/src/jsscript.cpp
--- a/js/src/jsscript.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jsscript.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -261,11 +261,11 @@ script_compile_sub(JSContext *cx, JSObje
      * run-time scope chain may not match the compile-time.  JSFRAME_EVAL is
      * tested in jsemit.c and jsscan.c to optimize based on identity of run-
      * and compile-time scope.
      */
     fp->flags |= JSFRAME_SCRIPT_OBJECT;
-    tcflags = 0;
+    tcflags = caller ? TCF_PUT_STATIC_DEPTH(caller->staticDepth + 1) : 0;
     script = js_CompileScript(cx, scopeobj, principals, tcflags,
                               JSSTRING_CHARS(str), JSSTRING_LENGTH(str),
                               NULL, file, line);
     if (!script)
         return JS_FALSE;
diff -r 6de576aeff11 js/src/jstracer.cpp
--- a/js/src/jstracer.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jstracer.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -2418,11 +2418,13 @@ TraceRecorder::ifop()
         guard(JSVAL_IS_NULL(v), lir->ins_eq0(get(&v)), BRANCH_EXIT);
     } else if (isNumber(v)) {
         jsdouble d = asNumber(v);
         jsdpun u;
         u.d = 0;
-        guard((d == 0 || JSDOUBLE_IS_NaN(d)), lir->ins2(LIR_feq, get(&v), lir->insImmq(u.u64)), BRANCH_EXIT);
+        guard(d == 0 || JSDOUBLE_IS_NaN(d),
+              lir->ins2(LIR_feq, get(&v), lir->insImmq(u.u64)),
+              BRANCH_EXIT);
     } else if (JSVAL_IS_STRING(v)) {
         guard(JSSTRING_LENGTH(JSVAL_TO_STRING(v)) == 0,
               lir->ins_eq0(lir->ins2(LIR_piand,
                                      lir->insLoad(LIR_ldp, 
                                                   get(&v), 
@@ -3780,11 +3782,11 @@ TraceRecorder::record_JSOP_SETPROP()
         ABORT_TRACE("primitive this for SETPROP");
 
     JSObject* obj = JSVAL_TO_OBJECT(l);
 
     if (obj->map->ops->setProperty != js_SetProperty)
-        ABORT_TRACE("non-native setProperty");
+        ABORT_TRACE("non-native JSObjectOps::setProperty");
 
     LIns* obj_ins = get(&l);
 
     JSPropertyCache* cache = &JS_PROPERTY_CACHE(cx);
     uint32 kshape = OBJ_SCOPE(obj)->shape;
@@ -4879,11 +4881,86 @@ TraceRecorder::record_JSOP_THROW()
 }
 
 bool
 TraceRecorder::record_JSOP_IN()
 {
-    return false;
+    jsval& rval = stackval(-1);
+    if (JSVAL_IS_PRIMITIVE(rval))
+        ABORT_TRACE("JSOP_IN on non-object right operand");
+
+    jsval& lval = stackval(-2);
+    if (!JSVAL_IS_PRIMITIVE(lval))
+        ABORT_TRACE("JSOP_IN on E4X QName left operand");
+
+    jsid id;
+    if (JSVAL_IS_INT(lval)) {
+        id = INT_JSVAL_TO_JSID(lval);
+    } else {
+        if (!js_ValueToStringId(cx, lval, &id))
+            ABORT_TRACE("OOM under js_ValueToStringId in JSOP_IN");
+        lval = ID_TO_VALUE(id);
+    }
+
+    // Expect what we see at trace recording time (hit or miss) to be the same
+    // when executing the trace. Use a builtin helper for named properties, as
+    // forInLoop does. First, handle indexes in dense arrays as a special case.
+    JSObject* obj = JSVAL_TO_OBJECT(rval);
+    LIns* obj_ins = get(&rval);
+
+    bool cond;
+    LIns* x;
+    do {
+        if (guardDenseArray(obj, obj_ins)) {
+            if (JSVAL_IS_INT(lval)) {
+                jsint idx = JSVAL_TO_INT(lval);
+                LIns* idx_ins = f2i(get(&lval));
+                LIns* dslots_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots));
+                if (!guardDenseArrayIndex(obj, idx, obj_ins, dslots_ins, idx_ins))
+                    ABORT_TRACE("dense array index out of bounds");
+
+                cond = obj->dslots[idx] != JSVAL_HOLE;
+                x = lir->ins_eq0(lir->ins2(LIR_eq,
+                                           lir->insLoad(LIR_ldp, dslots_ins, idx * sizeof(jsval)),
+                                           INS_CONST(JSVAL_HOLE)));
+                break;
+            }
+
+            // Not an index id, but a dense array -- go up to the proto. */
+            obj = STOBJ_GET_PROTO(obj);
+            obj_ins = stobj_get_fslot(obj_ins, JSSLOT_PROTO);
+        } else {
+            if (JSVAL_IS_INT(id))
+                ABORT_TRACE("INT in OBJ where OBJ is not a dense array");
+        }
+
+        JSObject* obj2;
+        JSProperty* prop;
+        if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
+            ABORT_TRACE("OBJ_LOOKUP_PROPERTY failed in JSOP_IN");
+
+        cond = prop != NULL;
+        if (prop)
+            OBJ_DROP_PROPERTY(cx, obj2, prop);
+
+        LIns* args[] = { get(&lval), obj_ins, cx_ins };
+        x = lir->insCall(F_HasNamedProperty, args);
+        guard(false, lir->ins2i(LIR_eq, x, 2), OOM_EXIT);
+        x = lir->ins2i(LIR_eq, x, 1);
+    } while (0);
+
+    /* The interpreter fuses comparisons and the following branch,
+       so we have to do that here as well. */
+    if (cx->fp->regs->pc[1] == JSOP_IFEQ || cx->fp->regs->pc[1] == JSOP_IFNE)
+        guard(cond, x, BRANCH_EXIT);
+
+    /* We update the stack after the guard. This is safe since
+       the guard bails out at the comparison and the interpreter
+       will this re-execute the comparison. This way the
+       value of the condition doesn't have to be calculated and
+       saved on the stack in most cases. */
+    set(&lval, x);
+    return true;
 }
 
 bool
 TraceRecorder::record_JSOP_INSTANCEOF()
 {
diff -r 6de576aeff11 js/src/jstypes.h
--- a/js/src/jstypes.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/jstypes.h	Thu Aug 28 21:06:42 2008 +0300
@@ -161,11 +161,11 @@
 #define JS_FRIEND_API(t)    JS_PUBLIC_API(t)
 #define JS_FRIEND_DATA(t)   JS_PUBLIC_DATA(t)
 
 #if defined(_MSC_VER) && defined(_M_IX86)
 #define JS_FASTCALL __fastcall
-#elif defined(__GNUC__) && defined(__i386__)
+#elif (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4) && defined(__i386__)
 #define JS_FASTCALL __attribute__((fastcall))
 #else
 #define JS_FASTCALL
 #endif
 
diff -r 6de576aeff11 js/src/trace-test.js
--- a/js/src/trace-test.js	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/src/trace-test.js	Thu Aug 28 21:06:42 2008 +0300
@@ -847,8 +847,34 @@ function forVarInWith() {
     return a.join("");
 }
 forVarInWith.expected = "pqrst";
 test(forVarInWith);
 
+function inObjectTest() {
+    var o = {p: 1, q: 2, r: 3, s: 4, t: 5};
+    var r = 0;
+    for (var i in o) {
+        if (!(i in o))
+            break;
+        if ((i + i) in o)
+            break;
+        ++r;
+    }
+    return r;
+}
+inObjectTest.expected = 5;
+test(inObjectTest);
+
+function inArrayTest() {
+    var a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
+    for (var i = 0; i < a.length; i++) {
+        if (!(i in a))
+            break;
+    }
+    return i;
+}
+inArrayTest.expected = 10;
+test(inArrayTest);
+
 /* Keep these at the end so that we can see the summary after the trace-debug spew. */
 print("\npassed:", passes.length && passes.join(","));
 print("\nFAILED:", fails.length && fails.join(","));
diff -r 6de576aeff11 js/tests/js1_5/extensions/regress-333541.js
--- a/js/tests/js1_5/extensions/regress-333541.js	Wed Aug 27 08:11:51 2008 -0400
+++ b/js/tests/js1_5/extensions/regress-333541.js	Thu Aug 28 21:06:42 2008 +0300
@@ -108,10 +108,13 @@ try
     "    x = (1)[\'\\'a\\''];\n" +
     "    x = (1)['1'];\n" +
     "    x = (1)['#'];\n" +
     "}";
   actual = "" + b;
+  // fudge the actual to match a['1'] ~ a[1].
+  // see https://bugzilla.mozilla.org/show_bug.cgi?id=452369
+  actual = actual.replace(/\(1\)\[1\];/, "(1)['1'];");
   compareSource(expect, actual, summary + ': 5');
 }
 catch(ex)
 {
   actual = ex + '';
diff -r 6de576aeff11 layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/layout/base/nsPresShell.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -5318,10 +5318,15 @@ PresShell::RenderNode(nsIDOMNode* aNode,
   // area will hold the size of the surface needed to draw the node, measured
   // from the root frame.
   nsRect area;
   nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
 
+  // nothing to draw if the node isn't in a document
+  nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
+  if (!node->IsInDoc())
+    return nsnull;
+  
   nsCOMPtr<nsIDOMRange> range;
   NS_NewRange(getter_AddRefs(range));
   range->SelectNode(aNode);
 
   RangePaintInfo* info = CreateRangePaintInfo(range, area);
diff -r 6de576aeff11 layout/style/nsCSSScanner.h
--- a/layout/style/nsCSSScanner.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/layout/style/nsCSSScanner.h	Thu Aug 28 21:06:42 2008 +0300
@@ -105,11 +105,11 @@ enum nsCSSTokenType {
 
 struct nsCSSToken {
   nsCSSTokenType  mType;
   PRPackedBool    mIntegerValid; // for number and dimension
   PRPackedBool    mHasSign; // for number, percentage, and dimension
-  nsAutoString    mIdent;
+  nsAutoString    mIdent NS_OKONHEAP;
   float           mNumber;
   PRInt32         mInteger;
   PRUnichar       mSymbol;
 
   nsCSSToken();
diff -r 6de576aeff11 modules/libpr0n/decoders/icon/win/nsIconChannel.cpp
--- a/modules/libpr0n/decoders/icon/win/nsIconChannel.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/modules/libpr0n/decoders/icon/win/nsIconChannel.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -61,10 +61,11 @@
 
 // we need windows.h to read out registry information...
 #include <windows.h>
 #include <shellapi.h>
 #include <shlobj.h>
+#include <wchar.h>
 
 struct ICONFILEHEADER {
   PRUint16 ifhReserved;
   PRUint16 ifhType;
   PRUint16 ifhCount;
@@ -187,11 +188,11 @@ nsIconChannel::Open(nsIInputStream **_re
 nsIconChannel::Open(nsIInputStream **_retval)
 {
   return MakeInputStream(_retval, PR_FALSE);
 }
 
-nsresult nsIconChannel::ExtractIconInfoFromUrl(nsIFile ** aLocalFile, PRUint32 * aDesiredImageSize, nsACString &aContentType, nsACString &aFileExtension)
+nsresult nsIconChannel::ExtractIconInfoFromUrl(nsIFile ** aLocalFile, PRUint32 * aDesiredImageSize, nsCString &aContentType, nsCString &aFileExtension)
 {
   nsresult rv = NS_OK;
   nsCOMPtr<nsIMozIconURI> iconURI (do_QueryInterface(mUrl, &rv));
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -234,33 +235,33 @@ NS_IMETHODIMP nsIconChannel::AsyncOpen(n
       mLoadGroup->AddRequest(this, nsnull);
   }
   return rv;
 }
 
-static DWORD GetSpecialFolderIcon(nsIFile* aFile, int aFolder, SHFILEINFO* aSFI, UINT aInfoFlags)
+static DWORD GetSpecialFolderIcon(nsIFile* aFile, int aFolder, SHFILEINFOW* aSFI, UINT aInfoFlags)
 {
   DWORD shellResult = 0;
 
   if (!aFile)
     return shellResult;
 
-  char fileNativePath[MAX_PATH];
-  nsCAutoString fileNativePathStr;
-  aFile->GetNativePath(fileNativePathStr);
-  ::GetShortPathName(fileNativePathStr.get(), fileNativePath, sizeof(fileNativePath));
+  PRUnichar fileNativePath[MAX_PATH];
+  nsAutoString fileNativePathStr;
+  aFile->GetPath(fileNativePathStr);
+  ::GetShortPathNameW(fileNativePathStr.get(), fileNativePath, NS_ARRAY_LENGTH(fileNativePath));
 
   LPITEMIDLIST idList;
   HRESULT hr = ::SHGetSpecialFolderLocation(NULL, aFolder, &idList);
   if (SUCCEEDED(hr)) {
-    char specialNativePath[MAX_PATH];
-    ::SHGetPathFromIDList(idList, specialNativePath);
-    ::GetShortPathName(specialNativePath, specialNativePath, sizeof(specialNativePath));
+    PRUnichar specialNativePath[MAX_PATH];
+    ::SHGetPathFromIDListW(idList, specialNativePath);
+    ::GetShortPathNameW(specialNativePath, specialNativePath, NS_ARRAY_LENGTH(specialNativePath));
   
-    if (nsDependentCString(fileNativePath).EqualsIgnoreCase(specialNativePath)) {
+    if (!wcsicmp(fileNativePath, specialNativePath)) {
       aInfoFlags |= (SHGFI_PIDL | SHGFI_SYSICONINDEX);
-      shellResult = ::SHGetFileInfo((LPCTSTR)(LPCITEMIDLIST)idList, 0, aSFI, 
-                                    sizeof(SHFILEINFO), aInfoFlags);
+      shellResult = ::SHGetFileInfoW((LPCWSTR)(LPCITEMIDLIST)idList, 0, aSFI,
+                                     sizeof(*aSFI), aInfoFlags);
       IMalloc* pMalloc;
       hr = ::SHGetMalloc(&pMalloc);
       if (SUCCEEDED(hr)) {
         pMalloc->Free(idList);
         pMalloc->Release();
@@ -271,18 +272,18 @@ static DWORD GetSpecialFolderIcon(nsIFil
 }
 
 nsresult nsIconChannel::MakeInputStream(nsIInputStream** _retval, PRBool nonBlocking)
 {
   nsXPIDLCString contentType;
-  nsCAutoString fileExt;
+  nsCString fileExt;
   nsCOMPtr<nsIFile> localFile; // file we want an icon for
   PRUint32 desiredImageSize;
   nsresult rv = ExtractIconInfoFromUrl(getter_AddRefs(localFile), &desiredImageSize, contentType, fileExt);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // if the file exists, we are going to use it's real attributes...otherwise we only want to use it for it's extension...
-  SHFILEINFO      sfi;
+  SHFILEINFOW      sfi;
   UINT infoFlags = SHGFI_ICON;
   
   PRBool fileExists = PR_FALSE;
  
   nsCAutoString filePath(fileExt);
@@ -341,11 +342,12 @@ nsresult nsIconChannel::MakeInputStream(
   // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
   // If we ever need to get them, code to do so would be inserted here. 
 
   // Not a special folder, or something else failed above.
   if (!shellResult)
-    shellResult = ::SHGetFileInfo(filePath.get(), FILE_ATTRIBUTE_ARCHIVE, &sfi, sizeof(sfi), infoFlags);
+    shellResult = ::SHGetFileInfoW(NS_ConvertUTF8toUTF16(filePath).get(),
+                                   FILE_ATTRIBUTE_ARCHIVE, &sfi, sizeof(sfi), infoFlags);
 
   if (shellResult && sfi.hIcon)
   {
     // we got a handle to an icon. Now we want to get a bitmap for the icon using GetIconInfo....
     ICONINFO iconInfo;
diff -r 6de576aeff11 modules/libpr0n/decoders/icon/win/nsIconChannel.h
--- a/modules/libpr0n/decoders/icon/win/nsIconChannel.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/modules/libpr0n/decoders/icon/win/nsIconChannel.h	Thu Aug 28 21:06:42 2008 +0300
@@ -75,10 +75,10 @@ protected:
   nsCOMPtr<nsISupports>  mOwner; 
 
   nsCOMPtr<nsIInputStreamPump> mPump;
   nsCOMPtr<nsIStreamListener>  mListener;
 
-  nsresult ExtractIconInfoFromUrl(nsIFile ** aLocalFile, PRUint32 * aDesiredImageSize, nsACString &aContentType, nsACString &aFileExtension);
+  nsresult ExtractIconInfoFromUrl(nsIFile ** aLocalFile, PRUint32 * aDesiredImageSize, nsCString &aContentType, nsCString &aFileExtension);
   nsresult MakeInputStream(nsIInputStream** _retval, PRBool nonBlocking);
 };
 
 #endif /* nsIconChannel_h___ */
diff -r 6de576aeff11 modules/oji/src/scd.cpp
--- a/modules/oji/src/scd.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/modules/oji/src/scd.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -98,11 +98,11 @@ nsSymantecDebugManager::SetDebugAgentPas
     if (err == 0) {
 //        PR_LOG(NSJAVA, PR_LOG_ALWAYS,
 //               ("SetWindowLong returned %ld (err=%d)\n", err, GetLastError()));
         /* continue so that we try to wake up the DebugManager */
     }
-    sem = OpenSemaphore(SEMAPHORE_MODIFY_STATE, FALSE, "Netscape-Symantec Debugger");
+    sem = OpenSemaphoreW(SEMAPHORE_MODIFY_STATE, FALSE, L"Netscape-Symantec Debugger");
     if (sem) {
         ReleaseSemaphore(sem, 1, NULL);
         CloseHandle(sem);
     }
     return NS_OK;
diff -r 6de576aeff11 netwerk/base/public/nsNetUtil.h
--- a/netwerk/base/public/nsNetUtil.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/base/public/nsNetUtil.h	Thu Aug 28 21:06:42 2008 +0300
@@ -72,10 +72,11 @@
 #include "nsIProtocolHandler.h"
 #include "nsIFileProtocolHandler.h"
 #include "nsIStringStream.h"
 #include "nsILocalFile.h"
 #include "nsIFileStreams.h"
+#include "nsIFileURL.h"
 #include "nsIProtocolProxyService.h"
 #include "nsIProxyInfo.h"
 #include "nsIFileStreams.h"
 #include "nsIBufferedStreams.h"
 #include "nsIInputStreamPump.h"
@@ -1463,6 +1464,130 @@ NS_OfflineAppAllowed(nsIURI *aURI, nsIPr
     NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
     return allowed;
 }
 
+inline PRBool
+NS_SecurityCompareURIs(nsIURI* aSourceURI,
+                       nsIURI* aTargetURI,
+                       PRBool aStrictFileOriginPolicy)
+{
+    // Note that this is not an Equals() test on purpose -- for URIs that don't
+    // support host/port, we want equality to basically be object identity, for
+    // security purposes.  Otherwise, for example, two javascript: URIs that
+    // are otherwise unrelated could end up "same origin", which would be
+    // unfortunate.
+    if (aSourceURI && aSourceURI == aTargetURI)
+    {
+        return PR_TRUE;
+    }
+
+    if (!aTargetURI || !aSourceURI)
+    {
+        return PR_FALSE;
+    }
+
+    // If either URI is a nested URI, get the base URI
+    nsCOMPtr<nsIURI> sourceBaseURI = NS_GetInnermostURI(aSourceURI);
+    nsCOMPtr<nsIURI> targetBaseURI = NS_GetInnermostURI(aTargetURI);
+
+    if (!sourceBaseURI || !targetBaseURI)
+        return PR_FALSE;
+
+    // Compare schemes
+    nsCAutoString targetScheme;
+    PRBool sameScheme = PR_FALSE;
+    if (NS_FAILED( targetBaseURI->GetScheme(targetScheme) ) ||
+        NS_FAILED( sourceBaseURI->SchemeIs(targetScheme.get(), &sameScheme) ) ||
+        !sameScheme)
+    {
+        // Not same-origin if schemes differ
+        return PR_FALSE;
+    }
+
+    // special handling for file: URIs
+    if (targetScheme.EqualsLiteral("file"))
+    {
+        // in traditional unsafe behavior all files are the same origin
+        if (!aStrictFileOriginPolicy)
+            return PR_TRUE;
+
+        nsCOMPtr<nsIFileURL> sourceFileURL(do_QueryInterface(sourceBaseURI));
+        nsCOMPtr<nsIFileURL> targetFileURL(do_QueryInterface(targetBaseURI));
+
+        if (!sourceFileURL || !targetFileURL)
+            return PR_FALSE;
+
+        nsCOMPtr<nsIFile> sourceFile, targetFile;
+
+        sourceFileURL->GetFile(getter_AddRefs(sourceFile));
+        targetFileURL->GetFile(getter_AddRefs(targetFile));
+
+        if (!sourceFile || !targetFile)
+            return PR_FALSE;
+
+        // Otherwise they had better match
+        PRBool filesAreEqual = PR_FALSE;
+        nsresult rv = sourceFile->Equals(targetFile, &filesAreEqual);
+        return NS_SUCCEEDED(rv) && filesAreEqual;
+    }
+
+    // Special handling for mailnews schemes
+    if (targetScheme.EqualsLiteral("imap") ||
+        targetScheme.EqualsLiteral("mailbox") ||
+        targetScheme.EqualsLiteral("news"))
+    {
+        // Each message is a distinct trust domain; use the
+        // whole spec for comparison
+        nsCAutoString targetSpec;
+        nsCAutoString sourceSpec;
+        return ( NS_SUCCEEDED( targetBaseURI->GetSpec(targetSpec) ) &&
+                 NS_SUCCEEDED( sourceBaseURI->GetSpec(sourceSpec) ) &&
+                 targetSpec.Equals(sourceSpec) );
+    }
+
+    // Compare hosts
+    nsCAutoString targetHost;
+    nsCAutoString sourceHost;
+    if (NS_FAILED( targetBaseURI->GetAsciiHost(targetHost) ) ||
+        NS_FAILED( sourceBaseURI->GetAsciiHost(sourceHost) ))
+    {
+        return PR_FALSE;
+    }
+
+#ifdef MOZILLA_INTERNAL_API
+    if (!targetHost.Equals(sourceHost, nsCaseInsensitiveCStringComparator() ))
+#else
+    if (!targetHost.Equals(sourceHost, CaseInsensitiveCompare))
+#endif
+    {
+        return PR_FALSE;
+    }
+
+    // Compare ports
+    PRInt32 targetPort;
+    nsresult rv = targetBaseURI->GetPort(&targetPort);
+    PRInt32 sourcePort;
+    if (NS_SUCCEEDED(rv))
+        rv = sourceBaseURI->GetPort(&sourcePort);
+    PRBool result = NS_SUCCEEDED(rv) && targetPort == sourcePort;
+    // If the port comparison failed, see if either URL has a
+    // port of -1. If so, replace -1 with the default port
+    // for that scheme.
+    if (NS_SUCCEEDED(rv) && !result &&
+        (sourcePort == -1 || targetPort == -1))
+    {
+        PRInt32 defaultPort = NS_GetDefaultPort(targetScheme.get());
+        if (defaultPort == -1)
+            return PR_FALSE; // No default port for this scheme
+
+        if (sourcePort == -1)
+            sourcePort = defaultPort;
+        else if (targetPort == -1)
+            targetPort = defaultPort;
+        result = targetPort == sourcePort;
+    }
+
+    return result;
+}
+
 #endif // !nsNetUtil_h__
diff -r 6de576aeff11 netwerk/base/src/nsAutodialWin.cpp
--- a/netwerk/base/src/nsAutodialWin.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/base/src/nsAutodialWin.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -41,10 +41,11 @@
 // Registry entries for Autodial mappings are located here:
 //  HKEY_CURRENT_USER\Software\Microsoft\RAS Autodial\Addresses
 
 #include <windows.h>
 #include <winsvc.h>
+#include "nsString.h"
 #include "nsAutodialWin.h"
 #include "prlog.h"
 
 #ifdef WINCE
 #include <objbase.h>
@@ -98,11 +99,11 @@ nsRASAutodial::nsRASAutodial()
 nsRASAutodial::nsRASAutodial()
 :   mAutodialBehavior(AUTODIAL_DEFAULT),
     mNumRASConnectionEntries(0),
     mAutodialServiceDialingLocation(-1)
 {
-    mOSVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+    mOSVerInfo.dwOSVersionInfoSize = sizeof(mOSVerInfo);
     GetVersionEx(&mOSVerInfo);
 
     // Initializations that can be made again since RAS OS settings can 
     // change.
     Init();
@@ -137,12 +138,12 @@ nsresult nsRASAutodial::Init()
 
     // Get the number of dialup entries in the phonebook.
     mNumRASConnectionEntries = NumRASEntries();
     
     // Get the name of the default entry.
-    nsresult result = GetDefaultEntryName(mDefaultEntryName, 
-                                           RAS_MaxEntryName + 1);
+    nsresult result = GetDefaultEntryName(mDefaultEntryName,
+                                          sizeof(mDefaultEntryName));
     
     return result;
 }
 
 
@@ -203,13 +204,13 @@ int nsRASAutodial::QueryAutodialBehavior
     }
 
     // If we get to here, then the service is not going to dial on error, so we
     // can dial ourselves if the control panel settings are set up that way.
     HKEY hKey = 0;
-    LONG result = ::RegOpenKeyEx(
+    LONG result = ::RegOpenKeyExW(
                     HKEY_CURRENT_USER, 
-                    "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 
+                    L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 
                     0, 
                     KEY_READ, 
                     &hKey);
 
     if (result != ERROR_SUCCESS)
@@ -221,19 +222,19 @@ int nsRASAutodial::QueryAutodialBehavior
     DWORD entryType = 0;
     DWORD autodial = 0;
     DWORD onDemand = 0;
     DWORD paramSize = sizeof(DWORD);
 
-    result = ::RegQueryValueEx(hKey, "EnableAutodial", nsnull, &entryType, (LPBYTE)&autodial, &paramSize);
+    result = ::RegQueryValueExW(hKey, L"EnableAutodial", nsnull, &entryType, (LPBYTE)&autodial, &paramSize);
     if (result != ERROR_SUCCESS)
     {
         ::RegCloseKey(hKey);
         LOGE(("Autodial: Error reading reg value EnableAutodial."));
         return AUTODIAL_NEVER;
     }
 
-    result = ::RegQueryValueEx(hKey, "NoNetAutodial", nsnull, &entryType, (LPBYTE)&onDemand, &paramSize);
+    result = ::RegQueryValueExW(hKey, L"NoNetAutodial", nsnull, &entryType, (LPBYTE)&onDemand, &paramSize);
     if (result != ERROR_SUCCESS)
     {
         ::RegCloseKey(hKey);
         LOGE(("Autodial: Error reading reg value NoNetAutodial."));
         return AUTODIAL_NEVER;
@@ -267,13 +268,13 @@ static nsresult DoPPCConnection()
 {
     static HANDLE    gConnectionHandle = NULL;
 
     // Make the connection to the new network
     CONNMGR_CONNECTIONINFO conn_info;
-    memset(&conn_info, 0, sizeof(CONNMGR_CONNECTIONINFO));
+    memset(&conn_info, 0, sizeof(conn_info));
 
-    conn_info.cbSize      = sizeof(CONNMGR_CONNECTIONINFO);
+    conn_info.cbSize      = sizeof(conn_info);
     conn_info.dwParams    = CONNMGR_PARAM_GUIDDESTNET;
     conn_info.dwPriority  = CONNMGR_PRIORITY_USERINTERACTIVE;
     conn_info.guidDestNet = IID_DestNetInternet;
     conn_info.bExclusive  = FALSE;
     conn_info.bDisabled   = FALSE;
@@ -319,11 +320,11 @@ static nsresult DoPPCConnection()
 // the user select the connection entry to use.
 //
 // Return values:
 //  NS_OK: dialing was successful and caller should retry
 //  all other values indicate that the caller should not retry
-nsresult nsRASAutodial::DialDefault(const char* hostName)
+nsresult nsRASAutodial::DialDefault(const PRUnichar* hostName)
 {
 #ifndef WINCE
     mDontRetryUntil = 0;
 
     if (mAutodialBehavior == AUTODIAL_NEVER)
@@ -371,12 +372,12 @@ nsresult nsRASAutodial::DialDefault(cons
         if (mDefaultEntryName[0] != '\0') 
         {
             LOGD(("Autodial: Dialing default: %s.",mDefaultEntryName));
 
             RASDIALDLG rasDialDlg;
-            memset(&rasDialDlg, 0, sizeof(RASDIALDLG));
-            rasDialDlg.dwSize = sizeof(RASDIALDLG);
+            memset(&rasDialDlg, 0, sizeof(rasDialDlg));
+            rasDialDlg.dwSize = sizeof(rasDialDlg);
 
             PRBool dialed = 
              (*mpRasDialDlg)(nsnull, mDefaultEntryName, nsnull, &rasDialDlg);
 
             if (!dialed)
@@ -402,12 +403,12 @@ nsresult nsRASAutodial::DialDefault(cons
         else
         {
             LOGD(("Autodial: Prompting for phonebook entry."));
 
             RASPBDLG rasPBDlg;
-            memset(&rasPBDlg, 0, sizeof(RASPBDLG));
-            rasPBDlg.dwSize = sizeof(RASPBDLG);
+            memset(&rasPBDlg, 0, sizeof(rasPBDlg));
+            rasPBDlg.dwSize = sizeof(rasPBDlg);
  
             PRBool dialed = (*mpRasPhonebookDlg)(nsnull, nsnull, &rasPBDlg);
 
             if (!dialed)
             {
@@ -441,12 +442,12 @@ nsresult nsRASAutodial::DialDefault(cons
 // Check to see if RAS is already connected.
 PRBool nsRASAutodial::IsRASConnected()
 {
     DWORD connections;
     RASCONN rasConn;
-    rasConn.dwSize = sizeof(RASCONN);
-    DWORD structSize = sizeof(RASCONN);
+    rasConn.dwSize = sizeof(rasConn);
+    DWORD structSize = sizeof(rasConn);
 
     if (!LoadRASapi32DLL())
         return NS_ERROR_NULL_POINTER;
 
     DWORD result = (*mpRasEnumConnections)(&rasConn, &structSize, &connections);
@@ -460,30 +461,29 @@ PRBool nsRASAutodial::IsRASConnected()
     LOGE(("Autodial: ::RasEnumConnections failed: Error = %d", result));
     return PR_FALSE;
 }
 
 // Get the first RAS dial entry name from the phonebook.
-nsresult nsRASAutodial::GetFirstEntryName(char* entryName, int bufferSize)
+nsresult nsRASAutodial::GetFirstEntryName(PRUnichar* entryName, int bufferSize)
 {
     // Need to load the DLL if not loaded yet.
     if (!LoadRASapi32DLL())
         return NS_ERROR_NULL_POINTER;
 
-    RASENTRYNAME rasEntryName;
-    rasEntryName.dwSize = sizeof(RASENTRYNAME);
-    DWORD cb = sizeof(RASENTRYNAME);
+    RASENTRYNAMEW rasEntryName;
+    rasEntryName.dwSize = sizeof(rasEntryName);
+    DWORD cb = sizeof(rasEntryName);
     DWORD cEntries = 0;
 
     DWORD result = 
      (*mpRasEnumEntries)(nsnull, nsnull, &rasEntryName, &cb, &cEntries);
 
     // ERROR_BUFFER_TOO_SMALL is OK because we only need one struct.
     if (result == ERROR_SUCCESS || result == ERROR_BUFFER_TOO_SMALL)
     {
-#ifndef WINCE
-        strncpy(entryName, rasEntryName.szEntryName, bufferSize);
-#endif
+        wcsncpy(entryName, rasEntryName.szEntryName,
+                bufferSize / sizeof(*entryName));
         return NS_OK;
     }
 
     return NS_ERROR_FAILURE;
 }
@@ -493,13 +493,13 @@ int nsRASAutodial::NumRASEntries()
 {
     // Need to load the DLL if not loaded yet.
     if (!LoadRASapi32DLL())
         return 0;
 
-    RASENTRYNAME rasEntryName;
-    rasEntryName.dwSize = sizeof(RASENTRYNAME);
-    DWORD cb = sizeof(RASENTRYNAME);
+    RASENTRYNAMEW rasEntryName;
+    rasEntryName.dwSize = sizeof(rasEntryName);
+    DWORD cb = sizeof(rasEntryName);
     DWORD cEntries = 0;
 
 
     DWORD result = 
      (*mpRasEnumEntries)(nsnull, nsnull, &rasEntryName, &cb, &cEntries);
@@ -512,11 +512,11 @@ int nsRASAutodial::NumRASEntries()
 
     return 0;
 }
 
 // Get the name of the default dial entry.
-nsresult nsRASAutodial::GetDefaultEntryName(char* entryName, int bufferSize)
+nsresult nsRASAutodial::GetDefaultEntryName(PRUnichar* entryName, int bufferSize)
 {
     // No RAS dialup entries. 
     if (mNumRASConnectionEntries <= 0)
     {
         return NS_ERROR_FAILURE;
@@ -533,24 +533,24 @@ nsresult nsRASAutodial::GetDefaultEntryN
     //
     // For Windows XP: HKCU/Software/Microsoft/RAS Autodial/Default/DefaultInternet.
     //              or HKLM/Software/Microsoft/RAS Autodial/Default/DefaultInternet.
     // For Windows 2K: HKCU/RemoteAccess/InternetProfile.
 
-    char* key = nsnull;
-    char* val = nsnull;
+    const PRUnichar* key = nsnull;
+    const PRUnichar* val = nsnull;
 
     HKEY hKey = 0;
     LONG result = 0;
 
     // Windows NT and 2000
     if ((mOSVerInfo.dwMajorVersion == 4) // Windows NT
      || ((mOSVerInfo.dwMajorVersion == 5) && (mOSVerInfo.dwMinorVersion == 0))) // Windows 2000
     {
-        key = "RemoteAccess";
-        val = "InternetProfile";
+        key = L"RemoteAccess";
+        val = L"InternetProfile";
 
-        result = ::RegOpenKeyEx(
+        result = ::RegOpenKeyExW(
                     HKEY_CURRENT_USER, 
                     key, 
                     0, 
                     KEY_READ, 
                     &hKey);
@@ -560,26 +560,26 @@ nsresult nsRASAutodial::GetDefaultEntryN
             return NS_ERROR_FAILURE;
         }
     }
     else  // Windows XP
     {
-        key = "Software\\Microsoft\\RAS Autodial\\Default";
-        val = "DefaultInternet";
+        key = L"Software\\Microsoft\\RAS Autodial\\Default";
+        val = L"DefaultInternet";
 
         
         // Try HKCU first.
-        result = ::RegOpenKeyEx(
+        result = ::RegOpenKeyExW(
                     HKEY_CURRENT_USER, 
                     key, 
                     0, 
                     KEY_READ, 
                     &hKey);
 
         if (result != ERROR_SUCCESS)
         {
             // If not present, try HKLM.
-            result = ::RegOpenKeyEx(
+            result = ::RegOpenKeyExW(
                         HKEY_LOCAL_MACHINE, 
                         key, 
                         0, 
                         KEY_READ, 
                         &hKey);
@@ -593,11 +593,11 @@ nsresult nsRASAutodial::GetDefaultEntryN
 
 
     DWORD entryType = 0;
     DWORD buffSize = bufferSize;
 
-    result = ::RegQueryValueEx(hKey, 
+    result = ::RegQueryValueExW(hKey, 
                                 val, 
                                 nsnull, 
                                 &entryType, 
                                 (LPBYTE)entryName, 
                                 &buffSize);
@@ -629,11 +629,11 @@ PRBool nsRASAutodial::IsAutodialServiceR
 
         return PR_FALSE;
     }
 
     SC_HANDLE hService = 
-      OpenService(hSCManager, "RasAuto", SERVICE_QUERY_STATUS);
+      OpenServiceW(hSCManager, L"RasAuto", SERVICE_QUERY_STATUS);
 
     if (hSCManager == nsnull)
     {
         LOGE(("Autodial: failed to open RasAuto service."));
         return PR_FALSE;
@@ -653,65 +653,65 @@ PRBool nsRASAutodial::IsAutodialServiceR
     return PR_TRUE;
 #endif
 }
 
 // Add the specified address to the autodial directory.
-PRBool nsRASAutodial::AddAddressToAutodialDirectory(const char* hostName)
+PRBool nsRASAutodial::AddAddressToAutodialDirectory(const PRUnichar* hostName)
 {
     // Need to load the DLL if not loaded yet.
     if (!LoadRASapi32DLL())
         return PR_FALSE;
 
     // First see if there is already a db entry for this address. 
-    RASAUTODIALENTRY autodialEntry;
-    autodialEntry.dwSize = sizeof(RASAUTODIALENTRY);
-    DWORD size = sizeof(RASAUTODIALENTRY);
+    RASAUTODIALENTRYW autodialEntry;
+    autodialEntry.dwSize = sizeof(autodialEntry);
+    DWORD size = sizeof(autodialEntry);
     DWORD entries = 0;
 
     DWORD result = (*mpRasGetAutodialAddress)(hostName, 
-                                    nsnull, 
-                                    &autodialEntry, 
-                                    &size, 
-                                    &entries);
+                                              nsnull, 
+                                              &autodialEntry, 
+                                              &size, 
+                                              &entries);
 
     // If there is already at least 1 entry in db for this address, return.
     if (result != ERROR_FILE_NOT_FOUND)
     {
         LOGD(("Autodial: Address %s already in autodial db.", hostName));
         return PR_FALSE;
     }
 
-    autodialEntry.dwSize = sizeof(RASAUTODIALENTRY);
+    autodialEntry.dwSize = sizeof(autodialEntry);
     autodialEntry.dwFlags = 0;
     autodialEntry.dwDialingLocation = mAutodialServiceDialingLocation;
-    GetDefaultEntryName(autodialEntry.szEntry, RAS_MaxEntryName);
+    GetDefaultEntryName(autodialEntry.szEntry, sizeof(autodialEntry.szEntry));
 
     result = (*mpRasSetAutodialAddress)(hostName, 
-                                    0, 
-                                    &autodialEntry, 
-                                    sizeof(RASAUTODIALENTRY), 
-                                    1);
+                                        0, 
+                                        &autodialEntry, 
+                                        sizeof(autodialEntry), 
+                                        1);
 
     if (result != ERROR_SUCCESS)
     {
         LOGE(("Autodial ::RasSetAutodialAddress failed result %d.", result));
         return PR_FALSE;
     }
 
     LOGD(("Autodial: Added address %s to RAS autodial db for entry %s.",
-     hostName, autodialEntry.szEntry));
+         hostName, NS_ConvertUTF16toUTF8(autodialEntry.szEntry).get()));
 
     return PR_TRUE;
 }
 
 // Get the current TAPI dialing location.
 int nsRASAutodial::GetCurrentLocation()
 {
     HKEY hKey = 0;
-    LONG result = ::RegOpenKeyEx(
+    LONG result = ::RegOpenKeyExW(
                     HKEY_LOCAL_MACHINE, 
-                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations", 
+                    L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations", 
                     0, 
                     KEY_READ, 
                     &hKey);
 
     if (result != ERROR_SUCCESS)
@@ -722,11 +722,11 @@ int nsRASAutodial::GetCurrentLocation()
 
     DWORD entryType = 0;
     DWORD location = 0;
     DWORD paramSize = sizeof(DWORD);
 
-    result = ::RegQueryValueEx(hKey, "CurrentID", nsnull, &entryType, (LPBYTE)&location, &paramSize);
+    result = ::RegQueryValueExW(hKey, L"CurrentID", nsnull, &entryType, (LPBYTE)&location, &paramSize);
     if (result != ERROR_SUCCESS)
     {
         ::RegCloseKey(hKey);
         LOGE(("Autodial: Error reading reg value CurrentID."));
         return -1;
@@ -760,11 +760,11 @@ PRBool nsRASAutodial::IsAutodialServiceE
 
 PRBool nsRASAutodial::LoadRASapi32DLL()
 {
     if (!mhRASapi32)
     {
-        mhRASapi32 = ::LoadLibrary("rasapi32.dll");
+        mhRASapi32 = ::LoadLibraryW(L"rasapi32.dll");
         if ((UINT)mhRASapi32 > 32)
         {
             // RasEnumConnections
             mpRasEnumConnections = (tRASENUMCONNECTIONS)
              ::GetProcAddress(mhRASapi32, "RasEnumConnectionsA");
@@ -809,20 +809,20 @@ PRBool nsRASAutodial::LoadRASapi32DLL()
 
 PRBool nsRASAutodial::LoadRASdlgDLL()
 {
     if (!mhRASdlg)
     {
-        mhRASdlg = ::LoadLibrary("rasdlg.dll");
+        mhRASdlg = ::LoadLibraryW(L"rasdlg.dll");
         if ((UINT)mhRASdlg > 32)
         {
             // RasPhonebookDlg
             mpRasPhonebookDlg =
-             (tRASPHONEBOOKDLG)::GetProcAddress(mhRASdlg, "RasPhonebookDlgA");
+             (tRASPHONEBOOKDLG)::GetProcAddress(mhRASdlg, "RasPhonebookDlgW");
 
             // RasDialDlg
             mpRasDialDlg =
-             (tRASDIALDLG)::GetProcAddress(mhRASdlg, "RasDialDlgA");
+             (tRASDIALDLG)::GetProcAddress(mhRASdlg, "RasDialDlgW");
 
         }
     }
 
     if (!mhRASdlg || !mpRasPhonebookDlg || !mpRasDialDlg)
diff -r 6de576aeff11 netwerk/base/src/nsAutodialWin.h
--- a/netwerk/base/src/nsAutodialWin.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/base/src/nsAutodialWin.h	Thu Aug 28 21:06:42 2008 +0300
@@ -50,25 +50,25 @@
 */
 typedef struct tagRASAUTODIALENTRYA {
     DWORD dwSize;
     DWORD dwFlags;
     DWORD dwDialingLocation;
-    CHAR szEntry[RAS_MaxEntryName + 1];
-} RASAUTODIALENTRYA, *LPRASAUTODIALENTRYA;
-typedef RASAUTODIALENTRYA RASAUTODIALENTRY, *LPRASAUTODIALENTRY;
+    PRUnichar szEntry[RAS_MaxEntryName + 1];
+} RASAUTODIALENTRYW, *LPRASAUTODIALENTRYW;
+typedef RASAUTODIALENTRYW RASAUTODIALENTRY, *LPRASAUTODIALENTRY;
 
 #define RASADP_LoginSessionDisable              1
 
 #endif  // WINVER
 
 // Loading the RAS DLL dynamically. 
-typedef DWORD (WINAPI* tRASPHONEBOOKDLG)(LPTSTR,LPTSTR,LPRASPBDLG);
-typedef DWORD (WINAPI* tRASDIALDLG)(LPTSTR,LPTSTR,LPTSTR,LPRASDIALDLG);
+typedef DWORD (WINAPI* tRASPHONEBOOKDLG)(LPWSTR,LPWSTR,LPRASPBDLG);
+typedef DWORD (WINAPI* tRASDIALDLG)(LPWSTR,LPWSTR,LPWSTR,LPRASDIALDLG);
 typedef DWORD (WINAPI* tRASENUMCONNECTIONS)(LPRASCONN,LPDWORD,LPDWORD);
-typedef DWORD (WINAPI* tRASENUMENTRIES)(LPTSTR,LPTSTR,LPRASENTRYNAME,LPDWORD,LPDWORD);
-typedef DWORD (WINAPI* tRASSETAUTODIALADDRESS)(LPCTSTR,DWORD,LPRASAUTODIALENTRY,DWORD,DWORD);
-typedef DWORD (WINAPI* tRASGETAUTODIALADDRESS)(LPCTSTR,LPDWORD,LPRASAUTODIALENTRY,LPDWORD,LPDWORD);
+typedef DWORD (WINAPI* tRASENUMENTRIES)(LPWSTR,LPWSTR,LPRASENTRYNAMEW,LPDWORD,LPDWORD);
+typedef DWORD (WINAPI* tRASSETAUTODIALADDRESS)(LPCWSTR,DWORD,LPRASAUTODIALENTRYW,DWORD,DWORD);
+typedef DWORD (WINAPI* tRASGETAUTODIALADDRESS)(LPCWSTR,LPDWORD,LPRASAUTODIALENTRYW,LPDWORD,LPDWORD);
 typedef DWORD (WINAPI* tRASGETAUTODIALENABLE)(DWORD,LPBOOL);
 typedef DWORD (WINAPI* tRASGETAUTODIALPARAM)(DWORD,LPVOID,LPDWORD);
 // For Windows NT 4, 2000, and XP, we sometimes want to open the RAS dialup 
 // window ourselves, since those versions aren't very nice about it. 
 // See bug 93002. If the RAS autodial service is running, (Remote Access 
@@ -105,23 +105,23 @@ private:
 
     // Get the number of RAS connection entries configured from the OS.
     int NumRASEntries();
 
     // Get the name of the default connection from the OS.
-    nsresult GetDefaultEntryName(char* entryName, int bufferSize);
+    nsresult GetDefaultEntryName(PRUnichar* entryName, int bufferSize);
 
     // Get the name of the first RAS dial entry from the OS.
-    nsresult GetFirstEntryName(char* entryName, int bufferSize);
+    nsresult GetFirstEntryName(PRUnichar* entryName, int bufferSize);
 
     // Check to see if RAS already has a dialup connection going.
     PRBool IsRASConnected();
 
     // Get the autodial behavior from the OS.
     int QueryAutodialBehavior();
 
     // Add the specified address to the autodial directory.
-    PRBool AddAddressToAutodialDirectory(const char* hostName);
+    PRBool AddAddressToAutodialDirectory(const PRUnichar* hostName);
 
     // Get the  current TAPI dialing location.
     int GetCurrentLocation();
 
     // See if autodial is enabled for specified location.
@@ -143,11 +143,11 @@ private:
 
     // Number of RAS connection entries in the phonebook. 
     int mNumRASConnectionEntries;
 
     // Default connection entry name.
-    char mDefaultEntryName[RAS_MaxEntryName + 1];  
+    PRUnichar mDefaultEntryName[RAS_MaxEntryName + 1];  
 
     // Don't try to dial again within a few seconds of when user pressed cancel.
     static PRIntervalTime mDontRetryUntil;
 
     // OS version info.
@@ -182,11 +182,11 @@ public:
     // Get the autodial info from the OS and init this obj with it. Call it any
     // time to refresh the object's settings from the OS.
     nsresult Init();
 
     // Dial the default RAS dialup connection.
-    nsresult DialDefault(const char* hostName);
+    nsresult DialDefault(const PRUnichar* hostName);
 
     // Should we try to dial on network error?
     PRBool ShouldDialOnNetworkError();
 };
 
diff -r 6de576aeff11 netwerk/base/src/nsNativeConnectionHelper.cpp
--- a/netwerk/base/src/nsNativeConnectionHelper.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/base/src/nsNativeConnectionHelper.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -42,11 +42,11 @@
 // API typically invoked on the socket transport thread
 //-----------------------------------------------------------------------------
 
 
 PRBool
-nsNativeConnectionHelper::OnConnectionFailed(const char* hostName)
+nsNativeConnectionHelper::OnConnectionFailed(const PRUnichar* hostName)
 {
     nsRASAutodial autodial;
 
     if (autodial.ShouldDialOnNetworkError()) 
         return NS_SUCCEEDED(autodial.DialDefault(hostName));
diff -r 6de576aeff11 netwerk/base/src/nsNativeConnectionHelper.h
--- a/netwerk/base/src/nsNativeConnectionHelper.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/base/src/nsNativeConnectionHelper.h	Thu Aug 28 21:06:42 2008 +0300
@@ -48,11 +48,11 @@ public:
     /**
      * OnConnectionFailed
      *
      * Return PR_TRUE if the connection should be re-attempted.
      */
-    static PRBool OnConnectionFailed(const char* hostName);
+    static PRBool OnConnectionFailed(const PRUnichar* hostName);
 
     /**
      * IsAutoDialEnabled
      *
      * Return PR_TRUE if autodial is enabled in the operating system.
diff -r 6de576aeff11 netwerk/base/src/nsSocketTransport2.cpp
--- a/netwerk/base/src/nsSocketTransport2.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/base/src/nsSocketTransport2.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -1250,12 +1250,14 @@ nsSocketTransport::RecoverFromError()
     // If not trying next address, try to make a connection using dialup. 
     // Retry if that connection is made.
     if (!tryAgain) {
         PRBool autodialEnabled;
         gSocketTransportService->GetAutodialEnabled(&autodialEnabled);
-        if (autodialEnabled)
-            tryAgain = nsNativeConnectionHelper::OnConnectionFailed(SocketHost().get());
+        if (autodialEnabled) {
+          tryAgain = nsNativeConnectionHelper::OnConnectionFailed(
+                       NS_ConvertUTF8toUTF16(SocketHost()).get());
+	    }
     }
 #endif
 
     // prepare to try again.
     if (tryAgain) {
diff -r 6de576aeff11 netwerk/cache/src/nsDiskCacheDeviceSQL.cpp
--- a/netwerk/cache/src/nsDiskCacheDeviceSQL.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/cache/src/nsDiskCacheDeviceSQL.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -42,10 +42,12 @@
 #include "nsCacheService.h"
 
 #include "nsNetUtil.h"
 #include "nsAutoPtr.h"
 #include "nsEscape.h"
+#include "nsIPrefBranch.h"
+#include "nsIPrefService.h"
 #include "nsString.h"
 #include "nsPrintfCString.h"
 #include "nsCRT.h"
 #include "nsIVariant.h"
 
@@ -688,10 +690,24 @@ nsOfflineCacheDevice::nsOfflineCacheDevi
 }
 
 nsOfflineCacheDevice::~nsOfflineCacheDevice()
 {
   Shutdown();
+}
+
+/* static */
+PRBool
+nsOfflineCacheDevice::GetStrictFileOriginPolicy()
+{
+    nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+
+    PRBool retval;
+    if (prefs && NS_SUCCEEDED(prefs->GetBoolPref("security.fileuri.strict_origin_policy", &retval)))
+        return retval;
+
+    // As default value use true (be more strict)
+    return PR_TRUE;
 }
 
 PRUint32
 nsOfflineCacheDevice::CacheSize()
 {
@@ -1743,17 +1759,44 @@ nsOfflineCacheDevice::ChooseApplicationC
 
   PRBool hasRows;
   rv = statement->ExecuteStep(&hasRows);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  nsCOMPtr<nsIURI> keyURI;
+  rv = NS_NewURI(getter_AddRefs(keyURI), key);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   while (hasRows) {
-    nsCString clientID;
-    rv = statement->GetUTF8String(0, clientID);
+    PRInt32 itemType;
+    rv = statement->GetInt32(1, &itemType);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    if (mActiveCaches.Contains(clientID))
-      return GetApplicationCache(clientID, out);
+    if (!(itemType & nsIApplicationCache::ITEM_FOREIGN)) {
+      nsCAutoString clientID;
+      rv = statement->GetUTF8String(0, clientID);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (mActiveCaches.Contains(clientID)) {
+        nsCAutoString groupID;
+        rv = GetGroupForCache(clientID, groupID);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        nsCOMPtr<nsIURI> groupURI;
+        rv = NS_NewURI(getter_AddRefs(groupURI), groupID);
+        if (NS_SUCCEEDED(rv)) {
+          // When we are choosing an initial cache to load the top
+          // level document from, the URL of that document must have
+          // the same origin as the manifest, according to the spec.
+          // The following check is here because explicit, fallback
+          // and dynamic entries might have origin different from the
+          // manifest origin. XXX: dynamic shouldn't?
+          if (NS_SecurityCompareURIs(keyURI, groupURI,
+                                     GetStrictFileOriginPolicy()))
+            return GetApplicationCache(clientID, out);
+        }
+      }
+    }
 
     rv = statement->ExecuteStep(&hasRows);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
diff -r 6de576aeff11 netwerk/cache/src/nsDiskCacheDeviceSQL.h
--- a/netwerk/cache/src/nsDiskCacheDeviceSQL.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/cache/src/nsDiskCacheDeviceSQL.h	Thu Aug 28 21:06:42 2008 +0300
@@ -182,10 +182,12 @@ private:
 
   static PLDHashOperator ShutdownApplicationCache(const nsACString &key,
                                                   nsIWeakReference *weakRef,
                                                   void *ctx);
 
+  static PRBool GetStrictFileOriginPolicy();
+
   PRBool   Initialized() { return mDB != nsnull; }
 
   nsresult InitActiveCaches();
   nsresult UpdateEntry(nsCacheEntry *entry);
   nsresult UpdateEntrySize(nsCacheEntry *entry, PRUint32 newSize);
diff -r 6de576aeff11 netwerk/dns/src/effective_tld_names.dat
--- a/netwerk/dns/src/effective_tld_names.dat	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/dns/src/effective_tld_names.dat	Thu Aug 28 21:06:42 2008 +0300
@@ -19,10 +19,12 @@
 // the Initial Developer. All Rights Reserved.
 // 
 // Contributor(s):
 //   Ruben Arakelyan <ruben@wackomenace.co.uk>
 //   Gervase Markham <gerv@gerv.net>
+//   Pamela Greene <pamg.bugs@gmail.com>
+//   David Triendl <david@triendl.name>
 //   The kind representatives of many TLD registries
 // 
 // Alternatively, the contents of this file may be used under the terms of
 // either the GNU General Public License Version 2 or later (the "GPL"), or
 // the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
@@ -192,12 +194,18 @@ net.an
 net.an
 org.an
 edu.an
 
 // ao : http://en.wikipedia.org/wiki/.ao
-// list of 2nd level TLDs ?
+// http://www.dns.ao/REGISTR.DOC
 ao
+ed.ao
+gv.ao
+og.ao
+co.ao
+pb.ao
+it.ao
 
 // aq : http://en.wikipedia.org/wiki/.aq
 aq
 
 // ar : http://en.wikipedia.org/wiki/.ar
@@ -211,18 +219,22 @@ aq
 !promocion.ar
 !retina.ar
 !uba.ar
 
 // arpa : http://en.wikipedia.org/wiki/.arpa
+// Confirmed by registry <iana-questions@icann.org> 2008-06-18
 e164.arpa
 in-addr.arpa
 ip6.arpa
 uri.arpa
 urn.arpa
 
 // as : http://en.wikipedia.org/wiki/.as
 as
+
+// asia: http://en.wikipedia.org/wiki/.asia
+asia
 
 // at : http://en.wikipedia.org/wiki/.at
 // Confirmed by registry <it@nic.at> 2008-06-17
 at
 gv.at
@@ -305,21 +317,65 @@ be
 be
 ac.be
 
 // bf : http://en.wikipedia.org/wiki/.bf
 bf
+gov.bf
 
 // bg : http://en.wikipedia.org/wiki/.bg
+// https://www.register.bg/user/static/rules/en/index.html
 bg
+a.bg
+b.bg
+c.bg
+d.bg
+e.bg
+f.bg
+g.bg
+h.bg
+i.bg
+j.bg
+k.bg
+l.bg
+m.bg
+n.bg
+o.bg
+p.bg
+q.bg
+r.bg
+s.bg
+t.bg
+u.bg
+v.bg
+w.bg
+x.bg
+y.bg
+z.bg
+0.bg
+1.bg
+2.bg
+3.bg
+4.bg
+5.bg
+6.bg
+7.bg
+8.bg
+9.bg	 	 	
 
 // bh : http://en.wikipedia.org/wiki/.bh
-// list of 2nd level tlds ?
+// list of other 2nd level tlds ?
 bh
+com.bh
 
 // bi : http://en.wikipedia.org/wiki/.bi
-// list of 2nd level tlds ?
+// http://whois.nic.bi/
 bi
+co.bi
+com.bi
+edu.bi
+or.bi
+org.bi
 
 // biz : http://en.wikipedia.org/wiki/.biz
 biz
 
 // bj : http://en.wikipedia.org/wiki/.bj
@@ -349,10 +405,11 @@ mil.bo
 mil.bo
 tv.bo
 
 // br : http://en.wikipedia.org/wiki/.br
 // http://registro.br/info/dpn.html
+// Confirmed by registry <fneves@registro.br> 2008-06-24
 br
 adm.br
 adv.br
 agr.br
 am.br
@@ -360,10 +417,11 @@ art.br
 art.br
 ato.br
 bio.br
 blog.br
 bmd.br
+can.br
 cim.br
 cng.br
 cnt.br
 com.br
 coop.br
@@ -428,20 +486,35 @@ gov.bs
 
 // bv : No registrations at this time.
 // Submitted by registry <jarle@uninett.no> 2006-06-16
 
 // bw : http://en.wikipedia.org/wiki/.bw
-// list of 2nd level tlds ?
+// http://www.gobin.info/domainname/bw.doc
+// list of other 2nd level tlds ?
 bw
+co.bw
+org.bw
 
 // by : http://en.wikipedia.org/wiki/.by
-// list of 2nd level tlds ?
+// http://tld.by/rules_2006_en.html
+// list of other 2nd level tlds ?
 by
+gov.by
+mil.by
+// Official information does not indicate that com.by is a reserved
+// second-level domain, but it's being used as one (see www.google.com.by and
+// www.yahoo.com.by, for example), so we list it here for safety's sake.
+com.by
 
 // bz : http://en.wikipedia.org/wiki/.bz
-// list of 2nd level tlds ?
+// http://www.belizenic.bz/
 bz
+com.bz
+net.bz
+org.bz
+edu.bz
+gov.bz
 
 // ca : http://en.wikipedia.org/wiki/.ca
 ca
 // ca geographical names
 ab.ca
@@ -464,11 +537,13 @@ cat
 
 // cc : http://en.wikipedia.org/wiki/.cc
 cc
 
 // cd : http://en.wikipedia.org/wiki/.cd
+// see also: https://www.nic.cd/domain/insertDomain_2.jsp?act=1
 cd
+gov.cd
 
 // cf : http://en.wikipedia.org/wiki/.cf
 cf
 
 // cg : http://en.wikipedia.org/wiki/.cg
@@ -476,21 +551,39 @@ cg
 
 // ch : http://en.wikipedia.org/wiki/.ch
 ch
 
 // ci : http://en.wikipedia.org/wiki/.ci
-// list of 2nd level tlds ?
+// http://www.nic.ci/index.php?page=charte
 ci
+org.ci
+or.ci
+com.ci
+co.ci
+edu.ci
+ed.ci
+ac.ci
+net.ci
+go.ci
+asso.ci
+aroport.ci
+int.ci
+presse.ci
+md.ci
+gouv.ci
 
 // ck : http://en.wikipedia.org/wiki/.ck
 *.ck
 
 // cl : http://en.wikipedia.org/wiki/.cl
 cl
+gov.cl
+gob.cl
 
 // cm : http://en.wikipedia.org/wiki/.cm
 cm
+gov.cm
 
 // cn : http://en.wikipedia.org/wiki/.cn
 // Submitted by registry <tanyaling@cnnic.cn> 2008-06-11
 cn
 ac.cn
@@ -597,19 +690,23 @@ inf.cu
 
 // cv : http://en.wikipedia.org/wiki/.cv
 cv
 
 // cx : http://en.wikipedia.org/wiki/.cx
+// list of other 2nd level tlds ?
 cx
+gov.cx
 
 // cy : http://en.wikipedia.org/wiki/.cy
 *.cy
 
 // cz : http://en.wikipedia.org/wiki/.cz
 cz
 
 // de : http://en.wikipedia.org/wiki/.de
+// Confirmed by registry <ops@denic.de> (with technical
+// reservations) 2008-07-01
 de
 
 // dj : http://en.wikipedia.org/wiki/.dj
 dj
 
@@ -636,15 +733,17 @@ asso.dz
 asso.dz
 pol.dz
 art.dz
 
 // ec : http://www.nic.ec/reg/paso1.asp
+// Submitted by registry <vabboud@nic.ec> 2008-07-04
 ec
 com.ec
 info.ec
 net.ec
 fin.ec
+k12.ec
 med.ec
 pro.ec
 org.ec
 edu.ec
 gov.ec
@@ -814,11 +913,15 @@ gs
 
 // gw : http://en.wikipedia.org/wiki/.gw
 gw
 
 // gy : http://en.wikipedia.org/wiki/.gy
+// http://registry.gy/
 gy
+co.gy
+com.gy
+net.gy
 
 // hk : https://www.hkdnr.hk
 // Submitted by registry <hk.tech@hkirc.hk> 2008-06-11
 hk
 com.hk
@@ -954,16 +1057,18 @@ mil.in
 
 // info : http://en.wikipedia.org/wiki/.info
 info
 
 // int : http://en.wikipedia.org/wiki/.int
+// Confirmed by registry <iana-questions@icann.org> 2008-06-18
 int
 eu.int
 
 // io : http://www.nic.io/rules.html
-// list of 2nd level tlds ?
+// list of other 2nd level tlds ?
 io
+com.io
 
 // iq : http://en.wikipedia.org/wiki/.iq
 // no registrar website found, but google shows .gov.iq and .edu.iq websites
 iq
 gov.iq
@@ -1412,14 +1517,39 @@ gov.ki
 gov.ki
 info.ki
 com.ki
 
 // km : http://en.wikipedia.org/wiki/.km
+// http://www.domaine.km/documents/charte.doc
 km
+org.km
+nom.km
+gov.km
+prd.km
+tm.km
+edu.km
+mil.km
+ass.km
+com.km
+// These are only mentioned as proposed suggestions at domaine.km, but
+// http://en.wikipedia.org/wiki/.km says they're available for registration:
+coop.km
+asso.km
+presse.km
+medecin.km
+notaires.km
+pharmaciens.km
+veterinaire.km
+gouv.km
 
 // kn : http://en.wikipedia.org/wiki/.kn
+// http://www.dot.kn/domainRules.html
 kn
+net.kn
+org.kn
+edu.kn
+gov.kn
 
 // kr : http://domain.nida.or.kr/eng/structure.jsp
 kr
 ac.kr
 co.kr
@@ -1565,24 +1695,37 @@ med.ly
 med.ly
 org.ly
 id.ly
 
 // ma : http://en.wikipedia.org/wiki/.ma
-// list of 2nd level tlds ?
+// http://www.anrt.ma/fr/admin/download/upload/file_fr782.pdf
 ma
 co.ma
 net.ma
 gov.ma
 org.ma
+ac.ma
+press.ma
 
 // mc : http://www.nic.mc/
 mc
 tm.mc
 asso.mc
 
 // md : http://en.wikipedia.org/wiki/.md
 md
+
+// me : http://en.wikipedia.org/wiki/.me
+me
+co.me
+net.me
+org.me
+edu.me
+ac.me
+gov.me
+its.me
+priv.me
 
 // mg : http://www.nic.mg/tarif.htm
 mg
 org.mg
 nom.mg
@@ -1598,17 +1741,19 @@ mh
 
 // mil : http://en.wikipedia.org/wiki/.mil
 mil
 
 // mk : http://en.wikipedia.org/wiki/.mk
-// list of 2nd level tlds ?
+// see also: http://dns.marnet.net.mk/postapka.php
 mk
 com.mk
-gov.mk
 org.mk
 net.mk
 edu.mk
+gov.mk
+inf.mk
+name.mk
 
 // ml : http://www.gobin.info/domainname/ml-template.doc
 *.ml
 
 // mm : http://en.wikipedia.org/wiki/.mm
@@ -1638,24 +1783,579 @@ mp
 // mq : http://en.wikipedia.org/wiki/.mq
 mq
 
 // mr : http://en.wikipedia.org/wiki/.mr
 mr
+gov.mr
 
 // ms : http://en.wikipedia.org/wiki/.ms
 ms
 
 // mt : https://www.nic.org.mt/dotmt/
 *.mt
 
 // mu : http://en.wikipedia.org/wiki/.mu
-// list of 2nd level tlds ?
 mu
+com.mu
+net.mu
+org.mu
+gov.mu
+ac.mu
+co.mu
+or.mu
 
 // museum : http://about.museum/naming/
-// there are 2nd-level TLD's, but there's no list
+// http://index.museum/
 museum
+academy.museum
+agriculture.museum
+air.museum
+airguard.museum
+alabama.museum
+alaska.museum
+amber.museum
+ambulance.museum
+american.museum
+americana.museum
+americanantiques.museum
+americanart.museum
+amsterdam.museum
+and.museum
+annefrank.museum
+anthro.museum
+anthropology.museum
+antiques.museum
+aquarium.museum
+arboretum.museum
+archaeological.museum
+archaeology.museum
+architecture.museum
+art.museum
+artanddesign.museum
+artcenter.museum
+artdeco.museum
+arteducation.museum
+artgallery.museum
+arts.museum
+artsandcrafts.museum
+asmatart.museum
+assassination.museum
+assisi.museum
+association.museum
+astronomy.museum
+atlanta.museum
+austin.museum
+australia.museum
+automotive.museum
+aviation.museum
+axis.museum
+badajoz.museum
+baghdad.museum
+bahn.museum
+bale.museum
+baltimore.museum
+barcelona.museum
+baseball.museum
+basel.museum
+baths.museum
+bauern.museum
+beauxarts.museum
+beeldengeluid.museum
+bellevue.museum
+bergbau.museum
+berkeley.museum
+berlin.museum
+bern.museum
+bible.museum
+bilbao.museum
+bill.museum
+birdart.museum
+birthplace.museum
+bonn.museum
+boston.museum
+botanical.museum
+botanicalgarden.museum
+botanicgarden.museum
+botany.museum
+brandywinevalley.museum
+brasil.museum
+bristol.museum
+british.museum
+britishcolumbia.museum
+broadcast.museum
+brunel.museum
+brussel.museum
+brussels.museum
+bruxelles.museum
+building.museum
+burghof.museum
+bus.museum
+bushey.museum
+cadaques.museum
+california.museum
+cambridge.museum
+can.museum
+canada.museum
+capebreton.museum
+carrier.museum
+cartoonart.museum
+casadelamoneda.museum
+castle.museum
+castres.museum
+celtic.museum
+center.museum
+chattanooga.museum
+cheltenham.museum
+chesapeakebay.museum
+chicago.museum
+children.museum
+childrens.museum
+childrensgarden.museum
+chiropractic.museum
+chocolate.museum
+christiansburg.museum
+cincinnati.museum
+cinema.museum
+circus.museum
+civilisation.museum
+civilization.museum
+civilwar.museum
+clinton.museum
+clock.museum
+coal.museum
+coastaldefence.museum
+cody.museum
+coldwar.museum
+collection.museum
+colonialwilliamsburg.museum
+coloradoplateau.museum
+columbia.museum
+columbus.museum
+communication.museum
+communications.museum
+community.museum
+computer.museum
+computerhistory.museum
+comunicaes.museum
+contemporary.museum
+contemporaryart.museum
+convent.museum
+copenhagen.museum
+corporation.museum
+correios-e-telecomunicaes.museum
+corvette.museum
+costume.museum
+countryestate.museum
+county.museum
+crafts.museum
+cranbrook.museum
+creation.museum
+cultural.museum
+culturalcenter.museum
+culture.museum
+cyber.museum
+cymru.museum
+dali.museum
+dallas.museum
+database.museum
+ddr.museum
+decorativearts.museum
+delaware.museum
+delmenhorst.museum
+denmark.museum
+depot.museum
+design.museum
+detroit.museum
+dinosaur.museum
+discovery.museum
+dolls.museum
+donostia.museum
+durham.museum
+eastafrica.museum
+eastcoast.museum
+education.museum
+educational.museum
+egyptian.museum
+eisenbahn.museum
+elburg.museum
+elvendrell.museum
+embroidery.museum
+encyclopedic.museum
+england.museum
+entomology.museum
+environment.museum
+environmentalconservation.museum
+epilepsy.museum
+essex.museum
+estate.museum
+ethnology.museum
+exeter.museum
+exhibition.museum
+family.museum
+farm.museum
+farmequipment.museum
+farmers.museum
+farmstead.museum
+field.museum
+figueres.museum
+filatelia.museum
+film.museum
+fineart.museum
+finearts.museum
+finland.museum
+flanders.museum
+florida.museum
+force.museum
+fortmissoula.museum
+fortworth.museum
+foundation.museum
+francaise.museum
+frankfurt.museum
+franziskaner.museum
+freemasonry.museum
+freiburg.museum
+fribourg.museum
+frog.museum
+fundacio.museum
+furniture.museum
+gallery.museum
+garden.museum
+gateway.museum
+geelvinck.museum
+gemological.museum
+geology.museum
+georgia.museum
+giessen.museum
+glas.museum
+glass.museum
+gorge.museum
+grandrapids.museum
+graz.museum
+guernsey.museum
+halloffame.museum
+hamburg.museum
+handson.museum
+harvestcelebration.museum
+hawaii.museum
+health.museum
+heimatunduhren.museum
+hellas.museum
+helsinki.museum
+hembygdsforbund.museum
+heritage.museum
+histoire.museum
+historical.museum
+historicalsociety.museum
+historichouses.museum
+historisch.museum
+historisches.museum
+history.museum
+historyofscience.museum
+horology.museum
+house.museum
+humanities.museum
+illustration.museum
+imageandsound.museum
+indian.museum
+indiana.museum
+indianapolis.museum
+indianmarket.museum
+intelligence.museum
+interactive.museum
+iraq.museum
+iron.museum
+isleofman.museum
+jamison.museum
+jefferson.museum
+jerusalem.museum
+jewelry.museum
+jewish.museum
+jewishart.museum
+jfk.museum
+journalism.museum
+judaica.museum
+judygarland.museum
+juedisches.museum
+juif.museum
+karate.museum
+karikatur.museum
+kids.museum
+koebenhavn.museum
+koeln.museum
+kunst.museum
+kunstsammlung.museum
+kunstunddesign.museum
+labor.museum
+labour.museum
+lajolla.museum
+lancashire.museum
+landes.museum
+lans.museum
+lns.museum
+larsson.museum
+lewismiller.museum
+lincoln.museum
+linz.museum
+living.museum
+livinghistory.museum
+localhistory.museum
+london.museum
+losangeles.museum
+louvre.museum
+loyalist.museum
+lucerne.museum
+luxembourg.museum
+luzern.museum
+mad.museum
+madrid.museum
+mallorca.museum
+manchester.museum
+mansion.museum
+mansions.museum
+manx.museum
+marburg.museum
+maritime.museum
+maritimo.museum
+maryland.museum
+marylhurst.museum
+media.museum
+medical.museum
+medizinhistorisches.museum
+meeres.museum
+memorial.museum
+mesaverde.museum
+michigan.museum
+midatlantic.museum
+military.museum
+mill.museum
+miners.museum
+mining.museum
+minnesota.museum
+missile.museum
+missoula.museum
+modern.museum
+moma.museum
+money.museum
+monmouth.museum
+monticello.museum
+montreal.museum
+moscow.museum
+motorcycle.museum
+muenchen.museum
+muenster.museum
+mulhouse.museum
+muncie.museum
+museet.museum
+museumcenter.museum
+museumvereniging.museum
+music.museum
+national.museum
+nationalfirearms.museum
+nationalheritage.museum
+nativeamerican.museum
+naturalhistory.museum
+naturalhistorymuseum.museum
+naturalsciences.museum
+nature.museum
+naturhistorisches.museum
+natuurwetenschappen.museum
+naumburg.museum
+naval.museum
+nebraska.museum
+neues.museum
+newhampshire.museum
+newjersey.museum
+newmexico.museum
+newport.museum
+newspaper.museum
+newyork.museum
+niepce.museum
+norfolk.museum
+north.museum
+nrw.museum
+nuernberg.museum
+nuremberg.museum
+nyc.museum
+nyny.museum
+oceanographic.museum
+oceanographique.museum
+omaha.museum
+online.museum
+ontario.museum
+openair.museum
+oregon.museum
+oregontrail.museum
+otago.museum
+oxford.museum
+pacific.museum
+paderborn.museum
+palace.museum
+paleo.museum
+palmsprings.museum
+panama.museum
+paris.museum
+pasadena.museum
+pharmacy.museum
+philadelphia.museum
+philadelphiaarea.museum
+philately.museum
+phoenix.museum
+photography.museum
+pilots.museum
+pittsburgh.museum
+planetarium.museum
+plantation.museum
+plants.museum
+plaza.museum
+portal.museum
+portland.museum
+portlligat.museum
+posts-and-telecommunications.museum
+preservation.museum
+presidio.museum
+press.museum
+project.museum
+public.museum
+pubol.museum
+quebec.museum
+railroad.museum
+railway.museum
+research.museum
+resistance.museum
+riodejaneiro.museum
+rochester.museum
+rockart.museum
+roma.museum
+russia.museum
+saintlouis.museum
+salem.museum
+salvadordali.museum
+salzburg.museum
+sandiego.museum
+sanfrancisco.museum
+santabarbara.museum
+santacruz.museum
+santafe.museum
+saskatchewan.museum
+satx.museum
+savannahga.museum
+schlesisches.museum
+schoenbrunn.museum
+schokoladen.museum
+school.museum
+schweiz.museum
+science.museum
+scienceandhistory.museum
+scienceandindustry.museum
+sciencecenter.museum
+sciencecenters.museum
+science-fiction.museum
+sciencehistory.museum
+sciences.museum
+sciencesnaturelles.museum
+scotland.museum
+seaport.museum
+settlement.museum
+settlers.museum
+shell.museum
+sherbrooke.museum
+sibenik.museum
+silk.museum
+ski.museum
+skole.museum
+society.museum
+sologne.museum
+soundandvision.museum
+southcarolina.museum
+southwest.museum
+space.museum
+spy.museum
+square.museum
+stadt.museum
+stalbans.museum
+starnberg.museum
+state.museum
+stateofdelaware.museum
+station.museum
+steam.museum
+steiermark.museum
+stjohn.museum
+stockholm.museum
+stpetersburg.museum
+stuttgart.museum
+suisse.museum
+surgeonshall.museum
+surrey.museum
+svizzera.museum
+sweden.museum
+sydney.museum
+tank.museum
+tcm.museum
+technology.museum
+telekommunikation.museum
+television.museum
+texas.museum
+textile.museum
+theater.museum
+time.museum
+timekeeping.museum
+topology.museum
+torino.museum
+touch.museum
+town.museum
+transport.museum
+tree.museum
+trolley.museum
+trust.museum
+trustee.museum
+uhren.museum
+ulm.museum
+undersea.museum
+university.museum
+usa.museum
+usantiques.museum
+usarts.museum
+uscountryestate.museum
+usculture.museum
+usdecorativearts.museum
+usgarden.museum
+ushistory.museum
+ushuaia.museum
+uslivinghistory.museum
+utah.museum
+uvic.museum
+valley.museum
+vantaa.museum
+versailles.museum
+viking.museum
+village.museum
+virginia.museum
+virtual.museum
+virtuel.museum
+vlaanderen.museum
+volkenkunde.museum
+wales.museum
+wallonie.museum
+war.museum
+washingtondc.museum
+watchandclock.museum
+watch-and-clock.museum
+western.museum
+westfalen.museum
+whaling.museum
+wildlife.museum
+williamsburg.museum
+windmill.museum
+workshop.museum
+york.museum
+yorkshire.museum
+yosemite.museum
+youth.museum
+zoological.museum
+zoology.museum
+.museum
+.museum
 
 // mv : http://en.wikipedia.org/wiki/.mv
 *.mv
 
 // mw : http://www.registrar.mw/
@@ -1670,13 +2370,11 @@ int.mw
 int.mw
 net.mw
 org.mw
 
 // mx : http://www.nic.mx/
-// 2008-06-23 - Wikipedia says second level registrations are prohibited,
-// but several exist. So, for safety, switched from "*.mx" to the below
-// ruleset until the situation is more clear.
+// Submitted by registry <farias@nic.mx> 2008-06-19
 mx
 com.mx
 org.mx
 gob.mx
 edu.mx
@@ -1687,12 +2385,29 @@ net.mx
 
 // mz : http://www.gobin.info/domainname/mz-template.doc
 *.mz
 
 // na : http://www.na-nic.com.na/
-// list of 2nd level tlds ?
+// http://www.info.na/domain/
 na
+info.na
+pro.na
+name.na
+school.na
+or.na
+dr.na
+us.na
+mx.na
+ca.na
+in.na
+cc.na
+tv.na
+ws.na
+mobi.na
+co.na
+com.na
+org.na
 
 // name : has 2nd-level tlds, but there's no list of them
 name
 
 // nc : http://www.cctld.nc/
@@ -2536,11 +3251,37 @@ org
 // CentralNic names : http://www.centralnic.com/names/domains
 // Submitted by registry <gavin.brown@centralnic.com> 2008-06-17
 ae.org
 
 // pa : http://www.nic.pa/
+// List with redundant entries as submitted by registry <edna.samudio@utp.ac.pa> 2008-06-18
+//*.pa
+//!nic.pa
+//!pannet.pa
+//!presidencia.pa
+//!milpolleras.pa
+//!sume911.pa
+//!root-ca.pa
+//ac.pa
+//gob.pa
+//com.pa
+//org.pa
+//sld.pa
+//edu.pa
+//net.pa
+//ing.pa
+//abo.pa
+//med.pa
+//nom.pa
+// As discussed in bug #447815 on bugzilla.mozilla.org, the list has been truncated.
 *.pa
+!nic.pa
+!pannet.pa
+!presidencia.pa
+!milpolleras.pa
+!sume911.pa
+!root-ca.pa
 
 // pe : http://www.nic.pe/normas-proced-i.htm
 *.pe
 
 // pf : http://www.gobin.info/domainname/formulaire-pf.pdf
@@ -2804,11 +3545,11 @@ law.pro
 law.pro
 med.pro
 eng.pro
 
 // ps : http://en.wikipedia.org/wiki/.ps
-// list of 2nd level tlds ?
+// http://www.nic.ps/registration/policy.html#reg
 ps
 edu.ps
 gov.ps
 sec.ps
 plo.ps
@@ -2854,18 +3595,154 @@ arts.ro
 arts.ro
 firm.ro
 store.ro
 www.ro
 
+// rs : http://en.wikipedia.org/wiki/.rs
+rs
+co.rs
+org.rs
+edu.rs
+ac.rs
+gov.rs
+in.rs
+
 // ru : http://en.wikipedia.org/wiki/.ru
 ru
+ac.ru
 com.ru
 net.ru
 org.ru
 pp.ru
 int.ru
-// there should be geo-names like msk.ru, but I didn't find a list
+// Geographic domains (http://www.ripn.net:8082/nic/dns/geo_list.html)
+adygeya.ru
+altai.ru
+amur.ru
+arkhangelsk.ru
+astrakhan.ru
+bashkiria.ru
+belgorod.ru
+bir.ru
+bryansk.ru
+buryatia.ru
+cbg.ru
+chel.ru
+chelyabinsk.ru
+chita.ru
+chukotka.ru
+chuvashia.ru
+dagestan.ru
+dudinka.ru
+e-burg.ru
+grozny.ru
+irkutsk.ru
+ivanovo.ru
+izhevsk.ru
+jar.ru
+joshkar-ola.ru
+kalmykia.ru
+kaluga.ru
+kamchatka.ru
+karelia.ru
+kazan.ru
+kchr.ru
+kemerovo.ru
+khabarovsk.ru
+khakassia.ru
+khv.ru
+kirov.ru
+koenig.ru
+komi.ru
+kostroma.ru
+krasnoyarsk.ru
+kuban.ru
+kurgan.ru
+kursk.ru
+lipetsk.ru
+magadan.ru
+mari-el.ru
+marine.ru
+mari.ru
+mordovia.ru
+mosreg.ru
+msk.ru
+murmansk.ru
+nalchik.ru
+nnov.ru
+novosibirsk.ru
+nov.ru
+nsk.ru
+omsk.ru
+orenburg.ru
+oryol.ru
+palana.ru
+penza.ru
+perm.ru
+pskov.ru
+ptz.ru
+rnd.ru
+ryazan.ru
+sakhalin.ru
+samara.ru
+saratov.ru
+simbirsk.ru
+smolensk.ru
+spb.ru
+stavropol.ru
+stv.ru
+surgut.ru
+tambov.ru
+tatarstan.ru
+tom.ru
+tomsk.ru
+tsaritsyn.ru
+tsk.ru
+tula.ru
+tuva.ru
+tver.ru
+tyumen.ru
+udm.ru
+udmurtia.ru
+ulan-ude.ru
+vladikavkaz.ru
+vladimir.ru
+vladivostok.ru
+volgograd.ru
+vologda.ru
+voronezh.ru
+vrn.ru
+vyatka.ru
+yakutia.ru
+yamal.ru
+yaroslavl.ru
+yekaterinburg.ru
+yuzhno-sakhalinsk.ru
+// Geographic domains registered before the adoption of the rules on the
+// second level domain registration
+amursk.ru
+baikal.ru
+cmw.ru
+fareast.ru
+jamal.ru
+kms.ru
+k-uralsk.ru
+kustanai.ru
+kuzbass.ru
+magnitka.ru
+mytis.ru
+nakhodka.ru
+nkz.ru
+norilsk.ru
+oskol.ru
+pyatigorsk.ru
+rubtsovsk.ru
+snz.ru
+syzran.ru
+tagil.ru
+vdonsk.ru
+zgrad.ru
 
 // rw : http://www.nic.rw/cgi-bin/policy.pl
 rw
 gov.rw
 net.rw
@@ -2876,10 +3753,21 @@ int.rw
 int.rw
 mil.rw
 gouv.rw
 
 // sa : http://www.saudinic.net.sa/page.php?page=1&lang=1
+// List with redundant entries as submitted by registry <sa-tld-tech-contact@nic.net.sa> 2008-06-23
+//*.sa
+//com.sa
+//net.sa
+//org.sa
+//gov.sa
+//med.sa
+//pub.sa
+//edu.sa
+//sch.sa
+// As discussed in bug #447815 on bugzilla.mozilla.org, the list has been truncated.
 *.sa
 
 // sb : http://www.sbnic.net.sb/
 // Submitted by registry <lee.humphries@telekom.com.sb> 2008-06-08
 sb
@@ -2907,39 +3795,51 @@ med.sd
 med.sd
 gov.sd
 info.sd
 
 // se : http://en.wikipedia.org/wiki/.se
-se
-org.se
-pp.se
-tm.se
-parti.se
-press.se
-mil.se
-// se geographical names
-ab.se
+// Submitted by registry <Patrik.Wallstrom@iis.se> 2008-06-24
+a.se
+ac.se
+b.se
+bd.se
+brand.se
 c.se
 d.se
 e.se
 f.se
+fh.se
+fhsk.se
+fhv.se
 g.se
 h.se
 i.se
 k.se
+komforb.se
+kommunalforbund.se
+komvux.se
+l.se
+lanbib.se
 m.se
 n.se
+naturbruksgymn.se
 o.se
+org.se
+p.se
+parti.se
+pp.se
+press.se
+r.se
 s.se
+sshn.se
 t.se
+tm.se
 u.se
 w.se
 x.se
 y.se
 z.se
-ac.se
-bd.se
 
 // sg : http://www.nic.net.sg/sub_policies_agreement/2ld.html
 sg
 com.sg
 net.sg
@@ -2957,10 +3857,11 @@ si
 
 // sj : No registrations at this time.
 // Submitted by registry <jarle@uninett.no> 2008-06-16
 
 // sk : http://en.wikipedia.org/wiki/.sk
+// list of 2nd level domains ?
 sk
 
 // sl : http://www.nic.sl
 // Submitted by registry <adam@neoip.com> 2008-06-12
 sl
@@ -2972,11 +3873,10 @@ org.sl
 
 // sm : http://en.wikipedia.org/wiki/.sm
 sm
 
 // sn : http://en.wikipedia.org/wiki/.sn
-// list of 2nd level domains ?
 sn
 
 // sr : http://en.wikipedia.org/wiki/.sr
 sr
 
@@ -2991,12 +3891,15 @@ su
 
 // sy : http://www.gobin.info/domainname/sy.doc
 *.sy
 
 // sz : http://en.wikipedia.org/wiki/.sz
-// list of 2nd level domains ?
+// http://www.sispa.org.sz/
 sz
+co.sz
+ac.sz
+org.sz
 
 // tc : http://en.wikipedia.org/wiki/.tc
 tc
 
 // td : http://en.wikipedia.org/wiki/.td
@@ -3004,11 +3907,12 @@ td
 
 // tf : http://en.wikipedia.org/wiki/.tf
 tf
 
 // tg : http://en.wikipedia.org/wiki/.tg
-// list of 2nd level domains ?
+// http://www.nic.tg/nictg/index.php implies no reserved 2nd-level domains,
+// although this contradicts wikipedia.
 tg
 
 // th : http://en.wikipedia.org/wiki/.th
 // Submitted by registry <krit@thains.co.th> 2008-06-17
 th
@@ -3038,20 +3942,40 @@ mil.tj
 
 // tk : http://en.wikipedia.org/wiki/.tk
 tk
 
 // tl : http://en.wikipedia.org/wiki/.tl
-// list of 2nd level tlds ?
 tl
+gov.tl
 
 // tm : http://www.nic.tm/rules.html
 // list of 2nd level tlds ?
 tm
 
 // tn : http://en.wikipedia.org/wiki/.tn
-// list of 2nd level tlds ?
+// http://whois.ati.tn/
 tn
+com.tn
+ens.tn
+fin.tn
+gov.tn
+ind.tn
+intl.tn
+nat.tn
+net.tn
+org.tn
+info.tn
+perso.tn
+tourism.tn
+edunet.tn
+rnrt.tn
+rns.tn
+rnu.tn
+mincom.tn
+agrinet.tn
+defense.tn
+turen.tn
 
 // to : http://en.wikipedia.org/wiki/.to
 // Submitted by registry <egullich@colo.to> 2008-06-17
 to
 com.to
@@ -3086,12 +4010,16 @@ name.tt
 name.tt
 gov.tt
 edu.tt
 
 // tv : http://en.wikipedia.org/wiki/.tv
-// list of 2nd level tlds ?
+// list of other 2nd level tlds ?
 tv
+com.tv
+net.tv
+org.tv
+gov.tv
 
 // tw : http://en.wikipedia.org/wiki/.tw
 tw
 edu.tw
 gov.tw
@@ -3319,11 +4247,17 @@ health.vn
 // vu : http://en.wikipedia.org/wiki/.vu
 // list of 2nd level tlds ?
 vu
 
 // ws : http://en.wikipedia.org/wiki/.ws
+// http://samoanic.ws/index.dhtml
 ws
+com.ws
+net.ws
+org.ws
+gov.ws
+edu.ws
 
 // ye : http://www.y.net.ye/services/domain_name.htm
 *.ye
 
 // yu : http://www.nic.yu/pravilnik-e.html
diff -r 6de576aeff11 netwerk/protocol/file/src/nsFileProtocolHandler.cpp
--- a/netwerk/protocol/file/src/nsFileProtocolHandler.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/protocol/file/src/nsFileProtocolHandler.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -112,27 +112,26 @@ nsFileProtocolHandler::ReadURLFile(nsIFi
 
     HRESULT result;
 
     rv = NS_ERROR_NOT_AVAILABLE;
 
-    IUniformResourceLocator* urlLink = nsnull;
+    IUniformResourceLocatorW* urlLink = nsnull;
     result = ::CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
-                                IID_IUniformResourceLocator, (void**)&urlLink);
+                                IID_IUniformResourceLocatorW, (void**)&urlLink);
     if (SUCCEEDED(result) && urlLink) {
         IPersistFile* urlFile = nsnull;
         result = urlLink->QueryInterface(IID_IPersistFile, (void**)&urlFile);
         if (SUCCEEDED(result) && urlFile) {
             result = urlFile->Load(path.get(), STGM_READ);
             if (SUCCEEDED(result) ) {
-                LPSTR lpTemp = nsnull;
+                LPWSTR lpTemp = nsnull;
 
                 // The URL this method will give us back seems to be already
                 // escaped. Hence, do not do escaping of our own.
                 result = urlLink->GetURL(&lpTemp);
                 if (SUCCEEDED(result) && lpTemp) {
-                    rv = NS_NewURI(aURI, lpTemp);
-
+                    rv = NS_NewURI(aURI, nsDependentString(lpTemp));
                     // free the string that GetURL alloc'd
                     CoTaskMemFree(lpTemp);
                 }
             }
             urlFile->Release();
diff -r 6de576aeff11 netwerk/system/win32/nsNotifyAddrListener.cpp
--- a/netwerk/system/win32/nsNotifyAddrListener.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/netwerk/system/win32/nsNotifyAddrListener.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -73,11 +73,11 @@ static void InitIPHelperLibrary(void)
 static void InitIPHelperLibrary(void)
 {
     if (sIPHelper)
         return;
 
-    sIPHelper = LoadLibraryA("iphlpapi.dll");
+    sIPHelper = LoadLibraryW(L"iphlpapi.dll");
     if (!sIPHelper)
         return;
 
     sGetAdaptersAddresses = (GetAdaptersAddressesFunc)
         GetProcAddress(sIPHelper, "GetAdaptersAddresses");
diff -r 6de576aeff11 rdf/datasource/src/nsFileSystemDataSource.cpp
--- a/rdf/datasource/src/nsFileSystemDataSource.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/rdf/datasource/src/nsFileSystemDataSource.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -926,18 +926,19 @@ FileSystemDataSource::GetVolumeList(nsIS
 #endif
 
 #if defined (XP_WIN) && !defined (WINCE)
 
     PRInt32         driveType;
-    char            drive[32];
+    PRUnichar       drive[32];
     PRInt32         volNum;
     char            *url;
 
     for (volNum = 0; volNum < 26; volNum++)
     {
-        sprintf(drive, "%c:\\", volNum + 'A');
-        driveType = GetDriveType(drive);
+        swprintf( drive, L"%c:\\", volNum + (PRUnichar)'A');
+
+        driveType = GetDriveTypeW(drive);
         if (driveType != DRIVE_UNKNOWN && driveType != DRIVE_NO_ROOT_DIR)
         {
             if (nsnull != (url = PR_smprintf("file:///%c|/", volNum + 'A')))
             {
                 rv = mRDFService->GetResource(nsDependentCString(url),
diff -r 6de576aeff11 storage/src/mozStorageBackground.cpp
--- a/storage/src/mozStorageBackground.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/storage/src/mozStorageBackground.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -1,7 +1,7 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 sts=2
+ * vim: sw=2 ts=2 sts=2 expandtab
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
@@ -14,11 +14,11 @@
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Mozilla Corporation. 
+ * Mozilla Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2008
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
@@ -35,20 +35,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#include "nsAutoLock.h"
-#include "nsIFile.h"
 #include "nsIThreadPool.h"
 #include "nsXPCOMCIDInternal.h"
 #include "nsIObserver.h"
 #include "nsIObserverService.h"
+#include "nsServiceManagerUtils.h"
 
 #include "mozStorageCID.h"
-#include "mozIStorageService.h"
-#include "mozStorageConnection.h"
 #include "mozStorageBackground.h"
 
 namespace {
   class ThreadShutdownObserver : public nsIObserver
   {
diff -r 6de576aeff11 storage/src/mozStorageBackground.h
--- a/storage/src/mozStorageBackground.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/storage/src/mozStorageBackground.h	Thu Aug 28 21:06:42 2008 +0300
@@ -1,7 +1,7 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 sts=2
+ * vim: sw=2 ts=2 sts=2 expandtab
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
@@ -14,11 +14,11 @@
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Mozilla Corporation. 
+ * Mozilla Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2008
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
@@ -45,14 +45,11 @@ class nsIThreadPool;
 class nsIThreadPool;
 class nsIEventTarget;
 class nsIObserver;
 
 /**
- * This class managed the connections used in the background for
- * asynchronous operations.  There is a one-to-one mapping of calling thread
- * connections to background ones.  Additionally, it manages the background
- * thread pool used for asynchronous database calls.
+ * Provides an event target to dispatch background events to for storage.
  *
  * @note This class is threadsafe.
  */
 class mozStorageBackground
 {
diff -r 6de576aeff11 storage/src/mozStorageStatement.cpp
--- a/storage/src/mozStorageStatement.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/storage/src/mozStorageStatement.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -1,7 +1,7 @@
 /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * vim: sw=4 ts=4 sts=4
+ * vim: sw=4 ts=4 sts=4 expandtab
  * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
@@ -85,11 +85,15 @@ protected:
 
 /**
  ** mozStorageStatement
  **/
 
-NS_IMPL_ISUPPORTS2(mozStorageStatement, mozIStorageStatement, mozIStorageValueArray)
+NS_IMPL_THREADSAFE_ISUPPORTS2(
+    mozStorageStatement
+,   mozIStorageStatement
+,   mozIStorageValueArray
+)
 
 mozStorageStatement::mozStorageStatement()
     : mDBConnection (nsnull), mDBStatement(nsnull), mColumnNames(nsnull), mExecuting(PR_FALSE)
 {
 }
diff -r 6de576aeff11 toolkit/components/alerts/src/mac/nsAlertsService.mm
--- a/toolkit/components/alerts/src/mac/nsAlertsService.mm	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/components/alerts/src/mac/nsAlertsService.mm	Thu Aug 28 21:06:42 2008 +0300
@@ -1,6 +1,8 @@
-/* ***** BEGIN LICENSE BLOCK *****
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
  * The contents of this file are subject to the Mozilla Public License Version
  * 1.1 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
@@ -90,11 +92,11 @@ DispatchNamedNotification(const nsAStrin
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 
   if ([GrowlApplicationBridge isGrowlInstalled] == NO ||
       [GrowlApplicationBridge isGrowlRunning] == NO)
     return NS_ERROR_NOT_AVAILABLE;
-  
+
   mozGrowlDelegate *delegate =
     static_cast<mozGrowlDelegate *>([GrowlApplicationBridge growlDelegate]);
   if (!delegate)
     return NS_ERROR_NOT_AVAILABLE;
 
@@ -180,18 +182,18 @@ nsAlertsService::ShowAlertNotification(c
 
   NS_ASSERTION(mDelegate->delegate == [GrowlApplicationBridge growlDelegate],
                "Growl Delegate was not registered properly.");
 
   if (!aAlertName.IsEmpty()) {
-    return DispatchNamedNotification(aAlertTitle, aImageUrl, aAlertTitle,
+    return DispatchNamedNotification(aAlertName, aImageUrl, aAlertTitle,
                                      aAlertText, aAlertCookie, aAlertListener);
   }
 
   nsresult rv;
   nsCOMPtr<nsIStringBundleService> bundleService =
     do_GetService("@mozilla.org/intl/stringbundle;1", &rv);
-  
+
   // We don't want to fail just yet if we can't get the alert name
   nsString name = NS_LITERAL_STRING("General Notification");
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIStringBundle> bundle;
     rv = bundleService->CreateBundle(GROWL_STRING_BUNDLE_LOCATION,
diff -r 6de576aeff11 toolkit/components/places/src/Makefile.in
--- a/toolkit/components/places/src/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/components/places/src/Makefile.in	Thu Aug 28 21:06:42 2008 +0300
@@ -105,10 +105,13 @@ LOCAL_INCLUDES += -I$(srcdir)/../../buil
 
 EXTRA_PP_COMPONENTS = nsLivemarkService.js \
                       nsTaggingService.js \
                       $(NULL)
 
-EXTRA_JS_MODULES = utils.js
+EXTRA_JS_MODULES = \
+  utils.js \
+  PlacesBackground.jsm \
+  $(NULL)
 
 EXTRA_PP_JS_MODULES = utils.js
 
 include $(topsrcdir)/config/rules.mk
diff -r 6de576aeff11 toolkit/components/places/src/PlacesBackground.jsm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/src/PlacesBackground.jsm	Thu Aug 28 21:06:42 2008 +0300
@@ -0,0 +1,105 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab filetype=javascript
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+var EXPORTED_SYMBOLS = [ "PlacesBackground" ];
+
+////////////////////////////////////////////////////////////////////////////////
+//// Constants
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+const kQuitApplication = "quit-application";
+
+////////////////////////////////////////////////////////////////////////////////
+//// nsPlacesBackgound class
+
+function nsPlacesBackground()
+{
+  let tm = Cc["@mozilla.org/thread-manager;1"].
+           getService(Ci.nsIThreadManager);
+  this._thread = tm.newThread(0);
+
+  let os = Cc["@mozilla.org/observer-service;1"].
+           getService(Ci.nsIObserverService);
+  os.addObserver(this, kQuitApplication, false);
+}
+
+nsPlacesBackground.prototype = {
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsIEventTarget
+
+  dispatch: function PlacesBackground_dispatch(aEvent, aFlags)
+  {
+    this._thread.dispatch(aEvent, aFlags);
+  },
+
+  isOnCurrentThread: function PlacesBackground_isOnCurrentThread()
+  {
+    return this._thread.isOnCurrentThread();
+  },
+
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsIObserver
+
+  observe: function PlacesBackground_observe(aSubject, aTopic, aData)
+  {
+    if (aTopic == kQuitApplication) {
+      this._thread.shutdown();
+      this._thread = null;
+    }
+  },
+
+  //////////////////////////////////////////////////////////////////////////////
+  //// nsISupports
+
+  QueryInterface: XPCOMUtils.generateQI([
+    Ci.nsIEventTarget,
+    Ci.nsIObserver,
+  ])
+};
+
+
+__defineGetter__("PlacesBackground", function() {
+  delete this.PlacesBackground;
+  return this.PlacesBackground = new nsPlacesBackground;
+});
diff -r 6de576aeff11 toolkit/components/places/tests/Makefile.in
--- a/toolkit/components/places/tests/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/components/places/tests/Makefile.in	Thu Aug 28 21:06:42 2008 +0300
@@ -46,10 +46,11 @@ include $(DEPTH)/config/autoconf.mk
 
 MODULE		= test_places
 
 XPCSHELL_TESTS = \
                  autocomplete \
+                 background \
                  bookmarks \
                  queries \
                  unit \
                  $(NULL)
 
diff -r 6de576aeff11 toolkit/components/places/tests/background/test_background.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/components/places/tests/background/test_background.js	Thu Aug 28 21:06:42 2008 +0300
@@ -0,0 +1,105 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: sw=2 ts=2 sts=2 expandtab
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+Components.utils.import("resource://gre/modules/PlacesBackground.jsm");
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+function test_service_exists()
+{
+  do_check_neq(PlacesBackground, null);
+}
+
+function test_isOnCurrentThread()
+{
+  do_check_false(PlacesBackground.isOnCurrentThread());
+
+  let event = {
+    run: function()
+    {
+      do_check_true(PlacesBackground.isOnCurrentThread());
+    }
+  };
+  PlacesBackground.dispatch(event, Ci.nsIEventTarget.DISPATCH_SYNC);
+}
+
+function test_two_events_same_thread()
+{
+  // This test imports PlacesBackground.jsm onto two different objects to
+  // ensure that the thread is the same for both.
+  let event = {
+    run: function()
+    {
+      let tm = Cc["@mozilla.org/thread-manager;1"].
+               getService(Ci.nsIThreadManager);
+
+      if (!this.thread1)
+        this.thread1 = tm.currentThread;
+      else
+        this.thread2 = tm.currentThread;
+    }
+  };
+
+  let obj1 = { };
+  Components.utils.import("resource://gre/modules/PlacesBackground.jsm", obj1);
+  obj1.PlacesBackground.dispatch(event, Ci.nsIEventTarget.DISPATCH_SYNC);
+  let obj2 = { };
+  Components.utils.import("resource://gre/modules/PlacesBackground.jsm", obj2);
+  obj2.PlacesBackground.dispatch(event, Ci.nsIEventTarget.DISPATCH_SYNC);
+  do_check_eq(event.thread1, event.thread2);
+}
+
+let tests = [
+  test_service_exists,
+  test_isOnCurrentThread,
+  test_two_events_same_thread,
+];
+
+function run_test()
+{
+  for (let i = 0; i < tests.length; i++)
+    tests[i]();
+
+  // xpcshell doesn't dispatch shutdown-application
+  let os = Cc["@mozilla.org/observer-service;1"].
+           getService(Ci.nsIObserverService);
+  os.notifyObservers(null, "quit-application", null);
+}
diff -r 6de576aeff11 toolkit/crashreporter/mac_utils.h
--- a/toolkit/crashreporter/mac_utils.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/crashreporter/mac_utils.h	Thu Aug 28 21:06:42 2008 +0300
@@ -36,12 +36,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef toolkit_breakpad_mac_utils_h__
 #define toolkit_breakpad_mac_utils_h__
 
+#include "nsStringGlue.h"
+
 /*
  * Look up a setting in our user defaults indicating
  * that the user wants to see the OS crash reporting dialog.
  */
 bool PassToOSCrashReporter();
 
+// Given an Objective-C NSException object, put exception info into a string.
+void GetObjCExceptionInfo(void* inException, nsACString& outString);
+
 #endif /* toolkit_breakpad_mac_utils_h__ */
diff -r 6de576aeff11 toolkit/crashreporter/mac_utils.mm
--- a/toolkit/crashreporter/mac_utils.mm	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/crashreporter/mac_utils.mm	Thu Aug 28 21:06:42 2008 +0300
@@ -18,10 +18,11 @@
  * Ted Mielczarek <ted.mielczarek@gmail.com>
  * Portions created by the Initial Developer are Copyright (C) 2007
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *  Josh Aas <josh@mozilla.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
@@ -37,10 +38,11 @@
 
 #include <Foundation/Foundation.h>
 
 #include "mac_utils.h"
 #include "nsObjCExceptions.h"
+#include "nsXPCOM.h"
 
 bool PassToOSCrashReporter()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 
@@ -51,5 +53,37 @@ bool PassToOSCrashReporter()
 
   return osCrashReporter == YES;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(false);
 }
+
+void GetObjCExceptionInfo(void* inException, nsACString& outString)
+{
+  NSException* e = (NSException*)inException;
+
+  NSString* name = [e name];
+  NSString* reason = [e reason];
+  unsigned int nameLength = [name length];
+  unsigned int reasonLength = [reason length];
+
+  unichar* nameBuffer = (unichar*)NS_Alloc(sizeof(unichar) * (nameLength + 1));
+  if (!nameBuffer)
+    return;
+  unichar* reasonBuffer = (unichar*)NS_Alloc(sizeof(unichar) * (reasonLength + 1));
+  if (!reasonBuffer) {
+    NS_Free(nameBuffer);
+    return;
+  }
+
+  [name getCharacters:nameBuffer];
+  [reason getCharacters:reasonBuffer];
+  nameBuffer[nameLength] = '\0';
+  reasonBuffer[reasonLength] = '\0';
+
+  outString.AssignLiteral("\nObj-C Exception data:\n");
+  AppendUTF16toUTF8(nameBuffer, outString);
+  outString.AppendLiteral(": ");
+  AppendUTF16toUTF8(reasonBuffer, outString);
+
+  NS_Free(nameBuffer);
+  NS_Free(reasonBuffer);
+}
diff -r 6de576aeff11 toolkit/crashreporter/nsExceptionHandler.cpp
--- a/toolkit/crashreporter/nsExceptionHandler.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/crashreporter/nsExceptionHandler.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -18,10 +18,11 @@
  * Ted Mielczarek <ted.mielczarek@gmail.com>
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *  Josh Aas <josh@mozilla.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
@@ -883,6 +884,16 @@ nsresult WriteMinidumpForException(EXCEP
 
   return gExceptionHandler->WriteMinidumpForException(aExceptionInfo) ? NS_OK : NS_ERROR_FAILURE;
 }
 #endif
 
+#ifdef XP_MACOSX
+nsresult AppendObjCExceptionInfoToAppNotes(void *inException)
+{
+  nsCAutoString excString;
+  GetObjCExceptionInfo(inException, excString);
+  AppendAppNotesToCrashReport(excString);
+  return NS_OK;
+}
+#endif
+
 } // namespace CrashReporter
diff -r 6de576aeff11 toolkit/crashreporter/nsExceptionHandler.h
--- a/toolkit/crashreporter/nsExceptionHandler.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/crashreporter/nsExceptionHandler.h	Thu Aug 28 21:06:42 2008 +0300
@@ -60,8 +60,11 @@ nsresult SetupExtraData(nsILocalFile* aA
 nsresult SetupExtraData(nsILocalFile* aAppDataDirectory,
                         const nsACString& aBuildID);
 #ifdef XP_WIN32
   nsresult WriteMinidumpForException(EXCEPTION_POINTERS* aExceptionInfo);
 #endif
+#ifdef XP_MACOSX
+  nsresult AppendObjCExceptionInfoToAppNotes(void *inException);
+#endif
 }
 
 #endif /* nsExceptionHandler_h__ */
diff -r 6de576aeff11 toolkit/mozapps/installer/packager.mk
--- a/toolkit/mozapps/installer/packager.mk	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/mozapps/installer/packager.mk	Thu Aug 28 21:06:42 2008 +0300
@@ -154,13 +154,13 @@ UNMAKE_PACKAGE	= \
      { sleep 5 && hdiutil detach $${DEV_NAME} -force; }; \
     return $$1 && $$?; \
   }; \
   unset NEXT_ROOT; \
   export PAGER=true; \
-  echo Y | hdiutil attach -readonly -mountroot /tmp -private -noautoopen $(UNPACKAGE) > hdi.output; \
+  expect $(_ABS_MOZSRCDIR)/build/package/mac_osx/installdmg.ex $(UNPACKAGE) > hdi.output; \
   DEV_NAME=`perl -n -e 'if($$_=~/(\/dev\/disk[^ ]*)/) {print $$1."\n";exit;}'< hdi.output`; \
-  MOUNTPOINT=`perl -n -e 'split(/\/dev\/disk[^ ]*/,$$_,2);if($$_[1]=~/(\/.*)/) {print $$1."\n";exit;}'< hdi.output` || cleanup 1; \
+  MOUNTPOINT=`perl -n -e 'split(/\/dev\/disk[^ ]*/,$$_,2);if($$_[1]=~/(\/.[^\r]*)/) {print $$1;exit;}'< hdi.output` || cleanup 1; \
   rsync -a "$${MOUNTPOINT}/$(_APPNAME)" $(MOZ_PKG_APPNAME) || cleanup 1; \
   test -n "$(MOZ_PKG_MAC_DSSTORE)" && \
     { rsync -a "$${MOUNTPOINT}/.DS_Store" "$(MOZ_PKG_MAC_DSSTORE)" || cleanup 1; }; \
   test -n "$(MOZ_PKG_MAC_BACKGROUND)" && \
     { rsync -a "$${MOUNTPOINT}/.background/`basename "$(MOZ_PKG_MAC_BACKGROUND)"`" "$(MOZ_PKG_MAC_BACKGROUND)" || cleanup 1; }; \
diff -r 6de576aeff11 toolkit/mozapps/update/content/updates.js
--- a/toolkit/mozapps/update/content/updates.js	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/mozapps/update/content/updates.js	Thu Aug 28 21:06:42 2008 +0300
@@ -860,10 +860,16 @@ var gLicensePage = {
 
   /**
    * When the user changes the state of the accept / decline radio group
    */
   onAcceptDeclineRadio: function() {
+    // Return early if this page hasn't been loaded (bug 405257). This event is
+    // fired during the construction of the wizard before gUpdates has received
+    // its onload event (bug 452389).
+    if (!this._licenseContent)
+      return;
+
     var selectedIndex = document.getElementById("acceptDeclineLicense")
                                 .selectedIndex;
     // 0 == Accept, 1 == Decline
     var licenseAccepted = (selectedIndex == 0);
     gUpdates.wiz.getButton("next").disabled = !licenseAccepted;
diff -r 6de576aeff11 toolkit/mozapps/update/test/unit/head_update.js
--- a/toolkit/mozapps/update/test/unit/head_update.js	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/mozapps/update/test/unit/head_update.js	Thu Aug 28 21:06:42 2008 +0300
@@ -47,10 +47,12 @@ const AUS_Cr = Components.results;
 
 var gAUS           = null;
 var gUpdateChecker = null;
 var gPrefs         = null;
 var gTestserver    = null;
+var gXHR           = null;
+var gXHRCallback   = null;
 
 /* Initializes the most commonly used global vars used by tests */
 function startAUS() {
   createAppInfo("xpcshell@tests.mozilla.org", "XPCShell", "1.0", "2.0");
   gPrefs = AUS_Cc["@mozilla.org/preferences;1"]
@@ -96,10 +98,85 @@ function toggleOffline(aOffline) {
   catch (e) {
   }
   if (ioService.offline != aOffline)
     ioService.offline = aOffline;
 }
+
+/**
+ * Sets up the bare bones XMLHttpRequest implementation below. 
+ *
+ * @param   callback
+ *          The callback function that will call the nsIDomEventListener's
+ *          handleEvent method.
+ *
+ *          Example of the callback function
+ *
+ *            function callHandleEvent() {
+ *              gXHR.status = gExpectedStatus;
+ *              var e = { target: gXHR };
+ *              gXHR.onload.handleEvent(e);
+ *            }
+ */
+function overrideXHR(callback) {
+  gXHRCallback = callback;
+  gXHR = new xhr();
+  var registrar = Components.manager.QueryInterface(AUS_Ci.nsIComponentRegistrar);
+  registrar.registerFactory(gXHR.classID, gXHR.classDescription,
+                            gXHR.contractID, gXHR);
+}
+
+/**
+ * Bare bones XMLHttpRequest implementation for testing onprogress, onerror,
+ * and onload nsIDomEventListener handleEvent.
+ */
+function xhr() {
+}
+xhr.prototype = {
+  overrideMimeType: function(mimetype) { },
+  setRequestHeader: function(header, value) { },
+  status: null,
+  channel: { set notificationCallbacks(val) { } },
+  _url: null,
+  _method: null,
+  open: function (method, url) { gXHR._method = method; gXHR._url = url; },
+  send: function(body) {
+    do_timeout(0, "gXHRCallback()"); // Use a timeout so the XHR completes
+  },
+  _onprogress: null,
+  set onprogress(val) { gXHR._onprogress = val; },
+  get onprogress() { return gXHR._onprogress; },
+  _onerror: null,
+  set onerror(val) { gXHR._onerror = val; },
+  get onerror() { return gXHR._onerror; },
+  _onload: null,
+  set onload(val) { gXHR._onload = val; },
+  get onload() { return gXHR._onload; },
+  flags: AUS_Ci.nsIClassInfo.SINGLETON,
+  implementationLanguage: AUS_Ci.nsIProgrammingLanguage.JAVASCRIPT,
+  getHelperForLanguage: function(language) null,
+  getInterfaces: function(count) {
+    var interfaces = [AUS_Ci.nsIXMLHttpRequest, AUS_Ci.nsIJSXMLHttpRequest];
+    count.value = interfaces.length;
+    return interfaces;
+  },
+  classDescription: "XMLHttpRequest",
+  contractID: "@mozilla.org/xmlextras/xmlhttprequest;1",
+  classID: Components.ID("{c9b37f43-4278-4304-a5e0-600991ab08cb}"),
+  createInstance: function (outer, aIID) {
+    if (outer != null)
+      throw AUS_Cr.NS_ERROR_NO_AGGREGATION;
+    return gXHR.QueryInterface(aIID);
+  },
+  QueryInterface: function(aIID) {
+    if (aIID.equals(AUS_Ci.nsIXMLHttpRequest) ||
+        aIID.equals(AUS_Ci.nsIJSXMLHttpRequest) ||
+        aIID.equals(AUS_Ci.nsIClassInfo) ||
+        aIID.equals(AUS_Ci.nsISupports))
+      return gXHR;
+    throw AUS_Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
 
 /**
  * Removes the updates directory and the active-update.xml file if they exist.
  * This prevents some tests from failing due to files being left behind when
  * the tests are interrupted.
diff -r 6de576aeff11 toolkit/mozapps/update/test/unit/tail_update.js
--- a/toolkit/mozapps/update/test/unit/tail_update.js	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/mozapps/update/test/unit/tail_update.js	Thu Aug 28 21:06:42 2008 +0300
@@ -34,10 +34,19 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK *****
  */
 
+if (gXHR) {
+  gXHRCallback = null;
+  // null out the event handlers to prevent a mFreeCount leak of 1
+  gXHR.onerror = null;
+  gXHR.onload = null;
+  gXHR.onprogress = null;
+  gXHR = null;
+}
+
 gUpdateChecker = null;
 gAUS = null;
 gPrefs = null;
 gTestserver = null;
 remove_dirs_and_files();
diff -r 6de576aeff11 toolkit/mozapps/update/test/unit/test_0051_general.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/mozapps/update/test/unit/test_0051_general.js	Thu Aug 28 21:06:42 2008 +0300
@@ -0,0 +1,202 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Application Update Service.
+ *
+ * The Initial Developer of the Original Code is
+ * Robert Strong <robert.bugzilla@gmail.com>.
+ *
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Mozilla Foundation <http://www.mozilla.org/>. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****
+ */
+
+/* General nsIUpdateCheckListener onload error code statusText Tests */
+
+// Errors tested:
+// 2152398849, 2152398862, 2152398864, 2152398867, 2152398868, 2152398878,
+// 2152398890, 2152398919, 2152398920, default (404)
+
+const DIR_DATA = "data"
+const URL_PREFIX = "http://localhost:4444/" + DIR_DATA + "/";
+
+const PREF_APP_UPDATE_URL_OVERRIDE = "app.update.url.override";
+
+const URI_UPDATES_PROPERTIES = "chrome://mozapps/locale/update/updates.properties";
+const gUpdateBundle = AUS_Cc["@mozilla.org/intl/stringbundle;1"]
+                       .getService(AUS_Ci.nsIStringBundleService)
+                       .createBundle(URI_UPDATES_PROPERTIES);
+
+var gStatusCode;
+var gStatusText;
+var gExpectedStatusCode;
+var gExpectedStatusText;
+var gCheckFunc;
+var gNextRunFunc;
+
+function run_test() {
+  do_test_pending();
+  startAUS();
+  overrideXHR(callHandleEvent);
+  do_timeout(0, "run_test_pt1()");
+}
+
+function end_test() {
+  do_test_finished();
+}
+
+// Returns human readable status text from the updates.properties bundle
+function getStatusText(aErrCode) {
+  try {
+    return gUpdateBundle.GetStringFromName("checker_error-" + aErrCode);
+  }
+  catch (e) {
+  }
+  return null;
+}
+
+// Callback function used by the custom XMLHttpRequest implemetation to
+// call the nsIDOMEventListener's handleEvent method for onload.
+function callHandleEvent() {
+  gXHR.status = gExpectedStatusCode;
+  var e = { target: gXHR };
+  gXHR.onload.handleEvent(e);
+}
+
+// Helper functions for testing nsIUpdateCheckListener onload error statusTexts
+function run_test_helper(aUpdateXML, aMsg, aExpectedStatusCode,
+                         aExpectedStatusText, aNextRunFunc) {
+  gStatusCode = null;
+  gStatusText = null;
+  gCheckFunc = check_test_helper;
+  gNextRunFunc = aNextRunFunc;
+  gExpectedStatusCode = aExpectedStatusCode;
+  gExpectedStatusText = aExpectedStatusText;
+  var url = URL_PREFIX + aUpdateXML;
+  dump("Testing: " + aMsg + " - " + url + "\n");
+  gPrefs.setCharPref(PREF_APP_UPDATE_URL_OVERRIDE, url);
+  gUpdateChecker.checkForUpdates(updateCheckListener, true);
+}
+
+function check_test_helper() {
+  do_check_eq(gStatusCode, gExpectedStatusCode);
+  do_check_eq(gStatusText, gExpectedStatusText);
+  gNextRunFunc();
+}
+
+/**
+ * The following tests use a custom XMLHttpRequest to return the status codes
+ */
+
+// failed (unknown reason)
+function run_test_pt1() {
+  run_test_helper("aus-0051_general-1.xml", "failed (unknown reason)",
+                  2152398849, getStatusText("2152398849"), run_test_pt2);
+}
+
+// connection timed out
+function run_test_pt2() {
+  run_test_helper("aus-0051_general-2.xml", "connection timed out",
+                  2152398862, getStatusText("2152398862"), run_test_pt3);
+}
+
+// network offline
+function run_test_pt3() {
+  run_test_helper("aus-0051_general-3.xml", "network offline",
+                  2152398864, getStatusText("2152398864"), run_test_pt4);
+}
+
+// port not allowed
+function run_test_pt4() {
+  run_test_helper("aus-0051_general-4.xml", "port not allowed",
+                  2152398867, getStatusText("2152398867"), run_test_pt5);
+}
+
+// no data was received
+function run_test_pt5() {
+  run_test_helper("aus-0051_general-5.xml", "no data was received",
+                  2152398868, getStatusText("2152398868"), run_test_pt6);
+}
+
+// update server not found
+function run_test_pt6() {
+  run_test_helper("aus-0051_general-6.xml", "update server not found",
+                  2152398878, getStatusText("2152398878"), run_test_pt7);
+}
+
+// proxy server not found
+function run_test_pt7() {
+  run_test_helper("aus-0051_general-7.xml", "proxy server not found",
+                  2152398890, getStatusText("2152398890"), run_test_pt8);
+}
+
+// data transfer interrupted
+function run_test_pt8() {
+  run_test_helper("aus-0051_general-8.xml", "data transfer interrupted",
+                  2152398919, getStatusText("2152398919"), run_test_pt9);
+}
+
+// proxy server connection refused
+function run_test_pt9() {
+  run_test_helper("aus-0051_general-9.xml", "proxy server connection refused",
+                  2152398920, getStatusText("2152398920"), run_test_pt10);
+}
+
+// default onload error message (error code 1152398920 is not defined)
+function run_test_pt10() {
+  run_test_helper("aus-0051_general-10.xml", "default onload error message",
+                  1152398920, getStatusText("404"), end_test);
+}
+
+// Update check listener
+const updateCheckListener = {
+  onProgress: function(request, position, totalSize) {
+  },
+
+  onCheckComplete: function(request, updates, updateCount) {
+    dump("onCheckComplete request.status = " + request.status + "\n\n");
+    // Use a timeout to allow the XHR to complete
+    do_timeout(0, "gCheckFunc()");
+  },
+
+  onError: function(request, update) {
+    gStatusCode = request.status;
+    gStatusText = update.statusText;
+    dump("onError: request.status = " + gStatusCode + ", update.statusText = " + gStatusText + "\n\n");
+    // Use a timeout to allow the XHR to complete
+    do_timeout(0, "gCheckFunc()");
+  },
+
+  QueryInterface: function(aIID) {
+    if (!aIID.equals(AUS_Ci.nsIUpdateCheckListener) &&
+        !aIID.equals(AUS_Ci.nsISupports))
+      throw AUS_Cr.NS_ERROR_NO_INTERFACE;
+
+    return this;
+  }
+};
diff -r 6de576aeff11 toolkit/xre/MacLaunchHelper.h
--- a/toolkit/xre/MacLaunchHelper.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/xre/MacLaunchHelper.h	Thu Aug 28 21:06:42 2008 +0300
@@ -37,14 +37,10 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __MacLaunchHelper_h__
 #define __MacLaunchHelper_h__
 
-#ifdef __cplusplus
 extern "C" {
-#endif
   void LaunchChildMac(int aArgc, char** aArgv);
-#ifdef __cplusplus
 }
-#endif
 
 #endif
diff -r 6de576aeff11 toolkit/xre/MacLaunchHelper.m
--- a/toolkit/xre/MacLaunchHelper.m	Wed Aug 27 08:11:51 2008 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,96 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Ben Goodger <ben@mozilla.org>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "MacLaunchHelper.h"
-
-#include "nsObjCExceptions.h"
-
-#include <Cocoa/Cocoa.h>
-
-#ifdef __ppc__
-#include <sys/types.h>
-#include <sys/sysctl.h>
-#include <mach/machine.h>
-#endif /* __ppc__ */
-
-void LaunchChildMac(int aArgc, char** aArgv)
-{
-  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
-
-  int i;
-  NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
-  NSTask* child = [[[NSTask alloc] init] autorelease];
-  NSMutableArray* args = [[[NSMutableArray alloc] init] autorelease];
-
-#ifdef __ppc__
-  // It's possible that the app is a universal binary running under Rosetta
-  // translation because the user forced it to.  Relaunching via NSTask would
-  // launch the app natively, which the user apparently doesn't want.
-  // In that case, try to preserve translation.
-
-  // If the sysctl doesn't exist, it's because Rosetta doesn't exist,
-  // so don't try to force translation.  In case of other errors, just assume
-  // that the app is native.
-
-  int isNative = 0;
-  size_t sz = sizeof(isNative);
-
-  if (sysctlbyname("sysctl.proc_native", &isNative, &sz, NULL, 0) == 0 &&
-      !isNative) {
-    // Running translated on ppc.
-
-    cpu_type_t preferredCPU = CPU_TYPE_POWERPC;
-    sysctlbyname("sysctl.proc_exec_affinity", NULL, NULL,
-                 &preferredCPU, sizeof(preferredCPU));
-
-    // Nothing can be done to handle failure, relaunch anyway.
-  }
-#endif /* __ppc__ */
-
-  for (i = 1; i < aArgc; ++i) 
-    [args addObject: [NSString stringWithCString: aArgv[i]]];
-  
-  [child setCurrentDirectoryPath:[[[NSBundle mainBundle] executablePath] stringByDeletingLastPathComponent]];
-  [child setLaunchPath:[[NSBundle mainBundle] executablePath]];
-  [child setArguments:args];
-  [child launch];
-  [pool release];
-
-  NS_OBJC_END_TRY_ABORT_BLOCK;
-}
-
diff -r 6de576aeff11 toolkit/xre/MacLaunchHelper.mm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/xre/MacLaunchHelper.mm	Thu Aug 28 21:06:42 2008 +0300
@@ -0,0 +1,95 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <ben@mozilla.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "MacLaunchHelper.h"
+
+#include "nsObjCExceptions.h"
+
+#include <Cocoa/Cocoa.h>
+
+#ifdef __ppc__
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <mach/machine.h>
+#endif /* __ppc__ */
+
+void LaunchChildMac(int aArgc, char** aArgv)
+{
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+
+  int i;
+  NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
+  NSTask* child = [[[NSTask alloc] init] autorelease];
+  NSMutableArray* args = [[[NSMutableArray alloc] init] autorelease];
+
+#ifdef __ppc__
+  // It's possible that the app is a universal binary running under Rosetta
+  // translation because the user forced it to.  Relaunching via NSTask would
+  // launch the app natively, which the user apparently doesn't want.
+  // In that case, try to preserve translation.
+
+  // If the sysctl doesn't exist, it's because Rosetta doesn't exist,
+  // so don't try to force translation.  In case of other errors, just assume
+  // that the app is native.
+
+  int isNative = 0;
+  size_t sz = sizeof(isNative);
+
+  if (sysctlbyname("sysctl.proc_native", &isNative, &sz, NULL, 0) == 0 &&
+      !isNative) {
+    // Running translated on ppc.
+
+    cpu_type_t preferredCPU = CPU_TYPE_POWERPC;
+    sysctlbyname("sysctl.proc_exec_affinity", NULL, NULL,
+                 &preferredCPU, sizeof(preferredCPU));
+
+    // Nothing can be done to handle failure, relaunch anyway.
+  }
+#endif /* __ppc__ */
+
+  for (i = 1; i < aArgc; ++i) 
+    [args addObject: [NSString stringWithCString: aArgv[i]]];
+  
+  [child setCurrentDirectoryPath:[[[NSBundle mainBundle] executablePath] stringByDeletingLastPathComponent]];
+  [child setLaunchPath:[[NSBundle mainBundle] executablePath]];
+  [child setArguments:args];
+  [child launch];
+  [pool release];
+
+  NS_OBJC_END_TRY_ABORT_BLOCK;
+}
diff -r 6de576aeff11 toolkit/xre/Makefile.in
--- a/toolkit/xre/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/xre/Makefile.in	Thu Aug 28 21:06:42 2008 +0300
@@ -150,12 +150,12 @@ endif
 endif
 endif
 endif
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
-CMSRCS = MacLaunchHelper.m
+ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
+CMMSRCS += MacLaunchHelper.mm
 CPPSRCS += nsCommandLineServiceMac.cpp
 LOCAL_INCLUDES += -I$(topsrcdir)/xpfe/bootstrap/appleevents
 OS_CXXFLAGS += -fexceptions
 SHARED_LIBRARY_LIBS += $(DEPTH)/xpfe/bootstrap/appleevents/$(LIB_PREFIX)appleevents_s.$(LIB_SUFFIX)
 endif
diff -r 6de576aeff11 toolkit/xre/nsAppRunner.cpp
--- a/toolkit/xre/nsAppRunner.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/xre/nsAppRunner.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -852,10 +852,20 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsXULAppInfo::WriteMinidumpForException(void* aExceptionInfo)
 {
 #ifdef XP_WIN32
   return CrashReporter::WriteMinidumpForException(static_cast<EXCEPTION_POINTERS*>(aExceptionInfo));
+#else
+  return NS_ERROR_NOT_IMPLEMENTED;
+#endif
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::AppendObjCExceptionInfoToAppNotes(void* aException)
+{
+#ifdef XP_MACOSX
+  return CrashReporter::AppendObjCExceptionInfoToAppNotes(aException);
 #else
   return NS_ERROR_NOT_IMPLEMENTED;
 #endif
 }
 #endif
diff -r 6de576aeff11 toolkit/xre/nsNativeAppSupportUnix.cpp
--- a/toolkit/xre/nsNativeAppSupportUnix.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/toolkit/xre/nsNativeAppSupportUnix.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -224,13 +224,13 @@ static void OssoHardwareCallback(osso_hw
     nsCOMPtr<nsIAppStartup> appService =  do_GetService("@mozilla.org/toolkit/app-startup;1");
     if (appService)
       appService->Quit(nsIAppStartup::eForceQuit);
     return;
   }
-    
+
   if (state->memory_low_ind) {
-    if (ourState->memory_low_ind) {
+      if (! ourState->memory_low_ind) {
       nsCOMPtr<nsIObserverService> os = do_GetService("@mozilla.org/observer-service;1");
       if (os)
         os->NotifyObservers(nsnull, "memory-pressure", NS_LITERAL_STRING("low-memory").get());
     }
   }
diff -r 6de576aeff11 tools/test-harness/xpcshell-simple/test_all.sh
--- a/tools/test-harness/xpcshell-simple/test_all.sh	Wed Aug 27 08:11:51 2008 -0400
+++ b/tools/test-harness/xpcshell-simple/test_all.sh	Thu Aug 28 21:06:42 2008 +0300
@@ -1,6 +1,6 @@
-#!/bin/sh
+#!/bin/bash
 #
 # vim:set ts=2 sw=2 sts=2 et:
 #
 # ***** BEGIN LICENSE BLOCK *****
 # Version: MPL 1.1/GPL 2.0/LGPL 2.1
diff -r 6de576aeff11 tools/test-harness/xpcshell-simple/test_one.sh
--- a/tools/test-harness/xpcshell-simple/test_one.sh	Wed Aug 27 08:11:51 2008 -0400
+++ b/tools/test-harness/xpcshell-simple/test_one.sh	Thu Aug 28 21:06:42 2008 +0300
@@ -1,6 +1,6 @@
-#!/bin/sh
+#!/bin/bash
 #
 # vim:set ts=2 sw=2 sts=2 et:
 #
 # ***** BEGIN LICENSE BLOCK *****
 # Version: MPL 1.1/GPL 2.0/LGPL 2.1
diff -r 6de576aeff11 uriloader/prefetch/nsIOfflineCacheUpdate.idl
--- a/uriloader/prefetch/nsIOfflineCacheUpdate.idl	Wed Aug 27 08:11:51 2008 -0400
+++ b/uriloader/prefetch/nsIOfflineCacheUpdate.idl	Thu Aug 28 21:06:42 2008 +0300
@@ -113,11 +113,11 @@ interface nsIOfflineCacheUpdateObserver 
  *
  * One update object will be updating at a time.  The active object will
  * load its items one by one, sending itemCompleted() to any registered
  * observers.
  */
-[scriptable, uuid(4b206247-82ee-46cf-a8b7-f7284e753bc2)]
+[scriptable, uuid(877261bb-b952-4d27-847e-859bdd47c0ec)]
 interface nsIOfflineCacheUpdate : nsISupports {
   /**
    * Fetch the status of the running update.  This will return a value
    * defined in nsIDOMOfflineResourceList.
    */
@@ -152,25 +152,34 @@ interface nsIOfflineCacheUpdate : nsISup
   readonly attribute boolean succeeded;
 
   /**
    * Initialize the update.
    *
-   * @param aPartialUpdate
-   *        TRUE if the update should just update the URIs given to it,
-   *        FALSE if all URLs for the owner domain should be added.
    * @param aManifestURI
-   *        The manifest URI to be checked, or for partial updates the
-   *        manifest that should own resources that are added.
+   *        The manifest URI to be checked.
    * @param aDocumentURI
    *        The page that is requesting the update.
    */
-  void init(in boolean aPartialUpdate,
-            in nsIURI aManifestURI,
-            in nsIURI aDocumentURI);
+  void init(in nsIURI aManifestURI, in nsIURI aDocumentURI);
 
   /**
-   * Add a URI to the offline cache as part of the update.
+   * Initialize the update for partial processing. 
+   *
+   * @param aManifestURI
+   *        The manifest URI of the related cache.
+   * @param aClientID
+   *        Client  ID of the cache to store resource to. This ClientID
+   *        must be ID of cache in the cache group identified by
+   *        the manifest URI passed in the first parameter.
+   * @param aDocumentURI
+   *        The page that is requesting the update. May be null 
+   *        when this information is unknown.
+   */
+  void initPartial(in nsIURI aManifestURI, in ACString aClientID, in nsIURI aDocumentURI);
+
+  /**
+   * Add a dynamic URI to the offline cache as part of the update.
    *
    * @param aURI
    *        The URI to add.
    */
   void addDynamicURI(in nsIURI aURI);
diff -r 6de576aeff11 uriloader/prefetch/nsOfflineCacheUpdate.cpp
--- a/uriloader/prefetch/nsOfflineCacheUpdate.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/uriloader/prefetch/nsOfflineCacheUpdate.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -44,10 +44,11 @@
 #include "nsIApplicationCacheService.h"
 #include "nsICache.h"
 #include "nsICacheService.h"
 #include "nsICacheSession.h"
 #include "nsICachingChannel.h"
+#include "nsIDocumentLoader.h"
 #include "nsIDOMWindow.h"
 #include "nsIDOMOfflineResourceList.h"
 #include "nsIObserverService.h"
 #include "nsIURL.h"
 #include "nsIWebProgress.h"
@@ -55,10 +56,11 @@
 #include "nsICacheEntryDescriptor.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 #include "nsStreamUtils.h"
+#include "nsStringEnumerator.h"
 #include "nsThreadUtils.h"
 #include "prlog.h"
 
 static nsOfflineCacheUpdateService *gOfflineCacheUpdateService = nsnull;
 
@@ -575,10 +577,11 @@ nsOfflineManifestItem::HandleManifestLin
     case PARSE_INIT:
     case PARSE_ERROR: {
         // this should have been dealt with earlier
         return NS_ERROR_FAILURE;
     }
+
     case PARSE_CACHE_ENTRIES: {
         nsCOMPtr<nsIURI> uri;
         rv = NS_NewURI(getter_AddRefs(uri), line, nsnull, mURI);
         if (NS_FAILED(rv))
             break;
@@ -808,25 +811,24 @@ nsOfflineCacheUpdate::GetCacheKey(nsIURI
 
     return NS_OK;
 }
 
 nsresult
-nsOfflineCacheUpdate::Init(PRBool aPartialUpdate,
-                           nsIURI *aManifestURI,
+nsOfflineCacheUpdate::Init(nsIURI *aManifestURI,
                            nsIURI *aDocumentURI)
 {
     nsresult rv;
 
     // Make sure the service has been initialized
     nsOfflineCacheUpdateService* service =
         nsOfflineCacheUpdateService::EnsureService();
     if (!service)
         return NS_ERROR_FAILURE;
 
-    LOG(("nsOfflineCacheUpdate::Init [%p, %d]", this, aPartialUpdate));
+    LOG(("nsOfflineCacheUpdate::Init [%p]", this));
 
-    mPartialUpdate = aPartialUpdate;
+    mPartialUpdate = PR_FALSE;
 
     // Only http and https applications are supported.
     PRBool match;
     rv = aManifestURI->SchemeIs("http", &match);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -856,24 +858,70 @@ nsOfflineCacheUpdate::Init(PRBool aParti
 
     rv = cacheService->GetActiveCache(manifestSpec,
                                       getter_AddRefs(mPreviousApplicationCache));
     NS_ENSURE_SUCCESS(rv, rv);
 
-    // Partial updates to existing application caches don't need a new cache.
-    if (aPartialUpdate && mPreviousApplicationCache) {
-        mApplicationCache = mPreviousApplicationCache;
-    } else {
-        rv = cacheService->CreateApplicationCache(manifestSpec,
-                                                  getter_AddRefs(mApplicationCache));
-        NS_ENSURE_SUCCESS(rv, rv);
-    }
+    rv = cacheService->CreateApplicationCache(manifestSpec,
+                                              getter_AddRefs(mApplicationCache));
+    NS_ENSURE_SUCCESS(rv, rv);
 
     rv = mApplicationCache->GetClientID(mClientID);
     NS_ENSURE_SUCCESS(rv, rv);
 
     mState = STATE_INITIALIZED;
+    return NS_OK;
+}
 
+nsresult
+nsOfflineCacheUpdate::InitPartial(nsIURI *aManifestURI,
+                                  const nsACString& clientID,
+                                  nsIURI *aDocumentURI)
+{
+    nsresult rv;
+
+    // Make sure the service has been initialized
+    nsOfflineCacheUpdateService* service =
+        nsOfflineCacheUpdateService::EnsureService();
+    if (!service)
+        return NS_ERROR_FAILURE;
+
+    LOG(("nsOfflineCacheUpdate::InitPartial [%p]", this));
+
+    mPartialUpdate = PR_TRUE;
+    mClientID = clientID;
+    mDocumentURI = aDocumentURI;
+
+    mManifestURI = aManifestURI;
+    rv = mManifestURI->GetAsciiHost(mUpdateDomain);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIApplicationCacheService> cacheService =
+        do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = cacheService->GetApplicationCache(mClientID,
+                                           getter_AddRefs(mApplicationCache));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (!mApplicationCache) {
+        nsCAutoString manifestSpec;
+        rv = GetCacheKey(mManifestURI, manifestSpec);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        rv = cacheService->CreateApplicationCache
+            (manifestSpec, getter_AddRefs(mApplicationCache));
+        NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    nsCAutoString groupID;
+    rv = mApplicationCache->GetGroupID(groupID);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = NS_NewURI(getter_AddRefs(mManifestURI), groupID);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mState = STATE_INITIALIZED;
     return NS_OK;
 }
 
 nsresult
 nsOfflineCacheUpdate::HandleManifest(PRBool *aDoUpdate)
@@ -1608,10 +1656,11 @@ nsOfflineCacheUpdateService::ScheduleOnD
                                                     nsIDOMDocument *aDocument)
 {
     LOG(("nsOfflineCacheUpdateService::ScheduleOnDocumentStop [%p, manifestURI=%p, documentURI=%p doc=%p]",
          this, aManifestURI, aDocumentURI, aDocument));
 
+    // Proceed with cache update
     PendingUpdate *update = new PendingUpdate();
     update->mManifestURI = aManifestURI;
     update->mDocumentURI = aDocumentURI;
     if (!mDocUpdates.Put(aDocument, update))
         return NS_ERROR_FAILURE;
@@ -1735,11 +1784,11 @@ nsOfflineCacheUpdateService::ScheduleUpd
 
     nsRefPtr<nsOfflineCacheUpdate> update = new nsOfflineCacheUpdate();
     if (!update)
         return NS_ERROR_OUT_OF_MEMORY;
 
-    rv = update->Init(PR_FALSE, aManifestURI, aDocumentURI);
+    rv = update->Init(aManifestURI, aDocumentURI);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = update->Schedule();
     NS_ENSURE_SUCCESS(rv, rv);
 
diff -r 6de576aeff11 widget/src/cocoa/nsNativeThemeColors.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/widget/src/cocoa/nsNativeThemeColors.h	Thu Aug 28 21:06:42 2008 +0300
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Markus Stange.
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsNativeThemeColors_h_
+#define nsNativeThemeColors_h_
+
+#import <Cocoa/Cocoa.h>
+
+enum ColorName {
+  headerStartGrey,
+  headerEndGrey,
+  headerBorderGrey
+};
+
+static const int sLeopardThemeColors[][2] = {
+  /* { active window, inactive window } */
+  // unified titlebar and toolbar gradient:
+  { 0xC5, 0xE9 }, // start grey
+  { 0x96, 0xCA }, // end grey
+  { 0x42, 0x89 }  // separator line
+};
+
+
+static int NativeGreyColorAsInt(ColorName name, BOOL isMain)
+{
+  return sLeopardThemeColors[name][isMain ? 0 : 1];
+}
+
+static float NativeGreyColorAsFloat(ColorName name, BOOL isMain)
+{
+  return NativeGreyColorAsInt(name, isMain) / 255.0f;
+}
+
+static NSColor* NativeGreyColorAsNSColor(ColorName name, BOOL isMain)
+{
+  return [NSColor colorWithDeviceWhite:NativeGreyColorAsFloat(name, isMain) alpha:1.0f];
+}
+
+#endif // nsNativeThemeColors_h_
diff -r 6de576aeff11 widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/widget/src/gtk2/nsWindow.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -521,25 +521,35 @@ nsWindow::Destroy(void)
     if (mDragMotionTimerID) {
         gtk_timeout_remove(mDragMotionTimerID);
         mDragMotionTimerID = 0;
     }
 
+    if (mDrawingarea) {
+        g_object_set_data(G_OBJECT(mDrawingarea->clip_window),
+                          "nsWindow", NULL);
+        g_object_set_data(G_OBJECT(mDrawingarea->inner_window),
+                          "nsWindow", NULL);
+
+        g_object_set_data(G_OBJECT(mDrawingarea->clip_window),
+                          "mozdrawingarea", NULL);
+        g_object_set_data(G_OBJECT(mDrawingarea->inner_window),
+                          "mozdrawingarea", NULL);
+
+        g_object_unref(mDrawingarea);
+        mDrawingarea = nsnull;
+    }
+
     if (mShell) {
         gtk_widget_destroy(mShell);
         mShell = nsnull;
         mContainer = nsnull;
     }
     else if (mContainer) {
         gtk_widget_destroy(GTK_WIDGET(mContainer));
         mContainer = nsnull;
     }
 
-    if (mDrawingarea) {
-        g_object_unref(mDrawingarea);
-        mDrawingarea = nsnull;
-    }
-
     OnDestroy();
 
 #ifdef ACCESSIBILITY
     if (mRootAccessible) {
         mRootAccessible = nsnull;
@@ -557,10 +567,22 @@ nsWindow::SetParent(nsIWidget *aNewParen
     GdkWindow* newParentWindow =
         static_cast<GdkWindow*>(aNewParent->GetNativeData(NS_NATIVE_WINDOW));
     NS_ASSERTION(newParentWindow, "Parent widget has a null native window handle");
 
     if (!mShell && mDrawingarea) {
+#ifdef DEBUG
+        if (!mContainer) {
+            // Check that the new Parent window has the same MozContainer
+            gpointer old_container;
+            gdk_window_get_user_data(mDrawingarea->inner_window,
+                                     &old_container);
+            gpointer new_container;
+            gdk_window_get_user_data(newParentWindow, &new_container);
+            NS_ASSERTION(old_container == new_container,
+                         "FIXME: Wrong MozContainer on MozDrawingarea");
+        }
+#endif
         moz_drawingarea_reparent(mDrawingarea, newParentWindow);
     } else {
         NS_NOTREACHED("nsWindow::SetParent - reparenting a non-child window");
     }
     return NS_OK;
@@ -829,12 +851,11 @@ nsWindow::SetFocus(PRBool aRaise)
     LOGFOCUS(("  SetFocus [%p]\n", (void *)this));
 
     if (!mDrawingarea)
         return NS_ERROR_FAILURE;
 
-    GtkWidget *owningWidget =
-        get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
+    GtkWidget *owningWidget = GetMozContainerWidget();
     if (!owningWidget)
         return NS_ERROR_FAILURE;
 
     // Raise the window if someone passed in PR_TRUE and the prefs are
     // set properly.
@@ -955,13 +976,12 @@ nsWindow::SetCursor(nsCursor aCursor)
 nsWindow::SetCursor(nsCursor aCursor)
 {
     // if we're not the toplevel window pass up the cursor request to
     // the toplevel window to handle it.
     if (!mContainer && mDrawingarea) {
-        GtkWidget *widget =
-            get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
-        nsWindow *window = get_window_for_gtk_widget(widget);
+        nsWindow *window;
+        GetContainerWindow(&window);
         return window->SetCursor(aCursor);
     }
 
     // Only change cursor if it's actually been changed
     if (aCursor != mCursor) {
@@ -1037,13 +1057,12 @@ nsWindow::SetCursor(imgIContainer* aCurs
                     PRUint32 aHotspotX, PRUint32 aHotspotY)
 {
     // if we're not the toplevel window pass up the cursor request to
     // the toplevel window to handle it.
     if (!mContainer && mDrawingarea) {
-        GtkWidget *widget =
-            get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
-        nsWindow *window = get_window_for_gtk_widget(widget);
+        nsWindow *window;
+        GetContainerWindow(&window);
         return window->SetCursor(aCursor, aHotspotX, aHotspotY);
     }
 
     if (!sPixbufCursorChecked) {
         PRLibrary* lib;
@@ -1520,12 +1539,11 @@ nsWindow::CaptureMouse(PRBool aCapture)
     LOG(("CaptureMouse %p\n", (void *)this));
 
     if (!mDrawingarea)
         return NS_OK;
 
-    GtkWidget *widget =
-        get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
+    GtkWidget *widget = GetMozContainerWidget();
 
     if (aCapture) {
         gtk_grab_add(widget);
         GrabPointer();
     }
@@ -1543,12 +1561,11 @@ nsWindow::CaptureRollupEvents(nsIRollupL
                               PRBool             aConsumeRollupEvent)
 {
     if (!mDrawingarea)
         return NS_OK;
 
-    GtkWidget *widget =
-        get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
+    GtkWidget *widget = GetMozContainerWidget();
 
     LOG(("CaptureRollupEvents %p\n", (void *)this));
 
     if (aDoCapture) {
         gConsumeRollupEvent = aConsumeRollupEvent;
@@ -1605,12 +1622,13 @@ nsWindow::LoseFocus(void)
     DispatchLostFocusEvent();
 
     LOGFOCUS(("  widget lost focus [%p]\n", (void *)this));
 }
 
+#if 0
 #ifdef DEBUG
-// Paint flashing code
+// Paint flashing code (disabled for cairo - see below)
 
 #define CAPS_LOCK_IS_ON \
 (gdk_keyboard_get_modifiers() & GDK_LOCK_MASK)
 
 #define WANT_PAINT_FLASHING \
@@ -1676,10 +1694,11 @@ gdk_window_flash(GdkWindow *    aGdkWind
 
   gdk_region_offset(aRegion, -x, -y);
 }
 #endif /* MOZ_X11 */
 #endif // DEBUG
+#endif
 
 gboolean
 nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
 {
     if (mIsDestroyed) {
@@ -4140,28 +4159,36 @@ nsWindow::GetToplevelWidget(GtkWidget **
     }
 
     if (!mDrawingarea)
         return;
 
-    GtkWidget *widget =
-        get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
+    GtkWidget *widget = GetMozContainerWidget();
     if (!widget)
         return;
 
     *aWidget = gtk_widget_get_toplevel(widget);
 }
 
-void
-nsWindow::GetContainerWindow(nsWindow **aWindow)
-{
-    if (!mDrawingarea)
-        return;
-
+GtkWidget *
+nsWindow::GetMozContainerWidget()
+{
     GtkWidget *owningWidget =
         get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
+    NS_ASSERTION(IS_MOZ_CONTAINER(owningWidget), "Lost our MozContainer");
+    return owningWidget;
+}
+
+void
+nsWindow::GetContainerWindow(nsWindow **aWindow)
+{
+    if (!mDrawingarea)
+        return;
+
+    GtkWidget *owningWidget = GetMozContainerWidget();
 
     *aWindow = get_window_for_gtk_widget(owningWidget);
+    NS_ASSERTION(*aWindow, "Lost our Container Window");
 }
 
 void
 nsWindow::SetUrgencyHint(GtkWidget *top_window, PRBool state)
 {
diff -r 6de576aeff11 widget/src/gtk2/nsWindow.h
--- a/widget/src/gtk2/nsWindow.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/widget/src/gtk2/nsWindow.h	Thu Aug 28 21:06:42 2008 +0300
@@ -380,10 +380,11 @@ public:
     static PRBool      sAccessibilityEnabled;
 #endif
 
 private:
     void               GetToplevelWidget(GtkWidget **aWidget);
+    GtkWidget         *GetMozContainerWidget();
     void               GetContainerWindow(nsWindow  **aWindow);
     void               SetUrgencyHint(GtkWidget *top_window, PRBool state);
     void              *SetupPluginPort(void);
     nsresult           SetWindowIconList(const nsCStringArray &aIconList);
     void               SetDefaultIcon(void);
diff -r 6de576aeff11 widget/src/os2/nsLookAndFeel.cpp
--- a/widget/src/os2/nsLookAndFeel.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/widget/src/os2/nsLookAndFeel.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -244,10 +244,13 @@ nsresult nsLookAndFeel::NativeGetColor(c
         return res;
       } else {
         idx = SYSCLR_MENUHILITE;
       }
       break;
+    case eColor__moz_nativehyperlinktext:
+      aColor = NS_RGB( 0, 0, 255);
+      return res;
     default:
       idx = SYSCLR_WINDOW;
       break;
   }
 
diff -r 6de576aeff11 widget/src/qt/nsDragService.cpp
--- a/widget/src/qt/nsDragService.cpp	Wed Aug 27 08:11:51 2008 -0400
+++ b/widget/src/qt/nsDragService.cpp	Thu Aug 28 21:06:42 2008 +0300
@@ -37,10 +37,11 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsDragService.h"
 #include "nsISupportsPrimitives.h"
 #include "nsXPIDLString.h"
+#include "nsIDOMMouseEvent.h"
 
 #include "qmimedata.h"
 #include "qwidget.h"
 
 NS_IMPL_ADDREF_INHERITED(nsDragService, nsBaseDragService)
@@ -206,18 +207,20 @@ nsDragService::InvokeDragSessionWithImag
                         nsIScriptableRegion* aRegion,
                         PRUint32 aActionType,
                         nsIDOMNode* aImage,
                         PRInt32 aImageX,
                         PRInt32 aImageY,
-                        nsIDOMMouseEvent* aDragEvent)
+                        nsIDOMDragEvent* aDragEvent,
+                        nsIDOMDataTransfer* aDataTransfer)
 {
     nsBaseDragService::InvokeDragSessionWithImage(
                                         aDOMNode, aTransferables,
                                         aRegion, aActionType,
                                         aImage,
                                         aImageX, aImageY,
-                                        aDragEvent );
+                                        aDragEvent,
+                                        aDataTransfer);
 
     SetupDragSession( aTransferables, aActionType);
 
     // Setup Image, and other stuff
     if (aImage)
@@ -236,21 +239,25 @@ nsDragService::InvokeDragSessionWithImag
     }
 
     return ExecuteDrag();
 }
 
-/* void invokeDragSessionWithSelection ( nsISelection selection , nsISupportsArray transferableArray , PRUint32 actionType , nsIDOMMouseEvent dragEvent ) */
 NS_IMETHODIMP
-nsDragService::InvokeDragSessionWithSelection(nsISelection* aSelection, nsISupportsArray* aTransferables, PRUint32 aActionType, nsIDOMMouseEvent* aDragEvent)
+nsDragService::InvokeDragSessionWithSelection(nsISelection* aSelection,
+                                              nsISupportsArray* aTransferableArray,
+                                              PRUint32 aActionType,
+                                              nsIDOMDragEvent* aDragEvent,
+                                              nsIDOMDataTransfer* aDataTransfer)
 {
     nsBaseDragService::InvokeDragSessionWithSelection(
                                         aSelection,
-                                        aTransferables,
+                                        aTransferableArray,
                                         aActionType,
-                                        aDragEvent );
+                                        aDragEvent,
+                                        aDataTransfer);
 
-    SetupDragSession( aTransferables, aActionType);
+    SetupDragSession( aTransferableArray, aActionType);
 
     // Setup selection related properties
     // There is however nothing that needs to be set
 
     return ExecuteDrag();
diff -r 6de576aeff11 xpcom/analysis/stack.js
--- a/xpcom/analysis/stack.js	Wed Aug 27 08:11:51 2008 -0400
+++ b/xpcom/analysis/stack.js	Thu Aug 28 21:06:42 2008 +0300
@@ -21,10 +21,13 @@ function isStack(c)
 
     for each (let member in c.members) {
       if (member.isFunction)
         continue;
 
+      if (hasAttribute(member, 'NS_okonheap'))
+        continue;
+      
       let type = member.type;
       while (true) {
         if (type === undefined)
           break;
 
diff -r 6de576aeff11 xpcom/base/nsObjCExceptions.h
--- a/xpcom/base/nsObjCExceptions.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/xpcom/base/nsObjCExceptions.h	Thu Aug 28 21:06:42 2008 +0300
@@ -44,10 +44,16 @@
 
 #ifdef DEBUG
 #import <ExceptionHandling/NSExceptionHandler.h>
 #endif
 
+#if defined(MOZ_CRASHREPORTER) && defined(__cplusplus)
+#include "nsICrashReporter.h"
+#include "nsCOMPtr.h"
+#include "nsServiceManagerUtils.h"
+#endif
+
 #include <unistd.h>
 #include <signal.h>
 #include "nsError.h"
 
 // See Mozilla bug 163260.
@@ -55,10 +61,18 @@
 
 static void nsObjCExceptionLog(NSException* aException)
 {
   NSLog(@"Mozilla has caught an Obj-C exception [%@: %@]",
         [aException name], [aException reason]);
+
+#if defined(MOZ_CRASHREPORTER) && defined(__cplusplus)
+  // Attach exception info to the crash report.
+  nsCOMPtr<nsICrashReporter> crashReporter =
+    do_GetService("@mozilla.org/toolkit/crash-reporter;1");
+  if (crashReporter)
+    crashReporter->AppendObjCExceptionInfoToAppNotes(static_cast<void*>(aException));
+#endif
 
 #ifdef DEBUG
   @try {
     // Try to get stack information out of the exception. 10.5 returns the stack
     // info with the callStackReturnAddresses selector.
diff -r 6de576aeff11 xpcom/base/nscore.h
--- a/xpcom/base/nscore.h	Wed Aug 27 08:11:51 2008 -0400
+++ b/xpcom/base/nscore.h	Thu Aug 28 21:06:42 2008 +0300
@@ -488,13 +488,15 @@ typedef PRUint32 nsrefcnt;
  * NS_STACK_CLASS: a class which must only be instantiated on the stack
  * NS_FINAL_CLASS: a class which may not be subclassed
  */
 #ifdef NS_STATIC_CHECKING
 #define NS_STACK_CLASS __attribute__((user("NS_stack")))
+#define NS_OKONHEAP    __attribute__((user("NS_okonheap")))
 #define NS_FINAL_CLASS __attribute__((user("NS_final")))
 #else
 #define NS_STACK_CLASS
+#define NS_OKONHEAP
 #define NS_FINAL_CLASS
 #endif
 
 /**
  * Attributes defined to help Dehydra GCC analysis.	
diff -r 6de576aeff11 xpcom/system/nsICrashReporter.idl
--- a/xpcom/system/nsICrashReporter.idl	Wed Aug 27 08:11:51 2008 -0400
+++ b/xpcom/system/nsICrashReporter.idl	Thu Aug 28 21:06:42 2008 +0300
@@ -41,11 +41,11 @@
  * Provides access to crash reporting functionality.
  * @status UNSTABLE - This interface is not frozen and will probably change in
  *                    future releases.
  */
 
-[scriptable, uuid(189c9392-157c-445f-84db-900eb46d4839)]
+[scriptable, uuid(D9A0F5B2-A7DF-4AEB-9775-21B9E01B4C59)]
 interface nsICrashReporter : nsISupports
 {
   /**
    * Add some extra data to be submitted with a crash report.
    * @param key
@@ -77,7 +77,13 @@ interface nsICrashReporter : nsISupports
     * Write a minidump immediately, with the user-supplied exception
     * information. This is implemented on Windows only, because
     * SEH (structured exception handling) exists on Windows only.
     * @param aExceptionInfo  EXCEPTION_INFO* provided by Window's SEH
     */
-  [noscript] void WriteMinidumpForException(in voidPtr aExceptionInfo);
+  [noscript] void writeMinidumpForException(in voidPtr aExceptionInfo);
+  
+  /**
+    * Append note containing an Obj-C exception's info.
+    * @param aException  NSException object to append note for
+    */
+  [noscript] void appendObjCExceptionInfoToAppNotes(in voidPtr aException);
 };
diff -r 6de576aeff11 xulrunner/installer/Makefile.in
--- a/xulrunner/installer/Makefile.in	Wed Aug 27 08:11:51 2008 -0400
+++ b/xulrunner/installer/Makefile.in	Thu Aug 28 21:06:42 2008 +0300
@@ -140,11 +140,11 @@ MOZ_DEB_TIMESTAMP = "$(shell date  +"%a,
 
 DEFINES += -DGRE_MILESTONE=$(GRE_MILESTONE) -DGRE_BUILDID=$(GRE_BUILDID) -DMOZ_DEB_TIMESTAMP=$(MOZ_DEB_TIMESTAMP)
 
 
 ifeq ($(OS_TARGET),Linux)
-debian/changelog: $(srcdir)/debian/changelog.in 
+debian/changelog: $(srcdir)/debian/changelog.in  $(LIBXUL_DIST)/bin/platform.ini
 	mkdir -p debian
 	$(PYTHON) $(topsrcdir)/config/Preprocessor.py \
         $(AUTOMATION_PPARGS) $(DEFINES) $(ACDEFINES) $^ > $@
 
 deb: debian/changelog
