diff -r 63f6591b1238 accessible/src/base/nsDocAccessible.h
--- a/accessible/src/base/nsDocAccessible.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/accessible/src/base/nsDocAccessible.h	Sat Sep 06 15:02:55 2008 +0300
@@ -86,10 +86,11 @@ class nsDocAccessible : public nsHyperTe
     NS_IMETHOD GetParent(nsIAccessible **aParent);
     NS_IMETHOD TakeFocus(void);
 
     // ----- nsIScrollPositionListener ---------------------------
     NS_IMETHOD ScrollPositionWillChange(nsIScrollableView *aView, nscoord aX, nscoord aY);
+    virtual void ViewPositionDidChange(nsIScrollableView* aScrollable) {}
     NS_IMETHOD ScrollPositionDidChange(nsIScrollableView *aView, nscoord aX, nscoord aY);
 
     // nsIDocumentObserver
     NS_DECL_NSIDOCUMENTOBSERVER
 
diff -r 63f6591b1238 browser/components/sessionstore/src/nsSessionStore.js
--- a/browser/components/sessionstore/src/nsSessionStore.js	Sat Sep 06 05:42:39 2008 +0200
+++ b/browser/components/sessionstore/src/nsSessionStore.js	Sat Sep 06 15:02:55 2008 +0300
@@ -367,10 +367,13 @@ SessionStoreService.prototype = {
       case "change":
       case "input":
       case "DOMAutoComplete":
         this.onTabInput(aEvent.currentTarget.ownerDocument.defaultView, aEvent.currentTarget);
         break;
+      case "scroll":
+        this.onTabScroll(aEvent.currentTarget.ownerDocument.defaultView);
+        break;
       case "TabOpen":
       case "TabClose":
         var panelID = aEvent.originalTarget.linkedPanel;
         var tabpanel = aEvent.originalTarget.ownerDocument.getElementById(panelID);
         if (aEvent.type == "TabOpen") {
@@ -530,10 +533,11 @@ SessionStoreService.prototype = {
     aPanel.addEventListener("load", this, true);
     aPanel.addEventListener("pageshow", this, true);
     aPanel.addEventListener("change", this, true);
     aPanel.addEventListener("input", this, true);
     aPanel.addEventListener("DOMAutoComplete", this, true);
+    aPanel.addEventListener("scroll", this, true);
     
     if (!aNoNotification) {
       this.saveStateDelayed(aWindow);
     }
   },
@@ -551,10 +555,11 @@ SessionStoreService.prototype = {
     aPanel.removeEventListener("load", this, true);
     aPanel.removeEventListener("pageshow", this, true);
     aPanel.removeEventListener("change", this, true);
     aPanel.removeEventListener("input", this, true);
     aPanel.removeEventListener("DOMAutoComplete", this, true);
+    aPanel.removeEventListener("scroll", this, true);
     
     delete aPanel.__SS_data;
     
     if (!aNoNotification) {
       this.saveStateDelayed(aWindow);
@@ -635,10 +640,19 @@ SessionStoreService.prototype = {
    */
   onTabInput: function sss_onTabInput(aWindow, aPanel) {
     if (aPanel.__SS_data)
       delete aPanel.__SS_data._formDataSaved;
     
+    this.saveStateDelayed(aWindow, 3000);
+  },
+
+  /**
+   * Called when a tabpanel sends a "scroll" notification 
+   * @param aWindow
+   *        Window reference
+   */
+  onTabScroll: function sss_onTabScroll(aWindow) {
     this.saveStateDelayed(aWindow, 3000);
   },
 
   /**
    * When a tab is selected, save session data
diff -r 63f6591b1238 content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/content/base/src/nsGenericElement.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -998,11 +998,12 @@ nsGenericElement::GetOffsetRect(nsRect& 
 
   // Get the union of all rectangles in this and continuation frames.
   // It doesn't really matter what we use as aRelativeTo here, since
   // we only care about the size. Using 'parent' might make things
   // a bit faster by speeding up the internal GetOffsetTo operations.
-  nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, nsnull);
+  nsIFrame* parent = frame->GetParent() ? frame->GetParent() : frame;
+  nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, parent);
   aRect.width = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.width);
   aRect.height = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.height);
 }
 
 void
diff -r 63f6591b1238 gfx/thebes/src/gfxAtsuiFonts.cpp
--- a/gfx/thebes/src/gfxAtsuiFonts.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/gfx/thebes/src/gfxAtsuiFonts.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -166,55 +166,91 @@ ATSUFontID gfxAtsuiFont::GetATSUFontID()
 ATSUFontID gfxAtsuiFont::GetATSUFontID()
 {
     return GetFontEntry()->GetFontID();
 }
 
+static void
+DisableUncommonLigatures(ATSUStyle aStyle)
+{
+    static const ATSUFontFeatureType types[] = {
+        kLigaturesType,
+        kLigaturesType,
+        kLigaturesType,
+        kLigaturesType,
+        kLigaturesType,
+        kLigaturesType,
+        kLigaturesType
+    };
+    static const ATSUFontFeatureType selectors[NS_ARRAY_LENGTH(types)] = {
+        kRareLigaturesOffSelector,
+        kLogosOffSelector,
+        kRebusPicturesOffSelector,
+        kDiphthongLigaturesOffSelector,
+        kSquaredLigaturesOffSelector,
+        kAbbrevSquaredLigaturesOffSelector,
+        kSymbolLigaturesOffSelector
+    };
+    ATSUSetFontFeatures(aStyle, NS_ARRAY_LENGTH(types), types, selectors);
+}
+
+static void
+DisableCommonLigatures(ATSUStyle aStyle)
+{
+    static const ATSUFontFeatureType types[] = {
+        kLigaturesType
+    };
+    static const ATSUFontFeatureType selectors[NS_ARRAY_LENGTH(types)] = {
+        kCommonLigaturesOffSelector
+    };
+    ATSUSetFontFeatures(aStyle, NS_ARRAY_LENGTH(types), types, selectors);
+}
+
 void
 gfxAtsuiFont::InitMetrics(ATSUFontID aFontID, ATSFontRef aFontRef)
 {
     /* Create the ATSUStyle */
-
-    ATSUAttributeTag styleTags[] = {
-        kATSUFontTag,
-        kATSUSizeTag,
-        kATSUFontMatrixTag
-    };
-
-    ByteCount styleArgSizes[] = {
-        sizeof(ATSUFontID),
-        sizeof(Fixed),
-        sizeof(CGAffineTransform),
-        sizeof(Fract)
-    };
 
     gfxFloat size =
         PR_MAX(((mAdjustedSize != 0.0f) ? mAdjustedSize : GetStyle()->size), 1.0f);
 
     //fprintf (stderr, "string: '%s', size: %f\n", NS_ConvertUTF16toUTF8(aString).get(), size);
 
+    if (mATSUStyle)
+      ATSUDisposeStyle(mATSUStyle);
+
+    ATSUFontID fid = aFontID;
     // fSize is in points (72dpi)
     Fixed fSize = FloatToFixed(size);
-    ATSUFontID fid = aFontID;
-
     // make the font render right-side up
     CGAffineTransform transform = CGAffineTransformMakeScale(1, -1);
 
-    ATSUAttributeValuePtr styleArgs[] = {
+    static const ATSUAttributeTag styleTags[] = {
+        kATSUFontTag,
+        kATSUSizeTag,
+        kATSUFontMatrixTag
+    };
+    const ATSUAttributeValuePtr styleArgs[NS_ARRAY_LENGTH(styleTags)] = {
         &fid,
         &fSize,
-        &transform,
+        &transform
     };
-
-    if (mATSUStyle)
-        ATSUDisposeStyle(mATSUStyle);
+    static const ByteCount styleArgSizes[NS_ARRAY_LENGTH(styleTags)] = {
+        sizeof(ATSUFontID),
+        sizeof(Fixed),
+        sizeof(CGAffineTransform)
+    };
 
     ATSUCreateStyle(&mATSUStyle);
     ATSUSetAttributes(mATSUStyle,
-                      sizeof(styleTags)/sizeof(ATSUAttributeTag),
+                      NS_ARRAY_LENGTH(styleTags),
                       styleTags,
                       styleArgSizes,
                       styleArgs);
+    // Disable uncommon ligatures, but *don't* enable common ones;
+    // the font may have default settings that disable common ligatures
+    // and we want to respect that.
+    DisableUncommonLigatures(mATSUStyle);
 
     /* Now pull out the metrics */
 
     ATSFontMetrics atsMetrics;
     ATSFontGetHorizontalMetrics(aFontRef, kATSOptionFlagsDefault,
@@ -1261,36 +1297,10 @@ GetFontPrefLangFor(PRUint8 aUnicodeRange
         case kRangeSetCJK:     return eFontPrefLang_CJKSet;
         default:               return eFontPrefLang_Others;
     }
 }
 
-static void
-DisableOptionalLigaturesInStyle(ATSUStyle aStyle)
-{
-    static ATSUFontFeatureType selectors[] = {
-        kCommonLigaturesOffSelector,
-        kRareLigaturesOffSelector,
-        kLogosOffSelector,
-        kRebusPicturesOffSelector,
-        kDiphthongLigaturesOffSelector,
-        kSquaredLigaturesOffSelector,
-        kAbbrevSquaredLigaturesOffSelector,
-        kSymbolLigaturesOffSelector
-    };
-    static ATSUFontFeatureType types[NS_ARRAY_LENGTH(selectors)] = {
-        kLigaturesType,
-        kLigaturesType,
-        kLigaturesType,
-        kLigaturesType,
-        kLigaturesType,
-        kLigaturesType,
-        kLigaturesType,
-        kLigaturesType
-    };
-    ATSUSetFontFeatures(aStyle, NS_ARRAY_LENGTH(selectors), types, selectors);
-}
-
 // 361695 - ATSUI only does glyph mirroring when the font contains a 'prop' table
 // with glyph mirroring info, the character mirroring has to be done manually in the 
 // fallback case.  Only used for RTL text runs.  The autoptr for the mirrored copy
 // is owned by the calling routine.
 
@@ -1379,11 +1389,11 @@ gfxAtsuiFontGroup::InitTextRun(gfxTextRu
 
     if (aRun->GetFlags() & TEXT_DISABLE_OPTIONAL_LIGATURES) {
         status = ATSUCreateAndCopyStyle(mainStyle, &mainStyle);
         if (status == noErr) {
             stylesToDispose.AppendElement(mainStyle);
-            DisableOptionalLigaturesInStyle(mainStyle);
+            DisableCommonLigatures(mainStyle);
         }
     }
 
     UniCharCount runLengths = aLengthInTextRun;
     ATSUTextLayout layout;
diff -r 63f6591b1238 layout/base/crashtests/243519-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/base/crashtests/243519-1.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,30 @@
+<!DOCTYPE HTML>
+<html>
+<body>
+  <div style="position:absolute;">Hello</div>
+  <div style="position:fixed;">Kitty</div>
+  <script>
+    document.body.offsetTop;
+    document.documentElement.style.display = "table";
+    document.body.offsetTop;
+    document.documentElement.style.display = "";
+    document.body.offsetTop;
+
+    document.documentElement.style.position = "absolute";
+    document.body.offsetTop;
+    document.documentElement.style.display = "table";
+    document.body.offsetTop;
+    document.documentElement.style.display = "";
+    document.body.offsetTop;
+
+    document.documentElement.style.position = "fixed";
+    document.body.offsetTop;
+    document.documentElement.style.display = "table";
+    document.body.offsetTop;
+    document.documentElement.style.display = "";
+    
+    document.documentElement.style.position = "";
+    document.body.offsetTop;
+  </script>
+</body>
+</html>
diff -r 63f6591b1238 layout/base/crashtests/crashtests.list
--- a/layout/base/crashtests/crashtests.list	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/base/crashtests/crashtests.list	Sat Sep 06 15:02:55 2008 +0300
@@ -1,10 +1,11 @@ load 56746-1.html
 load 56746-1.html
 load 143862-1.html
 load 143862-2.html
 load 243159-1.html
 load 243159-2.xhtml
+load 243519-1.html
 load 306940-1.html
 load 310267-1.xml
 load 310638-1.svg
 load 310638-2.html
 load 313086-1.xml
diff -r 63f6591b1238 layout/base/nsCSSFrameConstructor.cpp
--- a/layout/base/nsCSSFrameConstructor.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/base/nsCSSFrameConstructor.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -1804,13 +1804,13 @@ nsCSSFrameConstructor::nsCSSFrameConstru
   , mGfxScrollFrame(nsnull)
   , mPageSequenceFrame(nsnull)
   , mUpdateCount(0)
   , mQuotesDirty(PR_FALSE)
   , mCountersDirty(PR_FALSE)
-  , mInitialContainingBlockIsAbsPosContainer(PR_FALSE)
   , mIsDestroyingFrameTree(PR_FALSE)
   , mRebuildAllStyleData(PR_FALSE)
+  , mHasRootAbsPosContainingBlock(PR_FALSE)
 {
   if (!gGotXBLFormPrefs) {
     gGotXBLFormPrefs = PR_TRUE;
 
     gUseXBLForms =
@@ -3970,36 +3970,10 @@ nsCSSFrameConstructor::GetDisplay(nsIFra
 
 /***********************************************
  * END TABLE SECTION
  ***********************************************/
 
-nsresult
-nsCSSFrameConstructor::ConstructDocElementTableFrame(nsIContent*     aDocElement,
-                                                     nsIFrame*       aParentFrame,
-                                                     nsIFrame**      aNewTableFrame,
-                                                     nsFrameConstructorState& aState)
-{
-  nsFrameItems    frameItems;
-
-  // XXXbz this is wrong.  We should at least be setting the fixed container in
-  // the framestate here.  Better yet, we should pass through aState
-  // unmodified.  Can't do that, though, because then a fixed or absolute
-  // positioned root table with auto offsets would look for a block to compute
-  // its hypothetical box and crash.  So we just disable fixed positioning
-  // altogether in documents where the root is a table.  Oh, well.
-  nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull,
-                                aState.mFrameState);
-  ConstructFrame(state, aDocElement, aParentFrame, frameItems);
-  *aNewTableFrame = frameItems.childList;
-  if (!*aNewTableFrame) {
-    NS_WARNING("cannot get table contentFrame");
-    // XXXbz maybe better to return the error from ConstructFrame?
-    return NS_ERROR_FAILURE;
-  }
-  return NS_OK;
-}
-
 static PRBool CheckOverflow(nsPresContext* aPresContext,
                             const nsStyleDisplay* aDisplay)
 {
   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
     return PR_FALSE;
@@ -4091,33 +4065,10 @@ nsCSSFrameConstructor::ConstructDocEleme
 nsCSSFrameConstructor::ConstructDocElementFrame(nsFrameConstructorState& aState,
                                                 nsIContent*              aDocElement,
                                                 nsIFrame*                aParentFrame,
                                                 nsIFrame**               aNewFrame)
 {
-    // how the root frame hierarchy should look
-
-    /*
-
----------------No Scrollbars------
-
-
-     AreaFrame or BoxFrame (InitialContainingBlock)
-  
-
-
----------------Gfx Scrollbars ------
-
-
-     ScrollFrame
-
-         ^
-         |
-         |
-     AreaFrame or BoxFrame (InitialContainingBlock)
-          
-*/    
-
   *aNewFrame = nsnull;
 
   if (!mTempFrameTreeState)
     aState.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
 
@@ -4187,12 +4138,17 @@ nsCSSFrameConstructor::ConstructDocEleme
                aState.mPresContext->IsPaginated() ||
                propagatedScrollToViewport,
                "Scrollbars should have been propagated to the viewport");
 #endif
 
-  nsIFrame* contentFrame = nsnull;
-  PRBool isBlockFrame = PR_FALSE;
+  nsFrameConstructorSaveState absoluteSaveState;
+  if (mHasRootAbsPosContainingBlock) {
+    // Push the absolute containing block now so we can absolutely position
+    // the root element
+    aState.PushAbsoluteContainingBlock(mDocElementContainingBlock, absoluteSaveState);
+  }
+
   nsresult rv;
 
   // The rules from CSS 2.1, section 9.2.4, have already been applied
   // by the style system, so we can assume that display->mDisplay is
   // either NONE, BLOCK, or TABLE.
@@ -4200,56 +4156,99 @@ nsCSSFrameConstructor::ConstructDocEleme
   PRBool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE) &&
                           !IsSpecialContent(aDocElement, aDocElement->Tag(),
                                             aDocElement->GetNameSpaceID(),
                                             styleContext);
 
+  // contentFrame is the primary frame for the root element. *aNewFrame
+  // is the frame that will be the child of the initial containing block.
+  // These are usually the same frame but they can be different, in
+  // particular if the root frame is positioned, in which case
+  // contentFrame is the out-of-flow frame and *aNewFrame is the
+  // placeholder.
+  nsIFrame* contentFrame;
+  PRBool processChildren = PR_FALSE;
   if (docElemIsTable) {
+    nsIFrame* innerTableFrame;
+    nsFrameItems frameItems;
     // if the document is a table then just populate it.
-    rv = ConstructDocElementTableFrame(aDocElement, aParentFrame, &contentFrame,
-                                       aState);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    styleContext = contentFrame->GetStyleContext();
+    rv = ConstructTableFrame(aState, aDocElement,
+                             aParentFrame, styleContext,
+                             kNameSpaceID_None, PR_FALSE, frameItems, contentFrame,
+                             innerTableFrame);
+    if (NS_FAILED(rv))
+      return rv;
+    if (!contentFrame || !frameItems.childList)
+      return NS_ERROR_FAILURE;
+    *aNewFrame = frameItems.childList;
+    NS_ASSERTION(!frameItems.childList->GetNextSibling(),
+                 "multiple root element frames");
   } else {
     // otherwise build a box or a block
 #ifdef MOZ_XUL
     if (aDocElement->IsNodeOfType(nsINode::eXUL)) {
       contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
+      if (NS_UNLIKELY(!contentFrame)) {
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+      InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
+      *aNewFrame = contentFrame;
+      processChildren = PR_TRUE;
     }
     else
 #endif 
 #ifdef MOZ_SVG
     if (aDocElement->GetNameSpaceID() == kNameSpaceID_SVG) {
       if (aDocElement->Tag() == nsGkAtoms::svg && NS_SVGEnabled()) {
         contentFrame = NS_NewSVGOuterSVGFrame(mPresShell, aDocElement, styleContext);
+        if (NS_UNLIKELY(!contentFrame)) {
+          return NS_ERROR_OUT_OF_MEMORY;
+        }
+        InitAndRestoreFrame(aState, aDocElement,
+                            aState.GetGeometricParent(display, aParentFrame),
+                            nsnull, contentFrame);
+
+        // AddChild takes care of transforming the frame tree for fixed-pos
+        // or abs-pos situations
+        nsFrameItems frameItems;
+        rv = aState.AddChild(contentFrame, frameItems, aDocElement,
+                             styleContext, aParentFrame);
+        if (NS_FAILED(rv) || !frameItems.childList) {
+          return rv;
+        }
+        *aNewFrame = frameItems.childList;
+        processChildren = PR_TRUE;
+
+        // See if we need to create a view, e.g. the frame is absolutely positioned
+        nsHTMLContainerFrame::CreateViewForFrame(contentFrame, aParentFrame, PR_FALSE);
       } else {
         return NS_ERROR_FAILURE;
       }
     }
     else 
 #endif
     {
-      contentFrame = NS_NewDocumentElementFrame(mPresShell, styleContext);
-      isBlockFrame = PR_TRUE;
-    }
-    
-    if (NS_UNLIKELY(!contentFrame)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-
-    // initialize the child
-    InitAndRestoreFrame(aState, aDocElement, aParentFrame, nsnull, contentFrame);
+      contentFrame = NS_NewBlockFrame(mPresShell, styleContext,
+        NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+      if (!contentFrame)
+        return NS_ERROR_OUT_OF_MEMORY;
+      nsFrameItems frameItems;
+      rv = ConstructBlock(aState, display, aDocElement,
+                          aState.GetGeometricParent(display, aParentFrame),
+                          aParentFrame, styleContext, &contentFrame,
+                          frameItems, display->IsPositioned());
+      if (NS_FAILED(rv) || !frameItems.childList)
+        return rv;
+      *aNewFrame = frameItems.childList;
+      NS_ASSERTION(!frameItems.childList->GetNextSibling(),
+                   "multiple root element frames");
+    }
   }
 
   // set the primary frame
   aState.mFrameManager->SetPrimaryFrameFor(aDocElement, contentFrame);
 
-  *aNewFrame = contentFrame;
-
   mInitialContainingBlock = contentFrame;
-  mInitialContainingBlockIsAbsPosContainer = PR_FALSE;
 
   // Figure out which frame has the main style for the document element,
   // assigning it to mRootElementStyleFrame.
   // Backgrounds should be propagated from that frame to the viewport.
   PRBool isChild;
@@ -4257,35 +4256,23 @@ nsCSSFrameConstructor::ConstructDocEleme
           &mRootElementStyleFrame, &isChild);
   if (!isChild) {
     mRootElementStyleFrame = mInitialContainingBlock;
   }
 
-  // if it was a table then we don't need to process our children.
-  if (!docElemIsTable) {
-    // Process the child content
-    nsFrameConstructorSaveState absoluteSaveState;
-    nsFrameConstructorSaveState floatSaveState;
-    nsFrameItems                childItems;
-
-    if (isBlockFrame) {
-      PRBool haveFirstLetterStyle, haveFirstLineStyle;
-      ShouldHaveSpecialBlockStyle(aDocElement, styleContext,
-                                  &haveFirstLetterStyle, &haveFirstLineStyle);
-      mInitialContainingBlockIsAbsPosContainer = PR_TRUE;
-      aState.PushAbsoluteContainingBlock(contentFrame, absoluteSaveState);
-      aState.PushFloatContainingBlock(contentFrame, floatSaveState,
-                                      haveFirstLetterStyle,
-                                      haveFirstLineStyle);
-    }
+  if (processChildren) {
+    // Still need to process the child content
+    nsFrameItems childItems;
 
     // Create any anonymous frames the doc element frame requires
     // This must happen before ProcessChildren to ensure that popups are
     // never constructed before the popupset.
     CreateAnonymousFrames(nsnull, aState, aDocElement, contentFrame,
                           PR_FALSE, childItems, PR_TRUE);
+    NS_ASSERTION(!nsLayoutUtils::GetAsBlock(contentFrame),
+                 "Only XUL and SVG frames should reach here");
     ProcessChildren(aState, aDocElement, contentFrame, PR_TRUE, childItems,
-                    isBlockFrame);
+                    PR_FALSE);
 
     // Set the initial child lists
     contentFrame->SetInitialChildList(nsnull, childItems.childList);
   }
 
@@ -4298,40 +4285,66 @@ nsCSSFrameConstructor::ConstructRootFram
                                           nsIFrame**      aNewFrame)
 {
   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
   NS_PRECONDITION(aNewFrame, "null out param");
   
-  // how the root frame hierarchy should look
-
     /*
-
----------------No Scrollbars------
-
-
-
-     ViewPortFrame (FixedContainingBlock) <---- RootView
-
-         ^
-         |
-     RootFrame(DocElementContainingBlock)
-  
-
-
----------------Gfx Scrollbars ------
-
-
-     ViewPortFrame (FixedContainingBlock) <---- RootView
-
-         ^
-         |
-     ScrollFrame
-
-         ^
-         |
-     RootFrame(DocElementContainingBlock)
-          
-*/    
+       how the root frame hierarchy should look
+
+  Galley presentation, non-XUL, with scrolling (i.e. not a frameset):
+  
+      ViewportFrame [fixed-cb]
+        nsHTMLScrollFrame
+          CanvasFrame [abs-cb]
+            root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
+                                nsTableOuterFrame, nsPlaceholderFrame)
+
+  Galley presentation, non-XUL, without scrolling (i.e. a frameset):
+  
+      ViewportFrame [fixed-cb]
+        CanvasFrame [abs-cb]
+          root element frame (nsBlockFrame)
+
+  Galley presentation, XUL
+  
+      ViewportFrame [fixed-cb]
+        nsRootBoxFrame
+          root element frame (nsDocElementBoxFrame)
+
+  Print presentation, non-XUL
+
+      ViewportFrame
+        nsSimplePageSequenceFrame
+          nsPageFrame [fixed-cb]
+            nsPageContentFrame
+              CanvasFrame [abs-cb]
+                root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
+                                    nsTableOuterFrame, nsPlaceholderFrame)
+
+  Print-preview presentation, non-XUL
+
+      ViewportFrame
+        nsHTMLScrollFrame
+          nsSimplePageSequenceFrame
+            nsPageFrame [fixed-cb]
+              nsPageContentFrame
+                CanvasFrame [abs-cb]
+                  root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
+                                      nsTableOuterFrame, nsPlaceholderFrame)
+
+  Print/print preview of XUL is not supported.
+  [fixed-cb]: the default containing block for fixed-pos content
+  [abs-cb]: the default containing block for abs-pos content
+ 
+  Meaning of nsCSSFrameConstructor fields:
+    mInitialContainingBlock is "root element frame".
+    mDocElementContainingBlock is the parent of mInitialContainingBlock
+      (i.e. CanvasFrame or nsRootBoxFrame)
+    mFixedContainingBlock is the [fixed-cb]
+    mGfxScrollFrame is the nsHTMLScrollFrame mentioned above, or null if there isn't one
+    mPageSequenceFrame is the nsSimplePageSequenceFrame, or null if there isn't one
+*/
 
   // Set up our style rule observer.
   {
     mPresShell->StyleSet()->SetBindingManager(mDocument->BindingManager());
   }
@@ -4392,10 +4405,11 @@ nsCSSFrameConstructor::ConstructRootFram
     } else
 #endif
     {
       // pass a temporary stylecontext, the correct one will be set later
       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
+      mHasRootAbsPosContainingBlock = PR_TRUE;
     }
 
     rootPseudo = nsCSSAnonBoxes::canvas;
     mDocElementContainingBlock = rootFrame;
   } else {
@@ -4520,34 +4534,35 @@ nsCSSFrameConstructor::ConstructRootFram
   }
   
   if (isPaginated) { // paginated
     // Create the first page
     // Set the initial child lists
-    nsIFrame *pageFrame, *pageContentFrame;
+    nsIFrame *pageFrame, *canvasFrame;
     ConstructPageFrame(mPresShell, presContext, rootFrame, nsnull,
-                       pageFrame, pageContentFrame);
+                       pageFrame, canvasFrame);
     rootFrame->SetInitialChildList(nsnull, pageFrame);
 
     // The eventual parent of the document element frame.
     // XXX should this be set for every new page (in ConstructPageFrame)?
-    mDocElementContainingBlock = pageContentFrame;
+    mDocElementContainingBlock = canvasFrame;
+    mHasRootAbsPosContainingBlock = PR_TRUE;
   }
 
   viewportFrame->SetInitialChildList(nsnull, newFrame);
   
   *aNewFrame = viewportFrame;
 
   return NS_OK;
 }
 
 nsresult
-nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*   aPresShell,
+nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*  aPresShell,
                                           nsPresContext* aPresContext,
-                                          nsIFrame*       aParentFrame,
-                                          nsIFrame*       aPrevPageFrame,
-                                          nsIFrame*&      aPageFrame,
-                                          nsIFrame*&      aPageContentFrame)
+                                          nsIFrame*      aParentFrame,
+                                          nsIFrame*      aPrevPageFrame,
+                                          nsIFrame*&     aPageFrame,
+                                          nsIFrame*&     aCanvasFrame)
 {
   nsStyleContext* parentStyleContext = aParentFrame->GetStyleContext();
   nsStyleSet *styleSet = aPresShell->StyleSet();
 
   nsRefPtr<nsStyleContext> pagePseudoStyle;
@@ -4566,25 +4581,41 @@ nsCSSFrameConstructor::ConstructPageFram
   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
   pageContentPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
                                                            nsCSSAnonBoxes::pageContent,
                                                            pagePseudoStyle);
 
-  aPageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
-  if (NS_UNLIKELY(!aPageContentFrame))
+  nsIFrame* pageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
+  if (NS_UNLIKELY(!pageContentFrame))
     return NS_ERROR_OUT_OF_MEMORY;
 
   // Initialize the page content frame and force it to have a view. Also make it the
   // containing block for fixed elements which are repeated on every page.
   nsIFrame* prevPageContentFrame = nsnull;
   if (aPrevPageFrame) {
     prevPageContentFrame = aPrevPageFrame->GetFirstChild(nsnull);
     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
   }
-  aPageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
-  mFixedContainingBlock = aPageContentFrame;
-
-  aPageFrame->SetInitialChildList(nsnull, aPageContentFrame);
+  pageContentFrame->Init(nsnull, aPageFrame, prevPageContentFrame);
+  aPageFrame->SetInitialChildList(nsnull, pageContentFrame);
+  mFixedContainingBlock = pageContentFrame;
+
+  nsRefPtr<nsStyleContext> canvasPseudoStyle;
+  canvasPseudoStyle = styleSet->ResolvePseudoStyleFor(nsnull,
+                                                      nsCSSAnonBoxes::canvas,
+                                                      pageContentPseudoStyle);
+
+  aCanvasFrame = NS_NewCanvasFrame(aPresShell, canvasPseudoStyle);
+  if (NS_UNLIKELY(!aCanvasFrame))
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  nsIFrame* prevCanvasFrame = nsnull;
+  if (prevPageContentFrame) {
+    prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
+    NS_ASSERTION(prevCanvasFrame, "missing canvas frame");
+  }
+  aCanvasFrame->Init(nsnull, pageContentFrame, prevCanvasFrame);
+  pageContentFrame->SetInitialChildList(nsnull, aCanvasFrame);
 
   return NS_OK;
 }
 
 /* static */
@@ -6679,21 +6710,28 @@ nsCSSFrameConstructor::InitAndRestoreFra
 
 already_AddRefed<nsStyleContext>
 nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
                                            nsIContent*       aContent)
 {
-  nsStyleContext* parentStyleContext;
+  nsStyleContext* parentStyleContext = nsnull;
   if (aContent->GetParent()) {
     aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nsnull);
   
-    // Resolve the style context based on the content object and the parent
-    // style context
-    parentStyleContext = aParentFrame->GetStyleContext();
+    if (aParentFrame) {
+      // Resolve the style context based on the content object and the parent
+      // style context
+      parentStyleContext = aParentFrame->GetStyleContext();
+    } else {
+      // Perhaps aParentFrame is a canvasFrame and we're replicating
+      // fixed-pos frames.
+      // XXX should we create a way to tell ConstructFrame which style
+      // context to use, and pass it the style context for the
+      // previous page's fixed-pos frame?
+    }
   } else {
     // This has got to be a call from ConstructDocElementTableFrame.
-    // Not sure how best to asserrt that here.
-    parentStyleContext = nsnull;
+    // Not sure how best to assert that here.
   }
 
   nsStyleSet *styleSet = mPresShell->StyleSet();
 
   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
@@ -7502,49 +7540,70 @@ nsCSSFrameConstructor::ReconstructDocEle
   // XXXbz is that null-check needed?  Why?
   if (mDocument && mPresShell) {
     nsIContent *rootContent = mDocument->GetRootContent();
     
     if (rootContent) {
+      nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
+                                    nsnull, nsnull, mTempFrameTreeState);
+
       // Before removing the frames associated with the content object, ask them to save their
       // state onto a temporary state object.
-      CaptureStateForFramesOf(rootContent, mTempFrameTreeState);
-
-      nsFrameConstructorState state(mPresShell, mFixedContainingBlock,
-                                    nsnull, nsnull, mTempFrameTreeState);
+      CaptureStateFor(state.mFrameManager->GetRootFrame(), mTempFrameTreeState);
 
       // Get the frame that corresponds to the document element
       nsIFrame* docElementFrame =
         state.mFrameManager->GetPrimaryFrameFor(rootContent, -1);
-        
+
+      if (docElementFrame) {
+        // Destroy out-of-flow frames that might not be in the frame subtree
+        // rooted at docElementFrame
+        ::DeletingFrameSubtree(state.mFrameManager, docElementFrame);
+      }
+
       // Remove any existing fixed items: they are always on the
       // FixedContainingBlock.  Note that this has to be done before we call
       // ClearPlaceholderFrameMap(), since RemoveFixedItems uses the
       // placeholder frame map.
-      rv = RemoveFixedItems(state);
+      rv = RemoveFixedItems(state, docElementFrame);
+
       if (NS_SUCCEEDED(rv)) {
+        nsPlaceholderFrame* placeholderFrame = nsnull;
+        if (docElementFrame &&
+            (docElementFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
+          // Get the placeholder frame now, before we tear down the
+          // placeholder frame map
+          placeholderFrame =
+            state.mFrameManager->GetPlaceholderFrameFor(docElementFrame);
+          NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
+        }
+
         // Clear the hash tables that map from content to frame and out-of-flow
         // frame to placeholder frame
         state.mFrameManager->ClearPrimaryFrameMap();
         state.mFrameManager->ClearPlaceholderFrameMap();
         state.mFrameManager->ClearUndisplayedContentMap();
 
         if (docElementFrame) {
           // Take the docElementFrame, and remove it from its parent.
-        
           // XXXbz So why can't we reuse ContentRemoved?
-
-          NS_ASSERTION(docElementFrame->GetParent() == mDocElementContainingBlock,
-                       "Unexpected doc element parent frame");
 
           // Notify self that we will destroy the entire frame tree, this blocks
           // RemoveMappingsForFrameSubtree() which would otherwise lead to a
           // crash since we cleared the placeholder map above (bug 398982).
           PRBool wasDestroyingFrameTree = mIsDestroyingFrameTree;
           WillDestroyFrameTree();
-          // Remove the old document element hieararchy
-          rv = state.mFrameManager->RemoveFrame(mDocElementContainingBlock,
-                                                nsnull, docElementFrame);
+
+          rv = state.mFrameManager->RemoveFrame(docElementFrame->GetParent(),
+                    GetChildListNameFor(docElementFrame), docElementFrame);
+          
+          if (placeholderFrame) {
+            // Remove the placeholder frame first (XXX second for now) (so
+            // that it doesn't retain a dangling pointer to memory)
+            rv |= state.mFrameManager->RemoveFrame(placeholderFrame->GetParent(),
+                                            nsnull, placeholderFrame);
+          }
+
           mIsDestroyingFrameTree = wasDestroyingFrameTree;
           if (NS_FAILED(rv)) {
             return rv;
           }
         }
@@ -7637,13 +7696,12 @@ nsCSSFrameConstructor::GetAbsoluteContai
   // If we found an absolutely positioned containing block, then use the
   // first-continuation.
   if (containingBlock)
     return AdjustAbsoluteContainingBlock(containingBlock);
 
-  // If we didn't find it, then use the initial containing block if it
-  // supports abs pos kids.
-  return mInitialContainingBlockIsAbsPosContainer ? mInitialContainingBlock : nsnull;
+  // If we didn't find it, then use the document element containing block
+  return mHasRootAbsPosContainingBlock ? mDocElementContainingBlock : nsnull;
 }
 
 nsIFrame*
 nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
 {
@@ -10224,13 +10282,13 @@ nsCSSFrameConstructor::CreateContinuingF
       // XXXbz should we be passing in a non-null aContentParentFrame?
       nsHTMLContainerFrame::CreateViewForFrame(newFrame, nsnull, PR_FALSE);
     }
 
   } else if (nsGkAtoms::pageFrame == frameType) {
-    nsIFrame* pageContentFrame;
+    nsIFrame* canvasFrame;
     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
-                            newFrame, pageContentFrame);
+                            newFrame, canvasFrame);
   } else if (nsGkAtoms::tableOuterFrame == frameType) {
     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
                                          content, styleContext, &newFrame);
 
   } else if (nsGkAtoms::tableFrame == frameType) {
@@ -10415,21 +10473,21 @@ nsCSSFrameConstructor::CreateContinuingF
 }
 
 nsresult
 nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
 {
-  // Now deal with fixed-pos things....  They should appear on all pages, and
-  // the placeholders must be kids of a block, so we want to move over the
-  // placeholders when processing the child of the pageContentFrame.
+  // Now deal with fixed-pos things....  They should appear on all pages,
+  // so we want to move over the placeholders when processing the child
+  // of the pageContentFrame.
 
   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
   if (!prevPageContentFrame) {
     return NS_OK;
   }
-  nsIFrame* docRootFrame = aParentFrame->GetFirstChild(nsnull);
-  nsIFrame* prevDocRootFrame = prevPageContentFrame->GetFirstChild(nsnull);
-  if (!docRootFrame || !prevDocRootFrame) {
+  nsIFrame* canvasFrame = aParentFrame->GetFirstChild(nsnull);
+  nsIFrame* prevCanvasFrame = prevPageContentFrame->GetFirstChild(nsnull);
+  if (!canvasFrame || !prevCanvasFrame) {
     // document's root element frame missing
     return NS_ERROR_UNEXPECTED;
   }
 
   nsFrameItems fixedPlaceholders;
@@ -10453,23 +10511,23 @@ nsCSSFrameConstructor::ReplicateFixedFra
   // page - bug 389619)
   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
     nsIFrame* prevPlaceholder = nsnull;
     mPresShell->GetPlaceholderFrameFor(fixed, &prevPlaceholder);
     if (prevPlaceholder &&
-        nsLayoutUtils::IsProperAncestorFrame(prevDocRootFrame, prevPlaceholder)) {
+        nsLayoutUtils::IsProperAncestorFrame(prevCanvasFrame, prevPlaceholder)) {
       nsresult rv = ConstructFrame(state, fixed->GetContent(),
-                                   docRootFrame, fixedPlaceholders);
+                                   canvasFrame, fixedPlaceholders);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
   // Add the placeholders to our primary child list.
-  // XXXbz this is a little screwed up, since the fixed frames will have the
-  // wrong parent block and hence auto-positioning will be broken.  Oh, well.
-  NS_ASSERTION(!docRootFrame->GetFirstChild(nsnull),
+  // XXXbz this is a little screwed up, since the fixed frames will have 
+  // broken auto-positioning. Oh, well.
+  NS_ASSERTION(!canvasFrame->GetFirstChild(nsnull),
                "leaking frames; doc root continuation must be empty");
-  docRootFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
+  canvasFrame->SetInitialChildList(nsnull, fixedPlaceholders.childList);
   return NS_OK;
 }
 
 static PRBool
 IsBindingAncestor(nsIContent* aContent, nsIContent* aBindingRoot)
@@ -12796,18 +12854,26 @@ nsCSSFrameConstructor::ReframeContaining
 
   // If we get here, we're screwed!
   return ReconstructDocElementHierarchyInternal();
 }
 
-nsresult nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState)
+nsresult
+nsCSSFrameConstructor::RemoveFixedItems(const nsFrameConstructorState& aState,
+                                        nsIFrame *aRootElementFrame)
 {
   nsresult rv=NS_OK;
 
   if (mFixedContainingBlock) {
     nsIFrame *fixedChild = nsnull;
     do {
       fixedChild = mFixedContainingBlock->GetFirstChild(nsGkAtoms::fixedList);
+      if (fixedChild == aRootElementFrame) {
+        // Skip the root element frame, if it happens to be fixed-positioned
+        // It will be explicitly removed later in
+        // ReconstructDocElementHierarchyInternal
+        fixedChild = fixedChild->GetNextSibling();
+      }
       if (fixedChild) {
         // Remove the placeholder so it doesn't end up sitting about pointing
         // to the removed fixed frame.
         nsPlaceholderFrame *placeholderFrame =
           aState.mFrameManager->GetPlaceholderFrameFor(fixedChild);
diff -r 63f6591b1238 layout/base/nsCSSFrameConstructor.h
--- a/layout/base/nsCSSFrameConstructor.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/base/nsCSSFrameConstructor.h	Sat Sep 06 15:02:55 2008 +0300
@@ -268,11 +268,11 @@ private:
   nsresult ConstructPageFrame(nsIPresShell*  aPresShell, 
                               nsPresContext* aPresContext,
                               nsIFrame*      aParentFrame,
                               nsIFrame*      aPrevPageFrame,
                               nsIFrame*&     aPageFrame,
-                              nsIFrame*&     aPageContentFrame);
+                              nsIFrame*&     aCanvasFrame);
 
   void DoContentStateChanged(nsIContent*     aContent,
                              PRInt32         aStateMask);
 
   /* aMinHint is the minimal change that should be made to the element */
@@ -1047,11 +1047,12 @@ private:
                                  nsIFrame*                aBlockFrame,
                                  nsIFrame**               aParentFrame,
                                  nsIFrame*                aPrevSibling,
                                  nsFrameItems&            aFrameItems);
 
-  nsresult RemoveFixedItems(const nsFrameConstructorState& aState);
+  nsresult RemoveFixedItems(const nsFrameConstructorState& aState,
+                            nsIFrame*                      aRootElementFrame);
 
   // Find the right frame to use for aContent when looking for sibling
   // frames for aTargetContent.  If aPrevSibling is true, this
   // will look for last continuations, etc, as necessary.  This calls
   // IsValidSibling as needed; if that returns false it returns null.
@@ -1162,10 +1163,13 @@ private:
   };
 
   nsIDocument*        mDocument;  // Weak ref
   nsIPresShell*       mPresShell; // Weak ref
 
+  // See the comment at the start of ConstructRootFrame for more details
+  // about the following frames.
+  
   // This is not the real CSS 2.1 "initial containing block"! It is just
   // the outermost frame for the root element.
   nsIFrame*           mInitialContainingBlock;
   // This is the frame for the root element that has no pseudo-element style.
   nsIFrame*           mRootElementStyleFrame;
@@ -1179,13 +1183,14 @@ private:
   nsQuoteList         mQuoteList;
   nsCounterManager    mCounterManager;
   PRUint16            mUpdateCount;
   PRPackedBool        mQuotesDirty : 1;
   PRPackedBool        mCountersDirty : 1;
-  PRPackedBool        mInitialContainingBlockIsAbsPosContainer : 1;
   PRPackedBool        mIsDestroyingFrameTree : 1;
   PRPackedBool        mRebuildAllStyleData : 1;
+  // This is true if mDocElementContainingBlock supports absolute positioning
+  PRPackedBool        mHasRootAbsPosContainingBlock : 1;
 
   nsRevocableEventPtr<RestyleEvent> mRestyleEvent;
 
   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
 
diff -r 63f6591b1238 layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/base/nsLayoutUtils.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -262,11 +262,12 @@ nsLayoutUtils::IsGeneratedContentFor(nsI
     (aPseudoElement == nsCSSPseudoElements::before);
 }
 
 // static
 nsIFrame*
-nsLayoutUtils::GetCrossDocParentFrame(nsIFrame* aFrame)
+nsLayoutUtils::GetCrossDocParentFrame(const nsIFrame* aFrame,
+                                      nsPoint* aExtraOffset)
 {
   nsIFrame* p = aFrame->GetParent();
   if (p)
     return p;
 
@@ -274,10 +275,13 @@ nsLayoutUtils::GetCrossDocParentFrame(ns
   if (!v)
     return nsnull;
   v = v->GetParent(); // anonymous inner view
   if (!v)
     return nsnull;
+  if (aExtraOffset) {
+    *aExtraOffset += v->GetPosition();
+  }
   v = v->GetParent(); // subdocumentframe's view
   if (!v)
     return nsnull;
   return static_cast<nsIFrame*>(v->GetClientData());
 }
diff -r 63f6591b1238 layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/base/nsLayoutUtils.h	Sat Sep 06 15:02:55 2008 +0300
@@ -227,12 +227,15 @@ public:
 
   /**
    * Get the parent of aFrame. If aFrame is the root frame for a document,
    * and the document has a parent document in the same view hierarchy, then
    * we try to return the subdocumentframe in the parent document.
+   * @param aExtraOffset [in/out] if non-null, then as we cross documents
+   * an extra offset may be required and it will be added to aCrossDocOffset
    */
-  static nsIFrame* GetCrossDocParentFrame(nsIFrame* aFrame);
+  static nsIFrame* GetCrossDocParentFrame(const nsIFrame* aFrame,
+                                          nsPoint* aCrossDocOffset = nsnull);
   
   /**
    * IsProperAncestorFrame checks whether aAncestorFrame is an ancestor
    * of aFrame and not equal to aFrame.
    * @param aCommonAncestor nsnull, or a common ancestor of aFrame and
diff -r 63f6591b1238 layout/forms/nsComboboxControlFrame.cpp
--- a/layout/forms/nsComboboxControlFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/forms/nsComboboxControlFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -477,11 +477,11 @@ nsComboboxControlFrame::ReflowDropdown(n
     viewManager->ResizeView(view, emptyRect);
   }
   
   // Allow the child to move/size/change-visibility its view if it's currently
   // dropped down
-  PRInt32 flags = NS_FRAME_NO_MOVE_VIEW | NS_FRAME_NO_VISIBILITY | NS_FRAME_NO_SIZE_VIEW;
+  PRInt32 flags = NS_FRAME_NO_MOVE_FRAME | NS_FRAME_NO_VISIBILITY | NS_FRAME_NO_SIZE_VIEW;
   if (mDroppedDown) {
     flags = 0;
   }
   nsRect rect = mDropdownFrame->GetRect();
   nsHTMLReflowMetrics desiredSize;
diff -r 63f6591b1238 layout/generic/crashtests/422283-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/422283-1.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,10 @@
+<!DOCTYPE html>
+<html>
+<head></head>
+
+<body style="-moz-column-width: 1px;"><div style="padding: 150px 0; height: 80px;"><span>
+</span>x<div></div><span>
+</span>a ! b c<div></div>
+</div></body>
+
+</html>
diff -r 63f6591b1238 layout/generic/crashtests/422301-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/generic/crashtests/422301-1.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,24 @@
+<!DOCTYPE html>
+<html>
+<head>
+
+<style type="text/css">
+
+div { height: .5em; margin: 1em; }
+
+</style>
+
+<script type="text/javascript">
+
+function boom()
+{
+  document.getElementById("b").style.padding = "";
+  document.getElementById("a").style.padding = "12em";
+}
+
+</script>
+</head>
+
+<body onload="boom();" style="-moz-column-width: 2em;"><div id="a"></div><div></div><div></div><div id="b" style="padding: 12em;">This is text</div>This is textThis is text<div>This is text</div></body>
+
+</html>
diff -r 63f6591b1238 layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/crashtests/crashtests.list	Sat Sep 06 15:02:55 2008 +0300
@@ -135,8 +135,10 @@ load 415685-1.html
 load 415685-1.html
 load 416264-1.html
 load 416476-1.html
 load 418532-1.html
 load 421404-1.html
+load 422283-1.html
+load 422301-1.html
 load 425253-1.html
 load 430352-1.html
 load 448903-1.html
diff -r 63f6591b1238 layout/generic/nsAbsoluteContainingBlock.cpp
--- a/layout/generic/nsAbsoluteContainingBlock.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsAbsoluteContainingBlock.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -49,21 +49,10 @@
 #include "nsPresContext.h"
 
 #ifdef DEBUG
 #include "nsBlockFrame.h"
 #endif
-
-
-nsresult
-nsAbsoluteContainingBlock::FirstChild(const nsIFrame* aDelegatingFrame,
-                                      nsIAtom*        aListName,
-                                      nsIFrame**      aFirstChild) const
-{
-  NS_PRECONDITION(GetChildListName() == aListName, "unexpected child list name");
-  *aFirstChild = mAbsoluteFrames.FirstChild();
-  return NS_OK;
-}
 
 nsresult
 nsAbsoluteContainingBlock::SetInitialChildList(nsIFrame*       aDelegatingFrame,
                                                nsIAtom*        aListName,
                                                nsIFrame*       aChildList)
diff -r 63f6591b1238 layout/generic/nsAbsoluteContainingBlock.h
--- a/layout/generic/nsAbsoluteContainingBlock.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsAbsoluteContainingBlock.h	Sat Sep 06 15:02:55 2008 +0300
@@ -82,14 +82,11 @@ public:
 
 #ifdef DEBUG
   nsIAtom* GetChildListName() const { return mChildListName; }
 #endif
 
-  nsresult FirstChild(const nsIFrame* aDelegatingFrame,
-                      nsIAtom*        aListName,
-                      nsIFrame**      aFirstChild) const;
-  nsIFrame* GetFirstChild() { return mAbsoluteFrames.FirstChild(); }
+  nsIFrame* GetFirstChild() const { return mAbsoluteFrames.FirstChild(); }
 
   nsresult SetInitialChildList(nsIFrame*       aDelegatingFrame,
                                nsIAtom*        aListName,
                                nsIFrame*       aChildList);
   nsresult AppendFrames(nsIFrame*      aDelegatingFrame,
diff -r 63f6591b1238 layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsBlockFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -518,13 +518,11 @@ nsBlockFrame::GetBaseline() const
 
 nsIFrame*
 nsBlockFrame::GetFirstChild(nsIAtom* aListName) const
 {
   if (nsGkAtoms::absoluteList == aListName) {
-    nsIFrame* result = nsnull;
-    mAbsoluteContainer.FirstChild(this, aListName, &result);
-    return result;
+    return mAbsoluteContainer.GetFirstChild();
   }
   else if (nsnull == aListName) {
     return (mLines.empty()) ? nsnull : mLines.front()->mFirstChild;
   }
   else if (aListName == nsGkAtoms::overflowList) {
@@ -801,31 +799,29 @@ CalculateContainingBlockSizeForAbsolutes
   const nsMargin& border =
     aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
   cbSize.width -= border.LeftRight();
   cbSize.height -= border.TopBottom();
 
-  if (frame->GetParent()->GetContent() == frame->GetContent()) {
-    // We are a wrapped frame for the content. Use the container's
-    // dimensions, if they have been precomputed.
+  if (frame->GetParent()->GetContent() == frame->GetContent() &&
+      frame->GetParent()->GetType() != nsGkAtoms::canvasFrame) {
+    // We are a wrapped frame for the content (and the wrapper is not the
+    // canvas frame, whose size is not meaningful here).
+    // Use the container's dimensions, if they have been precomputed.
     // XXX This is a hack! We really should be waiting until the outermost
     // frame is fully reflowed and using the resulting dimensions, even
     // if they're intrinsic.
     // In fact we should be attaching absolute children to the outermost
     // frame and not always sticking them in block frames.
 
     // First, find the reflow state for the outermost frame for this
     // content.
     const nsHTMLReflowState* aLastRS = &aReflowState;
     const nsHTMLReflowState* lastButOneRS = &aReflowState;
-    PRBool isCanvasBlock = PR_FALSE;
     while (aLastRS->parentReflowState &&
            aLastRS->parentReflowState->frame->GetContent() == frame->GetContent()) {
       lastButOneRS = aLastRS;
       aLastRS = aLastRS->parentReflowState;
-      if (aLastRS->frame->GetType() == nsGkAtoms::canvasFrame) {
-        isCanvasBlock = PR_TRUE;
-      }
     }
     if (aLastRS != &aReflowState) {
       // Scrollbars need to be specifically excluded, if present, because they are outside the
       // padding-edge. We need better APIs for getting the various boxes from a frame.
       nsIScrollableFrame* scrollFrame;
@@ -842,27 +838,15 @@ CalculateContainingBlockSizeForAbsolutes
           scrollbars.left = scrollbars.right = 0;
         }
       }
       // We found a reflow state for the outermost wrapping frame, so use
       // its computed metrics if available
-      // XXX grotesque hack for Firefox 2 compatibility until we can
-      // properly fix abs-pos containers! If this is the block for
-      // the root element, don't adjust the width here, just use the block's
-      // width. We have to do this because the abs-pos frame will be
-      // positioned relative to the block, not the canvas frame, and the
-      // block might have borders and margin which will throw things off
-      // if we use the canvas frame width.
-      // Positioning abs-pos frames relative to the canvas is bug 425432.
-      if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE && !isCanvasBlock) {
+      if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE) {
         cbSize.width = PR_MAX(0,
           aLastRS->ComputedWidth() + aLastRS->mComputedPadding.LeftRight() - scrollbars.LeftRight());
       }
       if (aLastRS->ComputedHeight() != NS_UNCONSTRAINEDSIZE) {
-        // XXX This can be terribly wrong if we're the root element's block,
-        // because our margin and borders will be included in the height
-        // here but the abs-pos element(s) are positioned relative to
-        // our content rect...
         cbSize.height = PR_MAX(0,
           aLastRS->ComputedHeight() + aLastRS->mComputedPadding.TopBottom() - scrollbars.TopBottom());
       }
     }
   }
diff -r 63f6591b1238 layout/generic/nsContainerFrame.cpp
--- a/layout/generic/nsContainerFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsContainerFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -762,11 +762,11 @@ nsContainerFrame::ReflowChild(nsIFrame* 
 
   // Send the WillReflow() notification, and position the child frame
   // and its view if requested
   aKidFrame->WillReflow(aPresContext);
 
-  if (0 == (aFlags & NS_FRAME_NO_MOVE_FRAME)) {
+  if (NS_FRAME_NO_MOVE_FRAME != (aFlags & NS_FRAME_NO_MOVE_FRAME)) {
     if ((aFlags & NS_FRAME_INVALIDATE_ON_MOVE) &&
         !(aKidFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) &&
         aKidFrame->GetPosition() != nsPoint(aX, aY)) {
       aKidFrame->InvalidateOverflowRect();
     }
@@ -1438,13 +1438,14 @@ nsOverflowContinuationTracker::Insert(ns
                   !!(aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
                   "shouldn't insert frame that doesn't match walker type");
   NS_PRECONDITION(aOverflowCont->GetPrevInFlow(),
                   "overflow containers must have a prev-in-flow");
   nsresult rv = NS_OK;
+  PRBool convertedToOverflowContainer = PR_FALSE;
+  nsPresContext* presContext = aOverflowCont->PresContext();
   if (!mSentry || aOverflowCont != mSentry->GetNextInFlow()) {
     // Not in our list, so we need to add it
-    nsPresContext* presContext = aOverflowCont->PresContext();
     if (aOverflowCont->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
       // aOverflowCont is in some other overflow container list,
       // steal it first
       NS_ASSERTION(!(mOverflowContList &&
                      mOverflowContList->ContainsFrame(aOverflowCont)),
@@ -1453,10 +1454,11 @@ nsOverflowContinuationTracker::Insert(ns
              ->StealFrame(presContext, aOverflowCont);
       NS_ENSURE_SUCCESS(rv, rv);
     }
     else {
       aOverflowCont->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
+      convertedToOverflowContainer = PR_TRUE;
     }
     if (!mOverflowContList) {
       mOverflowContList = new nsFrameList();
       rv = mParent->SetPropTableFrames(presContext,
              mOverflowContList, nsGkAtoms::excessOverflowContainersProperty);
@@ -1481,37 +1483,55 @@ nsOverflowContinuationTracker::Insert(ns
   NS_ASSERTION(mPrevOverflowCont == aOverflowCont ||
                (mSkipOverflowContainerChildren &&
                 (mPrevOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW) !=
                 (aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW)),
               "OverflowContTracker in unexpected state");
+
+  if (convertedToOverflowContainer) {
+    // Convert all non-overflow-container continuations of aOverflowCont
+    // into overflow containers and move them to our overflow
+    // tracker. This preserves the invariant that the next-continuations
+    // of an overflow container are also overflow containers.
+    nsIFrame* f = aOverflowCont->GetNextContinuation();
+    if (f && !(f->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
+      nsContainerFrame* parent = static_cast<nsContainerFrame*>(f->GetParent());
+      rv = parent->StealFrame(presContext, f);
+      NS_ENSURE_SUCCESS(rv, rv);
+      Insert(f, aReflowStatus);
+    }
+  }
   return rv;
 }
 
 void
 nsOverflowContinuationTracker::Finish(nsIFrame* aChild)
 {
   NS_PRECONDITION(aChild, "null ptr");
   NS_PRECONDITION(aChild->GetNextInFlow(),
                 "supposed to call Finish *before* deleting next-in-flow!");
-  if (aChild == mSentry) {
-    // Make sure we drop all references if this was the only frame
-    // in the overflow containers list
-    if (mOverflowContList->FirstChild() == aChild->GetNextInFlow()
-        && !aChild->GetNextInFlow()->GetNextSibling()) {
-      mOverflowContList = nsnull;
-      mPrevOverflowCont = nsnull;
-      mSentry = nsnull;
-      mParent = static_cast<nsContainerFrame*>(aChild->GetParent());
-    }
-    else {
-      // Step past aChild
-      nsIFrame* prevOverflowCont = mPrevOverflowCont;
-      StepForward();
-      if (mPrevOverflowCont == aChild->GetNextInFlow()) {
-        // Pull mPrevOverflowChild back to aChild's prevSibling:
-        // aChild will be removed from our list by our caller
-        mPrevOverflowCont = prevOverflowCont;
+
+  for (nsIFrame* f = aChild; f; f = f->GetNextInFlow()) {
+    if (f == mSentry) {
+      // Make sure we drop all references if this was the only frame
+      // in the overflow containers list
+      if (mOverflowContList->FirstChild() == f->GetNextInFlow()
+          && !f->GetNextInFlow()->GetNextSibling()) {
+        mOverflowContList = nsnull;
+        mPrevOverflowCont = nsnull;
+        mSentry = nsnull;
+        mParent = static_cast<nsContainerFrame*>(f->GetParent());
+        break;
+      }
+      else {
+        // Step past aChild
+        nsIFrame* prevOverflowCont = mPrevOverflowCont;
+        StepForward();
+        if (mPrevOverflowCont == f->GetNextInFlow()) {
+          // Pull mPrevOverflowChild back to aChild's prevSibling:
+          // aChild will be removed from our list by our caller
+          mPrevOverflowCont = prevOverflowCont;
+        }
       }
     }
   }
 }
 
@@ -1562,10 +1582,13 @@ nsContainerFrame::List(FILE* out, PRInt3
   // Output the children
   nsIAtom* listName = nsnull;
   PRInt32 listIndex = 0;
   PRBool outputOneList = PR_FALSE;
   do {
+    if (!outputOneList) {
+      fputs("\n", out);
+    }
     nsIFrame* kid = GetFirstChild(listName);
     if (nsnull != kid) {
       if (outputOneList) {
         IndentBy(out, aIndent);
       }
diff -r 63f6591b1238 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -2152,11 +2152,11 @@ NS_IMETHODIMP nsFrame::HandleDrag(nsPres
 {
   PRBool  selectable;
   PRUint8 selectStyle;
   IsSelectable(&selectable, &selectStyle);
   // XXX Do we really need to exclude non-selectable content here?
-  // GetContentAndOffsetsFromPoint can handle it just fine, although some
+  // GetContentOffsetsFromPoint can handle it just fine, although some
   // other stuff might not like it.
   if (!selectable)
     return NS_OK;
   if (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF) {
     return NS_OK;
@@ -3450,26 +3450,29 @@ nsPoint nsIFrame::GetOffsetToExternal(co
 
 nsPoint nsIFrame::GetOffsetTo(const nsIFrame* aOther) const
 {
   NS_PRECONDITION(aOther,
                   "Must have frame for destination coordinate system!");
-  // Note that if we hit a view while walking up the frame tree we need to stop
-  // and switch to traversing the view tree so that we will deal with scroll
-  // views properly.
   nsPoint offset(0, 0);
   const nsIFrame* f;
-  for (f = this; !f->HasView() && f != aOther; f = f->GetParent()) {
+  for (f = this; f != aOther && f;
+       f = nsLayoutUtils::GetCrossDocParentFrame(f, &offset)) {
     offset += f->GetPosition();
   }
-  
+
   if (f != aOther) {
-    // We found a view.  Switch to the view tree
-    nsPoint toViewOffset(0, 0);
-    nsIView* otherView = aOther->GetClosestView(&toViewOffset);
-    offset += f->GetView()->GetOffsetTo(otherView) - toViewOffset;
-  }
-  
+    // Looks like aOther wasn't an ancestor of |this|.  So now we have
+    // the root-document-relative position of |this| in |offset|.  Convert back
+    // to the coordinates of aOther
+    nsPoint negativeOffset(0,0);
+    while (aOther) {
+      offset -= aOther->GetPosition();
+      aOther = nsLayoutUtils::GetCrossDocParentFrame(aOther, &negativeOffset);
+    }
+    offset -= negativeOffset;
+  }
+
   return offset;
 }
 
 // virtual
 nsIntRect nsIFrame::GetScreenRectExternal() const
@@ -3530,92 +3533,10 @@ NS_IMETHODIMP nsFrame::GetOffsetFromView
     frame = frame->GetParent();
   } while (frame && !frame->HasView());
   if (frame)
     *aView = frame->GetView();
   return NS_OK;
-}
-
-// The (x,y) value of the frame's upper left corner is always
-// relative to its parentFrame's upper left corner, unless
-// its parentFrame has a view associated with it, in which case, it
-// will be relative to the upper left corner of the view returned
-// by a call to parentFrame->GetView().
-//
-// This means that while drilling down the frame hierarchy, from
-// parent to child frame, we sometimes need to take into account
-// crossing these view boundaries, because the coordinate system
-// changes from parent frame coordinate system, to the associated
-// view's coordinate system.
-//
-// GetOriginToViewOffset() is a utility method that returns the
-// offset necessary to map a point, relative to the frame's upper
-// left corner, into the coordinate system of the view associated
-// with the frame.
-//
-// If there is no view associated with the frame, or the view is
-// not a descendant of the frame's parent view (ex: scrolling popup menu),
-// the offset returned will be (0,0).
-
-NS_IMETHODIMP nsFrame::GetOriginToViewOffset(nsPoint&        aOffset,
-                                             nsIView**       aView) const
-{
-  nsresult rv = NS_OK;
-
-  aOffset.MoveTo(0,0);
-
-  if (aView)
-    *aView = nsnull;
-
-  if (HasView()) {
-    nsIView *view = GetView();
-    nsIView *parentView = nsnull;
-    nsPoint offsetToParentView;
-    rv = GetOffsetFromView(offsetToParentView, &parentView);
-
-    if (NS_SUCCEEDED(rv)) {
-      nsPoint viewOffsetFromParent(0,0);
-      nsIView *pview = view;
-
-      nsIViewManager* vVM = view->GetViewManager();
-
-      while (pview && pview != parentView) {
-        viewOffsetFromParent += pview->GetPosition();
-
-        nsIView *tmpView = pview->GetParent();
-        if (tmpView && vVM != tmpView->GetViewManager()) {
-          // Don't cross ViewManager boundaries!
-          // XXXbz why not?
-          break;
-        }
-        pview = tmpView;
-      }
-
-#ifdef DEBUG_KIN
-      if (pview != parentView) {
-        // XXX: At this point, pview is probably null since it traversed
-        //      all the way up view's parent hierarchy and did not run across
-        //      parentView. In the future, instead of just returning an offset
-        //      of (0,0) for this case, we may want offsetToParentView to
-        //      include the offset from the parentView to the top of the
-        //      view hierarchy which would make both offsetToParentView and
-        //      viewOffsetFromParent, offsets to the global coordinate space.
-        //      We'd have to investigate any perf impact this would have before
-        //      checking in such a change, so for now we just return (0,0).
-        //      -- kin    
-        NS_WARNING("view is not a descendant of parentView!");
-      }
-#endif // DEBUG
-
-      if (pview == parentView)
-        aOffset = offsetToParentView - viewOffsetFromParent;
-
-      if (aView)
-        *aView = view;
-    }
-  }
-
-  return rv;
 }
 
 /* virtual */ PRBool
 nsIFrame::AreAncestorViewsVisible() const
 {
@@ -5636,16 +5557,23 @@ nsFrame::CorrectStyleParentFrame(nsIFram
     }
 
     parent = parent->GetParent();
   } while (parent);
 
-  // We can get here if aProspectiveParent is the scrollframe for a viewport
-  // and the kids are the anonymous scrollbars.
-  NS_ASSERTION(aProspectiveParent->GetStyleContext()->GetPseudoType() ==
-                 nsCSSAnonBoxes::viewportScroll,
+  if (aProspectiveParent->GetStyleContext()->GetPseudoType() ==
+      nsCSSAnonBoxes::viewportScroll) {
+    // aProspectiveParent is the scrollframe for a viewport
+    // and the kids are the anonymous scrollbars
+    return aProspectiveParent;
+  }
+
+  // We can get here if the root element is absolutely positioned.
+  // We can't test for this very accurately, but it can only happen
+  // when the prospective parent is a canvas frame.
+  NS_ASSERTION(aProspectiveParent->GetType() == nsGkAtoms::canvasFrame,
                "Should have found a parent before this");
-  return aProspectiveParent;
+  return nsnull;
 }
 
 nsresult
 nsFrame::DoGetParentStyleContextFrame(nsPresContext* aPresContext,
                                       nsIFrame**      aProviderFrame,
diff -r 63f6591b1238 layout/generic/nsFrame.h
--- a/layout/generic/nsFrame.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsFrame.h	Sat Sep 06 15:02:55 2008 +0300
@@ -226,11 +226,10 @@ public:
   virtual nsIFrame* GetPrevInFlowVirtual() const;
   NS_IMETHOD  SetPrevInFlow(nsIFrame*);
   virtual nsIFrame* GetNextInFlowVirtual() const;
   NS_IMETHOD  SetNextInFlow(nsIFrame*);
   NS_IMETHOD  GetOffsetFromView(nsPoint& aOffset, nsIView** aView) const;
-  NS_IMETHOD  GetOriginToViewOffset(nsPoint& aOffset, nsIView **aView) const;
   virtual nsIAtom* GetType() const;
   virtual PRBool IsContainingBlock() const;
 #ifdef NS_DEBUG
   NS_IMETHOD  List(FILE* out, PRInt32 aIndent) const;
   NS_IMETHOD  GetFrameName(nsAString& aResult) const;
diff -r 63f6591b1238 layout/generic/nsGfxScrollFrame.cpp
--- a/layout/generic/nsGfxScrollFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsGfxScrollFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -1791,21 +1791,25 @@ nsGfxScrollFrameInner::InternalScrollPos
   if (mHScrollbarBox)
     SetCoordAttribute(mHScrollbarBox->GetContent(), nsGkAtoms::curpos,
                       aX - GetScrolledRect(GetScrollPortSize()).x);
 }
 
+void
+nsGfxScrollFrameInner::ViewPositionDidChange(nsIScrollableView* aScrollable)
+{
+  // Update frame position to match view offsets
+  nsPoint childOffset = mScrolledFrame->GetView()->GetOffsetTo(mOuter->GetView());
+  mScrolledFrame->SetPosition(childOffset);
+}
+
 /**
  * Called whenever actual scrolling happens for any reason.
  */
 NS_IMETHODIMP
 nsGfxScrollFrameInner::ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY)
 {
   NS_ASSERTION(!mViewInitiatedScroll, "Cannot reenter ScrollPositionDidChange");
-
-  // Update frame position to match view offsets
-  nsPoint childOffset = mScrolledFrame->GetView()->GetOffsetTo(mOuter->GetView());
-  mScrolledFrame->SetPosition(childOffset);
 
   mViewInitiatedScroll = PR_TRUE;
   InternalScrollPositionDidChange(aX, aY);
   mViewInitiatedScroll = PR_FALSE;
   
diff -r 63f6591b1238 layout/generic/nsGfxScrollFrame.h
--- a/layout/generic/nsGfxScrollFrame.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsGfxScrollFrame.h	Sat Sep 06 15:02:55 2008 +0300
@@ -97,10 +97,11 @@ public:
   virtual void ReflowCallbackCanceled();
 
   // nsIScrollPositionListener
 
   NS_IMETHOD ScrollPositionWillChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
+  virtual void ViewPositionDidChange(nsIScrollableView* aScrollable);
   NS_IMETHOD ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
 
   // This gets called when the 'curpos' attribute on one of the scrollbars changes
   void CurPosAttributeChanged(nsIContent* aChild);
   void PostScrollEvent();
diff -r 63f6591b1238 layout/generic/nsHTMLFrame.cpp
--- a/layout/generic/nsHTMLFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsHTMLFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -52,10 +52,11 @@
 #include "nsIEventStateManager.h"
 #include "nsIDeviceContext.h"
 #include "nsIPresShell.h"
 #include "nsIScrollPositionListener.h"
 #include "nsDisplayList.h"
+#include "nsAbsoluteContainingBlock.h"
 
 // for focus
 #include "nsIDOMWindowInternal.h"
 #include "nsIFocusController.h"
 #include "nsIScrollableFrame.h"
@@ -64,10 +65,12 @@
 #include "nsICanvasFrame.h"
 
 #ifdef DEBUG_rods
 //#define DEBUG_CANVAS_FOCUS
 #endif
+
+#define CANVAS_ABS_POS_CHILD_LIST NS_CONTAINER_LIST_COUNT_INCL_OC
 
 // Interface IDs
 
 /**
  * Root frame class.
@@ -79,55 +82,82 @@ class CanvasFrame : public nsHTMLContain
 class CanvasFrame : public nsHTMLContainerFrame, 
                     public nsIScrollPositionListener, 
                     public nsICanvasFrame {
 public:
   CanvasFrame(nsStyleContext* aContext)
-  : nsHTMLContainerFrame(aContext), mDoPaintFocus(PR_FALSE) {}
+  : nsHTMLContainerFrame(aContext), mDoPaintFocus(PR_FALSE),
+    mAbsoluteContainer(nsGkAtoms::absoluteList) {}
 
    // nsISupports
   NS_IMETHOD QueryInterface(const nsIID& aIID, void** aInstancePtr);
 
   NS_IMETHOD Init(nsIContent*      aContent,
                   nsIFrame*        aParent,
                   nsIFrame*        aPrevInFlow);
   virtual void Destroy();
 
+  NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
+                                 nsIFrame*       aChildList);
   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList);
   NS_IMETHOD InsertFrames(nsIAtom*        aListName,
                           nsIFrame*       aPrevFrame,
                           nsIFrame*       aFrameList);
   NS_IMETHOD RemoveFrame(nsIAtom*        aListName,
                          nsIFrame*       aOldFrame);
 
+  virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const;
+  virtual nsIFrame* GetFirstChild(nsIAtom* aListName) const;
+
   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus);
   virtual PRBool IsContainingBlock() const { return PR_TRUE; }
+  virtual PRBool IsFrameOfType(PRUint32 aFlags) const
+  {
+    return nsHTMLContainerFrame::IsFrameOfType(aFlags &
+             ~(nsIFrame::eCanContainOverflowContainers));
+  }
 
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
 
   void PaintFocus(nsIRenderingContext& aRenderingContext, nsPoint aPt);
 
   // nsIScrollPositionListener
   NS_IMETHOD ScrollPositionWillChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
-	NS_IMETHOD ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
+  virtual void ViewPositionDidChange(nsIScrollableView* aScrollable) {}
+  NS_IMETHOD ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
 
   // nsICanvasFrame
   NS_IMETHOD SetHasFocus(PRBool aHasFocus);
 
   /**
    * Get the "type" of the frame
    *
    * @see nsGkAtoms::canvasFrame
    */
   virtual nsIAtom* GetType() const;
+
+  virtual nsresult StealFrame(nsPresContext* aPresContext,
+                              nsIFrame*      aChild,
+                              PRBool         aForceNormal)
+  {
+    NS_ASSERTION(!aForceNormal, "No-one should be passing this in here");
+
+    // CanvasFrame keeps overflow container continuations of its child
+    // frame in main child list
+    nsresult rv = nsContainerFrame::StealFrame(aPresContext, aChild, PR_TRUE);
+    if (NS_FAILED(rv)) {
+      rv = nsContainerFrame::StealFrame(aPresContext, aChild);
+    }
+    return rv;
+  }
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
   NS_IMETHOD GetContentForEvent(nsPresContext* aPresContext,
@@ -138,12 +168,13 @@ public:
 
 protected:
   virtual PRIntn GetSkipSides() const;
 
   // Data members
-  PRPackedBool             mDoPaintFocus;
-  nsCOMPtr<nsIViewManager> mViewManager;
+  PRPackedBool              mDoPaintFocus;
+  nsCOMPtr<nsIViewManager>  mViewManager;
+  nsAbsoluteContainingBlock mAbsoluteContainer;
 
 private:
   NS_IMETHOD_(nsrefcnt) AddRef() { return NS_OK; }
   NS_IMETHOD_(nsrefcnt) Release() { return NS_OK; }
 };
@@ -195,10 +226,12 @@ CanvasFrame::Init(nsIContent*      aCont
 }
 
 void
 CanvasFrame::Destroy()
 {
+  mAbsoluteContainer.DestroyFrames(this);
+
   nsIScrollableView* scrollingView = nsnull;
   mViewManager->GetRootScrollableView(&scrollingView);
   if (scrollingView) {
     scrollingView->RemoveScrollPositionListener(this);
   }
@@ -243,23 +276,35 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 CanvasFrame::SetHasFocus(PRBool aHasFocus)
 {
   if (mDoPaintFocus != aHasFocus) {
     mDoPaintFocus = aHasFocus;
-    nsIViewManager* vm = PresContext()->PresShell()->GetViewManager();
-    if (vm) {
-      vm->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
-    }
+    mViewManager->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
   }
   return NS_OK;
+}
+
+NS_IMETHODIMP
+CanvasFrame::SetInitialChildList(nsIAtom*        aListName,
+                                 nsIFrame*       aChildList)
+{
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
+
+  NS_ASSERTION(aListName || !aChildList || !aChildList->GetNextSibling(),
+               "Primary child list can have at most one frame in it");
+  return nsHTMLContainerFrame::SetInitialChildList(aListName, aChildList);
 }
 
 NS_IMETHODIMP
 CanvasFrame::AppendFrames(nsIAtom*        aListName,
                           nsIFrame*       aFrameList)
 {
   nsresult  rv;
+
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
 
   NS_ASSERTION(!aListName, "unexpected child list name");
   NS_PRECONDITION(mFrames.IsEmpty(), "already have a child frame");
   if (aListName) {
     // We only support unnamed principal child list
@@ -289,10 +334,13 @@ CanvasFrame::InsertFrames(nsIAtom*      
                           nsIFrame*       aPrevFrame,
                           nsIFrame*       aFrameList)
 {
   nsresult  rv;
 
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame, aFrameList);
+
   // Because we only support a single child frame inserting is the same
   // as appending
   NS_PRECONDITION(!aPrevFrame, "unexpected previous sibling frame");
   if (aPrevFrame) {
     rv = NS_ERROR_UNEXPECTED;
@@ -306,10 +354,13 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 CanvasFrame::RemoveFrame(nsIAtom*        aListName,
                          nsIFrame*       aOldFrame)
 {
   nsresult  rv;
+
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
 
   NS_ASSERTION(!aListName, "unexpected child list name");
   if (aListName) {
     // We only support the unnamed principal child list
     rv = NS_ERROR_INVALID_ARG;
@@ -330,10 +381,28 @@ CanvasFrame::RemoveFrame(nsIAtom*       
   } else {
     rv = NS_ERROR_FAILURE;
   }
 
   return rv;
+}
+
+nsIAtom*
+CanvasFrame::GetAdditionalChildListName(PRInt32 aIndex) const
+{
+  if (CANVAS_ABS_POS_CHILD_LIST == aIndex)
+    return nsGkAtoms::absoluteList;
+
+  return nsHTMLContainerFrame::GetAdditionalChildListName(aIndex);
+}
+
+nsIFrame*
+CanvasFrame::GetFirstChild(nsIAtom* aListName) const
+{
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.GetFirstChild();
+
+  return nsHTMLContainerFrame::GetFirstChild(aListName);
 }
 
 nsRect CanvasFrame::CanvasArea() const
 {
   nsRect result(GetOverflowRect());
@@ -416,10 +485,17 @@ CanvasFrame::BuildDisplayList(nsDisplayL
 CanvasFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists)
 {
   nsresult rv;
+
+  if (GetPrevInFlow()) {
+    DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
+  }
+
+  aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetFirstChild(), aDirtyRect);
+  
   // Force a background to be shown. We may have a background propagated to us,
   // in which case GetStyleBackground wouldn't have the right background
   // and the code in nsFrame::DisplayBorderBackgroundOutline might not give us
   // a background.
   // We don't have any border or outline, and our background draws over
@@ -429,12 +505,12 @@ CanvasFrame::BuildDisplayList(nsDisplayL
     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
            nsDisplayCanvasBackground(this));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  nsIFrame* kid = GetFirstChild(nsnull);
-  if (kid) {
+  nsIFrame* kid;
+  for (kid = GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {
     // Put our child into its own pseudo-stack.
     rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists,
                                   DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT);
     NS_ENSURE_SUCCESS(rv, rv);
   }
@@ -525,11 +601,11 @@ CanvasFrame::GetPrefWidth(nsIRenderingCo
     result = mFrames.FirstChild()->GetPrefWidth(aRenderingContext);
   return result;
 }
 
 NS_IMETHODIMP
-CanvasFrame::Reflow(nsPresContext*          aPresContext,
+CanvasFrame::Reflow(nsPresContext*           aPresContext,
                     nsHTMLReflowMetrics&     aDesiredSize,
                     const nsHTMLReflowState& aReflowState,
                     nsReflowStatus&          aStatus)
 {
   DO_GLOBAL_REFLOW_COUNT("CanvasFrame");
@@ -537,41 +613,88 @@ CanvasFrame::Reflow(nsPresContext*      
   NS_FRAME_TRACE_REFLOW_IN("CanvasFrame::Reflow");
 
   // Initialize OUT parameter
   aStatus = NS_FRAME_COMPLETE;
 
-  // Reflow our one and only child frame
+  CanvasFrame* prevCanvasFrame = static_cast<CanvasFrame*>
+                                               (GetPrevInFlow());
+  if (prevCanvasFrame) {
+    nsIFrame* overflow = prevCanvasFrame->GetOverflowFrames(aPresContext, PR_TRUE);
+    if (overflow) {
+      NS_ASSERTION(!overflow->GetNextSibling(),
+                   "must have doc root as canvas frame's only child");
+      nsHTMLContainerFrame::ReparentFrameView(aPresContext, overflow, prevCanvasFrame, this);
+      // Prepend overflow to the our child list. There may already be
+      // children placeholders for fixed-pos elements, which don't get
+      // reflowed but must not be lost until the canvas frame is destroyed.
+      mFrames.InsertFrames(this, nsnull, overflow);
+    }
+  }
+
+  // Reflow our one and only normal child frame. It's either the root
+  // element's frame or a placeholder for that frame, if the root element
+  // is abs-pos or fixed-pos. We may have additional children which
+  // are placeholders for continuations of fixed-pos content, but those
+  // don't need to be reflowed. The normal child is always comes before
+  // the fixed-pos placeholders, because we insert it at the start
+  // of the child list, above.
   nsHTMLReflowMetrics kidDesiredSize;
   if (mFrames.IsEmpty()) {
     // We have no child frame, so return an empty size
     aDesiredSize.width = aDesiredSize.height = 0;
   } else {
     nsIFrame* kidFrame = mFrames.FirstChild();
     PRBool kidDirty = (kidFrame->GetStateBits() & NS_FRAME_IS_DIRTY) != 0;
 
-    // We must specify an unconstrained available height, because constrained
-    // is only for when we're paginated...
     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, kidFrame,
                                      nsSize(aReflowState.availableWidth,
-                                            NS_UNCONSTRAINEDSIZE));
+                                            aReflowState.availableHeight));
 
     if (aReflowState.mFlags.mVResize &&
         (kidFrame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT)) {
       // Tell our kid it's being vertically resized too.  Bit of a
       // hack for framesets.
       kidReflowState.mFlags.mVResize = PR_TRUE;
     }
-    
+
+    nsPoint kidPt(kidReflowState.mComputedMargin.left,
+                  kidReflowState.mComputedMargin.top);
+    // Apply CSS relative positioning
+    const nsStyleDisplay* styleDisp = kidFrame->GetStyleDisplay();
+    if (NS_STYLE_POSITION_RELATIVE == styleDisp->mPosition) {
+      kidPt += nsPoint(kidReflowState.mComputedOffsets.left,
+                       kidReflowState.mComputedOffsets.top);
+    }
+
     // Reflow the frame
     ReflowChild(kidFrame, aPresContext, kidDesiredSize, kidReflowState,
-                kidReflowState.mComputedMargin.left, kidReflowState.mComputedMargin.top,
-                0, aStatus);
+                kidPt.x, kidPt.y, 0, aStatus);
 
     // Complete the reflow and position and size the child frame
     FinishReflowChild(kidFrame, aPresContext, &kidReflowState, kidDesiredSize,
-                      kidReflowState.mComputedMargin.left,
-                      kidReflowState.mComputedMargin.top, 0);
+                      kidPt.x, kidPt.y, 0);
+
+    if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
+      nsIFrame* nextFrame = kidFrame->GetNextInFlow();
+      NS_ASSERTION(nextFrame || aStatus & NS_FRAME_REFLOW_NEXTINFLOW,
+        "If it's incomplete and has no nif yet, it must flag a nif reflow.");
+      if (!nextFrame) {
+        nsresult rv = nsHTMLContainerFrame::CreateNextInFlow(aPresContext,
+                                              this, kidFrame, nextFrame);
+        NS_ENSURE_SUCCESS(rv, rv);
+        kidFrame->SetNextSibling(nextFrame->GetNextSibling());
+        nextFrame->SetNextSibling(nsnull);
+        SetOverflowFrames(aPresContext, nextFrame);
+        // Root overflow containers will be normal children of
+        // the canvas frame, but that's ok because there
+        // aren't any other frames we need to isolate them from
+        // during reflow.
+      }
+      if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aStatus)) {
+        nextFrame->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
+      }
+    }
 
     // If the child frame was just inserted, then we're responsible for making sure
     // it repaints
     if (kidDirty) {
       // But we have a new child, which will affect our background, so
@@ -583,23 +706,38 @@ CanvasFrame::Reflow(nsPresContext*      
       // could also include overflow to our top and left (out of the viewport)
       // which doesn't need to be painted.
       nsIFrame* viewport = PresContext()->GetPresShell()->GetRootFrame();
       viewport->Invalidate(nsRect(nsPoint(0, 0), viewport->GetSize()));
     }
-
+    
     // Return our desired size (which doesn't matter)
-    aDesiredSize.width = aReflowState.availableWidth;
-    aDesiredSize.height = kidDesiredSize.height +
-                          kidReflowState.mComputedMargin.TopBottom();
+    aDesiredSize.width = aReflowState.ComputedWidth();
+    aDesiredSize.height = aReflowState.ComputedHeight();
 
     aDesiredSize.mOverflowArea.UnionRect(
       nsRect(0, 0, aDesiredSize.width, aDesiredSize.height),
-      kidDesiredSize.mOverflowArea +
-        nsPoint(kidReflowState.mComputedMargin.left,
-                kidReflowState.mComputedMargin.top));
-    FinishAndStoreOverflow(&aDesiredSize);
+      kidDesiredSize.mOverflowArea + kidPt);
+
+    if (mAbsoluteContainer.HasAbsoluteFrames()) {
+      PRBool widthChanged = aDesiredSize.width != mRect.width;
+      PRBool heightChanged = aDesiredSize.height != mRect.height;
+      nsRect absPosBounds;
+      mAbsoluteContainer.Reflow(this, aPresContext, aReflowState, aStatus,
+                                aDesiredSize.width, aDesiredSize.height,
+                                PR_TRUE, widthChanged, heightChanged,
+                                &absPosBounds);
+      aDesiredSize.mOverflowArea.UnionRect(aDesiredSize.mOverflowArea, absPosBounds);
+    }
   }
+
+  if (prevCanvasFrame) {
+    ReflowOverflowContainerChildren(aPresContext, aReflowState,
+                                    aDesiredSize.mOverflowArea, 0,
+                                    aStatus);
+  }
+
+  FinishAndStoreOverflow(&aDesiredSize);
 
   NS_FRAME_TRACE_REFLOW_OUT("CanvasFrame::Reflow", aStatus);
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
   return NS_OK;
 }
diff -r 63f6591b1238 layout/generic/nsHTMLParts.h
--- a/layout/generic/nsHTMLParts.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsHTMLParts.h	Sat Sep 06 15:02:55 2008 +0300
@@ -111,35 +111,28 @@ inline nsIFrame*
 inline nsIFrame*
 NS_NewTableCellInnerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   return NS_NewBlockFrame(aPresShell, aContext);
 }
 
-// This type of AreaFrame is the document root, a margin root, and the
-// initial containing block for absolutely positioned elements
+// This type of BlockFrame is a margin root, but does not shrink wrap
 inline nsIFrame*
-NS_NewDocumentElementFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
+NS_NewAbsoluteItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
+  return NS_NewBlockFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
-// This type of AreaFrame is a margin root, but does not shrink wrap
-inline nsIFrame*
-NS_NewAbsoluteItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
-}
-
-// This type of AreaFrame shrink wraps
+// This type of BlockFrame shrink wraps
 inline nsIFrame*
 NS_NewFloatingItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
-  return NS_NewAreaFrame(aPresShell, aContext,
+  return NS_NewBlockFrame(aPresShell, aContext,
     NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
 }
 
-// This type of AreaFrame doesn't use its own space manager and
+// This type of BlockFrame doesn't use its own space manager and
 // doesn't shrink wrap.
 inline nsIFrame*
 NS_NewRelativeItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags) {
-  return NS_NewAreaFrame(aPresShell, aContext, aFlags);
+  return NS_NewBlockFrame(aPresShell, aContext, aFlags);
 }
 
 nsIFrame*
 NS_NewBRFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 
diff -r 63f6591b1238 layout/generic/nsHTMLReflowState.cpp
--- a/layout/generic/nsHTMLReflowState.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsHTMLReflowState.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -1529,29 +1529,11 @@ nsHTMLReflowState::ComputeContainingBloc
                    "Negative containing block height!");
     } else {
       // If the ancestor is block-level, the containing block is formed by the
       // padding edge of the ancestor
       aContainingBlockWidth += aContainingBlockRS->mComputedPadding.LeftRight();
-
-      // If the containing block is the initial containing block and it has a
-      // height that depends on its content, then use the viewport height instead.
-      // This gives us a reasonable value against which to compute percentage
-      // based heights and to do bottom relative positioning
-      if ((NS_AUTOHEIGHT == aContainingBlockHeight) &&
-          nsLayoutUtils::IsInitialContainingBlock(aContainingBlockRS->frame)) {
-
-        // Use the viewport height as the containing block height
-        const nsHTMLReflowState* rs = aContainingBlockRS->parentReflowState;
-        while (rs) {
-          aContainingBlockHeight = rs->mComputedHeight;
-          rs = rs->parentReflowState;
-        }
-
-      } else {
-        aContainingBlockHeight +=
-          aContainingBlockRS->mComputedPadding.TopBottom();
-      }
+      aContainingBlockHeight += aContainingBlockRS->mComputedPadding.TopBottom();
     }
   } else {
     // an element in quirks mode gets a containing block based on looking for a
     // parent with a non-auto height if the element has a percent height
     if (NS_AUTOHEIGHT == aContainingBlockHeight) {
diff -r 63f6591b1238 layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsIFrame.h	Sat Sep 06 15:02:55 2008 +0300
@@ -102,14 +102,14 @@ struct nsMargin;
 struct nsMargin;
 
 typedef class nsIFrame nsIBox;
 
 // IID for the nsIFrame interface
-// 04a7dee5-3435-47dc-bd42-a36c0f66a42c
-  #define NS_IFRAME_IID \
-{ 0x04a7dee5, 0x3435, 0x47dc, \
-  { 0xbd, 0x42, 0xa3, 0x6c, 0x0f, 0x66, 0xa4, 0x2c } }
+// 98a0c040-09cf-408b-b55f-321b4f8d9d67
+#define NS_IFRAME_IID \
+    { 0x98a0c040, 0x09cf, 0x408b, \
+      { 0xb5, 0x5f, 0x32, 0x1b, 0x4f, 0x8d, 0x9d, 0x67 } }
 
 /**
  * Indication of how the frame can be split. This is used when doing runaround
  * of floats, and when pulling up child frames from a next-in-flow.
  *
@@ -1528,21 +1528,10 @@ public:
    */
   NS_IMETHOD  GetOffsetFromView(nsPoint&  aOffset,
                                 nsIView** aView) const = 0;
 
   /**
-   * Returns the offset from this frame's upper left corner to the upper
-   * left corner of the view returned by a call to GetView(). aOffset
-   * will contain the offset to the view or (0,0) if the frame has no
-   * view. aView will contain a pointer to the view returned by GetView().
-   * aView is optional, that is, you may pass null if you are not interested
-   * in getting a pointer to the view.
-   */
-  NS_IMETHOD  GetOriginToViewOffset(nsPoint&        aOffset,
-                                    nsIView**       aView) const = 0;
-
-  /**
    * Returns true if and only if all views, from |GetClosestView| up to
    * the top of the view hierarchy are visible.
    */
   virtual PRBool AreAncestorViewsVisible() const;
 
diff -r 63f6591b1238 layout/generic/nsInlineFrame.cpp
--- a/layout/generic/nsInlineFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsInlineFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -1071,15 +1071,12 @@ nsPositionedInlineFrame::GetAdditionalCh
 }
 
 nsIFrame*
 nsPositionedInlineFrame::GetFirstChild(nsIAtom* aListName) const
 {
-  if (nsGkAtoms::absoluteList == aListName) {
-    nsIFrame* result = nsnull;
-    mAbsoluteContainer.FirstChild(this, aListName, &result);
-    return result;
-  }
+  if (nsGkAtoms::absoluteList == aListName)
+    return mAbsoluteContainer.GetFirstChild();
 
   return nsInlineFrame::GetFirstChild(aListName);
 }
 
 nsIAtom*
diff -r 63f6591b1238 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsObjectFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -384,10 +384,11 @@ public:
   void CancelTimer();
   void StartTimer(unsigned int aDelay);
 
   // nsIScrollPositionListener interface
   NS_IMETHOD ScrollPositionWillChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
+  virtual void ViewPositionDidChange(nsIScrollableView* aScrollable) {}
   NS_IMETHOD ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
 
   //locals
 
   nsresult Init(nsPresContext* aPresContext, nsObjectFrame* aFrame,
diff -r 63f6591b1238 layout/generic/nsPageContentFrame.cpp
--- a/layout/generic/nsPageContentFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsPageContentFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -67,59 +67,10 @@ nsPageContentFrame::ComputeSize(nsIRende
                    ? NS_UNCONSTRAINEDSIZE
                    : (mPD->mReflowSize.height - mPD->mReflowMargin.TopBottom());
   return nsSize(aAvailableWidth, height);
 }
 
-/**
- * Returns true if aFrame is a placeholder for one of our fixed frames.
- */
-inline PRBool
-nsPageContentFrame::IsFixedPlaceholder(nsIFrame* aFrame)
-{
-  if (!aFrame || nsGkAtoms::placeholderFrame != aFrame->GetType())
-    return PR_FALSE;
-
-  return static_cast<nsPlaceholderFrame*>(aFrame)->GetOutOfFlowFrame()
-           ->GetParent() == this;
-}
-
-/**
- * Steals replicated fixed placeholder frames from aDocRoot so they don't
- * get in the way of reflow.
- */
-inline nsFrameList
-nsPageContentFrame::StealFixedPlaceholders(nsIFrame* aDocRoot)
-{
-  nsPresContext* presContext = PresContext();
-  nsFrameList list;
-  if (GetPrevInFlow()) {
-    for (nsIFrame* f = aDocRoot->GetFirstChild(nsnull);
-        IsFixedPlaceholder(f); f = aDocRoot->GetFirstChild(nsnull)) {
-      nsresult rv = static_cast<nsContainerFrame*>(aDocRoot)
-                      ->StealFrame(presContext, f);
-      NS_ENSURE_SUCCESS(rv, list);
-      list.AppendFrame(nsnull, f);
-    }
-  }
-  return list;
-}
-
-/**
- * Restores stolen replicated fixed placeholder frames to aDocRoot.
- */
-static inline nsresult
-ReplaceFixedPlaceholders(nsIFrame*    aDocRoot,
-                         nsFrameList& aPlaceholderList)
-{
-  nsresult rv = NS_OK;
-  if (aPlaceholderList.NotEmpty()) {
-    rv = static_cast<nsContainerFrame*>(aDocRoot)
-           ->AddFrames(aPlaceholderList.FirstChild(), nsnull);
-  }
-  return rv;
-}
-
 NS_IMETHODIMP
 nsPageContentFrame::Reflow(nsPresContext*           aPresContext,
                            nsHTMLReflowMetrics&     aDesiredSize,
                            const nsHTMLReflowState& aReflowState,
                            nsReflowStatus&          aStatus)
@@ -127,70 +78,30 @@ nsPageContentFrame::Reflow(nsPresContext
   DO_GLOBAL_REFLOW_COUNT("nsPageContentFrame");
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   aStatus = NS_FRAME_COMPLETE;  // initialize out parameter
   nsresult rv = NS_OK;
 
-  // A PageContentFrame must always have one child: the doc root element's frame.
-  // We only need to get overflow frames if we don't already have that child;
-  // Also we need to avoid repeating the call to ReplicateFixedFrames.
-  nsPageContentFrame* prevPageContentFrame = static_cast<nsPageContentFrame*>
-                                               (GetPrevInFlow());
-  if (mFrames.IsEmpty() && prevPageContentFrame) {
-    // Pull the doc root frame's continuation and copy fixed frames.
-    nsIFrame* overflow = prevPageContentFrame->GetOverflowFrames(aPresContext, PR_TRUE);
-    NS_ASSERTION(overflow && !overflow->GetNextSibling(),
-                 "must have doc root as pageContentFrame's only child");
-    nsHTMLContainerFrame::ReparentFrameView(aPresContext, overflow, prevPageContentFrame, this);
-    // Prepend overflow to the page content frame. There may already be
-    // children placeholders which don't get reflowed but must not be
-    // lost until the page content frame is destroyed.
-    mFrames.InsertFrames(this, nsnull, overflow);
+  if (GetPrevInFlow() && (GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
     nsresult rv = aPresContext->PresShell()->FrameConstructor()
                     ->ReplicateFixedFrames(this);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
+  // A PageContentFrame must always have one child: the canvas frame.
   // Resize our frame allowing it only to be as big as we are
   // XXX Pay attention to the page's border and padding...
   if (mFrames.NotEmpty()) {
     nsIFrame* frame = mFrames.FirstChild();
     nsSize  maxSize(aReflowState.availableWidth, aReflowState.availableHeight);
     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, frame, maxSize);
+    kidReflowState.SetComputedHeight(aReflowState.availableHeight);
 
     mPD->mPageContentSize  = aReflowState.availableWidth;
-
-    // Get replicated fixed frames' placeholders out of the way
-    nsFrameList stolenPlaceholders = StealFixedPlaceholders(frame);
 
     // Reflow the page content area
     rv = ReflowChild(frame, aPresContext, aDesiredSize, kidReflowState, 0, 0, 0, aStatus);
     NS_ENSURE_SUCCESS(rv, rv);
-
-    // Put removed fixed placeholders back
-    rv = ReplaceFixedPlaceholders(frame, stolenPlaceholders);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
-      nsIFrame* nextFrame = frame->GetNextInFlow();
-      NS_ASSERTION(nextFrame || aStatus & NS_FRAME_REFLOW_NEXTINFLOW,
-        "If it's incomplete and has no nif yet, it must flag a nif reflow.");
-      if (!nextFrame) {
-        nsresult rv = nsHTMLContainerFrame::CreateNextInFlow(aPresContext,
-                                              this, frame, nextFrame);
-        NS_ENSURE_SUCCESS(rv, rv);
-        frame->SetNextSibling(nextFrame->GetNextSibling());
-        nextFrame->SetNextSibling(nsnull);
-        SetOverflowFrames(aPresContext, nextFrame);
-        // Root overflow containers will be normal children of
-        // the pageContentFrame, but that's ok because there
-        // aren't any other frames we need to isolate them from
-        // during reflow.
-      }
-      if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aStatus)) {
-        nextFrame->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
-      }
-    }
 
     // The document element's background should cover the entire canvas, so
     // take into account the combined area and any space taken up by
     // absolutely positioned elements
     nsMargin padding(0,0,0,0);
diff -r 63f6591b1238 layout/generic/nsPageContentFrame.h
--- a/layout/generic/nsPageContentFrame.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsPageContentFrame.h	Sat Sep 06 15:02:55 2008 +0300
@@ -81,13 +81,9 @@ public:
 
 protected:
   nsPageContentFrame(nsStyleContext* aContext) : ViewportFrame(aContext) {}
 
   nsSharedPageData*         mPD;
-
-private:
-  PRBool IsFixedPlaceholder(nsIFrame* aFrame);
-  nsFrameList StealFixedPlaceholders(nsIFrame* aDocRoot);
 };
 
 #endif /* nsPageContentFrame_h___ */
 
diff -r 63f6591b1238 layout/generic/nsViewportFrame.cpp
--- a/layout/generic/nsViewportFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/generic/nsViewportFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -177,15 +177,12 @@ ViewportFrame::GetAdditionalChildListNam
 }
 
 nsIFrame*
 ViewportFrame::GetFirstChild(nsIAtom* aListName) const
 {
-  if (nsGkAtoms::fixedList == aListName) {
-    nsIFrame* result = nsnull;
-    mFixedContainer.FirstChild(this, aListName, &result);
-    return result;
-  }
+  if (nsGkAtoms::fixedList == aListName)
+    return mFixedContainer.GetFirstChild();
 
   return nsContainerFrame::GetFirstChild(aListName);
 }
 
 /* virtual */ nscoord
@@ -307,12 +304,11 @@ ViewportFrame::Reflow(nsPresContext*    
   // to reflect the available space for the fixed items
   nsHTMLReflowState reflowState(aReflowState);
   nsPoint offset = AdjustReflowStateForScrollbars(&reflowState);
   
 #ifdef DEBUG
-  nsIFrame* f;
-  mFixedContainer.FirstChild(this, nsGkAtoms::fixedList, &f);
+  nsIFrame* f = mFixedContainer.GetFirstChild();
   NS_ASSERTION(!f || (offset.x == 0 && offset.y == 0),
                "We don't handle correct positioning of fixed frames with "
                "scrollbars in odd positions");
 #endif
 
diff -r 63f6591b1238 layout/reftests/bugs/200774-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/200774-1.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" 
+   "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" class="reftest-print">
+
+<head>
+<title>Fixed DIV, Multipe Page Testcase</title>
+<style type="text/css">
+div.header { position: fixed;
+	width: 100%;
+	height: 1.5em;
+	top: 0;
+	font-style: italic;
+	background-color: white;
+	color: black }
+</style>
+</head>
+
+<body>
+
+<div class="header">I stay on the top of the web page and each printed page.</div>
+
+<h1>Fixed DIV, multiple page testcase</h1>
+
+<hr />
+
+<p>Maybe related to bug 163800?</p>
+
+<p>Similar to 193686 and 197808, but there are <i>no</i> forms involved in this crash.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+<p>Repeating text, to get  us onto the next page.</p>
+
+</body>
+</html>
\ No newline at end of file
diff -r 63f6591b1238 layout/reftests/bugs/243519-1-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-1-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,20 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<style>
+body { margin:0; }
+.pos { position:absolute; width:100px; height:100px; }
+</style>
+</head>
+<body>
+<div style="height:10000px; margin:0; margin:10px; border:20px solid black; padding:30px;"></div>
+<script>
+window.scrollTo(0,50);
+</script>
+<div class="pos" style="top:0; left:60px; background:yellow;"></div>
+<div class="pos" style="right:0; top:60px; background:orange;"></div>
+<div class="pos" style="bottom:0; left:60px; background:brown;"></div>
+<div class="pos" style="left:0; top:60px; background:pink;"></div>
+</div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-1.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,19 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<style>
+html { margin:10px; border:20px solid black; padding:30px; }
+body { height:10000px; margin:0; }
+div { position:absolute; width:100px; height:100px; }
+</style>
+</head>
+<body>
+<script>
+window.scrollTo(0,50);
+</script>
+<div style="top:0; background:yellow;"></div>
+<div style="right:0; background:orange;"></div>
+<div style="bottom:0; background:brown;"></div>
+<div style="left:0; background:pink;"></div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-2-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-2-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html>
+<body style="-moz-column-count:2; margin:0;">
+Hello<br>
+Kitty
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-2.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html style="-moz-column-count:2;">
+<body style="margin:0;">
+Hello<br>
+Kitty
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-3-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-3-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,17 @@
+<!DOCTYPE HTML>
+<html class="reftest-print">
+<head>
+<style>
+body { margin:0; }
+.pos { position:absolute; width:100px; height:100px; }
+</style>
+</head>
+<body>
+<div class="pos" style="top:0; left:60px; border:10px solid yellow;"></div>
+<div class="pos" style="right:0; top:60px; border:10px solid orange;"></div>
+<div class="pos" style="bottom:0; left:60px; border:10px solid brown;"></div>
+<div class="pos" style="left:0; top:60px; border:10px solid pink;"></div>
+<div style="margin:10px; border:20px solid black; padding:30px;"></div>
+</div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-3.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-3.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,16 @@
+<!DOCTYPE HTML>
+<html class="reftest-print">
+<head>
+<style>
+html { margin:10px; border:20px solid black; padding:30px; }
+body { margin:0; }
+div { position:absolute; width:100px; height:100px; }
+</style>
+</head>
+<body>
+<div style="top:0; border:10px solid yellow;"></div>
+<div style="right:0; border:10px solid orange;"></div>
+<div style="bottom:0; border:10px solid brown;"></div>
+<div style="left:0; border:10px solid pink;"></div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-4-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-4-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,7 @@
+<!DOCTYPE HTML>
+<html style="background:yellow;">
+<body>
+<div style="position:absolute; top:100px; left:100px; width:100px; height:100px;
+            border:10px solid black;"></div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-4a.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-4a.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:absolute; left:100px; top:100px; width:100px; height:100px;
+             background:yellow; border:10px solid black;">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-4b.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-4b.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:fixed; left:100px; top:100px; width:100px; height:100px;
+             background:yellow; border:10px solid black;">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-4c.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-4c.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:absolute; left:100px; top:100px; width:100px; height:100px;
+             background:yellow; border:10px solid black; display:table;">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-4d.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-4d.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:fixed; left:100px; top:100px; width:100px; height:100px;
+             background:yellow; border:10px solid black; display:table">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-4e.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-4e.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="display:table">
+<body style="position:absolute; left:100px; top:100px; width:100px; height:100px; border:10px solid black;
+             background:yellow; margin:0">
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-4f.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-4f.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="display:table">
+<body style="position:fixed; left:100px; top:100px; width:100px; height:100px; border:10px solid black;
+             background:yellow; margin:0">
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-5-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-5-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="background:yellow;">
+<body style="margin:0">
+<div style="border:10px solid black; width:100px; height:100px;"></div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-5a.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-5a.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:absolute; width:100px; height:100px;
+             background:yellow; border:10px solid black;">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-5b.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-5b.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:absolute; width:100px; height:100px; display:table;
+             background:yellow; border:10px solid black;">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-5c.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-5c.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:fixed; width:100px; height:100px;
+             background:yellow; border:10px solid black;">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-5d.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-5d.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html style="position:fixed; width:100px; height:100px; display:table;
+             background:yellow; border:10px solid black;">
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-6-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-6-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,12 @@
+<!DOCTYPE HTML>
+<html class="reftest-print">
+<head>
+<style>
+div { margin:10px; border:20px solid black; padding:30px; height:4in; position:absolute; }
+body { margin:0; }
+</style>
+</head>
+<body>
+<div></div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-6.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-6.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,11 @@
+<!DOCTYPE HTML>
+<html class="reftest-print">
+<head>
+<style>
+html { margin:10px; border:20px solid black; padding:30px; height:4in; position:absolute; }
+body { margin:0; }
+</style>
+</head>
+<body>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-7-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-7-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,8 @@
+<!DOCTYPE HTML>
+<html>
+<body style="margin:0;">
+<div style="position:relative; top:100px; left:100px; height:100px; border:10px solid black;">
+  <div style="position:absolute; bottom:0; height:30px; border:10px solid orange;">
+  </div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-7.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-7.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,5 @@
+<!DOCTYPE HTML>
+<html style="position:relative; top:100px; left:100px; height:100px; border:10px solid black;">
+<body style="position:absolute; margin:0; bottom:0; height:30px; border:10px solid orange;">
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-8-ref.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-8-ref.svg	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg">
+  <rect fill="lime" x="100" y="100" width="100" height="100"/>
+</svg>
diff -r 63f6591b1238 layout/reftests/bugs/243519-8.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-8.svg	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,3 @@
+<svg xmlns="http://www.w3.org/2000/svg" style="position:absolute; left:100px; top:100px; overflow:hidden;">
+  <rect fill="lime" width="100" height="100"/>
+</svg>
diff -r 63f6591b1238 layout/reftests/bugs/243519-9-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-9-ref.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,6 @@
+<!DOCTYPE HTML>
+<html>
+<body style="margin:0">
+<div style="position:fixed; width:50%; height:50%; left:50px; top:50px; border:10px solid black;"></div>
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-9a.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-9a.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,3 @@
+<!DOCTYPE HTML>
+<html style="width:50%; height:50%; margin:50px; border:10px solid black;">
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-9b.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-9b.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,3 @@
+<!DOCTYPE HTML>
+<html style="position:absolute; left:50px; top:50px; width:50%; height:50%; border:10px solid black;">
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-9c.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-9c.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,2 @@
+<html style="width:50%; height:50%; margin:50px; border:10px solid black;">
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-9d.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-9d.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,2 @@
+<html style="position:absolute; left:50px; top:50px; width:50%; height:50%; border:10px solid black;">
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/243519-9e.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/243519-9e.html	Sat Sep 06 15:02:55 2008 +0300
@@ -0,0 +1,5 @@
+<!DOCTYPE HTML>
+<html>
+<body style="position:absolute; width:50%; height:50%; top:50px; left:50px; margin:0; border:10px solid black;">
+</body>
+</html>
diff -r 63f6591b1238 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/reftests/bugs/reftest.list	Sat Sep 06 15:02:55 2008 +0300
@@ -123,10 +123,11 @@ fails == 25888-3r.html 25888-3r-ref.html
 == 169749-1.html 169749-1-ref.html
 == 172073-1.html 172073-1-ref.html
 == 180085-1.html 180085-1-ref.html
 == 180085-2.html 180085-2-ref.html
 == 185388-1.html 185388-1-ref.html
+!= 200774-1.html about:blank # really a crashtest
 == 201215-1.html 201215-1-ref.html
 == 201293-1a.html 201293-1-ref.html
 == 201293-1b.html 201293-1-ref.html
 == 201293-1c.html 201293-1-ref.html
 == 201293-1d.html 201293-1-ref.html
@@ -164,10 +165,31 @@ fails == 25888-3r.html 25888-3r-ref.html
 == 235593-1.html 235593-1-ref.html
 == 236539-1.html 236539-1-ref.html
 == 240470-1.html 240470-1-ref.html
 == 243266-1.html 243266-1-ref.html
 == 243302-1.html 243302-1-ref.html
+== 243519-1.html 243519-1-ref.html
+== 243519-2.html 243519-2-ref.html
+== 243519-3.html 243519-3-ref.html
+== 243519-4a.html 243519-4-ref.html
+== 243519-4b.html 243519-4-ref.html
+== 243519-4c.html 243519-4-ref.html
+== 243519-4d.html 243519-4-ref.html
+== 243519-4e.html 243519-4-ref.html
+== 243519-4f.html 243519-4-ref.html
+== 243519-5a.html 243519-5-ref.html
+== 243519-5b.html 243519-5-ref.html
+== 243519-5c.html 243519-5-ref.html
+== 243519-5d.html 243519-5-ref.html
+== 243519-6.html 243519-6-ref.html
+== 243519-7.html 243519-7-ref.html
+== 243519-8.svg 243519-8-ref.svg
+== 243519-9a.html 243519-9-ref.html
+== 243519-9b.html 243519-9-ref.html
+== 243519-9c.html 243519-9-ref.html
+== 243519-9d.html 243519-9-ref.html
+== 243519-9e.html 243519-9-ref.html
 == 244135-1.html 244135-1-ref.html
 == 244135-2.html 244135-2-ref.html
 == 244932-1.html 244932-1-ref.html
 == 249982-1.html 249982-1-ref.html
 == 253701-1.html 253701-1-ref.html
diff -r 63f6591b1238 layout/xul/base/src/nsBox.cpp
--- a/layout/xul/base/src/nsBox.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/xul/base/src/nsBox.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -272,11 +272,11 @@ nsBox::SetBounds(nsBoxLayoutState& aStat
 
     PRUint32 stateFlags = aState.LayoutFlags();
 
     flags |= stateFlags;
 
-    if (flags & NS_FRAME_NO_MOVE_FRAME)
+    if ((flags & NS_FRAME_NO_MOVE_FRAME) == NS_FRAME_NO_MOVE_FRAME)
       SetSize(nsSize(aRect.width, aRect.height));
     else
       SetRect(aRect);
 
     // Nuke the overflow area. The caller is responsible for restoring
diff -r 63f6591b1238 layout/xul/base/src/nsMenuPopupFrame.cpp
--- a/layout/xul/base/src/nsMenuPopupFrame.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/layout/xul/base/src/nsMenuPopupFrame.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -883,10 +883,13 @@ nsMenuPopupFrame::SetPopupPosition(nsIFr
 
   PRBool sizedToPopup = PR_FALSE;
 
   nsPresContext* presContext = PresContext();
   nsIFrame* rootFrame = presContext->PresShell()->FrameManager()->GetRootFrame();
+  NS_ASSERTION(rootFrame->GetView() && GetView() &&
+               rootFrame->GetView() == GetView()->GetParent(),
+               "rootFrame's view is not our view's parent???");
 
   // if the frame is not specified, use the anchor node passed to ShowPopup. If
   // that wasn't specified either, use the root frame. Note that mAnchorContent
   // might be a different document so its presshell must be used.
   if (!aAnchorFrame) {
@@ -1235,15 +1238,13 @@ nsMenuPopupFrame::SetPopupPosition(nsIFr
   }
 
   presContext->GetViewManager()->MoveViewTo(GetView(), xpos, ypos); 
 
   // Now that we've positioned the view, sync up the frame's origin.
-  nsPoint frameOrigin = GetPosition();
-  nsPoint offsetToView;
-  GetOriginToViewOffset(offsetToView, nsnull);
-  frameOrigin -= offsetToView;
-  nsBoxFrame::SetPosition(frameOrigin);
+  // Note that (xpos,ypos) is the position relative to rootFrame.
+  nsBoxFrame::SetPosition(nsPoint(xpos, ypos) -
+                          GetParent()->GetOffsetTo(rootFrame));
 
   if (sizedToPopup) {
     nsBoxLayoutState state(PresContext());
     SetBounds(state, nsRect(mRect.x, mRect.y, parentSize.width, mRect.height));
   }
diff -r 63f6591b1238 view/public/nsIScrollPositionListener.h
--- a/view/public/nsIScrollPositionListener.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/view/public/nsIScrollPositionListener.h	Sat Sep 06 15:02:55 2008 +0300
@@ -45,23 +45,26 @@
 
 // forward declarations
 class nsIScrollableView;
 
 // IID for the nsIScrollPositionListener interface
-// {f8dfc500-6ad1-11d3-8360-a3f373ff79fc}
+// {98a0c040-09cf-408b-b55f-321b4f8d9d67}
+
 #define NS_ISCROLLPOSITIONLISTENER_IID \
-{ 0xf8dfc500, 0x6ad1, 0x11d3, { 0x83, 0x60, 0xa3, 0xf3, 0x73, 0xff, 0x79, 0xfc } }
+    { 0x98a0c040, 0x09cf, 0x408b, \
+      { 0xb5, 0x5f, 0x32, 0x1b, 0x4f, 0x8d, 0x9d, 0x67 } }
 
 /**
  * Provides a way for a client of an nsIScrollableView to learn about scroll position
  * changes.
  */
 class nsIScrollPositionListener : public nsISupports {
 public:
 	NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISCROLLPOSITIONLISTENER_IID)
 
 	NS_IMETHOD ScrollPositionWillChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY) = 0;
+	virtual void ViewPositionDidChange(nsIScrollableView* aScrollable) = 0;
 	NS_IMETHOD ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIScrollPositionListener,
                               NS_ISCROLLPOSITIONLISTENER_IID)
diff -r 63f6591b1238 view/src/nsScrollPortView.cpp
--- a/view/src/nsScrollPortView.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/view/src/nsScrollPortView.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -544,22 +544,22 @@ void nsScrollPortView::Scroll(nsView *aS
       // repainted back to the right rendering.
       AdjustChildWidgets(aScrolledView, offsetToWidget, aP2A, PR_TRUE);
       // If we don't have a scroll widget then we must just update.
       // We should call this after fixing up the widget positions to be
       // consistent with the view hierarchy.
-      mViewManager->UpdateView(this, 0);
+      mViewManager->UpdateView(this, NS_VMREFRESH_DEFERRED);
     } else if (!canBitBlit) {
       // We can't blit for some reason.
       // Just update the view and adjust widgets
       // Recall that our widget's origin is at our bounds' top-left
       nsRect bounds(GetBounds());
       nsPoint topLeft(bounds.x, bounds.y);
       AdjustChildWidgets(aScrolledView,
                          GetPosition() - topLeft, aP2A, PR_FALSE);
       // We should call this after fixing up the widget positions to be
       // consistent with the view hierarchy.
-      mViewManager->UpdateView(this, 0);
+      mViewManager->UpdateView(this, NS_VMREFRESH_DEFERRED);
     } else { // if we can blit and have a scrollwidget then scroll.
       nsRect* toScrollPtr = nsnull;
 
 #ifdef XP_WIN
       nsRect toScroll;
@@ -645,10 +645,22 @@ NS_IMETHODIMP nsScrollPortView::ScrollTo
   // move the scrolled view to the new location
   // Note that child widgets may be scrolled by the native widget scrolling,
   // so don't update their positions
   scrolledView->SetPositionIgnoringChildWidgets(-aX, -aY);
       
+  // notify the listeners.
+  if (nsnull != mListeners) {
+    if (NS_SUCCEEDED(mListeners->Count(&listenerCount))) {
+      for (PRUint32 i = 0; i < listenerCount; i++) {
+        if (NS_SUCCEEDED(mListeners->QueryElementAt(i, kScrollPositionListenerIID, (void**)&listener))) {
+          listener->ViewPositionDidChange(this);
+          NS_RELEASE(listener);
+        }
+      }
+    }
+  }
+
   nsPoint twipsDelta(aX - mOffsetX, aY - mOffsetY);
 
   // store the new position
   mOffsetX = aX;
   mOffsetY = aY;
diff -r 63f6591b1238 view/src/nsViewManager.cpp
--- a/view/src/nsViewManager.cpp	Sat Sep 06 05:42:39 2008 +0200
+++ b/view/src/nsViewManager.cpp	Sat Sep 06 15:02:55 2008 +0300
@@ -1683,10 +1683,15 @@ NS_IMETHODIMP nsViewManager::ResizeView(
   // because layout will change it back again if necessary.
 
   return NS_OK;
 }
 
+static double GetArea(const nsRect& aRect)
+{
+  return double(aRect.width)*double(aRect.height);
+}
+
 PRBool nsViewManager::CanScrollWithBitBlt(nsView* aView, nsPoint aDelta,
                                           nsRegion* aUpdateRegion)
 {
   NS_ASSERTION(!IsPainting(),
                "View manager shouldn't be scrolling during a paint");
@@ -1709,11 +1714,11 @@ PRBool nsViewManager::CanScrollWithBitBl
   aUpdateRegion->MoveBy(-displayOffset);
 
 #if defined(MOZ_WIDGET_GTK2) || defined(XP_OS2)
   return aUpdateRegion->IsEmpty();
 #else
-  return PR_TRUE;
+  return GetArea(aUpdateRegion->GetBounds()) < GetArea(parentBounds)/2;
 #endif
 }
 
 NS_IMETHODIMP nsViewManager::SetViewFloating(nsIView *aView, PRBool aFloating)
 {
diff -r 63f6591b1238 view/src/nsViewManager.h
--- a/view/src/nsViewManager.h	Sat Sep 06 05:42:39 2008 +0200
+++ b/view/src/nsViewManager.h	Sat Sep 06 15:02:55 2008 +0300
@@ -393,11 +393,12 @@ public: // NOT in nsIViewManager, so pri
    * 14 although the bug report did not mention the problem.)
    */
   nsresult WillBitBlit(nsView* aView, nsPoint aScrollAmount);
   
   /**
-   * Called to inform the view manager that a view has scrolled.
+   * Called to inform the view manager that a view has scrolled via a
+   * bitblit.
    * The view manager will invalidate any widgets which may need
    * to be rerendered.
    * @param aView view to paint. should be the nsScrollPortView that
    * got scrolled.
    * @param aUpdateRegion ensure that this part of the view is repainted
