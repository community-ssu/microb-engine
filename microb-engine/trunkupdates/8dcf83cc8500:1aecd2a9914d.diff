diff -r 8dcf83cc8500 browser/app/Makefile.in
--- a/browser/app/Makefile.in	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/app/Makefile.in	Tue Sep 16 07:55:12 2008 -0500
@@ -67,21 +67,17 @@ DEFINES += -DAPP_UA_NAME="$(APP_UA_NAME)
 
 DIST_FILES = application.ini
 
 GRE_MILESTONE = $(shell $(PYTHON) $(topsrcdir)/config/printconfigsetting.py $(LIBXUL_DIST)/bin/platform.ini Build Milestone)
 GRE_BUILDID = $(shell $(PYTHON) $(topsrcdir)/config/printconfigsetting.py $(LIBXUL_DIST)/bin/platform.ini Build BuildID)
 
 DEFINES += -DGRE_MILESTONE=$(GRE_MILESTONE) -DGRE_BUILDID=$(GRE_BUILDID)
 
-ifdef MOZ_MEMORY
-ifneq ($(OS_ARCH),WINNT)
-LIBS += -ljemalloc
-endif
-endif
+LIBS += $(JEMALLOC_LIBS)
 
 ifdef LIBXUL_SDK
 include $(topsrcdir)/config/rules.mk
 else
 # Build a binary bootstrapping with XRE_main
 
 ifeq ($(USE_SHORT_LIBNAME), 1)
 PROGRAM = $(MOZ_APP_NAME)$(BIN_SUFFIX)
diff -r 8dcf83cc8500 browser/base/content/sanitize.js
--- a/browser/base/content/sanitize.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/base/content/sanitize.js	Tue Sep 16 07:55:12 2008 -0500
@@ -174,35 +174,49 @@ Sanitizer.prototype = {
         // the browser:purge-session-history notification. (like error console)
         return true;
       }
     },
     
     formdata: {
       clear: function ()
       {
-        //Clear undo history of all searchBars
-        var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService();
-        var windowManagerInterface = windowManager.QueryInterface(Components.interfaces.nsIWindowMediator);
-        var windows = windowManagerInterface.getEnumerator("navigator:browser");
+        // Clear undo history of all searchBars
+        var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1']
+                                      .getService(Components.interfaces.nsIWindowMediator);
+        var windows = windowManager.getEnumerator("navigator:browser");
         while (windows.hasMoreElements()) {
           var searchBar = windows.getNext().document.getElementById("searchbar");
           if (searchBar) {
             searchBar.value = "";
             searchBar.textbox.editor.transactionManager.clear();
           }
         }
 
         var formHistory = Components.classes["@mozilla.org/satchel/form-history;1"]
                                     .getService(Components.interfaces.nsIFormHistory2);
         formHistory.removeAllEntries();
       },
-      
+
       get canClear()
       {
+        var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1']
+                                      .getService(Components.interfaces.nsIWindowMediator);
+        var windows = windowManager.getEnumerator("navigator:browser");
+        while (windows.hasMoreElements()) {
+          var searchBar = windows.getNext().document.getElementById("searchbar");
+          if (searchBar) {
+            var transactionMgr = searchBar.textbox.editor.transactionManager;
+            if (searchBar.value ||
+                transactionMgr.numberOfUndoItems ||
+                transactionMgr.numberOfRedoItems)
+              return true;
+          }
+        }
+
         var formHistory = Components.classes["@mozilla.org/satchel/form-history;1"]
                                     .getService(Components.interfaces.nsIFormHistory2);
         return formHistory.hasEntries;
       }
     },
     
     downloads: {
       clear: function ()
diff -r 8dcf83cc8500 browser/build.mk
--- a/browser/build.mk	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/build.mk	Tue Sep 16 07:55:12 2008 -0500
@@ -57,16 +57,24 @@ package:
 package:
 	@$(MAKE) -C browser/installer
 
 install::
 	@$(MAKE) -C browser/installer install
 
 ifdef ENABLE_TESTS
 # Implemented in testing/testsuite-targets.mk
+
+# Browser tests live in a slightly different location, so we correct the path
+ifdef TEST_PATH
+BROWSER_TEST_PATH = --test-path=../browser/$(TEST_PATH)
+else
+BROWSER_TEST_PATH =
+endif
+
 mochitest-browser-chrome:
-	$(RUN_MOCHITEST) --browser-chrome
+	$(RUN_MOCHITEST) --browser-chrome $(BROWSER_TEST_PATH)
 	$(CHECK_TEST_ERROR)
 
 mochitest:: mochitest-browser-chrome
 
 .PHONY: mochitest-browser-chrome
 endif
diff -r 8dcf83cc8500 browser/components/nsBrowserGlue.js
--- a/browser/components/nsBrowserGlue.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/components/nsBrowserGlue.js	Tue Sep 16 07:55:12 2008 -0500
@@ -172,20 +172,19 @@ BrowserGlue.prototype = {
     distro.applyPrefDefaults();
   },
 
   // profile startup handler (contains profile initialization routines)
   _onProfileStartup: function() 
   {
     // Check to see if the EULA must be shown on startup
 
-    // Global override for tinderbox machines
     var prefBranch = Cc["@mozilla.org/preferences-service;1"].
                      getService(Ci.nsIPrefBranch);
-    var mustDisplayEULA = true;
+    var mustDisplayEULA = false;
     try {
       mustDisplayEULA = !prefBranch.getBoolPref("browser.EULA.override");
     } catch (e) {
       // Pref might not exist
     }
 
     // Make sure it hasn't already been accepted
     if (mustDisplayEULA) {
diff -r 8dcf83cc8500 browser/components/places/content/menu.xml
--- a/browser/components/places/content/menu.xml	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/components/places/content/menu.xml	Tue Sep 16 07:55:12 2008 -0500
@@ -960,16 +960,20 @@
       <property name="selType" readonly="true" onget="return 'single';"/>
 
       <method name="buildContextMenu">
         <parameter name="aPopup"/>
         <body><![CDATA[
           this._ensureInitialized();
           this._contextMenuShown = true;
           this.focus();
+          // The above call to focus activates the controller, but it may not
+          // always fire a consumable event for commandUpdater, so we force a
+          // command update.
+          window.updateCommands("focus");
           var show = this.controller.buildContextMenu(aPopup);
           if (show) {
             // disable the Delete command if the selection isn't explicit
             if (document.popupNode && document.popupNode.localName == "menupopup")
               document.getElementById("cmd_delete").setAttribute("disabled", "true");
             return true;
           }
           return false;
diff -r 8dcf83cc8500 browser/components/places/content/toolbar.xml
--- a/browser/components/places/content/toolbar.xml	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/components/places/content/toolbar.xml	Tue Sep 16 07:55:12 2008 -0500
@@ -995,16 +995,20 @@
 
       <property name="selType" onget="return 'single';"/>
 
       <method name="buildContextMenu">
         <parameter name="aPopup"/>
         <body><![CDATA[
           this._contextMenuShown = true;
           this.focus();
+          // The above call to focus activates the controller, but it may not
+          // always fire a consumable event for commandUpdater, so we force a
+          // command update.
+          window.updateCommands("focus");
           var show = this.controller.buildContextMenu(aPopup);
           if (show) {
             // disable the Delete command if the selection isn't explicit
             if (document.popupNode && document.popupNode.localName == "menupopup")
               document.getElementById("cmd_delete").setAttribute("disabled", "true");
             return true;
           }
           return false;
diff -r 8dcf83cc8500 browser/components/preferences/tests/browser_bug410900.js
--- a/browser/components/preferences/tests/browser_bug410900.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/components/preferences/tests/browser_bug410900.js	Tue Sep 16 07:55:12 2008 -0500
@@ -1,12 +1,12 @@ function test() {
 function test() {
   waitForExplicitFinish();
 
-  // setup a phony hander to ensure the app pane will be populated.
+  // Setup a phony handler to ensure the app pane will be populated.
   var handler = Cc["@mozilla.org/uriloader/web-handler-app;1"].
                 createInstance(Ci.nsIWebHandlerApp);
   handler.name = "App pane alive test";
   handler.uriTemplate = "http://test.mozilla.org/%s";
 
   var extps = Cc["@mozilla.org/uriloader/external-protocol-service;1"].
               getService(Ci.nsIExternalProtocolService);
   var info = extps.getProtocolHandlerInfo("apppanetest");
@@ -18,18 +18,19 @@ function test() {
 
   var obs = Cc["@mozilla.org/observer-service;1"].
             getService(Ci.nsIObserverService);
 
   var observer = {
     observe: function(win, topic, data) {
       if (topic != "app-handler-pane-loaded")
         return;
+
+      obs.removeObserver(observer, "app-handler-pane-loaded");
       runTest(win);
-      obs.removeObserver(observer, "app-handler-pane-loaded");
     }
   };
   obs.addObserver(observer, "app-handler-pane-loaded", false);
 
   openDialog("chrome://browser/content/preferences/preferences.xul", "Preferences",
              "chrome,titlebar,toolbar,centerscreen,dialog=no", "paneApplications");
 }
 
diff -r 8dcf83cc8500 browser/components/sessionstore/test/browser/Makefile.in
--- a/browser/components/sessionstore/test/browser/Makefile.in	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/components/sessionstore/test/browser/Makefile.in	Tue Sep 16 07:55:12 2008 -0500
@@ -41,16 +41,17 @@ VPATH		= @srcdir@
 VPATH		= @srcdir@
 relativesrcdir  = browser/components/sessionstore/test/browser 
 
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
 _BROWSER_TEST_FILES = \
 	browser_346337.js \
+	browser_346337_sample.html \
 	browser_350525.js \
 	browser_367052.js \
 	browser_393716.js \
 	browser_448741.js \
 	$(NULL)
 
 libs:: $(_BROWSER_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/browser/$(relativesrcdir)
diff -r 8dcf83cc8500 browser/components/sessionstore/test/browser/browser_346337.js
--- a/browser/components/sessionstore/test/browser/browser_346337.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/components/sessionstore/test/browser/browser_346337.js	Tue Sep 16 07:55:12 2008 -0500
@@ -33,25 +33,30 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 function test() {
   /** Test for Bug 346337 **/
   
   let fieldList = {
-    "//input[@name='testinput']": Date.now().toString(),
-    "//input[@name='bad name']":  Math.random().toString(),
+    "//input[@name='input']":     Date.now().toString(),
+    "//input[@name='spaced 1']":  Math.random().toString(),
+    "//input[3]":                 "three",
     "//input[@type='checkbox']":  true,
+    "//input[@name='uncheck']":   false,
     "//input[@type='radio'][1]":  false,
     "//input[@type='radio'][2]":  true,
+    "//input[@type='radio'][3]":  false,
     "//select":                   2,
     "//select[@multiple]":        [1, 3],
     "//textarea[1]":              "",
-    "//textarea[3]":              "Some more test\n" + new Date()
+    "//textarea[2]":              "Some text... " + Math.random(),
+    "//textarea[3]":              "Some more text\n" + new Date(),
+    "//input[@type='file']":      "/dev/null"
   };
   
   function getElementByXPath(aTab, aQuery) {
     let doc = aTab.linkedBrowser.contentDocument;
     let xptype = Ci.nsIDOMXPathResult.FIRST_ORDERED_NODE_TYPE;
     return doc.evaluate(aQuery, doc, null, xptype, null).singleNodeValue;
   }
   
@@ -86,18 +91,19 @@ function test() {
   // test setup
   let tabbrowser = getBrowser();
   waitForExplicitFinish();
   
   // make sure we don't save form data at all (except for tab duplication)
   let privacy_level = gPrefService.getIntPref("browser.sessionstore.privacy_level");
   gPrefService.setIntPref("browser.sessionstore.privacy_level", 2);
   
-  todo(false, "test doesn't run from the harness's http server");
-  let tab = tabbrowser.addTab("https://bugzilla.mozilla.org/attachment.cgi?id=328502");
+  let testURL = "chrome://mochikit/content/browser/" +
+    "browser/components/sessionstore/test/browser/browser_346337_sample.html";
+  let tab = tabbrowser.addTab(testURL);
   tab.linkedBrowser.addEventListener("load", function(aEvent) {
     for (let xpath in fieldList)
       setFormValue(tab, xpath, fieldList[xpath]);
     
     let tab2 = tabbrowser.duplicateTab(tab);
     tab2.linkedBrowser.addEventListener("load", function(aEvent) {
       for (let xpath in fieldList)
         ok(compareFormValue(tab2, xpath, fieldList[xpath]),
diff -r 8dcf83cc8500 browser/components/sessionstore/test/browser/browser_346337_sample.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/browser/components/sessionstore/test/browser/browser_346337_sample.html	Tue Sep 16 07:55:12 2008 -0500
@@ -0,0 +1,36 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
+<title>Test for bug 346337</title>
+
+<h3>Text Fields</h3>
+<input type="text" name="input">
+<input type="text" name="spaced 1">
+<input>
+
+<h3>Checkboxes and Radio buttons</h3>
+<input type="checkbox" name="check"> Check 1
+<input type="checkbox" name="uncheck" checked> Check 2
+<p>
+<input type="radio" name="group" value="1"> Radio 1
+<input type="radio" name="group" value="some"> Radio 2
+<input type="radio" name="group" checked> Radio 3
+
+<h3>Selects</h3>
+<select name="any">  
+  <option value="1"> Select 1  
+  <option value="some"> Select 2 
+  <option>Select 3
+</select>
+<select multiple="multiple">  
+  <option value=1> Multi-select 1
+  <option value=2> Multi-select 2  
+  <option value=3> Multi-select 3
+  <option value=4> Multi-select 4
+</select> 
+
+<h3>Text Areas</h3>
+<textarea name="testarea"></textarea>
+<textarea name="sized one" rows="5" cols="25"></textarea>
+<textarea></textarea>
+
+<h3>File Selector</h3>
+<input type="file">
diff -r 8dcf83cc8500 browser/modules/Sanitizer.jsm
--- a/browser/modules/Sanitizer.jsm	Sun Sep 14 00:37:23 2008 -0700
+++ b/browser/modules/Sanitizer.jsm	Tue Sep 16 07:55:12 2008 -0500
@@ -152,35 +152,49 @@ Sanitizer.prototype = {
         // the browser:purge-session-history notification. (like error console)
         return true;
       }
     },
     
     formdata: {
       clear: function ()
       {
-        //Clear undo history of all searchBars
-        var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService();
-        var windowManagerInterface = windowManager.QueryInterface(Components.interfaces.nsIWindowMediator);
-        var windows = windowManagerInterface.getEnumerator("navigator:browser");
+        // Clear undo history of all searchBars
+        var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1']
+                                      .getService(Components.interfaces.nsIWindowMediator);
+        var windows = windowManager.getEnumerator("navigator:browser");
         while (windows.hasMoreElements()) {
           var searchBar = windows.getNext().document.getElementById("searchbar");
           if (searchBar) {
             searchBar.value = "";
             searchBar.textbox.editor.transactionManager.clear();
           }
         }
 
         var formHistory = Components.classes["@mozilla.org/satchel/form-history;1"]
                                     .getService(Components.interfaces.nsIFormHistory2);
         formHistory.removeAllEntries();
       },
-      
+
       get canClear()
       {
+        var windowManager = Components.classes['@mozilla.org/appshell/window-mediator;1']
+                                      .getService(Components.interfaces.nsIWindowMediator);
+        var windows = windowManager.getEnumerator("navigator:browser");
+        while (windows.hasMoreElements()) {
+          var searchBar = windows.getNext().document.getElementById("searchbar");
+          if (searchBar) {
+            var transactionMgr = searchBar.textbox.editor.transactionManager;
+            if (searchBar.value ||
+                transactionMgr.numberOfUndoItems ||
+                transactionMgr.numberOfRedoItems)
+              return true;
+          }
+        }
+
         var formHistory = Components.classes["@mozilla.org/satchel/form-history;1"]
                                     .getService(Components.interfaces.nsIFormHistory2);
         return formHistory.hasEntries;
       }
     },
     
     downloads: {
       clear: function ()
diff -r 8dcf83cc8500 browser/themes/pinstripe/browser/places/star-icons.png
Binary file browser/themes/pinstripe/browser/places/star-icons.png has changed
diff -r 8dcf83cc8500 config/config.mk
--- a/config/config.mk	Sun Sep 14 00:37:23 2008 -0700
+++ b/config/config.mk	Tue Sep 16 07:55:12 2008 -0500
@@ -147,16 +147,22 @@ OS_CONFIG	:= $(OS_ARCH)$(OS_RELEASE)
 OS_CONFIG	:= $(OS_ARCH)$(OS_RELEASE)
 
 FINAL_LINK_LIBS = $(DEPTH)/config/final-link-libs
 FINAL_LINK_COMPS = $(DEPTH)/config/final-link-comps
 FINAL_LINK_COMP_NAMES = $(DEPTH)/config/final-link-comp-names
 
 MOZ_UNICHARUTIL_LIBS = $(LIBXUL_DIST)/lib/$(LIB_PREFIX)unicharutil_s.$(LIB_SUFFIX)
 MOZ_WIDGET_SUPPORT_LIBS    = $(DIST)/lib/$(LIB_PREFIX)widgetsupport_s.$(LIB_SUFFIX)
+
+ifdef MOZ_MEMORY
+ifneq ($(OS_ARCH),WINNT)
+JEMALLOC_LIBS = $(MKSHLIB_FORCE_ALL) $(call EXPAND_LIBNAME,jemalloc) $(MKSHLIB_UNFORCE_ALL)
+endif
+endif
 
 # determine debug-related options
 _DEBUG_CFLAGS :=
 _DEBUG_LDFLAGS :=
 
 ifndef MOZ_DEBUG
   # global debugging is disabled 
   # check if it was explicitly enabled for this module
diff -r 8dcf83cc8500 content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/base/public/nsContentUtils.h	Tue Sep 16 07:55:12 2008 -0500
@@ -62,16 +62,17 @@
 
 struct nsNativeKeyEvent; // Don't include nsINativeKeyBindings.h here: it will force strange compilation error!
 
 class nsIDOMScriptObjectFactory;
 class nsIXPConnect;
 class nsINode;
 class nsIContent;
 class nsIDOMNode;
+class nsIDOMKeyEvent;
 class nsIDocument;
 class nsIDocShell;
 class nsINameSpaceManager;
 class nsIScriptSecurityManager;
 class nsIJSContextStack;
 class nsIThreadJSContextStack;
 class nsIParserService;
 class nsIIOService;
@@ -1185,29 +1186,29 @@ public:
    * See bug 406407 for details.
    */
   static nsEvent* GetNativeEvent(nsIDOMEvent* aDOMEvent);
   static PRBool DOMEventToNativeKeyEvent(nsIDOMEvent* aDOMEvent,
                                          nsNativeKeyEvent* aNativeEvent,
                                          PRBool aGetCharCode);
 
   /**
-   * Get the candidates for accelkeys for aDOMEvent.
+   * Get the candidates for accelkeys for aDOMKeyEvent.
    *
-   * @param aDOMEvent [in] the input event for accelkey handling.
+   * @param aDOMKeyEvent [in] the key event for accelkey handling.
    * @param aCandidates [out] the candidate shortcut key combination list.
    *                          the first item is most preferred.
    */
-  static void GetAccelKeyCandidates(nsIDOMEvent* aDOMEvent,
+  static void GetAccelKeyCandidates(nsIDOMKeyEvent* aDOMKeyEvent,
                                     nsTArray<nsShortcutCandidate>& aCandidates);
 
   /**
-   * Get the candidates for accesskeys for aDOMEvent.
+   * Get the candidates for accesskeys for aNativeKeyEvent.
    *
-   * @param aNativeKeyEvent [in] the input event for accesskey handling.
+   * @param aNativeKeyEvent [in] the key event for accesskey handling.
    * @param aCandidates [out] the candidate access key list.
    *                          the first item is most preferred.
    */
   static void GetAccessKeyCandidates(nsKeyEvent* aNativeKeyEvent,
                                      nsTArray<PRUint32>& aCandidates);
 
   /**
    * Hide any XUL popups associated with aDocument, including any documents
diff -r 8dcf83cc8500 content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/base/src/nsContentUtils.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -3997,30 +3997,32 @@ IsCaseChangeableChar(PRUint32 aChar)
 IsCaseChangeableChar(PRUint32 aChar)
 {
   return IS_IN_BMP(aChar) &&
          ToLowerCase(PRUnichar(aChar)) != ToUpperCase(PRUnichar(aChar));
 }
 
 /* static */
 void
-nsContentUtils::GetAccelKeyCandidates(nsIDOMEvent* aDOMEvent,
+nsContentUtils::GetAccelKeyCandidates(nsIDOMKeyEvent* aDOMKeyEvent,
                   nsTArray<nsShortcutCandidate>& aCandidates)
 {
   NS_PRECONDITION(aCandidates.IsEmpty(), "aCandidates must be empty");
 
   nsAutoString eventType;
-  aDOMEvent->GetType(eventType);
-  // Don't process if aDOMEvent is not a keypress event.
+  aDOMKeyEvent->GetType(eventType);
+  // Don't process if aDOMKeyEvent is not a keypress event.
   if (!eventType.EqualsLiteral("keypress"))
     return;
 
   nsKeyEvent* nativeKeyEvent =
-    static_cast<nsKeyEvent*>(GetNativeEvent(aDOMEvent));
+    static_cast<nsKeyEvent*>(GetNativeEvent(aDOMKeyEvent));
   if (nativeKeyEvent) {
+    NS_ASSERTION(nativeKeyEvent->eventStructType == NS_KEY_EVENT,
+                 "wrong type of native event");
     // nsShortcutCandidate::mCharCode is a candidate charCode.
     // nsShoftcutCandidate::mIgnoreShift means the mCharCode should be tried to
     // execute a command with/without shift key state. If this is TRUE, the
     // shifted key state should be ignored. Otherwise, don't ignore the state.
     // the priority of the charCodes are (shift key is not pressed):
     //   0: charCode/PR_FALSE,
     //   1: unshiftedCharCodes[0]/PR_FALSE, 2: unshiftedCharCodes[1]/PR_FALSE...
     // the priority of the charCodes are (shift key is pressed):
@@ -4087,19 +4089,18 @@ nsContentUtils::GetAccelKeyCandidates(ns
 
         // Setting the alternative charCode candidates for retry without shift
         // key state only when the shift key is pressed.
         nsShortcutCandidate key(ch, PR_TRUE);
         aCandidates.AppendElement(key);
       }
     }
   } else {
-    nsCOMPtr<nsIDOMKeyEvent> key(do_QueryInterface(aDOMEvent));
     PRUint32 charCode;
-    key->GetCharCode(&charCode);
+    aDOMKeyEvent->GetCharCode(&charCode);
     if (charCode) {
       nsShortcutCandidate key(charCode, PR_FALSE);
       aCandidates.AppendElement(key);
     }
   }
 }
 
 /* static */
diff -r 8dcf83cc8500 content/base/src/nsGkAtomList.h
--- a/content/base/src/nsGkAtomList.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/base/src/nsGkAtomList.h	Tue Sep 16 07:55:12 2008 -0500
@@ -1611,16 +1611,17 @@ GK_ATOM(overflowAreaProperty, "OverflowA
 GK_ATOM(overflowAreaProperty, "OverflowArea")              // nsRect*
 GK_ATOM(overflowProperty, "OverflowProperty")              // list of nsIFrame*
 GK_ATOM(overflowContainersProperty, "OverflowContainersProperty")             // nsFrameList*
 GK_ATOM(excessOverflowContainersProperty, "ExcessOverflowContainersProperty") // nsFrameList*
 GK_ATOM(overflowLinesProperty, "OverflowLinesProperty")    // list of nsLineBox*
 GK_ATOM(overflowOutOfFlowsProperty, "OverflowOutOfFlowsProperty")      // nsFrameList*
 GK_ATOM(overflowPlaceholdersProperty, "OverflowPlaceholdersProperty")  // nsFrameList*
 GK_ATOM(preEffectsBBoxProperty, "PreEffectsBBoxProperty") // nsRect*
+GK_ATOM(preTransformBBoxProperty, "PreTransformBBoxProperty") // nsRect*
 GK_ATOM(rowUnpaginatedHeightProperty, "RowUnpaginatedHeightProperty")  // nscoord*
 GK_ATOM(spaceManagerProperty, "SpaceManagerProperty")      // the space manager for a block
 GK_ATOM(tabWidthProperty, "TabWidthProperty")              // nsTArray<TabSetting>* array of tab widths
 GK_ATOM(tableBCProperty, "TableBCProperty")                // table border collapsing info (e.g. damage area, table border widths)
 GK_ATOM(usedMarginProperty, "UsedMarginProperty") // nsMargin*
 GK_ATOM(usedPaddingProperty, "UsedPaddingProperty") // nsMargin*
 GK_ATOM(viewProperty, "ViewProperty")                      
 
diff -r 8dcf83cc8500 content/base/test/Makefile.in
--- a/content/base/test/Makefile.in	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/base/test/Makefile.in	Tue Sep 16 07:55:12 2008 -0500
@@ -204,16 +204,17 @@ _TEST_FILES = 	test_bug5141.html \
 		test_bug445225.html \
 		file_bug445225_multipart.txt \
 		file_bug445225_multipart.txt^headers^ \
 		test_title.html \
 		test_bug453521.html \
 		test_bug391728.html \
 		file_bug391728.html \
 		file_bug391728_2.html \
+		test_bug368972.html \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
 
 check::
 	@$(EXIT_ON_ERROR) \
 	for f in $(subst .cpp,,$(CPP_UNIT_TESTS)); do \
diff -r 8dcf83cc8500 content/base/test/test_bug368972.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/base/test/test_bug368972.html	Tue Sep 16 07:55:12 2008 -0500
@@ -0,0 +1,126 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=368972
+-->
+<head>
+  <title>Test for Bug 368972</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+<style type="text/css">
+#embed11, #object11 {
+  width: 400px;
+  height: 400px;
+}
+</style>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=368972">Mozilla Bug 368972</a>
+<p id="display"></p>
+<div id="content">
+Embed without defined width/height:
+<embed id="embed1" type="bogus"><br>
+Embed width=0 height=0
+<embed id="embed2" type="bogus" width="0" height="0"><br>
+Embed width=100 height=100
+<embed id="embed3" type="bogus" width="100" height="100"><br>
+Embed height=100
+<embed id="embed4" type="bogus" height="100"><br>
+Embed width=100
+<embed id="embed5" type="bogus" width="100"><br>
+Embed width=100xxx height=100
+<embed id="embed6" type="bogus" width="100xxx" height="100"><br>
+Embed width=0100 height=100
+<embed id="embed7" type="bogus" width="0100" height="100"><br>
+Embed width= height=100
+<embed id="embed8" type="bogus" width="" height="100"><br>
+Embed width=100 height=100 style="width:400px"
+<embed id="embed9" type="bogus" width="100" height="100" style="width:400px;"><br>
+Embed height=100 style="width:400px"
+<embed id="embed10" type="bogus" height="100" style="width:400px;"><br>
+Embed height=100 (stylesheet width:400px height:400px)
+<embed id="embed11" type="bogus" height="100"><br>
+
+Object without defined width/height:
+<object id="object1" type="bogus">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object width=0 height=0
+<object id="object2" type="bogus" width="0" height="0">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object width=100 height=100
+<object id="object3" type="bogus" width="100" height="100">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object height=100
+<object id="object4" type="bogus" height="100">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object width=100
+<object id="object5" type="bogus" width="100">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object width=100xxx height=100
+<object id="object6" type="bogus" width="100xxx" height="100">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object width=0100 height=100
+<object id="object7" type="bogus" width="0100" height="100">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object width= height=100
+<object id="object8" type="bogus" width="" height="100">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object width=100 height=100 style="width:400px"
+<object id="object9" type="bogus" width="100" height="100" style="width:400px;">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object height=100 style="width:400px"
+<object id="object10" type="bogus" height="100" style="width:400px;">
+<param name="pluginurl" value="http://foo">
+</object><br>
+Object height=100 (stylesheet width:400px height:400px)
+<object id="object11" type="bogus" height="100">
+<param name="pluginurl" value="http://foo">
+</object><br>
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+function check_size(id, width, height) {
+  var element = document.getElementById(id);
+  ok(element, "Plugin element " + id + " did not exist");
+  var style = window.getComputedStyle(element, null);
+  is(style.width, width + "px", "Plugin element " + id + " had an incorrect width");
+  is(style.height, height + "px", "Plugin element " + id + " had an incorrect height");
+}
+
+check_size("embed1", 240, 200);
+check_size("embed2", 0, 0);
+check_size("embed3", 100, 100);
+check_size("embed4", 240, 100);
+check_size("embed5", 100, 200);
+check_size("embed6", 100, 100);
+check_size("embed7", 100, 100);
+check_size("embed8", 240, 100);
+check_size("embed9", 400, 100);
+check_size("embed10", 400, 100);
+check_size("embed11", 400, 400);
+
+check_size("object1", 240, 200);
+check_size("object2", 0, 0);
+check_size("object3", 100, 100);
+check_size("object4", 240, 100);
+check_size("object5", 100, 200);
+check_size("object6", 100, 100);
+check_size("object7", 100, 100);
+check_size("object8", 240, 100);
+check_size("object9", 400, 100);
+check_size("object10", 400, 100);
+check_size("object11", 400, 400);
+</script>
+</pre>
+</body>
+</html>
diff -r 8dcf83cc8500 content/xbl/src/nsXBLEventHandler.cpp
--- a/content/xbl/src/nsXBLEventHandler.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/xbl/src/nsXBLEventHandler.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -161,19 +161,21 @@ nsXBLKeyEventHandler::HandleEvent(nsIDOM
   if (mPhase == NS_PHASE_TARGET) {
     PRUint16 eventPhase;
     aEvent->GetEventPhase(&eventPhase);
     if (eventPhase != nsIDOMEvent::AT_TARGET)
       return NS_OK;
   }
 
   nsCOMPtr<nsIDOMKeyEvent> key(do_QueryInterface(aEvent));
+  if (!key)
+    return NS_OK;
 
   nsAutoTArray<nsShortcutCandidate, 10> accessKeys;
-  nsContentUtils::GetAccelKeyCandidates(aEvent, accessKeys);
+  nsContentUtils::GetAccelKeyCandidates(key, accessKeys);
 
   if (accessKeys.IsEmpty()) {
     ExecuteMatchedHandlers(key, 0, PR_FALSE);
     return NS_OK;
   }
 
   for (PRUint32 i = 0; i < accessKeys.Length(); ++i) {
     if (ExecuteMatchedHandlers(key, accessKeys[i].mCharCode,
diff -r 8dcf83cc8500 content/xbl/src/nsXBLWindowKeyHandler.cpp
--- a/content/xbl/src/nsXBLWindowKeyHandler.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/xbl/src/nsXBLWindowKeyHandler.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -313,38 +313,33 @@ DoCommandCallback(const char *aCommand, 
     controllers->GetControllerForCommand(aCommand, getter_AddRefs(controller));
     if (controller) {
       controller->DoCommand(aCommand);
     }
   }
 }
 
 nsresult
-nsXBLWindowKeyHandler::WalkHandlers(nsIDOMEvent* aKeyEvent, nsIAtom* aEventType)
+nsXBLWindowKeyHandler::WalkHandlers(nsIDOMKeyEvent* aKeyEvent, nsIAtom* aEventType)
 {
   nsCOMPtr<nsIDOMNSUIEvent> evt = do_QueryInterface(aKeyEvent);
   PRBool prevent;
   evt->GetPreventDefault(&prevent);
   if (prevent)
     return NS_OK;
 
   nsCOMPtr<nsIDOMNSEvent> domNSEvent = do_QueryInterface(aKeyEvent);
   PRBool trustedEvent = PR_FALSE;
 
   if (domNSEvent) {
     //Don't process the event if it was not dispatched from a trusted source
     domNSEvent->GetIsTrusted(&trustedEvent);
   }
 
   if (!trustedEvent)
-    return NS_OK;
-
-  // Make sure our event is really a key event
-  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aKeyEvent));
-  if (!keyEvent)
     return NS_OK;
 
   PRBool isEditor;
   nsresult rv = EnsureHandlers(&isEditor);
   NS_ENSURE_SUCCESS(rv, rv);
   
   nsCOMPtr<nsIDOMElement> el = GetElement();
   if (!el) {
@@ -397,48 +392,51 @@ nsXBLWindowKeyHandler::WalkHandlers(nsID
     if (handled)
       aKeyEvent->PreventDefault();
 
   }
   
   return NS_OK;
 }
 
-nsresult nsXBLWindowKeyHandler::KeyUp(nsIDOMEvent* aKeyEvent)
+nsresult nsXBLWindowKeyHandler::KeyUp(nsIDOMEvent* aEvent)
 {
-  return WalkHandlers(aKeyEvent, nsGkAtoms::keyup);
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aEvent));
+  NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
+  return WalkHandlers(keyEvent, nsGkAtoms::keyup);
 }
 
-nsresult nsXBLWindowKeyHandler::KeyDown(nsIDOMEvent* aKeyEvent)
+nsresult nsXBLWindowKeyHandler::KeyDown(nsIDOMEvent* aEvent)
 {
-  return WalkHandlers(aKeyEvent, nsGkAtoms::keydown);
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aEvent));
+  NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
+  return WalkHandlers(keyEvent, nsGkAtoms::keydown);
 }
 
-nsresult nsXBLWindowKeyHandler::KeyPress(nsIDOMEvent* aKeyEvent)
+nsresult nsXBLWindowKeyHandler::KeyPress(nsIDOMEvent* aEvent)
 {
-  return WalkHandlers(aKeyEvent, nsGkAtoms::keypress);
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aEvent));
+  NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
+  return WalkHandlers(keyEvent, nsGkAtoms::keypress);
 }
 
 
 //
 // EventMatched
 //
 // See if the given handler cares about this particular key event
 //
 PRBool
 nsXBLWindowKeyHandler::EventMatched(nsXBLPrototypeHandler* inHandler,
-                                    nsIAtom* inEventType, nsIDOMEvent* inEvent,
+                                    nsIAtom* inEventType,
+                                    nsIDOMKeyEvent* inEvent,
                                     PRUint32 aCharCode, PRBool aIgnoreShiftKey)
 {
-  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(inEvent));
-  if (keyEvent)
-    return inHandler->KeyEventMatched(inEventType, keyEvent, aCharCode,
-                                      aIgnoreShiftKey);
-
-  return PR_FALSE;
+  return inHandler->KeyEventMatched(inEventType, inEvent, aCharCode,
+                                    aIgnoreShiftKey);
 }
 
 /* static */ void
 nsXBLWindowKeyHandler::ShutDown()
 {
   NS_IF_RELEASE(sNativeEditorBindings);
 }
 
@@ -482,58 +480,58 @@ nsXBLWindowKeyHandler::IsEditor()
 //
 // WalkHandlersInternal and WalkHandlersAndExecute
 //
 // Given a particular DOM event and a pointer to the first handler in the list,
 // scan through the list to find something to handle the event and then make it
 // so.
 //
 nsresult
-nsXBLWindowKeyHandler::WalkHandlersInternal(nsIDOMEvent* aEvent,
+nsXBLWindowKeyHandler::WalkHandlersInternal(nsIDOMKeyEvent* aKeyEvent,
                                             nsIAtom* aEventType, 
                                             nsXBLPrototypeHandler* aHandler)
 {
   nsAutoTArray<nsShortcutCandidate, 10> accessKeys;
-  nsContentUtils::GetAccelKeyCandidates(aEvent, accessKeys);
+  nsContentUtils::GetAccelKeyCandidates(aKeyEvent, accessKeys);
 
   if (accessKeys.IsEmpty()) {
-    WalkHandlersAndExecute(aEvent, aEventType, aHandler, 0, PR_FALSE);
+    WalkHandlersAndExecute(aKeyEvent, aEventType, aHandler, 0, PR_FALSE);
     return NS_OK;
   }
 
   for (PRUint32 i = 0; i < accessKeys.Length(); ++i) {
     nsShortcutCandidate &key = accessKeys[i];
-    if (WalkHandlersAndExecute(aEvent, aEventType, aHandler,
+    if (WalkHandlersAndExecute(aKeyEvent, aEventType, aHandler,
                                key.mCharCode, key.mIgnoreShift))
       return NS_OK;
   }
   return NS_OK;
 }
 
 PRBool
-nsXBLWindowKeyHandler::WalkHandlersAndExecute(nsIDOMEvent* aEvent,
+nsXBLWindowKeyHandler::WalkHandlersAndExecute(nsIDOMKeyEvent* aKeyEvent,
                                               nsIAtom* aEventType,
                                               nsXBLPrototypeHandler* aHandler,
                                               PRUint32 aCharCode,
                                               PRBool aIgnoreShiftKey)
 {
   nsresult rv;
-  nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aEvent));
+  nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aKeyEvent));
 
   // Try all of the handlers until we find one that matches the event.
   for (nsXBLPrototypeHandler *currHandler = aHandler; currHandler;
        currHandler = currHandler->GetNextHandler()) {
     PRBool stopped;
     privateEvent->IsDispatchStopped(&stopped);
     if (stopped) {
       // The event is finished, don't execute any more handlers
       return NS_OK;
     }
 
-    if (!EventMatched(currHandler, aEventType, aEvent,
+    if (!EventMatched(currHandler, aEventType, aKeyEvent,
                       aCharCode, aIgnoreShiftKey))
       continue;  // try the next one
 
     // Before executing this handler, check that it's not disabled,
     // and that it has something to do (oncommand of the <key> or its
     // <command> is non-empty).
     nsCOMPtr<nsIContent> elt = currHandler->GetHandlerElement();
     nsCOMPtr<nsIDOMElement> commandElt;
@@ -581,17 +579,17 @@ nsXBLWindowKeyHandler::WalkHandlersAndEx
     nsCOMPtr<nsPIDOMEventTarget> piTarget;
     nsCOMPtr<nsIDOMElement> element = GetElement();
     if (element) {
       piTarget = do_QueryInterface(commandElt);
     } else {
       piTarget = mTarget;
     }
 
-    rv = currHandler->ExecuteHandler(piTarget, aEvent);
+    rv = currHandler->ExecuteHandler(piTarget, aKeyEvent);
     if (NS_SUCCEEDED(rv)) {
       return PR_TRUE;
     }
   }
 
   return PR_FALSE;
 }
 
diff -r 8dcf83cc8500 content/xbl/src/nsXBLWindowKeyHandler.h
--- a/content/xbl/src/nsXBLWindowKeyHandler.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/xbl/src/nsXBLWindowKeyHandler.h	Tue Sep 16 07:55:12 2008 -0500
@@ -41,16 +41,17 @@
 #define nsXBLWindowKeyHandler_h__
 
 #include "nsWeakPtr.h"
 #include "nsIDOMKeyListener.h"
 
 class nsIAtom;
 class nsIDOMElement;
 class nsIDOMEventTarget;
+class nsIDOMKeyEvent;
 class nsPIDOMEventTarget;
 class nsIXBLDocumentInfo;
 class nsXBLSpecialDocInfo;
 class nsXBLPrototypeHandler;
 
 class nsXBLWindowKeyHandler : public nsIDOMKeyListener
 {
 public:
@@ -68,35 +69,35 @@ public:
   NS_IMETHOD KeyPress(nsIDOMEvent* aKeyEvent);
    
   NS_DECL_ISUPPORTS
 
   // release globals
   static NS_HIDDEN_(void) ShutDown();
 
 protected:
-  nsresult WalkHandlers(nsIDOMEvent* aKeyEvent, nsIAtom* aEventType);
+  nsresult WalkHandlers(nsIDOMKeyEvent* aKeyEvent, nsIAtom* aEventType);
 
   // walk the handlers, looking for one to handle the event
-  nsresult WalkHandlersInternal(nsIDOMEvent* aKeyEvent,
+  nsresult WalkHandlersInternal(nsIDOMKeyEvent* aKeyEvent,
                                 nsIAtom* aEventType, 
                                 nsXBLPrototypeHandler* aHandler);
 
   // walk the handlers for aEvent, aCharCode and aIgnoreShiftKey
-  PRBool WalkHandlersAndExecute(nsIDOMEvent* aEvent, nsIAtom* aEventType,
+  PRBool WalkHandlersAndExecute(nsIDOMKeyEvent* aKeyEvent, nsIAtom* aEventType,
                                 nsXBLPrototypeHandler* aHandler,
                                 PRUint32 aCharCode, PRBool aIgnoreShiftKey);
 
   // lazily load the handlers. Overridden to handle being attached
   // to a particular element rather than the document
   nsresult EnsureHandlers(PRBool *aIsEditor);
 
   // check if the given handler cares about the given key event
   PRBool EventMatched(nsXBLPrototypeHandler* inHandler, nsIAtom* inEventType,
-                      nsIDOMEvent* inEvent, PRUint32 aCharCode,
+                      nsIDOMKeyEvent* inEvent, PRUint32 aCharCode,
                       PRBool aIgnoreShiftKey);
 
   // are we working with editor or browser?
   PRBool IsEditor() ;
 
   // Returns the element which was passed as a parameter to the constructor,
   // unless the element has been removed from the document.
   already_AddRefed<nsIDOMElement> GetElement();
diff -r 8dcf83cc8500 content/xslt/tests/buster/jar.mn
--- a/content/xslt/tests/buster/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/content/xslt/tests/buster/jar.mn	Tue Sep 16 07:55:12 2008 -0500
@@ -1,15 +1,11 @@ xslt-qa.jar:
 xslt-qa.jar:
-#ifdef MOZ_XUL_APP
 % content xslt-qa %content/xslt-qa/
 % overlay chrome://communicator/content/tasksOverlay.xul chrome://xslt-qa/content/xslt-qa-overlay.xul
-#else
-* content/xslt-qa/contents.rdf                 (contents.rdf)
-#endif
   content/xslt-qa/xslt-qa-overlay.xul
   content/xslt-qa/xslt-qa-overlay.js
   content/xslt-qa/buster/buster.xul
   content/xslt-qa/buster/buster.css
   content/xslt-qa/buster/buster-statics.js
   content/xslt-qa/buster/buster-handlers.js
   content/xslt-qa/buster/buster-files.js
   content/xslt-qa/buster/buster-test.js
diff -r 8dcf83cc8500 dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/dom/src/base/nsDOMClassInfo.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -2136,16 +2136,18 @@ nsDOMClassInfo::Init()
 
   DOM_CLASSINFO_MAP_BEGIN(HTMLDocument, nsIDOMHTMLDocument)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLDocument)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNSHTMLDocument)
     DOM_CLASSINFO_DOCUMENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(HTMLOptionsCollection, nsIDOMHTMLOptionsCollection)
+    // Order is significant.  nsIDOMHTMLOptionsCollection.length shadows
+    // nsIDOMHTMLCollection.length, which is readonly.
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLOptionsCollection)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNSHTMLOptionCollection)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLCollection)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN_NO_CLASS_IF(HTMLFormControlCollection,
                                       nsIDOMHTMLCollection)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLCollection)
@@ -2359,16 +2361,18 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(HTMLOptGroupElement, nsIDOMHTMLOptGroupElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLOptGroupElement)
     DOM_CLASSINFO_GENERIC_HTML_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(HTMLOptionElement, nsIDOMHTMLOptionElement)
+    // Order is significant.  nsIDOMNSHTMLOptionElement.text shdaows
+    // nsIDOMHTMLOptionElement.text, which is readonly.
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNSHTMLOptionElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLOptionElement)
     DOM_CLASSINFO_GENERIC_HTML_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(HTMLParagraphElement, nsIDOMHTMLParagraphElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMHTMLParagraphElement)
     DOM_CLASSINFO_GENERIC_HTML_MAP_ENTRIES
@@ -2705,18 +2709,20 @@ nsDOMClassInfo::Init()
   // XXX - the proto chain stuff is sort of hackish, because of the MI in
   // the SVG interfaces. I doubt that extending the proto on one interface
   // works properly on an element which inherits off multiple interfaces.
   // Tough luck. - bbaetz
 
   // The SVG document
 
   DOM_CLASSINFO_MAP_BEGIN(SVGDocument, nsIDOMSVGDocument)
+    // Order is significant.  nsIDOMDocument.title shadows
+    // nsIDOMSVGDocument.title, which is readonly.
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMDocument)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGDocument)
-    DOM_CLASSINFO_MAP_ENTRY(nsIDOMDocument)
     DOM_CLASSINFO_DOCUMENT_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
   // SVG element classes
 
   DOM_CLASSINFO_MAP_BEGIN(SVGAElement, nsIDOMSVGAElement)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMSVGAElement)
     DOM_CLASSINFO_SVG_GRAPHIC_ELEMENT_MAP_ENTRIES
diff -r 8dcf83cc8500 dom/src/threads/nsDOMWorkerScriptLoader.cpp
--- a/dom/src/threads/nsDOMWorkerScriptLoader.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerScriptLoader.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -738,17 +738,18 @@ nsDOMWorkerScriptLoader::ScriptCompiler:
   // execution to automatically report errors. We let them propagate instead.
   uint32 oldOpts =
     JS_SetOptions(mCx, JS_GetOptions(mCx) | JSOPTION_DONT_REPORT_UNCAUGHT);
 
   JSPrincipals* principal = nsDOMWorkerSecurityManager::WorkerPrincipal();
 
   JSScript* script =
     JS_CompileUCScriptForPrincipals(mCx, global, principal,
-                                    mScriptText.BeginReading(),
+                                    reinterpret_cast<const jschar*>
+                                               (mScriptText.BeginReading()),
                                     mScriptText.Length(), mFilename.get(), 1);
 
   JS_SetOptions(mCx, oldOpts);
 
   if (!script) {
     return NS_ERROR_FAILURE;
   }
 
diff -r 8dcf83cc8500 dom/src/threads/nsDOMWorkerThread.cpp
--- a/dom/src/threads/nsDOMWorkerThread.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/dom/src/threads/nsDOMWorkerThread.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -669,17 +669,19 @@ nsDOMWorkerThread::CompileGlobalObject(J
   }
   else {
     NS_ASSERTION(!mSource.IsEmpty(), "No source text!");
 
     JSPrincipals* principal = nsDOMWorkerSecurityManager::WorkerPrincipal();
 
     // Evaluate and execute the script
     success = JS_EvaluateUCScriptForPrincipals(aCx, global, principal,
-                                               mSource.get(), mSource.Length(),
+                                               reinterpret_cast<const jschar*>
+                                                          (mSource.get()), 
+                                               mSource.Length(),
                                                "DOMWorker inline script", 1,
                                                &val);
     if (!success) {
       mGlobal = NULL;
       return PR_FALSE;
     }
   }
 
diff -r 8dcf83cc8500 embedding/components/ui/jar.mn
--- a/embedding/components/ui/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/embedding/components/ui/jar.mn	Tue Sep 16 07:55:12 2008 -0500
@@ -1,11 +1,3 @@
-#ifndef MOZ_XUL_APP
-en-US.jar:
-    locale/en-US/global/nsHelperAppDlg.dtd (/toolkit/locales/en-US/chrome/global/nsHelperAppDlg.dtd)
-    locale/en-US/global/nsHelperAppDlg.properties (/toolkit/locales/en-US/chrome/global/nsHelperAppDlg.properties)
-    locale/en-US/global/nsProgressDialog.dtd (/toolkit/locales/en-US/chrome/global/nsProgressDialog.dtd)
-    locale/en-US/global/nsProgressDialog.properties (/toolkit/locales/en-US/chrome/global/nsProgressDialog.properties)
-#endif
-
 toolkit.jar:
     content/global/nsHelperAppDlg.xul (helperAppDlg/nsHelperAppDlg.xul)
     content/global/nsProgressDialog.xul  (progressDlg/nsProgressDialog.xul)
diff -r 8dcf83cc8500 embedding/qa/testembed/BrowserView.cpp
--- a/embedding/qa/testembed/BrowserView.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/embedding/qa/testembed/BrowserView.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -968,17 +968,16 @@ LRESULT CBrowserView::OnFindMsg(WPARAM w
 }
 
 void CBrowserView::OnFilePrint()
 {
   nsresult rv;
   nsCOMPtr<nsIPref> prefs(do_GetService(NS_PREF_CONTRACTID, &rv));
   if (NS_SUCCEEDED(rv)) 
   {
-    prefs->SetBoolPref("print.use_native_print_dialog", PR_TRUE);
     prefs->SetBoolPref("print.show_print_progress", PR_FALSE);
   }
   else
 	NS_ASSERTION(PR_FALSE, "Could not get preferences service");
 
   nsCOMPtr<nsIDOMWindow> domWindow;
 	mWebBrowser->GetContentDOMWindow(getter_AddRefs(domWindow));
   if(domWindow) {
diff -r 8dcf83cc8500 extensions/python/dom/test/pyxultest/jar.mn
--- a/extensions/python/dom/test/pyxultest/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/extensions/python/dom/test/pyxultest/jar.mn	Tue Sep 16 07:55:12 2008 -0500
@@ -4,23 +4,17 @@
 # only used by the Mozilla build process (although I'm not sure exactly now!)
 
 # As most apps will be outside the mozilla tree and presumably have their 
 # own build process, they probably don't need this file.
 #
 # Clarifications and simplifications welcome!
 
 pyxultest.jar:
-#ifdef MOZ_XUL_APP
-## A xulrunner app
 %   content pyxultest %content/pyxultest/
-#else
-## Old style manifest.
-    content/pyxultest/contents.rdf            (chrome/contents.rdf)
-#endif
     content/pyxultest/pyxultest.xul           (chrome/content/pyxultest.xul)
     content/pyxultest/pyxultest.py            (chrome/content/pyxultest.py)
     content/pyxultest/pyxultest.css           (chrome/content/pyxultest.css)
     content/pyxultest/dialog.xul              (chrome/content/dialog.xul)
     content/pyxultest/python_overlay.xul      (chrome/content/python_overlay.xul)
     content/pyxultest/js_overlay.xul          (chrome/content/js_overlay.xul)
     content/pyxultest/pytester.xul            (chrome/content/pytester.xul)
     content/pyxultest/pytester.py             (chrome/content/pytester.py)
diff -r 8dcf83cc8500 extensions/reporter/jar.mn
--- a/extensions/reporter/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/extensions/reporter/jar.mn	Tue Sep 16 07:55:12 2008 -0500
@@ -1,19 +1,14 @@ reporter.jar:
 reporter.jar:
-#ifdef MOZ_XUL_APP
 % content reporter %content/reporter/ xpcnativewrappers=yes
 % overlay chrome://browser/content/browser.xul         chrome://reporter/content/reporterOverlay.xul
 % overlay chrome://navigator/content/navigator.xul     chrome://reporter/content/reporterOverlay.xul
 % overlay chrome://global/content/customizeToolbar.xul chrome://reporter/content/reporterOverlay.xul
 % skin reporter classic/1.0 %skin/classic/reporter/
-#else
-* content/reporter/contents.rdf                          (resources/content/reporter/contents.rdf)
-  skin/classic/reporter/contents.rdf                     (resources/skin/classic/reporter/contents.rdf)
-#endif
  content/reporter/reportWizard.xul                       (resources/content/reporter/reportWizard.xul)
  content/reporter/reportWizard.js                        (resources/content/reporter/reportWizard.js)
  content/reporter/reporterOverlay.xul                    (resources/content/reporter/reporterOverlay.xul)
  content/reporter/reporterOverlay.js                     (resources/content/reporter/reporterOverlay.js)
  content/reporter/error.xhtml                            (resources/content/reporter/error.xhtml)
  content/reporter/report.xhtml                           (resources/content/reporter/report.xhtml)
  skin/classic/reporter/icon.png                          (resources/skin/classic/reporter/icon.png)
  skin/classic/reporter/reportResults.css                 (resources/skin/classic/reporter/reportResults.css)
diff -r 8dcf83cc8500 extensions/reporter/locales/jar.mn
--- a/extensions/reporter/locales/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/extensions/reporter/locales/jar.mn	Tue Sep 16 07:55:12 2008 -0500
@@ -1,16 +1,11 @@
 #filter substitution
 
-#ifdef MOZ_XUL_APP
 @AB_CD@.jar:
-#else
-reporter.jar:
-* locale/@AB_CD@/reporter/contents.rdf                      (generic/chrome/contents.rdf)
-#endif
 % locale reporter @AB_CD@ %locale/@AB_CD@/reporter/
   locale/@AB_CD@/reporter/reportWizard.dtd                  (%chrome/reportWizard.dtd)
   locale/@AB_CD@/reporter/about.dtd                         (%chrome/about.dtd)
   locale/@AB_CD@/reporter/reporterOverlay.dtd               (%chrome/reporterOverlay.dtd)
   locale/@AB_CD@/reporter/reportResults.dtd                 (%chrome/reportResults.dtd)
   locale/@AB_CD@/reporter/reporter.dtd                      (%chrome/reporter.dtd)
   locale/@AB_CD@/reporter/reportWizard.properties           (%chrome/reportWizard.properties)
   locale/@AB_CD@/reporter/reporterOverlay.properties        (%chrome/reporterOverlay.properties)
diff -r 8dcf83cc8500 gfx/src/thebes/nsSystemFontsGTK2.cpp
--- a/gfx/src/thebes/nsSystemFontsGTK2.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/src/thebes/nsSystemFontsGTK2.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -214,17 +214,17 @@ nsSystemFontsGTK2::GetSystemFontInfo(Gtk
     aFontStyle->weight = pango_font_description_get_weight(desc);
 
     float size = float(pango_font_description_get_size(desc) / PANGO_SCALE);
 
     // |size| is now either pixels or pango-points (not Mozilla-points!)
 
     if (!MOZ_pango_font_description_get_size_is_absolute(desc)) {
         // |size| is in pango-points, so convert to pixels.
-        size *= float(gfxPlatformGtk::DPI()) / POINTS_PER_INCH_FLOAT;
+        size *= gfxPlatformGtk::DPI() / POINTS_PER_INCH_FLOAT;
     }
 
     // |size| is now pixels
 
     aFontStyle->size = size;
   
     pango_font_description_free(desc);
 
diff -r 8dcf83cc8500 gfx/src/thebes/nsThebesFontEnumerator.cpp
--- a/gfx/src/thebes/nsThebesFontEnumerator.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/src/thebes/nsThebesFontEnumerator.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -119,17 +119,17 @@ nsThebesFontEnumerator::GetDefaultFont(c
     NS_ENSURE_ARG_POINTER(aResult);
     *aResult = nsnull;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsThebesFontEnumerator::UpdateFontList(PRBool *_retval)
 {
-    nsresult rv = gfxPlatform::GetPlatform()->UpdateFontList();
+    gfxPlatform::GetPlatform()->UpdateFontList();
     *_retval = PR_FALSE; // always return false for now
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsThebesFontEnumerator::GetStandardFamilyName(const PRUnichar *aName,
                                               PRUnichar **aResult)
 {
diff -r 8dcf83cc8500 gfx/src/thebes/nsThebesRenderingContext.cpp
--- a/gfx/src/thebes/nsThebesRenderingContext.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/src/thebes/nsThebesRenderingContext.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -93,18 +93,16 @@ nsThebesRenderingContext::~nsThebesRende
 //////////////////////////////////////////////////////////////////////
 //// nsIRenderingContext
 
 NS_IMETHODIMP
 nsThebesRenderingContext::Init(nsIDeviceContext* aContext, gfxASurface *aThebesSurface)
 {
     PR_LOG(gThebesGFXLog, PR_LOG_DEBUG, ("## %p nsTRC::Init ctx %p thebesSurface %p\n", this, aContext, aThebesSurface));
 
-    nsThebesDeviceContext *thebesDC = static_cast<nsThebesDeviceContext*>(aContext);
-
     mDeviceContext = aContext;
     mWidget = nsnull;
 
     mThebes = new gfxContext(aThebesSurface);
 
     return (CommonInit());
 }
 
@@ -120,18 +118,16 @@ nsThebesRenderingContext::Init(nsIDevice
 
     return (CommonInit());
 }
 
 NS_IMETHODIMP
 nsThebesRenderingContext::Init(nsIDeviceContext* aContext, nsIWidget *aWidget)
 {
     PR_LOG(gThebesGFXLog, PR_LOG_DEBUG, ("## %p nsTRC::Init ctx %p widget %p\n", this, aContext, aWidget));
-
-    nsThebesDeviceContext *thebesDC = static_cast<nsThebesDeviceContext*>(aContext);
 
     mDeviceContext = aContext;
     mWidget = aWidget;
 
     mThebes = new gfxContext(aWidget->GetThebesSurface());
 
     //mThebes->SetColor(gfxRGBA(0.9, 0.0, 0.0, 0.3));
     //mThebes->Paint();
diff -r 8dcf83cc8500 gfx/thebes/crashtests/441360.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gfx/thebes/crashtests/441360.html	Tue Sep 16 07:55:12 2008 -0500
@@ -0,0 +1,39 @@
+<html><head>
+    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+    <title>Testcase for bug </title>
+    <style type="text/css">
+
+        html,body {
+            color:black; background-color:white; font-size:16px; padding:0; margin:0;
+        }
+	
+
+    </style>
+</head>
+<body>
+
+<div id="Image"></div>
+
+<script>
+var v;
+function insertImage() {
+	var img_node = document.createElement('iframe');
+	img_node.src = "441360_data.gif";
+	var image_div = document.getElementById('Image');
+	image_div.appendChild(img_node);
+}
+
+insertImage();
+v = document.body.offsetHeight;
+insertImage();
+v = document.body.offsetHeight;
+insertImage();
+v = document.body.offsetHeight;
+insertImage();
+v = document.body.offsetHeight;
+
+</script>
+
+
+</body>
+</html>
diff -r 8dcf83cc8500 gfx/thebes/crashtests/crashtests.list
--- a/gfx/thebes/crashtests/crashtests.list	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/crashtests/crashtests.list	Tue Sep 16 07:55:12 2008 -0500
@@ -34,9 +34,10 @@ load 416637-1.html
 load 416637-1.html
 load 419095-1.html
 load 420945-1.html
 load 420962-1.html
 load 421393-1.html
 load 421813-1.html
 load 423270-1.html
 load 429899-1.html
+load 441360.html
 
diff -r 8dcf83cc8500 gfx/thebes/public/gfxFont.h
--- a/gfx/thebes/public/gfxFont.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/public/gfxFont.h	Tue Sep 16 07:55:12 2008 -0500
@@ -449,31 +449,41 @@ public:
         NS_LOG_ADDREF(this, mRefCnt, "gfxFont", sizeof(*this));
         return mRefCnt;
     }
     nsrefcnt Release(void) {
         NS_PRECONDITION(0 != mRefCnt, "dup release");
         --mRefCnt;
         NS_LOG_RELEASE(this, mRefCnt, "gfxFont");
         if (mRefCnt == 0) {
-            // Don't delete just yet; return the object to the cache for
-            // possibly recycling within some time limit
-            gfxFontCache::GetCache()->NotifyReleased(this);
-            return 0;
+            NotifyReleased();
         }
         return mRefCnt;
     }
 
     PRInt32 GetRefCount() { return mRefCnt; }
 
 protected:
     nsAutoRefCnt mRefCnt;
 
+    void NotifyReleased() {
+        gfxFontCache *cache = gfxFontCache::GetCache();
+        if (cache) {
+            // Don't delete just yet; return the object to the cache for
+            // possibly recycling within some time limit
+            cache->NotifyReleased(this);
+        } else {
+            // The cache may have already been shut down.
+            delete this;
+        }
+    }
+
+    gfxFont(gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle);
+
 public:
-    gfxFont(gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle);
     virtual ~gfxFont();
 
     const nsString& GetName() const { return mFontEntry->Name(); }
     const gfxFontStyle *GetStyle() const { return &mStyle; }
 
     virtual nsString GetUniqueName() = 0;
 
     // Font metrics
@@ -632,17 +642,16 @@ public:
         if (!mIsValid)
             return PR_FALSE;
         return mFontEntry->HasCharacter(ch); 
     }
 
 protected:
     nsRefPtr<gfxFontEntry> mFontEntry;
 
-    // The family name of the font
     PRPackedBool               mIsValid;
     nsExpirationState          mExpirationState;
     gfxFontStyle               mStyle;
     nsAutoTArray<gfxGlyphExtents*,1> mGlyphExtentsArray;
 
     // synthetic bolding for environments where this is not supported by the platform
     PRUint32                   mSyntheticBoldOffset;  // number of devunit pixels to offset double-strike, 0 ==> no bolding
 
@@ -1475,19 +1484,20 @@ private:
     nsExpirationState mExpirationState;
     PRUint32          mAppUnitsPerDevUnit;
     PRUint32          mFlags;
     PRUint32          mCharacterCount;
     PRUint32          mHashCode;
 };
 
 class THEBES_API gfxFontGroup : public gfxTextRunFactory {
-public:
+protected:
     gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle);
 
+public:
     virtual ~gfxFontGroup() {
         mFonts.Clear();
     }
 
     virtual gfxFont *GetFontAt(PRInt32 i) {
         return static_cast<gfxFont*>(mFonts[i]);
     }
     virtual PRUint32 FontListLength() const {
diff -r 8dcf83cc8500 gfx/thebes/public/gfxPangoFonts.h
--- a/gfx/thebes/public/gfxPangoFonts.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/public/gfxPangoFonts.h	Tue Sep 16 07:55:12 2008 -0500
@@ -81,18 +81,16 @@ public:
 
     virtual const gfxFont::Metrics& GetMetrics();
 
     PangoFont *GetPangoFont() { if (!mPangoFont) RealizePangoFont(); return mPangoFont; }
 
     // Check GetStyle()->sizeAdjust != 0.0 before calling this 
     gfxFloat GetAdjustedSize() { if (!mPangoFont) RealizePangoFont(); return mAdjustedSize; }
 
-    PRUint32 GetGlyph(const PRUint32 aChar);
-
     virtual nsString GetUniqueName();
 
     // Get the glyphID of a space
     virtual PRUint32 GetSpaceGlyph() {
         NS_ASSERTION(GetStyle()->size != 0,
                      "forgot to short-circuit a text run with zero-sized font?");
         GetMetrics();
         return mSpaceGlyph;
@@ -143,17 +141,17 @@ protected:
      * (TEXT_IS_8BIT can return false when the characters are all below 0x100
      * but stored in UTF16 format)
      */
     void InitTextRun(gfxTextRun *aTextRun, const gchar *aUTF8Text,
                      PRUint32 aUTF8Length, PRUint32 aUTF8HeaderLength,
                      PRBool aTake8BitPath);
 
     // Returns NS_ERROR_FAILURE if there's a missing glyph
-    nsresult SetGlyphs(gfxTextRun *aTextRun, gfxPangoFont *aFont,
+    nsresult SetGlyphs(gfxTextRun *aTextRun,
                        const gchar *aUTF8, PRUint32 aUTF8Length,
                        PRUint32 *aUTF16Offset, PangoGlyphString *aGlyphs,
                        PangoGlyphUnit aOverrideSpaceWidth,
                        PRBool aAbortOnMissingGlyph);
     nsresult SetMissingGlyphs(gfxTextRun *aTextRun,
                               const gchar *aUTF8, PRUint32 aUTF8Length,
                               PRUint32 *aUTF16Offset);
     void CreateGlyphRunsItemizing(gfxTextRun *aTextRun,
diff -r 8dcf83cc8500 gfx/thebes/public/gfxPlatformGtk.h
--- a/gfx/thebes/public/gfxPlatformGtk.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/public/gfxPlatformGtk.h	Tue Sep 16 07:55:12 2008 -0500
@@ -81,35 +81,35 @@ public:
     gfxFontGroup *CreateFontGroup(const nsAString &aFamilies,
                                   const gfxFontStyle *aStyle);
 
 #ifndef MOZ_PANGO
     FontFamily *FindFontFamily(const nsAString& aName);
     FontEntry *FindFontEntry(const nsAString& aFamilyName, const gfxFontStyle& aFontStyle);
 #endif
 
-    static PRInt32 DPI() {
-        if (sDPI == -1) {
+    static double DPI() {
+        if (sDPI < 0.0) {
             InitDPI();
         }
-        NS_ASSERTION(sDPI > 0, "Something is wrong");
+        NS_ASSERTION(sDPI > 0.0, "Something is wrong");
         return sDPI;
     }
 
 #ifndef MOZ_PANGO
     FT_Library GetFTLibrary();
 #endif
 
     void SetGdkDrawable(gfxASurface *target,
                         GdkDrawable *drawable);
     GdkDrawable *GetGdkDrawable(gfxASurface *target);
 
 protected:
     static void InitDPI();
 
-    static PRInt32 sDPI;
+    static double sDPI;
     static gfxFontconfigUtils *sFontconfigUtils;
 
 private:
     virtual cmsHPROFILE GetPlatformCMSOutputProfile();
 };
 
 #endif /* GFX_PLATFORM_GTK_H */
diff -r 8dcf83cc8500 gfx/thebes/src/gfxFont.cpp
--- a/gfx/thebes/src/gfxFont.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/src/gfxFont.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -257,17 +257,17 @@ gfxFont::RunMetrics::CombineWith(const R
     } else {
         mBoundingBox =
             mBoundingBox.Union(aOther.mBoundingBox + gfxPoint(mAdvanceWidth, 0));
     }
     mAdvanceWidth += aOther.mAdvanceWidth;
 }
 
 gfxFont::gfxFont(gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle) :
-    mIsValid(PR_TRUE), mStyle(*aFontStyle), mFontEntry(aFontEntry), mSyntheticBoldOffset(0)
+    mFontEntry(aFontEntry), mIsValid(PR_TRUE), mStyle(*aFontStyle), mSyntheticBoldOffset(0)
 {
 #ifdef DEBUG_TEXT_RUN_STORAGE_METRICS
     ++gFontCount;
 #endif
 }
 
 gfxFont::~gfxFont()
 {
@@ -2323,19 +2323,19 @@ gfxTextRun::CopyGlyphDataFrom(gfxTextRun
 #ifdef DEBUG
     gfxFont *lastFont = nsnull;
 #endif
     while (iter.NextRun()) {
         gfxFont *font = iter.GetGlyphRun()->mFont;
         NS_ASSERTION(font != lastFont, "Glyphruns not coalesced?");
 #ifdef DEBUG
         lastFont = font;
+        PRUint32 end = iter.GetStringEnd();
 #endif
         PRUint32 start = iter.GetStringStart();
-        PRUint32 end = iter.GetStringEnd();
         NS_ASSERTION(aSource->IsClusterStart(start),
                      "Started word in the middle of a cluster...");
         NS_ASSERTION(end == aSource->GetLength() || aSource->IsClusterStart(end),
                      "Ended word in the middle of a cluster...");
 
         nsresult rv = AddGlyphRun(font, start - aStart + aDest);
         if (NS_FAILED(rv))
             return;
diff -r 8dcf83cc8500 gfx/thebes/src/gfxFontUtils.cpp
--- a/gfx/thebes/src/gfxFontUtils.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/src/gfxFontUtils.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -290,17 +290,17 @@ gfxFontUtils::ReadCMAPTableFormat4(PRUin
     const PRUint16 *idRangeOffsets = idDeltas + segCount;
     for (PRUint16 i = 0; i < segCount; i++) {
         const PRUint16 endCount = ReadShortAt16(endCounts, i);
         const PRUint16 startCount = ReadShortAt16(startCounts, i);
         const PRUint16 idRangeOffset = ReadShortAt16(idRangeOffsets, i);
         if (idRangeOffset == 0) {
             aCharacterMap.SetRange(startCount, endCount);
         } else {
-            const PRUint16 idDelta = ReadShortAt16(idDeltas, i);
+            // const PRUint16 idDelta = ReadShortAt16(idDeltas, i); // Unused: self-documenting.
             for (PRUint32 c = startCount; c <= endCount; ++c) {
                 if (c == 0xFFFF)
                     break;
 
                 const PRUint16 *gdata = (idRangeOffset/2 
                                          + (c - startCount)
                                          + &idRangeOffsets[i]);
 
@@ -361,17 +361,17 @@ gfxFontUtils::ReadCMAP(PRUint8 *aBuf, PR
     };
     enum {
         EncodingIDSymbol = 0,
         EncodingIDMicrosoft = 1,
         EncodingIDUCS4ForUnicodePlatform = 3,
         EncodingIDUCS4ForMicrosoftPlatform = 10
     };
 
-    PRUint16 version = ReadShortAt(aBuf, OffsetVersion);
+    // PRUint16 version = ReadShortAt(aBuf, OffsetVersion); // Unused: self-documenting.
     PRUint16 numTables = ReadShortAt(aBuf, OffsetNumTables);
 
     // save the format and offset we want here
     PRUint32 keepOffset = 0;
     PRUint32 keepFormat = 0;
 
     PRUint8 *table = aBuf + SizeOfHeader;
     for (PRUint16 i = 0; i < numTables; ++i, table += SizeOfTable) {
diff -r 8dcf83cc8500 gfx/thebes/src/gfxFontconfigUtils.cpp
--- a/gfx/thebes/src/gfxFontconfigUtils.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/src/gfxFontconfigUtils.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -32,27 +32,85 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "gfxFontconfigUtils.h"
+#include "gfxFont.h"
 
 #include <fontconfig/fontconfig.h>
 
 #include "nsIPrefBranch.h"
 #include "nsIPrefService.h"
 #include "nsServiceManagerUtils.h"
 
 #include "nsIAtom.h"
 #include "nsCRT.h"
 
 /* static */ gfxFontconfigUtils* gfxFontconfigUtils::sUtils = nsnull;
+
+/* static */ PRUint8
+gfxFontconfigUtils::GetThebesStyle(FcPattern *aPattern)
+{
+    int slant;
+    if (FcPatternGetInteger(aPattern, FC_SLANT, 0, &slant) == FcResultMatch) {
+        if (slant == FC_SLANT_ITALIC)
+            return FONT_STYLE_ITALIC;
+        if (slant == FC_SLANT_OBLIQUE)
+            return FONT_STYLE_OBLIQUE;
+    }
+
+    return FONT_STYLE_NORMAL;
+}
+
+// OS/2 weight classes were introduced in fontconfig-2.1.93 (2003).
+#ifndef FC_WEIGHT_THIN 
+#define FC_WEIGHT_THIN              0 // 2.1.93
+#define FC_WEIGHT_EXTRALIGHT        40 // 2.1.93
+#define FC_WEIGHT_REGULAR           80 // 2.1.93
+#define FC_WEIGHT_EXTRABOLD         205 // 2.1.93
+#endif
+// book was introduced in fontconfig-2.2.90 (and so fontconfig-2.3.0 in 2005)
+#ifndef FC_WEIGHT_BOOK
+#define FC_WEIGHT_BOOK              75
+#endif
+
+/* static */ PRUint16
+gfxFontconfigUtils::GetThebesWeight(FcPattern *aPattern)
+{
+    int weight;
+    if (FcPatternGetInteger(aPattern, FC_WEIGHT, 0, &weight) != FcResultMatch)
+        return FONT_WEIGHT_NORMAL;
+
+    if (weight <= (FC_WEIGHT_THIN + FC_WEIGHT_EXTRALIGHT) / 2)
+        return 100;
+    if (weight <= (FC_WEIGHT_EXTRALIGHT + FC_WEIGHT_LIGHT) / 2)
+        return 200;
+    if (weight <= (FC_WEIGHT_LIGHT + FC_WEIGHT_BOOK) / 2)
+        return 300;
+    if (weight <= (FC_WEIGHT_REGULAR + FC_WEIGHT_MEDIUM) / 2)
+        // This includes FC_WEIGHT_BOOK
+        return 400;
+    if (weight <= (FC_WEIGHT_MEDIUM + FC_WEIGHT_DEMIBOLD) / 2)
+        return 500;
+    if (weight <= (FC_WEIGHT_DEMIBOLD + FC_WEIGHT_BOLD) / 2)
+        return 600;
+    if (weight <= (FC_WEIGHT_BOLD + FC_WEIGHT_EXTRABOLD) / 2)
+        return 700;
+    if (weight <= (FC_WEIGHT_EXTRABOLD + FC_WEIGHT_BLACK) / 2)
+        return 800;
+    if (weight <= FC_WEIGHT_BLACK)
+        return 900;
+
+    // FC_WEIGHT_EXTRABLACK was introduced in fontconfig-2.4.91 (2007)
+    return 901;
+}
 
 gfxFontconfigUtils::gfxFontconfigUtils()
 {
     mAliasTable.Init(50);
     UpdateFontListInternal(PR_TRUE);
 }
 
 nsresult
diff -r 8dcf83cc8500 gfx/thebes/src/gfxFontconfigUtils.h
--- a/gfx/thebes/src/gfxFontconfigUtils.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/src/gfxFontconfigUtils.h	Tue Sep 16 07:55:12 2008 -0500
@@ -38,16 +38,18 @@
 #ifndef GFX_FONTCONFIG_UTILS_H
 #define GFX_FONTCONFIG_UTILS_H
 
 #include "gfxPlatform.h"
 
 #include "nsTArray.h"
 #include "nsDataHashtable.h"
 
+#include <fontconfig/fontconfig.h>
+
 class gfxFontNameList : public nsTArray<nsString>
 {
 public:
     THEBES_INLINE_DECL_REFCOUNTING(gfxFontList)
     PRBool Exists(nsAString& aName);
 };
 
 class gfxFontconfigUtils {
@@ -72,16 +74,19 @@ public:
     nsresult UpdateFontList();
 
     nsresult ResolveFontName(const nsAString& aFontName,
                              gfxPlatform::FontResolverCallback aCallback,
                              void *aClosure, PRBool& aAborted);
 
     nsresult GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName);
 
+    static PRUint8 GetThebesStyle(FcPattern *aPattern); // slant
+    static PRUint16 GetThebesWeight(FcPattern *aPattern);
+
 protected:
     static gfxFontconfigUtils* sUtils;
 
     PRInt32 IsExistingFont(const nsACString& aFontName);
     nsresult GetResolvedFonts(const nsACString& aName,
                               gfxFontNameList* aResult);
 
     nsresult GetFontListInternal(nsCStringArray& aListOfFonts,
diff -r 8dcf83cc8500 gfx/thebes/src/gfxPangoFonts.cpp
--- a/gfx/thebes/src/gfxPangoFonts.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/src/gfxPangoFonts.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -1026,25 +1026,16 @@ gfxPangoFont::GetMetrics()
 
     if (pfm)
         pango_font_metrics_unref(pfm);
 
     mHasMetrics = PR_TRUE;
     return mMetrics;
 }
 
-PRUint32
-gfxPangoFont::GetGlyph(const PRUint32 aChar)
-{
-    // Ensure that null character should be missing.
-    if (aChar == 0)
-        return 0;
-    return pango_fc_font_get_glyph(PANGO_FC_FONT(GetPangoFont()), aChar);
-}
-
 nsString
 gfxPangoFont::GetUniqueName()
 {
     PangoFont *font = GetPangoFont();
     PangoFontDescription *desc = pango_font_describe(font);
     pango_font_description_unset_fields (desc, PANGO_FONT_MASK_SIZE);
     char *str = pango_font_description_to_string(desc);
     pango_font_description_free (desc);
@@ -1323,42 +1314,52 @@ SetGlyphsForCharacterGroup(const PangoGl
     PRInt32 advance = ConvertPangoToAppUnits(width, appUnitsPerDevUnit);
 
     gfxTextRun::CompressedGlyph g;
     PRBool atClusterStart = aTextRun->IsClusterStart(utf16Offset);
     // See if we fit in the compressed area.
     if (aGlyphCount == 1 && advance >= 0 && atClusterStart &&
         aGlyphs[0].geometry.x_offset == 0 &&
         aGlyphs[0].geometry.y_offset == 0 &&
+        !IS_EMPTY_GLYPH(aGlyphs[0].glyph) &&
         gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
         gfxTextRun::CompressedGlyph::IsSimpleGlyphID(aGlyphs[0].glyph)) {
         aTextRun->SetSimpleGlyph(utf16Offset,
                                  g.SetSimpleGlyph(advance, aGlyphs[0].glyph));
     } else {
         nsAutoTArray<gfxTextRun::DetailedGlyph,10> detailedGlyphs;
         if (!detailedGlyphs.AppendElements(aGlyphCount))
             return NS_ERROR_OUT_OF_MEMORY;
 
-        PRUint32 i;
-        for (i = 0; i < aGlyphCount; ++i) {
-            gfxTextRun::DetailedGlyph *details = &detailedGlyphs[i];
-            PRUint32 j = (aTextRun->IsRightToLeft()) ? aGlyphCount - 1 - i : i; 
-            const PangoGlyphInfo &glyph = aGlyphs[j];
+        PRInt32 direction = aTextRun->IsRightToLeft() ? -1 : 1;
+        PRUint32 pangoIndex = direction > 0 ? 0 : aGlyphCount - 1;
+        PRUint32 detailedIndex = 0;
+        for (PRUint32 i = 0; i < aGlyphCount; ++i) {
+            const PangoGlyphInfo &glyph = aGlyphs[pangoIndex];
+            pangoIndex += direction;
+            // The zero width characters return empty glyph ID at
+            // shaping; we should skip these.
+            if (IS_EMPTY_GLYPH(glyph.glyph))
+                continue;
+
+            gfxTextRun::DetailedGlyph *details = &detailedGlyphs[detailedIndex];
+            ++detailedIndex;
+
             details->mGlyphID = glyph.glyph;
             NS_ASSERTION(details->mGlyphID == glyph.glyph,
                          "Seriously weird glyph ID detected!");
             details->mAdvance =
                 ConvertPangoToAppUnits(glyph.geometry.width,
                                        appUnitsPerDevUnit);
             details->mXOffset =
                 float(glyph.geometry.x_offset)*appUnitsPerDevUnit/PANGO_SCALE;
             details->mYOffset =
                 float(glyph.geometry.y_offset)*appUnitsPerDevUnit/PANGO_SCALE;
         }
-        g.SetComplex(atClusterStart, PR_TRUE, aGlyphCount);
+        g.SetComplex(atClusterStart, PR_TRUE, detailedIndex);
         aTextRun->SetGlyphs(utf16Offset, g, detailedGlyphs.Elements());
     }
 
     // Check for ligatures and set *aUTF16Offset.
     const gchar *p = aUTF8;
     const gchar *end = aUTF8 + aUTF8Length;
     while (1) {
         // Skip the CompressedGlyph that we have added, but check if the
@@ -1387,17 +1388,17 @@ SetGlyphsForCharacterGroup(const PangoGl
         g.SetComplex(aTextRun->IsClusterStart(utf16Offset), PR_FALSE, 0);
         aTextRun->SetGlyphs(utf16Offset, g, nsnull);
     }
     *aUTF16Offset = utf16Offset;
     return NS_OK;
 }
 
 nsresult
-gfxPangoFontGroup::SetGlyphs(gfxTextRun *aTextRun, gfxPangoFont *aFont,
+gfxPangoFontGroup::SetGlyphs(gfxTextRun *aTextRun,
                              const gchar *aUTF8, PRUint32 aUTF8Length,
                              PRUint32 *aUTF16Offset, PangoGlyphString *aGlyphs,
                              PangoGlyphUnit aOverrideSpaceWidth,
                              PRBool aAbortOnMissingGlyph)
 {
     gint numGlyphs = aGlyphs->num_glyphs;
     PangoGlyphInfo *glyphs = aGlyphs->glyphs;
     const gint *logClusters = aGlyphs->log_clusters;
@@ -1452,22 +1453,17 @@ gfxPangoFontGroup::SetGlyphs(gfxTextRun 
         const gchar *clusterUTF8 = &aUTF8[clusterUTF8Start];
         PRUint32 clusterUTF8Length = utf8Index - clusterUTF8Start;
 
         PRBool haveMissingGlyph = PR_FALSE;
         gint glyphIndex = glyphClusterStart;
 
         // It's now unncecessary to do NUL handling here.
         do {
-            if (IS_EMPTY_GLYPH(glyphs[glyphIndex].glyph)) {
-                // The zero width characters return empty glyph ID at
-                // shaping, we should override it.
-                glyphs[glyphIndex].glyph = aFont->GetGlyph(' ');
-                glyphs[glyphIndex].geometry.width = 0;
-            } else if (IS_MISSING_GLYPH(glyphs[glyphIndex].glyph)) {
+            if (IS_MISSING_GLYPH(glyphs[glyphIndex].glyph)) {
                 // Does pango ever provide more than one glyph in the
                 // cluster if there is a missing glyph?
                 // behdad: yes
                 haveMissingGlyph = PR_TRUE;
             }
             glyphIndex++;
         } while (glyphIndex < numGlyphs && 
                  logClusters[glyphIndex] == gint(clusterUTF8Start));
@@ -1638,17 +1634,19 @@ gfxPangoFontGroup::CreateGlyphRunsItemiz
     if (lang && !GetStyle()->systemFont) {
         SetBaseFont(context, GetFontAt(0)->GetPangoFont());
     }
 
     PangoDirection dir = aTextRun->IsRightToLeft() ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR;
     GList *items = pango_itemize_with_base_dir(context, dir, aUTF8, 0, aUTF8Length, nsnull, nsnull);
 
     PRUint32 utf16Offset = 0;
+#ifdef DEBUG
     PRBool isRTL = aTextRun->IsRightToLeft();
+#endif
     GList *pos = items;
     PangoGlyphString *glyphString = pango_glyph_string_new();
     if (!glyphString)
         goto out; // OOM
 
     for (; pos && pos->data; pos = pos->next) {
         PangoItem *item = (PangoItem *)pos->data;
         NS_ASSERTION(isRTL == item->analysis.level % 2, "RTL assumption mismatch");
@@ -1690,17 +1688,17 @@ gfxPangoFontGroup::CreateGlyphRunsItemiz
             const gchar *text = p;
             do {
                 ++p;
             } while(p < end && *p != 0);
             gint len = p - text;
 
             pango_shape(text, len, &item->analysis, glyphString);
             SetupClusterBoundaries(aTextRun, text, len, utf16Offset, &item->analysis);
-            SetGlyphs(aTextRun, font, text, len, &utf16Offset, glyphString, spaceWidth, PR_FALSE);
+            SetGlyphs(aTextRun, text, len, &utf16Offset, glyphString, spaceWidth, PR_FALSE);
         }
     }
 
     aTextRun->SortGlyphRuns();
 
 out:
     if (glyphString)
         pango_glyph_string_free(glyphString);
diff -r 8dcf83cc8500 gfx/thebes/src/gfxPlatformGtk.cpp
--- a/gfx/thebes/src/gfxPlatformGtk.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/gfx/thebes/src/gfxPlatformGtk.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -41,17 +41,16 @@
 #define PANGO_ENABLE_BACKEND
 #define PANGO_ENABLE_ENGINE
 #endif
 
 #include "gfxPlatformGtk.h"
 
 #include "gfxFontconfigUtils.h"
 #ifdef MOZ_PANGO
-#include <pango/pangocairo.h>
 #include "gfxPangoFonts.h"
 #include "gfxContext.h"
 #else
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include "gfxFT2Fonts.h"
 #endif
 
@@ -84,17 +83,17 @@
 
 #include "lcms.h"
 
 #ifndef MOZ_PANGO
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #endif
 
-PRInt32 gfxPlatformGtk::sDPI = -1;
+double gfxPlatformGtk::sDPI = -1.0;
 gfxFontconfigUtils *gfxPlatformGtk::sFontconfigUtils = nsnull;
 
 #ifndef MOZ_PANGO
 typedef nsDataHashtable<nsStringHashKey, nsRefPtr<FontFamily> > FontTable;
 static FontTable *gPlatformFonts = NULL;
 static FontTable *gPlatformFontAliases = NULL;
 static FT_Library gPlatformFTLibrary = NULL;
 #endif
@@ -366,53 +365,18 @@ gfxPlatformGtk::UpdateFontList()
         int x;
         if (FcPatternGetInteger(fs->fonts[i], FC_INDEX, 0, &x) == FcResultMatch) {
             //printf(" - index: %d\n", x);
             fe->mFTFontIndex = x;
         } else {
             fe->mFTFontIndex = 0;
         }
 
-        if (FcPatternGetInteger(fs->fonts[i], FC_WEIGHT, 0, &x) == FcResultMatch) {
-            switch(x) {
-            case 0:
-                fe->mWeight = 100;
-                break;
-            case 40:
-                fe->mWeight = 200;
-                break;
-            case 50:
-                fe->mWeight = 300;
-                break;
-            case 75:
-            case 80:
-                fe->mWeight = 400;
-                break;
-            case 100:
-                fe->mWeight = 500;
-                break;
-            case 180:
-                fe->mWeight = 600;
-                break;
-            case 200:
-                fe->mWeight = 700;
-                break;
-            case 205:
-                fe->mWeight = 800;
-                break;
-            case 210:
-                fe->mWeight = 900;
-                break;
-            default:
-                // rough estimate
-                fe->mWeight = (((x * 4) + 100) / 100) * 100;
-                break;
-            }
-            //printf(" - weight: %d\n", fe->mWeight);
-        }
+        fe->mWeight = gfxFontconfigUtils::GetThebesWeight(fs->fonts[i]);
+        //printf(" - weight: %d\n", fe->mWeight);
 
         fe->mItalic = PR_FALSE;
         if (FcPatternGetInteger(fs->fonts[i], FC_SLANT, 0, &x) == FcResultMatch) {
             switch (x) {
             case FC_SLANT_ITALIC:
             case FC_SLANT_OBLIQUE:
                 fe->mItalic = PR_TRUE;
             }
@@ -532,25 +496,21 @@ gfxPlatformGtk::CreateFontGroup(const ns
 
 #endif
 
 
 /* static */
 void
 gfxPlatformGtk::InitDPI()
 {
-#ifdef MOZ_PANGO
-    PangoContext *context = gdk_pango_context_get ();
-    sDPI = pango_cairo_context_get_resolution (context);
-    g_object_unref (context);
-#endif
+    sDPI = gdk_screen_get_resolution(gdk_screen_get_default());
 
-    if (sDPI <= 0) {
-	// Fall back to something sane
-	sDPI = 96;
+    if (sDPI <= 0.0) {
+        // Fall back to something sane
+        sDPI = 96.0;
     }
 }
 
 cmsHPROFILE
 gfxPlatformGtk::GetPlatformCMSOutputProfile()
 {
 #ifdef MOZ_X11
     const char EDID1_ATOM_NAME[] = "XFree86_DDC_EDID1_RAWDATA";
diff -r 8dcf83cc8500 intl/unicharutil/util/nsBidiUtils.h
--- a/intl/unicharutil/util/nsBidiUtils.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/intl/unicharutil/util/nsBidiUtils.h	Tue Sep 16 07:55:12 2008 -0500
@@ -322,17 +322,17 @@ typedef enum nsCharType nsCharType;
 
 #define IS_HEBREW_CHAR(c) (((0x0590 <= (c)) && ((c)<= 0x05FF)) || (((c) >= 0xfb1d) && ((c) <= 0xfb4f)))
 #define IS_06_CHAR(c) ((0x0600 <= (c)) && ((c)<= 0x06FF))
 #define IS_FE_CHAR(c) (((0xfb50 <= (c)) && ((c)<= 0xfbFF)) \
                        || ((0xfe70 <= (c)) && ((c)<= 0xfeFC)))
 #define IS_ARABIC_CHAR(c) ((0x0600 <= (c)) && ((c)<= 0x06FF))
 #define IS_ARABIC_ALPHABETIC(c) (IS_ARABIC_CHAR(c) && \
                                 !(IS_HINDI_DIGIT(c) || IS_FARSI_DIGIT(c) || IS_ARABIC_SEPARATOR(c)))
-#define IS_BIDI_CONTROL_CHAR(c) ((0x202a <= (c)) && ((c)<= 0x202e) \
+#define IS_BIDI_CONTROL_CHAR(c) (((0x202a <= (c)) && ((c)<= 0x202e)) \
                                 || ((c) == 0x200e) || ((c) == 0x200f))
 
 /**
  * The codepoint ranges in the following macros are based on the blocks
  *  allocated, or planned to be allocated, to right-to-left characters in the
  *  BMP (Basic Multilingual Plane) and SMP (Supplementary Multilingual Plane)
  *  according to
  *  http://unicode.org/Public/UNIDATA/extracted/DerivedBidiClass.txt and
diff -r 8dcf83cc8500 js/src/xpconnect/src/dom_quickstubs.qsconf
--- a/js/src/xpconnect/src/dom_quickstubs.qsconf	Sun Sep 14 00:37:23 2008 -0700
+++ b/js/src/xpconnect/src/dom_quickstubs.qsconf	Tue Sep 16 07:55:12 2008 -0500
@@ -200,17 +200,20 @@ members = [
     'nsIDOMNameList.getName',
     'nsIDOMNameList.contains',
     'nsIDOMNameList.containsNS',
     'nsIDOMNameList.length',
     'nsIDOMNameList.getNamespaceURI',
     'nsIDOMNSDocument.getElementsByClassName',
     'nsIDOMNSDocument.title',
     'nsIDOMNSDocument.hasFocus',
-    'nsIDOMNSDocument.location',
+    # This property is treated specially in nsDOMClassInfo in a way that
+    # would shadow any quick stub.  Also, document.location is a special
+    # case for security.
+    #'nsIDOMNSDocument.location',
     'nsIDOMNSDocument.elementFromPoint',
     'nsIDOMNSDocument.activeElement',
     'nsIDOMNSDocument.getBoxObjectFor',
     'nsIDOMXMLDocument.evaluateXPointer',
     'nsIDOMXMLDocument.evaluateFIXptr',
     'nsIDOMNSEditableElement.editor',
     'nsIDOMNSEditableElement.setUserInput',
     'nsIDOMNSElement.getClientRects',
@@ -256,17 +259,20 @@ members = [
     'nsIDOMEvent.timeStamp',
     'nsIDOMEvent.bubbles',
     'nsIDOMEvent.type',
     'nsIDOMEvent.initEvent',
     'nsIDOMEvent.stopPropagation',
     'nsIDOMEvent.eventPhase',
     'nsIDOMEventTarget.dispatchEvent',
     'nsIDOMEventTarget.removeEventListener',
-    'nsIDOMEventTarget.addEventListener',
+    # Conflicts with nsIDOMNSEventTarget.addEventListener;
+    # the conflict is specially resolved in nsDOMClassInfo.cpp.
+    # (See bug 453331.)
+    #'nsIDOMEventTarget.addEventListener',
     'nsIDOMEventListener.handleEvent',
     'nsIDOMCustomEvent.setCurrentTarget',
     'nsIDOMCustomEvent.setEventPhase',
     'nsIDOMDocumentEvent.createEvent',
     'nsIDOMMouseEvent.clientX',
     'nsIDOMMouseEvent.clientY',
     'nsIDOMMouseEvent.relatedTarget',
     'nsIDOMMouseEvent.shiftKey',
@@ -305,29 +311,30 @@ members = [
     'nsIDOMHTMLAnchorElement.target',
     'nsIDOMHTMLBaseElement.href',
     'nsIDOMHTMLBaseElement.target',
     'nsIDOMHTMLButtonElement.name',
     'nsIDOMHTMLButtonElement.form',
     'nsIDOMHTMLButtonElement.value',
     'nsIDOMHTMLButtonElement.disabled',
     'nsIDOMHTMLCollection.item',
-    # Commented out to fix bug 453105 (special case of bug 453331).
-    #'nsIDOMHTMLCollection.length',
+    # This is shadowed by nsIDOMHTMLOptionsCollection.length,
+    # but it is also present in other objects where it isn't shadowed.
+    # Quick stubs handle the shadowing the same as XPConnect.
+    'nsIDOMHTMLCollection.length',
     'nsIDOMHTMLDocument.body',
     'nsIDOMHTMLDocument.getElementsByName',
     'nsIDOMHTMLDocument.anchors',
     'nsIDOMHTMLDocument.links',
     'nsIDOMHTMLDocument.title',
     'nsIDOMHTMLDocument.URL',
     'nsIDOMHTMLDocument.referrer',
     'nsIDOMHTMLDocument.forms',
     'nsIDOMHTMLDocument.cookie',
     'nsIDOMHTMLDocument.images',
-    'nsIDOMHTMLDocument.close',
     'nsIDOMHTMLElement.className',
     'nsIDOMHTMLElement.id',
     'nsIDOMHTMLElement.title',
     'nsIDOMHTMLFormElement.elements',
     'nsIDOMHTMLFormElement.name',
     'nsIDOMHTMLFormElement.submit',
     'nsIDOMHTMLFormElement.length',
     'nsIDOMHTMLFormElement.target',
@@ -351,19 +358,17 @@ members = [
     'nsIDOMHTMLInputElement.form',
     'nsIDOMHTMLInputElement.src',
     'nsIDOMHTMLInputElement.name',
     'nsIDOMHTMLInputElement.value',
     'nsIDOMHTMLLinkElement.disabled',
     'nsIDOMHTMLOptionElement.index',
     'nsIDOMHTMLOptionElement.selected',
     'nsIDOMHTMLOptionElement.form',
-    # Commented out because it's not writable while
-    # nsIDOMNSHTMLOptionElement.text is, which causes bustage when
-    # someone tries to assign .text.  (Special case of bug 453331.)
+    # Readonly, shadowed by nsIDOMNSHTMLOptionElement.text (below).
     #'nsIDOMHTMLOptionElement.text',
     'nsIDOMHTMLOptionElement.defaultSelected',
     'nsIDOMHTMLOptionElement.value',
     'nsIDOMHTMLOptionElement.label',
     'nsIDOMHTMLOptionElement.disabled',
     'nsIDOMHTMLOptionsCollection.item',
     'nsIDOMHTMLOptionsCollection.length',
     'nsIDOMHTMLSelectElement.name',
@@ -499,51 +504,14 @@ members = [
 # for very long interface names are slightly abbreviated, and many interfaces
 # don't have their own files, just for extra wackiness.  So qsgen.py needs
 # a little help.
 #
 irregularFilenames = {
     # abbreviations
     'nsIDOMNSHTMLOptionCollection': 'nsIDOMNSHTMLOptionCollectn',
     'nsIDOMHTMLTableSectionElement': 'nsIDOMHTMLTableSectionElem',
-    'nsIDOMHTMLTableCaptionElement': 'nsIDOMHTMLTableCaptionElem',
-    'nsIDOMSVGAnimatedEnumeration': 'nsIDOMSVGAnimatedEnum',
-    'nsIDOMSVGAnimatedPreserveAspectRatio': 'nsIDOMSVGAnimPresAspRatio',
-    'nsIDOMSVGAnimatedTransformList': 'nsIDOMSVGAnimTransformList',
-    'nsIDOMSVGForeignObjectElement': 'nsIDOMSVGForeignObjectElem',
-    'nsIDOMSVGPreserveAspectRatio': 'nsIDOMSVGPresAspectRatio',
-    'nsIDOMSVGTextPositioningElement': 'nsIDOMSVGTextPositionElem',
-    'nsIDOMXULLabeledControlElement': 'nsIDOMXULLabeledControlEl',
-    'nsIDOMXULSelectControlElement': 'nsIDOMXULSelectCntrlEl',
-    'nsIDOMXULSelectControlItemElement': 'nsIDOMXULSelectCntrlItemEl',
-    'nsIDOMXULMultiSelectControlElement': 'nsIDOMXULMultSelectCntrlEl',
 
     # stowaways
+    'nsIDOMTextMetrics': 'nsIDOMCanvasRenderingContext2D',
+    'nsIDOMNSCSS2Properties': 'nsIDOMCSS2Properties',
     'nsIXPointerResult': 'nsIXPointer',
-    'nsIDOMCanvasGradient': 'nsIDOMCanvasRenderingContext2D',
-    'nsIDOMCanvasPattern': 'nsIDOMCanvasRenderingContext2D',
-    'nsIDOMTextMetrics': 'nsIDOMCanvasRenderingContext2D',
-    'nsIGeolocationUpdate': 'nsIGeolocationProvider',
-    'nsIDOMNSCSS2Properties': 'nsIDOMCSS2Properties',
-    'nsIDOMSVGPathSegArcRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegMovetoAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegLinetoAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegArcAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegMovetoRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoCubicRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegLinetoRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegLinetoVerticalAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoQuadraticRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegLinetoVerticalRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegLinetoHorizontalAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoQuadraticAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoQuadraticSmoothAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoCubicSmoothRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegClosePath': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegLinetoHorizontalRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoCubicSmoothAbs': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoQuadraticSmoothRel': 'nsIDOMSVGPathSeg',
-    'nsIDOMSVGPathSegCurvetoCubicAbs': 'nsIDOMSVGPathSeg',
-
-    # mistakes
-    'nsIDOMXULTextBoxElement': 'nsIDOMXULTextboxElement',
-    'nsIDOMDOMConstructor': 'nsIDOMConstructor'
     }
diff -r 8dcf83cc8500 js/src/xpconnect/src/qsgen.py
--- a/js/src/xpconnect/src/qsgen.py	Sun Sep 14 00:37:23 2008 -0700
+++ b/js/src/xpconnect/src/qsgen.py	Tue Sep 16 07:55:12 2008 -0500
@@ -67,20 +67,23 @@
 # quick stubs necessarily differ from XPConnect in potentially observable ways.
 # For many specific interface members, the differences are not observable from
 # scripts or don't matter enough to worry about; but you do have to be careful
 # which members you decide to generate quick stubs for.
 #
 # The complete list of known differences, as of this writing, after an
 # assiduous search:
 #
-# - Quick stubs are currently always enumerable; XPConnect properties are
-#   non-enumerable if the object being wrapped has a scriptable helper with the
-#   DONT_ENUM_STATIC_PROPS flag (in nsIXPCScriptable.scriptableFlags).  (I
-#   think this is a bug that I'll have to fix.)
+# - Quick stubs affect the handling of naming conflicts--that is, which C++
+#   method gets called when a script uses an XPCOM feature that is declared in
+#   more than one of the interfaces the object implements.  Without quick
+#   stubs, XPConnect just walks the interfaces in the order they're listed by
+#   nsClassInfo.  You get the first interface that implements a feature with
+#   that name.  With quick stubs, it's the same except that non-quick-stubbed
+#   features are shadowed.
 #
 # - Quick stub getters and setters are JSPropertyOps-- that is, they do not use
 #   JSPROP_GETTER or JSPROP_SETTER.  This means __lookupGetter__ does not work
 #   on them.  This change is visible to scripts.
 #
 # - Quick stub methods are JSFastNative, which means that when a quick stub
 #   method is called, no JS stack frame is created.  This doesn't affect
 #   Mozilla security checks because they look for scripted JSStackFrames, not
diff -r 8dcf83cc8500 js/src/xpconnect/src/xpcquickstubs.cpp
--- a/js/src/xpconnect/src/xpcquickstubs.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/js/src/xpconnect/src/xpcquickstubs.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -100,17 +100,25 @@ LookupInterfaceOrAncestor(PRUint32 table
     return p;
 }
 
 JSBool
 xpc_qsDefineQuickStubs(JSContext *cx, JSObject *proto, uintN flags,
                        PRUint32 ifacec, const nsIID **interfaces,
                        PRUint32 tableSize, const xpc_qsHashEntry *table)
 {
-    for(uint32 i = 0; i < ifacec; i++)
+    /*
+     * Walk interfaces in reverse order to behave like XPConnect when a
+     * feature is defined in more than one of the interfaces.
+     *
+     * XPCNativeSet::FindMethod returns the first matching feature it finds,
+     * searching the interfaces forward.  Here, definitions toward the
+     * front of 'interfaces' overwrite those toward the back.
+     */
+    for(uint32 i = ifacec; i-- != 0;)
     {
         const nsID &iid = *interfaces[i];
         const xpc_qsHashEntry *entry =
             LookupInterfaceOrAncestor(tableSize, table, iid);
 
         if(entry)
         {
             for(;;)
diff -r 8dcf83cc8500 js/src/xpconnect/src/xpcwrappednativejsops.cpp
--- a/js/src/xpconnect/src/xpcwrappednativejsops.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/js/src/xpconnect/src/xpcwrappednativejsops.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -1441,19 +1441,23 @@ XPCNativeScriptableShared::PopulateJSCla
     if(mFlags.WantHasInstance())
         mJSClass.base.hasInstance = XPC_WN_Helper_HasInstance;
 
     if(mFlags.WantTrace())
         mJSClass.base.mark = JS_CLASS_TRACE(XPC_WN_Helper_Trace);
     else
         mJSClass.base.mark = JS_CLASS_TRACE(XPC_WN_Shared_Trace);
 
+    // Equality is a required hook.
     mJSClass.equality = XPC_WN_Equality;
-    mJSClass.outerObject = XPC_WN_OuterObject;
-    mJSClass.innerObject = XPC_WN_InnerObject;
+
+    if(mFlags.WantOuterObject())
+        mJSClass.outerObject = XPC_WN_OuterObject;
+    if(mFlags.WantInnerObject())
+        mJSClass.innerObject = XPC_WN_InnerObject;
 }
 
 /***************************************************************************/
 /***************************************************************************/
 
 JSBool
 XPC_WN_CallMethod(JSContext *cx, JSObject *obj,
                   uintN argc, jsval *argv, jsval *vp)
diff -r 8dcf83cc8500 layout/base/nsBidi.cpp
--- a/layout/base/nsBidi.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/base/nsBidi.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -301,17 +301,17 @@ void nsBidi::Free()
 
 nsresult nsBidi::SetPara(const PRUnichar *aText, PRInt32 aLength,
                          nsBidiLevel aParaLevel, nsBidiLevel *aEmbeddingLevels)
 {
   nsBidiDirection direction;
 
   /* check the argument values */
   if(aText==NULL ||
-     (NSBIDI_MAX_EXPLICIT_LEVEL<aParaLevel) && !IS_DEFAULT_LEVEL(aParaLevel) ||
+     ((NSBIDI_MAX_EXPLICIT_LEVEL<aParaLevel) && !IS_DEFAULT_LEVEL(aParaLevel)) ||
      aLength<-1
     ) {
     return NS_ERROR_INVALID_ARG;
   }
 
   if(aLength==-1) {
     aLength=nsCRT::strlen(aText);
   }
@@ -783,17 +783,17 @@ nsresult nsBidi::CheckExplicitLevels(nsB
   *aDirection = DirectionFromFlags(flags);
   return NS_OK;
 }
 
 /* determine if the text is mixed-directional or single-directional */
 nsBidiDirection nsBidi::DirectionFromFlags(Flags aFlags)
 {
   /* if the text contains AN and neutrals, then some neutrals may become RTL */
-  if(!(aFlags&MASK_RTL || aFlags&DIRPROP_FLAG(AN) && aFlags&MASK_POSSIBLE_N)) {
+  if(!(aFlags&MASK_RTL || (aFlags&DIRPROP_FLAG(AN) && aFlags&MASK_POSSIBLE_N))) {
     return NSBIDI_LTR;
   } else if(!(aFlags&MASK_LTR)) {
     return NSBIDI_RTL;
   } else {
     return NSBIDI_MIXED;
   }
 }
 
@@ -930,17 +930,17 @@ void nsBidi::ResolveImplicitLevels(PRInt
             dirProp=EN;
           } else {
             /* (W7) */
             dirProp=L;
           }
           historyOfEN|=EN_AFTER_W4;
         } else if(prevDirProp==AN &&                    /* previous was AN */
               (nextDirProp==AN ||                   /* next is AN */
-               nextDirProp==EN && lastStrong==AL)   /* or (W2) will make it one */
+               (nextDirProp==EN && lastStrong==AL))   /* or (W2) will make it one */
              ) {
           /* (W4) */
           dirProp=AN;
         } else {
           /* (W6) */
           dirProp=O_N;
         }
         break;
@@ -951,17 +951,17 @@ void nsBidi::ResolveImplicitLevels(PRInt
             nextDirProp=dirProps[next];
           } else {
             nextDirProp=aEOR;
             break;
           }
         }
 
         if( historyOfEN&PREV_EN_AFTER_W4 ||     /* previous was EN before (W5) */
-            nextDirProp==EN && lastStrong!=AL   /* next is EN and (W2) won't make it AN */
+            (nextDirProp==EN && lastStrong!=AL)   /* next is EN and (W2) won't make it AN */
           ) {
           /* (W5) */
           if(lastStrong!=L) {
             dirProp=EN;
           } else {
             /* (W7) */
             dirProp=L;
           }
@@ -1472,17 +1472,17 @@ nsresult nsBidi::CountRuns(PRInt32* aRun
       *aRunCount = mRunCount;
     return NS_OK;
   }
 }
 
 nsresult nsBidi::GetVisualRun(PRInt32 aRunIndex, PRInt32 *aLogicalStart, PRInt32 *aLength, nsBidiDirection *aDirection)
 {
   if( aRunIndex<0 ||
-      mRunCount==-1 && !GetRuns() ||
+      (mRunCount==-1 && !GetRuns()) ||
       aRunIndex>=mRunCount
     ) {
     *aDirection = NSBIDI_LTR;
     return NS_OK;
   } else {
     PRInt32 start=mRuns[aRunIndex].logicalStart;
     if(aLogicalStart!=NULL) {
       *aLogicalStart=GET_INDEX(start);
diff -r 8dcf83cc8500 layout/base/nsCaret.cpp
--- a/layout/base/nsCaret.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/base/nsCaret.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -785,18 +785,18 @@ nsCaret::GetCaretFrameForNodeOffset(nsIC
         levelBefore = levels.mLevelBefore;
         levelAfter = levels.mLevelAfter;
 
         if ((levelBefore != levelAfter) || (aBidiLevel != levelBefore))
         {
           aBidiLevel = PR_MAX(aBidiLevel, PR_MIN(levelBefore, levelAfter));                                  // rule c3
           aBidiLevel = PR_MIN(aBidiLevel, PR_MAX(levelBefore, levelAfter));                                  // rule c4
           if (aBidiLevel == levelBefore                                                                      // rule c1
-              || aBidiLevel > levelBefore && aBidiLevel < levelAfter && !((aBidiLevel ^ levelBefore) & 1)    // rule c5
-              || aBidiLevel < levelBefore && aBidiLevel > levelAfter && !((aBidiLevel ^ levelBefore) & 1))   // rule c9
+              || (aBidiLevel > levelBefore && aBidiLevel < levelAfter && !((aBidiLevel ^ levelBefore) & 1))    // rule c5
+              || (aBidiLevel < levelBefore && aBidiLevel > levelAfter && !((aBidiLevel ^ levelBefore) & 1)))  // rule c9
           {
             if (theFrame != frameBefore)
             {
               if (frameBefore) // if there is a frameBefore, move into it
               {
                 theFrame = frameBefore;
                 theFrame->GetOffsets(start, end);
                 theFrameOffset = end;
@@ -816,18 +816,18 @@ nsCaret::GetCaretFrameForNodeOffset(nsIC
                     theFrame = pos.mResultFrame;
                     theFrameOffset = pos.mContentOffset;
                   }
                 }
               }
             }
           }
           else if (aBidiLevel == levelAfter                                                                     // rule c2
-                   || aBidiLevel > levelBefore && aBidiLevel < levelAfter && !((aBidiLevel ^ levelAfter) & 1)   // rule c6  
-                   || aBidiLevel < levelBefore && aBidiLevel > levelAfter && !((aBidiLevel ^ levelAfter) & 1))  // rule c10
+                   || (aBidiLevel > levelBefore && aBidiLevel < levelAfter && !((aBidiLevel ^ levelAfter) & 1))   // rule c6
+                   || (aBidiLevel < levelBefore && aBidiLevel > levelAfter && !((aBidiLevel ^ levelAfter) & 1)))  // rule c10
           {
             if (theFrame != frameAfter)
             {
               if (frameAfter)
               {
                 // if there is a frameAfter, move into it
                 theFrame = frameAfter;
                 theFrame->GetOffsets(start, end);
diff -r 8dcf83cc8500 layout/base/nsDisplayList.cpp
--- a/layout/base/nsDisplayList.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/base/nsDisplayList.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -1324,17 +1324,17 @@ nsRect nsDisplayTransform::UntransformRe
 
   return nsLayoutUtils::MatrixTransformRect(aUntransformedBounds, matrix,
                                             factor);
 }
 
 #ifdef MOZ_SVG
 nsDisplaySVGEffects::nsDisplaySVGEffects(nsIFrame* aFrame, nsDisplayList* aList)
     : nsDisplayWrapList(aFrame, aList), mEffectsFrame(aFrame),
-      mBounds(aFrame->GetOverflowRect())
+      mBounds(aFrame->GetOverflowRectRelativeToSelf())
 {
   MOZ_COUNT_CTOR(nsDisplaySVGEffects);
 }
 
 #ifdef NS_BUILD_REFCNT_LOGGING
 nsDisplaySVGEffects::~nsDisplaySVGEffects()
 {
   MOZ_COUNT_DTOR(nsDisplaySVGEffects);
diff -r 8dcf83cc8500 layout/forms/nsTextControlFrame.cpp
--- a/layout/forms/nsTextControlFrame.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/forms/nsTextControlFrame.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -490,18 +490,18 @@ nsTextInputListener::EditAction()
   editor->GetTransactionManager(getter_AddRefs(manager));
   NS_ENSURE_TRUE(manager, NS_ERROR_FAILURE);
 
   // Get the number of undo / redo items
   PRInt32 numUndoItems = 0;
   PRInt32 numRedoItems = 0;
   manager->GetNumberOfUndoItems(&numUndoItems);
   manager->GetNumberOfRedoItems(&numRedoItems);
-  if (numUndoItems && !mHadUndoItems || !numUndoItems && mHadUndoItems ||
-      numRedoItems && !mHadRedoItems || !numRedoItems && mHadRedoItems) {
+  if ((numUndoItems && !mHadUndoItems) || (!numUndoItems && mHadUndoItems) ||
+      (numRedoItems && !mHadRedoItems) || (!numRedoItems && mHadRedoItems)) {
     // Modify the menu if undo or redo items are different
     UpdateTextInputCommands(NS_LITERAL_STRING("undo"));
 
     mHadUndoItems = numUndoItems != 0;
     mHadRedoItems = numRedoItems != 0;
   }
 
   // Make sure we know we were changed (do NOT set this to false if there are
diff -r 8dcf83cc8500 layout/generic/nsFrame.cpp
--- a/layout/generic/nsFrame.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/generic/nsFrame.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -3915,16 +3915,32 @@ nsIFrame::GetOverflowRect() const
   // this method will be fixed up.
 
   if (GetStateBits() & NS_FRAME_OUTSIDE_CHILDREN)
     return *const_cast<nsIFrame*>(this)->GetOverflowAreaProperty(PR_FALSE);
   // NOTE this won't return accurate info if the overflow rect was updated
   // but the mRect hasn't been set yet!
   return nsRect(nsPoint(0, 0), GetSize());
 }
+
+nsRect
+nsIFrame::GetOverflowRectRelativeToParent() const
+{
+  return GetOverflowRect() + mRect.TopLeft();
+}
+  
+nsRect
+nsIFrame::GetOverflowRectRelativeToSelf() const
+{
+  if (!(mState & NS_FRAME_MAY_BE_TRANSFORMED) ||
+      !GetStyleDisplay()->HasTransform())
+    return GetOverflowRect();
+  return *static_cast<nsRect*>
+    (GetProperty(nsGkAtoms::preEffectsBBoxProperty));
+}
   
 void
 nsFrame::CheckInvalidateSizeChange(nsHTMLReflowMetrics& aNewDesiredSize)
 {
   nsIFrame::CheckInvalidateSizeChange(mRect, GetOverflowRect(), aNewDesiredSize);
 }
 
 void
@@ -4460,18 +4476,18 @@ nsFrame::GetPointFromOffset(PRInt32 inOf
   nsPoint bottomLeft(0, 0);
   if (mContent)
   {
     nsIContent* newContent = mContent->GetParent();
     if (newContent){
       PRInt32 newOffset = newContent->IndexOf(mContent);
 
       PRBool isRTL = (NS_GET_EMBEDDING_LEVEL(this) & 1) == 1;
-      if (!isRTL && inOffset > newOffset ||
-          isRTL && inOffset <= newOffset)
+      if ((!isRTL && inOffset > newOffset) ||
+          (isRTL && inOffset <= newOffset))
         bottomLeft.x = GetRect().width;
     }
   }
   *outPoint = bottomLeft;
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -4794,17 +4810,17 @@ FindBlockFrameOrBR(nsIFrame* aFrame, nsD
   nsresult rv = aFrame->QueryInterface(NS_GET_IID(nsIFormControlFrame), (void**)&fcf);
   if (NS_SUCCEEDED(rv))
     return result;
   
   // Check the frame itself
   // Fall through "special" block frames because their mContent is the content
   // of the inline frames they were created from. The first/last child of
   // such frames is the real block frame we're looking for.
-  if (nsLayoutUtils::GetAsBlock(aFrame) && !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) ||
+  if ((nsLayoutUtils::GetAsBlock(aFrame) && !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) ||
       aFrame->GetType() == nsGkAtoms::brFrame) {
     nsIContent* content = aFrame->GetContent();
     result.mContent = content->GetParent();
     // In some cases (bug 310589, bug 370174) we end up here with a null content.
     // This probably shouldn't ever happen, but since it sometimes does, we want
     // to avoid crashing here.
     NS_ASSERTION(result.mContent, "Unexpected orphan content");
     if (result.mContent)
@@ -5017,17 +5033,17 @@ nsIFrame::PeekOffset(nsPeekOffsetStruct*
           PRBool jumpedLine;
           result =
             current->GetFrameFromDirection(aPos->mDirection, aPos->mVisual,
                                            aPos->mJumpLines, aPos->mScrollViewStop,
                                            &nextFrame, &nextFrameOffset, &jumpedLine);
           // We can't jump lines if we're looking for whitespace following
           // non-whitespace, and we already encountered non-whitespace.
           if (NS_FAILED(result) ||
-              jumpedLine && !wordSelectEatSpace && state.mSawBeforeType) {
+              (jumpedLine && !wordSelectEatSpace && state.mSawBeforeType)) {
             done = PR_TRUE;
           } else {
             if (jumpedLine) {
               state.mContext.Truncate();
             }
             current = nextFrame;
             offset = nextFrameOffset;
             // Jumping a line is equivalent to encountering whitespace
@@ -5383,17 +5399,17 @@ nsIFrame::GetFrameFromDirection(nsDirect
     if (aVisual && presContext->BidiEnabled()) {
       PRBool lineIsRTL;                                                             
       it->GetDirection(&lineIsRTL);
       PRBool isReordered;
       result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
       nsIFrame** framePtr = aDirection == eDirPrevious ? &firstFrame : &lastFrame;
       if (*framePtr) {
         nsBidiLevel embeddingLevel = nsBidiPresUtils::GetFrameEmbeddingLevel(*framePtr);
-        if (((embeddingLevel & 1) && lineIsRTL || !(embeddingLevel & 1) && !lineIsRTL) ==
+        if ((((embeddingLevel & 1) && lineIsRTL) || (!(embeddingLevel & 1) && !lineIsRTL)) ==
             (aDirection == eDirPrevious)) {
           nsFrame::GetFirstLeaf(presContext, framePtr);
         } else {
           nsFrame::GetLastLeaf(presContext, framePtr);
         }
         atLineEdge = *framePtr == traversedFrame;
       } else {
         atLineEdge = PR_TRUE;
@@ -5593,55 +5609,58 @@ nsIFrame::FinishAndStoreOverflow(nsRect*
   // Overflow area must always include the frame's top-left and bottom-right,
   // even if the frame rect is empty.
   // Pending a real fix for bug 426879, don't do this for inline frames
   // with zero width.
   if (aNewSize.width != 0 || !IsInlineFrame(this))
     aOverflowArea->UnionRectIncludeEmpty(*aOverflowArea,
                                          nsRect(nsPoint(0, 0), aNewSize));
 
-  /* If we're transformed, transform the overflow rect by the current transformation. */
-  if ((mState & NS_FRAME_MAY_BE_TRANSFORMED) && 
-      GetStyleDisplay()->HasTransform()) {
-    /* Since our size might not actually have been computed yet, we need to make sure that we use the
-     * correct dimensions by overriding the stored bounding rectangle with the value the caller has
-     * ensured us we'll use.
-     */
-    nsRect newBounds(nsPoint(0, 0), aNewSize);
-    *aOverflowArea = nsDisplayTransform::TransformRect(*aOverflowArea, this, nsPoint(0, 0), &newBounds);
-  }
-  
   PRBool geometricOverflow =
     aOverflowArea->x < 0 || aOverflowArea->y < 0 ||
     aOverflowArea->XMost() > aNewSize.width || aOverflowArea->YMost() > aNewSize.height;
   // Clear geometric overflow area if we clip our children
   NS_ASSERTION((disp->mOverflowY == NS_STYLE_OVERFLOW_CLIP) ==
                (disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP),
                "If one overflow is clip, the other should be too");
   if (geometricOverflow &&
       disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP) {
     *aOverflowArea = nsRect(nsPoint(0, 0), aNewSize);
     geometricOverflow = PR_FALSE;
   }
 
-  nsRect overflowRect = GetAdditionalOverflow(*aOverflowArea, aNewSize);
-
-  if (overflowRect != nsRect(nsPoint(0, 0), aNewSize)) {
+  *aOverflowArea = GetAdditionalOverflow(*aOverflowArea, aNewSize);
+
+  /* If we're transformed, transform the overflow rect by the current transformation. */
+  if ((mState & NS_FRAME_MAY_BE_TRANSFORMED) && 
+      GetStyleDisplay()->HasTransform()) {
+    // Save overflow area before the transform
+    SetRectProperty(this, nsGkAtoms::preTransformBBoxProperty, *aOverflowArea);
+
+    /* Since our size might not actually have been computed yet, we need to make sure that we use the
+     * correct dimensions by overriding the stored bounding rectangle with the value the caller has
+     * ensured us we'll use.
+     */
+    nsRect newBounds(nsPoint(0, 0), aNewSize);
+    *aOverflowArea = nsDisplayTransform::TransformRect(*aOverflowArea, this, nsPoint(0, 0), &newBounds);
+  }
+  
+  if (*aOverflowArea != nsRect(nsPoint(0, 0), aNewSize)) {
     mState |= NS_FRAME_OUTSIDE_CHILDREN;
     nsRect* overflowArea = GetOverflowAreaProperty(PR_TRUE); 
     NS_ASSERTION(overflowArea, "should have created rect");
-    *aOverflowArea = *overflowArea = overflowRect;
-  } 
+    *overflowArea = *aOverflowArea;
+  }
   else {
     if (mState & NS_FRAME_OUTSIDE_CHILDREN) {
       // remove the previously stored overflow area 
       DeleteProperty(nsGkAtoms::overflowAreaProperty);
     }
     mState &= ~NS_FRAME_OUTSIDE_CHILDREN;
-  }   
+  }
 }
 
 void
 nsFrame::ConsiderChildOverflow(nsRect&   aOverflowArea,
                                nsIFrame* aChildFrame)
 {
   const nsStyleDisplay* disp = GetStyleDisplay();
   // check here also for hidden as table frames (table, tr and td) currently 
diff -r 8dcf83cc8500 layout/generic/nsIFrame.h
--- a/layout/generic/nsIFrame.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/generic/nsIFrame.h	Tue Sep 16 07:55:12 2008 -0500
@@ -100,20 +100,20 @@ struct nsPoint;
 struct nsPoint;
 struct nsRect;
 struct nsSize;
 struct nsMargin;
 
 typedef class nsIFrame nsIBox;
 
 // IID for the nsIFrame interface
-// 98a0c040-09cf-408b-b55f-321b4f8d9d67
+// bc99463c-5ff7-4ff3-b2c8-b4172646f793
 #define NS_IFRAME_IID \
-    { 0x98a0c040, 0x09cf, 0x408b, \
-      { 0xb5, 0x5f, 0x32, 0x1b, 0x4f, 0x8d, 0x9d, 0x67 } }
+{ 0xbc99463c, 0x5ff7, 0x4ff3, \
+  { 0xb2, 0xc8, 0xb4, 0x17, 0x26, 0x46, 0xf7, 0x93 } }
 
 /**
  * Indication of how the frame can be split. This is used when doing runaround
  * of floats, and when pulling up child frames from a next-in-flow.
  *
  * The choices are splittable, not splittable at all, and splittable in
  * a non-rectangular fashion. This last type only applies to block-level
  * elements, and indicates whether splitting can be used when doing runaround.
@@ -348,20 +348,20 @@ typedef PRUint32 nsReflowStatus;
   (0 != ((status) & NS_FRAME_OVERFLOW_INCOMPLETE))
 
 #define NS_FRAME_IS_FULLY_COMPLETE(status) \
   (NS_FRAME_IS_COMPLETE(status) && !NS_FRAME_OVERFLOW_IS_INCOMPLETE(status))
 
 // These macros set or switch incompete statuses without touching th
 // NS_FRAME_REFLOW_NEXTINFLOW bit.
 #define NS_FRAME_SET_INCOMPLETE(status) \
-  status = status & ~NS_FRAME_OVERFLOW_INCOMPLETE | NS_FRAME_NOT_COMPLETE
+  status = (status & ~NS_FRAME_OVERFLOW_INCOMPLETE) | NS_FRAME_NOT_COMPLETE
 
 #define NS_FRAME_SET_OVERFLOW_INCOMPLETE(status) \
-  status = status & ~NS_FRAME_NOT_COMPLETE | NS_FRAME_OVERFLOW_INCOMPLETE
+  status = (status & ~NS_FRAME_NOT_COMPLETE) | NS_FRAME_OVERFLOW_INCOMPLETE
 
 // This macro tests to see if an nsReflowStatus is an error value
 // or just a regular return value
 #define NS_IS_REFLOW_ERROR(_status) (PRInt32(_status) < 0)
 
 /**
  * Extensions to the reflow status bits defined by nsIFrameReflow
  */
@@ -1726,19 +1726,51 @@ public:
    *
    * The NS_FRAME_OUTSIDE_CHILDREN state bit is set when this overflow rect
    * is different from nsRect(0, 0, GetRect().width, GetRect().height).
    * XXX Note: because of a space optimization using the formula above,
    * during reflow this function does not give accurate data if
    * FinishAndStoreOverflow has been called but mRect hasn't yet been
    * updated yet.
    *
-   * @return the rect relative to this frame's origin
+   * @return the rect relative to this frame's origin, but after
+   * CSS transforms have been applied (i.e. not really this frame's coordinate
+   * system, and may not contain the frame's border-box, e.g. if there
+   * is a CSS transform scaling it down)
    */
   nsRect GetOverflowRect() const;
+
+  /**
+   * Computes a rect that encompasses everything that might be painted by
+   * this frame.  This includes this frame, all its descendent frames, this
+   * frame's outline, and descentant frames' outline, but does not include
+   * areas clipped out by the CSS "overflow" and "clip" properties.
+   *
+   * The NS_FRAME_OUTSIDE_CHILDREN state bit is set when this overflow rect
+   * is different from nsRect(0, 0, GetRect().width, GetRect().height).
+   * XXX Note: because of a space optimization using the formula above,
+   * during reflow this function does not give accurate data if
+   * FinishAndStoreOverflow has been called but mRect hasn't yet been
+   * updated yet.
+   *
+   * @return the rect relative to the parent frame, in the parent frame's
+   * coordinate system
+   */
+  nsRect GetOverflowRectRelativeToParent() const;
+
+  /**
+   * Computes a rect that encompasses everything that might be painted by
+   * this frame.  This includes this frame, all its descendent frames, this
+   * frame's outline, and descentant frames' outline, but does not include
+   * areas clipped out by the CSS "overflow" and "clip" properties.
+   *
+   * @return the rect relative to this frame, before any CSS transforms have
+   * been applied, i.e. in this frame's coordinate system
+   */
+  nsRect GetOverflowRectRelativeToSelf() const;
 
   /**
    * Set/unset the NS_FRAME_OUTSIDE_CHILDREN flag and store the overflow area
    * as a frame property in the frame manager so that it can be retrieved
    * later without reflowing the frame.
    */
   void FinishAndStoreOverflow(nsRect* aOverflowArea, nsSize aNewSize);
 
diff -r 8dcf83cc8500 layout/generic/nsImageFrame.cpp
--- a/layout/generic/nsImageFrame.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/generic/nsImageFrame.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -1430,19 +1430,19 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsImageFrame::HandleEvent(nsPresContext* aPresContext,
                           nsGUIEvent* aEvent,
                           nsEventStatus* aEventStatus)
 {
   NS_ENSURE_ARG_POINTER(aEventStatus);
   nsImageMap* map;
 
-  if (aEvent->eventStructType == NS_MOUSE_EVENT &&
-      (aEvent->message == NS_MOUSE_BUTTON_UP && 
-      static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) ||
+  if ((aEvent->eventStructType == NS_MOUSE_EVENT &&
+       aEvent->message == NS_MOUSE_BUTTON_UP && 
+       static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) ||
       aEvent->message == NS_MOUSE_MOVE) {
     map = GetImageMap(aPresContext);
     PRBool isServerMap = IsServerImageMap();
     if ((nsnull != map) || isServerMap) {
       nsIntPoint p;
       TranslateEventCoords(
         nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this), p);
       PRBool inside = PR_FALSE;
diff -r 8dcf83cc8500 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/generic/nsObjectFrame.cpp	Tue Sep 16 07:55:12 2008 -0500
@@ -1001,19 +1001,19 @@ nsObjectFrame::IsHidden(PRBool aCheckVis
     // on the tag...
 
     // HIDDEN w/ no attributes gets translated as we are hidden for
     // compatibility w/ 4.x and IE so we don't create a non-painting
     // widget in layout. See bug 188959.
     nsAutoString hidden;
     if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::hidden, hidden) &&
        (hidden.IsEmpty() ||
-        !hidden.LowerCaseEqualsLiteral("false") &&
-        !hidden.LowerCaseEqualsLiteral("no") &&
-        !hidden.LowerCaseEqualsLiteral("off"))) {
+        (!hidden.LowerCaseEqualsLiteral("false") &&
+         !hidden.LowerCaseEqualsLiteral("no") &&
+         !hidden.LowerCaseEqualsLiteral("off")))) {
       return PR_TRUE;
     }
   }
 
   return PR_FALSE;
 }
 
 nsPoint nsObjectFrame::GetWindowOriginInPixels(PRBool aWindowless)
diff -r 8dcf83cc8500 layout/mathml/content/src/mathml.css
--- a/layout/mathml/content/src/mathml.css	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/mathml/content/src/mathml.css	Tue Sep 16 07:55:12 2008 -0500
@@ -221,16 +221,17 @@ merror {
 /**************************************************************************/
 /* mtable and its related tags                                            */
 /**************************************************************************/
 
 mtable {
   display: inline-table;
   border-collapse: separate;
   border-spacing: 0;
+  text-indent: 0;
 }
 mtable[frame="none"] {
   border: none;
 }
 mtable[frame="solid"] {
   border: solid thin;
 }
 mtable[frame="dashed"] {
diff -r 8dcf83cc8500 layout/reftests/bugs/212563-1-inner.html
--- a/layout/reftests/bugs/212563-1-inner.html	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/reftests/bugs/212563-1-inner.html	Tue Sep 16 07:55:12 2008 -0500
@@ -1,3 +1,3 @@
 <frameset resizable="yes" rows="100%">
-  <frame src="data:text/html,<body onload=%22var d = parent.document; d.write('<body>foo'); d.close();%22>">
+  <frame src="data:text/html,<body onload=%22var d = parent.document; d.write('<body onload=parent.document.documentElement.removeAttribute(\'class\');>foo'); d.close();%22>">
 </frameset>
diff -r 8dcf83cc8500 layout/reftests/bugs/212563-1-ref.html
--- a/layout/reftests/bugs/212563-1-ref.html	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/reftests/bugs/212563-1-ref.html	Tue Sep 16 07:55:12 2008 -0500
@@ -1,1 +1,7 @@
+<html>
+<head>
+</head>
+<body>
 <iframe src="212563-1-ref-inner.html"></iframe>
+</body>
+</html>
diff -r 8dcf83cc8500 layout/reftests/bugs/212563-1.html
--- a/layout/reftests/bugs/212563-1.html	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/reftests/bugs/212563-1.html	Tue Sep 16 07:55:12 2008 -0500
@@ -1,1 +1,7 @@
+<html class="reftest-wait">
+<head>
+</head>
+<body>
 <iframe src="212563-1-inner.html"></iframe>
+</body>
+</html>
diff -r 8dcf83cc8500 layout/reftests/bugs/455280-1-ref.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/455280-1-ref.xhtml	Tue Sep 16 07:55:12 2008 -0500
@@ -0,0 +1,10 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml">
+<body>
+  <div style="width:160px; height:160px; position:relative; left:120px; top:120px; background:lime;"></div>
+</body>
+</html>
+
diff -r 8dcf83cc8500 layout/reftests/bugs/455280-1.xhtml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/bugs/455280-1.xhtml	Tue Sep 16 07:55:12 2008 -0500
@@ -0,0 +1,16 @@
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<html xmlns="http://www.w3.org/1999/xhtml"
+      xmlns:svg="http://www.w3.org/2000/svg">
+<body>
+  <div style="width:400px; height:400px; clip-path: url(#c1); background:lime; -moz-transform:scale(0.5)"></div>
+  <svg:svg height="0">
+    <svg:clipPath id="c1" clipPathUnits="objectBoundingBox">
+      <svg:rect x="0.1" y="0.1" width="0.8" height="0.8"/>
+    </svg:clipPath>
+  </svg:svg>
+</body>
+</html>
+
diff -r 8dcf83cc8500 layout/reftests/bugs/reftest.list
--- a/layout/reftests/bugs/reftest.list	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/reftests/bugs/reftest.list	Tue Sep 16 07:55:13 2008 -0500
@@ -907,8 +907,10 @@ fails == 441259-2.html 441259-2-ref.html
 == 444015-1.html 444015-1-ref.html
 # == 448987.html 448987-ref.html  # Disabled for now - it needs privileges
 == 449171-1.html 449171-ref.html
 == 449519-1.html 449519-1-ref.html
 # == 449653-1.html 449653-1-ref.html # Disabled for now - it needs privileges
 == 450670-1.html 450670-1-ref.html
 == 451168-1.html 451168-1-ref.html
 == 454361.html about:blank
+== 455280-1.xhtml 455280-1-ref.xhtml
+
diff -r 8dcf83cc8500 layout/reftests/svg/dynamic-feFlood-01.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg/dynamic-feFlood-01.svg	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,24 @@
+<?xml version="1.0"?>
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg version="1.1" xmlns="http://www.w3.org/2000/svg" onload="m();">
+	<title>Testcase for dynamic feFlood changes</title>
+	<!-- From https://bugzilla.mozilla.org/show_bug.cgi?id=448831 -->
+	<script>
+		function m() {
+		document.getElementById("feFlood").setAttribute("flood-color", "lime");
+		}
+	</script>
+
+	<defs>
+		<filter id="f1" filterUnits="objectBoundingBox" primitiveUnits="objectBoundingBox"
+				x="0" y="0" width="1" height="1">
+	    	<feFlood id="feFlood" x="0" y="0" width="100%" height="100%" flood-color="red"/>
+	    </filter>
+	</defs>
+	<g filter="url(#f1)">
+		<rect x="0" y="0" width="100%" height="100%" fill="red" opacity="0"/>
+	</g>
+</svg>
diff -r 8dcf83cc8500 layout/reftests/svg/dynamic-feImage-01.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/svg/dynamic-feImage-01.svg	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+     Any copyright is dedicated to the Public Domain.
+     http://creativecommons.org/licenses/publicdomain/
+-->
+<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" onload="m();">
+	<title>Testcase for dynamic feImage changes</title>
+	<!-- From https://bugzilla.mozilla.org/show_bug.cgi?id=448831 -->
+	<script>
+		function m() {
+		var xlinkNS = "http://www.w3.org/1999/xlink";
+		document.getElementById("feImage").removeAttributeNS(xlinkNS, "href");
+		}
+	</script>
+
+	<defs>
+		<filter id="f1" filterUnits="objectBoundingBox" primitiveUnits="objectBoundingBox" x="0" y="0" width="1" height="1">
+			<feImage id="feImage" x="0" y="0" width="100%" height="100%" style="color-interpolation-filters: srgb;"/>
+		</filter>
+	</defs>
+	<rect width="100%" height="100%" fill="lime"/>
+	<rect width="100%" height="100%" filter="url(#f1)"/>
+</svg>
diff -r 8dcf83cc8500 layout/reftests/svg/reftest.list
--- a/layout/reftests/svg/reftest.list	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/reftests/svg/reftest.list	Tue Sep 16 07:55:13 2008 -0500
@@ -13,16 +13,17 @@ include moz-only/reftest.list
 == clipPath-basic-01.svg pass.svg
 == clip-surface-clone-01.svg clip-surface-clone-01-ref.svg
 == conditions-01.svg pass.svg
 == currentColor-01.svg pass.svg
 == currentColor-02.svg pass.svg
 == currentColor-03.svg pass.svg
 == dynamic-conditions-01.svg pass.svg
 == dynamic-clipPath-01.svg pass.svg
+== dynamic-feFlood-01.svg pass.svg
 == dynamic-link-style-01.svg pass.svg
 == dynamic-rect-01.svg dynamic-rect-01-ref.svg
 == dynamic-rect-02.svg dynamic-rect-02-ref.svg
 == dynamic-rect-03.svg dynamic-rect-03-ref.svg
 == dynamic-rect-04.xhtml pass.svg
 == dynamic-reflow-01.svg dynamic-reflow-01-ref.svg
 == dynamic-switch-01.svg pass.svg
 == dynamic-text-01.svg dynamic-text-01-ref.svg
diff -r 8dcf83cc8500 layout/reftests/text/cgj-01-ref.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/text/cgj-01-ref.html	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<!-- U+034F Combining Grapheme Joiner test #1.
+     The CGJ should not be visible,
+     nor affect the width of the first cluster. -->
+<html>
+ <head>
+  <title>CGJ test</title>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <style type="text/css">
+  body {   
+    font-size: 35px;
+  }
+  </style>
+ </head>
+ <body lang="fr">
+   <p>a&#x300;b</p>
+ </body>
+</html>
diff -r 8dcf83cc8500 layout/reftests/text/cgj-01.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/layout/reftests/text/cgj-01.html	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<!-- U+034F Combining Grapheme Joiner test #1.
+     The CGJ should not be visible,
+     nor affect the width of the first cluster. -->
+<html>
+ <head>
+  <title>CGJ test</title>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <style type="text/css">
+  body {   
+    font-size: 35px;
+  }
+  </style>
+ </head>
+ <body lang="fr">
+   <p>a&#x300;&#x34f;b</p>
+ </body>
+</html>
diff -r 8dcf83cc8500 layout/reftests/text/reftest.list
--- a/layout/reftests/text/reftest.list	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/reftests/text/reftest.list	Tue Sep 16 07:55:13 2008 -0500
@@ -16,10 +16,11 @@ random-if(MOZ_WIDGET_TOOLKIT=="gtk2") ==
 random-if(MOZ_WIDGET_TOOLKIT=="gtk2") == wordwrap-03.html wordwrap-03-ref.html # Bad fonts on test boxes
 == wordwrap-04.html wordwrap-04-ref.html
 == wordwrap-05.html wordwrap-05-ref.html
 == wordwrap-06.html wordwrap-06-ref.html
 == wordwrap-07.html wordwrap-07-ref.html
 == zwnj-01.html zwnj-01-ref.html
 == zwnj-02.html zwnj-02-ref.html
 random-if(MOZ_WIDGET_TOOLKIT=="gtk2") != zwnj-01.html zwnj-02-ref.html # Bad fonts on the tinderbox -- works locally
+== cgj-01.html cgj-01-ref.html
 == 444656.html 444656-ref.html
 == 449555-1.html 449555-1-ref.html
diff -r 8dcf83cc8500 layout/style/nsCSSLoader.h
--- a/layout/style/nsCSSLoader.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/style/nsCSSLoader.h	Tue Sep 16 07:55:13 2008 -0500
@@ -257,17 +257,17 @@ public:
 
     if (!mPrincipal != !aKey->mPrincipal) {
       // One or the other has a principal, but not both... not equal
       return PR_FALSE;
     }
        
     PRBool eq;
     return !mPrincipal ||
-      NS_SUCCEEDED(mPrincipal->Equals(aKey->mPrincipal, &eq)) && eq;
+      (NS_SUCCEEDED(mPrincipal->Equals(aKey->mPrincipal, &eq)) && eq);
   }
  
   static const nsURIAndPrincipalHashKey*
   KeyToPointer(nsURIAndPrincipalHashKey* aKey) { return aKey; }
   static PLDHashNumber HashKey(const nsURIAndPrincipalHashKey* aKey) {
     return nsURIHashKey::HashKey(aKey->mKey);
   }
      
diff -r 8dcf83cc8500 layout/style/xbl-marquee/jar.mn
--- a/layout/style/xbl-marquee/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/style/xbl-marquee/jar.mn	Tue Sep 16 07:55:13 2008 -0500
@@ -1,8 +1,4 @@ comm.jar:
 comm.jar:
-#ifdef MOZ_XUL_APP
 %   content xbl-marquee %content/xbl-marquee/ xpcnativewrappers=yes
-#else
-    content/xbl-marquee/contents.rdf
-#endif
     content/xbl-marquee/xbl-marquee.xml
     content/xbl-marquee/xbl-marquee.css
diff -r 8dcf83cc8500 layout/svg/base/src/nsSVGInnerSVGFrame.cpp
--- a/layout/svg/base/src/nsSVGInnerSVGFrame.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/svg/base/src/nsSVGInnerSVGFrame.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -189,21 +189,21 @@ nsSVGInnerSVGFrame::NotifySVGChanged(PRU
 
     nsSVGSVGElement *svg = static_cast<nsSVGSVGElement*>(mContent);
 
     // Coordinate context changes affect mCanvasTM if we have a
     // percentage 'x' or 'y', or if we have a percentage 'width' or 'height' AND
     // a 'viewBox'.
 
     if (!(aFlags & TRANSFORM_CHANGED) &&
-        svg->mLengthAttributes[nsSVGSVGElement::X].IsPercentage() ||
-        svg->mLengthAttributes[nsSVGSVGElement::Y].IsPercentage() ||
-        (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::viewBox) &&
-         (svg->mLengthAttributes[nsSVGSVGElement::WIDTH].IsPercentage() ||
-          svg->mLengthAttributes[nsSVGSVGElement::HEIGHT].IsPercentage()))) {
+        (svg->mLengthAttributes[nsSVGSVGElement::X].IsPercentage() ||
+         svg->mLengthAttributes[nsSVGSVGElement::Y].IsPercentage() ||
+         (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::viewBox) &&
+          (svg->mLengthAttributes[nsSVGSVGElement::WIDTH].IsPercentage() ||
+           svg->mLengthAttributes[nsSVGSVGElement::HEIGHT].IsPercentage())))) {
     
       aFlags |= TRANSFORM_CHANGED;
     }
 
     // XXX We could clear the COORD_CONTEXT_CHANGED flag in some circumstances
     // if we have a non-percentage 'width' AND 'height, or if we have a 'viewBox'
     // rect. This is because, when we have a viewBox rect, the viewBox rect
     // is the coordinate context for our children, and it isn't changing.
diff -r 8dcf83cc8500 layout/svg/base/src/nsSVGUtils.cpp
--- a/layout/svg/base/src/nsSVGUtils.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/svg/base/src/nsSVGUtils.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -800,20 +800,20 @@ nsSVGUtils::GetViewBoxTransform(float aV
   float a, d, e, f;
   a = aViewportWidth / aViewboxWidth;
   d = aViewportHeight / aViewboxHeight;
   e = 0.0f;
   f = 0.0f;
 
   if (align != nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_NONE &&
       a != d) {
-    if (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET &&
-        a < d ||
-        meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE &&
-        d < a) {
+    if ((meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET &&
+        a < d) ||
+        (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE &&
+        d < a)) {
       d = a;
       switch (align) {
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMIN:
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMIN:
         break;
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMID:
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
@@ -825,20 +825,20 @@ nsSVGUtils::GetViewBoxTransform(float aV
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMAXYMAX:
         f = aViewportHeight - a * aViewboxHeight;
         break;
       default:
         NS_NOTREACHED("Unknown value for align");
       }
     }
     else if (
-      meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET &&
-      d < a ||
-      meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE &&
-      a < d) {
+      (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_MEET &&
+      d < a) ||
+      (meetOrSlice == nsIDOMSVGPreserveAspectRatio::SVG_MEETORSLICE_SLICE &&
+      a < d)) {
       a = d;
       switch (align) {
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMIN:
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMID:
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMINYMAX:
         break;
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMIN:
       case nsIDOMSVGPreserveAspectRatio::SVG_PRESERVEASPECTRATIO_XMIDYMID:
diff -r 8dcf83cc8500 layout/svg/base/src/svg.css
--- a/layout/svg/base/src/svg.css	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/svg/base/src/svg.css	Tue Sep 16 07:55:13 2008 -0500
@@ -58,9 +58,10 @@ foreignObject {
   margin: 0 ! important;
   padding: 0 ! important;
   border-width: 0 ! important;
 }
 
 *|*::-moz-svg-foreign-content {
   display: block !important;
   position: static !important;
+  text-indent: 0;
 }
diff -r 8dcf83cc8500 layout/xul/base/src/nsMenuFrame.cpp
--- a/layout/xul/base/src/nsMenuFrame.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/layout/xul/base/src/nsMenuFrame.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -709,17 +709,17 @@ nsMenuFrame::IsSizedToPopup(nsIContent* 
 {
   PRBool sizeToPopup;
   if (aContent->Tag() == nsGkAtoms::select)
     sizeToPopup = PR_TRUE;
   else {
     nsAutoString sizedToPopup;
     aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::sizetopopup, sizedToPopup);
     sizeToPopup = sizedToPopup.EqualsLiteral("always") ||
-                  !aRequireAlways && sizedToPopup.EqualsLiteral("pref");
+                  (!aRequireAlways && sizedToPopup.EqualsLiteral("pref"));
   }
   
   return sizeToPopup;
 }
 
 nsSize
 nsMenuFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
 {
diff -r 8dcf83cc8500 modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/libpref/src/init/all.js	Tue Sep 16 07:55:13 2008 -0500
@@ -242,19 +242,16 @@ pref("print.print_footerright", "&D");
 pref("print.print_footerright", "&D");
 pref("print.show_print_progress", true);
 
 // xxxbsmedberg: more toolkit prefs
 
 // When this is set to false each window has its own PrintSettings
 // and a change in one window does not affect the others
 pref("print.use_global_printsettings", true);
-
-// Use the native dialog or the XP dialog?
-pref("print.use_native_print_dialog", false);
 
 // Save the Printings after each print job
 pref("print.save_print_settings", true);
 
 pref("print.whileInPrintPreview", true);
 
 // Cache old Presentation when going into Print Preview
 pref("print.always_cache_old_pres", false);
@@ -1464,19 +1461,16 @@ pref("layout.word_select.eat_space_to_ne
 
 // scrollbar snapping region
 pref("slider.snapMultiplier", 6);
 
 // print_extra_margin enables platforms to specify an extra gap or margin
 // around the content of the page for Print Preview only
 pref("print.print_extra_margin", 90); // twips (90 twips is an eigth of an inch)
 
-// This indicates whether it should use the native dialog or the XP Dialog
-pref("print.use_native_print_dialog", true);
-
 // Whether to extend the native dialog with information on printing frames.
 pref("print.extend_native_print_dialog", true);
 
 // Locate Java by scanning the Sun JRE installation directory with a minimum version
 // Note: Does not scan if security.enable_java is not true
 pref("plugin.scan.SunJRE", "1.3");
 
 // Locate plugins by scanning the Adobe Acrobat installation directory with a minimum version
@@ -1926,19 +1920,16 @@ pref("ui.key.generalAccessKey", -1);
 // Use 0 for disabled, 1 for Shift, 2 for Ctrl, 4 for Alt, 8 for Meta (Cmd)
 // (values can be combined, e.g. 3 for Ctrl+Shift)
 pref("ui.key.chromeAccess", 2);
 pref("ui.key.contentAccess", 2);
 
 // print_extra_margin enables platforms to specify an extra gap or margin
 // around the content of the page for Print Preview only
 pref("print.print_extra_margin", 90); // twips (90 twips is an eigth of an inch)
-
-// This indicates whether it should use the native dialog or the XP Dialog
-pref("print.use_native_print_dialog", true);
 
 // See bug 404131, topmost <panel> element wins to Dashboard on MacOSX.
 pref("ui.panel.default_level_parent", false);
 
 # XP_MACOSX
 #endif
 
 #ifdef XP_OS2
diff -r 8dcf83cc8500 modules/plugin/base/src/Makefile.in
--- a/modules/plugin/base/src/Makefile.in	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/plugin/base/src/Makefile.in	Tue Sep 16 07:55:13 2008 -0500
@@ -80,18 +80,18 @@ REQUIRES	= xpcom \
 		  locale \
 		  $(NULL)
 
 ifneq (,$(filter gtk2,$(MOZ_WIDGET_TOOLKIT)))
 REQUIRES	+= gtkxtbin
 endif
 
 CPPSRCS		= \
-		ns4xPlugin.cpp \
-		ns4xPluginInstance.cpp \
+		nsNPAPIPlugin.cpp \
+		nsNPAPIPluginInstance.cpp \
 		nsPluginHostImpl.cpp \
 		nsPluginModule.cpp \
 		nsPluginInstancePeer.cpp \
 		nsJSNPRuntime.cpp \
 		nsJVMAuthTools.cpp \
 		$(NULL)
 
 ifeq ($(OS_ARCH), BeOS)
diff -r 8dcf83cc8500 modules/plugin/base/src/ns4xPlugin.cpp
--- a/modules/plugin/base/src/ns4xPlugin.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2663 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Josh Aas <josh@mozilla.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "prtypes.h"
-#include "prmem.h"
-#include "prclist.h"
-#include "nsAutoLock.h"
-#include "ns4xPlugin.h"
-#include "ns4xPluginInstance.h"
-#include "ns4xPluginStreamListener.h"
-#include "nsIServiceManager.h"
-#include "nsThreadUtils.h"
-
-#include "nsIPluginStreamListener.h"
-#include "nsPluginsDir.h"
-#include "nsPluginSafety.h"
-#include "nsIPrefService.h"
-#include "nsIPrefBranch.h"
-#include "nsPluginLogging.h"
-
-#include "nsIPluginInstancePeer2.h"
-#include "nsIJSContextStack.h"
-
-#include "nsPIPluginInstancePeer.h"
-#include "nsIDOMElement.h"
-#include "nsIDOMDocument.h"
-#include "nsPIDOMWindow.h"
-#include "nsIDocument.h"
-#include "nsIScriptGlobalObject.h"
-#include "nsIScriptContext.h"
-#include "nsDOMJSUtils.h"
-#include "nsIPrincipal.h"
-
-#include "jscntxt.h"
-
-#include "nsIXPConnect.h"
-
-#include "nsIObserverService.h"
-#include <prinrval.h>
-
-#ifdef XP_MACOSX
-#include <Carbon/Carbon.h>
-#endif
-
-// needed for nppdf plugin
-#ifdef MOZ_WIDGET_GTK2
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include "gtk2xtbin.h"
-#endif
-
-#include "nsJSNPRuntime.h"
-
-static PRLock *sPluginThreadAsyncCallLock = nsnull;
-static PRCList sPendingAsyncCalls = PR_INIT_STATIC_CLIST(&sPendingAsyncCalls);
-
-// POST/GET stream type
-enum eNPPStreamTypeInternal {
-  eNPPStreamTypeInternal_Get,
-  eNPPStreamTypeInternal_Post
-};
-
-static NS_DEFINE_IID(kCPluginManagerCID, NS_PLUGINMANAGER_CID);
-static NS_DEFINE_IID(kPluginManagerCID, NS_PLUGINMANAGER_CID);
-static NS_DEFINE_IID(kMemoryCID, NS_MEMORY_CID);
-
-// Static stub functions that are exported to the 4.x plugin as entry
-// points via the CALLBACKS variable.
-PR_BEGIN_EXTERN_C
-
-  static NPError NP_CALLBACK
-  _requestread(NPStream *pstream, NPByteRange *rangeList);
-
-  static NPError NP_CALLBACK
-  _geturlnotify(NPP npp, const char* relativeURL, const char* target,
-                void* notifyData);
-
-  static NPError NP_CALLBACK
-  _getvalue(NPP npp, NPNVariable variable, void *r_value);
-
-  static NPError NP_CALLBACK
-  _setvalue(NPP npp, NPPVariable variable, void *r_value);
-
-  static NPError NP_CALLBACK
-  _geturl(NPP npp, const char* relativeURL, const char* target);
-
-  static NPError NP_CALLBACK
-  _posturlnotify(NPP npp, const char* relativeURL, const char *target,
-                 uint32_t len, const char *buf, NPBool file, void* notifyData);
-
-  static NPError NP_CALLBACK
-  _posturl(NPP npp, const char* relativeURL, const char *target, uint32_t len,
-              const char *buf, NPBool file);
-
-  static NPError NP_CALLBACK
-  _newstream(NPP npp, NPMIMEType type, const char* window, NPStream** pstream);
-
-  static int32_t NP_CALLBACK
-  _write(NPP npp, NPStream *pstream, int32_t len, void *buffer);
-
-  static NPError NP_CALLBACK
-  _destroystream(NPP npp, NPStream *pstream, NPError reason);
-
-  static void NP_CALLBACK
-  _status(NPP npp, const char *message);
-
-  static void NP_CALLBACK
-  _memfree (void *ptr);
-
-  static uint32_t NP_CALLBACK
-  _memflush(uint32_t size);
-
-  static void NP_CALLBACK
-  _reloadplugins(NPBool reloadPages);
-
-  static void NP_CALLBACK
-  _invalidaterect(NPP npp, NPRect *invalidRect);
-
-  static void NP_CALLBACK
-  _invalidateregion(NPP npp, NPRegion invalidRegion);
-
-  static void NP_CALLBACK
-  _forceredraw(NPP npp);
-
-  static void NP_CALLBACK
-  _pushpopupsenabledstate(NPP npp, NPBool enabled);
-
-  static void NP_CALLBACK
-  _poppopupsenabledstate(NPP npp);
-
-  typedef void(*PluginThreadCallback)(void *);
-  static void NP_CALLBACK
-  _pluginthreadasynccall(NPP instance, PluginThreadCallback func,
-                         void *userData);
-
-  static const char* NP_CALLBACK
-  _useragent(NPP npp);
-
-  static void* NP_CALLBACK
-  _memalloc (uint32_t size);
-
-  // Deprecated entry points for the old Java plugin.
-  static void* NP_CALLBACK /* OJI type: JRIEnv* */
-  _getJavaEnv(void);
-  static void* NP_CALLBACK /* OJI type: jref */
-  _getJavaPeer(NPP npp);
-
-PR_END_EXTERN_C
-
-#if defined(XP_MACOSX) && defined(__POWERPC__)
-
-#define TV2FP(tvp) _TV2FP((void *)tvp)
-
-static void*
-_TV2FP(void *tvp)
-{
-    static uint32_t glue[6] = {
-      0x3D800000, 0x618C0000, 0x800C0000, 0x804C0004, 0x7C0903A6, 0x4E800420
-    };
-    uint32_t* newGlue = NULL;
-
-    if (tvp != NULL) {
-        newGlue = (uint32_t*) malloc(sizeof(glue));
-        if (newGlue != NULL) {
-            memcpy(newGlue, glue, sizeof(glue));
-            newGlue[0] |= ((UInt32)tvp >> 16);
-            newGlue[1] |= ((UInt32)tvp & 0xFFFF);
-            MakeDataExecutable(newGlue, sizeof(glue));
-        }
-    }
-    return newGlue;
-}
-
-#define FP2TV(fp) _FP2TV((void *)fp)
-
-static void*
-_FP2TV(void *fp)
-{
-    void **newGlue = NULL;
-    if (fp != NULL) {
-        newGlue = (void**) malloc(2 * sizeof(void *));
-        if (newGlue != NULL) {
-            newGlue[0] = fp;
-            newGlue[1] = NULL;
-        }
-    }
-    return newGlue;
-}
-
-#else
-
-#define TV2FP(f) (f)
-#define FP2TV(f) (f)
-
-#endif /* XP_MACOSX && __POWERPC__ */
-
-// This function sends a notification using the observer service to any object
-// registered to listen to the "experimental-notify-plugin-call" subject.
-// Each "experimental-notify-plugin-call" notification carries with it the run
-// time value in milliseconds that the call took to execute.
-void NS_NotifyPluginCall(PRIntervalTime startTime) 
-{
-  PRIntervalTime endTime = PR_IntervalNow() - startTime;
-  nsCOMPtr<nsIObserverService> notifyUIService =
-    do_GetService("@mozilla.org/observer-service;1");
-  float runTimeInSeconds = float(endTime) / PR_TicksPerSecond();
-  nsAutoString runTimeString;
-  runTimeString.AppendFloat(runTimeInSeconds);
-  const PRUnichar* runTime = runTimeString.get();
-  notifyUIService->NotifyObservers(nsnull, "experimental-notify-plugin-call",
-                                   runTime);
-}
-
-NPNetscapeFuncs ns4xPlugin::CALLBACKS;
-
-void
-ns4xPlugin::CheckClassInitialized(void)
-{
-  static PRBool initialized = PR_FALSE;
-
-  if (initialized)
-    return;
-
-  // XXX It'd be nice to make this const and initialize it statically...
-  CALLBACKS.size = sizeof(CALLBACKS);
-  CALLBACKS.version = (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR;
-
-  CALLBACKS.geturl =
-    NewNPN_GetURLProc(FP2TV(_geturl));
-
-  CALLBACKS.posturl =
-    NewNPN_PostURLProc(FP2TV(_posturl));
-
-  CALLBACKS.requestread =
-    NewNPN_RequestReadProc(FP2TV(_requestread));
-
-  CALLBACKS.newstream =
-    NewNPN_NewStreamProc(FP2TV(_newstream));
-
-  CALLBACKS.write =
-    NewNPN_WriteProc(FP2TV(_write));
-
-  CALLBACKS.destroystream =
-    NewNPN_DestroyStreamProc(FP2TV(_destroystream));
-
-  CALLBACKS.status =
-    NewNPN_StatusProc(FP2TV(_status));
-
-  CALLBACKS.uagent =
-    NewNPN_UserAgentProc(FP2TV(_useragent));
-
-  CALLBACKS.memalloc =
-    NewNPN_MemAllocProc(FP2TV(_memalloc));
-
-  CALLBACKS.memfree =
-    NewNPN_MemFreeProc(FP2TV(_memfree));
-
-  CALLBACKS.memflush =
-    NewNPN_MemFlushProc(FP2TV(_memflush));
-
-  CALLBACKS.reloadplugins =
-    NewNPN_ReloadPluginsProc(FP2TV(_reloadplugins));
-
-  // Deprecated API callbacks.
-  CALLBACKS.getJavaEnv =
-    NewNPN_GetJavaEnvProc(FP2TV(_getJavaEnv));
-  CALLBACKS.getJavaPeer =
-    NewNPN_GetJavaPeerProc(FP2TV(_getJavaPeer));
-
-  CALLBACKS.geturlnotify =
-    NewNPN_GetURLNotifyProc(FP2TV(_geturlnotify));
-
-  CALLBACKS.posturlnotify =
-    NewNPN_PostURLNotifyProc(FP2TV(_posturlnotify));
-
-  CALLBACKS.getvalue =
-    NewNPN_GetValueProc(FP2TV(_getvalue));
-
-  CALLBACKS.setvalue =
-    NewNPN_SetValueProc(FP2TV(_setvalue));
-
-  CALLBACKS.invalidaterect =
-    NewNPN_InvalidateRectProc(FP2TV(_invalidaterect));
-
-  CALLBACKS.invalidateregion =
-    NewNPN_InvalidateRegionProc(FP2TV(_invalidateregion));
-
-  CALLBACKS.forceredraw =
-    NewNPN_ForceRedrawProc(FP2TV(_forceredraw));
-
-  CALLBACKS.getstringidentifier =
-    NewNPN_GetStringIdentifierProc(FP2TV(_getstringidentifier));
-
-  CALLBACKS.getstringidentifiers =
-    NewNPN_GetStringIdentifiersProc(FP2TV(_getstringidentifiers));
-
-  CALLBACKS.getintidentifier =
-    NewNPN_GetIntIdentifierProc(FP2TV(_getintidentifier));
-
-  CALLBACKS.identifierisstring =
-    NewNPN_IdentifierIsStringProc(FP2TV(_identifierisstring));
-
-  CALLBACKS.utf8fromidentifier =
-    NewNPN_UTF8FromIdentifierProc(FP2TV(_utf8fromidentifier));
-
-  CALLBACKS.intfromidentifier =
-    NewNPN_IntFromIdentifierProc(FP2TV(_intfromidentifier));
-
-  CALLBACKS.createobject =
-    NewNPN_CreateObjectProc(FP2TV(_createobject));
-
-  CALLBACKS.retainobject =
-    NewNPN_RetainObjectProc(FP2TV(_retainobject));
-
-  CALLBACKS.releaseobject =
-    NewNPN_ReleaseObjectProc(FP2TV(_releaseobject));
-
-  CALLBACKS.invoke =
-    NewNPN_InvokeProc(FP2TV(_invoke));
-
-  CALLBACKS.invokeDefault =
-    NewNPN_InvokeDefaultProc(FP2TV(_invokeDefault));
-
-  CALLBACKS.evaluate =
-    NewNPN_EvaluateProc(FP2TV(_evaluate));
-
-  CALLBACKS.getproperty =
-    NewNPN_GetPropertyProc(FP2TV(_getproperty));
-
-  CALLBACKS.setproperty =
-    NewNPN_SetPropertyProc(FP2TV(_setproperty));
-
-  CALLBACKS.removeproperty =
-    NewNPN_RemovePropertyProc(FP2TV(_removeproperty));
-
-  CALLBACKS.hasproperty =
-    NewNPN_HasPropertyProc(FP2TV(_hasproperty));
-
-  CALLBACKS.hasmethod =
-    NewNPN_HasMethodProc(FP2TV(_hasmethod));
-
-  CALLBACKS.enumerate =
-    NewNPN_EnumerateProc(FP2TV(_enumerate));
-
-  CALLBACKS.construct =
-    NewNPN_ConstructProc(FP2TV(_construct));
-
-  CALLBACKS.releasevariantvalue =
-    NewNPN_ReleaseVariantValueProc(FP2TV(_releasevariantvalue));
-
-  CALLBACKS.setexception =
-    NewNPN_SetExceptionProc(FP2TV(_setexception));
-
-  CALLBACKS.pushpopupsenabledstate =
-    NewNPN_PushPopupsEnabledStateProc(FP2TV(_pushpopupsenabledstate));
-
-  CALLBACKS.poppopupsenabledstate =
-    NewNPN_PopPopupsEnabledStateProc(FP2TV(_poppopupsenabledstate));
-
-  CALLBACKS.pluginthreadasynccall =
-    NewNPN_PluginThreadAsyncCallProc(FP2TV(_pluginthreadasynccall));
-
-  if (!sPluginThreadAsyncCallLock) {
-    sPluginThreadAsyncCallLock =
-      nsAutoLock::NewLock("sPluginThreadAsyncCallLock");
-  }
-
-  initialized = PR_TRUE;
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN callbacks initialized\n"));
-}
-
-NS_IMPL_ISUPPORTS2(ns4xPlugin, nsIPlugin, nsIFactory)
-
-ns4xPlugin::ns4xPlugin(NPPluginFuncs* callbacks, PRLibrary* aLibrary,
-                       NP_PLUGINSHUTDOWN aShutdown)
-{
-  memset((void*) &fCallbacks, 0, sizeof(fCallbacks));
-  fLibrary = nsnull;
-
-#if defined(XP_WIN) || defined(XP_OS2)
-  // On Windows (and Mac) we need to keep a direct reference to the
-  // fCallbacks and NOT just copy the struct. See Bugzilla 85334
-
-  NP_GETENTRYPOINTS pfnGetEntryPoints =
-    (NP_GETENTRYPOINTS)PR_FindSymbol(aLibrary, "NP_GetEntryPoints");
-
-  if (!pfnGetEntryPoints)
-    return;
-
-  fCallbacks.size = sizeof(fCallbacks);
-
-  nsresult result = pfnGetEntryPoints(&fCallbacks);
-  NS_ASSERTION(result == NS_OK, "Failed to get callbacks");
-
-  NS_ASSERTION(HIBYTE(fCallbacks.version) >= NP_VERSION_MAJOR,
-               "callback version is less than NP version");
-
-  fShutdownEntry = (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
-#elif defined(XP_MACOSX)
-  NPPluginFuncs np_callbacks;
-  memset((void*) &np_callbacks, 0, sizeof(np_callbacks));
-  np_callbacks.size = sizeof(np_callbacks);
-
-/*  Since WebKit supports getting function pointers via NP_GetEntryPoints and
- *  sending function pointers via NP_Initialize, it would be nice if we
- *  supported that too. We can't do it on PPC because there is no standard for
- *  whether or not function pointers returned via NP_GetEntryPoints or sent
- *  via NP_Initialize are supposed to be wrapped with tvector glue. However,
- *  since there are no tvectors on Intel we can do it on that arch.
- */
-#ifndef __POWERPC__
-  fShutdownEntry = (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
-  NP_GETENTRYPOINTS pfnGetEntryPoints = (NP_GETENTRYPOINTS)PR_FindSymbol(aLibrary, "NP_GetEntryPoints");
-  NP_PLUGININIT pfnInitialize = (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
-  if (pfnGetEntryPoints && pfnInitialize && fShutdownEntry) {
-    // we call NP_Initialize before getting function pointers to match
-    // WebKit's behavior. They implemented this first on Mac OS X.
-    if (pfnInitialize(&(ns4xPlugin::CALLBACKS)) != NPERR_NO_ERROR)
-      return;
-    if (pfnGetEntryPoints(&np_callbacks) != NPERR_NO_ERROR)
-      return;
-  }
-  else
-#endif
-  {
-    // call into the entry point
-    NP_MAIN pfnMain = (NP_MAIN)PR_FindSymbol(aLibrary, "main");
-
-    if (pfnMain == NULL)
-      return;
-
-    NPError error;
-    NPP_ShutdownUPP pfnMainShutdown;
-    NS_TRY_SAFE_CALL_RETURN(error,
-                            CallNPP_MainEntryProc(pfnMain,
-                                                  &(ns4xPlugin::CALLBACKS),
-                                                  &np_callbacks,
-                                                  &pfnMainShutdown),
-                            aLibrary,
-                            nsnull);
-    
-    NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
-                   ("NPP MainEntryProc called: return=%d\n",error));
-    
-    if (error != NPERR_NO_ERROR)
-      return;
-    
-    fShutdownEntry = (NP_PLUGINSHUTDOWN)TV2FP(pfnMainShutdown);
-    
-    // version is a uint16_t so cast to int to avoid an invalid
-    // comparison due to limited range of the data type
-    int cb_version = np_callbacks.version;
-    if ((cb_version >> 8) < NP_VERSION_MAJOR)
-      return;
-  }
-
-  // wrap all plugin entry points tvectors as mach-o callable function
-  // pointers.
-  fCallbacks.size = sizeof(fCallbacks);
-  fCallbacks.version = np_callbacks.version;
-  fCallbacks.newp = (NPP_NewUPP) TV2FP(np_callbacks.newp);
-  fCallbacks.destroy = (NPP_DestroyUPP) TV2FP(np_callbacks.destroy);
-  fCallbacks.setwindow = (NPP_SetWindowUPP) TV2FP(np_callbacks.setwindow);
-  fCallbacks.newstream = (NPP_NewStreamUPP) TV2FP(np_callbacks.newstream);
-  fCallbacks.destroystream =
-    (NPP_DestroyStreamUPP) TV2FP(np_callbacks.destroystream);
-  fCallbacks.asfile = (NPP_StreamAsFileUPP) TV2FP(np_callbacks.asfile);
-  fCallbacks.writeready = (NPP_WriteReadyUPP) TV2FP(np_callbacks.writeready);
-  fCallbacks.write = (NPP_WriteUPP) TV2FP(np_callbacks.write);
-  fCallbacks.print = (NPP_PrintUPP) TV2FP(np_callbacks.print);
-  fCallbacks.event = (NPP_HandleEventUPP) TV2FP(np_callbacks.event);
-  fCallbacks.urlnotify = (NPP_URLNotifyUPP) TV2FP(np_callbacks.urlnotify);
-  fCallbacks.getvalue = (NPP_GetValueUPP) TV2FP(np_callbacks.getvalue);
-  fCallbacks.setvalue = (NPP_SetValueUPP) TV2FP(np_callbacks.setvalue);
-#else // for everyone else
-  memcpy((void*) &fCallbacks, (void*) callbacks, sizeof(fCallbacks));
-  fShutdownEntry = aShutdown;
-#endif
-
-  fLibrary = aLibrary;
-}
-
-ns4xPlugin::~ns4xPlugin(void)
-{
-  // reset the callbacks list
-#if defined(XP_MACOSX) && defined(__POWERPC__)
-  // release all wrapped plugin entry points.
-  if (fCallbacks.newp)
-    free((void *)fCallbacks.newp);
-  if (fCallbacks.destroy)
-    free((void *)fCallbacks.destroy);
-  if (fCallbacks.setwindow)
-    free((void *)fCallbacks.setwindow);
-  if (fCallbacks.newstream)
-    free((void *)fCallbacks.newstream);
-  if (fCallbacks.asfile)
-    free((void *)fCallbacks.asfile);
-  if (fCallbacks.writeready)
-    free((void *)fCallbacks.writeready);
-  if (fCallbacks.write)
-    free((void *)fCallbacks.write);
-  if (fCallbacks.print)
-    free((void *)fCallbacks.print);
-  if (fCallbacks.event)
-    free((void *)fCallbacks.event);
-  if (fCallbacks.urlnotify)
-    free((void *)fCallbacks.urlnotify);
-  if (fCallbacks.getvalue)
-    free((void *)fCallbacks.getvalue);
-  if (fCallbacks.setvalue)
-    free((void *)fCallbacks.setvalue);
-#endif
-  memset((void*) &fCallbacks, 0, sizeof(fCallbacks));
-}
-
-
-#if defined(XP_MACOSX)
-void
-ns4xPlugin::SetPluginRefNum(short aRefNum)
-{
-  fPluginRefNum = aRefNum;
-}
-#endif
-
-// Creates the ns4xPlugin object. One ns4xPlugin object exists per Plugin (not instance).
-nsresult
-ns4xPlugin::CreatePlugin(const char* aFileName, const char* aFullPath,
-                         PRLibrary* aLibrary, nsIPlugin** aResult)
-{
-  CheckClassInitialized();
-
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-  ns4xPlugin *plptr;
-
-  NPPluginFuncs callbacks;
-  memset((void*) &callbacks, 0, sizeof(callbacks));
-  callbacks.size = sizeof(callbacks);
-
-  NP_PLUGINSHUTDOWN pfnShutdown =
-    (NP_PLUGINSHUTDOWN)PR_FindFunctionSymbol(aLibrary, "NP_Shutdown");
-
-  // create the new plugin handler
-  *aResult = plptr =
-    new ns4xPlugin(&callbacks, aLibrary, pfnShutdown);
-
-  if (*aResult == NULL)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  NS_ADDREF(*aResult);
-
-  if (!aFileName) //do not call NP_Initialize in this case, bug 74938
-    return NS_OK;
-
-  // we must init here because the plugin may call NPN functions
-  // when we call into the NP_Initialize entry point - NPN functions
-  // require that mBrowserManager be set up
-  plptr->Initialize();
-
-  NP_PLUGINUNIXINIT pfnInitialize =
-    (NP_PLUGINUNIXINIT)PR_FindFunctionSymbol(aLibrary, "NP_Initialize");
-
-  if (pfnInitialize == NULL)
-    return NS_ERROR_UNEXPECTED; // XXX Right error?
-
-  if (pfnInitialize(&(ns4xPlugin::CALLBACKS),&callbacks) != NS_OK)
-    return NS_ERROR_UNEXPECTED;
-
-  // now copy function table back to ns4xPlugin instance
-  memcpy((void*) &(plptr->fCallbacks), (void*)&callbacks, sizeof(callbacks));
-#endif
-
-#ifdef XP_WIN
-  // Note: on Windows, we must use the fCallback because plugins may
-  // change the function table. The Shockwave installer makes changes
-  // in the table while running
-  *aResult = new ns4xPlugin(nsnull, aLibrary, nsnull);
-
-  if (*aResult == NULL)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  NS_ADDREF(*aResult);
-
-  // we must init here because the plugin may call NPN functions
-  // when we call into the NP_Initialize entry point - NPN functions
-  // require that mBrowserManager be set up
-  if (NS_FAILED((*aResult)->Initialize())) {
-    NS_RELEASE(*aResult);
-    return NS_ERROR_FAILURE;
-  }
-
-  NP_PLUGININIT pfnInitialize =
-    (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
-
-  if (pfnInitialize == NULL)
-    return NS_ERROR_UNEXPECTED;
-
-  if (pfnInitialize(&(ns4xPlugin::CALLBACKS)) != NS_OK)
-    return NS_ERROR_UNEXPECTED;
-#endif
-
-#ifdef XP_OS2
-  // create the new plugin handler
-  *aResult = new ns4xPlugin(nsnull, aLibrary, nsnull);
-
-  if (*aResult == NULL)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  NS_ADDREF(*aResult);
-
-  // we must init here because the plugin may call NPN functions
-  // when we call into the NP_Initialize entry point - NPN functions
-  // require that mBrowserManager be set up
-  if (NS_FAILED((*aResult)->Initialize())) {
-    NS_RELEASE(*aResult);
-    return NS_ERROR_FAILURE;
-  }
-
-  NP_PLUGININIT pfnInitialize =
-    (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
-
-  if (pfnInitialize == NULL)
-    return NS_ERROR_UNEXPECTED; // XXX Right error?
-
-  // Fixes problem where the OS/2 native multimedia plugins weren't
-  // working on mozilla though did work on 4.x.  Problem is that they
-  // expect the current working directory to be the plugins dir.
-  // Since these plugins are no longer maintained and they represent
-  // the majority of the OS/2 plugin contingency, we'll have to make
-  // them work here.
-
-#define MAP_DISKNUM_TO_LETTER(n) ('A' + (n - 1))
-#define MAP_LETTER_TO_DISKNUM(c) (toupper(c)-'A'+1)
-
-  unsigned long origDiskNum, pluginDiskNum, logicalDisk;
-
-  char pluginPath[CCHMAXPATH], origPath[CCHMAXPATH];
-  strcpy(pluginPath, aFileName);
-  char* slash = strrchr(pluginPath, '\\');
-  *slash = '\0';
-
-  DosQueryCurrentDisk( &origDiskNum, &logicalDisk );
-  pluginDiskNum = MAP_LETTER_TO_DISKNUM(pluginPath[0]);
-
-  origPath[0] = MAP_DISKNUM_TO_LETTER(origDiskNum);
-  origPath[1] = ':';
-  origPath[2] = '\\';
-
-  ULONG len = CCHMAXPATH-3;
-  APIRET rc = DosQueryCurrentDir(0, &origPath[3], &len);
-  NS_ASSERTION(NO_ERROR == rc,"DosQueryCurrentDir failed");
-
-  BOOL bChangedDir = FALSE;
-  BOOL bChangedDisk = FALSE;
-  if (pluginDiskNum != origDiskNum) {
-    rc = DosSetDefaultDisk(pluginDiskNum);
-    NS_ASSERTION(NO_ERROR == rc,"DosSetDefaultDisk failed");
-    bChangedDisk = TRUE;
-  }
-
-  if (stricmp(origPath, pluginPath) != 0) {
-    rc = DosSetCurrentDir(pluginPath);
-    NS_ASSERTION(NO_ERROR == rc,"DosSetCurrentDir failed");
-    bChangedDir = TRUE;
-  }
-
-  nsresult rv = pfnInitialize(&(ns4xPlugin::CALLBACKS));
-
-  if (bChangedDisk) {
-    rc= DosSetDefaultDisk(origDiskNum);
-    NS_ASSERTION(NO_ERROR == rc,"DosSetDefaultDisk failed");
-  }
-  if (bChangedDir) {
-    rc = DosSetCurrentDir(origPath);
-    NS_ASSERTION(NO_ERROR == rc,"DosSetCurrentDir failed");
-  }
-
-  if (!NS_SUCCEEDED(rv)) {
-    return NS_ERROR_UNEXPECTED;
-  }
-#endif
-
-#if defined(XP_MACOSX)
-  short appRefNum = ::CurResFile();
-  short pluginRefNum;
-
-  nsCOMPtr<nsILocalFile> pluginPath;
-  NS_NewNativeLocalFile(nsDependentCString(aFullPath), PR_TRUE,
-                        getter_AddRefs(pluginPath));
-
-  nsPluginFile pluginFile(pluginPath);
-  pluginRefNum = pluginFile.OpenPluginResource();
-
-  ns4xPlugin* plugin = new ns4xPlugin(nsnull, aLibrary, nsnull);
-  ::UseResFile(appRefNum);
-  if (!plugin)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  *aResult = plugin;
-
-  NS_ADDREF(*aResult);
-  if (NS_FAILED((*aResult)->Initialize())) {
-    NS_RELEASE(*aResult);
-    return NS_ERROR_FAILURE;
-  }
-
-  plugin->SetPluginRefNum(pluginRefNum);
-#endif
-
-#ifdef XP_BEOS
-  // I just copied UNIX version.
-  // Makoto Hamanaka <VYA04230@nifty.com>
-
-  ns4xPlugin *plptr;
-
-  NPPluginFuncs callbacks;
-  memset((void*) &callbacks, 0, sizeof(callbacks));
-  callbacks.size = sizeof(callbacks);
-
-  NP_PLUGINSHUTDOWN pfnShutdown =
-    (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
-
-  // create the new plugin handler
-  *aResult = plptr =
-    new ns4xPlugin(&callbacks, aLibrary, pfnShutdown);
-
-  if (*aResult == NULL)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  NS_ADDREF(*aResult);
-
-  // we must init here because the plugin may call NPN functions
-  // when we call into the NP_Initialize entry point - NPN functions
-  // require that mBrowserManager be set up
-  plptr->Initialize();
-
-  NP_PLUGINUNIXINIT pfnInitialize =
-    (NP_PLUGINUNIXINIT)PR_FindSymbol(aLibrary, "NP_Initialize");
-
-  if (pfnInitialize == NULL)
-    return NS_ERROR_FAILURE;
-
-  if (pfnInitialize(&(ns4xPlugin::CALLBACKS),&callbacks) != NS_OK)
-    return NS_ERROR_FAILURE;
-
-  // now copy function table back to ns4xPlugin instance
-  memcpy((void*) &(plptr->fCallbacks), (void*)&callbacks, sizeof(callbacks));
-#endif
-
-  return NS_OK;
-}
-
-nsresult
-ns4xPlugin::CreateInstance(nsISupports *aOuter, const nsIID &aIID,
-                           void **aResult)
-{
-  if (aResult == NULL)
-    return NS_ERROR_NULL_POINTER;
-
-  *aResult = NULL;
-
-  // XXX This is suspicuous!
-  nsRefPtr<ns4xPluginInstance> inst =
-    new ns4xPluginInstance(&fCallbacks, fLibrary);
-
-  if (!inst)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  return inst->QueryInterface(aIID, aResult);
-}
-
-nsresult
-ns4xPlugin::LockFactory(PRBool aLock)
-{
-  // Not implemented in simplest case.
-  return NS_OK;
-}
-
-NS_METHOD
-ns4xPlugin::CreatePluginInstance(nsISupports *aOuter, REFNSIID aIID,
-                                 const char *aPluginMIMEType, void **aResult)
-{
-  return CreateInstance(aOuter, aIID, aResult);
-}
-
-nsresult
-ns4xPlugin::Initialize(void)
-{
-  if (nsnull == fLibrary)
-    return NS_ERROR_FAILURE;
-  return NS_OK;
-}
-
-nsresult
-ns4xPlugin::Shutdown(void)
-{
-  NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
-                 ("NPP Shutdown to be called: this=%p\n", this));
-
-  if (fShutdownEntry != nsnull) {
-#if defined(XP_MACOSX)
-    CallNPP_ShutdownProc(fShutdownEntry);
-    if (fPluginRefNum > 0)
-      ::CloseResFile(fPluginRefNum);
-#else
-    NS_TRY_SAFE_CALL_VOID(fShutdownEntry(), fLibrary, nsnull);
-#endif
-
-#if defined(XP_MACOSX) && defined(__POWERPC__)
-    // release the wrapped plugin function.
-    free((void *)fShutdownEntry);
-#endif
-    fShutdownEntry = nsnull;
-  }
-
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-             ("4xPlugin Shutdown done, this=%p", this));
-  return NS_OK;
-}
-
-nsresult
-ns4xPlugin::GetMIMEDescription(const char* *resultingDesc)
-{
-  const char* (*npGetMIMEDescription)() =
-    (const char* (*)()) PR_FindFunctionSymbol(fLibrary, "NP_GetMIMEDescription");
-
-  *resultingDesc = npGetMIMEDescription ? npGetMIMEDescription() : "";
-
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-             ("ns4xPlugin::GetMIMEDescription called: this=%p, result=%s\n",
-              this, *resultingDesc));
-
-  return NS_OK;
-}
-
-nsresult
-ns4xPlugin::GetValue(nsPluginVariable variable, void *value)
-{
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("ns4xPlugin::GetValue called: this=%p, variable=%d\n", this, variable));
-
-  NPError (*npGetValue)(void*, nsPluginVariable, void*) =
-    (NPError (*)(void*, nsPluginVariable, void*)) PR_FindFunctionSymbol(fLibrary,
-                                                                "NP_GetValue");
-
-  if (npGetValue && NPERR_NO_ERROR == npGetValue(nsnull, variable, value)) {
-    return NS_OK;
-  }
-
-  return NS_ERROR_FAILURE;
-}
-
-// Create a new NPP GET or POST (given in the type argument) url
-// stream that may have a notify callback
-NPError
-MakeNew4xStreamInternal(NPP npp, const char *relativeURL, const char *target,
-                        eNPPStreamTypeInternal type,
-                        PRBool bDoNotify = PR_FALSE,
-                        void *notifyData = nsnull, uint32_t len = 0,
-                        const char *buf = nsnull, NPBool file = PR_FALSE)
-{
-  if (!npp)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  PluginDestructionGuard guard(npp);
-
-  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
-
-  NS_ASSERTION(inst != NULL, "null instance");
-  if (inst == NULL)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  nsCOMPtr<nsIPluginManager> pm = do_GetService(kPluginManagerCID);
-  NS_ASSERTION(pm, "failed to get plugin manager");
-  if (!pm) return NPERR_GENERIC_ERROR;
-
-  nsCOMPtr<nsIPluginStreamListener> listener;
-  if (target == nsnull)
-    ((ns4xPluginInstance*)inst)->NewNotifyStream(getter_AddRefs(listener),
-                                                 notifyData,
-                                                 bDoNotify, relativeURL);
-
-  switch (type) {
-  case eNPPStreamTypeInternal_Get:
-    {
-      if (NS_FAILED(pm->GetURL(inst, relativeURL, target, listener)))
-        return NPERR_GENERIC_ERROR;
-      break;
-    }
-  case eNPPStreamTypeInternal_Post:
-    {
-      if (NS_FAILED(pm->PostURL(inst, relativeURL, len, buf, file, target,
-                                listener)))
-        return NPERR_GENERIC_ERROR;
-      break;
-    }
-  default:
-    NS_ASSERTION(0, "how'd I get here");
-  }
-
-  return NPERR_NO_ERROR;
-}
-
-//
-// Static callbacks that get routed back through the new C++ API
-//
-
-NPError NP_CALLBACK
-_geturl(NPP npp, const char* relativeURL, const char* target)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturl called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
-   relativeURL));
-
-  PluginDestructionGuard guard(npp);
-
-  // Block Adobe Acrobat from loading URLs that are not http:, https:,
-  // or ftp: URLs if the given target is null.
-  if (target == nsnull && relativeURL &&
-      (strncmp(relativeURL, "http:", 5) != 0) &&
-      (strncmp(relativeURL, "https:", 6) != 0) &&
-      (strncmp(relativeURL, "ftp:", 4) != 0)) {
-    ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
-
-    const char *name = nsPluginHostImpl::GetPluginName(inst);
-
-    if (name && strstr(name, "Adobe") && strstr(name, "Acrobat")) {
-      return NPERR_NO_ERROR;
-    }
-  }
-
-  return MakeNew4xStreamInternal (npp, relativeURL, target,
-                                  eNPPStreamTypeInternal_Get);
-}
-
-NPError NP_CALLBACK
-_geturlnotify(NPP npp, const char* relativeURL, const char* target,
-              void* notifyData)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturlnotify called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-    ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
-     target, notifyData, relativeURL));
-
-  PluginDestructionGuard guard(npp);
-
-  return MakeNew4xStreamInternal (npp, relativeURL, target,
-                                  eNPPStreamTypeInternal_Get, PR_TRUE,
-                                  notifyData);
-}
-
-NPError NP_CALLBACK
-_posturlnotify(NPP npp, const char *relativeURL, const char *target,
-               uint32_t len, const char *buf, NPBool file, void *notifyData)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturlnotify called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
-                  "notify=%p, url=%s, buf=%s\n",
-                  (void*)npp, target, len, file, notifyData, relativeURL,
-                  buf));
-
-  PluginDestructionGuard guard(npp);
-
-  return MakeNew4xStreamInternal(npp, relativeURL, target,
-                                 eNPPStreamTypeInternal_Post, PR_TRUE,
-                                 notifyData, len, buf, file);
-}
-
-NPError NP_CALLBACK
-_posturl(NPP npp, const char *relativeURL, const char *target,
-         uint32_t len, const char *buf, NPBool file)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturl called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
-                  "buf=%s\n",
-                  (void*)npp, target, file, len, relativeURL, buf));
-
-  PluginDestructionGuard guard(npp);
-
-  return MakeNew4xStreamInternal(npp, relativeURL, target,
-                                 eNPPStreamTypeInternal_Post, PR_FALSE, nsnull,
-                                 len, buf, file);
-}
-
-// A little helper class used to wrap up plugin manager streams (that is,
-// streams from the plugin to the browser).
-class ns4xStreamWrapper : nsISupports
-{
-public:
-  NS_DECL_ISUPPORTS
-
-protected:
-  nsIOutputStream *fStream;
-  NPStream        fNPStream;
-
-public:
-  ns4xStreamWrapper(nsIOutputStream* stream);
-  ~ns4xStreamWrapper();
-
-  void GetStream(nsIOutputStream* &result);
-  NPStream* GetNPStream(void) { return &fNPStream; }
-};
-
-NS_IMPL_ISUPPORTS1(ns4xStreamWrapper, nsISupports)
-
-ns4xStreamWrapper::ns4xStreamWrapper(nsIOutputStream* stream)
-  : fStream(stream)
-{
-  NS_ASSERTION(stream != NULL, "bad stream");
-
-  fStream = stream;
-  NS_ADDREF(fStream);
-
-  memset(&fNPStream, 0, sizeof(fNPStream));
-  fNPStream.ndata = (void*) this;
-}
-
-ns4xStreamWrapper::~ns4xStreamWrapper(void)
-{
-  fStream->Close();
-  NS_IF_RELEASE(fStream);
-}
-
-void
-ns4xStreamWrapper::GetStream(nsIOutputStream* &result)
-{
-  result = fStream;
-  NS_IF_ADDREF(fStream);
-}
-
-NPError NP_CALLBACK
-_newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_newstream called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
-   (const char *)type, target));
-
-  NPError err = NPERR_INVALID_INSTANCE_ERROR;
-  if (npp && npp->ndata) {
-    nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
-
-    PluginDestructionGuard guard(inst);
-
-    nsCOMPtr<nsIOutputStream> stream;
-    nsCOMPtr<nsIPluginInstancePeer> peer;
-    if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) &&
-      peer &&
-      NS_SUCCEEDED(peer->NewStream((const char*) type, target,
-                                   getter_AddRefs(stream)))) {
-      ns4xStreamWrapper* wrapper = new ns4xStreamWrapper(stream);
-      if (wrapper) {
-        (*result) = wrapper->GetNPStream();
-        err = NPERR_NO_ERROR;
-      } else {
-        err = NPERR_OUT_OF_MEMORY_ERROR;
-      }
-    } else {
-      err = NPERR_GENERIC_ERROR;
-    }
-  }
-  return err;
-}
-
-int32_t NP_CALLBACK
-_write(NPP npp, NPStream *pstream, int32_t len, void *buffer)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
-    return 0;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
-                  pstream->url, len, (char*)buffer));
-
-  // negative return indicates failure to the plugin
-  if (!npp)
-    return -1;
-
-  PluginDestructionGuard guard(npp);
-
-  ns4xStreamWrapper* wrapper = (ns4xStreamWrapper*) pstream->ndata;
-  NS_ASSERTION(wrapper != NULL, "null stream");
-
-  if (wrapper == NULL)
-    return -1;
-
-  nsIOutputStream* stream;
-  wrapper->GetStream(stream);
-
-  PRUint32 count = 0;
-  nsresult rv = stream->Write((char *)buffer, len, &count);
-  NS_RELEASE(stream);
-
-  if (rv != NS_OK)
-    return -1;
-
-  return (int32_t)count;
-}
-
-NPError NP_CALLBACK
-_destroystream(NPP npp, NPStream *pstream, NPError reason)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
-                  pstream->url, (int)reason));
-
-  if (!npp)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  PluginDestructionGuard guard(npp);
-
-  nsCOMPtr<nsIPluginStreamListener> listener =
-    do_QueryInterface((nsISupports *)pstream->ndata);
-
-  // DestroyStream can kill two kinds of streams: NPP derived and NPN derived.
-  // check to see if they're trying to kill a NPP stream
-  if (listener) {
-    // Tell the stream listner that the stream is now gone.
-    listener->OnStopBinding(nsnull, NS_BINDING_ABORTED);
-
-    // FIXME: http://bugzilla.mozilla.org/show_bug.cgi?id=240131
-    //
-    // Is it ok to leave pstream->ndata set here, and who releases it
-    // (or is it even properly ref counted)? And who closes the stream
-    // etc?
-  } else {
-    ns4xStreamWrapper* wrapper = (ns4xStreamWrapper *)pstream->ndata;
-    NS_ASSERTION(wrapper != NULL, "null wrapper");
-
-    if (wrapper == NULL)
-      return NPERR_INVALID_PARAM;
-
-    // This will release the wrapped nsIOutputStream.
-    delete wrapper;
-    pstream->ndata = nsnull;
-  }
-
-  return NPERR_NO_ERROR;
-}
-
-void NP_CALLBACK
-_status(NPP npp, const char *message)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_status called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_Status: npp=%p, message=%s\n",
-                                     (void*)npp, message));
-
-  if (!npp || !npp->ndata) {
-    NS_WARNING("_status: npp or npp->ndata == 0");
-    return;
-  }
-
-  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
-
-  PluginDestructionGuard guard(inst);
-
-  nsCOMPtr<nsIPluginInstancePeer> peer;
-  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
-    peer->ShowStatus(message);
-  }
-}
-
-void NP_CALLBACK
-_memfree (void *ptr)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memfree called from the wrong thread\n"));
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
-
-  if (ptr)
-    nsMemory::Free(ptr);
-}
-
-uint32_t NP_CALLBACK
-_memflush(uint32_t size)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memflush called from the wrong thread\n"));
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
-
-  nsMemory::HeapMinimize(PR_TRUE);
-  return 0;
-}
-
-void NP_CALLBACK
-_reloadplugins(NPBool reloadPages)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_reloadplugins called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
-
-  nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
-  if (!pm)
-    return;
-
-  pm->ReloadPlugins(reloadPages);
-}
-
-void NP_CALLBACK
-_invalidaterect(NPP npp, NPRect *invalidRect)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidaterect called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
-                  "right=%d\n", (void *)npp, invalidRect->top,
-                  invalidRect->left, invalidRect->bottom, invalidRect->right));
-
-  if (!npp || !npp->ndata) {
-    NS_WARNING("_invalidaterect: npp or npp->ndata == 0");
-    return;
-  }
-
-  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
-
-  PluginDestructionGuard guard(inst);
-
-  nsCOMPtr<nsIPluginInstancePeer> peer;
-  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
-    nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
-    if (wpeer) {
-      // XXX nsRect & NPRect are structurally equivalent
-      wpeer->InvalidateRect((nsPluginRect *)invalidRect);
-    }
-  }
-}
-
-void NP_CALLBACK
-_invalidateregion(NPP npp, NPRegion invalidRegion)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidateregion called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
-                  (void*)invalidRegion));
-
-  if (!npp || !npp->ndata) {
-    NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
-    return;
-  }
-
-  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
-
-  PluginDestructionGuard guard(inst);
-
-  nsCOMPtr<nsIPluginInstancePeer> peer;
-  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
-    nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
-    if (wpeer) {
-      // nsPluginRegion & NPRegion are typedef'd to the same thing
-      wpeer->InvalidateRegion((nsPluginRegion)invalidRegion);
-    }
-  }
-}
-
-void NP_CALLBACK
-_forceredraw(NPP npp)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_forceredraw called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_ForceDraw: npp=%p\n", (void*)npp));
-
-  if (!npp || !npp->ndata) {
-    NS_WARNING("_forceredraw: npp or npp->ndata == 0");
-    return;
-  }
-
-  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
-
-  PluginDestructionGuard guard(inst);
-
-  nsCOMPtr<nsIPluginInstancePeer> peer;
-  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
-    nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
-    if (wpeer) {
-      wpeer->ForceRedraw();
-    }
-  }
-}
-
-static nsIDocument *
-GetDocumentFromNPP(NPP npp)
-{
-  NS_ENSURE_TRUE(npp, nsnull);
-
-  ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
-  NS_ENSURE_TRUE(inst, nsnull);
-
-  PluginDestructionGuard guard(inst);
-
-  nsCOMPtr<nsIPluginInstancePeer> pip;
-  inst->GetPeer(getter_AddRefs(pip));
-  nsCOMPtr<nsPIPluginInstancePeer> pp(do_QueryInterface(pip));
-  NS_ENSURE_TRUE(pp, nsnull);
-
-  nsCOMPtr<nsIPluginInstanceOwner> owner;
-  pp->GetOwner(getter_AddRefs(owner));
-  NS_ENSURE_TRUE(owner, nsnull);
-
-  nsCOMPtr<nsIDocument> doc;
-  owner->GetDocument(getter_AddRefs(doc));
-
-  return doc;
-}
-
-static JSContext *
-GetJSContextFromDoc(nsIDocument *doc)
-{
-  nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
-  NS_ENSURE_TRUE(sgo, nsnull);
-
-  nsIScriptContext *scx = sgo->GetContext();
-  NS_ENSURE_TRUE(scx, nsnull);
-
-  return (JSContext *)scx->GetNativeContext();
-}
-
-static JSContext *
-GetJSContextFromNPP(NPP npp)
-{
-  nsIDocument *doc = GetDocumentFromNPP(npp);
-  NS_ENSURE_TRUE(doc, nsnull);
-
-  return GetJSContextFromDoc(doc);
-}
-
-NPObject* NP_CALLBACK
-_getwindowobject(NPP npp)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getwindowobject called from the wrong thread\n"));
-    return nsnull;
-  }
-  JSContext *cx = GetJSContextFromNPP(npp);
-  NS_ENSURE_TRUE(cx, nsnull);
-
-  // Using ::JS_GetGlobalObject(cx) is ok here since the window we
-  // want to return here is the outer window, *not* the inner (since
-  // we don't know what the plugin will do with it).
-  return nsJSObjWrapper::GetNewOrUsed(npp, cx, ::JS_GetGlobalObject(cx));
-}
-
-NPObject* NP_CALLBACK
-_getpluginelement(NPP npp)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getpluginelement called from the wrong thread\n"));
-    return nsnull;
-  }
-  nsIDOMElement *elementp = nsnull;
-  NPError nperr = _getvalue(npp, NPNVDOMElement, &elementp);
-
-  if (nperr != NPERR_NO_ERROR) {
-    return nsnull;
-  }
-
-  // Pass ownership of elementp to element
-  nsCOMPtr<nsIDOMElement> element;
-  element.swap(elementp);
-
-  JSContext *cx = GetJSContextFromNPP(npp);
-  NS_ENSURE_TRUE(cx, nsnull);
-
-  nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID()));
-  NS_ENSURE_TRUE(xpc, nsnull);
-
-  nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
-  xpc->WrapNative(cx, ::JS_GetGlobalObject(cx), element,
-                  NS_GET_IID(nsIDOMElement),
-                  getter_AddRefs(holder));
-  NS_ENSURE_TRUE(holder, nsnull);
-
-  JSObject* obj = nsnull;
-  holder->GetJSObject(&obj);
-  NS_ENSURE_TRUE(obj, nsnull);
-
-  return nsJSObjWrapper::GetNewOrUsed(npp, cx, obj);
-}
-
-static NPIdentifier
-doGetIdentifier(JSContext *cx, const NPUTF8* name)
-{
-  NS_ConvertUTF8toUTF16 utf16name(name);
-
-  JSString *str = ::JS_InternUCStringN(cx, (jschar *)utf16name.get(),
-                                       utf16name.Length());
-
-  if (!str)
-    return NULL;
-
-  return (NPIdentifier)STRING_TO_JSVAL(str);
-}
-
-NPIdentifier NP_CALLBACK
-_getstringidentifier(const NPUTF8* name)
-{
-  if (!name) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifier: passed null name"));
-    return NULL;
-  }
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
-  }
-
-  nsCOMPtr<nsIThreadJSContextStack> stack =
-    do_GetService("@mozilla.org/js/xpc/ContextStack;1");
-  if (!stack)
-    return NULL;
-
-  JSContext *cx = nsnull;
-  stack->GetSafeJSContext(&cx);
-  if (!cx)
-    return NULL;
-
-  JSAutoRequest ar(cx);
-  return doGetIdentifier(cx, name);
-}
-
-void NP_CALLBACK
-_getstringidentifiers(const NPUTF8** names, int32_t nameCount,
-                      NPIdentifier *identifiers)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifiers called from the wrong thread\n"));
-  }
-  nsCOMPtr<nsIThreadJSContextStack> stack =
-    do_GetService("@mozilla.org/js/xpc/ContextStack;1");
-  if (!stack)
-    return;
-
-  JSContext *cx = nsnull;
-  stack->GetSafeJSContext(&cx);
-  if (!cx)
-    return;
-
-  JSAutoRequest ar(cx);
-
-  for (int32_t i = 0; i < nameCount; ++i) {
-    if (names[i]) {
-      identifiers[i] = doGetIdentifier(cx, names[i]);
-    } else {
-      NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifiers: passed null name"));
-      identifiers[i] = NULL;
-    }
-  }
-}
-
-NPIdentifier NP_CALLBACK
-_getintidentifier(int32_t intid)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
-  }
-  return (NPIdentifier)INT_TO_JSVAL(intid);
-}
-
-NPUTF8* NP_CALLBACK
-_utf8fromidentifier(NPIdentifier identifier)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_utf8fromidentifier called from the wrong thread\n"));
-  }
-  if (!identifier)
-    return NULL;
-
-  jsval v = (jsval)identifier;
-
-  if (!JSVAL_IS_STRING(v)) {
-    return nsnull;
-  }
-
-  JSString *str = JSVAL_TO_STRING(v);
-
-  return
-    ToNewUTF8String(nsDependentString((PRUnichar *)::JS_GetStringChars(str),
-                                      ::JS_GetStringLength(str)));
-}
-
-int32_t NP_CALLBACK
-_intfromidentifier(NPIdentifier identifier)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_intfromidentifier called from the wrong thread\n"));
-  }
-  jsval v = (jsval)identifier;
-
-  if (!JSVAL_IS_INT(v)) {
-    return PR_INT32_MIN;
-  }
-
-  return JSVAL_TO_INT(v);
-}
-
-bool NP_CALLBACK
-_identifierisstring(NPIdentifier identifier)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_identifierisstring called from the wrong thread\n"));
-  }
-  jsval v = (jsval)identifier;
-
-  return JSVAL_IS_STRING(v);
-}
-
-NPObject* NP_CALLBACK
-_createobject(NPP npp, NPClass* aClass)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_createobject called from the wrong thread\n"));
-    return nsnull;
-  }
-  if (!npp) {
-    NS_ERROR("Null npp passed to _createobject()!");
-
-    return nsnull;
-  }
-
-  PluginDestructionGuard guard(npp);
-
-  if (!aClass) {
-    NS_ERROR("Null class passed to _createobject()!");
-
-    return nsnull;
-  }
-
-  NPPAutoPusher nppPusher(npp);
-
-  NPObject *npobj;
-
-  if (aClass->allocate) {
-    npobj = aClass->allocate(npp, aClass);
-  } else {
-    npobj = (NPObject *)PR_Malloc(sizeof(NPObject));
-  }
-
-  if (npobj) {
-    npobj->_class = aClass;
-    npobj->referenceCount = 1;
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("Created NPObject %p, NPClass %p\n", npobj, aClass));
-
-  return npobj;
-}
-
-NPObject* NP_CALLBACK
-_retainobject(NPObject* npobj)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_retainobject called from the wrong thread\n"));
-  }
-  if (npobj) {
-    PR_AtomicIncrement((PRInt32*)&npobj->referenceCount);
-  }
-
-  return npobj;
-}
-
-void NP_CALLBACK
-_releaseobject(NPObject* npobj)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releaseobject called from the wrong thread\n"));
-  }
-  if (!npobj)
-    return;
-
-  int32_t refCnt = PR_AtomicDecrement((PRInt32*)&npobj->referenceCount);
-
-  if (refCnt == 0) {
-    nsNPObjWrapper::OnDestroy(npobj);
-
-    NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                   ("Deleting NPObject %p, refcount hit 0\n", npobj));
-
-    if (npobj->_class && npobj->_class->deallocate) {
-      npobj->_class->deallocate(npobj);
-    } else {
-      PR_Free(npobj);
-    }
-  }
-}
-
-bool NP_CALLBACK
-_invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
-        uint32_t argCount, NPVariant *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invoke called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
-    return false;
-
-  PluginDestructionGuard guard(npp);
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_Invoke(npp %p, npobj %p, method %p, args %d\n", npp,
-                  npobj, method, argCount));
-
-  return npobj->_class->invoke(npobj, method, args, argCount, result);
-}
-
-bool NP_CALLBACK
-_invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
-               uint32_t argCount, NPVariant *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invokedefault called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_InvokeDefault(npp %p, npobj %p, args %d\n", npp,
-                  npobj, argCount));
-
-  return npobj->_class->invokeDefault(npobj, args, argCount, result);
-}
-
-bool NP_CALLBACK
-_evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_evaluate called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp)
-    return false;
-
-  NPPAutoPusher nppPusher(npp);
-
-  nsIDocument *doc = GetDocumentFromNPP(npp);
-  NS_ENSURE_TRUE(doc, false);
-
-  JSContext *cx = GetJSContextFromDoc(doc);
-  NS_ENSURE_TRUE(cx, false);
-
-  JSObject *obj =
-    nsNPObjWrapper::GetNewOrUsed(npp, cx, npobj);
-
-  if (!obj) {
-    return false;
-  }
-
-  // Root obj and the rval (below).
-  jsval vec[] = { OBJECT_TO_JSVAL(obj), JSVAL_NULL };
-  JSAutoTempValueRooter tvr(cx, NS_ARRAY_LENGTH(vec), vec);
-  jsval *rval = &vec[1];
-
-  if (result) {
-    // Initialize the out param to void
-    VOID_TO_NPVARIANT(*result);
-  }
-
-  if (!script || !script->utf8length || !script->utf8characters) {
-    // Nothing to evaluate.
-
-    return true;
-  }
-
-  NS_ConvertUTF8toUTF16 utf16script(script->utf8characters,
-                                    script->utf8length);
-
-  nsCOMPtr<nsIScriptContext> scx = GetScriptContextFromJSContext(cx);
-  NS_ENSURE_TRUE(scx, false);
-
-  nsIPrincipal *principal = doc->NodePrincipal();
-
-  nsCAutoString specStr;
-  const char *spec;
-
-  nsCOMPtr<nsIURI> uri;
-  principal->GetURI(getter_AddRefs(uri));
-
-  if (uri) {
-    uri->GetSpec(specStr);
-    spec = specStr.get();
-  } else {
-    // No URI in a principal means it's the system principal. If the
-    // document URI is a chrome:// URI, pass that in as the URI of the
-    // script, else pass in null for the filename as there's no way to
-    // know where this document really came from. Passing in null here
-    // also means that the script gets treated by XPConnect as if it
-    // needs additional protection, which is what we want for unknown
-    // chrome code anyways.
-
-    uri = doc->GetDocumentURI();
-    PRBool isChrome = PR_FALSE;
-
-    if (uri && NS_SUCCEEDED(uri->SchemeIs("chrome", &isChrome)) && isChrome) {
-      uri->GetSpec(specStr);
-      spec = specStr.get();
-    } else {
-      spec = nsnull;
-    }
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n",
-                  npp, npobj, script->utf8characters));
-
-  nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
-                                             spec, 0, 0, rval, nsnull);
-
-  return NS_SUCCEEDED(rv) &&
-         (!result || JSValToNPVariant(npp, cx, *rval, result));
-}
-
-bool NP_CALLBACK
-_getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-             NPVariant *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_GetProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, property));
-
-  return npobj->_class->getProperty(npobj, property, result);
-}
-
-bool NP_CALLBACK
-_setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-             const NPVariant *value)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_SetProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, property));
-
-  return npobj->_class->setProperty(npobj, property, value);
-}
-
-bool NP_CALLBACK
-_removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_removeproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_RemoveProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, property));
-
-  return npobj->_class->removeProperty(npobj, property);
-}
-
-bool NP_CALLBACK
-_hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_HasProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, propertyName));
-
-  return npobj->_class->hasProperty(npobj, propertyName);
-}
-
-bool NP_CALLBACK
-_hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasmethod called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_HasMethod(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, methodName));
-
-  return npobj->_class->hasProperty(npobj, methodName);
-}
-
-bool NP_CALLBACK
-_enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
-           uint32_t *count)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_enumerate called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class)
-    return false;
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_Enumerate(npp %p, npobj %p) called\n", npp, npobj));
-
-  if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
-      !npobj->_class->enumerate) {
-    *identifier = 0;
-    *count = 0;
-    return true;
-  }
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  return npobj->_class->enumerate(npobj, identifier, count);
-}
-
-bool NP_CALLBACK
-_construct(NPP npp, NPObject* npobj, const NPVariant *args,
-               uint32_t argCount, NPVariant *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_construct called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class ||
-      !NP_CLASS_STRUCT_VERSION_HAS_CTOR(npobj->_class) ||
-      !npobj->_class->construct) {
-    return false;
-  }
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  return npobj->_class->construct(npobj, args, argCount, result);
-}
-
-#ifdef MOZ_MEMORY_WINDOWS
-extern "C" size_t malloc_usable_size(const void *ptr);
-
-BOOL
-InHeap(HANDLE hHeap, LPVOID lpMem)
-{
-  BOOL success = FALSE;
-  PROCESS_HEAP_ENTRY he;
-  he.lpData = NULL;
-  while (HeapWalk(hHeap, &he) != 0) {
-    if (he.lpData == lpMem) {
-      success = TRUE;
-      break;
-    }
-  }
-  HeapUnlock(hHeap);
-  return success;
-}
-#endif
-
-void NP_CALLBACK
-_releasevariantvalue(NPVariant* variant)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releasevariantvalue called from the wrong thread\n"));
-  }
-  switch (variant->type) {
-  case NPVariantType_Void :
-  case NPVariantType_Null :
-  case NPVariantType_Bool :
-  case NPVariantType_Int32 :
-  case NPVariantType_Double :
-    break;
-  case NPVariantType_String :
-    {
-      const NPString *s = &NPVARIANT_TO_STRING(*variant);
-
-      if (s->utf8characters) {
-#ifdef MOZ_MEMORY_WINDOWS
-        if (malloc_usable_size((void *)s->utf8characters) != 0) {
-          PR_Free((void *)s->utf8characters);
-        } else {
-          void *p = (void *)s->utf8characters;
-          DWORD nheaps = 0;
-          nsAutoTArray<HANDLE, 50> heaps;
-          nheaps = GetProcessHeaps(0, heaps.Elements());
-          heaps.AppendElements(nheaps);
-          GetProcessHeaps(nheaps, heaps.Elements());
-          for (DWORD i = 0; i < nheaps; i++) {
-            if (InHeap(heaps[i], p)) {
-              HeapFree(heaps[i], 0, p);
-              break;
-            }
-          }
-        }
-#else
-        PR_Free((void *)s->utf8characters);
-#endif
-      }
-      break;
-    }
-  case NPVariantType_Object:
-    {
-      NPObject *npobj = NPVARIANT_TO_OBJECT(*variant);
-
-      if (npobj)
-        _releaseobject(npobj);
-
-      break;
-    }
-  default:
-    NS_ERROR("Unknown NPVariant type!");
-  }
-
-  VOID_TO_NPVARIANT(*variant);
-}
-
-bool NP_CALLBACK
-_tostring(NPObject* npobj, NPVariant *result)
-{
-  NS_ERROR("Write me!");
-
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_tostring called from the wrong thread\n"));
-    return false;
-  }
-
-  return false;
-}
-
-static char *gNPPException;
-
-void NP_CALLBACK
-_setexception(NPObject* npobj, const NPUTF8 *message)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setexception called from the wrong thread\n"));
-    return;
-  }
-
-  if (gNPPException) {
-    // If a plugin throws multiple exceptions, we'll only report the
-    // last one for now.
-    free(gNPPException);
-  }
-
-  gNPPException = strdup(message);
-}
-
-const char *
-PeekException()
-{
-  return gNPPException;
-}
-
-void
-PopException()
-{
-  NS_ASSERTION(gNPPException, "Uh, no NPP exception to pop!");
-
-  if (gNPPException) {
-    free(gNPPException);
-
-    gNPPException = nsnull;
-  }
-}
-
-NPPExceptionAutoHolder::NPPExceptionAutoHolder()
-  : mOldException(gNPPException)
-{
-  gNPPException = nsnull;
-}
-
-NPPExceptionAutoHolder::~NPPExceptionAutoHolder()
-{
-  NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
-
-  gNPPException = mOldException;
-}
-
-NPError NP_CALLBACK
-_getvalue(NPP npp, NPNVariable variable, void *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getvalue called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
-                                     (void*)npp, (int)variable));
-
-  nsresult res;
-
-  PluginDestructionGuard guard(npp);
-
-  switch(variable) {
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-  case NPNVxDisplay : {
-#ifdef MOZ_WIDGET_GTK2
-    if (npp) {
-      ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
-      PRBool windowless = PR_FALSE;
-      inst->GetValue(nsPluginInstanceVariable_WindowlessBool, &windowless);
-      NPBool needXEmbed = PR_FALSE;
-      if (!windowless) {
-        inst->GetValue((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &needXEmbed);
-      }
-      if (windowless || needXEmbed) {
-        (*(Display **)result) = GDK_DISPLAY();
-        return NPERR_NO_ERROR;
-      }
-    }
-    // adobe nppdf calls XtGetApplicationNameAndClass(display,
-    // &instance, &class) we have to init Xt toolkit before get
-    // XtDisplay just call gtk_xtbin_new(w,0) once
-    static GtkWidget *gtkXtBinHolder = 0;
-    if (!gtkXtBinHolder) {
-      gtkXtBinHolder = gtk_xtbin_new(GDK_ROOT_PARENT(),0);
-      // it crashes on destroy, let it leak
-      // gtk_widget_destroy(gtkXtBinHolder);
-    }
-    (*(Display **)result) =  GTK_XTBIN(gtkXtBinHolder)->xtdisplay;
-    return NPERR_NO_ERROR;
-#endif
-    return NPERR_GENERIC_ERROR;
-  }
-
-  case NPNVxtAppContext:
-    return NPERR_GENERIC_ERROR;
-#endif
-
-#if defined(XP_WIN) || defined(XP_OS2) || defined(MOZ_WIDGET_GTK2)
-  case NPNVnetscapeWindow: {
-    if (!npp || !npp->ndata)
-      return NPERR_INVALID_INSTANCE_ERROR;
-
-    ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
-
-    nsCOMPtr<nsIPluginInstancePeer> peer;
-    if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) &&
-        peer &&
-        NS_SUCCEEDED(peer->GetValue(nsPluginInstancePeerVariable_NetscapeWindow,
-                                    result))) {
-      return NPERR_NO_ERROR;
-    }
-    return NPERR_GENERIC_ERROR;
-  }
-#endif
-
-  case NPNVjavascriptEnabledBool: {
-    *(NPBool*)result = PR_FALSE;
-    nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
-    if (prefs) {
-      PRBool js = PR_FALSE;;
-      res = prefs->GetBoolPref("javascript.enabled", &js);
-      if (NS_SUCCEEDED(res))
-        *(NPBool*)result = js;
-    }
-    return NPERR_NO_ERROR;
-  }
-
-  case NPNVasdEnabledBool:
-    *(NPBool*)result = PR_FALSE;
-    return NPERR_NO_ERROR;
-
-  case NPNVisOfflineBool: {
-    PRBool offline = PR_FALSE;
-    nsCOMPtr<nsIIOService> ioservice =
-      do_GetService(NS_IOSERVICE_CONTRACTID, &res);
-    if (NS_SUCCEEDED(res))
-      res = ioservice->GetOffline(&offline);
-    if (NS_FAILED(res))
-      return NPERR_GENERIC_ERROR;
-
-    *(NPBool*)result = offline;
-    return NPERR_NO_ERROR;
-  }
-
-  case NPNVserviceManager: {
-    nsIServiceManager * sm;
-    res = NS_GetServiceManager(&sm);
-    if (NS_SUCCEEDED(res)) {
-      *(nsIServiceManager**)result = sm;
-      return NPERR_NO_ERROR;
-    } else {
-      return NPERR_GENERIC_ERROR;
-    }
-  }
-
-  case NPNVDOMElement: {
-    ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
-    NS_ENSURE_TRUE(inst, NPERR_GENERIC_ERROR);
-
-    nsCOMPtr<nsIPluginInstancePeer> pip;
-    inst->GetPeer(getter_AddRefs(pip));
-    nsCOMPtr<nsIPluginTagInfo2> pti2 (do_QueryInterface(pip));
-    if (pti2) {
-      nsCOMPtr<nsIDOMElement> e;
-      pti2->GetDOMElement(getter_AddRefs(e));
-      if (e) {
-        NS_ADDREF(*(nsIDOMElement**)result = e.get());
-        return NPERR_NO_ERROR;
-      }
-    }
-    return NPERR_GENERIC_ERROR;
-  }
-
-  case NPNVDOMWindow: {
-    ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
-    NS_ENSURE_TRUE(inst, NPERR_GENERIC_ERROR);
-
-    nsIDOMWindow *domWindow = inst->GetDOMWindow().get();
-
-    if (domWindow) {
-      // Pass over ownership of domWindow to the caller.
-      (*(nsIDOMWindow**)result) = domWindow;
-
-      return NPERR_NO_ERROR;
-    }
-    return NPERR_GENERIC_ERROR;
-  }
-
-  case NPNVToolkit: {
-#ifdef MOZ_WIDGET_GTK2
-    *((NPNToolkitType*)result) = NPNVGtk2;
-#endif
-
-    if (*(NPNToolkitType*)result)
-        return NPERR_NO_ERROR;
-
-    return NPERR_GENERIC_ERROR;
-  }
-
-  case NPNVSupportsXEmbedBool: {
-#ifdef MOZ_WIDGET_GTK2
-    *(NPBool*)result = PR_TRUE;
-#else
-    *(NPBool*)result = PR_FALSE;
-#endif
-    return NPERR_NO_ERROR;
-  }
-
-  case NPNVWindowNPObject: {
-    *(NPObject **)result = _getwindowobject(npp);
-
-    return NPERR_NO_ERROR;
-  }
-
-  case NPNVPluginElementNPObject: {
-    *(NPObject **)result = _getpluginelement(npp);
-
-    return NPERR_NO_ERROR;
-  }
-
-  case NPNVSupportsWindowless: {
-#if defined(XP_WIN) || defined(XP_MACOSX) || (defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2))
-    *(NPBool*)result = PR_TRUE;
-#else
-    *(NPBool*)result = PR_FALSE;
-#endif
-    return NPERR_NO_ERROR;
-  }
-
-#ifdef XP_MACOSX
-  case NPNVpluginDrawingModel: {
-    if (npp) {
-      ns4xPluginInstance *inst = (ns4xPluginInstance*)npp->ndata;
-      if (inst) {
-        *(NPDrawingModel*)result = inst->GetDrawingModel();
-        return NPERR_NO_ERROR;
-      }
-    }
-    else {
-      return NPERR_GENERIC_ERROR;
-    }
-  }
-
-#ifndef NP_NO_QUICKDRAW
-  case NPNVsupportsQuickDrawBool: {
-    *(NPBool*)result = PR_TRUE;
-    
-    return NPERR_NO_ERROR;
-  }
-#endif
-
-  case NPNVsupportsCoreGraphicsBool: {
-    *(NPBool*)result = PR_TRUE;
-    
-    return NPERR_NO_ERROR;
-  }
-#endif
-
-  default:
-    return NPERR_GENERIC_ERROR;
-  }
-}
-
-NPError NP_CALLBACK
-_setvalue(NPP npp, NPPVariable variable, void *result)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setvalue called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
-                                     (void*)npp, (int)variable));
-
-  if (!npp)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
-
-  NS_ASSERTION(inst != NULL, "null instance");
-
-  if (inst == NULL)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  PluginDestructionGuard guard(inst);
-
-  switch (variable) {
-
-    // we should keep backward compatibility with 4x where the
-    // actual pointer value is checked rather than its content
-    // when passing booleans
-    case NPPVpluginWindowBool: {
-      NPBool bWindowless = (result == nsnull);
-      return inst->SetWindowless(bWindowless);
-    }
-
-    case NPPVpluginTransparentBool: {
-      NPBool bTransparent = (result != nsnull);
-      return inst->SetTransparent(bTransparent);
-    }
-
-    case NPPVjavascriptPushCallerBool:
-      {
-        nsresult rv;
-        nsCOMPtr<nsIJSContextStack> contextStack =
-          do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
-        if (NS_SUCCEEDED(rv)) {
-          NPBool bPushCaller = (result != nsnull);
-
-          if (bPushCaller) {
-            rv = NS_ERROR_FAILURE;
-
-            nsCOMPtr<nsIPluginInstancePeer> peer;
-            if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
-              nsCOMPtr<nsIPluginInstancePeer2> peer2 =
-                do_QueryInterface(peer);
-
-              if (peer2) {
-                JSContext *cx;
-                rv = peer2->GetJSContext(&cx);
-
-                if (NS_SUCCEEDED(rv))
-                  rv = contextStack->Push(cx);
-              }
-            }
-          } else {
-            rv = contextStack->Pop(nsnull);
-          }
-        }
-        return NS_SUCCEEDED(rv) ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
-      }
-
-    case NPPVpluginKeepLibraryInMemory: {
-      NPBool bCached = (result != nsnull);
-      return inst->SetCached(bCached);
-    }
-
-    case NPPVpluginWantsAllNetworkStreams: {
-      PRBool bWantsAllNetworkStreams = (result != nsnull);
-      return inst->SetWantsAllNetworkStreams(bWantsAllNetworkStreams);
-    }
-
-#ifdef XP_MACOSX
-    case NPPVpluginDrawingModel: {
-      if (inst) {
-        int dModelValue = (int)result;
-        inst->SetDrawingModel((NPDrawingModel)dModelValue);
-        return NPERR_NO_ERROR;
-      }
-      else {
-        return NPERR_GENERIC_ERROR;
-      }
-    }
-#endif
-
-    default:
-      return NPERR_NO_ERROR;
-  }
-}
-
-NPError NP_CALLBACK
-_requestread(NPStream *pstream, NPByteRange *rangeList)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_requestread called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_RequestRead: stream=%p\n",
-                                     (void*)pstream));
-
-#ifdef PLUGIN_LOGGING
-  for(NPByteRange * range = rangeList; range != nsnull; range = range->next)
-    PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY,
-    ("%i-%i", range->offset, range->offset + range->length - 1));
-
-  PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY, ("\n\n"));
-  PR_LogFlush();
-#endif
-
-  if (!pstream || !rangeList || !pstream->ndata)
-    return NPERR_INVALID_PARAM;
-
-  ns4xPluginStreamListener * streamlistener =
-    (ns4xPluginStreamListener *)pstream->ndata;
-
-  nsPluginStreamType streamtype = nsPluginStreamType_Normal;
-
-  streamlistener->GetStreamType(&streamtype);
-
-  if (streamtype != nsPluginStreamType_Seek)
-    return NPERR_STREAM_NOT_SEEKABLE;
-
-  if (streamlistener->mStreamInfo)
-    streamlistener->mStreamInfo->RequestRead((nsByteRange *)rangeList);
-
-  return NS_OK;
-}
-
-// Deprecated, only stubbed out
-void* NP_CALLBACK /* OJI type: JRIEnv* */
-_getJavaEnv(void)
-{
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
-  return NULL;
-}
-
-const char * NP_CALLBACK
-_useragent(NPP npp)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_useragent called from the wrong thread\n"));
-    return nsnull;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
-
-  nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
-  if (!pm)
-    return nsnull;
-
-  const char *retstr;
-  nsresult rv = pm->UserAgent(&retstr);
-  if (NS_FAILED(rv))
-    return nsnull;
-
-  return retstr;
-}
-
-void * NP_CALLBACK
-_memalloc (uint32_t size)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN_memalloc called from the wrong thread\n"));
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
-  return nsMemory::Alloc(size);
-}
-
-// Deprecated, only stubbed out
-void* NP_CALLBACK /* OJI type: jref */
-_getJavaPeer(NPP npp)
-{
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
-  return NULL;
-}
-
-void NP_CALLBACK
-_pushpopupsenabledstate(NPP npp, NPBool enabled)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_pushpopupsenabledstate called from the wrong thread\n"));
-    return;
-  }
-  ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
-  if (!inst)
-    return;
-
-  inst->PushPopupsEnabledState(enabled);
-}
-
-void NP_CALLBACK
-_poppopupsenabledstate(NPP npp)
-{
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_poppopupsenabledstate called from the wrong thread\n"));
-    return;
-  }
-  ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
-  if (!inst)
-    return;
-
-  inst->PopPopupsEnabledState();
-}
-
-class nsPluginThreadRunnable : public nsRunnable,
-                               public PRCList
-{
-public:
-  nsPluginThreadRunnable(NPP instance, PluginThreadCallback func,
-                         void *userData);
-  virtual ~nsPluginThreadRunnable();
-
-  NS_IMETHOD Run();
-
-  PRBool IsForInstance(NPP instance)
-  {
-    return (mInstance == instance);
-  }
-
-  void Invalidate()
-  {
-    mFunc = nsnull;
-  }
-
-  PRBool IsValid()
-  {
-    return (mFunc != nsnull);
-  }
-
-private:  
-  NPP mInstance;
-  PluginThreadCallback mFunc;
-  void *mUserData;
-};
-
-nsPluginThreadRunnable::nsPluginThreadRunnable(NPP instance,
-                                               PluginThreadCallback func,
-                                               void *userData)
-  : mInstance(instance), mFunc(func), mUserData(userData)
-{
-  if (!sPluginThreadAsyncCallLock) {
-    // Failed to create lock, not much we can do here then...
-    mFunc = nsnull;
-
-    return;
-  }
-
-  PR_INIT_CLIST(this);
-
-  {
-    nsAutoLock lock(sPluginThreadAsyncCallLock);
-
-    ns4xPluginInstance *inst = (ns4xPluginInstance *)instance->ndata;
-    if (!inst || !inst->IsStarted()) {
-      // The plugin was stopped, ignore this async call.
-      mFunc = nsnull;
-
-      return;
-    }
-
-    PR_APPEND_LINK(this, &sPendingAsyncCalls);
-  }
-}
-
-nsPluginThreadRunnable::~nsPluginThreadRunnable()
-{
-  if (!sPluginThreadAsyncCallLock) {
-    return;
-  }
-
-  {
-    nsAutoLock lock(sPluginThreadAsyncCallLock);
-
-    PR_REMOVE_LINK(this);
-  }
-}
-
-NS_IMETHODIMP
-nsPluginThreadRunnable::Run()
-{
-  if (mFunc) {
-    PluginDestructionGuard guard(mInstance);
-
-    NS_TRY_SAFE_CALL_VOID(mFunc(mUserData), nsnull, nsnull);
-  }
-
-  return NS_OK;
-}
-
-void NP_CALLBACK
-_pluginthreadasynccall(NPP instance, PluginThreadCallback func, void *userData)
-{
-  if (NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from the main thread\n"));
-  } else {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from a non main thread\n"));
-  }
-  nsRefPtr<nsPluginThreadRunnable> evt =
-    new nsPluginThreadRunnable(instance, func, userData);
-
-  if (evt && evt->IsValid()) {
-    NS_DispatchToMainThread(evt);
-  }
-}
-
-void
-OnPluginDestroy(NPP instance)
-{
-  if (!sPluginThreadAsyncCallLock) {
-    return;
-  }
-
-  {
-    nsAutoLock lock(sPluginThreadAsyncCallLock);
-
-    if (PR_CLIST_IS_EMPTY(&sPendingAsyncCalls)) {
-      return;
-    }
-
-    nsPluginThreadRunnable *r =
-      (nsPluginThreadRunnable *)PR_LIST_HEAD(&sPendingAsyncCalls);
-
-    do {
-      if (r->IsForInstance(instance)) {
-        r->Invalidate();
-      }
-
-      r = (nsPluginThreadRunnable *)PR_NEXT_LINK(r);
-    } while (r != &sPendingAsyncCalls);
-  }
-}
-
-void
-OnShutdown()
-{
-  NS_ASSERTION(PR_CLIST_IS_EMPTY(&sPendingAsyncCalls),
-               "Pending async plugin call list not cleaned up!");
-
-  if (sPluginThreadAsyncCallLock) {
-    nsAutoLock::DestroyLock(sPluginThreadAsyncCallLock);
-
-    sPluginThreadAsyncCallLock = nsnull;
-  }
-}
-
-void
-EnterAsyncPluginThreadCallLock()
-{
-  if (sPluginThreadAsyncCallLock) {
-    PR_Lock(sPluginThreadAsyncCallLock);
-  }
-}
-
-void
-ExitAsyncPluginThreadCallLock()
-{
-  if (sPluginThreadAsyncCallLock) {
-    PR_Unlock(sPluginThreadAsyncCallLock);
-  }
-}
-
-NPP NPPStack::sCurrentNPP = nsnull;
diff -r 8dcf83cc8500 modules/plugin/base/src/ns4xPlugin.h
--- a/modules/plugin/base/src/ns4xPlugin.h	Sun Sep 14 00:37:23 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,267 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef ns4xPlugin_h_
-#define ns4xPlugin_h_
-
-#include "nsIFactory.h"
-#include "nsIPlugin.h"
-#include "nsIPluginInstancePeer.h"
-#include "nsIWindowlessPlugInstPeer.h"
-#include "prlink.h"
-#include "npupp.h"
-#include "nsPluginHostImpl.h"
-
-/*
- * Use this macro before each exported function
- * (between the return address and the function
- * itself), to ensure that the function has the
- * right calling conventions on Win16.
- */
-// XXX NP_CALLBACK should be the same as NP_LOADDS in npapi.h which differs
-// for WIN16 and maybe WIN64?
-#ifdef XP_OS2
-#define NP_CALLBACK _System
-#else
-#define NP_CALLBACK
-#endif
-#if defined(XP_WIN)
-#define NS_4XPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
-#elif defined(XP_OS2)
-#define NS_4XPLUGIN_CALLBACK(_type, _name) _type (_System * _name)
-#else
-#define NS_4XPLUGIN_CALLBACK(_type, _name) _type (* _name)
-#endif
-
-typedef NS_4XPLUGIN_CALLBACK(NPError, NP_GETENTRYPOINTS) (NPPluginFuncs* pCallbacks);
-typedef NS_4XPLUGIN_CALLBACK(NPError, NP_PLUGININIT) (const NPNetscapeFuncs* pCallbacks);
-typedef NS_4XPLUGIN_CALLBACK(NPError, NP_PLUGINUNIXINIT) (const NPNetscapeFuncs* pCallbacks,NPPluginFuncs* fCallbacks);
-typedef NS_4XPLUGIN_CALLBACK(NPError, NP_PLUGINSHUTDOWN) (void);
-#ifdef XP_MACOSX
-typedef NS_4XPLUGIN_CALLBACK(NPError, NP_MAIN) (NPNetscapeFuncs* nCallbacks, NPPluginFuncs* pCallbacks, NPP_ShutdownUPP* unloadUpp);
-#endif
-
-class ns4xPlugin : public nsIPlugin
-{
-public:
-  ns4xPlugin(NPPluginFuncs* callbacks, PRLibrary* aLibrary,
-             NP_PLUGINSHUTDOWN aShutdown);
-  virtual ~ns4xPlugin(void);
-
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIFACTORY
-  NS_DECL_NSIPLUGIN
-
-  // Constructs and initializes an ns4xPlugin object
-  static nsresult CreatePlugin(const char* aFileName,
-                               const char* aFullPath,
-                               PRLibrary* aLibrary,
-                               nsIPlugin** aResult);
-#ifdef XP_MACOSX
-  void SetPluginRefNum(short aRefNum);
-#endif
-
-protected:
-  // Ensures that the static CALLBACKS is properly initialized
-  static void CheckClassInitialized(void);
-
-#ifdef XP_MACOSX
-  short fPluginRefNum;
-#endif
-
-  // The plugin-side callbacks that the browser calls. One set of
-  // plugin callbacks for each plugin.
-  NPPluginFuncs fCallbacks;
-  PRLibrary*    fLibrary;
-
-  NP_PLUGINSHUTDOWN fShutdownEntry;
-
-  // The browser-side callbacks that a 4.x-style plugin calls.
-  static NPNetscapeFuncs CALLBACKS;
-};
-
-
-PR_BEGIN_EXTERN_C
-NPObject* NP_CALLBACK
-_getwindowobject(NPP npp);
-
-NPObject* NP_CALLBACK
-_getpluginelement(NPP npp);
-
-NPIdentifier NP_CALLBACK
-_getstringidentifier(const NPUTF8* name);
-
-void NP_CALLBACK
-_getstringidentifiers(const NPUTF8** names, int32_t nameCount,
-                      NPIdentifier *identifiers);
-
-bool NP_CALLBACK
-_identifierisstring(NPIdentifier identifiers);
-
-NPIdentifier NP_CALLBACK
-_getintidentifier(int32_t intid);
-
-NPUTF8* NP_CALLBACK
-_utf8fromidentifier(NPIdentifier identifier);
-
-int32_t NP_CALLBACK
-_intfromidentifier(NPIdentifier identifier);
-
-NPObject* NP_CALLBACK
-_createobject(NPP npp, NPClass* aClass);
-
-NPObject* NP_CALLBACK
-_retainobject(NPObject* npobj);
-
-void NP_CALLBACK
-_releaseobject(NPObject* npobj);
-
-bool NP_CALLBACK
-_invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
-        uint32_t argCount, NPVariant *result);
-
-bool NP_CALLBACK
-_invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
-               uint32_t argCount, NPVariant *result);
-
-bool NP_CALLBACK
-_evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result);
-
-bool NP_CALLBACK
-_getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-             NPVariant *result);
-
-bool NP_CALLBACK
-_setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-             const NPVariant *value);
-
-bool NP_CALLBACK
-_removeproperty(NPP npp, NPObject* npobj, NPIdentifier property);
-
-bool NP_CALLBACK
-_hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
-
-bool NP_CALLBACK
-_hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName);
-
-bool NP_CALLBACK
-_enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
-           uint32_t *count);
-
-bool NP_CALLBACK
-_construct(NPP npp, NPObject* npobj, const NPVariant *args,
-           uint32_t argCount, NPVariant *result);
-
-void NP_CALLBACK
-_releasevariantvalue(NPVariant *variant);
-
-void NP_CALLBACK
-_setexception(NPObject* npobj, const NPUTF8 *message);
-
-PR_END_EXTERN_C
-
-const char *
-PeekException();
-
-void
-PopException();
-
-void
-OnPluginDestroy(NPP instance);
-
-void
-OnShutdown();
-
-void
-EnterAsyncPluginThreadCallLock();
-void
-ExitAsyncPluginThreadCallLock();
-
-class NPPStack
-{
-public:
-  static NPP Peek()
-  {
-    return sCurrentNPP;
-  }
-
-protected:
-  static NPP sCurrentNPP;
-};
-
-// XXXjst: The NPPAutoPusher stack is a bit redundant now that
-// PluginDestructionGuard exists, and could thus be replaced by code
-// that uses the PluginDestructionGuard list of plugins on the
-// stack. But they're not identical, and to minimize code changes
-// we're keeping both for the moment, and making NPPAutoPusher inherit
-// the PluginDestructionGuard class to avoid having to keep two
-// separate objects on the stack since we always want a
-// PluginDestructionGuard where we use an NPPAutoPusher.
-
-class NPPAutoPusher : public NPPStack,
-                      protected PluginDestructionGuard
-{
-public:
-  NPPAutoPusher(NPP npp)
-    : PluginDestructionGuard(npp),
-      mOldNPP(sCurrentNPP)
-  {
-    NS_ASSERTION(npp, "Uh, null npp passed to NPPAutoPusher!");
-
-    sCurrentNPP = npp;
-  }
-
-  ~NPPAutoPusher()
-  {
-    sCurrentNPP = mOldNPP;
-  }
-
-private:
-  NPP mOldNPP;
-};
-
-class NPPExceptionAutoHolder
-{
-public:
-  NPPExceptionAutoHolder();
-  ~NPPExceptionAutoHolder();
-
-protected:
-  char *mOldException;
-};
-
-#endif // ns4xPlugin_h_
diff -r 8dcf83cc8500 modules/plugin/base/src/ns4xPluginInstance.cpp
--- a/modules/plugin/base/src/ns4xPluginInstance.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1550 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Tim Copperfield <timecop@network.email.ne.jp>
- *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "prlog.h"
-#include "prmem.h"
-#include "nscore.h"
-#include "prenv.h"
-
-#include "ns4xPluginInstance.h"
-#include "ns4xPlugin.h"
-#include "ns4xPluginStreamListener.h"
-#include "nsPluginHostImpl.h"
-#include "nsPluginSafety.h"
-#include "nsPluginLogging.h"
-
-#include "nsPIPluginInstancePeer.h"
-#include "nsPIDOMWindow.h"
-#include "nsIDocument.h"
-
-#include "nsJSNPRuntime.h"
-
-#ifdef XP_OS2
-#include "nsILegacyPluginWrapperOS2.h"
-#endif
-
-static NS_DEFINE_IID(kCPluginManagerCID, NS_PLUGINMANAGER_CID); // needed for NS_TRY_SAFE_CALL
-static NS_DEFINE_IID(kIPluginStreamListenerIID, NS_IPLUGINSTREAMLISTENER_IID);
-
-// ns4xPluginStreamListener Methods
-
-NS_IMPL_ISUPPORTS3(ns4xPluginStreamListener, nsIPluginStreamListener,
-                   nsITimerCallback, nsIHTTPHeaderListener)
-
-ns4xPluginStreamListener::ns4xPluginStreamListener(ns4xPluginInstance* inst, 
-                                                   void* notifyData,
-                                                   const char* aURL)
-  : mNotifyData(notifyData),
-    mStreamBuffer(nsnull),
-    mNotifyURL(aURL ? PL_strdup(aURL) : nsnull),
-    mInst(inst),
-    mStreamBufferSize(0),
-    mStreamBufferByteCount(0),
-    mStreamType(nsPluginStreamType_Normal),
-    mStreamStarted(PR_FALSE),
-    mStreamCleanedUp(PR_FALSE),
-    mCallNotify(PR_FALSE),
-    mIsSuspended(PR_FALSE),
-    mIsPluginInitJSStream(mInst->mInPluginInitCall &&
-                          aURL && strncmp(aURL, "javascript:",
-                                          sizeof("javascript:") - 1) == 0),
-    mResponseHeaderBuf(nsnull)
-{
-  // Initialize the 4.x interface structure
-  memset(&mNPStream, 0, sizeof(mNPStream));
-
-  NS_IF_ADDREF(mInst);
-}
-
-ns4xPluginStreamListener::~ns4xPluginStreamListener(void)
-{
-  // remove itself from the instance stream list
-  ns4xPluginInstance *inst = mInst;
-  if (inst) {
-    nsInstanceStream * prev = nsnull;
-    for (nsInstanceStream *is = inst->mStreams; is != nsnull; is = is->mNext) {
-      if (is->mPluginStreamListener == this) {
-        if (!prev)
-          inst->mStreams = is->mNext;
-        else
-          prev->mNext = is->mNext;
-
-        delete is;
-        break;
-      }
-      prev = is;
-    }
-  }
-
-  // For those cases when NewStream is never called, we still may need
-  // to fire a notification callback. Return network error as fallback
-  // reason because for other cases, notify should have already been
-  // called for other reasons elsewhere.
-  CallURLNotify(NPRES_NETWORK_ERR);
-
-  // lets get rid of the buffer
-  if (mStreamBuffer) {
-    PR_Free(mStreamBuffer);
-    mStreamBuffer=nsnull;
-  }
-
-  NS_IF_RELEASE(inst);
-
-  if (mNotifyURL)
-    PL_strfree(mNotifyURL);
-
-  if (mResponseHeaderBuf)
-    PL_strfree(mResponseHeaderBuf);
-}
-
-nsresult ns4xPluginStreamListener::CleanUpStream(NPReason reason)
-{
-  nsresult rv = NS_ERROR_FAILURE;
-
-  if (mStreamCleanedUp)
-    return NS_OK;
-
-  if (!mInst || !mInst->IsStarted())
-    return rv;
-
-  PluginDestructionGuard guard(mInst);
-
-  const NPPluginFuncs *callbacks = nsnull;
-  mInst->GetCallbacks(&callbacks);
-  if (!callbacks)
-    return rv;
-
-  NPP npp;
-  mInst->GetNPP(&npp);
-
-  if (mStreamStarted && callbacks->destroystream) {
-    PRLibrary* lib = nsnull;
-    lib = mInst->fLibrary;
-    NPError error;
-    NS_TRY_SAFE_CALL_RETURN(error, CallNPP_DestroyStreamProc(callbacks->destroystream,
-                                                               npp,
-                                                               &mNPStream,
-                                                               reason), lib, mInst);
-
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-    ("NPP DestroyStream called: this=%p, npp=%p, reason=%d, return=%d, url=%s\n",
-    this, npp, reason, error, mNPStream.url));
-
-    if (error == NPERR_NO_ERROR)
-      rv = NS_OK;
-  }
-
-  mStreamCleanedUp = PR_TRUE;
-  mStreamStarted   = PR_FALSE;
-
-  StopDataPump();
-
-  // fire notification back to plugin, just like before
-  CallURLNotify(reason);
-
-  return rv;
-}
-
-void ns4xPluginStreamListener::CallURLNotify(NPReason reason)
-{
-  if (!mCallNotify || !mInst || !mInst->IsStarted())
-    return;
-
-  PluginDestructionGuard guard(mInst);
-
-  mCallNotify = PR_FALSE; // only do this ONCE and prevent recursion
-
-  const NPPluginFuncs *callbacks = nsnull;
-  mInst->GetCallbacks(&callbacks);
-  if (!callbacks)
-    return;
-  
-  if (callbacks->urlnotify) {
-
-    NPP npp;
-    mInst->GetNPP(&npp);
-
-    NS_TRY_SAFE_CALL_VOID(CallNPP_URLNotifyProc(callbacks->urlnotify,
-                                                npp,
-                                                mNotifyURL,
-                                                reason,
-                                                mNotifyData), mInst->fLibrary, mInst);
-
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-    ("NPP URLNotify called: this=%p, npp=%p, notify=%p, reason=%d, url=%s\n",
-    this, npp, mNotifyData, reason, mNotifyURL));
-  }
-}
-
-NS_IMETHODIMP
-ns4xPluginStreamListener::OnStartBinding(nsIPluginStreamInfo* pluginInfo)
-{
-  if (!mInst)
-    return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(mInst);
-
-  NPP npp;
-  const NPPluginFuncs *callbacks = nsnull;
-
-  mInst->GetCallbacks(&callbacks);
-  mInst->GetNPP(&npp);
-
-  if (!callbacks || !mInst->IsStarted())
-    return NS_ERROR_FAILURE;
-
-  PRBool seekable;
-  nsMIMEType contentType;
-  PRUint16 streamType = NP_NORMAL;
-  NPError error;
-
-  mNPStream.ndata = (void*) this;
-  pluginInfo->GetURL(&mNPStream.url);
-  mNPStream.notifyData = mNotifyData;
-
-  pluginInfo->GetLength((PRUint32*)&(mNPStream.end));
-  pluginInfo->GetLastModified((PRUint32*)&(mNPStream.lastmodified));
-  pluginInfo->IsSeekable(&seekable);
-  pluginInfo->GetContentType(&contentType);
-  
-  if (!mResponseHeaders.IsEmpty()) {
-    mResponseHeaderBuf = PL_strdup(mResponseHeaders.get());
-    mNPStream.headers = mResponseHeaderBuf;
-  }
-
-  mStreamInfo = pluginInfo;
-
-  NS_TRY_SAFE_CALL_RETURN(error, CallNPP_NewStreamProc(callbacks->newstream,
-                                                       npp,
-                                                       (char *)contentType,
-                                                       &mNPStream,
-                                                       seekable,
-                                                       &streamType), mInst->fLibrary, mInst);
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("NPP NewStream called: this=%p, npp=%p, mime=%s, seek=%d, type=%d, return=%d, url=%s\n",
-  this, npp, (char *)contentType, seekable, streamType, error, mNPStream.url));
-
-  if (error != NPERR_NO_ERROR)
-    return NS_ERROR_FAILURE;
-
-  // translate the old 4x style stream type to the new one
-  switch(streamType)
-  {
-    case NP_NORMAL:
-      mStreamType = nsPluginStreamType_Normal; 
-      break;
-    case NP_ASFILEONLY:
-      mStreamType = nsPluginStreamType_AsFileOnly; 
-      break;
-    case NP_ASFILE:
-      mStreamType = nsPluginStreamType_AsFile; 
-      break;
-    case NP_SEEK:
-      mStreamType = nsPluginStreamType_Seek; 
-      break;
-    default:
-      return NS_ERROR_FAILURE;
-  }
-
-  mStreamStarted = PR_TRUE;
-  return NS_OK;
-}
-
-nsresult
-ns4xPluginStreamListener::SuspendRequest()
-{
-  NS_ASSERTION(!mIsSuspended,
-               "Suspending a request that's already suspended!");
-
-  nsCOMPtr<nsI4xPluginStreamInfo> pluginInfo4x =
-    do_QueryInterface(mStreamInfo);
-  nsIRequest *request;
-
-  if (!pluginInfo4x || !(request = pluginInfo4x->GetRequest())) {
-    NS_ERROR("Trying to suspend a non-suspendable stream!");
-
-    return NS_ERROR_FAILURE;
-  }
-
-  nsresult rv = StartDataPump();
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  mIsSuspended = PR_TRUE;
-
-  return request->Suspend();
-}
-
-void
-ns4xPluginStreamListener::ResumeRequest()
-{
-  nsCOMPtr<nsI4xPluginStreamInfo> pluginInfo4x =
-    do_QueryInterface(mStreamInfo);
-
-  nsIRequest *request = pluginInfo4x->GetRequest();
-
-  // request can be null if the network stream is done.
-  if (request) {
-    request->Resume();
-  }
-
-  mIsSuspended = PR_FALSE;
-}
-
-nsresult
-ns4xPluginStreamListener::StartDataPump()
-{
-  nsresult rv;
-  mDataPumpTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  // Start pumping data to the plugin every 100ms until it obeys and
-  // eats the data.
-  return mDataPumpTimer->InitWithCallback(this, 100,
-                                          nsITimer::TYPE_REPEATING_SLACK);
-}
-
-void
-ns4xPluginStreamListener::StopDataPump()
-{
-  if (mDataPumpTimer) {
-    mDataPumpTimer->Cancel();
-
-    mDataPumpTimer = nsnull;
-  }
-}
-
-// Return true if a javascript: load that was started while the plugin
-// was being initialized is still in progress.
-PRBool
-ns4xPluginStreamListener::PluginInitJSLoadInProgress()
-{
-  for (nsInstanceStream *is = mInst->mStreams; is; is = is->mNext) {
-    if (is->mPluginStreamListener->mIsPluginInitJSStream) {
-      return PR_TRUE;
-    }
-  }
-
-  return PR_FALSE;
-}
-
-// This method is called when there's more data available off the
-// network, but it's also called from our data pump when we're feeding
-// the plugin data that we already got off the network, but the plugin
-// was unable to consume it at the point it arrived. In the case when
-// the plugin pump calls this method, the input argument will be null,
-// and the length will be the number of bytes available in our
-// internal buffer.
-NS_IMETHODIMP
-ns4xPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,
-                                          nsIInputStream* input,
-                                          PRUint32 length)
-{
-  if (!mInst || !mInst->IsStarted())
-    return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(mInst);
-
-  // Just in case the caller switches plugin info on us.
-  mStreamInfo = pluginInfo;
-
-  const NPPluginFuncs *callbacks = nsnull;
-  mInst->GetCallbacks(&callbacks);
-  // check out if plugin implements NPP_Write call
-  if (!callbacks || !callbacks->write || !length)
-    return NS_ERROR_FAILURE; // it'll cancel necko transaction 
-  
-  if (!mStreamBuffer) {
-    // To optimize the mem usage & performance we have to allocate
-    // mStreamBuffer here in first ODA when length of data available
-    // in input stream is known.  mStreamBuffer will be freed in DTOR.
-    // we also have to remember the size of that buff to make safe
-    // consecutive Read() calls form input stream into our buff.
-
-    PRUint32 contentLength;
-    pluginInfo->GetLength(&contentLength);
-
-    mStreamBufferSize = PR_MAX(length, contentLength);
-
-    // Limit the size of the initial buffer to MAX_PLUGIN_NECKO_BUFFER
-    // (16k). This buffer will grow if needed, as in the case where
-    // we're getting data faster than the plugin can process it.
-    mStreamBufferSize = PR_MIN(mStreamBufferSize, MAX_PLUGIN_NECKO_BUFFER);
-
-    mStreamBuffer = (char*) PR_Malloc(mStreamBufferSize);
-    if (!mStreamBuffer)
-      return NS_ERROR_OUT_OF_MEMORY;
-  }
-  
-  // prepare NPP_ calls params
-  NPP npp;
-  mInst->GetNPP(&npp);
-
-  PRInt32 streamPosition;
-  pluginInfo->GetStreamOffset(&streamPosition);
-  PRInt32 streamOffset = streamPosition;
-
-  if (input) {
-    streamOffset += length;
-
-    // Set new stream offset for the next ODA call regardless of how
-    // following NPP_Write call will behave we pretend to consume all
-    // data from the input stream.  It's possible that current steam
-    // position will be overwritten from NPP_RangeRequest call made
-    // from NPP_Write, so we cannot call SetStreamOffset after
-    // NPP_Write.
-    //
-    // Note: there is a special case when data flow should be
-    // temporarily stopped if NPP_WriteReady returns 0 (bug #89270)
-    pluginInfo->SetStreamOffset(streamOffset);
-
-    // set new end in case the content is compressed
-    // initial end is less than end of decompressed stream
-    // and some plugins (e.g. acrobat) can fail. 
-    if ((PRInt32)mNPStream.end < streamOffset)
-      mNPStream.end = streamOffset;
-  }
-
-  nsresult rv = NS_OK;
-  while (NS_SUCCEEDED(rv) && length > 0) {
-    if (input && length) {
-      if (mStreamBufferSize < mStreamBufferByteCount + length &&
-          mIsSuspended) {
-        // We're in the ::OnDataAvailable() call that we might get
-        // after suspending a request, or we suspended the request
-        // from within this ::OnDataAvailable() call while there's
-        // still data in the input, and we don't have enough space to
-        // store what we got off the network. Reallocate our internal
-        // buffer.
-        mStreamBufferSize = mStreamBufferByteCount + length;
-        char *buf = (char *)PR_Realloc(mStreamBuffer, mStreamBufferSize);
-        if (!buf)
-          return NS_ERROR_OUT_OF_MEMORY;
-
-        mStreamBuffer = buf;
-      }
-
-      PRUint32 bytesToRead =
-        PR_MIN(length, mStreamBufferSize - mStreamBufferByteCount);
-
-      PRUint32 amountRead = 0;
-      rv = input->Read(mStreamBuffer + mStreamBufferByteCount, bytesToRead,
-                       &amountRead);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      if (amountRead == 0) {
-        NS_NOTREACHED("input->Read() returns no data, it's almost impossible "
-                      "to get here");
-
-        break;
-      }
-
-      mStreamBufferByteCount += amountRead;
-      length -= amountRead;
-    } else {
-      // No input, nothing to read. Set length to 0 so that we don't
-      // keep iterating through this outer loop any more.
-
-      length = 0;
-    }
-
-    // Temporary pointer to the beginning of the data we're writing as
-    // we loop and feed the plugin data.
-    char *ptrStreamBuffer = mStreamBuffer;
-
-    // it is possible plugin's NPP_Write() returns 0 byte consumed. We
-    // use zeroBytesWriteCount to count situation like this and break
-    // the loop
-    PRInt32 zeroBytesWriteCount = 0;
-
-    // mStreamBufferByteCount tells us how many bytes there are in the
-    // buffer. WriteReady returns to us how many bytes the plugin is
-    // ready to handle.
-    while (mStreamBufferByteCount > 0) {
-      PRInt32 numtowrite;
-      if (callbacks->writeready) {
-        NS_TRY_SAFE_CALL_RETURN(numtowrite, 
-                                CallNPP_WriteReadyProc(callbacks->writeready,
-                                                       npp, &mNPStream),
-                                mInst->fLibrary, mInst);
-
-        NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                       ("NPP WriteReady called: this=%p, npp=%p, "
-                        "return(towrite)=%d, url=%s\n",
-                        this, npp, numtowrite, mNPStream.url));
-
-        if (!mStreamStarted) {
-          // The plugin called NPN_DestroyStream() from within
-          // NPP_WriteReady(), kill the stream.
-
-          return NS_BINDING_ABORTED;
-        }
-
-        // if WriteReady returned 0, the plugin is not ready to handle
-        // the data, suspend the stream (if it isn't already
-        // suspended).
-        //
-        // Also suspend the stream if the stream we're loading is not
-        // a javascript: URL load that was initiated during plugin
-        // initialization and there currently is such a stream
-        // loading. This is done to work around a Windows Media Player
-        // plugin bug where it can't deal with being fed data for
-        // other streams while it's waiting for data from the
-        // javascript: URL loads it requests during
-        // initialization. See bug 386493 for more details.
-
-        if (numtowrite <= 0 ||
-            (!mIsPluginInitJSStream && PluginInitJSLoadInProgress())) {
-          if (!mIsSuspended) {
-            rv = SuspendRequest();
-          }
-
-          // Break out of the inner loop, but keep going through the
-          // outer loop in case there's more data to read from the
-          // input stream.
-
-          break;
-        }
-
-        numtowrite = PR_MIN(numtowrite, mStreamBufferByteCount);
-      } else {
-        // if WriteReady is not supported by the plugin, just write
-        // the whole buffer
-        numtowrite = mStreamBufferByteCount;
-      }
-
-      PRInt32 writeCount = 0; // bytes consumed by plugin instance
-      NS_TRY_SAFE_CALL_RETURN(writeCount, 
-                              CallNPP_WriteProc(callbacks->write, npp,
-                                                &mNPStream, streamPosition,
-                                                numtowrite,
-                                                ptrStreamBuffer),
-                              mInst->fLibrary, mInst);
-
-      NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                     ("NPP Write called: this=%p, npp=%p, pos=%d, len=%d, "
-                      "buf=%s, return(written)=%d,  url=%s\n",
-                      this, npp, streamPosition, numtowrite,
-                      ptrStreamBuffer, writeCount, mNPStream.url));
-
-      if (!mStreamStarted) {
-        // The plugin called NPN_DestroyStream() from within
-        // NPP_Write(), kill the stream.
-
-        return NS_BINDING_ABORTED;
-      }
-
-      if (writeCount > 0) {
-        NS_ASSERTION(writeCount <= mStreamBufferByteCount,
-                     "Plugin read past the end of the available data!");
-
-        writeCount = PR_MIN(writeCount, mStreamBufferByteCount);
-        mStreamBufferByteCount -= writeCount;
-
-        streamPosition += writeCount;
-
-        zeroBytesWriteCount = 0;
-
-        if (mStreamBufferByteCount > 0) {
-          // This alignment code is most likely bogus, but we'll leave
-          // it in for now in case it matters for some plugins on some
-          // architectures. Who knows...
-          if (writeCount % sizeof(PRWord)) {
-            // memmove will take care  about alignment 
-            memmove(mStreamBuffer, ptrStreamBuffer + writeCount,
-                    mStreamBufferByteCount);
-            ptrStreamBuffer = mStreamBuffer;
-          } else {
-            // if aligned we can use ptrStreamBuffer += to eliminate
-            // memmove()
-            ptrStreamBuffer += writeCount;
-          }
-        }
-      } else if (writeCount == 0) {
-        // if NPP_Write() returns writeCount == 0 lets say 3 times in
-        // a row, suspend the request and continue feeding the plugin
-        // the data we got so far. Once that data is consumed, we'll
-        // resume the request.
-        if (mIsSuspended || ++zeroBytesWriteCount == 3) {
-          if (!mIsSuspended) {
-            rv = SuspendRequest();
-          }
-
-          // Break out of the for loop, but keep going through the
-          // while loop in case there's more data to read from the
-          // input stream.
-
-          break;
-        }
-      } else {
-        // Something's really wrong, kill the stream.
-        rv = NS_ERROR_FAILURE;
-
-        break;
-      }  
-    } // end of inner while loop
-
-    if (mStreamBufferByteCount && mStreamBuffer != ptrStreamBuffer) {
-      memmove(mStreamBuffer, ptrStreamBuffer, mStreamBufferByteCount);
-    }
-  }
-
-  if (streamPosition != streamOffset) {
-    // The plugin didn't consume all available data, or consumed some
-    // of our cached data while we're pumping cached data. Adjust the
-    // plugin info's stream offset to match reality, except if the
-    // plugin info's stream offset was set by a re-entering
-    // NPN_RequestRead() call.
-
-    PRInt32 postWriteStreamPosition;
-    pluginInfo->GetStreamOffset(&postWriteStreamPosition);
-
-    if (postWriteStreamPosition == streamOffset) {
-      pluginInfo->SetStreamOffset(streamPosition);
-    }
-  }
-
-  return rv;
-}
-
-NS_IMETHODIMP
-ns4xPluginStreamListener::OnFileAvailable(nsIPluginStreamInfo* pluginInfo, 
-                                          const char* fileName)
-{
-  if (!mInst || !mInst->IsStarted())
-    return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(mInst);
-
-  const NPPluginFuncs *callbacks = nsnull;
-  mInst->GetCallbacks(&callbacks);
-  if (!callbacks || !callbacks->asfile)
-    return NS_ERROR_FAILURE;
-  
-  NPP npp;
-  mInst->GetNPP(&npp);
-
-  PRLibrary* lib = nsnull;
-  lib = mInst->fLibrary;
-
-  NS_TRY_SAFE_CALL_VOID(CallNPP_StreamAsFileProc(callbacks->asfile,
-                                                   npp,
-                                                   &mNPStream,
-                                                   fileName), lib, mInst);
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("NPP StreamAsFile called: this=%p, npp=%p, url=%s, file=%s\n",
-  this, npp, mNPStream.url, fileName));
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ns4xPluginStreamListener::OnStopBinding(nsIPluginStreamInfo* pluginInfo, 
-                                        nsresult status)
-{
-  StopDataPump();
-
-  if (NS_FAILED(status)) {
-    // The stream was destroyed, or died for some reason. Make sure we
-    // cancel the underlying request.
-    nsCOMPtr<nsI4xPluginStreamInfo> pluginInfo4x =
-      do_QueryInterface(mStreamInfo);
-
-    nsIRequest *request;
-    if (pluginInfo4x && (request = pluginInfo4x->GetRequest())) {
-      request->Cancel(status);
-    }
-  }
-
-  if (!mInst || !mInst->IsStarted())
-    return NS_ERROR_FAILURE;
-
-  // check if the stream is of seekable type and later its destruction
-  // see bug 91140    
-  nsresult rv = NS_OK;
-  if (mStreamType != nsPluginStreamType_Seek) {
-    NPReason reason = NPRES_DONE;
-
-    if (NS_FAILED(status))
-      reason = NPRES_NETWORK_ERR;   // since the stream failed, we need to tell the plugin that
-
-    rv = CleanUpStream(reason);
-  }
-
-  if (rv != NPERR_NO_ERROR)
-    return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ns4xPluginStreamListener::GetStreamType(nsPluginStreamType *result)
-{
-  *result = mStreamType;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ns4xPluginStreamListener::Notify(nsITimer *aTimer)
-{
-  NS_ASSERTION(aTimer == mDataPumpTimer, "Uh, wrong timer?");
-
-  PRInt32 oldStreamBufferByteCount = mStreamBufferByteCount;
-
-  nsresult rv = OnDataAvailable(mStreamInfo, nsnull, mStreamBufferByteCount);
-
-  if (NS_FAILED(rv)) {
-    // We ran into an error, no need to keep firing this timer then.
-
-    aTimer->Cancel();
-
-    return NS_OK;
-  }
-
-  if (mStreamBufferByteCount != oldStreamBufferByteCount &&
-      ((mStreamStarted && mStreamBufferByteCount < 1024) ||
-       mStreamBufferByteCount == 0)) {
-    // The plugin read some data and we've got less than 1024 bytes in
-    // our buffer (or its empty and the stream is already
-    // done). Resume the request so that we get more data off the
-    // network.
-
-    ResumeRequest();
-
-    // Necko will pump data now that we've resumed the request.
-    StopDataPump();
-  }
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ns4xPluginStreamListener::StatusLine(const char* line)
-{
-  mResponseHeaders.Append(line);
-  mResponseHeaders.Append('\n');
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ns4xPluginStreamListener::NewResponseHeader(const char* headerName,
-                                            const char* headerValue)
-{
-  mResponseHeaders.Append(headerName);
-  mResponseHeaders.Append(": ");
-  mResponseHeaders.Append(headerValue);
-  mResponseHeaders.Append('\n');
-  return NS_OK;
-}
-
-nsInstanceStream::nsInstanceStream()
-{
-  mNext = nsnull;
-  mPluginStreamListener = nsnull;
-}
-
-nsInstanceStream::~nsInstanceStream()
-{
-}
-
-NS_IMPL_ISUPPORTS3(ns4xPluginInstance, nsIPluginInstance, nsIScriptablePlugin,
-                   nsIPluginInstanceInternal)
-
-ns4xPluginInstance::ns4xPluginInstance(NPPluginFuncs* callbacks,
-                                       PRLibrary* aLibrary)
-  : fCallbacks(callbacks),
-#ifdef XP_MACOSX
-#ifdef NP_NO_QUICKDRAW
-    mDrawingModel(NPDrawingModelCoreGraphics),
-#else
-    mDrawingModel(NPDrawingModelQuickDraw),
-#endif
-#endif
-    mWindowless(PR_FALSE),
-    mTransparent(PR_FALSE),
-    mStarted(PR_FALSE),
-    mCached(PR_FALSE),
-    mIsJavaPlugin(PR_FALSE),
-    mWantsAllNetworkStreams(PR_FALSE),
-    mInPluginInitCall(PR_FALSE),
-    fLibrary(aLibrary),
-    mStreams(nsnull)
-{
-  NS_ASSERTION(fCallbacks != NULL, "null callbacks");
-
-  // Initialize the NPP structure.
-
-  fNPP.pdata = NULL;
-  fNPP.ndata = this;
-
-  PLUGIN_LOG(PLUGIN_LOG_BASIC, ("ns4xPluginInstance ctor: this=%p\n",this));
-}
-
-ns4xPluginInstance::~ns4xPluginInstance(void)
-{
-  PLUGIN_LOG(PLUGIN_LOG_BASIC, ("ns4xPluginInstance dtor: this=%p\n",this));
-
-  // clean the stream list if any
-  for (nsInstanceStream *is = mStreams; is != nsnull;) {
-    nsInstanceStream * next = is->mNext;
-    delete is;
-    is = next;
-  }
-}
-
-PRBool
-ns4xPluginInstance::IsStarted(void)
-{
-  return mStarted;
-}
-
-NS_IMETHODIMP ns4xPluginInstance::Initialize(nsIPluginInstancePeer* peer)
-{
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Initialize this=%p\n",this));
-
-  return InitializePlugin(peer);
-}
-
-NS_IMETHODIMP ns4xPluginInstance::GetPeer(nsIPluginInstancePeer* *resultingPeer)
-{
-  *resultingPeer = mPeer;
-  NS_IF_ADDREF(*resultingPeer);
-  
-  return NS_OK;
-}
-
-NS_IMETHODIMP ns4xPluginInstance::Start(void)
-{
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Start this=%p\n",this));
-
-  if (mStarted)
-    return NS_OK;
-
-  return InitializePlugin(mPeer); 
-}
-
-NS_IMETHODIMP ns4xPluginInstance::Stop(void)
-{
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Stop this=%p\n",this));
-
-  NPError error;
-
-  // Make sure the plugin didn't leave popups enabled.
-  if (mPopupStates.Count() > 0) {
-    nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
-
-    if (window) {
-      window->PopPopupControlState(openAbused);
-    }
-  }
-
-  if (!mStarted)
-    return NS_OK;
-
-  // If there's code from this plugin instance on the stack, delay the
-  // destroy.
-  if (PluginDestructionGuard::DelayDestroy(this)) {
-    return NS_OK;
-  }
-
-  // Make sure we lock while we're writing to mStarted after we've
-  // started as other threads might be checking that inside a lock.
-  EnterAsyncPluginThreadCallLock();
-  mStarted = PR_FALSE;
-  ExitAsyncPluginThreadCallLock();
-
-  OnPluginDestroy(&fNPP);
-
-  if (fCallbacks->destroy == NULL)
-    return NS_ERROR_FAILURE; // XXX right error?
-
-  NPSavedData *sdata = 0;
-
-  // clean up open streams
-  for (nsInstanceStream *is = mStreams; is != nsnull;) {
-    ns4xPluginStreamListener * listener = is->mPluginStreamListener;
-
-    nsInstanceStream *next = is->mNext;
-    delete is;
-    is = next;
-    mStreams = is;
-
-    // Clean up our stream after removing it from the list because 
-    // it may be released and destroyed at this point.
-    if (listener)
-      listener->CleanUpStream(NPRES_USER_BREAK);
-  }
-
-  NS_TRY_SAFE_CALL_RETURN(error, CallNPP_DestroyProc(fCallbacks->destroy, &fNPP, &sdata), fLibrary, this);
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("NPP Destroy called: this=%p, npp=%p, return=%d\n", this, &fNPP, error));
-
-  nsJSNPRuntime::OnPluginDestroy(&fNPP);
-
-  if (error != NPERR_NO_ERROR)
-    return NS_ERROR_FAILURE;
-  else
-    return NS_OK;
-}
-
-already_AddRefed<nsPIDOMWindow>
-ns4xPluginInstance::GetDOMWindow()
-{
-  nsCOMPtr<nsPIPluginInstancePeer> pp (do_QueryInterface(mPeer));
-  if (!pp) {
-    return nsnull;
-  }
-
-  nsCOMPtr<nsIPluginInstanceOwner> owner;
-  pp->GetOwner(getter_AddRefs(owner));
-
-  if (!owner) {
-    return nsnull;
-  }
-
-  nsCOMPtr<nsIDocument> doc;
-  owner->GetDocument(getter_AddRefs(doc));
-
-  if (!doc) {
-    return nsnull;
-  }
-
-  nsPIDOMWindow *window = doc->GetWindow();
-  NS_IF_ADDREF(window);
-
-  return window;
-}
-
-nsresult ns4xPluginInstance::InitializePlugin(nsIPluginInstancePeer* peer)
-{
-  NS_ENSURE_ARG_POINTER(peer);
- 
-  nsCOMPtr<nsIPluginTagInfo2> taginfo = do_QueryInterface(peer);
-  NS_ENSURE_TRUE(taginfo, NS_ERROR_NO_INTERFACE);
-  
-  PluginDestructionGuard guard(this);
-
-  PRUint16 count = 0;
-  const char* const* names = nsnull;
-  const char* const* values = nsnull;
-  nsPluginTagType tagtype;
-  nsresult rv = taginfo->GetTagType(&tagtype);
-  if (NS_SUCCEEDED(rv)) {
-    // Note: If we failed to get the tag type, we may be a full page plugin, so no arguments
-    rv = taginfo->GetAttributes(count, names, values);
-    NS_ENSURE_SUCCESS(rv, rv);
-    
-    // nsPluginTagType_Object or Applet may also have PARAM tags
-    // Note: The arrays handed back by GetParameters() are
-    // crafted specially to be directly behind the arrays from GetAttributes()
-    // with a null entry as a separator. This is for 4.x backwards compatibility!
-    // see bug 111008 for details
-    if (tagtype != nsPluginTagType_Embed) {
-      PRUint16 pcount = 0;
-      const char* const* pnames = nsnull;
-      const char* const* pvalues = nsnull;    
-      if (NS_SUCCEEDED(taginfo->GetParameters(pcount, pnames, pvalues))) {
-        NS_ASSERTION(nsnull == values[count], "attribute/parameter array not setup correctly for 4.x plugins");
-        if (pcount)
-          count += ++pcount; //if it's all setup correctly, then all we need is to change the count (attrs + PARAM/blank + params)
-      }
-    }
-  }
-
-  NS_ENSURE_TRUE(fCallbacks->newp, NS_ERROR_FAILURE);
-  
-  // XXX Note that the NPPluginType_* enums were crafted to be
-  // backward compatible...
-  
-  nsPluginMode  mode;
-  nsMIMEType    mimetype;
-  NPError       error;
-
-  peer->GetMode(&mode);
-  peer->GetMIMEType(&mimetype);
-
-  // Some older versions of Flash have a bug in them
-  // that causes the stack to become currupt if we
-  // pass swliveconect=1 in the NPP_NewProc arrays.
-  // See bug 149336 (UNIX), bug 186287 (Mac)
-  //
-  // The code below disables the attribute unless
-  // the environment variable:
-  // MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK
-  // is set.
-  //
-  // It is okay to disable this attribute because
-  // back in 4.x, scripting required liveconnect to
-  // start Java which was slow. Scripting no longer
-  // requires starting Java and is quick plus controled
-  // from the browser, so Flash now ignores this attribute.
-  //
-  // This code can not be put at the time of creating
-  // the array because we may need to examine the
-  // stream header to determine we want Flash.
-
-  static const char flashMimeType[] = "application/x-shockwave-flash";
-  static const char blockedParam[] = "swliveconnect";
-  if (count && !PL_strcasecmp(mimetype, flashMimeType)) {
-    static int cachedDisableHack = 0;
-    if (!cachedDisableHack) {
-       if (PR_GetEnv("MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK"))
-         cachedDisableHack = -1;
-       else
-         cachedDisableHack = 1;
-    }
-    if (cachedDisableHack > 0) {
-      for (PRUint16 i=0; i<count; i++) {
-        if (!PL_strcasecmp(names[i], blockedParam)) {
-          // BIG FAT WARNIG:
-          // I'm ugly casting |const char*| to |char*| and altering it
-          // because I know we do malloc it values in
-          // http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/layout/html/base/src/nsObjectFrame.cpp&rev=1.349&root=/cvsroot#3020
-          // and free it at line #2096, so it couldn't be a const ptr to string literal
-          char *val = (char*) values[i];
-          if (val && *val) {
-            // we cannot just *val=0, it won't be free properly in such case
-            val[0] = '0';
-            val[1] = 0;
-          }
-          break;
-        }
-      }
-    }
-  }
-
-  mIsJavaPlugin = nsPluginHostImpl::IsJavaMIMEType(mimetype);
-
-  // Assign mPeer now and mark this instance as started before calling NPP_New 
-  // because the plugin may call other NPAPI functions, like NPN_GetURLNotify,
-  // that assume these are set before returning. If the plugin returns failure,
-  // we'll clear them out below.
-  mPeer = peer;
-  mStarted = PR_TRUE;
-
-  PRBool oldVal = mInPluginInitCall;
-  mInPluginInitCall = PR_TRUE;
-
-  NS_TRY_SAFE_CALL_RETURN(error, CallNPP_NewProc(fCallbacks->newp,
-                                          (char *)mimetype,
-                                          &fNPP,
-                                          (PRUint16)mode,
-                                          count,
-                                          (char**)names,
-                                          (char**)values,
-                                          NULL), fLibrary,this);
-
-  mInPluginInitCall = oldVal;
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("NPP New called: this=%p, npp=%p, mime=%s, mode=%d, argc=%d, return=%d\n",
-  this, &fNPP, mimetype, mode, count, error));
-
-  if (error != NPERR_NO_ERROR) {
-    // since the plugin returned failure, these should not be set
-    mPeer = nsnull;
-    mStarted = PR_FALSE;
-
-    return NS_ERROR_FAILURE;
-  }
-  
-  return NS_OK;
-}
-
-NS_IMETHODIMP ns4xPluginInstance::Destroy(void)
-{
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Destroy this=%p\n",this));
-
-  // destruction is handled in the Stop call
-  return NS_OK;
-}
-
-NS_IMETHODIMP ns4xPluginInstance::SetWindow(nsPluginWindow* window)
-{
-  // XXX 4.x plugins don't want a SetWindow(NULL).
-  if (!window || !mStarted)
-    return NS_OK;
-
-  NPError error;
-
-#if defined (MOZ_WIDGET_GTK2)
-  // bug 108347, flash plugin on linux doesn't like window->width <=
-  // 0, but Java needs wants this call.
-  if (!mIsJavaPlugin && window->type == nsPluginWindowType_Window &&
-      (window->width <= 0 || window->height <= 0)) {
-    return NS_OK;
-  }
-#endif // MOZ_WIDGET
-
-  if (fCallbacks->setwindow) {
-    PluginDestructionGuard guard(this);
-
-    // XXX Turns out that NPPluginWindow and NPWindow are structurally
-    // identical (on purpose!), so there's no need to make a copy.
-
-    PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::SetWindow (about to call it) this=%p\n",this));
-
-    PRBool oldVal = mInPluginInitCall;
-    mInPluginInitCall = PR_TRUE;
-
-    NS_TRY_SAFE_CALL_RETURN(error, CallNPP_SetWindowProc(fCallbacks->setwindow,
-                                  &fNPP,
-                                  (NPWindow*) window), fLibrary, this);
-
-    mInPluginInitCall = oldVal;
-
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-    ("NPP SetWindow called: this=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d], return=%d\n",
-    this, window->x, window->y, window->width, window->height,
-    window->clipRect.top, window->clipRect.bottom, window->clipRect.left, window->clipRect.right, error));
-      
-    // XXX In the old code, we'd just ignore any errors coming
-    // back from the plugin's SetWindow(). Is this the correct
-    // behavior?!?
-
-  }
-  return NS_OK;
-}
-
-/* NOTE: the caller must free the stream listener */
-// Create a normal stream, one without a urlnotify callback
-NS_IMETHODIMP ns4xPluginInstance::NewStream(nsIPluginStreamListener** listener)
-{
-  return NewNotifyStream(listener, nsnull, PR_FALSE, nsnull);
-}
-
-// Create a stream that will notify when complete
-nsresult ns4xPluginInstance::NewNotifyStream(nsIPluginStreamListener** listener, 
-                                             void* notifyData,
-                                             PRBool aCallNotify,
-                                             const char* aURL)
-{
-  ns4xPluginStreamListener* stream = new ns4xPluginStreamListener(this, notifyData, aURL);
-  NS_ENSURE_TRUE(stream, NS_ERROR_OUT_OF_MEMORY);
-
-  // add it to the list
-  nsInstanceStream * is = new nsInstanceStream();
-  NS_ENSURE_TRUE(is, NS_ERROR_OUT_OF_MEMORY);
-
-  is->mNext = mStreams;
-  is->mPluginStreamListener = stream;
-  mStreams = is;
-  stream->SetCallNotify(aCallNotify);  // set flag in stream to call URLNotify
-
-  NS_ADDREF(stream);  // Stabilize
-    
-  nsresult res = stream->QueryInterface(kIPluginStreamListenerIID, (void**)listener);
-
-  // Destabilize and avoid leaks. Avoid calling delete <interface pointer>
-  NS_RELEASE(stream);
-
-  return res;
-}
-
-NS_IMETHODIMP ns4xPluginInstance::Print(nsPluginPrint* platformPrint)
-{
-  NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
-
-  PluginDestructionGuard guard(this);
-
-  NPPrint* thePrint = (NPPrint *)platformPrint;
-
-  // to be compatible with the older SDK versions and to match what
-  // 4.x and other browsers do, overwrite |window.type| field with one
-  // more copy of |platformPrint|. See bug 113264
-  if (fCallbacks) {
-    PRUint16 sdkmajorversion = (fCallbacks->version & 0xff00)>>8;
-    PRUint16 sdkminorversion = fCallbacks->version & 0x00ff;
-    if ((sdkmajorversion == 0) && (sdkminorversion < 11)) { 
-      // Let's copy platformPrint bytes over to where it was supposed to be 
-      // in older versions -- four bytes towards the beginning of the struct
-      // but we should be careful about possible misalignments
-      if (sizeof(NPWindowType) >= sizeof(void *)) {
-        void* source = thePrint->print.embedPrint.platformPrint; 
-        void** destination = (void **)&(thePrint->print.embedPrint.window.type); 
-        *destination = source;
-      } 
-      else 
-        NS_ASSERTION(PR_FALSE, "Incompatible OS for assignment");
-    }
-  }
-
-  if (fCallbacks->print) {
-      NS_TRY_SAFE_CALL_VOID(CallNPP_PrintProc(fCallbacks->print,
-                                              &fNPP,
-                                              thePrint), fLibrary, this);
-  }
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-  ("NPP PrintProc called: this=%p, pDC=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d]\n",
-  this,
-  platformPrint->print.embedPrint.platformPrint,
-  platformPrint->print.embedPrint.window.x,
-  platformPrint->print.embedPrint.window.y,
-  platformPrint->print.embedPrint.window.width,
-  platformPrint->print.embedPrint.window.height,
-  platformPrint->print.embedPrint.window.clipRect.top,
-  platformPrint->print.embedPrint.window.clipRect.bottom,
-  platformPrint->print.embedPrint.window.clipRect.left,
-  platformPrint->print.embedPrint.window.clipRect.right));
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP ns4xPluginInstance::HandleEvent(nsPluginEvent* event, PRBool* handled)
-{
-  if (!mStarted)
-    return NS_OK;
-
-  if (!event)
-    return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(this);
-
-  PRInt16 result = 0;
-  
-  if (fCallbacks->event) {
-#ifdef XP_MACOSX
-    result = CallNPP_HandleEventProc(fCallbacks->event,
-                                     &fNPP,
-                                     (void*) event->event);
-
-#elif defined(XP_WIN) || defined(XP_OS2)
-      NPEvent npEvent;
-      npEvent.event = event->event;
-      npEvent.wParam = event->wParam;
-      npEvent.lParam = event->lParam;
-
-      NS_TRY_SAFE_CALL_RETURN(result, CallNPP_HandleEventProc(fCallbacks->event,
-                                    &fNPP,
-                                    (void*)&npEvent), fLibrary, this);
-
-#else // MOZ_X11 or other
-      result = CallNPP_HandleEventProc(fCallbacks->event,
-                                       &fNPP,
-                                       (void*)&event->event);
-#endif
-
-      NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-      ("NPP HandleEvent called: this=%p, npp=%p, event=%d, return=%d\n", 
-      this, &fNPP, event->event, result));
-
-      *handled = result;
-    }
-
-  return NS_OK;
-}
-
-nsresult ns4xPluginInstance::GetValueInternal(NPPVariable variable, void* value)
-{
-  nsresult  res = NS_OK;
-  if (fCallbacks->getvalue && mStarted) {
-    PluginDestructionGuard guard(this);
-
-    NS_TRY_SAFE_CALL_RETURN(res, 
-                            CallNPP_GetValueProc(fCallbacks->getvalue, 
-                                                 &fNPP, 
-                                                 variable, 
-                                                 value), 
-                                                 fLibrary, this);
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-    ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%d, return=%d\n", 
-    this, &fNPP, variable, value, res));
-
-#ifdef XP_OS2
-    /* Query interface for legacy Flash plugin */
-    if (res == NS_OK && variable == NPPVpluginScriptableInstance)
-    {
-      nsCOMPtr<nsILegacyPluginWrapperOS2> wrapper =
-               do_GetService(NS_LEGACY_PLUGIN_WRAPPER_CONTRACTID, &res);
-      if (res == NS_OK)
-      {
-        nsIID *iid = nsnull; 
-        res = CallNPP_GetValueProc(fCallbacks->getvalue, &fNPP, 
-                                   NPPVpluginScriptableIID, (void *)&iid);
-        if (res == NS_OK)
-          res = wrapper->MaybeWrap(*iid, *(nsISupports**)value,
-                                   (nsISupports**)value);
-      }
-    }
-#endif
-  }
-
-  return res;
-}
-
-NS_IMETHODIMP ns4xPluginInstance::GetValue(nsPluginInstanceVariable variable, void *value)
-{
-  nsresult  res = NS_OK;
-
-  switch (variable) {
-    case nsPluginInstanceVariable_WindowlessBool:
-      *(PRBool *)value = mWindowless;
-      break;
-
-    case nsPluginInstanceVariable_TransparentBool:
-      *(PRBool *)value = mTransparent;
-      break;
-
-    case nsPluginInstanceVariable_DoCacheBool:
-      *(PRBool *)value = mCached;
-      break;
-
-    case nsPluginInstanceVariable_CallSetWindowAfterDestroyBool:
-      *(PRBool *)value = 0;  // not supported for 4.x plugins
-      break;
-
-#ifdef XP_MACOSX
-    case nsPluginInstanceVariable_DrawingModel:
-      *(NPDrawingModel*)value = mDrawingModel;
-      break;
-#endif
-
-    default:
-      res = GetValueInternal((NPPVariable)variable, value);
-  }
-
-  return res;
-}
-
-nsresult ns4xPluginInstance::GetNPP(NPP* aNPP) 
-{
-  if (aNPP != nsnull)
-    *aNPP = &fNPP;
-  else
-    return NS_ERROR_NULL_POINTER;
-
-  return NS_OK;
-}
-
-nsresult ns4xPluginInstance::GetCallbacks(const NPPluginFuncs ** aCallbacks)
-{
-  if (aCallbacks != nsnull)
-    *aCallbacks = fCallbacks;
-  else
-    return NS_ERROR_NULL_POINTER;
-
-  return NS_OK;
-}
-
-NPError ns4xPluginInstance::SetWindowless(PRBool aWindowless)
-{
-  mWindowless = aWindowless;
-  return NPERR_NO_ERROR;
-}
-
-NPError ns4xPluginInstance::SetTransparent(PRBool aTransparent)
-{
-  mTransparent = aTransparent;
-  return NPERR_NO_ERROR;
-}
-
-NPError ns4xPluginInstance::SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams)
-{
-  mWantsAllNetworkStreams = aWantsAllNetworkStreams;
-  return NPERR_NO_ERROR;
-}
-
-#ifdef XP_MACOSX
-void ns4xPluginInstance::SetDrawingModel(NPDrawingModel aModel)
-{
-  mDrawingModel = aModel;
-}
-
-NPDrawingModel ns4xPluginInstance::GetDrawingModel()
-{
-  return mDrawingModel;
-}
-#endif
-
-/* readonly attribute nsQIResult scriptablePeer; */
-NS_IMETHODIMP ns4xPluginInstance::GetScriptablePeer(void * *aScriptablePeer)
-{
-  if (!aScriptablePeer)
-    return NS_ERROR_NULL_POINTER;
-
-  *aScriptablePeer = nsnull;
-  return GetValueInternal(NPPVpluginScriptableInstance, aScriptablePeer);
-}
-
-/* readonly attribute nsIIDPtr scriptableInterface; */
-NS_IMETHODIMP ns4xPluginInstance::GetScriptableInterface(nsIID * *aScriptableInterface)
-{
-  if (!aScriptableInterface)
-    return NS_ERROR_NULL_POINTER;
-
-  *aScriptableInterface = nsnull;
-  return GetValueInternal(NPPVpluginScriptableIID, (void*)aScriptableInterface);
-}
-
-JSObject *
-ns4xPluginInstance::GetJSObject(JSContext *cx)
-{
-  JSObject *obj = nsnull;
-  NPObject *npobj = nsnull;
-
-  nsresult rv = GetValueInternal(NPPVpluginScriptableNPObject, &npobj);
-
-  if (NS_SUCCEEDED(rv) && npobj) {
-    obj = nsNPObjWrapper::GetNewOrUsed(&fNPP, cx, npobj);
-
-    _releaseobject(npobj);
-  }
-
-  return obj;
-}
-
-void
-ns4xPluginInstance::DefineJavaProperties()
-{
-  NPObject *plugin_obj = nsnull;
-
-  // The dummy Java plugin's scriptable object is what we want to
-  // expose as window.Packages. And Window.Packages.java will be
-  // exposed as window.java.
-
-  // Get the scriptable plugin object.
-  nsresult rv = GetValueInternal(NPPVpluginScriptableNPObject, &plugin_obj);
-
-  if (NS_FAILED(rv) || !plugin_obj) {
-    return;
-  }
-
-  // Get the NPObject wrapper for window.
-  NPObject *window_obj = _getwindowobject(&fNPP);
-
-  if (!window_obj) {
-    _releaseobject(plugin_obj);
-
-    return;
-  }
-
-  NPIdentifier java_id = _getstringidentifier("java");
-  NPIdentifier packages_id = _getstringidentifier("Packages");
-
-  NPObject *java_obj = nsnull;
-  NPVariant v;
-  OBJECT_TO_NPVARIANT(plugin_obj, v);
-
-  // Define the properties.
-
-  bool ok = _setproperty(&fNPP, window_obj, packages_id, &v);
-  if (ok) {
-    ok = _getproperty(&fNPP, plugin_obj, java_id, &v);
-
-    if (ok && NPVARIANT_IS_OBJECT(v)) {
-      // Set java_obj so that we properly release it at the end of
-      // this function.
-      java_obj = NPVARIANT_TO_OBJECT(v);
-
-      ok = _setproperty(&fNPP, window_obj, java_id, &v);
-    }
-  }
-
-  _releaseobject(window_obj);
-  _releaseobject(plugin_obj);
-  _releaseobject(java_obj);
-}
-
-nsresult
-ns4xPluginInstance::GetFormValue(nsAString& aValue)
-{
-  aValue.Truncate();
-
-  char *value = nsnull;
-  nsresult rv = GetValueInternal(NPPVformValue, &value);
-
-  if (NS_SUCCEEDED(rv) && value) {
-    CopyUTF8toUTF16(value, aValue);
-
-    // NPPVformValue allocates with NPN_MemAlloc(), which uses
-    // nsMemory.
-    nsMemory::Free(value);
-  }
-
-  return NS_OK;
-}
-
-void
-ns4xPluginInstance::PushPopupsEnabledState(PRBool aEnabled)
-{
-  nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
-  if (!window)
-    return;
-
-  PopupControlState oldState =
-    window->PushPopupControlState(aEnabled ? openAllowed : openAbused,
-                                  PR_TRUE);
-
-  if (!mPopupStates.AppendElement(NS_INT32_TO_PTR(oldState))) {
-    // Appending to our state stack failed, push what we just popped.
-
-    window->PopPopupControlState(oldState);
-  }
-}
-
-void
-ns4xPluginInstance::PopPopupsEnabledState()
-{
-  PRInt32 last = mPopupStates.Count() - 1;
-
-  if (last < 0) {
-    // Nothing to pop.
-    return;
-  }
-
-  nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
-  if (!window)
-    return;
-
-  PopupControlState oldState =
-    (PopupControlState)NS_PTR_TO_INT32(mPopupStates[last]);
-
-  window->PopPopupControlState(oldState);
-
-  mPopupStates.RemoveElementAt(last);
-}
-
-PRUint16
-ns4xPluginInstance::GetPluginAPIVersion()
-{
-  return fCallbacks->version;
-}
diff -r 8dcf83cc8500 modules/plugin/base/src/ns4xPluginInstance.h
--- a/modules/plugin/base/src/ns4xPluginInstance.h	Sun Sep 14 00:37:23 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,176 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Tim Copperfield <timecop@network.email.ne.jp>
- *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef ns4xPluginInstance_h_
-#define ns4xPluginInstance_h_
-
-#include "nsCOMPtr.h"
-#include "nsVoidArray.h"
-#include "nsIPlugin.h"
-#include "nsIPluginInstance.h"
-#include "nsIPluginInstancePeer.h"
-#include "nsIPluginTagInfo2.h"
-#include "nsIScriptablePlugin.h"
-#include "nsIPluginInstanceInternal.h"
-
-#include "npupp.h"
-#include "prlink.h"
-
-class ns4xPluginStreamListener;
-class nsPIDOMWindow;
-
-struct nsInstanceStream
-{
-    nsInstanceStream *mNext;
-    ns4xPluginStreamListener *mPluginStreamListener;
-
-    nsInstanceStream();
-    ~nsInstanceStream();
-};
-
-class ns4xPluginInstance : public nsIPluginInstance,
-                           public nsIScriptablePlugin,
-                           public nsIPluginInstanceInternal
-{
-public:
-
-    NS_DECL_ISUPPORTS
-    NS_DECL_NSIPLUGININSTANCE
-    NS_DECL_NSISCRIPTABLEPLUGIN
-
-    // nsIPluginInstanceInternal methods
-
-    virtual JSObject *GetJSObject(JSContext *cx);
-
-    virtual nsresult GetFormValue(nsAString& aValue);
-
-    virtual void PushPopupsEnabledState(PRBool aEnabled);
-    virtual void PopPopupsEnabledState();
-
-    virtual PRUint16 GetPluginAPIVersion();
-
-    virtual void DefineJavaProperties();
-
-    // ns4xPluginInstance-specific methods
-
-    // Return the 4.x-style interface object.
-    nsresult GetNPP(NPP * aNPP);
-
-    // Return the callbacks for the plugin instance.
-    nsresult GetCallbacks(const NPPluginFuncs ** aCallbacks);
-
-    NPError SetWindowless(PRBool aWindowless);
-
-    NPError SetTransparent(PRBool aTransparent);
-
-    NPError SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams);
-
-#ifdef XP_MACOSX
-    void SetDrawingModel(NPDrawingModel aModel);
-    NPDrawingModel GetDrawingModel();
-#endif
-
-    nsresult NewNotifyStream(nsIPluginStreamListener** listener, 
-                             void* notifyData, 
-                             PRBool aCallNotify,
-                             const char * aURL);
-
-    // Construct a new 4.x plugin instance with the specified peer
-    // and callbacks.
-    ns4xPluginInstance(NPPluginFuncs* callbacks, PRLibrary* aLibrary);
-
-    // Use Release() to destroy this
-    virtual ~ns4xPluginInstance(void);
-
-    // returns the state of mStarted
-    PRBool IsStarted(void);
-
-    // cache this 4.x plugin like an XPCOM plugin
-    nsresult SetCached(PRBool aCache) { mCached = aCache; return NS_OK; }
-
-    // Non-refcounting accessor for faster access to the peer.
-    nsIPluginInstancePeer *Peer()
-    {
-        return mPeer;
-    }
-
-    already_AddRefed<nsPIDOMWindow> GetDOMWindow();
-
-protected:
-
-    nsresult InitializePlugin(nsIPluginInstancePeer* peer);
-
-    // Calls NPP_GetValue
-    nsresult GetValueInternal(NPPVariable variable, void* value);
-
-    // The plugin instance peer for this instance.
-    nsCOMPtr<nsIPluginInstancePeer> mPeer;
-
-    // A pointer to the plugin's callback functions. This information
-    // is actually stored in the plugin class (<b>nsPluginClass</b>),
-    // and is common for all plugins of the class.
-    NPPluginFuncs* fCallbacks;
-
-    // The 4.x-style structure used to communicate between the plugin
-    // instance and the browser.
-    NPP_t fNPP;
-
-#ifdef XP_MACOSX
-    NPDrawingModel mDrawingModel;
-#endif
-
-    // these are used to store the windowless properties
-    // which the browser will later query
-    PRPackedBool  mWindowless;
-    PRPackedBool  mTransparent;
-    PRPackedBool  mStarted;
-    PRPackedBool  mCached;
-    PRPackedBool  mIsJavaPlugin;
-    PRPackedBool  mWantsAllNetworkStreams;
-
-public:
-    // True while creating the plugin, or calling NPP_SetWindow() on it.
-    PRPackedBool  mInPluginInitCall;
-    PRLibrary* fLibrary;
-    nsInstanceStream *mStreams;
-
-    nsVoidArray mPopupStates;
-};
-
-#endif // ns4xPluginInstance_h_
diff -r 8dcf83cc8500 modules/plugin/base/src/ns4xPluginStreamListener.h
--- a/modules/plugin/base/src/ns4xPluginStreamListener.h	Sun Sep 14 00:37:23 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,127 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef ns4xPluginStreamListener_h_
-#define ns4xPluginStreamListener_h_
-
-#include "nsIPluginStreamListener.h"
-#include "nsIPluginStreamInfo.h"
-#include "nsIHTTPHeaderListener.h"
-#include "nsIRequest.h"
-#include "nsITimer.h"
-#include "nsCOMPtr.h"
-
-#define MAX_PLUGIN_NECKO_BUFFER 16384
-
-class ns4xPluginInstance;
-class nsI4xPluginStreamInfo;
-
-class ns4xPluginStreamListener : public nsIPluginStreamListener,
-                                 public nsITimerCallback,
-                                 public nsIHTTPHeaderListener
-{
-public:
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIPLUGINSTREAMLISTENER
-  NS_DECL_NSITIMERCALLBACK
-  NS_DECL_NSIHTTPHEADERLISTENER
-
-  // ns4xPluginStreamListener specific methods:
-  ns4xPluginStreamListener(ns4xPluginInstance* inst, void* notifyData,
-                           const char* aURL);
-  virtual ~ns4xPluginStreamListener();
-  PRBool IsStarted();
-  nsresult CleanUpStream(NPReason reason);
-  void CallURLNotify(NPReason reason);
-  void SetCallNotify(PRBool aCallNotify)
-  {
-    mCallNotify = aCallNotify;
-  }
-  nsresult SuspendRequest();
-  void ResumeRequest();
-  nsresult StartDataPump();
-  void StopDataPump();
-
-  PRBool PluginInitJSLoadInProgress();
-
-protected:
-  void* mNotifyData;
-  char* mStreamBuffer;
-  char* mNotifyURL;
-  ns4xPluginInstance* mInst;
-  NPStream mNPStream;
-  PRUint32 mStreamBufferSize;
-  PRInt32 mStreamBufferByteCount;
-  nsPluginStreamType mStreamType;
-  PRPackedBool mStreamStarted;
-  PRPackedBool mStreamCleanedUp;
-  PRPackedBool mCallNotify;
-  PRPackedBool mIsSuspended;
-  PRPackedBool mIsPluginInitJSStream;
-  nsCString mResponseHeaders;
-  char* mResponseHeaderBuf;
-
-  nsCOMPtr<nsITimer> mDataPumpTimer;
-
-public:
-  nsCOMPtr<nsIPluginStreamInfo> mStreamInfo;
-};
-
-// nsI4xPluginStreamInfo is an internal helper interface that exposes
-// the underlying necko request to consumers of nsIPluginStreamInfo's.
-#define NS_I4XPLUGINSTREAMINFO_IID       \
-{ 0x097fdaaa, 0xa2a3, 0x49c2, \
-  {0x91, 0xee, 0xeb, 0xc5, 0x7d, 0x6c, 0x9c, 0x97} }
-
-class nsI4xPluginStreamInfo : public nsIPluginStreamInfo
-{
-public:
-  NS_DECLARE_STATIC_IID_ACCESSOR(NS_I4XPLUGINSTREAMINFO_IID)
-
-  nsIRequest *GetRequest()
-  {
-    return mRequest;
-  }
-
-protected:
-  nsCOMPtr<nsIRequest> mRequest;
-};
-
-NS_DEFINE_STATIC_IID_ACCESSOR(nsI4xPluginStreamInfo,
-                              NS_I4XPLUGINSTREAMINFO_IID)
-
-#endif // ns4xPluginStreamListener_h_
diff -r 8dcf83cc8500 modules/plugin/base/src/nsJSNPRuntime.cpp
--- a/modules/plugin/base/src/nsJSNPRuntime.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/plugin/base/src/nsJSNPRuntime.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -31,18 +31,18 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsJSNPRuntime.h"
-#include "ns4xPlugin.h"
-#include "ns4xPluginInstance.h"
+#include "nsNPAPIPlugin.h"
+#include "nsNPAPIPluginInstance.h"
 #include "nsIPluginInstancePeer2.h"
 #include "nsPIPluginInstancePeer.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptContext.h"
 #include "nsDOMJSUtils.h"
 #include "nsIDocument.h"
 #include "nsIJSRuntimeService.h"
 #include "nsIJSContextStack.h"
@@ -287,17 +287,17 @@ struct AutoCXPusher
   }
 };
 
 static JSContext *
 GetJSContext(NPP npp)
 {
   NS_ENSURE_TRUE(npp, nsnull);
 
-  ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
+  nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
   NS_ENSURE_TRUE(inst, nsnull);
 
   nsCOMPtr<nsPIPluginInstancePeer> pp(do_QueryInterface(inst->Peer()));
   NS_ENSURE_TRUE(pp, nsnull);
 
   nsCOMPtr<nsIPluginInstanceOwner> owner;
   pp->GetOwner(getter_AddRefs(owner));
   NS_ENSURE_TRUE(owner, nsnull);
@@ -1870,17 +1870,17 @@ nsJSNPRuntime::OnPluginDestroy(NPP npp)
   // chain. Now that the plugin is being destroyed we need to pull the
   // plugin's scriptable object out of that prototype chain.
   if (!npp) {
     return;
   }
 
   // Find the plugin instance so that we can (eventually) get to the
   // DOM element
-  ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
+  nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
   if (!inst) {
     return;
   }
 
   nsCOMPtr<nsIPluginInstancePeer> pip;
   inst->GetPeer(getter_AddRefs(pip));
   nsCOMPtr<nsIPluginTagInfo2> pti2(do_QueryInterface(pip));
   if (!pti2) {
diff -r 8dcf83cc8500 modules/plugin/base/src/nsNPAPIPlugin.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/base/src/nsNPAPIPlugin.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,2662 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Josh Aas <josh@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "prtypes.h"
+#include "prmem.h"
+#include "prclist.h"
+#include "nsAutoLock.h"
+#include "nsNPAPIPlugin.h"
+#include "nsNPAPIPluginInstance.h"
+#include "nsNPAPIPluginStreamListener.h"
+#include "nsIServiceManager.h"
+#include "nsThreadUtils.h"
+
+#include "nsIPluginStreamListener.h"
+#include "nsPluginsDir.h"
+#include "nsPluginSafety.h"
+#include "nsIPrefService.h"
+#include "nsIPrefBranch.h"
+#include "nsPluginLogging.h"
+
+#include "nsIPluginInstancePeer2.h"
+#include "nsIJSContextStack.h"
+
+#include "nsPIPluginInstancePeer.h"
+#include "nsIDOMElement.h"
+#include "nsIDOMDocument.h"
+#include "nsPIDOMWindow.h"
+#include "nsIDocument.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIScriptContext.h"
+#include "nsDOMJSUtils.h"
+#include "nsIPrincipal.h"
+
+#include "jscntxt.h"
+
+#include "nsIXPConnect.h"
+
+#include "nsIObserverService.h"
+#include <prinrval.h>
+
+#ifdef XP_MACOSX
+#include <Carbon/Carbon.h>
+#endif
+
+// needed for nppdf plugin
+#ifdef MOZ_WIDGET_GTK2
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include "gtk2xtbin.h"
+#endif
+
+#include "nsJSNPRuntime.h"
+
+static PRLock *sPluginThreadAsyncCallLock = nsnull;
+static PRCList sPendingAsyncCalls = PR_INIT_STATIC_CLIST(&sPendingAsyncCalls);
+
+// POST/GET stream type
+enum eNPPStreamTypeInternal {
+  eNPPStreamTypeInternal_Get,
+  eNPPStreamTypeInternal_Post
+};
+
+static NS_DEFINE_IID(kCPluginManagerCID, NS_PLUGINMANAGER_CID);
+static NS_DEFINE_IID(kPluginManagerCID, NS_PLUGINMANAGER_CID);
+static NS_DEFINE_IID(kMemoryCID, NS_MEMORY_CID);
+
+// Static stub functions that are exported to the 4.x plugin as entry
+// points via the CALLBACKS variable.
+PR_BEGIN_EXTERN_C
+
+  static NPError NP_CALLBACK
+  _requestread(NPStream *pstream, NPByteRange *rangeList);
+
+  static NPError NP_CALLBACK
+  _geturlnotify(NPP npp, const char* relativeURL, const char* target,
+                void* notifyData);
+
+  static NPError NP_CALLBACK
+  _getvalue(NPP npp, NPNVariable variable, void *r_value);
+
+  static NPError NP_CALLBACK
+  _setvalue(NPP npp, NPPVariable variable, void *r_value);
+
+  static NPError NP_CALLBACK
+  _geturl(NPP npp, const char* relativeURL, const char* target);
+
+  static NPError NP_CALLBACK
+  _posturlnotify(NPP npp, const char* relativeURL, const char *target,
+                 uint32_t len, const char *buf, NPBool file, void* notifyData);
+
+  static NPError NP_CALLBACK
+  _posturl(NPP npp, const char* relativeURL, const char *target, uint32_t len,
+              const char *buf, NPBool file);
+
+  static NPError NP_CALLBACK
+  _newstream(NPP npp, NPMIMEType type, const char* window, NPStream** pstream);
+
+  static int32_t NP_CALLBACK
+  _write(NPP npp, NPStream *pstream, int32_t len, void *buffer);
+
+  static NPError NP_CALLBACK
+  _destroystream(NPP npp, NPStream *pstream, NPError reason);
+
+  static void NP_CALLBACK
+  _status(NPP npp, const char *message);
+
+  static void NP_CALLBACK
+  _memfree (void *ptr);
+
+  static uint32_t NP_CALLBACK
+  _memflush(uint32_t size);
+
+  static void NP_CALLBACK
+  _reloadplugins(NPBool reloadPages);
+
+  static void NP_CALLBACK
+  _invalidaterect(NPP npp, NPRect *invalidRect);
+
+  static void NP_CALLBACK
+  _invalidateregion(NPP npp, NPRegion invalidRegion);
+
+  static void NP_CALLBACK
+  _forceredraw(NPP npp);
+
+  static void NP_CALLBACK
+  _pushpopupsenabledstate(NPP npp, NPBool enabled);
+
+  static void NP_CALLBACK
+  _poppopupsenabledstate(NPP npp);
+
+  typedef void(*PluginThreadCallback)(void *);
+  static void NP_CALLBACK
+  _pluginthreadasynccall(NPP instance, PluginThreadCallback func,
+                         void *userData);
+
+  static const char* NP_CALLBACK
+  _useragent(NPP npp);
+
+  static void* NP_CALLBACK
+  _memalloc (uint32_t size);
+
+  // Deprecated entry points for the old Java plugin.
+  static void* NP_CALLBACK /* OJI type: JRIEnv* */
+  _getJavaEnv(void);
+  static void* NP_CALLBACK /* OJI type: jref */
+  _getJavaPeer(NPP npp);
+
+PR_END_EXTERN_C
+
+#if defined(XP_MACOSX) && defined(__POWERPC__)
+
+#define TV2FP(tvp) _TV2FP((void *)tvp)
+
+static void*
+_TV2FP(void *tvp)
+{
+    static uint32_t glue[6] = {
+      0x3D800000, 0x618C0000, 0x800C0000, 0x804C0004, 0x7C0903A6, 0x4E800420
+    };
+    uint32_t* newGlue = NULL;
+
+    if (tvp != NULL) {
+        newGlue = (uint32_t*) malloc(sizeof(glue));
+        if (newGlue != NULL) {
+            memcpy(newGlue, glue, sizeof(glue));
+            newGlue[0] |= ((UInt32)tvp >> 16);
+            newGlue[1] |= ((UInt32)tvp & 0xFFFF);
+            MakeDataExecutable(newGlue, sizeof(glue));
+        }
+    }
+    return newGlue;
+}
+
+#define FP2TV(fp) _FP2TV((void *)fp)
+
+static void*
+_FP2TV(void *fp)
+{
+    void **newGlue = NULL;
+    if (fp != NULL) {
+        newGlue = (void**) malloc(2 * sizeof(void *));
+        if (newGlue != NULL) {
+            newGlue[0] = fp;
+            newGlue[1] = NULL;
+        }
+    }
+    return newGlue;
+}
+
+#else
+
+#define TV2FP(f) (f)
+#define FP2TV(f) (f)
+
+#endif /* XP_MACOSX && __POWERPC__ */
+
+// This function sends a notification using the observer service to any object
+// registered to listen to the "experimental-notify-plugin-call" subject.
+// Each "experimental-notify-plugin-call" notification carries with it the run
+// time value in milliseconds that the call took to execute.
+void NS_NotifyPluginCall(PRIntervalTime startTime) 
+{
+  PRIntervalTime endTime = PR_IntervalNow() - startTime;
+  nsCOMPtr<nsIObserverService> notifyUIService =
+    do_GetService("@mozilla.org/observer-service;1");
+  float runTimeInSeconds = float(endTime) / PR_TicksPerSecond();
+  nsAutoString runTimeString;
+  runTimeString.AppendFloat(runTimeInSeconds);
+  const PRUnichar* runTime = runTimeString.get();
+  notifyUIService->NotifyObservers(nsnull, "experimental-notify-plugin-call",
+                                   runTime);
+}
+
+NPNetscapeFuncs nsNPAPIPlugin::CALLBACKS;
+
+void
+nsNPAPIPlugin::CheckClassInitialized(void)
+{
+  static PRBool initialized = PR_FALSE;
+
+  if (initialized)
+    return;
+
+  // XXX It'd be nice to make this const and initialize it statically...
+  CALLBACKS.size = sizeof(CALLBACKS);
+  CALLBACKS.version = (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR;
+
+  CALLBACKS.geturl =
+    NewNPN_GetURLProc(FP2TV(_geturl));
+
+  CALLBACKS.posturl =
+    NewNPN_PostURLProc(FP2TV(_posturl));
+
+  CALLBACKS.requestread =
+    NewNPN_RequestReadProc(FP2TV(_requestread));
+
+  CALLBACKS.newstream =
+    NewNPN_NewStreamProc(FP2TV(_newstream));
+
+  CALLBACKS.write =
+    NewNPN_WriteProc(FP2TV(_write));
+
+  CALLBACKS.destroystream =
+    NewNPN_DestroyStreamProc(FP2TV(_destroystream));
+
+  CALLBACKS.status =
+    NewNPN_StatusProc(FP2TV(_status));
+
+  CALLBACKS.uagent =
+    NewNPN_UserAgentProc(FP2TV(_useragent));
+
+  CALLBACKS.memalloc =
+    NewNPN_MemAllocProc(FP2TV(_memalloc));
+
+  CALLBACKS.memfree =
+    NewNPN_MemFreeProc(FP2TV(_memfree));
+
+  CALLBACKS.memflush =
+    NewNPN_MemFlushProc(FP2TV(_memflush));
+
+  CALLBACKS.reloadplugins =
+    NewNPN_ReloadPluginsProc(FP2TV(_reloadplugins));
+
+  // Deprecated API callbacks.
+  CALLBACKS.getJavaEnv =
+    NewNPN_GetJavaEnvProc(FP2TV(_getJavaEnv));
+  CALLBACKS.getJavaPeer =
+    NewNPN_GetJavaPeerProc(FP2TV(_getJavaPeer));
+
+  CALLBACKS.geturlnotify =
+    NewNPN_GetURLNotifyProc(FP2TV(_geturlnotify));
+
+  CALLBACKS.posturlnotify =
+    NewNPN_PostURLNotifyProc(FP2TV(_posturlnotify));
+
+  CALLBACKS.getvalue =
+    NewNPN_GetValueProc(FP2TV(_getvalue));
+
+  CALLBACKS.setvalue =
+    NewNPN_SetValueProc(FP2TV(_setvalue));
+
+  CALLBACKS.invalidaterect =
+    NewNPN_InvalidateRectProc(FP2TV(_invalidaterect));
+
+  CALLBACKS.invalidateregion =
+    NewNPN_InvalidateRegionProc(FP2TV(_invalidateregion));
+
+  CALLBACKS.forceredraw =
+    NewNPN_ForceRedrawProc(FP2TV(_forceredraw));
+
+  CALLBACKS.getstringidentifier =
+    NewNPN_GetStringIdentifierProc(FP2TV(_getstringidentifier));
+
+  CALLBACKS.getstringidentifiers =
+    NewNPN_GetStringIdentifiersProc(FP2TV(_getstringidentifiers));
+
+  CALLBACKS.getintidentifier =
+    NewNPN_GetIntIdentifierProc(FP2TV(_getintidentifier));
+
+  CALLBACKS.identifierisstring =
+    NewNPN_IdentifierIsStringProc(FP2TV(_identifierisstring));
+
+  CALLBACKS.utf8fromidentifier =
+    NewNPN_UTF8FromIdentifierProc(FP2TV(_utf8fromidentifier));
+
+  CALLBACKS.intfromidentifier =
+    NewNPN_IntFromIdentifierProc(FP2TV(_intfromidentifier));
+
+  CALLBACKS.createobject =
+    NewNPN_CreateObjectProc(FP2TV(_createobject));
+
+  CALLBACKS.retainobject =
+    NewNPN_RetainObjectProc(FP2TV(_retainobject));
+
+  CALLBACKS.releaseobject =
+    NewNPN_ReleaseObjectProc(FP2TV(_releaseobject));
+
+  CALLBACKS.invoke =
+    NewNPN_InvokeProc(FP2TV(_invoke));
+
+  CALLBACKS.invokeDefault =
+    NewNPN_InvokeDefaultProc(FP2TV(_invokeDefault));
+
+  CALLBACKS.evaluate =
+    NewNPN_EvaluateProc(FP2TV(_evaluate));
+
+  CALLBACKS.getproperty =
+    NewNPN_GetPropertyProc(FP2TV(_getproperty));
+
+  CALLBACKS.setproperty =
+    NewNPN_SetPropertyProc(FP2TV(_setproperty));
+
+  CALLBACKS.removeproperty =
+    NewNPN_RemovePropertyProc(FP2TV(_removeproperty));
+
+  CALLBACKS.hasproperty =
+    NewNPN_HasPropertyProc(FP2TV(_hasproperty));
+
+  CALLBACKS.hasmethod =
+    NewNPN_HasMethodProc(FP2TV(_hasmethod));
+
+  CALLBACKS.enumerate =
+    NewNPN_EnumerateProc(FP2TV(_enumerate));
+
+  CALLBACKS.construct =
+    NewNPN_ConstructProc(FP2TV(_construct));
+
+  CALLBACKS.releasevariantvalue =
+    NewNPN_ReleaseVariantValueProc(FP2TV(_releasevariantvalue));
+
+  CALLBACKS.setexception =
+    NewNPN_SetExceptionProc(FP2TV(_setexception));
+
+  CALLBACKS.pushpopupsenabledstate =
+    NewNPN_PushPopupsEnabledStateProc(FP2TV(_pushpopupsenabledstate));
+
+  CALLBACKS.poppopupsenabledstate =
+    NewNPN_PopPopupsEnabledStateProc(FP2TV(_poppopupsenabledstate));
+
+  CALLBACKS.pluginthreadasynccall =
+    NewNPN_PluginThreadAsyncCallProc(FP2TV(_pluginthreadasynccall));
+
+  if (!sPluginThreadAsyncCallLock) {
+    sPluginThreadAsyncCallLock =
+      nsAutoLock::NewLock("sPluginThreadAsyncCallLock");
+  }
+
+  initialized = PR_TRUE;
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN callbacks initialized\n"));
+}
+
+NS_IMPL_ISUPPORTS2(nsNPAPIPlugin, nsIPlugin, nsIFactory)
+
+nsNPAPIPlugin::nsNPAPIPlugin(NPPluginFuncs* callbacks, PRLibrary* aLibrary,
+                             NP_PLUGINSHUTDOWN aShutdown)
+{
+  memset((void*) &fCallbacks, 0, sizeof(fCallbacks));
+  fLibrary = nsnull;
+
+#if defined(XP_WIN) || defined(XP_OS2)
+  // On Windows (and Mac) we need to keep a direct reference to the
+  // fCallbacks and NOT just copy the struct. See Bugzilla 85334
+
+  NP_GETENTRYPOINTS pfnGetEntryPoints =
+    (NP_GETENTRYPOINTS)PR_FindSymbol(aLibrary, "NP_GetEntryPoints");
+
+  if (!pfnGetEntryPoints)
+    return;
+
+  fCallbacks.size = sizeof(fCallbacks);
+
+  nsresult result = pfnGetEntryPoints(&fCallbacks);
+  NS_ASSERTION(result == NS_OK, "Failed to get callbacks");
+
+  NS_ASSERTION(HIBYTE(fCallbacks.version) >= NP_VERSION_MAJOR,
+               "callback version is less than NP version");
+
+  fShutdownEntry = (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
+#elif defined(XP_MACOSX)
+  NPPluginFuncs np_callbacks;
+  memset((void*) &np_callbacks, 0, sizeof(np_callbacks));
+  np_callbacks.size = sizeof(np_callbacks);
+
+/*  Since WebKit supports getting function pointers via NP_GetEntryPoints and
+ *  sending function pointers via NP_Initialize, it would be nice if we
+ *  supported that too. We can't do it on PPC because there is no standard for
+ *  whether or not function pointers returned via NP_GetEntryPoints or sent
+ *  via NP_Initialize are supposed to be wrapped with tvector glue. However,
+ *  since there are no tvectors on Intel we can do it on that arch.
+ */
+#ifndef __POWERPC__
+  fShutdownEntry = (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
+  NP_GETENTRYPOINTS pfnGetEntryPoints = (NP_GETENTRYPOINTS)PR_FindSymbol(aLibrary, "NP_GetEntryPoints");
+  NP_PLUGININIT pfnInitialize = (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
+  if (pfnGetEntryPoints && pfnInitialize && fShutdownEntry) {
+    // we call NP_Initialize before getting function pointers to match
+    // WebKit's behavior. They implemented this first on Mac OS X.
+    if (pfnInitialize(&(nsNPAPIPlugin::CALLBACKS)) != NPERR_NO_ERROR)
+      return;
+    if (pfnGetEntryPoints(&np_callbacks) != NPERR_NO_ERROR)
+      return;
+  }
+  else
+#endif
+  {
+    // call into the entry point
+    NP_MAIN pfnMain = (NP_MAIN)PR_FindSymbol(aLibrary, "main");
+
+    if (pfnMain == NULL)
+      return;
+
+    NPError error;
+    NPP_ShutdownUPP pfnMainShutdown;
+    NS_TRY_SAFE_CALL_RETURN(error,
+                            CallNPP_MainEntryProc(pfnMain,
+                                                  &(nsNPAPIPlugin::CALLBACKS),
+                                                  &np_callbacks,
+                                                  &pfnMainShutdown),
+                            aLibrary,
+                            nsnull);
+    
+    NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
+                   ("NPP MainEntryProc called: return=%d\n",error));
+    
+    if (error != NPERR_NO_ERROR)
+      return;
+    
+    fShutdownEntry = (NP_PLUGINSHUTDOWN)TV2FP(pfnMainShutdown);
+    
+    // version is a uint16_t so cast to int to avoid an invalid
+    // comparison due to limited range of the data type
+    int cb_version = np_callbacks.version;
+    if ((cb_version >> 8) < NP_VERSION_MAJOR)
+      return;
+  }
+
+  // wrap all plugin entry points tvectors as mach-o callable function
+  // pointers.
+  fCallbacks.size = sizeof(fCallbacks);
+  fCallbacks.version = np_callbacks.version;
+  fCallbacks.newp = (NPP_NewUPP) TV2FP(np_callbacks.newp);
+  fCallbacks.destroy = (NPP_DestroyUPP) TV2FP(np_callbacks.destroy);
+  fCallbacks.setwindow = (NPP_SetWindowUPP) TV2FP(np_callbacks.setwindow);
+  fCallbacks.newstream = (NPP_NewStreamUPP) TV2FP(np_callbacks.newstream);
+  fCallbacks.destroystream =
+    (NPP_DestroyStreamUPP) TV2FP(np_callbacks.destroystream);
+  fCallbacks.asfile = (NPP_StreamAsFileUPP) TV2FP(np_callbacks.asfile);
+  fCallbacks.writeready = (NPP_WriteReadyUPP) TV2FP(np_callbacks.writeready);
+  fCallbacks.write = (NPP_WriteUPP) TV2FP(np_callbacks.write);
+  fCallbacks.print = (NPP_PrintUPP) TV2FP(np_callbacks.print);
+  fCallbacks.event = (NPP_HandleEventUPP) TV2FP(np_callbacks.event);
+  fCallbacks.urlnotify = (NPP_URLNotifyUPP) TV2FP(np_callbacks.urlnotify);
+  fCallbacks.getvalue = (NPP_GetValueUPP) TV2FP(np_callbacks.getvalue);
+  fCallbacks.setvalue = (NPP_SetValueUPP) TV2FP(np_callbacks.setvalue);
+#else // for everyone else
+  memcpy((void*) &fCallbacks, (void*) callbacks, sizeof(fCallbacks));
+  fShutdownEntry = aShutdown;
+#endif
+
+  fLibrary = aLibrary;
+}
+
+nsNPAPIPlugin::~nsNPAPIPlugin(void)
+{
+  // reset the callbacks list
+#if defined(XP_MACOSX) && defined(__POWERPC__)
+  // release all wrapped plugin entry points.
+  if (fCallbacks.newp)
+    free((void *)fCallbacks.newp);
+  if (fCallbacks.destroy)
+    free((void *)fCallbacks.destroy);
+  if (fCallbacks.setwindow)
+    free((void *)fCallbacks.setwindow);
+  if (fCallbacks.newstream)
+    free((void *)fCallbacks.newstream);
+  if (fCallbacks.asfile)
+    free((void *)fCallbacks.asfile);
+  if (fCallbacks.writeready)
+    free((void *)fCallbacks.writeready);
+  if (fCallbacks.write)
+    free((void *)fCallbacks.write);
+  if (fCallbacks.print)
+    free((void *)fCallbacks.print);
+  if (fCallbacks.event)
+    free((void *)fCallbacks.event);
+  if (fCallbacks.urlnotify)
+    free((void *)fCallbacks.urlnotify);
+  if (fCallbacks.getvalue)
+    free((void *)fCallbacks.getvalue);
+  if (fCallbacks.setvalue)
+    free((void *)fCallbacks.setvalue);
+#endif
+  memset((void*) &fCallbacks, 0, sizeof(fCallbacks));
+}
+
+
+#if defined(XP_MACOSX)
+void
+nsNPAPIPlugin::SetPluginRefNum(short aRefNum)
+{
+  fPluginRefNum = aRefNum;
+}
+#endif
+
+// Creates the nsNPAPIPlugin object. One nsNPAPIPlugin object exists per plugin (not instance).
+nsresult
+nsNPAPIPlugin::CreatePlugin(const char* aFileName, const char* aFullPath,
+                            PRLibrary* aLibrary, nsIPlugin** aResult)
+{
+  CheckClassInitialized();
+
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+  nsNPAPIPlugin *plptr;
+
+  NPPluginFuncs callbacks;
+  memset((void*) &callbacks, 0, sizeof(callbacks));
+  callbacks.size = sizeof(callbacks);
+
+  NP_PLUGINSHUTDOWN pfnShutdown =
+    (NP_PLUGINSHUTDOWN)PR_FindFunctionSymbol(aLibrary, "NP_Shutdown");
+
+  // create the new plugin handler
+  *aResult = plptr =
+    new nsNPAPIPlugin(&callbacks, aLibrary, pfnShutdown);
+
+  if (*aResult == NULL)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aResult);
+
+  if (!aFileName) //do not call NP_Initialize in this case, bug 74938
+    return NS_OK;
+
+  // we must init here because the plugin may call NPN functions
+  // when we call into the NP_Initialize entry point - NPN functions
+  // require that mBrowserManager be set up
+  plptr->Initialize();
+
+  NP_PLUGINUNIXINIT pfnInitialize =
+    (NP_PLUGINUNIXINIT)PR_FindFunctionSymbol(aLibrary, "NP_Initialize");
+
+  if (pfnInitialize == NULL)
+    return NS_ERROR_UNEXPECTED; // XXX Right error?
+
+  if (pfnInitialize(&(nsNPAPIPlugin::CALLBACKS),&callbacks) != NS_OK)
+    return NS_ERROR_UNEXPECTED;
+
+  // now copy function table back to nsNPAPIPlugin instance
+  memcpy((void*) &(plptr->fCallbacks), (void*)&callbacks, sizeof(callbacks));
+#endif
+
+#ifdef XP_WIN
+  // Note: on Windows, we must use the fCallback because plugins may
+  // change the function table. The Shockwave installer makes changes
+  // in the table while running
+  *aResult = new nsNPAPIPlugin(nsnull, aLibrary, nsnull);
+
+  if (*aResult == NULL)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aResult);
+
+  // we must init here because the plugin may call NPN functions
+  // when we call into the NP_Initialize entry point - NPN functions
+  // require that mBrowserManager be set up
+  if (NS_FAILED((*aResult)->Initialize())) {
+    NS_RELEASE(*aResult);
+    return NS_ERROR_FAILURE;
+  }
+
+  NP_PLUGININIT pfnInitialize =
+    (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
+
+  if (pfnInitialize == NULL)
+    return NS_ERROR_UNEXPECTED;
+
+  if (pfnInitialize(&(nsNPAPIPlugin::CALLBACKS)) != NS_OK)
+    return NS_ERROR_UNEXPECTED;
+#endif
+
+#ifdef XP_OS2
+  // create the new plugin handler
+  *aResult = new nsNPAPIPlugin(nsnull, aLibrary, nsnull);
+
+  if (*aResult == NULL)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aResult);
+
+  // we must init here because the plugin may call NPN functions
+  // when we call into the NP_Initialize entry point - NPN functions
+  // require that mBrowserManager be set up
+  if (NS_FAILED((*aResult)->Initialize())) {
+    NS_RELEASE(*aResult);
+    return NS_ERROR_FAILURE;
+  }
+
+  NP_PLUGININIT pfnInitialize =
+    (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
+
+  if (pfnInitialize == NULL)
+    return NS_ERROR_UNEXPECTED; // XXX Right error?
+
+  // Fixes problem where the OS/2 native multimedia plugins weren't
+  // working on mozilla though did work on 4.x.  Problem is that they
+  // expect the current working directory to be the plugins dir.
+  // Since these plugins are no longer maintained and they represent
+  // the majority of the OS/2 plugin contingency, we'll have to make
+  // them work here.
+
+#define MAP_DISKNUM_TO_LETTER(n) ('A' + (n - 1))
+#define MAP_LETTER_TO_DISKNUM(c) (toupper(c)-'A'+1)
+
+  unsigned long origDiskNum, pluginDiskNum, logicalDisk;
+
+  char pluginPath[CCHMAXPATH], origPath[CCHMAXPATH];
+  strcpy(pluginPath, aFileName);
+  char* slash = strrchr(pluginPath, '\\');
+  *slash = '\0';
+
+  DosQueryCurrentDisk( &origDiskNum, &logicalDisk );
+  pluginDiskNum = MAP_LETTER_TO_DISKNUM(pluginPath[0]);
+
+  origPath[0] = MAP_DISKNUM_TO_LETTER(origDiskNum);
+  origPath[1] = ':';
+  origPath[2] = '\\';
+
+  ULONG len = CCHMAXPATH-3;
+  APIRET rc = DosQueryCurrentDir(0, &origPath[3], &len);
+  NS_ASSERTION(NO_ERROR == rc,"DosQueryCurrentDir failed");
+
+  BOOL bChangedDir = FALSE;
+  BOOL bChangedDisk = FALSE;
+  if (pluginDiskNum != origDiskNum) {
+    rc = DosSetDefaultDisk(pluginDiskNum);
+    NS_ASSERTION(NO_ERROR == rc,"DosSetDefaultDisk failed");
+    bChangedDisk = TRUE;
+  }
+
+  if (stricmp(origPath, pluginPath) != 0) {
+    rc = DosSetCurrentDir(pluginPath);
+    NS_ASSERTION(NO_ERROR == rc,"DosSetCurrentDir failed");
+    bChangedDir = TRUE;
+  }
+
+  nsresult rv = pfnInitialize(&(nsNPAPIPlugin::CALLBACKS));
+
+  if (bChangedDisk) {
+    rc= DosSetDefaultDisk(origDiskNum);
+    NS_ASSERTION(NO_ERROR == rc,"DosSetDefaultDisk failed");
+  }
+  if (bChangedDir) {
+    rc = DosSetCurrentDir(origPath);
+    NS_ASSERTION(NO_ERROR == rc,"DosSetCurrentDir failed");
+  }
+
+  if (!NS_SUCCEEDED(rv)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+#endif
+
+#if defined(XP_MACOSX)
+  short appRefNum = ::CurResFile();
+  short pluginRefNum;
+
+  nsCOMPtr<nsILocalFile> pluginPath;
+  NS_NewNativeLocalFile(nsDependentCString(aFullPath), PR_TRUE,
+                        getter_AddRefs(pluginPath));
+
+  nsPluginFile pluginFile(pluginPath);
+  pluginRefNum = pluginFile.OpenPluginResource();
+
+  nsNPAPIPlugin* plugin = new nsNPAPIPlugin(nsnull, aLibrary, nsnull);
+  ::UseResFile(appRefNum);
+  if (!plugin)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  *aResult = plugin;
+
+  NS_ADDREF(*aResult);
+  if (NS_FAILED((*aResult)->Initialize())) {
+    NS_RELEASE(*aResult);
+    return NS_ERROR_FAILURE;
+  }
+
+  plugin->SetPluginRefNum(pluginRefNum);
+#endif
+
+#ifdef XP_BEOS
+  // I just copied UNIX version.
+  // Makoto Hamanaka <VYA04230@nifty.com>
+
+  nsNPAPIPlugin *plptr;
+
+  NPPluginFuncs callbacks;
+  memset((void*) &callbacks, 0, sizeof(callbacks));
+  callbacks.size = sizeof(callbacks);
+
+  NP_PLUGINSHUTDOWN pfnShutdown =
+    (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
+
+  // create the new plugin handler
+  *aResult = plptr =
+    new nsNPAPIPlugin(&callbacks, aLibrary, pfnShutdown);
+
+  if (*aResult == NULL)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aResult);
+
+  // we must init here because the plugin may call NPN functions
+  // when we call into the NP_Initialize entry point - NPN functions
+  // require that mBrowserManager be set up
+  plptr->Initialize();
+
+  NP_PLUGINUNIXINIT pfnInitialize =
+    (NP_PLUGINUNIXINIT)PR_FindSymbol(aLibrary, "NP_Initialize");
+
+  if (pfnInitialize == NULL)
+    return NS_ERROR_FAILURE;
+
+  if (pfnInitialize(&(nsNPAPIPlugin::CALLBACKS),&callbacks) != NS_OK)
+    return NS_ERROR_FAILURE;
+
+  // now copy function table back to nsNPAPIPlugin instance
+  memcpy((void*) &(plptr->fCallbacks), (void*)&callbacks, sizeof(callbacks));
+#endif
+
+  return NS_OK;
+}
+
+nsresult
+nsNPAPIPlugin::CreateInstance(nsISupports *aOuter, const nsIID &aIID,
+                           void **aResult)
+{
+  if (aResult == NULL)
+    return NS_ERROR_NULL_POINTER;
+
+  *aResult = NULL;
+
+  // XXX This is suspicuous!
+  nsRefPtr<nsNPAPIPluginInstance> inst =
+    new nsNPAPIPluginInstance(&fCallbacks, fLibrary);
+
+  if (!inst)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  return inst->QueryInterface(aIID, aResult);
+}
+
+nsresult
+nsNPAPIPlugin::LockFactory(PRBool aLock)
+{
+  // Not implemented in simplest case.
+  return NS_OK;
+}
+
+NS_METHOD
+nsNPAPIPlugin::CreatePluginInstance(nsISupports *aOuter, REFNSIID aIID,
+                                    const char *aPluginMIMEType, void **aResult)
+{
+  return CreateInstance(aOuter, aIID, aResult);
+}
+
+nsresult
+nsNPAPIPlugin::Initialize(void)
+{
+  if (nsnull == fLibrary)
+    return NS_ERROR_FAILURE;
+  return NS_OK;
+}
+
+nsresult
+nsNPAPIPlugin::Shutdown(void)
+{
+  NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
+                 ("NPP Shutdown to be called: this=%p\n", this));
+
+  if (fShutdownEntry != nsnull) {
+#if defined(XP_MACOSX)
+    CallNPP_ShutdownProc(fShutdownEntry);
+    if (fPluginRefNum > 0)
+      ::CloseResFile(fPluginRefNum);
+#else
+    NS_TRY_SAFE_CALL_VOID(fShutdownEntry(), fLibrary, nsnull);
+#endif
+
+#if defined(XP_MACOSX) && defined(__POWERPC__)
+    // release the wrapped plugin function.
+    free((void *)fShutdownEntry);
+#endif
+    fShutdownEntry = nsnull;
+  }
+
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+             ("NPAPIPlugin Shutdown done, this=%p", this));
+  return NS_OK;
+}
+
+nsresult
+nsNPAPIPlugin::GetMIMEDescription(const char* *resultingDesc)
+{
+  const char* (*npGetMIMEDescription)() =
+    (const char* (*)()) PR_FindFunctionSymbol(fLibrary, "NP_GetMIMEDescription");
+
+  *resultingDesc = npGetMIMEDescription ? npGetMIMEDescription() : "";
+
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+             ("nsNPAPIPlugin::GetMIMEDescription called: this=%p, result=%s\n",
+              this, *resultingDesc));
+
+  return NS_OK;
+}
+
+nsresult
+nsNPAPIPlugin::GetValue(nsPluginVariable variable, void *value)
+{
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("nsNPAPIPlugin::GetValue called: this=%p, variable=%d\n", this, variable));
+
+  NPError (*npGetValue)(void*, nsPluginVariable, void*) =
+    (NPError (*)(void*, nsPluginVariable, void*)) PR_FindFunctionSymbol(fLibrary,
+                                                                "NP_GetValue");
+
+  if (npGetValue && NPERR_NO_ERROR == npGetValue(nsnull, variable, value)) {
+    return NS_OK;
+  }
+
+  return NS_ERROR_FAILURE;
+}
+
+// Create a new NPP GET or POST (given in the type argument) url
+// stream that may have a notify callback
+NPError
+MakeNewNPAPIStreamInternal(NPP npp, const char *relativeURL, const char *target,
+                          eNPPStreamTypeInternal type,
+                          PRBool bDoNotify = PR_FALSE,
+                          void *notifyData = nsnull, uint32_t len = 0,
+                          const char *buf = nsnull, NPBool file = PR_FALSE)
+{
+  if (!npp)
+    return NPERR_INVALID_INSTANCE_ERROR;
+
+  PluginDestructionGuard guard(npp);
+
+  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+
+  NS_ASSERTION(inst != NULL, "null instance");
+  if (inst == NULL)
+    return NPERR_INVALID_INSTANCE_ERROR;
+
+  nsCOMPtr<nsIPluginManager> pm = do_GetService(kPluginManagerCID);
+  NS_ASSERTION(pm, "failed to get plugin manager");
+  if (!pm) return NPERR_GENERIC_ERROR;
+
+  nsCOMPtr<nsIPluginStreamListener> listener;
+  if (target == nsnull)
+    ((nsNPAPIPluginInstance*)inst)->NewNotifyStream(getter_AddRefs(listener),
+                                                    notifyData,
+                                                    bDoNotify, relativeURL);
+
+  switch (type) {
+  case eNPPStreamTypeInternal_Get:
+    {
+      if (NS_FAILED(pm->GetURL(inst, relativeURL, target, listener)))
+        return NPERR_GENERIC_ERROR;
+      break;
+    }
+  case eNPPStreamTypeInternal_Post:
+    {
+      if (NS_FAILED(pm->PostURL(inst, relativeURL, len, buf, file, target,
+                                listener)))
+        return NPERR_GENERIC_ERROR;
+      break;
+    }
+  default:
+    NS_ASSERTION(0, "how'd I get here");
+  }
+
+  return NPERR_NO_ERROR;
+}
+
+//
+// Static callbacks that get routed back through the new C++ API
+//
+
+NPError NP_CALLBACK
+_geturl(NPP npp, const char* relativeURL, const char* target)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturl called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
+   relativeURL));
+
+  PluginDestructionGuard guard(npp);
+
+  // Block Adobe Acrobat from loading URLs that are not http:, https:,
+  // or ftp: URLs if the given target is null.
+  if (target == nsnull && relativeURL &&
+      (strncmp(relativeURL, "http:", 5) != 0) &&
+      (strncmp(relativeURL, "https:", 6) != 0) &&
+      (strncmp(relativeURL, "ftp:", 4) != 0)) {
+    nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
+
+    const char *name = nsPluginHostImpl::GetPluginName(inst);
+
+    if (name && strstr(name, "Adobe") && strstr(name, "Acrobat")) {
+      return NPERR_NO_ERROR;
+    }
+  }
+
+  return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
+                                    eNPPStreamTypeInternal_Get);
+}
+
+NPError NP_CALLBACK
+_geturlnotify(NPP npp, const char* relativeURL, const char* target,
+              void* notifyData)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturlnotify called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+    ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
+     target, notifyData, relativeURL));
+
+  PluginDestructionGuard guard(npp);
+
+  return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
+                                    eNPPStreamTypeInternal_Get, PR_TRUE,
+                                    notifyData);
+}
+
+NPError NP_CALLBACK
+_posturlnotify(NPP npp, const char *relativeURL, const char *target,
+               uint32_t len, const char *buf, NPBool file, void *notifyData)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturlnotify called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+                 ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
+                  "notify=%p, url=%s, buf=%s\n",
+                  (void*)npp, target, len, file, notifyData, relativeURL,
+                  buf));
+
+  PluginDestructionGuard guard(npp);
+
+  return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
+                                    eNPPStreamTypeInternal_Post, PR_TRUE,
+                                    notifyData, len, buf, file);
+}
+
+NPError NP_CALLBACK
+_posturl(NPP npp, const char *relativeURL, const char *target,
+         uint32_t len, const char *buf, NPBool file)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturl called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+                 ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
+                  "buf=%s\n",
+                  (void*)npp, target, file, len, relativeURL, buf));
+
+  PluginDestructionGuard guard(npp);
+
+  return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
+                                    eNPPStreamTypeInternal_Post, PR_FALSE, nsnull,
+                                    len, buf, file);
+}
+
+// A little helper class used to wrap up plugin manager streams (that is,
+// streams from the plugin to the browser).
+class nsNPAPIStreamWrapper : nsISupports
+{
+public:
+  NS_DECL_ISUPPORTS
+
+protected:
+  nsIOutputStream *fStream;
+  NPStream        fNPStream;
+
+public:
+  nsNPAPIStreamWrapper(nsIOutputStream* stream);
+  ~nsNPAPIStreamWrapper();
+
+  void GetStream(nsIOutputStream* &result);
+  NPStream* GetNPStream(void) { return &fNPStream; }
+};
+
+NS_IMPL_ISUPPORTS1(nsNPAPIStreamWrapper, nsISupports)
+
+nsNPAPIStreamWrapper::nsNPAPIStreamWrapper(nsIOutputStream* stream)
+: fStream(stream)
+{
+  NS_ASSERTION(stream != NULL, "bad stream");
+
+  fStream = stream;
+  NS_ADDREF(fStream);
+
+  memset(&fNPStream, 0, sizeof(fNPStream));
+  fNPStream.ndata = (void*) this;
+}
+
+nsNPAPIStreamWrapper::~nsNPAPIStreamWrapper(void)
+{
+  fStream->Close();
+  NS_IF_RELEASE(fStream);
+}
+
+void
+nsNPAPIStreamWrapper::GetStream(nsIOutputStream* &result)
+{
+  result = fStream;
+  NS_IF_ADDREF(fStream);
+}
+
+NPError NP_CALLBACK
+_newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_newstream called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
+   (const char *)type, target));
+
+  NPError err = NPERR_INVALID_INSTANCE_ERROR;
+  if (npp && npp->ndata) {
+    nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+
+    PluginDestructionGuard guard(inst);
+
+    nsCOMPtr<nsIOutputStream> stream;
+    nsCOMPtr<nsIPluginInstancePeer> peer;
+    if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) &&
+      peer &&
+      NS_SUCCEEDED(peer->NewStream((const char*) type, target,
+                                   getter_AddRefs(stream)))) {
+      nsNPAPIStreamWrapper* wrapper = new nsNPAPIStreamWrapper(stream);
+      if (wrapper) {
+        (*result) = wrapper->GetNPStream();
+        err = NPERR_NO_ERROR;
+      } else {
+        err = NPERR_OUT_OF_MEMORY_ERROR;
+      }
+    } else {
+      err = NPERR_GENERIC_ERROR;
+    }
+  }
+  return err;
+}
+
+int32_t NP_CALLBACK
+_write(NPP npp, NPStream *pstream, int32_t len, void *buffer)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
+    return 0;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+                 ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
+                  pstream->url, len, (char*)buffer));
+
+  // negative return indicates failure to the plugin
+  if (!npp)
+    return -1;
+
+  PluginDestructionGuard guard(npp);
+
+  nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper*) pstream->ndata;
+  NS_ASSERTION(wrapper != NULL, "null stream");
+
+  if (wrapper == NULL)
+    return -1;
+
+  nsIOutputStream* stream;
+  wrapper->GetStream(stream);
+
+  PRUint32 count = 0;
+  nsresult rv = stream->Write((char *)buffer, len, &count);
+  NS_RELEASE(stream);
+
+  if (rv != NS_OK)
+    return -1;
+
+  return (int32_t)count;
+}
+
+NPError NP_CALLBACK
+_destroystream(NPP npp, NPStream *pstream, NPError reason)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+                 ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
+                  pstream->url, (int)reason));
+
+  if (!npp)
+    return NPERR_INVALID_INSTANCE_ERROR;
+
+  PluginDestructionGuard guard(npp);
+
+  nsCOMPtr<nsIPluginStreamListener> listener =
+    do_QueryInterface((nsISupports *)pstream->ndata);
+
+  // DestroyStream can kill two kinds of streams: NPP derived and NPN derived.
+  // check to see if they're trying to kill a NPP stream
+  if (listener) {
+    // Tell the stream listner that the stream is now gone.
+    listener->OnStopBinding(nsnull, NS_BINDING_ABORTED);
+
+    // FIXME: http://bugzilla.mozilla.org/show_bug.cgi?id=240131
+    //
+    // Is it ok to leave pstream->ndata set here, and who releases it
+    // (or is it even properly ref counted)? And who closes the stream
+    // etc?
+  } else {
+    nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper *)pstream->ndata;
+    NS_ASSERTION(wrapper != NULL, "null wrapper");
+
+    if (wrapper == NULL)
+      return NPERR_INVALID_PARAM;
+
+    // This will release the wrapped nsIOutputStream.
+    delete wrapper;
+    pstream->ndata = nsnull;
+  }
+
+  return NPERR_NO_ERROR;
+}
+
+void NP_CALLBACK
+_status(NPP npp, const char *message)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_status called from the wrong thread\n"));
+    return;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_Status: npp=%p, message=%s\n",
+                                     (void*)npp, message));
+
+  if (!npp || !npp->ndata) {
+    NS_WARNING("_status: npp or npp->ndata == 0");
+    return;
+  }
+
+  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+
+  PluginDestructionGuard guard(inst);
+
+  nsCOMPtr<nsIPluginInstancePeer> peer;
+  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
+    peer->ShowStatus(message);
+  }
+}
+
+void NP_CALLBACK
+_memfree (void *ptr)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memfree called from the wrong thread\n"));
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
+
+  if (ptr)
+    nsMemory::Free(ptr);
+}
+
+uint32_t NP_CALLBACK
+_memflush(uint32_t size)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memflush called from the wrong thread\n"));
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
+
+  nsMemory::HeapMinimize(PR_TRUE);
+  return 0;
+}
+
+void NP_CALLBACK
+_reloadplugins(NPBool reloadPages)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_reloadplugins called from the wrong thread\n"));
+    return;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+                 ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
+
+  nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
+  if (!pm)
+    return;
+
+  pm->ReloadPlugins(reloadPages);
+}
+
+void NP_CALLBACK
+_invalidaterect(NPP npp, NPRect *invalidRect)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidaterect called from the wrong thread\n"));
+    return;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+                 ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
+                  "right=%d\n", (void *)npp, invalidRect->top,
+                  invalidRect->left, invalidRect->bottom, invalidRect->right));
+
+  if (!npp || !npp->ndata) {
+    NS_WARNING("_invalidaterect: npp or npp->ndata == 0");
+    return;
+  }
+
+  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+
+  PluginDestructionGuard guard(inst);
+
+  nsCOMPtr<nsIPluginInstancePeer> peer;
+  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
+    nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
+    if (wpeer) {
+      // XXX nsRect & NPRect are structurally equivalent
+      wpeer->InvalidateRect((nsPluginRect *)invalidRect);
+    }
+  }
+}
+
+void NP_CALLBACK
+_invalidateregion(NPP npp, NPRegion invalidRegion)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidateregion called from the wrong thread\n"));
+    return;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+                 ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
+                  (void*)invalidRegion));
+
+  if (!npp || !npp->ndata) {
+    NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
+    return;
+  }
+
+  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+
+  PluginDestructionGuard guard(inst);
+
+  nsCOMPtr<nsIPluginInstancePeer> peer;
+  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
+    nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
+    if (wpeer) {
+      // nsPluginRegion & NPRegion are typedef'd to the same thing
+      wpeer->InvalidateRegion((nsPluginRegion)invalidRegion);
+    }
+  }
+}
+
+void NP_CALLBACK
+_forceredraw(NPP npp)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_forceredraw called from the wrong thread\n"));
+    return;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_ForceDraw: npp=%p\n", (void*)npp));
+
+  if (!npp || !npp->ndata) {
+    NS_WARNING("_forceredraw: npp or npp->ndata == 0");
+    return;
+  }
+
+  nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+
+  PluginDestructionGuard guard(inst);
+
+  nsCOMPtr<nsIPluginInstancePeer> peer;
+  if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
+    nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
+    if (wpeer) {
+      wpeer->ForceRedraw();
+    }
+  }
+}
+
+static nsIDocument *
+GetDocumentFromNPP(NPP npp)
+{
+  NS_ENSURE_TRUE(npp, nsnull);
+
+  nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
+  NS_ENSURE_TRUE(inst, nsnull);
+
+  PluginDestructionGuard guard(inst);
+
+  nsCOMPtr<nsIPluginInstancePeer> pip;
+  inst->GetPeer(getter_AddRefs(pip));
+  nsCOMPtr<nsPIPluginInstancePeer> pp(do_QueryInterface(pip));
+  NS_ENSURE_TRUE(pp, nsnull);
+
+  nsCOMPtr<nsIPluginInstanceOwner> owner;
+  pp->GetOwner(getter_AddRefs(owner));
+  NS_ENSURE_TRUE(owner, nsnull);
+
+  nsCOMPtr<nsIDocument> doc;
+  owner->GetDocument(getter_AddRefs(doc));
+
+  return doc;
+}
+
+static JSContext *
+GetJSContextFromDoc(nsIDocument *doc)
+{
+  nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
+  NS_ENSURE_TRUE(sgo, nsnull);
+
+  nsIScriptContext *scx = sgo->GetContext();
+  NS_ENSURE_TRUE(scx, nsnull);
+
+  return (JSContext *)scx->GetNativeContext();
+}
+
+static JSContext *
+GetJSContextFromNPP(NPP npp)
+{
+  nsIDocument *doc = GetDocumentFromNPP(npp);
+  NS_ENSURE_TRUE(doc, nsnull);
+
+  return GetJSContextFromDoc(doc);
+}
+
+NPObject* NP_CALLBACK
+_getwindowobject(NPP npp)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getwindowobject called from the wrong thread\n"));
+    return nsnull;
+  }
+  JSContext *cx = GetJSContextFromNPP(npp);
+  NS_ENSURE_TRUE(cx, nsnull);
+
+  // Using ::JS_GetGlobalObject(cx) is ok here since the window we
+  // want to return here is the outer window, *not* the inner (since
+  // we don't know what the plugin will do with it).
+  return nsJSObjWrapper::GetNewOrUsed(npp, cx, ::JS_GetGlobalObject(cx));
+}
+
+NPObject* NP_CALLBACK
+_getpluginelement(NPP npp)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getpluginelement called from the wrong thread\n"));
+    return nsnull;
+  }
+  nsIDOMElement *elementp = nsnull;
+  NPError nperr = _getvalue(npp, NPNVDOMElement, &elementp);
+
+  if (nperr != NPERR_NO_ERROR) {
+    return nsnull;
+  }
+
+  // Pass ownership of elementp to element
+  nsCOMPtr<nsIDOMElement> element;
+  element.swap(elementp);
+
+  JSContext *cx = GetJSContextFromNPP(npp);
+  NS_ENSURE_TRUE(cx, nsnull);
+
+  nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID()));
+  NS_ENSURE_TRUE(xpc, nsnull);
+
+  nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
+  xpc->WrapNative(cx, ::JS_GetGlobalObject(cx), element,
+                  NS_GET_IID(nsIDOMElement),
+                  getter_AddRefs(holder));
+  NS_ENSURE_TRUE(holder, nsnull);
+
+  JSObject* obj = nsnull;
+  holder->GetJSObject(&obj);
+  NS_ENSURE_TRUE(obj, nsnull);
+
+  return nsJSObjWrapper::GetNewOrUsed(npp, cx, obj);
+}
+
+static NPIdentifier
+doGetIdentifier(JSContext *cx, const NPUTF8* name)
+{
+  NS_ConvertUTF8toUTF16 utf16name(name);
+
+  JSString *str = ::JS_InternUCStringN(cx, (jschar *)utf16name.get(),
+                                       utf16name.Length());
+
+  if (!str)
+    return NULL;
+
+  return (NPIdentifier)STRING_TO_JSVAL(str);
+}
+
+NPIdentifier NP_CALLBACK
+_getstringidentifier(const NPUTF8* name)
+{
+  if (!name) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifier: passed null name"));
+    return NULL;
+  }
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
+  }
+
+  nsCOMPtr<nsIThreadJSContextStack> stack =
+    do_GetService("@mozilla.org/js/xpc/ContextStack;1");
+  if (!stack)
+    return NULL;
+
+  JSContext *cx = nsnull;
+  stack->GetSafeJSContext(&cx);
+  if (!cx)
+    return NULL;
+
+  JSAutoRequest ar(cx);
+  return doGetIdentifier(cx, name);
+}
+
+void NP_CALLBACK
+_getstringidentifiers(const NPUTF8** names, int32_t nameCount,
+                      NPIdentifier *identifiers)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifiers called from the wrong thread\n"));
+  }
+  nsCOMPtr<nsIThreadJSContextStack> stack =
+    do_GetService("@mozilla.org/js/xpc/ContextStack;1");
+  if (!stack)
+    return;
+
+  JSContext *cx = nsnull;
+  stack->GetSafeJSContext(&cx);
+  if (!cx)
+    return;
+
+  JSAutoRequest ar(cx);
+
+  for (int32_t i = 0; i < nameCount; ++i) {
+    if (names[i]) {
+      identifiers[i] = doGetIdentifier(cx, names[i]);
+    } else {
+      NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifiers: passed null name"));
+      identifiers[i] = NULL;
+    }
+  }
+}
+
+NPIdentifier NP_CALLBACK
+_getintidentifier(int32_t intid)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
+  }
+  return (NPIdentifier)INT_TO_JSVAL(intid);
+}
+
+NPUTF8* NP_CALLBACK
+_utf8fromidentifier(NPIdentifier identifier)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_utf8fromidentifier called from the wrong thread\n"));
+  }
+  if (!identifier)
+    return NULL;
+
+  jsval v = (jsval)identifier;
+
+  if (!JSVAL_IS_STRING(v)) {
+    return nsnull;
+  }
+
+  JSString *str = JSVAL_TO_STRING(v);
+
+  return
+    ToNewUTF8String(nsDependentString((PRUnichar *)::JS_GetStringChars(str),
+                                      ::JS_GetStringLength(str)));
+}
+
+int32_t NP_CALLBACK
+_intfromidentifier(NPIdentifier identifier)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_intfromidentifier called from the wrong thread\n"));
+  }
+  jsval v = (jsval)identifier;
+
+  if (!JSVAL_IS_INT(v)) {
+    return PR_INT32_MIN;
+  }
+
+  return JSVAL_TO_INT(v);
+}
+
+bool NP_CALLBACK
+_identifierisstring(NPIdentifier identifier)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_identifierisstring called from the wrong thread\n"));
+  }
+  jsval v = (jsval)identifier;
+
+  return JSVAL_IS_STRING(v);
+}
+
+NPObject* NP_CALLBACK
+_createobject(NPP npp, NPClass* aClass)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_createobject called from the wrong thread\n"));
+    return nsnull;
+  }
+  if (!npp) {
+    NS_ERROR("Null npp passed to _createobject()!");
+
+    return nsnull;
+  }
+
+  PluginDestructionGuard guard(npp);
+
+  if (!aClass) {
+    NS_ERROR("Null class passed to _createobject()!");
+
+    return nsnull;
+  }
+
+  NPPAutoPusher nppPusher(npp);
+
+  NPObject *npobj;
+
+  if (aClass->allocate) {
+    npobj = aClass->allocate(npp, aClass);
+  } else {
+    npobj = (NPObject *)PR_Malloc(sizeof(NPObject));
+  }
+
+  if (npobj) {
+    npobj->_class = aClass;
+    npobj->referenceCount = 1;
+  }
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("Created NPObject %p, NPClass %p\n", npobj, aClass));
+
+  return npobj;
+}
+
+NPObject* NP_CALLBACK
+_retainobject(NPObject* npobj)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_retainobject called from the wrong thread\n"));
+  }
+  if (npobj) {
+    PR_AtomicIncrement((PRInt32*)&npobj->referenceCount);
+  }
+
+  return npobj;
+}
+
+void NP_CALLBACK
+_releaseobject(NPObject* npobj)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releaseobject called from the wrong thread\n"));
+  }
+  if (!npobj)
+    return;
+
+  int32_t refCnt = PR_AtomicDecrement((PRInt32*)&npobj->referenceCount);
+
+  if (refCnt == 0) {
+    nsNPObjWrapper::OnDestroy(npobj);
+
+    NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                   ("Deleting NPObject %p, refcount hit 0\n", npobj));
+
+    if (npobj->_class && npobj->_class->deallocate) {
+      npobj->_class->deallocate(npobj);
+    } else {
+      PR_Free(npobj);
+    }
+  }
+}
+
+bool NP_CALLBACK
+_invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
+        uint32_t argCount, NPVariant *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invoke called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
+    return false;
+
+  PluginDestructionGuard guard(npp);
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_Invoke(npp %p, npobj %p, method %p, args %d\n", npp,
+                  npobj, method, argCount));
+
+  return npobj->_class->invoke(npobj, method, args, argCount, result);
+}
+
+bool NP_CALLBACK
+_invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
+               uint32_t argCount, NPVariant *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invokedefault called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
+    return false;
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_InvokeDefault(npp %p, npobj %p, args %d\n", npp,
+                  npobj, argCount));
+
+  return npobj->_class->invokeDefault(npobj, args, argCount, result);
+}
+
+bool NP_CALLBACK
+_evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_evaluate called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp)
+    return false;
+
+  NPPAutoPusher nppPusher(npp);
+
+  nsIDocument *doc = GetDocumentFromNPP(npp);
+  NS_ENSURE_TRUE(doc, false);
+
+  JSContext *cx = GetJSContextFromDoc(doc);
+  NS_ENSURE_TRUE(cx, false);
+
+  JSObject *obj =
+    nsNPObjWrapper::GetNewOrUsed(npp, cx, npobj);
+
+  if (!obj) {
+    return false;
+  }
+
+  // Root obj and the rval (below).
+  jsval vec[] = { OBJECT_TO_JSVAL(obj), JSVAL_NULL };
+  JSAutoTempValueRooter tvr(cx, NS_ARRAY_LENGTH(vec), vec);
+  jsval *rval = &vec[1];
+
+  if (result) {
+    // Initialize the out param to void
+    VOID_TO_NPVARIANT(*result);
+  }
+
+  if (!script || !script->utf8length || !script->utf8characters) {
+    // Nothing to evaluate.
+
+    return true;
+  }
+
+  NS_ConvertUTF8toUTF16 utf16script(script->utf8characters,
+                                    script->utf8length);
+
+  nsCOMPtr<nsIScriptContext> scx = GetScriptContextFromJSContext(cx);
+  NS_ENSURE_TRUE(scx, false);
+
+  nsIPrincipal *principal = doc->NodePrincipal();
+
+  nsCAutoString specStr;
+  const char *spec;
+
+  nsCOMPtr<nsIURI> uri;
+  principal->GetURI(getter_AddRefs(uri));
+
+  if (uri) {
+    uri->GetSpec(specStr);
+    spec = specStr.get();
+  } else {
+    // No URI in a principal means it's the system principal. If the
+    // document URI is a chrome:// URI, pass that in as the URI of the
+    // script, else pass in null for the filename as there's no way to
+    // know where this document really came from. Passing in null here
+    // also means that the script gets treated by XPConnect as if it
+    // needs additional protection, which is what we want for unknown
+    // chrome code anyways.
+
+    uri = doc->GetDocumentURI();
+    PRBool isChrome = PR_FALSE;
+
+    if (uri && NS_SUCCEEDED(uri->SchemeIs("chrome", &isChrome)) && isChrome) {
+      uri->GetSpec(specStr);
+      spec = specStr.get();
+    } else {
+      spec = nsnull;
+    }
+  }
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n",
+                  npp, npobj, script->utf8characters));
+
+  nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
+                                             spec, 0, 0, rval, nsnull);
+
+  return NS_SUCCEEDED(rv) &&
+         (!result || JSValToNPVariant(npp, cx, *rval, result));
+}
+
+bool NP_CALLBACK
+_getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
+             NPVariant *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getproperty called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
+    return false;
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_GetProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, property));
+
+  return npobj->_class->getProperty(npobj, property, result);
+}
+
+bool NP_CALLBACK
+_setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
+             const NPVariant *value)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setproperty called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
+    return false;
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_SetProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, property));
+
+  return npobj->_class->setProperty(npobj, property, value);
+}
+
+bool NP_CALLBACK
+_removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_removeproperty called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
+    return false;
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_RemoveProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, property));
+
+  return npobj->_class->removeProperty(npobj, property);
+}
+
+bool NP_CALLBACK
+_hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasproperty called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
+    return false;
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_HasProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, propertyName));
+
+  return npobj->_class->hasProperty(npobj, propertyName);
+}
+
+bool NP_CALLBACK
+_hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasmethod called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
+    return false;
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_HasMethod(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, methodName));
+
+  return npobj->_class->hasProperty(npobj, methodName);
+}
+
+bool NP_CALLBACK
+_enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
+           uint32_t *count)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_enumerate called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class)
+    return false;
+
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_Enumerate(npp %p, npobj %p) called\n", npp, npobj));
+
+  if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
+      !npobj->_class->enumerate) {
+    *identifier = 0;
+    *count = 0;
+    return true;
+  }
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  return npobj->_class->enumerate(npobj, identifier, count);
+}
+
+bool NP_CALLBACK
+_construct(NPP npp, NPObject* npobj, const NPVariant *args,
+               uint32_t argCount, NPVariant *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_construct called from the wrong thread\n"));
+    return false;
+  }
+  if (!npp || !npobj || !npobj->_class ||
+      !NP_CLASS_STRUCT_VERSION_HAS_CTOR(npobj->_class) ||
+      !npobj->_class->construct) {
+    return false;
+  }
+
+  NPPExceptionAutoHolder nppExceptionHolder;
+  NPPAutoPusher nppPusher(npp);
+
+  return npobj->_class->construct(npobj, args, argCount, result);
+}
+
+#ifdef MOZ_MEMORY_WINDOWS
+extern "C" size_t malloc_usable_size(const void *ptr);
+
+BOOL
+InHeap(HANDLE hHeap, LPVOID lpMem)
+{
+  BOOL success = FALSE;
+  PROCESS_HEAP_ENTRY he;
+  he.lpData = NULL;
+  while (HeapWalk(hHeap, &he) != 0) {
+    if (he.lpData == lpMem) {
+      success = TRUE;
+      break;
+    }
+  }
+  HeapUnlock(hHeap);
+  return success;
+}
+#endif
+
+void NP_CALLBACK
+_releasevariantvalue(NPVariant* variant)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releasevariantvalue called from the wrong thread\n"));
+  }
+  switch (variant->type) {
+  case NPVariantType_Void :
+  case NPVariantType_Null :
+  case NPVariantType_Bool :
+  case NPVariantType_Int32 :
+  case NPVariantType_Double :
+    break;
+  case NPVariantType_String :
+    {
+      const NPString *s = &NPVARIANT_TO_STRING(*variant);
+
+      if (s->utf8characters) {
+#ifdef MOZ_MEMORY_WINDOWS
+        if (malloc_usable_size((void *)s->utf8characters) != 0) {
+          PR_Free((void *)s->utf8characters);
+        } else {
+          void *p = (void *)s->utf8characters;
+          DWORD nheaps = 0;
+          nsAutoTArray<HANDLE, 50> heaps;
+          nheaps = GetProcessHeaps(0, heaps.Elements());
+          heaps.AppendElements(nheaps);
+          GetProcessHeaps(nheaps, heaps.Elements());
+          for (DWORD i = 0; i < nheaps; i++) {
+            if (InHeap(heaps[i], p)) {
+              HeapFree(heaps[i], 0, p);
+              break;
+            }
+          }
+        }
+#else
+        PR_Free((void *)s->utf8characters);
+#endif
+      }
+      break;
+    }
+  case NPVariantType_Object:
+    {
+      NPObject *npobj = NPVARIANT_TO_OBJECT(*variant);
+
+      if (npobj)
+        _releaseobject(npobj);
+
+      break;
+    }
+  default:
+    NS_ERROR("Unknown NPVariant type!");
+  }
+
+  VOID_TO_NPVARIANT(*variant);
+}
+
+bool NP_CALLBACK
+_tostring(NPObject* npobj, NPVariant *result)
+{
+  NS_ERROR("Write me!");
+
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_tostring called from the wrong thread\n"));
+    return false;
+  }
+
+  return false;
+}
+
+static char *gNPPException;
+
+void NP_CALLBACK
+_setexception(NPObject* npobj, const NPUTF8 *message)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setexception called from the wrong thread\n"));
+    return;
+  }
+
+  if (gNPPException) {
+    // If a plugin throws multiple exceptions, we'll only report the
+    // last one for now.
+    free(gNPPException);
+  }
+
+  gNPPException = strdup(message);
+}
+
+const char *
+PeekException()
+{
+  return gNPPException;
+}
+
+void
+PopException()
+{
+  NS_ASSERTION(gNPPException, "Uh, no NPP exception to pop!");
+
+  if (gNPPException) {
+    free(gNPPException);
+
+    gNPPException = nsnull;
+  }
+}
+
+NPPExceptionAutoHolder::NPPExceptionAutoHolder()
+  : mOldException(gNPPException)
+{
+  gNPPException = nsnull;
+}
+
+NPPExceptionAutoHolder::~NPPExceptionAutoHolder()
+{
+  NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
+
+  gNPPException = mOldException;
+}
+
+NPError NP_CALLBACK
+_getvalue(NPP npp, NPNVariable variable, void *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getvalue called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
+                                     (void*)npp, (int)variable));
+
+  nsresult res;
+
+  PluginDestructionGuard guard(npp);
+
+  switch(variable) {
+#if defined(XP_UNIX) && !defined(XP_MACOSX)
+  case NPNVxDisplay : {
+#ifdef MOZ_WIDGET_GTK2
+    if (npp) {
+      nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
+      PRBool windowless = PR_FALSE;
+      inst->GetValue(nsPluginInstanceVariable_WindowlessBool, &windowless);
+      NPBool needXEmbed = PR_FALSE;
+      if (!windowless) {
+        inst->GetValue((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &needXEmbed);
+      }
+      if (windowless || needXEmbed) {
+        (*(Display **)result) = GDK_DISPLAY();
+        return NPERR_NO_ERROR;
+      }
+    }
+    // adobe nppdf calls XtGetApplicationNameAndClass(display,
+    // &instance, &class) we have to init Xt toolkit before get
+    // XtDisplay just call gtk_xtbin_new(w,0) once
+    static GtkWidget *gtkXtBinHolder = 0;
+    if (!gtkXtBinHolder) {
+      gtkXtBinHolder = gtk_xtbin_new(GDK_ROOT_PARENT(),0);
+      // it crashes on destroy, let it leak
+      // gtk_widget_destroy(gtkXtBinHolder);
+    }
+    (*(Display **)result) =  GTK_XTBIN(gtkXtBinHolder)->xtdisplay;
+    return NPERR_NO_ERROR;
+#endif
+    return NPERR_GENERIC_ERROR;
+  }
+
+  case NPNVxtAppContext:
+    return NPERR_GENERIC_ERROR;
+#endif
+
+#if defined(XP_WIN) || defined(XP_OS2) || defined(MOZ_WIDGET_GTK2)
+  case NPNVnetscapeWindow: {
+    if (!npp || !npp->ndata)
+      return NPERR_INVALID_INSTANCE_ERROR;
+
+    nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
+
+    nsCOMPtr<nsIPluginInstancePeer> peer;
+    if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) &&
+        peer &&
+        NS_SUCCEEDED(peer->GetValue(nsPluginInstancePeerVariable_NetscapeWindow,
+                                    result))) {
+      return NPERR_NO_ERROR;
+    }
+    return NPERR_GENERIC_ERROR;
+  }
+#endif
+
+  case NPNVjavascriptEnabledBool: {
+    *(NPBool*)result = PR_FALSE;
+    nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
+    if (prefs) {
+      PRBool js = PR_FALSE;;
+      res = prefs->GetBoolPref("javascript.enabled", &js);
+      if (NS_SUCCEEDED(res))
+        *(NPBool*)result = js;
+    }
+    return NPERR_NO_ERROR;
+  }
+
+  case NPNVasdEnabledBool:
+    *(NPBool*)result = PR_FALSE;
+    return NPERR_NO_ERROR;
+
+  case NPNVisOfflineBool: {
+    PRBool offline = PR_FALSE;
+    nsCOMPtr<nsIIOService> ioservice =
+      do_GetService(NS_IOSERVICE_CONTRACTID, &res);
+    if (NS_SUCCEEDED(res))
+      res = ioservice->GetOffline(&offline);
+    if (NS_FAILED(res))
+      return NPERR_GENERIC_ERROR;
+
+    *(NPBool*)result = offline;
+    return NPERR_NO_ERROR;
+  }
+
+  case NPNVserviceManager: {
+    nsIServiceManager * sm;
+    res = NS_GetServiceManager(&sm);
+    if (NS_SUCCEEDED(res)) {
+      *(nsIServiceManager**)result = sm;
+      return NPERR_NO_ERROR;
+    } else {
+      return NPERR_GENERIC_ERROR;
+    }
+  }
+
+  case NPNVDOMElement: {
+    nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
+    NS_ENSURE_TRUE(inst, NPERR_GENERIC_ERROR);
+
+    nsCOMPtr<nsIPluginInstancePeer> pip;
+    inst->GetPeer(getter_AddRefs(pip));
+    nsCOMPtr<nsIPluginTagInfo2> pti2 (do_QueryInterface(pip));
+    if (pti2) {
+      nsCOMPtr<nsIDOMElement> e;
+      pti2->GetDOMElement(getter_AddRefs(e));
+      if (e) {
+        NS_ADDREF(*(nsIDOMElement**)result = e.get());
+        return NPERR_NO_ERROR;
+      }
+    }
+    return NPERR_GENERIC_ERROR;
+  }
+
+  case NPNVDOMWindow: {
+    nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
+    NS_ENSURE_TRUE(inst, NPERR_GENERIC_ERROR);
+
+    nsIDOMWindow *domWindow = inst->GetDOMWindow().get();
+
+    if (domWindow) {
+      // Pass over ownership of domWindow to the caller.
+      (*(nsIDOMWindow**)result) = domWindow;
+
+      return NPERR_NO_ERROR;
+    }
+    return NPERR_GENERIC_ERROR;
+  }
+
+  case NPNVToolkit: {
+#ifdef MOZ_WIDGET_GTK2
+    *((NPNToolkitType*)result) = NPNVGtk2;
+#endif
+
+    if (*(NPNToolkitType*)result)
+        return NPERR_NO_ERROR;
+
+    return NPERR_GENERIC_ERROR;
+  }
+
+  case NPNVSupportsXEmbedBool: {
+#ifdef MOZ_WIDGET_GTK2
+    *(NPBool*)result = PR_TRUE;
+#else
+    *(NPBool*)result = PR_FALSE;
+#endif
+    return NPERR_NO_ERROR;
+  }
+
+  case NPNVWindowNPObject: {
+    *(NPObject **)result = _getwindowobject(npp);
+
+    return NPERR_NO_ERROR;
+  }
+
+  case NPNVPluginElementNPObject: {
+    *(NPObject **)result = _getpluginelement(npp);
+
+    return NPERR_NO_ERROR;
+  }
+
+  case NPNVSupportsWindowless: {
+#if defined(XP_WIN) || defined(XP_MACOSX) || (defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2))
+    *(NPBool*)result = PR_TRUE;
+#else
+    *(NPBool*)result = PR_FALSE;
+#endif
+    return NPERR_NO_ERROR;
+  }
+
+#ifdef XP_MACOSX
+  case NPNVpluginDrawingModel: {
+    if (npp) {
+      nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
+      if (inst) {
+        *(NPDrawingModel*)result = inst->GetDrawingModel();
+        return NPERR_NO_ERROR;
+      }
+    }
+    else {
+      return NPERR_GENERIC_ERROR;
+    }
+  }
+
+#ifndef NP_NO_QUICKDRAW
+  case NPNVsupportsQuickDrawBool: {
+    *(NPBool*)result = PR_TRUE;
+    
+    return NPERR_NO_ERROR;
+  }
+#endif
+
+  case NPNVsupportsCoreGraphicsBool: {
+    *(NPBool*)result = PR_TRUE;
+    
+    return NPERR_NO_ERROR;
+  }
+#endif
+
+  default:
+    return NPERR_GENERIC_ERROR;
+  }
+}
+
+NPError NP_CALLBACK
+_setvalue(NPP npp, NPPVariable variable, void *result)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setvalue called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
+                                     (void*)npp, (int)variable));
+
+  if (!npp)
+    return NPERR_INVALID_INSTANCE_ERROR;
+
+  nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
+
+  NS_ASSERTION(inst != NULL, "null instance");
+
+  if (inst == NULL)
+    return NPERR_INVALID_INSTANCE_ERROR;
+
+  PluginDestructionGuard guard(inst);
+
+  switch (variable) {
+
+    // we should keep backward compatibility with NPAPI where the
+    // actual pointer value is checked rather than its content
+    // when passing booleans
+    case NPPVpluginWindowBool: {
+      NPBool bWindowless = (result == nsnull);
+      return inst->SetWindowless(bWindowless);
+    }
+
+    case NPPVpluginTransparentBool: {
+      NPBool bTransparent = (result != nsnull);
+      return inst->SetTransparent(bTransparent);
+    }
+
+    case NPPVjavascriptPushCallerBool:
+      {
+        nsresult rv;
+        nsCOMPtr<nsIJSContextStack> contextStack =
+          do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
+        if (NS_SUCCEEDED(rv)) {
+          NPBool bPushCaller = (result != nsnull);
+
+          if (bPushCaller) {
+            rv = NS_ERROR_FAILURE;
+
+            nsCOMPtr<nsIPluginInstancePeer> peer;
+            if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
+              nsCOMPtr<nsIPluginInstancePeer2> peer2 =
+                do_QueryInterface(peer);
+
+              if (peer2) {
+                JSContext *cx;
+                rv = peer2->GetJSContext(&cx);
+
+                if (NS_SUCCEEDED(rv))
+                  rv = contextStack->Push(cx);
+              }
+            }
+          } else {
+            rv = contextStack->Pop(nsnull);
+          }
+        }
+        return NS_SUCCEEDED(rv) ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
+      }
+
+    case NPPVpluginKeepLibraryInMemory: {
+      NPBool bCached = (result != nsnull);
+      return inst->SetCached(bCached);
+    }
+
+    case NPPVpluginWantsAllNetworkStreams: {
+      PRBool bWantsAllNetworkStreams = (result != nsnull);
+      return inst->SetWantsAllNetworkStreams(bWantsAllNetworkStreams);
+    }
+
+#ifdef XP_MACOSX
+    case NPPVpluginDrawingModel: {
+      if (inst) {
+        int dModelValue = (int)result;
+        inst->SetDrawingModel((NPDrawingModel)dModelValue);
+        return NPERR_NO_ERROR;
+      }
+      else {
+        return NPERR_GENERIC_ERROR;
+      }
+    }
+#endif
+
+    default:
+      return NPERR_NO_ERROR;
+  }
+}
+
+NPError NP_CALLBACK
+_requestread(NPStream *pstream, NPByteRange *rangeList)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_requestread called from the wrong thread\n"));
+    return NPERR_INVALID_PARAM;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_RequestRead: stream=%p\n",
+                                     (void*)pstream));
+
+#ifdef PLUGIN_LOGGING
+  for(NPByteRange * range = rangeList; range != nsnull; range = range->next)
+    PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY,
+    ("%i-%i", range->offset, range->offset + range->length - 1));
+
+  PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY, ("\n\n"));
+  PR_LogFlush();
+#endif
+
+  if (!pstream || !rangeList || !pstream->ndata)
+    return NPERR_INVALID_PARAM;
+
+  nsNPAPIPluginStreamListener* streamlistener = (nsNPAPIPluginStreamListener*)pstream->ndata;
+
+  nsPluginStreamType streamtype = nsPluginStreamType_Normal;
+
+  streamlistener->GetStreamType(&streamtype);
+
+  if (streamtype != nsPluginStreamType_Seek)
+    return NPERR_STREAM_NOT_SEEKABLE;
+
+  if (streamlistener->mStreamInfo)
+    streamlistener->mStreamInfo->RequestRead((nsByteRange *)rangeList);
+
+  return NS_OK;
+}
+
+// Deprecated, only stubbed out
+void* NP_CALLBACK /* OJI type: JRIEnv* */
+_getJavaEnv(void)
+{
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
+  return NULL;
+}
+
+const char * NP_CALLBACK
+_useragent(NPP npp)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_useragent called from the wrong thread\n"));
+    return nsnull;
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
+
+  nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
+  if (!pm)
+    return nsnull;
+
+  const char *retstr;
+  nsresult rv = pm->UserAgent(&retstr);
+  if (NS_FAILED(rv))
+    return nsnull;
+
+  return retstr;
+}
+
+void * NP_CALLBACK
+_memalloc (uint32_t size)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN_memalloc called from the wrong thread\n"));
+  }
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
+  return nsMemory::Alloc(size);
+}
+
+// Deprecated, only stubbed out
+void* NP_CALLBACK /* OJI type: jref */
+_getJavaPeer(NPP npp)
+{
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
+  return NULL;
+}
+
+void NP_CALLBACK
+_pushpopupsenabledstate(NPP npp, NPBool enabled)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_pushpopupsenabledstate called from the wrong thread\n"));
+    return;
+  }
+  nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
+  if (!inst)
+    return;
+
+  inst->PushPopupsEnabledState(enabled);
+}
+
+void NP_CALLBACK
+_poppopupsenabledstate(NPP npp)
+{
+  if (!NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_poppopupsenabledstate called from the wrong thread\n"));
+    return;
+  }
+  nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
+  if (!inst)
+    return;
+
+  inst->PopPopupsEnabledState();
+}
+
+class nsPluginThreadRunnable : public nsRunnable,
+                               public PRCList
+{
+public:
+  nsPluginThreadRunnable(NPP instance, PluginThreadCallback func,
+                         void *userData);
+  virtual ~nsPluginThreadRunnable();
+
+  NS_IMETHOD Run();
+
+  PRBool IsForInstance(NPP instance)
+  {
+    return (mInstance == instance);
+  }
+
+  void Invalidate()
+  {
+    mFunc = nsnull;
+  }
+
+  PRBool IsValid()
+  {
+    return (mFunc != nsnull);
+  }
+
+private:  
+  NPP mInstance;
+  PluginThreadCallback mFunc;
+  void *mUserData;
+};
+
+nsPluginThreadRunnable::nsPluginThreadRunnable(NPP instance,
+                                               PluginThreadCallback func,
+                                               void *userData)
+  : mInstance(instance), mFunc(func), mUserData(userData)
+{
+  if (!sPluginThreadAsyncCallLock) {
+    // Failed to create lock, not much we can do here then...
+    mFunc = nsnull;
+
+    return;
+  }
+
+  PR_INIT_CLIST(this);
+
+  {
+    nsAutoLock lock(sPluginThreadAsyncCallLock);
+
+    nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
+    if (!inst || !inst->IsStarted()) {
+      // The plugin was stopped, ignore this async call.
+      mFunc = nsnull;
+
+      return;
+    }
+
+    PR_APPEND_LINK(this, &sPendingAsyncCalls);
+  }
+}
+
+nsPluginThreadRunnable::~nsPluginThreadRunnable()
+{
+  if (!sPluginThreadAsyncCallLock) {
+    return;
+  }
+
+  {
+    nsAutoLock lock(sPluginThreadAsyncCallLock);
+
+    PR_REMOVE_LINK(this);
+  }
+}
+
+NS_IMETHODIMP
+nsPluginThreadRunnable::Run()
+{
+  if (mFunc) {
+    PluginDestructionGuard guard(mInstance);
+
+    NS_TRY_SAFE_CALL_VOID(mFunc(mUserData), nsnull, nsnull);
+  }
+
+  return NS_OK;
+}
+
+void NP_CALLBACK
+_pluginthreadasynccall(NPP instance, PluginThreadCallback func, void *userData)
+{
+  if (NS_IsMainThread()) {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from the main thread\n"));
+  } else {
+    NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from a non main thread\n"));
+  }
+  nsRefPtr<nsPluginThreadRunnable> evt =
+    new nsPluginThreadRunnable(instance, func, userData);
+
+  if (evt && evt->IsValid()) {
+    NS_DispatchToMainThread(evt);
+  }
+}
+
+void
+OnPluginDestroy(NPP instance)
+{
+  if (!sPluginThreadAsyncCallLock) {
+    return;
+  }
+
+  {
+    nsAutoLock lock(sPluginThreadAsyncCallLock);
+
+    if (PR_CLIST_IS_EMPTY(&sPendingAsyncCalls)) {
+      return;
+    }
+
+    nsPluginThreadRunnable *r =
+      (nsPluginThreadRunnable *)PR_LIST_HEAD(&sPendingAsyncCalls);
+
+    do {
+      if (r->IsForInstance(instance)) {
+        r->Invalidate();
+      }
+
+      r = (nsPluginThreadRunnable *)PR_NEXT_LINK(r);
+    } while (r != &sPendingAsyncCalls);
+  }
+}
+
+void
+OnShutdown()
+{
+  NS_ASSERTION(PR_CLIST_IS_EMPTY(&sPendingAsyncCalls),
+               "Pending async plugin call list not cleaned up!");
+
+  if (sPluginThreadAsyncCallLock) {
+    nsAutoLock::DestroyLock(sPluginThreadAsyncCallLock);
+
+    sPluginThreadAsyncCallLock = nsnull;
+  }
+}
+
+void
+EnterAsyncPluginThreadCallLock()
+{
+  if (sPluginThreadAsyncCallLock) {
+    PR_Lock(sPluginThreadAsyncCallLock);
+  }
+}
+
+void
+ExitAsyncPluginThreadCallLock()
+{
+  if (sPluginThreadAsyncCallLock) {
+    PR_Unlock(sPluginThreadAsyncCallLock);
+  }
+}
+
+NPP NPPStack::sCurrentNPP = nsnull;
diff -r 8dcf83cc8500 modules/plugin/base/src/nsNPAPIPlugin.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/base/src/nsNPAPIPlugin.h	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,267 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsNPAPIPlugin_h_
+#define nsNPAPIPlugin_h_
+
+#include "nsIFactory.h"
+#include "nsIPlugin.h"
+#include "nsIPluginInstancePeer.h"
+#include "nsIWindowlessPlugInstPeer.h"
+#include "prlink.h"
+#include "npupp.h"
+#include "nsPluginHostImpl.h"
+
+/*
+ * Use this macro before each exported function
+ * (between the return address and the function
+ * itself), to ensure that the function has the
+ * right calling conventions on Win16.
+ */
+// XXX NP_CALLBACK should be the same as NP_LOADDS in npapi.h which differs
+// for WIN16 and maybe WIN64?
+#ifdef XP_OS2
+#define NP_CALLBACK _System
+#else
+#define NP_CALLBACK
+#endif
+#if defined(XP_WIN)
+#define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
+#elif defined(XP_OS2)
+#define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (_System * _name)
+#else
+#define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (* _name)
+#endif
+
+typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_GETENTRYPOINTS) (NPPluginFuncs* pCallbacks);
+typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGININIT) (const NPNetscapeFuncs* pCallbacks);
+typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINUNIXINIT) (const NPNetscapeFuncs* pCallbacks,NPPluginFuncs* fCallbacks);
+typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINSHUTDOWN) (void);
+#ifdef XP_MACOSX
+typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_MAIN) (NPNetscapeFuncs* nCallbacks, NPPluginFuncs* pCallbacks, NPP_ShutdownUPP* unloadUpp);
+#endif
+
+class nsNPAPIPlugin : public nsIPlugin
+{
+public:
+  nsNPAPIPlugin(NPPluginFuncs* callbacks, PRLibrary* aLibrary,
+                NP_PLUGINSHUTDOWN aShutdown);
+  virtual ~nsNPAPIPlugin(void);
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIFACTORY
+  NS_DECL_NSIPLUGIN
+
+  // Constructs and initializes an nsNPAPIPlugin object
+  static nsresult CreatePlugin(const char* aFileName,
+                               const char* aFullPath,
+                               PRLibrary* aLibrary,
+                               nsIPlugin** aResult);
+#ifdef XP_MACOSX
+  void SetPluginRefNum(short aRefNum);
+#endif
+
+protected:
+  // Ensures that the static CALLBACKS is properly initialized
+  static void CheckClassInitialized(void);
+
+#ifdef XP_MACOSX
+  short fPluginRefNum;
+#endif
+
+  // The plugin-side callbacks that the browser calls. One set of
+  // plugin callbacks for each plugin.
+  NPPluginFuncs fCallbacks;
+  PRLibrary*    fLibrary;
+
+  NP_PLUGINSHUTDOWN fShutdownEntry;
+
+  // The browser-side callbacks that a 4.x-style plugin calls.
+  static NPNetscapeFuncs CALLBACKS;
+};
+
+
+PR_BEGIN_EXTERN_C
+NPObject* NP_CALLBACK
+_getwindowobject(NPP npp);
+
+NPObject* NP_CALLBACK
+_getpluginelement(NPP npp);
+
+NPIdentifier NP_CALLBACK
+_getstringidentifier(const NPUTF8* name);
+
+void NP_CALLBACK
+_getstringidentifiers(const NPUTF8** names, int32_t nameCount,
+                      NPIdentifier *identifiers);
+
+bool NP_CALLBACK
+_identifierisstring(NPIdentifier identifiers);
+
+NPIdentifier NP_CALLBACK
+_getintidentifier(int32_t intid);
+
+NPUTF8* NP_CALLBACK
+_utf8fromidentifier(NPIdentifier identifier);
+
+int32_t NP_CALLBACK
+_intfromidentifier(NPIdentifier identifier);
+
+NPObject* NP_CALLBACK
+_createobject(NPP npp, NPClass* aClass);
+
+NPObject* NP_CALLBACK
+_retainobject(NPObject* npobj);
+
+void NP_CALLBACK
+_releaseobject(NPObject* npobj);
+
+bool NP_CALLBACK
+_invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
+        uint32_t argCount, NPVariant *result);
+
+bool NP_CALLBACK
+_invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
+               uint32_t argCount, NPVariant *result);
+
+bool NP_CALLBACK
+_evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result);
+
+bool NP_CALLBACK
+_getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
+             NPVariant *result);
+
+bool NP_CALLBACK
+_setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
+             const NPVariant *value);
+
+bool NP_CALLBACK
+_removeproperty(NPP npp, NPObject* npobj, NPIdentifier property);
+
+bool NP_CALLBACK
+_hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
+
+bool NP_CALLBACK
+_hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName);
+
+bool NP_CALLBACK
+_enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
+           uint32_t *count);
+
+bool NP_CALLBACK
+_construct(NPP npp, NPObject* npobj, const NPVariant *args,
+           uint32_t argCount, NPVariant *result);
+
+void NP_CALLBACK
+_releasevariantvalue(NPVariant *variant);
+
+void NP_CALLBACK
+_setexception(NPObject* npobj, const NPUTF8 *message);
+
+PR_END_EXTERN_C
+
+const char *
+PeekException();
+
+void
+PopException();
+
+void
+OnPluginDestroy(NPP instance);
+
+void
+OnShutdown();
+
+void
+EnterAsyncPluginThreadCallLock();
+void
+ExitAsyncPluginThreadCallLock();
+
+class NPPStack
+{
+public:
+  static NPP Peek()
+  {
+    return sCurrentNPP;
+  }
+
+protected:
+  static NPP sCurrentNPP;
+};
+
+// XXXjst: The NPPAutoPusher stack is a bit redundant now that
+// PluginDestructionGuard exists, and could thus be replaced by code
+// that uses the PluginDestructionGuard list of plugins on the
+// stack. But they're not identical, and to minimize code changes
+// we're keeping both for the moment, and making NPPAutoPusher inherit
+// the PluginDestructionGuard class to avoid having to keep two
+// separate objects on the stack since we always want a
+// PluginDestructionGuard where we use an NPPAutoPusher.
+
+class NPPAutoPusher : public NPPStack,
+                      protected PluginDestructionGuard
+{
+public:
+  NPPAutoPusher(NPP npp)
+    : PluginDestructionGuard(npp),
+      mOldNPP(sCurrentNPP)
+  {
+    NS_ASSERTION(npp, "Uh, null npp passed to NPPAutoPusher!");
+
+    sCurrentNPP = npp;
+  }
+
+  ~NPPAutoPusher()
+  {
+    sCurrentNPP = mOldNPP;
+  }
+
+private:
+  NPP mOldNPP;
+};
+
+class NPPExceptionAutoHolder
+{
+public:
+  NPPExceptionAutoHolder();
+  ~NPPExceptionAutoHolder();
+
+protected:
+  char *mOldException;
+};
+
+#endif // nsNPAPIPlugin_h_
diff -r 8dcf83cc8500 modules/plugin/base/src/nsNPAPIPluginInstance.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/base/src/nsNPAPIPluginInstance.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,1549 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Copperfield <timecop@network.email.ne.jp>
+ *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "prlog.h"
+#include "prmem.h"
+#include "nscore.h"
+#include "prenv.h"
+
+#include "nsNPAPIPluginInstance.h"
+#include "nsNPAPIPlugin.h"
+#include "nsNPAPIPluginStreamListener.h"
+#include "nsPluginHostImpl.h"
+#include "nsPluginSafety.h"
+#include "nsPluginLogging.h"
+
+#include "nsPIPluginInstancePeer.h"
+#include "nsPIDOMWindow.h"
+#include "nsIDocument.h"
+
+#include "nsJSNPRuntime.h"
+
+#ifdef XP_OS2
+#include "nsILegacyPluginWrapperOS2.h"
+#endif
+
+static NS_DEFINE_IID(kCPluginManagerCID, NS_PLUGINMANAGER_CID); // needed for NS_TRY_SAFE_CALL
+static NS_DEFINE_IID(kIPluginStreamListenerIID, NS_IPLUGINSTREAMLISTENER_IID);
+
+// nsNPAPIPluginStreamListener Methods
+
+NS_IMPL_ISUPPORTS3(nsNPAPIPluginStreamListener, nsIPluginStreamListener,
+                   nsITimerCallback, nsIHTTPHeaderListener)
+
+nsNPAPIPluginStreamListener::nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst, 
+                                                         void* notifyData,
+                                                         const char* aURL)
+  : mNotifyData(notifyData),
+    mStreamBuffer(nsnull),
+    mNotifyURL(aURL ? PL_strdup(aURL) : nsnull),
+    mInst(inst),
+    mStreamBufferSize(0),
+    mStreamBufferByteCount(0),
+    mStreamType(nsPluginStreamType_Normal),
+    mStreamStarted(PR_FALSE),
+    mStreamCleanedUp(PR_FALSE),
+    mCallNotify(PR_FALSE),
+    mIsSuspended(PR_FALSE),
+    mIsPluginInitJSStream(mInst->mInPluginInitCall &&
+                          aURL && strncmp(aURL, "javascript:",
+                                          sizeof("javascript:") - 1) == 0),
+    mResponseHeaderBuf(nsnull)
+{
+  // Initialize the 4.x interface structure
+  memset(&mNPStream, 0, sizeof(mNPStream));
+
+  NS_IF_ADDREF(mInst);
+}
+
+nsNPAPIPluginStreamListener::~nsNPAPIPluginStreamListener(void)
+{
+  // remove itself from the instance stream list
+  nsNPAPIPluginInstance *inst = mInst;
+  if (inst) {
+    nsInstanceStream * prev = nsnull;
+    for (nsInstanceStream *is = inst->mStreams; is != nsnull; is = is->mNext) {
+      if (is->mPluginStreamListener == this) {
+        if (!prev)
+          inst->mStreams = is->mNext;
+        else
+          prev->mNext = is->mNext;
+
+        delete is;
+        break;
+      }
+      prev = is;
+    }
+  }
+
+  // For those cases when NewStream is never called, we still may need
+  // to fire a notification callback. Return network error as fallback
+  // reason because for other cases, notify should have already been
+  // called for other reasons elsewhere.
+  CallURLNotify(NPRES_NETWORK_ERR);
+
+  // lets get rid of the buffer
+  if (mStreamBuffer) {
+    PR_Free(mStreamBuffer);
+    mStreamBuffer=nsnull;
+  }
+
+  NS_IF_RELEASE(inst);
+
+  if (mNotifyURL)
+    PL_strfree(mNotifyURL);
+
+  if (mResponseHeaderBuf)
+    PL_strfree(mResponseHeaderBuf);
+}
+
+nsresult nsNPAPIPluginStreamListener::CleanUpStream(NPReason reason)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+
+  if (mStreamCleanedUp)
+    return NS_OK;
+
+  if (!mInst || !mInst->IsStarted())
+    return rv;
+
+  PluginDestructionGuard guard(mInst);
+
+  const NPPluginFuncs *callbacks = nsnull;
+  mInst->GetCallbacks(&callbacks);
+  if (!callbacks)
+    return rv;
+
+  NPP npp;
+  mInst->GetNPP(&npp);
+
+  if (mStreamStarted && callbacks->destroystream) {
+    PRLibrary* lib = nsnull;
+    lib = mInst->fLibrary;
+    NPError error;
+    NS_TRY_SAFE_CALL_RETURN(error, CallNPP_DestroyStreamProc(callbacks->destroystream,
+                                                               npp,
+                                                               &mNPStream,
+                                                               reason), lib, mInst);
+
+    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+    ("NPP DestroyStream called: this=%p, npp=%p, reason=%d, return=%d, url=%s\n",
+    this, npp, reason, error, mNPStream.url));
+
+    if (error == NPERR_NO_ERROR)
+      rv = NS_OK;
+  }
+
+  mStreamCleanedUp = PR_TRUE;
+  mStreamStarted   = PR_FALSE;
+
+  StopDataPump();
+
+  // fire notification back to plugin, just like before
+  CallURLNotify(reason);
+
+  return rv;
+}
+
+void nsNPAPIPluginStreamListener::CallURLNotify(NPReason reason)
+{
+  if (!mCallNotify || !mInst || !mInst->IsStarted())
+    return;
+
+  PluginDestructionGuard guard(mInst);
+
+  mCallNotify = PR_FALSE; // only do this ONCE and prevent recursion
+
+  const NPPluginFuncs *callbacks = nsnull;
+  mInst->GetCallbacks(&callbacks);
+  if (!callbacks)
+    return;
+  
+  if (callbacks->urlnotify) {
+
+    NPP npp;
+    mInst->GetNPP(&npp);
+
+    NS_TRY_SAFE_CALL_VOID(CallNPP_URLNotifyProc(callbacks->urlnotify,
+                                                npp,
+                                                mNotifyURL,
+                                                reason,
+                                                mNotifyData), mInst->fLibrary, mInst);
+
+    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+    ("NPP URLNotify called: this=%p, npp=%p, notify=%p, reason=%d, url=%s\n",
+    this, npp, mNotifyData, reason, mNotifyURL));
+  }
+}
+
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::OnStartBinding(nsIPluginStreamInfo* pluginInfo)
+{
+  if (!mInst)
+    return NS_ERROR_FAILURE;
+
+  PluginDestructionGuard guard(mInst);
+
+  NPP npp;
+  const NPPluginFuncs *callbacks = nsnull;
+
+  mInst->GetCallbacks(&callbacks);
+  mInst->GetNPP(&npp);
+
+  if (!callbacks || !mInst->IsStarted())
+    return NS_ERROR_FAILURE;
+
+  PRBool seekable;
+  nsMIMEType contentType;
+  PRUint16 streamType = NP_NORMAL;
+  NPError error;
+
+  mNPStream.ndata = (void*) this;
+  pluginInfo->GetURL(&mNPStream.url);
+  mNPStream.notifyData = mNotifyData;
+
+  pluginInfo->GetLength((PRUint32*)&(mNPStream.end));
+  pluginInfo->GetLastModified((PRUint32*)&(mNPStream.lastmodified));
+  pluginInfo->IsSeekable(&seekable);
+  pluginInfo->GetContentType(&contentType);
+  
+  if (!mResponseHeaders.IsEmpty()) {
+    mResponseHeaderBuf = PL_strdup(mResponseHeaders.get());
+    mNPStream.headers = mResponseHeaderBuf;
+  }
+
+  mStreamInfo = pluginInfo;
+
+  NS_TRY_SAFE_CALL_RETURN(error, CallNPP_NewStreamProc(callbacks->newstream,
+                                                       npp,
+                                                       (char *)contentType,
+                                                       &mNPStream,
+                                                       seekable,
+                                                       &streamType), mInst->fLibrary, mInst);
+
+  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("NPP NewStream called: this=%p, npp=%p, mime=%s, seek=%d, type=%d, return=%d, url=%s\n",
+  this, npp, (char *)contentType, seekable, streamType, error, mNPStream.url));
+
+  if (error != NPERR_NO_ERROR)
+    return NS_ERROR_FAILURE;
+
+  switch(streamType)
+  {
+    case NP_NORMAL:
+      mStreamType = nsPluginStreamType_Normal; 
+      break;
+    case NP_ASFILEONLY:
+      mStreamType = nsPluginStreamType_AsFileOnly; 
+      break;
+    case NP_ASFILE:
+      mStreamType = nsPluginStreamType_AsFile; 
+      break;
+    case NP_SEEK:
+      mStreamType = nsPluginStreamType_Seek; 
+      break;
+    default:
+      return NS_ERROR_FAILURE;
+  }
+
+  mStreamStarted = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsNPAPIPluginStreamListener::SuspendRequest()
+{
+  NS_ASSERTION(!mIsSuspended,
+               "Suspending a request that's already suspended!");
+
+  nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
+    do_QueryInterface(mStreamInfo);
+  nsIRequest *request;
+
+  if (!pluginInfoNPAPI || !(request = pluginInfoNPAPI->GetRequest())) {
+    NS_ERROR("Trying to suspend a non-suspendable stream!");
+
+    return NS_ERROR_FAILURE;
+  }
+
+  nsresult rv = StartDataPump();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mIsSuspended = PR_TRUE;
+
+  return request->Suspend();
+}
+
+void
+nsNPAPIPluginStreamListener::ResumeRequest()
+{
+  nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
+    do_QueryInterface(mStreamInfo);
+
+  nsIRequest *request = pluginInfoNPAPI->GetRequest();
+
+  // request can be null if the network stream is done.
+  if (request) {
+    request->Resume();
+  }
+
+  mIsSuspended = PR_FALSE;
+}
+
+nsresult
+nsNPAPIPluginStreamListener::StartDataPump()
+{
+  nsresult rv;
+  mDataPumpTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Start pumping data to the plugin every 100ms until it obeys and
+  // eats the data.
+  return mDataPumpTimer->InitWithCallback(this, 100,
+                                          nsITimer::TYPE_REPEATING_SLACK);
+}
+
+void
+nsNPAPIPluginStreamListener::StopDataPump()
+{
+  if (mDataPumpTimer) {
+    mDataPumpTimer->Cancel();
+
+    mDataPumpTimer = nsnull;
+  }
+}
+
+// Return true if a javascript: load that was started while the plugin
+// was being initialized is still in progress.
+PRBool
+nsNPAPIPluginStreamListener::PluginInitJSLoadInProgress()
+{
+  for (nsInstanceStream *is = mInst->mStreams; is; is = is->mNext) {
+    if (is->mPluginStreamListener->mIsPluginInitJSStream) {
+      return PR_TRUE;
+    }
+  }
+
+  return PR_FALSE;
+}
+
+// This method is called when there's more data available off the
+// network, but it's also called from our data pump when we're feeding
+// the plugin data that we already got off the network, but the plugin
+// was unable to consume it at the point it arrived. In the case when
+// the plugin pump calls this method, the input argument will be null,
+// and the length will be the number of bytes available in our
+// internal buffer.
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,
+                                          nsIInputStream* input,
+                                          PRUint32 length)
+{
+  if (!mInst || !mInst->IsStarted())
+    return NS_ERROR_FAILURE;
+
+  PluginDestructionGuard guard(mInst);
+
+  // Just in case the caller switches plugin info on us.
+  mStreamInfo = pluginInfo;
+
+  const NPPluginFuncs *callbacks = nsnull;
+  mInst->GetCallbacks(&callbacks);
+  // check out if plugin implements NPP_Write call
+  if (!callbacks || !callbacks->write || !length)
+    return NS_ERROR_FAILURE; // it'll cancel necko transaction 
+  
+  if (!mStreamBuffer) {
+    // To optimize the mem usage & performance we have to allocate
+    // mStreamBuffer here in first ODA when length of data available
+    // in input stream is known.  mStreamBuffer will be freed in DTOR.
+    // we also have to remember the size of that buff to make safe
+    // consecutive Read() calls form input stream into our buff.
+
+    PRUint32 contentLength;
+    pluginInfo->GetLength(&contentLength);
+
+    mStreamBufferSize = PR_MAX(length, contentLength);
+
+    // Limit the size of the initial buffer to MAX_PLUGIN_NECKO_BUFFER
+    // (16k). This buffer will grow if needed, as in the case where
+    // we're getting data faster than the plugin can process it.
+    mStreamBufferSize = PR_MIN(mStreamBufferSize, MAX_PLUGIN_NECKO_BUFFER);
+
+    mStreamBuffer = (char*) PR_Malloc(mStreamBufferSize);
+    if (!mStreamBuffer)
+      return NS_ERROR_OUT_OF_MEMORY;
+  }
+  
+  // prepare NPP_ calls params
+  NPP npp;
+  mInst->GetNPP(&npp);
+
+  PRInt32 streamPosition;
+  pluginInfo->GetStreamOffset(&streamPosition);
+  PRInt32 streamOffset = streamPosition;
+
+  if (input) {
+    streamOffset += length;
+
+    // Set new stream offset for the next ODA call regardless of how
+    // following NPP_Write call will behave we pretend to consume all
+    // data from the input stream.  It's possible that current steam
+    // position will be overwritten from NPP_RangeRequest call made
+    // from NPP_Write, so we cannot call SetStreamOffset after
+    // NPP_Write.
+    //
+    // Note: there is a special case when data flow should be
+    // temporarily stopped if NPP_WriteReady returns 0 (bug #89270)
+    pluginInfo->SetStreamOffset(streamOffset);
+
+    // set new end in case the content is compressed
+    // initial end is less than end of decompressed stream
+    // and some plugins (e.g. acrobat) can fail. 
+    if ((PRInt32)mNPStream.end < streamOffset)
+      mNPStream.end = streamOffset;
+  }
+
+  nsresult rv = NS_OK;
+  while (NS_SUCCEEDED(rv) && length > 0) {
+    if (input && length) {
+      if (mStreamBufferSize < mStreamBufferByteCount + length &&
+          mIsSuspended) {
+        // We're in the ::OnDataAvailable() call that we might get
+        // after suspending a request, or we suspended the request
+        // from within this ::OnDataAvailable() call while there's
+        // still data in the input, and we don't have enough space to
+        // store what we got off the network. Reallocate our internal
+        // buffer.
+        mStreamBufferSize = mStreamBufferByteCount + length;
+        char *buf = (char *)PR_Realloc(mStreamBuffer, mStreamBufferSize);
+        if (!buf)
+          return NS_ERROR_OUT_OF_MEMORY;
+
+        mStreamBuffer = buf;
+      }
+
+      PRUint32 bytesToRead =
+        PR_MIN(length, mStreamBufferSize - mStreamBufferByteCount);
+
+      PRUint32 amountRead = 0;
+      rv = input->Read(mStreamBuffer + mStreamBufferByteCount, bytesToRead,
+                       &amountRead);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (amountRead == 0) {
+        NS_NOTREACHED("input->Read() returns no data, it's almost impossible "
+                      "to get here");
+
+        break;
+      }
+
+      mStreamBufferByteCount += amountRead;
+      length -= amountRead;
+    } else {
+      // No input, nothing to read. Set length to 0 so that we don't
+      // keep iterating through this outer loop any more.
+
+      length = 0;
+    }
+
+    // Temporary pointer to the beginning of the data we're writing as
+    // we loop and feed the plugin data.
+    char *ptrStreamBuffer = mStreamBuffer;
+
+    // it is possible plugin's NPP_Write() returns 0 byte consumed. We
+    // use zeroBytesWriteCount to count situation like this and break
+    // the loop
+    PRInt32 zeroBytesWriteCount = 0;
+
+    // mStreamBufferByteCount tells us how many bytes there are in the
+    // buffer. WriteReady returns to us how many bytes the plugin is
+    // ready to handle.
+    while (mStreamBufferByteCount > 0) {
+      PRInt32 numtowrite;
+      if (callbacks->writeready) {
+        NS_TRY_SAFE_CALL_RETURN(numtowrite, 
+                                CallNPP_WriteReadyProc(callbacks->writeready,
+                                                       npp, &mNPStream),
+                                mInst->fLibrary, mInst);
+
+        NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                       ("NPP WriteReady called: this=%p, npp=%p, "
+                        "return(towrite)=%d, url=%s\n",
+                        this, npp, numtowrite, mNPStream.url));
+
+        if (!mStreamStarted) {
+          // The plugin called NPN_DestroyStream() from within
+          // NPP_WriteReady(), kill the stream.
+
+          return NS_BINDING_ABORTED;
+        }
+
+        // if WriteReady returned 0, the plugin is not ready to handle
+        // the data, suspend the stream (if it isn't already
+        // suspended).
+        //
+        // Also suspend the stream if the stream we're loading is not
+        // a javascript: URL load that was initiated during plugin
+        // initialization and there currently is such a stream
+        // loading. This is done to work around a Windows Media Player
+        // plugin bug where it can't deal with being fed data for
+        // other streams while it's waiting for data from the
+        // javascript: URL loads it requests during
+        // initialization. See bug 386493 for more details.
+
+        if (numtowrite <= 0 ||
+            (!mIsPluginInitJSStream && PluginInitJSLoadInProgress())) {
+          if (!mIsSuspended) {
+            rv = SuspendRequest();
+          }
+
+          // Break out of the inner loop, but keep going through the
+          // outer loop in case there's more data to read from the
+          // input stream.
+
+          break;
+        }
+
+        numtowrite = PR_MIN(numtowrite, mStreamBufferByteCount);
+      } else {
+        // if WriteReady is not supported by the plugin, just write
+        // the whole buffer
+        numtowrite = mStreamBufferByteCount;
+      }
+
+      PRInt32 writeCount = 0; // bytes consumed by plugin instance
+      NS_TRY_SAFE_CALL_RETURN(writeCount, 
+                              CallNPP_WriteProc(callbacks->write, npp,
+                                                &mNPStream, streamPosition,
+                                                numtowrite,
+                                                ptrStreamBuffer),
+                              mInst->fLibrary, mInst);
+
+      NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                     ("NPP Write called: this=%p, npp=%p, pos=%d, len=%d, "
+                      "buf=%s, return(written)=%d,  url=%s\n",
+                      this, npp, streamPosition, numtowrite,
+                      ptrStreamBuffer, writeCount, mNPStream.url));
+
+      if (!mStreamStarted) {
+        // The plugin called NPN_DestroyStream() from within
+        // NPP_Write(), kill the stream.
+
+        return NS_BINDING_ABORTED;
+      }
+
+      if (writeCount > 0) {
+        NS_ASSERTION(writeCount <= mStreamBufferByteCount,
+                     "Plugin read past the end of the available data!");
+
+        writeCount = PR_MIN(writeCount, mStreamBufferByteCount);
+        mStreamBufferByteCount -= writeCount;
+
+        streamPosition += writeCount;
+
+        zeroBytesWriteCount = 0;
+
+        if (mStreamBufferByteCount > 0) {
+          // This alignment code is most likely bogus, but we'll leave
+          // it in for now in case it matters for some plugins on some
+          // architectures. Who knows...
+          if (writeCount % sizeof(PRWord)) {
+            // memmove will take care  about alignment 
+            memmove(mStreamBuffer, ptrStreamBuffer + writeCount,
+                    mStreamBufferByteCount);
+            ptrStreamBuffer = mStreamBuffer;
+          } else {
+            // if aligned we can use ptrStreamBuffer += to eliminate
+            // memmove()
+            ptrStreamBuffer += writeCount;
+          }
+        }
+      } else if (writeCount == 0) {
+        // if NPP_Write() returns writeCount == 0 lets say 3 times in
+        // a row, suspend the request and continue feeding the plugin
+        // the data we got so far. Once that data is consumed, we'll
+        // resume the request.
+        if (mIsSuspended || ++zeroBytesWriteCount == 3) {
+          if (!mIsSuspended) {
+            rv = SuspendRequest();
+          }
+
+          // Break out of the for loop, but keep going through the
+          // while loop in case there's more data to read from the
+          // input stream.
+
+          break;
+        }
+      } else {
+        // Something's really wrong, kill the stream.
+        rv = NS_ERROR_FAILURE;
+
+        break;
+      }  
+    } // end of inner while loop
+
+    if (mStreamBufferByteCount && mStreamBuffer != ptrStreamBuffer) {
+      memmove(mStreamBuffer, ptrStreamBuffer, mStreamBufferByteCount);
+    }
+  }
+
+  if (streamPosition != streamOffset) {
+    // The plugin didn't consume all available data, or consumed some
+    // of our cached data while we're pumping cached data. Adjust the
+    // plugin info's stream offset to match reality, except if the
+    // plugin info's stream offset was set by a re-entering
+    // NPN_RequestRead() call.
+
+    PRInt32 postWriteStreamPosition;
+    pluginInfo->GetStreamOffset(&postWriteStreamPosition);
+
+    if (postWriteStreamPosition == streamOffset) {
+      pluginInfo->SetStreamOffset(streamPosition);
+    }
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::OnFileAvailable(nsIPluginStreamInfo* pluginInfo, 
+                                             const char* fileName)
+{
+  if (!mInst || !mInst->IsStarted())
+    return NS_ERROR_FAILURE;
+
+  PluginDestructionGuard guard(mInst);
+
+  const NPPluginFuncs *callbacks = nsnull;
+  mInst->GetCallbacks(&callbacks);
+  if (!callbacks || !callbacks->asfile)
+    return NS_ERROR_FAILURE;
+  
+  NPP npp;
+  mInst->GetNPP(&npp);
+
+  PRLibrary* lib = nsnull;
+  lib = mInst->fLibrary;
+
+  NS_TRY_SAFE_CALL_VOID(CallNPP_StreamAsFileProc(callbacks->asfile,
+                                                   npp,
+                                                   &mNPStream,
+                                                   fileName), lib, mInst);
+
+  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("NPP StreamAsFile called: this=%p, npp=%p, url=%s, file=%s\n",
+  this, npp, mNPStream.url, fileName));
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::OnStopBinding(nsIPluginStreamInfo* pluginInfo, 
+                                        nsresult status)
+{
+  StopDataPump();
+
+  if (NS_FAILED(status)) {
+    // The stream was destroyed, or died for some reason. Make sure we
+    // cancel the underlying request.
+    nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
+      do_QueryInterface(mStreamInfo);
+
+    nsIRequest *request;
+    if (pluginInfoNPAPI && (request = pluginInfoNPAPI->GetRequest())) {
+      request->Cancel(status);
+    }
+  }
+
+  if (!mInst || !mInst->IsStarted())
+    return NS_ERROR_FAILURE;
+
+  // check if the stream is of seekable type and later its destruction
+  // see bug 91140    
+  nsresult rv = NS_OK;
+  if (mStreamType != nsPluginStreamType_Seek) {
+    NPReason reason = NPRES_DONE;
+
+    if (NS_FAILED(status))
+      reason = NPRES_NETWORK_ERR;   // since the stream failed, we need to tell the plugin that
+
+    rv = CleanUpStream(reason);
+  }
+
+  if (rv != NPERR_NO_ERROR)
+    return NS_ERROR_FAILURE;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::GetStreamType(nsPluginStreamType *result)
+{
+  *result = mStreamType;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::Notify(nsITimer *aTimer)
+{
+  NS_ASSERTION(aTimer == mDataPumpTimer, "Uh, wrong timer?");
+
+  PRInt32 oldStreamBufferByteCount = mStreamBufferByteCount;
+
+  nsresult rv = OnDataAvailable(mStreamInfo, nsnull, mStreamBufferByteCount);
+
+  if (NS_FAILED(rv)) {
+    // We ran into an error, no need to keep firing this timer then.
+
+    aTimer->Cancel();
+
+    return NS_OK;
+  }
+
+  if (mStreamBufferByteCount != oldStreamBufferByteCount &&
+      ((mStreamStarted && mStreamBufferByteCount < 1024) ||
+       mStreamBufferByteCount == 0)) {
+    // The plugin read some data and we've got less than 1024 bytes in
+    // our buffer (or its empty and the stream is already
+    // done). Resume the request so that we get more data off the
+    // network.
+
+    ResumeRequest();
+
+    // Necko will pump data now that we've resumed the request.
+    StopDataPump();
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::StatusLine(const char* line)
+{
+  mResponseHeaders.Append(line);
+  mResponseHeaders.Append('\n');
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNPAPIPluginStreamListener::NewResponseHeader(const char* headerName,
+                                            const char* headerValue)
+{
+  mResponseHeaders.Append(headerName);
+  mResponseHeaders.Append(": ");
+  mResponseHeaders.Append(headerValue);
+  mResponseHeaders.Append('\n');
+  return NS_OK;
+}
+
+nsInstanceStream::nsInstanceStream()
+{
+  mNext = nsnull;
+  mPluginStreamListener = nsnull;
+}
+
+nsInstanceStream::~nsInstanceStream()
+{
+}
+
+NS_IMPL_ISUPPORTS3(nsNPAPIPluginInstance, nsIPluginInstance, nsIScriptablePlugin,
+                   nsIPluginInstanceInternal)
+
+nsNPAPIPluginInstance::nsNPAPIPluginInstance(NPPluginFuncs* callbacks,
+                                       PRLibrary* aLibrary)
+  : fCallbacks(callbacks),
+#ifdef XP_MACOSX
+#ifdef NP_NO_QUICKDRAW
+    mDrawingModel(NPDrawingModelCoreGraphics),
+#else
+    mDrawingModel(NPDrawingModelQuickDraw),
+#endif
+#endif
+    mWindowless(PR_FALSE),
+    mTransparent(PR_FALSE),
+    mStarted(PR_FALSE),
+    mCached(PR_FALSE),
+    mIsJavaPlugin(PR_FALSE),
+    mWantsAllNetworkStreams(PR_FALSE),
+    mInPluginInitCall(PR_FALSE),
+    fLibrary(aLibrary),
+    mStreams(nsnull)
+{
+  NS_ASSERTION(fCallbacks != NULL, "null callbacks");
+
+  // Initialize the NPP structure.
+
+  fNPP.pdata = NULL;
+  fNPP.ndata = this;
+
+  PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance ctor: this=%p\n",this));
+}
+
+nsNPAPIPluginInstance::~nsNPAPIPluginInstance(void)
+{
+  PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance dtor: this=%p\n",this));
+
+  // clean the stream list if any
+  for (nsInstanceStream *is = mStreams; is != nsnull;) {
+    nsInstanceStream * next = is->mNext;
+    delete is;
+    is = next;
+  }
+}
+
+PRBool
+nsNPAPIPluginInstance::IsStarted(void)
+{
+  return mStarted;
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::Initialize(nsIPluginInstancePeer* peer)
+{
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Initialize this=%p\n",this));
+
+  return InitializePlugin(peer);
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::GetPeer(nsIPluginInstancePeer* *resultingPeer)
+{
+  *resultingPeer = mPeer;
+  NS_IF_ADDREF(*resultingPeer);
+  
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::Start(void)
+{
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Start this=%p\n",this));
+
+  if (mStarted)
+    return NS_OK;
+
+  return InitializePlugin(mPeer); 
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::Stop(void)
+{
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Stop this=%p\n",this));
+
+  NPError error;
+
+  // Make sure the plugin didn't leave popups enabled.
+  if (mPopupStates.Count() > 0) {
+    nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
+
+    if (window) {
+      window->PopPopupControlState(openAbused);
+    }
+  }
+
+  if (!mStarted)
+    return NS_OK;
+
+  // If there's code from this plugin instance on the stack, delay the
+  // destroy.
+  if (PluginDestructionGuard::DelayDestroy(this)) {
+    return NS_OK;
+  }
+
+  // Make sure we lock while we're writing to mStarted after we've
+  // started as other threads might be checking that inside a lock.
+  EnterAsyncPluginThreadCallLock();
+  mStarted = PR_FALSE;
+  ExitAsyncPluginThreadCallLock();
+
+  OnPluginDestroy(&fNPP);
+
+  if (fCallbacks->destroy == NULL)
+    return NS_ERROR_FAILURE; // XXX right error?
+
+  NPSavedData *sdata = 0;
+
+  // clean up open streams
+  for (nsInstanceStream *is = mStreams; is != nsnull;) {
+    nsNPAPIPluginStreamListener * listener = is->mPluginStreamListener;
+
+    nsInstanceStream *next = is->mNext;
+    delete is;
+    is = next;
+    mStreams = is;
+
+    // Clean up our stream after removing it from the list because 
+    // it may be released and destroyed at this point.
+    if (listener)
+      listener->CleanUpStream(NPRES_USER_BREAK);
+  }
+
+  NS_TRY_SAFE_CALL_RETURN(error, CallNPP_DestroyProc(fCallbacks->destroy, &fNPP, &sdata), fLibrary, this);
+
+  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("NPP Destroy called: this=%p, npp=%p, return=%d\n", this, &fNPP, error));
+
+  nsJSNPRuntime::OnPluginDestroy(&fNPP);
+
+  if (error != NPERR_NO_ERROR)
+    return NS_ERROR_FAILURE;
+  else
+    return NS_OK;
+}
+
+already_AddRefed<nsPIDOMWindow>
+nsNPAPIPluginInstance::GetDOMWindow()
+{
+  nsCOMPtr<nsPIPluginInstancePeer> pp (do_QueryInterface(mPeer));
+  if (!pp) {
+    return nsnull;
+  }
+
+  nsCOMPtr<nsIPluginInstanceOwner> owner;
+  pp->GetOwner(getter_AddRefs(owner));
+
+  if (!owner) {
+    return nsnull;
+  }
+
+  nsCOMPtr<nsIDocument> doc;
+  owner->GetDocument(getter_AddRefs(doc));
+
+  if (!doc) {
+    return nsnull;
+  }
+
+  nsPIDOMWindow *window = doc->GetWindow();
+  NS_IF_ADDREF(window);
+
+  return window;
+}
+
+nsresult nsNPAPIPluginInstance::InitializePlugin(nsIPluginInstancePeer* peer)
+{
+  NS_ENSURE_ARG_POINTER(peer);
+ 
+  nsCOMPtr<nsIPluginTagInfo2> taginfo = do_QueryInterface(peer);
+  NS_ENSURE_TRUE(taginfo, NS_ERROR_NO_INTERFACE);
+  
+  PluginDestructionGuard guard(this);
+
+  PRUint16 count = 0;
+  const char* const* names = nsnull;
+  const char* const* values = nsnull;
+  nsPluginTagType tagtype;
+  nsresult rv = taginfo->GetTagType(&tagtype);
+  if (NS_SUCCEEDED(rv)) {
+    // Note: If we failed to get the tag type, we may be a full page plugin, so no arguments
+    rv = taginfo->GetAttributes(count, names, values);
+    NS_ENSURE_SUCCESS(rv, rv);
+    
+    // nsPluginTagType_Object or Applet may also have PARAM tags
+    // Note: The arrays handed back by GetParameters() are
+    // crafted specially to be directly behind the arrays from GetAttributes()
+    // with a null entry as a separator. This is for 4.x backwards compatibility!
+    // see bug 111008 for details
+    if (tagtype != nsPluginTagType_Embed) {
+      PRUint16 pcount = 0;
+      const char* const* pnames = nsnull;
+      const char* const* pvalues = nsnull;    
+      if (NS_SUCCEEDED(taginfo->GetParameters(pcount, pnames, pvalues))) {
+        NS_ASSERTION(nsnull == values[count], "attribute/parameter array not setup correctly for 4.x plugins");
+        if (pcount)
+          count += ++pcount; //if it's all setup correctly, then all we need is to change the count (attrs + PARAM/blank + params)
+      }
+    }
+  }
+
+  NS_ENSURE_TRUE(fCallbacks->newp, NS_ERROR_FAILURE);
+  
+  // XXX Note that the NPPluginType_* enums were crafted to be
+  // backward compatible...
+  
+  nsPluginMode  mode;
+  nsMIMEType    mimetype;
+  NPError       error;
+
+  peer->GetMode(&mode);
+  peer->GetMIMEType(&mimetype);
+
+  // Some older versions of Flash have a bug in them
+  // that causes the stack to become currupt if we
+  // pass swliveconect=1 in the NPP_NewProc arrays.
+  // See bug 149336 (UNIX), bug 186287 (Mac)
+  //
+  // The code below disables the attribute unless
+  // the environment variable:
+  // MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK
+  // is set.
+  //
+  // It is okay to disable this attribute because
+  // back in 4.x, scripting required liveconnect to
+  // start Java which was slow. Scripting no longer
+  // requires starting Java and is quick plus controled
+  // from the browser, so Flash now ignores this attribute.
+  //
+  // This code can not be put at the time of creating
+  // the array because we may need to examine the
+  // stream header to determine we want Flash.
+
+  static const char flashMimeType[] = "application/x-shockwave-flash";
+  static const char blockedParam[] = "swliveconnect";
+  if (count && !PL_strcasecmp(mimetype, flashMimeType)) {
+    static int cachedDisableHack = 0;
+    if (!cachedDisableHack) {
+       if (PR_GetEnv("MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK"))
+         cachedDisableHack = -1;
+       else
+         cachedDisableHack = 1;
+    }
+    if (cachedDisableHack > 0) {
+      for (PRUint16 i=0; i<count; i++) {
+        if (!PL_strcasecmp(names[i], blockedParam)) {
+          // BIG FAT WARNIG:
+          // I'm ugly casting |const char*| to |char*| and altering it
+          // because I know we do malloc it values in
+          // http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/layout/html/base/src/nsObjectFrame.cpp&rev=1.349&root=/cvsroot#3020
+          // and free it at line #2096, so it couldn't be a const ptr to string literal
+          char *val = (char*) values[i];
+          if (val && *val) {
+            // we cannot just *val=0, it won't be free properly in such case
+            val[0] = '0';
+            val[1] = 0;
+          }
+          break;
+        }
+      }
+    }
+  }
+
+  mIsJavaPlugin = nsPluginHostImpl::IsJavaMIMEType(mimetype);
+
+  // Assign mPeer now and mark this instance as started before calling NPP_New 
+  // because the plugin may call other NPAPI functions, like NPN_GetURLNotify,
+  // that assume these are set before returning. If the plugin returns failure,
+  // we'll clear them out below.
+  mPeer = peer;
+  mStarted = PR_TRUE;
+
+  PRBool oldVal = mInPluginInitCall;
+  mInPluginInitCall = PR_TRUE;
+
+  NS_TRY_SAFE_CALL_RETURN(error, CallNPP_NewProc(fCallbacks->newp,
+                                          (char *)mimetype,
+                                          &fNPP,
+                                          (PRUint16)mode,
+                                          count,
+                                          (char**)names,
+                                          (char**)values,
+                                          NULL), fLibrary,this);
+
+  mInPluginInitCall = oldVal;
+
+  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("NPP New called: this=%p, npp=%p, mime=%s, mode=%d, argc=%d, return=%d\n",
+  this, &fNPP, mimetype, mode, count, error));
+
+  if (error != NPERR_NO_ERROR) {
+    // since the plugin returned failure, these should not be set
+    mPeer = nsnull;
+    mStarted = PR_FALSE;
+
+    return NS_ERROR_FAILURE;
+  }
+  
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::Destroy(void)
+{
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Destroy this=%p\n",this));
+
+  // destruction is handled in the Stop call
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::SetWindow(nsPluginWindow* window)
+{
+  // XXX 4.x plugins don't want a SetWindow(NULL).
+  if (!window || !mStarted)
+    return NS_OK;
+
+  NPError error;
+
+#if defined (MOZ_WIDGET_GTK2)
+  // bug 108347, flash plugin on linux doesn't like window->width <=
+  // 0, but Java needs wants this call.
+  if (!mIsJavaPlugin && window->type == nsPluginWindowType_Window &&
+      (window->width <= 0 || window->height <= 0)) {
+    return NS_OK;
+  }
+#endif // MOZ_WIDGET
+
+  if (fCallbacks->setwindow) {
+    PluginDestructionGuard guard(this);
+
+    // XXX Turns out that NPPluginWindow and NPWindow are structurally
+    // identical (on purpose!), so there's no need to make a copy.
+
+    PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::SetWindow (about to call it) this=%p\n",this));
+
+    PRBool oldVal = mInPluginInitCall;
+    mInPluginInitCall = PR_TRUE;
+
+    NS_TRY_SAFE_CALL_RETURN(error, CallNPP_SetWindowProc(fCallbacks->setwindow,
+                                  &fNPP,
+                                  (NPWindow*) window), fLibrary, this);
+
+    mInPluginInitCall = oldVal;
+
+    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+    ("NPP SetWindow called: this=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d], return=%d\n",
+    this, window->x, window->y, window->width, window->height,
+    window->clipRect.top, window->clipRect.bottom, window->clipRect.left, window->clipRect.right, error));
+      
+    // XXX In the old code, we'd just ignore any errors coming
+    // back from the plugin's SetWindow(). Is this the correct
+    // behavior?!?
+
+  }
+  return NS_OK;
+}
+
+/* NOTE: the caller must free the stream listener */
+// Create a normal stream, one without a urlnotify callback
+NS_IMETHODIMP nsNPAPIPluginInstance::NewStream(nsIPluginStreamListener** listener)
+{
+  return NewNotifyStream(listener, nsnull, PR_FALSE, nsnull);
+}
+
+// Create a stream that will notify when complete
+nsresult nsNPAPIPluginInstance::NewNotifyStream(nsIPluginStreamListener** listener, 
+                                                void* notifyData,
+                                                PRBool aCallNotify,
+                                                const char* aURL)
+{
+  nsNPAPIPluginStreamListener* stream = new nsNPAPIPluginStreamListener(this, notifyData, aURL);
+  NS_ENSURE_TRUE(stream, NS_ERROR_OUT_OF_MEMORY);
+
+  // add it to the list
+  nsInstanceStream * is = new nsInstanceStream();
+  NS_ENSURE_TRUE(is, NS_ERROR_OUT_OF_MEMORY);
+
+  is->mNext = mStreams;
+  is->mPluginStreamListener = stream;
+  mStreams = is;
+  stream->SetCallNotify(aCallNotify);  // set flag in stream to call URLNotify
+
+  NS_ADDREF(stream);  // Stabilize
+    
+  nsresult res = stream->QueryInterface(kIPluginStreamListenerIID, (void**)listener);
+
+  // Destabilize and avoid leaks. Avoid calling delete <interface pointer>
+  NS_RELEASE(stream);
+
+  return res;
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::Print(nsPluginPrint* platformPrint)
+{
+  NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
+
+  PluginDestructionGuard guard(this);
+
+  NPPrint* thePrint = (NPPrint *)platformPrint;
+
+  // to be compatible with the older SDK versions and to match what
+  // 4.x and other browsers do, overwrite |window.type| field with one
+  // more copy of |platformPrint|. See bug 113264
+  if (fCallbacks) {
+    PRUint16 sdkmajorversion = (fCallbacks->version & 0xff00)>>8;
+    PRUint16 sdkminorversion = fCallbacks->version & 0x00ff;
+    if ((sdkmajorversion == 0) && (sdkminorversion < 11)) { 
+      // Let's copy platformPrint bytes over to where it was supposed to be 
+      // in older versions -- four bytes towards the beginning of the struct
+      // but we should be careful about possible misalignments
+      if (sizeof(NPWindowType) >= sizeof(void *)) {
+        void* source = thePrint->print.embedPrint.platformPrint; 
+        void** destination = (void **)&(thePrint->print.embedPrint.window.type); 
+        *destination = source;
+      } 
+      else 
+        NS_ASSERTION(PR_FALSE, "Incompatible OS for assignment");
+    }
+  }
+
+  if (fCallbacks->print) {
+      NS_TRY_SAFE_CALL_VOID(CallNPP_PrintProc(fCallbacks->print,
+                                              &fNPP,
+                                              thePrint), fLibrary, this);
+  }
+
+  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+  ("NPP PrintProc called: this=%p, pDC=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d]\n",
+  this,
+  platformPrint->print.embedPrint.platformPrint,
+  platformPrint->print.embedPrint.window.x,
+  platformPrint->print.embedPrint.window.y,
+  platformPrint->print.embedPrint.window.width,
+  platformPrint->print.embedPrint.window.height,
+  platformPrint->print.embedPrint.window.clipRect.top,
+  platformPrint->print.embedPrint.window.clipRect.bottom,
+  platformPrint->print.embedPrint.window.clipRect.left,
+  platformPrint->print.embedPrint.window.clipRect.right));
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::HandleEvent(nsPluginEvent* event, PRBool* handled)
+{
+  if (!mStarted)
+    return NS_OK;
+
+  if (!event)
+    return NS_ERROR_FAILURE;
+
+  PluginDestructionGuard guard(this);
+
+  PRInt16 result = 0;
+  
+  if (fCallbacks->event) {
+#ifdef XP_MACOSX
+    result = CallNPP_HandleEventProc(fCallbacks->event,
+                                     &fNPP,
+                                     (void*) event->event);
+
+#elif defined(XP_WIN) || defined(XP_OS2)
+      NPEvent npEvent;
+      npEvent.event = event->event;
+      npEvent.wParam = event->wParam;
+      npEvent.lParam = event->lParam;
+
+      NS_TRY_SAFE_CALL_RETURN(result, CallNPP_HandleEventProc(fCallbacks->event,
+                                    &fNPP,
+                                    (void*)&npEvent), fLibrary, this);
+
+#else // MOZ_X11 or other
+      result = CallNPP_HandleEventProc(fCallbacks->event,
+                                       &fNPP,
+                                       (void*)&event->event);
+#endif
+
+      NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+      ("NPP HandleEvent called: this=%p, npp=%p, event=%d, return=%d\n", 
+      this, &fNPP, event->event, result));
+
+      *handled = result;
+    }
+
+  return NS_OK;
+}
+
+nsresult nsNPAPIPluginInstance::GetValueInternal(NPPVariable variable, void* value)
+{
+  nsresult  res = NS_OK;
+  if (fCallbacks->getvalue && mStarted) {
+    PluginDestructionGuard guard(this);
+
+    NS_TRY_SAFE_CALL_RETURN(res, 
+                            CallNPP_GetValueProc(fCallbacks->getvalue, 
+                                                 &fNPP, 
+                                                 variable, 
+                                                 value), 
+                                                 fLibrary, this);
+    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+    ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%d, return=%d\n", 
+    this, &fNPP, variable, value, res));
+
+#ifdef XP_OS2
+    /* Query interface for legacy Flash plugin */
+    if (res == NS_OK && variable == NPPVpluginScriptableInstance)
+    {
+      nsCOMPtr<nsILegacyPluginWrapperOS2> wrapper =
+               do_GetService(NS_LEGACY_PLUGIN_WRAPPER_CONTRACTID, &res);
+      if (res == NS_OK)
+      {
+        nsIID *iid = nsnull; 
+        res = CallNPP_GetValueProc(fCallbacks->getvalue, &fNPP, 
+                                   NPPVpluginScriptableIID, (void *)&iid);
+        if (res == NS_OK)
+          res = wrapper->MaybeWrap(*iid, *(nsISupports**)value,
+                                   (nsISupports**)value);
+      }
+    }
+#endif
+  }
+
+  return res;
+}
+
+NS_IMETHODIMP nsNPAPIPluginInstance::GetValue(nsPluginInstanceVariable variable, void *value)
+{
+  nsresult  res = NS_OK;
+
+  switch (variable) {
+    case nsPluginInstanceVariable_WindowlessBool:
+      *(PRBool *)value = mWindowless;
+      break;
+
+    case nsPluginInstanceVariable_TransparentBool:
+      *(PRBool *)value = mTransparent;
+      break;
+
+    case nsPluginInstanceVariable_DoCacheBool:
+      *(PRBool *)value = mCached;
+      break;
+
+    case nsPluginInstanceVariable_CallSetWindowAfterDestroyBool:
+      *(PRBool *)value = 0;  // not supported for 4.x plugins
+      break;
+
+#ifdef XP_MACOSX
+    case nsPluginInstanceVariable_DrawingModel:
+      *(NPDrawingModel*)value = mDrawingModel;
+      break;
+#endif
+
+    default:
+      res = GetValueInternal((NPPVariable)variable, value);
+  }
+
+  return res;
+}
+
+nsresult nsNPAPIPluginInstance::GetNPP(NPP* aNPP) 
+{
+  if (aNPP != nsnull)
+    *aNPP = &fNPP;
+  else
+    return NS_ERROR_NULL_POINTER;
+
+  return NS_OK;
+}
+
+nsresult nsNPAPIPluginInstance::GetCallbacks(const NPPluginFuncs ** aCallbacks)
+{
+  if (aCallbacks != nsnull)
+    *aCallbacks = fCallbacks;
+  else
+    return NS_ERROR_NULL_POINTER;
+
+  return NS_OK;
+}
+
+NPError nsNPAPIPluginInstance::SetWindowless(PRBool aWindowless)
+{
+  mWindowless = aWindowless;
+  return NPERR_NO_ERROR;
+}
+
+NPError nsNPAPIPluginInstance::SetTransparent(PRBool aTransparent)
+{
+  mTransparent = aTransparent;
+  return NPERR_NO_ERROR;
+}
+
+NPError nsNPAPIPluginInstance::SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams)
+{
+  mWantsAllNetworkStreams = aWantsAllNetworkStreams;
+  return NPERR_NO_ERROR;
+}
+
+#ifdef XP_MACOSX
+void nsNPAPIPluginInstance::SetDrawingModel(NPDrawingModel aModel)
+{
+  mDrawingModel = aModel;
+}
+
+NPDrawingModel nsNPAPIPluginInstance::GetDrawingModel()
+{
+  return mDrawingModel;
+}
+#endif
+
+/* readonly attribute nsQIResult scriptablePeer; */
+NS_IMETHODIMP nsNPAPIPluginInstance::GetScriptablePeer(void * *aScriptablePeer)
+{
+  if (!aScriptablePeer)
+    return NS_ERROR_NULL_POINTER;
+
+  *aScriptablePeer = nsnull;
+  return GetValueInternal(NPPVpluginScriptableInstance, aScriptablePeer);
+}
+
+/* readonly attribute nsIIDPtr scriptableInterface; */
+NS_IMETHODIMP nsNPAPIPluginInstance::GetScriptableInterface(nsIID * *aScriptableInterface)
+{
+  if (!aScriptableInterface)
+    return NS_ERROR_NULL_POINTER;
+
+  *aScriptableInterface = nsnull;
+  return GetValueInternal(NPPVpluginScriptableIID, (void*)aScriptableInterface);
+}
+
+JSObject *
+nsNPAPIPluginInstance::GetJSObject(JSContext *cx)
+{
+  JSObject *obj = nsnull;
+  NPObject *npobj = nsnull;
+
+  nsresult rv = GetValueInternal(NPPVpluginScriptableNPObject, &npobj);
+
+  if (NS_SUCCEEDED(rv) && npobj) {
+    obj = nsNPObjWrapper::GetNewOrUsed(&fNPP, cx, npobj);
+
+    _releaseobject(npobj);
+  }
+
+  return obj;
+}
+
+void
+nsNPAPIPluginInstance::DefineJavaProperties()
+{
+  NPObject *plugin_obj = nsnull;
+
+  // The dummy Java plugin's scriptable object is what we want to
+  // expose as window.Packages. And Window.Packages.java will be
+  // exposed as window.java.
+
+  // Get the scriptable plugin object.
+  nsresult rv = GetValueInternal(NPPVpluginScriptableNPObject, &plugin_obj);
+
+  if (NS_FAILED(rv) || !plugin_obj) {
+    return;
+  }
+
+  // Get the NPObject wrapper for window.
+  NPObject *window_obj = _getwindowobject(&fNPP);
+
+  if (!window_obj) {
+    _releaseobject(plugin_obj);
+
+    return;
+  }
+
+  NPIdentifier java_id = _getstringidentifier("java");
+  NPIdentifier packages_id = _getstringidentifier("Packages");
+
+  NPObject *java_obj = nsnull;
+  NPVariant v;
+  OBJECT_TO_NPVARIANT(plugin_obj, v);
+
+  // Define the properties.
+
+  bool ok = _setproperty(&fNPP, window_obj, packages_id, &v);
+  if (ok) {
+    ok = _getproperty(&fNPP, plugin_obj, java_id, &v);
+
+    if (ok && NPVARIANT_IS_OBJECT(v)) {
+      // Set java_obj so that we properly release it at the end of
+      // this function.
+      java_obj = NPVARIANT_TO_OBJECT(v);
+
+      ok = _setproperty(&fNPP, window_obj, java_id, &v);
+    }
+  }
+
+  _releaseobject(window_obj);
+  _releaseobject(plugin_obj);
+  _releaseobject(java_obj);
+}
+
+nsresult
+nsNPAPIPluginInstance::GetFormValue(nsAString& aValue)
+{
+  aValue.Truncate();
+
+  char *value = nsnull;
+  nsresult rv = GetValueInternal(NPPVformValue, &value);
+
+  if (NS_SUCCEEDED(rv) && value) {
+    CopyUTF8toUTF16(value, aValue);
+
+    // NPPVformValue allocates with NPN_MemAlloc(), which uses
+    // nsMemory.
+    nsMemory::Free(value);
+  }
+
+  return NS_OK;
+}
+
+void
+nsNPAPIPluginInstance::PushPopupsEnabledState(PRBool aEnabled)
+{
+  nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
+  if (!window)
+    return;
+
+  PopupControlState oldState =
+    window->PushPopupControlState(aEnabled ? openAllowed : openAbused,
+                                  PR_TRUE);
+
+  if (!mPopupStates.AppendElement(NS_INT32_TO_PTR(oldState))) {
+    // Appending to our state stack failed, push what we just popped.
+
+    window->PopPopupControlState(oldState);
+  }
+}
+
+void
+nsNPAPIPluginInstance::PopPopupsEnabledState()
+{
+  PRInt32 last = mPopupStates.Count() - 1;
+
+  if (last < 0) {
+    // Nothing to pop.
+    return;
+  }
+
+  nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
+  if (!window)
+    return;
+
+  PopupControlState oldState =
+    (PopupControlState)NS_PTR_TO_INT32(mPopupStates[last]);
+
+  window->PopPopupControlState(oldState);
+
+  mPopupStates.RemoveElementAt(last);
+}
+
+PRUint16
+nsNPAPIPluginInstance::GetPluginAPIVersion()
+{
+  return fCallbacks->version;
+}
diff -r 8dcf83cc8500 modules/plugin/base/src/nsNPAPIPluginInstance.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/base/src/nsNPAPIPluginInstance.h	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,176 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Copperfield <timecop@network.email.ne.jp>
+ *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsNPAPIPluginInstance_h_
+#define nsNPAPIPluginInstance_h_
+
+#include "nsCOMPtr.h"
+#include "nsVoidArray.h"
+#include "nsIPlugin.h"
+#include "nsIPluginInstance.h"
+#include "nsIPluginInstancePeer.h"
+#include "nsIPluginTagInfo2.h"
+#include "nsIScriptablePlugin.h"
+#include "nsIPluginInstanceInternal.h"
+
+#include "npupp.h"
+#include "prlink.h"
+
+class nsNPAPIPluginStreamListener;
+class nsPIDOMWindow;
+
+struct nsInstanceStream
+{
+    nsInstanceStream *mNext;
+    nsNPAPIPluginStreamListener *mPluginStreamListener;
+
+    nsInstanceStream();
+    ~nsInstanceStream();
+};
+
+class nsNPAPIPluginInstance : public nsIPluginInstance,
+                              public nsIScriptablePlugin,
+                              public nsIPluginInstanceInternal
+{
+public:
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIPLUGININSTANCE
+    NS_DECL_NSISCRIPTABLEPLUGIN
+
+    // nsIPluginInstanceInternal methods
+
+    virtual JSObject *GetJSObject(JSContext *cx);
+
+    virtual nsresult GetFormValue(nsAString& aValue);
+
+    virtual void PushPopupsEnabledState(PRBool aEnabled);
+    virtual void PopPopupsEnabledState();
+
+    virtual PRUint16 GetPluginAPIVersion();
+
+    virtual void DefineJavaProperties();
+
+    // nsNPAPIPluginInstance-specific methods
+
+    // Return the 4.x-style interface object.
+    nsresult GetNPP(NPP * aNPP);
+
+    // Return the callbacks for the plugin instance.
+    nsresult GetCallbacks(const NPPluginFuncs ** aCallbacks);
+
+    NPError SetWindowless(PRBool aWindowless);
+
+    NPError SetTransparent(PRBool aTransparent);
+
+    NPError SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams);
+
+#ifdef XP_MACOSX
+    void SetDrawingModel(NPDrawingModel aModel);
+    NPDrawingModel GetDrawingModel();
+#endif
+
+    nsresult NewNotifyStream(nsIPluginStreamListener** listener, 
+                             void* notifyData, 
+                             PRBool aCallNotify,
+                             const char * aURL);
+
+    // Construct a new 4.x plugin instance with the specified peer
+    // and callbacks.
+    nsNPAPIPluginInstance(NPPluginFuncs* callbacks, PRLibrary* aLibrary);
+
+    // Use Release() to destroy this
+    virtual ~nsNPAPIPluginInstance(void);
+
+    // returns the state of mStarted
+    PRBool IsStarted(void);
+
+    // cache this 4.x plugin like an XPCOM plugin
+    nsresult SetCached(PRBool aCache) { mCached = aCache; return NS_OK; }
+
+    // Non-refcounting accessor for faster access to the peer.
+    nsIPluginInstancePeer *Peer()
+    {
+        return mPeer;
+    }
+
+    already_AddRefed<nsPIDOMWindow> GetDOMWindow();
+
+protected:
+
+    nsresult InitializePlugin(nsIPluginInstancePeer* peer);
+
+    // Calls NPP_GetValue
+    nsresult GetValueInternal(NPPVariable variable, void* value);
+
+    // The plugin instance peer for this instance.
+    nsCOMPtr<nsIPluginInstancePeer> mPeer;
+
+    // A pointer to the plugin's callback functions. This information
+    // is actually stored in the plugin class (<b>nsPluginClass</b>),
+    // and is common for all plugins of the class.
+    NPPluginFuncs* fCallbacks;
+
+    // The 4.x-style structure used to communicate between the plugin
+    // instance and the browser.
+    NPP_t fNPP;
+
+#ifdef XP_MACOSX
+    NPDrawingModel mDrawingModel;
+#endif
+
+    // these are used to store the windowless properties
+    // which the browser will later query
+    PRPackedBool  mWindowless;
+    PRPackedBool  mTransparent;
+    PRPackedBool  mStarted;
+    PRPackedBool  mCached;
+    PRPackedBool  mIsJavaPlugin;
+    PRPackedBool  mWantsAllNetworkStreams;
+
+public:
+    // True while creating the plugin, or calling NPP_SetWindow() on it.
+    PRPackedBool  mInPluginInitCall;
+    PRLibrary* fLibrary;
+    nsInstanceStream *mStreams;
+
+    nsVoidArray mPopupStates;
+};
+
+#endif // nsNPAPIPluginInstance_h_
diff -r 8dcf83cc8500 modules/plugin/base/src/nsNPAPIPluginStreamListener.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/modules/plugin/base/src/nsNPAPIPluginStreamListener.h	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,127 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsNPAPIPluginStreamListener_h_
+#define nsNPAPIPluginStreamListener_h_
+
+#include "nsIPluginStreamListener.h"
+#include "nsIPluginStreamInfo.h"
+#include "nsIHTTPHeaderListener.h"
+#include "nsIRequest.h"
+#include "nsITimer.h"
+#include "nsCOMPtr.h"
+
+#define MAX_PLUGIN_NECKO_BUFFER 16384
+
+class nsNPAPIPluginInstance;
+class nsINPAPIPluginStreamInfo;
+
+class nsNPAPIPluginStreamListener : public nsIPluginStreamListener,
+                                 public nsITimerCallback,
+                                 public nsIHTTPHeaderListener
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIPLUGINSTREAMLISTENER
+  NS_DECL_NSITIMERCALLBACK
+  NS_DECL_NSIHTTPHEADERLISTENER
+
+  // nsNPAPIPluginStreamListener specific methods:
+  nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst, void* notifyData,
+                              const char* aURL);
+  virtual ~nsNPAPIPluginStreamListener();
+  PRBool IsStarted();
+  nsresult CleanUpStream(NPReason reason);
+  void CallURLNotify(NPReason reason);
+  void SetCallNotify(PRBool aCallNotify)
+  {
+    mCallNotify = aCallNotify;
+  }
+  nsresult SuspendRequest();
+  void ResumeRequest();
+  nsresult StartDataPump();
+  void StopDataPump();
+
+  PRBool PluginInitJSLoadInProgress();
+
+protected:
+  void* mNotifyData;
+  char* mStreamBuffer;
+  char* mNotifyURL;
+  nsNPAPIPluginInstance* mInst;
+  NPStream mNPStream;
+  PRUint32 mStreamBufferSize;
+  PRInt32 mStreamBufferByteCount;
+  nsPluginStreamType mStreamType;
+  PRPackedBool mStreamStarted;
+  PRPackedBool mStreamCleanedUp;
+  PRPackedBool mCallNotify;
+  PRPackedBool mIsSuspended;
+  PRPackedBool mIsPluginInitJSStream;
+  nsCString mResponseHeaders;
+  char* mResponseHeaderBuf;
+
+  nsCOMPtr<nsITimer> mDataPumpTimer;
+
+public:
+  nsCOMPtr<nsIPluginStreamInfo> mStreamInfo;
+};
+
+// nsINPAPIPluginStreamInfo is an internal helper interface that exposes
+// the underlying necko request to consumers of nsIPluginStreamInfo's.
+#define NS_INPAPIPLUGINSTREAMINFO_IID       \
+{ 0x097fdaaa, 0xa2a3, 0x49c2, \
+  {0x91, 0xee, 0xeb, 0xc5, 0x7d, 0x6c, 0x9c, 0x97} }
+
+class nsINPAPIPluginStreamInfo : public nsIPluginStreamInfo
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_INPAPIPLUGINSTREAMINFO_IID)
+
+  nsIRequest *GetRequest()
+  {
+    return mRequest;
+  }
+
+protected:
+  nsCOMPtr<nsIRequest> mRequest;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsINPAPIPluginStreamInfo,
+                              NS_INPAPIPLUGINSTREAMINFO_IID)
+
+#endif // nsNPAPIPluginStreamListener_h_
diff -r 8dcf83cc8500 modules/plugin/base/src/nsPluginHostImpl.cpp
--- a/modules/plugin/base/src/nsPluginHostImpl.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/plugin/base/src/nsPluginHostImpl.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -41,18 +41,18 @@
 /* nsPluginHostImpl.cpp - bulk of code for managing plugins */
 
 #include "nscore.h"
 #include "nsPluginHostImpl.h"
 
 #include <stdio.h>
 #include "prio.h"
 #include "prmem.h"
-#include "ns4xPlugin.h"
-#include "ns4xPluginStreamListener.h"
+#include "nsNPAPIPlugin.h"
+#include "nsNPAPIPluginStreamListener.h"
 #include "nsPluginInstancePeer.h"
 #include "nsIPlugin.h"
 #include "nsIPluginInstanceInternal.h"
 #ifdef OJI
 #include "nsIJVMPlugin.h"
 #include "nsIJVMPluginInstance.h"
 #include "nsIJVMManager.h"
 #endif
@@ -1188,25 +1188,25 @@ PRBool nsPluginTag::Equals(nsPluginTag *
     }
   }
   return PR_TRUE;
 }
 
 ////////////////////////////////////////////////////////////////////////
 class nsPluginStreamListenerPeer;
 
-class nsPluginStreamInfo : public nsI4xPluginStreamInfo
+class nsPluginStreamInfo : public nsINPAPIPluginStreamInfo
 {
 public:
   nsPluginStreamInfo();
   virtual ~nsPluginStreamInfo();
 
   NS_DECL_ISUPPORTS
 
-  // nsI4xPluginStreamInfo interface
+  // nsINPAPIPluginStreamInfo interface
  
   NS_IMETHOD
   GetContentType(nsMIMEType* result);
 
   NS_IMETHOD
   IsSeekable(PRBool* result);
 
   NS_IMETHOD
@@ -1401,17 +1401,17 @@ nsPluginStreamInfo::~nsPluginStreamInfo(
   if(mURL != nsnull)
     PL_strfree(mURL);
 
   NS_IF_RELEASE(mPluginInstance);
 }
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS2(nsPluginStreamInfo, nsIPluginStreamInfo,
-                   nsI4xPluginStreamInfo)
+                   nsINPAPIPluginStreamInfo)
 ////////////////////////////////////////////////////////////////////////
 
 NS_IMETHODIMP
 nsPluginStreamInfo::GetContentType(nsMIMEType* result)
 {
   *result = mContentType;
   return NS_OK;
 }
@@ -2030,17 +2030,17 @@ nsPluginStreamListenerPeer::OnStartReque
   // deal with 404 (Not Found) HTTP response,
   // just return, this causes the request to be ignored.
   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
   if (httpChannel) {
     PRUint32 responseCode = 0;
     rv = httpChannel->GetResponseStatus(&responseCode);
     if (NS_FAILED(rv)) {
       // NPP_Notify() will be called from OnStopRequest
-      // in ns4xPluginStreamListener::CleanUpStream
+      // in nsNPAPIPluginStreamListener::CleanUpStream
       // return error will cancel this request
       // ...and we also need to tell the plugin that
       mRequestFailed = PR_TRUE;
       return NS_ERROR_FAILURE;
     }
 
     if (responseCode > 206) { // not normal
       PRBool bWantsAllNetworkStreams = PR_FALSE;
@@ -4689,19 +4689,19 @@ static nsresult ConvertToNative(nsIUnico
     return NS_ERROR_OUT_OF_MEMORY;
   rv = aEncoder->Convert(utf16.get(), &len,
                          aNativeString.BeginWriting(), &outLen);
   NS_ENSURE_SUCCESS(rv, rv);
   aNativeString.SetLength(outLen);
   return NS_OK;
 }
 
-static nsresult Create4xPlugin(nsIServiceManagerObsolete* aServiceManager,
-                               const nsPluginTag *aPluginTag,
-                               nsIPlugin **aOut4xPlugnin)
+static nsresult CreateNPAPIPlugin(nsIServiceManagerObsolete* aServiceManager,
+                                  const nsPluginTag *aPluginTag,
+                                  nsIPlugin **aOutNPAPIPlugnin)
 {
   nsresult rv;
   nsCOMPtr <nsIPlatformCharset> pcs =
     do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCAutoString charset;
   rv = pcs->GetCharset(kPlatformCharsetSel_FileName, charset);
@@ -4719,20 +4719,20 @@ static nsresult Create4xPlugin(nsIServic
     NS_ENSURE_SUCCESS(rv, rv);
     rv = ConvertToNative(encoder, aPluginTag->mFullPath, fullPath);
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
     fileName = aPluginTag->mFileName;
     fullPath = aPluginTag->mFullPath;
   }
 
-  return ns4xPlugin::CreatePlugin(fileName.get(),
-                                  fullPath.get(),
-                                  aPluginTag->mLibrary,
-                                  aOut4xPlugnin);
+  return nsNPAPIPlugin::CreatePlugin(fileName.get(),
+                                     fullPath.get(),
+                                     aPluginTag->mLibrary,
+                                     aOutNPAPIPlugnin);
 }
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetPluginFactory(const char *aMimeType, nsIPlugin** aPlugin)
 {
   nsresult rv = NS_ERROR_FAILURE;
   *aPlugin = NULL;
 
@@ -4839,17 +4839,17 @@ NS_IMETHODIMP nsPluginHostImpl::GetPlugi
           if (plugin != NULL)
             plugin->Initialize();
         }
       }
 #endif
       else
       {
         // Now lets try to get the entry point from a 4.x plugin
-        rv = Create4xPlugin(serviceManager, pluginTag, &plugin);
+        rv = CreateNPAPIPlugin(serviceManager, pluginTag, &plugin);
         if (NS_SUCCEEDED(rv))
           pluginTag->mEntryPoint = plugin;
         pluginTag->Mark(NS_PLUGIN_FLAG_OLDSCHOOL);
         // no need to initialize, already done by CreatePlugin()
       }
     }
 
 #if defined (XP_MACOSX)
@@ -4980,17 +4980,17 @@ static int PR_CALLBACK ComparePluginFile
   else if (LL_CMP(pfd1->mModTime, >, pfd2->mModTime))
     result = -1;
   else
     result = 1;
 
   return result;
 }
 
-typedef NS_4XPLUGIN_CALLBACK(char *, NP_GETMIMEDESCRIPTION)(void);
+typedef NS_NPAPIPLUGIN_CALLBACK(char *, NP_GETMIMEDESCRIPTION)(void);
 
 static nsresult FixUpPluginInfo(nsPluginInfo &aInfo, nsPluginFile &aPluginFile)
 {
 #ifndef XP_WIN
   return NS_OK;
 #endif
 
   for (PRUint32 i = 0; i < aInfo.fVariantCount; i++) {
diff -r 8dcf83cc8500 modules/plugin/base/src/nsPluginHostImpl.h
--- a/modules/plugin/base/src/nsPluginHostImpl.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/plugin/base/src/nsPluginHostImpl.h	Tue Sep 16 07:55:13 2008 -0500
@@ -43,17 +43,17 @@
 #include "nsIPluginHost.h"
 #include "nsIObserver.h"
 #include "nsPIPluginHost.h"
 #include "nsCRT.h"
 #include "nsCOMPtr.h"
 #include "prlink.h"
 #include "prclist.h"
 #include "npapi.h"
-#include "ns4xPluginInstance.h"
+#include "nsNPAPIPluginInstance.h"
 
 #include "nsIPlugin.h"
 #include "nsIPluginTag.h"
 #include "nsIPluginTagInfo2.h"
 #include "nsIPluginInstancePeer2.h"
 
 #include "nsIFileUtilities.h"
 #include "nsICookieStorage.h"
@@ -68,17 +68,17 @@
 #include "nsIPrefBranch.h"
 #include "nsWeakReference.h"
 #include "nsThreadUtils.h"
 #include "nsTArray.h"
 
 // XXX this file really doesn't think this is possible, but ...
 #include "nsIFactory.h"
 
-class ns4xPlugin;
+class nsNPAPIPlugin;
 class nsIComponentManager;
 class nsIFile;
 class nsIChannel;
 class nsIRegistry;
 class nsPluginHostImpl;
 
 #define NS_PLUGIN_FLAG_ENABLED      0x0001    // is this plugin enabled?
 #define NS_PLUGIN_FLAG_OLDSCHOOL    0x0002    // is this a pre-xpcom plugin?
@@ -477,17 +477,17 @@ public:
 public:
   PluginDestructionGuard(nsIPluginInstance *aInstance)
     : mInstance(aInstance)
   {
     Init();
   }
 
   PluginDestructionGuard(NPP npp)
-    : mInstance(npp ? static_cast<ns4xPluginInstance*>(npp->ndata) : nsnull)
+    : mInstance(npp ? static_cast<nsNPAPIPluginInstance*>(npp->ndata) : nsnull)
   {
     Init();
   }
 
   ~PluginDestructionGuard();
 
   static PRBool DelayDestroy(nsIPluginInstance *aInstance);
 
diff -r 8dcf83cc8500 modules/plugin/base/src/nsPluginModule.cpp
--- a/modules/plugin/base/src/nsPluginModule.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/plugin/base/src/nsPluginModule.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -35,17 +35,16 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIGenericFactory.h"
 #include "nsIPluginManager.h"
 #include "nsPluginsCID.h"
 #include "nsPluginHostImpl.h"
-#include "ns4xPlugin.h"
 #include "nsJVMAuthTools.h"
 
 NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsPluginHostImpl,
                                          nsPluginHostImpl::GetInst)
 NS_GENERIC_AGGREGATED_CONSTRUCTOR(nsJVMAuthTools)
 
 static const nsModuleComponentInfo gComponentInfo[] = {
   { "Plugin Host",
diff -r 8dcf83cc8500 modules/plugin/base/src/nsPluginsDirDarwin.cpp
--- a/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/plugin/base/src/nsPluginsDirDarwin.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -45,33 +45,33 @@
   by Patrick C. Beard.
  */
 
 #include "prlink.h"
 #include "prnetdb.h"
 #include "nsXPCOM.h"
 
 #include "nsPluginsDir.h"
-#include "ns4xPlugin.h"
+#include "nsNPAPIPlugin.h"
 #include "nsPluginsDirUtils.h"
 
 #include "nsILocalFileMac.h"
 
 #include <string.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <fcntl.h>
 
 #include <Carbon/Carbon.h>
 #include <CoreServices/CoreServices.h>
 #include <mach-o/loader.h>
 #include <mach-o/fat.h>
 
-typedef NS_4XPLUGIN_CALLBACK(const char *, NP_GETMIMEDESCRIPTION) ();
-typedef NS_4XPLUGIN_CALLBACK(OSErr, BP_GETSUPPORTEDMIMETYPES) (BPSupportedMIMETypes *mimeInfo, UInt32 flags);
+typedef NS_NPAPIPLUGIN_CALLBACK(const char *, NP_GETMIMEDESCRIPTION) ();
+typedef NS_NPAPIPLUGIN_CALLBACK(OSErr, BP_GETSUPPORTEDMIMETYPES) (BPSupportedMIMETypes *mimeInfo, UInt32 flags);
 
 
 /*
 ** Returns a CFBundleRef if the FSSpec refers to a Mac OS X bundle directory.
 ** The caller is responsible for calling CFRelease() to deallocate.
 */
 static CFBundleRef getPluginBundle(const char* path)
 {
diff -r 8dcf83cc8500 modules/plugin/base/src/nsPluginsDirUnix.cpp
--- a/modules/plugin/base/src/nsPluginsDirUnix.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/modules/plugin/base/src/nsPluginsDirUnix.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -39,18 +39,18 @@
 	nsPluginsDirUNIX.cpp
 	
 	UNIX implementation of the nsPluginsDir/nsPluginsFile classes.
 	
 	by Alex Musil
  */
 
 #include "nsplugin.h"
-#include "ns4xPlugin.h"
-#include "ns4xPluginInstance.h"
+#include "nsNPAPIPlugin.h"
+#include "nsNPAPIPluginInstance.h"
 #include "nsIServiceManager.h"
 #include "nsIMemory.h"
 #include "nsIPluginStreamListener.h"
 #include "nsPluginsDir.h"
 #include "nsPluginsDirUtils.h"
 #include "nsObsoleteModuleLoading.h"
 #include "prmem.h"
 #include "prenv.h"
@@ -453,26 +453,26 @@ nsresult nsPluginFile::GetPluginInfo(nsP
         rv = nsGetFactory(mgr, kPluginCID, nsnull, nsnull, 
 			  getter_AddRefs(factory));
 
         if (NS_FAILED(rv)) {
             // HACK: The symbol lookup for "NSGetFactory" mistakenly returns
             // a reference to an unrelated function when we have an NPAPI
             // plugin linked to libxul.so.  Give this plugin another shot as
             // an NPAPI plugin
-            rv = ns4xPlugin::CreatePlugin(0, 0, pLibrary, getter_AddRefs(plugin));
+            rv = nsNPAPIPlugin::CreatePlugin(0, 0, pLibrary, getter_AddRefs(plugin));
             if (NS_FAILED(rv))
                 return rv;
         } else {
             plugin = do_QueryInterface(factory);
         }
     } else {
         // It's old sk00l
-        // if fileName parameter == 0 ns4xPlugin::CreatePlugin() will not call NP_Initialize()
-        rv = ns4xPlugin::CreatePlugin(0, 0, pLibrary, getter_AddRefs(plugin));
+        // if fileName parameter == 0 nsNPAPIPlugin::CreatePlugin() will not call NP_Initialize()
+        rv = nsNPAPIPlugin::CreatePlugin(0, 0, pLibrary, getter_AddRefs(plugin));
         if (NS_FAILED(rv)) return rv;
     }
 
     if (plugin) {
         const char* (*npGetPluginVersion)() =
           (const char* (*)()) PR_FindFunctionSymbol(pLibrary, "NP_GetPluginVersion");
         if (npGetPluginVersion)
             info.fVersion = PL_strdup(npGetPluginVersion());
diff -r 8dcf83cc8500 netwerk/base/src/nsIOService.cpp
--- a/netwerk/base/src/nsIOService.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/base/src/nsIOService.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -949,28 +949,28 @@ nsIOService::EscapeString(const nsACStri
   return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsIOService::EscapeURL(const nsACString &aStr, 
                        PRUint32 aFlags, nsACString &aResult)
 {
   aResult.Truncate();
-  PRBool escaped = NS_EscapeURL(aStr.BeginReading(), aStr.Length(), 
-                                aFlags | esc_AlwaysCopy, aResult);
+  NS_EscapeURL(aStr.BeginReading(), aStr.Length(), 
+               aFlags | esc_AlwaysCopy, aResult);
   return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsIOService::UnescapeString(const nsACString &aStr, 
                             PRUint32 aFlags, nsACString &aResult)
 {
   aResult.Truncate();
-  PRBool unescaped = NS_UnescapeURL(aStr.BeginReading(), aStr.Length(), 
-                                    aFlags | esc_AlwaysCopy, aResult);
+  NS_UnescapeURL(aStr.BeginReading(), aStr.Length(), 
+                 aFlags | esc_AlwaysCopy, aResult);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsIOService::ExtractCharsetFromContentType(const nsACString &aTypeHeader,
                                            nsACString &aCharset,
                                            PRInt32 *aCharsetStart,
                                            PRInt32 *aCharsetEnd,
diff -r 8dcf83cc8500 netwerk/base/src/nsStandardURL.cpp
--- a/netwerk/base/src/nsStandardURL.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/base/src/nsStandardURL.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -490,16 +490,18 @@ nsStandardURL::BuildNormalizedSpec(const
     // already point to a [ ] delimited IPv6 address literal.
     // However, perform Unicode normalization on it, as IDN does.
     mHostEncoding = eEncoding_ASCII;
     if (mHost.mLen > 0) {
         const nsCSubstring& tempHost =
             Substring(spec + mHost.mPos, spec + mHost.mPos + mHost.mLen);
         if (tempHost.FindChar('\0') != kNotFound)
             return NS_ERROR_MALFORMED_URI;  // null embedded in hostname
+        if (tempHost.FindChar(' ') != kNotFound)
+            return NS_ERROR_MALFORMED_URI;  // don't allow spaces in the hostname
         if ((useEncHost = NormalizeIDN(tempHost, encHost)))
             approxLen += encHost.Length();
         else
             approxLen += mHost.mLen;
     }
 
     //
     // generate the normalized URL string
diff -r 8dcf83cc8500 netwerk/cache/src/nsCacheService.cpp
--- a/netwerk/cache/src/nsCacheService.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/cache/src/nsCacheService.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -521,18 +521,21 @@ nsCacheProfilePrefObserver::MemoryCacheC
     if (capacity >= 0) {
         CACHE_LOG_DEBUG(("Memory cache capacity forced to %d\n", capacity));
         return capacity;
     }
 
     PRUint64 bytes = PR_GetPhysicalMemorySize();
     CACHE_LOG_DEBUG(("Physical Memory size is %llu\n", bytes));
 
-    if (LL_CMP(bytes, ==, LL_ZERO))
-        return 0;
+    // If getting the physical memory failed, arbitrarily assume
+    // 32 MB of RAM. We use a low default to have a reasonable
+    // size on all the devices we support.
+    if (bytes == 0)
+        bytes = 32 * 1024 * 1024;
 
     // Conversion from unsigned int64 to double doesn't work on all platforms.
     // We need to truncate the value at LL_MAXINT to make sure we don't
     // overflow.
     if (LL_CMP(bytes, >, LL_MAXINT))
         bytes = LL_MAXINT;
 
     PRUint64 kbytes;
diff -r 8dcf83cc8500 netwerk/cache/src/nsDiskCacheDevice.cpp
--- a/netwerk/cache/src/nsDiskCacheDevice.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/cache/src/nsDiskCacheDevice.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -545,17 +545,20 @@ nsDiskCacheDevice::DoomEntry(nsCacheEntr
     CACHE_LOG_DEBUG(("CACHE: disk DoomEntry [%p]\n", entry));
 
     nsDiskCacheBinding * binding = GetCacheEntryBinding(entry);
     NS_ASSERTION(binding, "DoomEntry: binding == nsnull");
     if (!binding)  return;
 
     if (!binding->mDoomed) {
         // so it can't be seen by FindEntry() ever again.
-        nsresult rv = mCacheMap.DeleteRecord(&binding->mRecord);
+#ifdef DEBUG
+        nsresult rv =
+#endif
+            mCacheMap.DeleteRecord(&binding->mRecord);
         NS_ASSERTION(NS_SUCCEEDED(rv),"DeleteRecord failed.");
         binding->mDoomed = PR_TRUE; // record in no longer in cache map
     }
 }
 
 
 /**
  *  NOTE: called while holding the cache service lock
@@ -680,17 +683,20 @@ nsDiskCacheDevice::OnDataSizeChange(nsCa
     NS_ASSERTION(binding->mRecord.ValidRecord(), "bad record");
 
     PRUint32  newSize = entry->DataSize() + deltaSize;
     PRUint32  newSizeK =  ((newSize + 0x3FF) >> 10);
 
     // If the new size is larger than max. file size or larger than
     // half the cache capacity (which is in KiB's), doom the entry and abort
     if ((newSize > kMaxDataFileSize) || (newSizeK > mCacheCapacity/2)) {
-        nsresult rv = nsCacheService::DoomEntry(entry);
+#ifdef DEBUG
+        nsresult rv =
+#endif
+            nsCacheService::DoomEntry(entry);
         NS_ASSERTION(NS_SUCCEEDED(rv),"DoomEntry() failed.");
         return NS_ERROR_ABORT;
     }
 
     PRUint32  sizeK = ((entry->DataSize() + 0x03FF) >> 10); // round up to next 1k
 
     NS_ASSERTION(sizeK < USHRT_MAX, "data size out of range");
     NS_ASSERTION(newSizeK < USHRT_MAX, "data size out of range");
diff -r 8dcf83cc8500 netwerk/cache/src/nsDiskCacheDeviceSQL.cpp
--- a/netwerk/cache/src/nsDiskCacheDeviceSQL.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/cache/src/nsDiskCacheDeviceSQL.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -1401,17 +1401,20 @@ nsOfflineCacheDevice::OnDataSizeChange(n
 
   mDeltaCounter += deltaSize; // this may go negative
 
   if (mDeltaCounter >= DELTA_THRESHOLD)
   {
     if (CacheSize() > mCacheCapacity) {
       // the entry will overrun the cache capacity, doom the entry
       // and abort
-      nsresult rv = nsCacheService::DoomEntry(entry);
+#ifdef DEBUG
+      nsresult rv =
+#endif
+        nsCacheService::DoomEntry(entry);
       NS_ASSERTION(NS_SUCCEEDED(rv), "DoomEntry() failed.");
       return NS_ERROR_ABORT;
     }
 
     mDeltaCounter = 0; // reset counter
   }
 
   return NS_OK;
diff -r 8dcf83cc8500 netwerk/cache/src/nsMemoryCacheDevice.cpp
--- a/netwerk/cache/src/nsMemoryCacheDevice.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/cache/src/nsMemoryCacheDevice.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -297,17 +297,20 @@ nsMemoryCacheDevice::GetFileForEntry( ns
 
 nsresult
 nsMemoryCacheDevice::OnDataSizeChange( nsCacheEntry * entry, PRInt32 deltaSize)
 {
     if (entry->IsStreamData()) {
         // we have the right to refuse or pre-evict
         PRUint32  newSize = entry->DataSize() + deltaSize;
         if ((PRInt32) newSize > mSoftLimit) {
-            nsresult rv = nsCacheService::DoomEntry(entry);
+#ifdef DEBUG
+            nsresult rv =
+#endif
+                nsCacheService::DoomEntry(entry);
             NS_ASSERTION(NS_SUCCEEDED(rv),"DoomEntry() failed.");
             return NS_ERROR_ABORT;
         }
     }
 
     // adjust our totals
     mTotalSize    += deltaSize;
     
diff -r 8dcf83cc8500 netwerk/locales/jar.mn
--- a/netwerk/locales/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/locales/jar.mn	Tue Sep 16 07:55:13 2008 -0500
@@ -1,9 +1,5 @@
 #filter substitution
 
 @AB_CD@.jar:
-#ifdef MOZ_XUL_APP
 % locale necko @AB_CD@ %locale/@AB_CD@/necko/
-#else
-* locale/@AB_CD@/necko/contents.rdf      (generic/contents.rdf)
-#endif
   locale/@AB_CD@/necko/necko.properties  (%necko.properties)
diff -r 8dcf83cc8500 netwerk/test/unit/test_bug261425.js
--- a/netwerk/test/unit/test_bug261425.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/netwerk/test/unit/test_bug261425.js	Tue Sep 16 07:55:13 2008 -0500
@@ -10,20 +10,18 @@ function run_test() {
 
   var success = false;
   try {
     newURI.spec = "http: //foo.com";
   }
   catch (e) {
     success = e.result == Cr.NS_ERROR_MALFORMED_URI;
   }
-  if (!success) {
-    // This is failing: bug 431890
-    //do_throw("We didn't throw NS_ERROR_MALFORMED_URI when a space was passed in the hostname!");
-  }
+  if (!success)
+    do_throw("We didn't throw NS_ERROR_MALFORMED_URI when a space was passed in the hostname!");
 
   success = false;
   try {
     newURI.host = " foo.com";
   }
   catch (e) {
     success = e.result == Cr.NS_ERROR_MALFORMED_URI;
   }
diff -r 8dcf83cc8500 other-licenses/branding/firefox/pref/firefox-branding.js
--- a/other-licenses/branding/firefox/pref/firefox-branding.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/other-licenses/branding/firefox/pref/firefox-branding.js	Tue Sep 16 07:55:13 2008 -0500
@@ -8,8 +8,10 @@ pref("app.update.url.details", "http://%
 pref("app.update.url.details", "http://%LOCALE%.www.mozilla.com/%LOCALE%/%APP%/releases/");
 
 // Release notes URL
 pref("app.releaseNotesURL", "http://%LOCALE%.www.mozilla.com/%LOCALE%/%APP%/%VERSION%/releasenotes/");
 
 pref("browser.search.param.yahoo-fr", "moz2");
 pref("browser.search.param.yahoo-fr-cjkt", "moz2");
 pref("browser.search.param.yahoo-f-CN", "D3_g");
+
+pref("browser.EULA.override", false); // false = Do show EULA on first start
diff -r 8dcf83cc8500 security/manager/locales/jar.mn
--- a/security/manager/locales/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/security/manager/locales/jar.mn	Tue Sep 16 07:55:13 2008 -0500
@@ -1,18 +1,13 @@
 #filter substitution
 
 @AB_CD@.jar:
-#ifdef MOZ_XUL_APP
 % locale pipnss @AB_CD@ %locale/@AB_CD@/pipnss/
 % locale pippki @AB_CD@ %locale/@AB_CD@/pippki/
-#else
-* locale/@AB_CD@/pipnss/contents.rdf          (generic/chrome/pipnss/contents.rdf)
-* locale/@AB_CD@/pippki/contents.rdf          (generic/chrome/pippki/contents.rdf)
-#endif
   locale/@AB_CD@/pipnss/pipnss.properties     (%chrome/pipnss/pipnss.properties)
   locale/@AB_CD@/pipnss/nsserrors.properties  (%chrome/pipnss/nsserrors.properties)
   locale/@AB_CD@/pipnss/security.properties   (%chrome/pipnss/security.properties)
   locale/@AB_CD@/pippki/pippki.dtd            (%chrome/pippki/pippki.dtd)
   locale/@AB_CD@/pippki/pippki.properties     (%chrome/pippki/pippki.properties)
   locale/@AB_CD@/pippki/certManager.dtd       (%chrome/pippki/certManager.dtd)
   locale/@AB_CD@/pippki/deviceManager.dtd     (%chrome/pippki/deviceManager.dtd)
   locale/@AB_CD@/pippki/validation.dtd        (%chrome/pippki/validation.dtd)
diff -r 8dcf83cc8500 security/manager/pki/resources/content/exceptionDialog.js
--- a/security/manager/pki/resources/content/exceptionDialog.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/security/manager/pki/resources/content/exceptionDialog.js	Tue Sep 16 07:55:13 2008 -0500
@@ -84,19 +84,34 @@ function initExceptionDialog() {
   
   var args = window.arguments;
   if (args && args[0]) {
     if (args[0].location) {
       // We were pre-seeded with a location.
       document.getElementById("locationTextBox").value = args[0].location;
       document.getElementById('checkCertButton').disabled = false;
       
-      // We can optionally pre-fetch the certificate too
-      if (args[0].prefetchCert)
-        checkCert();
+      // We can optionally pre-fetch the certificate too.  Don't do this
+      // synchronously, since it would prevent the window from appearing
+      // until the fetch is completed, which could be multiple seconds.
+      // Instead, let's use a timer to spawn the actual fetch, but update
+      // the dialog to "checking..." state right away, so that the UI
+      // is appropriately responsive.  We could include a very short lag
+      // and there would still be time for the window to draw, but bringing
+      // it up to a couple seconds still feels responsive, while also giving
+      // users who are unfamiliar with the dialog a chance to read the preamble
+      // before the dialog fills up with details about the certificate
+      // problems.  Bug 453855
+      if (args[0].prefetchCert) {
+        
+        gChecking = true;
+        updateCertStatus();
+        
+        window.setTimeout(checkCert, 2000);
+      }
     }
     
     // Set out parameter to false by default
     args[0].exceptionAdded = false; 
   }
 }
 
 // returns true if found and global status could be set
diff -r 8dcf83cc8500 security/manager/pki/resources/jar.mn
--- a/security/manager/pki/resources/jar.mn	Sun Sep 14 00:37:23 2008 -0700
+++ b/security/manager/pki/resources/jar.mn	Tue Sep 16 07:55:13 2008 -0500
@@ -1,14 +1,10 @@ pippki.jar:
 pippki.jar:
-#ifdef MOZ_XUL_APP
 % content pippki %content/pippki/ xpcnativewrappers=yes
-#else
-*   content/pippki/contents.rdf              (content/contents.rdf)
-#endif
     content/pippki/changepassword.xul        (content/changepassword.xul)
     content/pippki/getpassword.xul           (content/getpassword.xul)
     content/pippki/password.js               (content/password.js)
     content/pippki/resetpassword.xul         (content/resetpassword.xul)
     content/pippki/resetpassword.js          (content/resetpassword.js)
     content/pippki/certerror.js              (content/certerror.js)
 *   content/pippki/certerror.xul             (content/certerror.xul)
     content/pippki/downloadcert.js           (content/downloadcert.js)
diff -r 8dcf83cc8500 storage/src/mozStorageEvents.cpp
--- a/storage/src/mozStorageEvents.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/storage/src/mozStorageEvents.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -157,17 +157,17 @@ public:
     , mErrorObj(aErrorObj)
     , mCanceled(PR_FALSE)
     , mCompletionNotifier(aCompletionNotifier)
   {
   }
 
   NS_IMETHOD Run()
   {
-    if (!mCanceled)
+    if (!mCanceled && mCallback)
       (void)mCallback->HandleError(mErrorObj);
 
     mCompletionNotifier->completed(this);
     // It is likely that the completion notifier holds a reference to us as
     // well, so we release our reference to it here to avoid cycles.
     mCompletionNotifier = nsnull;
     return NS_OK;
   }
diff -r 8dcf83cc8500 storage/test/unit/test_storage_statement_executeAsync.js
--- a/storage/test/unit/test_storage_statement_executeAsync.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/storage/test/unit/test_storage_statement_executeAsync.js	Tue Sep 16 07:55:13 2008 -0500
@@ -296,24 +296,49 @@ function test_tuple_out_of_bounds()
       do_check_eq(Ci.mozIStorageStatementCallback.REASON_FINISHED, aReason);
       do_check_true(this.resultObtained);
       do_test_finished();
     }
   });
   stmt.finalize();
 }
 
-function test_no_listener_works()
+function test_no_listener_works_on_success()
 {
-  dump("test_no_listener_works()\n");
+  dump("test_no_listener_works_on_success()\n");
 
   var stmt = getOpenedDatabase().createStatement(
     "DELETE FROM test WHERE id = ?"
   );
   stmt.bindInt32Parameter(0, 0);
+  stmt.executeAsync();
+  stmt.finalize();
+}
+
+function test_no_listener_works_on_results()
+{
+  dump("test_no_listener_works_on_results()\n");
+
+  var stmt = getOpenedDatabase().createStatement(
+    "SELECT ?"
+  );
+  stmt.bindInt32Parameter(0, 1);
+  stmt.executeAsync();
+  stmt.finalize();
+}
+
+function test_no_listener_works_on_error()
+{
+  return;
+  dump("test_no_listener_works_on_error()\n");
+
+  // commit without a transaction will trigger an error
+  var stmt = getOpenedDatabase().createStatement(
+    "COMMIT"
+  );
   stmt.executeAsync();
   stmt.finalize();
 }
 
 function test_partial_listener_works()
 {
   dump("test_partial_listener_works()\n");
 
@@ -448,17 +473,19 @@ function test_double_execute()
   stmt.finalize();
 }
 
 var tests =
 [
   test_add_data,
   test_get_data,
   test_tuple_out_of_bounds,
-  test_no_listener_works,
+  test_no_listener_works_on_success,
+  test_no_listener_works_on_results,
+  test_no_listener_works_on_error,
   test_partial_listener_works,
   test_immediate_cancellation,
   test_double_cancellation,
   test_double_execute,
 ];
 
 function run_test()
 {
diff -r 8dcf83cc8500 testing/mochitest/browser-test.js
--- a/testing/mochitest/browser-test.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/testing/mochitest/browser-test.js	Tue Sep 16 07:55:13 2008 -0500
@@ -1,15 +1,17 @@ if (Cc === undefined) {
 if (Cc === undefined) {
   var Cc = Components.classes;
   var Ci = Components.interfaces;
 }
 window.addEventListener("load", testOnLoad, false);
 
 function testOnLoad() {
+  window.removeEventListener("load", testOnLoad, false);
+
   // Make sure to launch the test harness for the first opened window only
   var prefs = Cc["@mozilla.org/preferences-service;1"].
               getService(Ci.nsIPrefBranch);
   if (prefs.prefHasUserValue("testing.browserTestHarness.running"))
     return;
 
   prefs.setBoolPref("testing.browserTestHarness.running", true);
 
diff -r 8dcf83cc8500 testing/testsuite-targets.mk
--- a/testing/testsuite-targets.mk	Sun Sep 14 00:37:23 2008 -0700
+++ b/testing/testsuite-targets.mk	Tue Sep 16 07:55:13 2008 -0500
@@ -47,21 +47,27 @@ define CHECK_TEST_ERROR
 	  echo "$$errors"; \
 	  exit 1; \
   else \
 	  echo "$@ passed"; \
   fi
 endef
 endif
 
+ifdef TEST_PATH
+MOCHITEST_PATH = --test-path=$(TEST_PATH)
+else
+MOCHITEST_PATH =
+endif
+
 mochitest-plain:
-	$(RUN_MOCHITEST)
+	$(RUN_MOCHITEST) $(MOCHITEST_PATH)
 	$(CHECK_TEST_ERROR)
 
 mochitest-chrome:
-	$(RUN_MOCHITEST) --chrome
+	$(RUN_MOCHITEST) --chrome $(MOCHITEST_PATH)
 	$(CHECK_TEST_ERROR)
 
 mochitest-a11y:
-	$(RUN_MOCHITEST) --a11y
+	$(RUN_MOCHITEST) --a11y $(MOCHITEST_PATH)
 	$(CHECK_TEST_ERROR)
 
 .PHONY: mochitest mochitest-plain mochitest-chrome mochitest-a11y
diff -r 8dcf83cc8500 toolkit/components/microformats/src/Microformats.js
--- a/toolkit/components/microformats/src/Microformats.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/toolkit/components/microformats/src/Microformats.js	Tue Sep 16 07:55:13 2008 -0500
@@ -301,16 +301,31 @@ var Microformats = {
      * @param  propnode   The DOMNode to check
      * @param  parentnode The parent node of the property. If it is a subproperty,
      *                    this is the parent property node. If it is not, this is the
      *                    microformat node.
      & @param  datatype   HTML/text - whether to use innerHTML or innerText - defaults to text
      * @return A string with the value of the property
      */
     defaultGetter: function(propnode, parentnode, datatype) {
+      function collapseWhitespace(instring) {
+        /* Remove new lines, carriage returns and tabs */
+        outstring = instring.replace(/[\n\r\t]/gi, ' ');
+        /* Replace any double spaces with single spaces */
+        outstring = outstring.replace(/\s{2,}/gi, ' ');
+        /* Remove any double spaces that are left */
+        outstring = outstring.replace(/\s{2,}/gi, '');
+        /* Remove any spaces at the beginning */
+        outstring = outstring.replace(/^\s+/, '');
+        /* Remove any spaces at the end */
+        outstring = outstring.replace(/\s+$/, '');
+        return outstring;
+      }
+      
+      
       if (((((propnode.localName.toLowerCase() == "abbr") || (propnode.localName.toLowerCase() == "html:abbr")) && !propnode.namespaceURI) || 
          ((propnode.localName.toLowerCase() == "abbr") && (propnode.namespaceURI == "http://www.w3.org/1999/xhtml"))) && (propnode.getAttribute("title"))) {
         return propnode.getAttribute("title");
       } else if ((propnode.nodeName.toLowerCase() == "img") && (propnode.getAttribute("alt"))) {
         return propnode.getAttribute("alt");
       } else if ((propnode.nodeName.toLowerCase() == "area") && (propnode.getAttribute("alt"))) {
         return propnode.getAttribute("alt");
       } else if ((propnode.nodeName.toLowerCase() == "textarea") ||
@@ -325,40 +340,32 @@ var Microformats = {
             values.splice(i,1);
           }
         }
         if (values.length > 0) {
           var value = "";
           for (let j=0;j<values.length;j++) {
             value += Microformats.parser.defaultGetter(values[j], propnode, datatype);
           }
-          return value;
+          return collapseWhitespace(value);
         }
         var s;
         if (datatype == "HTML") {
           s = propnode.innerHTML;
         } else {
           if (propnode.innerText) {
             s = propnode.innerText;
           } else {
             s = propnode.textContent;
           }
         }
-        /* If we are processing a value node, don't remove whitespace */
+        /* If we are processing a value node, don't remove whitespace now */
+        /* (we'll do it later) */
         if (!Microformats.matchClass(propnode, "value")) {
-          /* Remove new lines, carriage returns and tabs */
-          s	= s.replace(/[\n\r\t]/gi, ' ');
-          /* Replace any double spaces with single spaces */
-          s	= s.replace(/\s{2,}/gi, ' ');
-          /* Remove any double spaces that are left */
-          s	= s.replace(/\s{2,}/gi, '');
-          /* Remove any spaces at the beginning */
-          s	= s.replace(/^\s+/, '');
-          /* Remove any spaces at the end */
-          s	= s.replace(/\s+$/, '');
+          s = collapseWhitespace(s);
         }
         if (s.length > 0) {
           return s;
         }
       }
     },
     /**
      * Used to specifically retrieve a date in a microformat node.
@@ -489,18 +496,18 @@ var Microformats = {
      *                    microformat node.
      * @return An emulated string object that also has a new function called toHTML
      */
     HTMLGetter: function(propnode, parentnode) {
       /* This is so we can have a string that behaves like a string */
       /* but also has a new function that can return the HTML that corresponds */
       /* to the string. */
       function mfHTML(value) {
-        this.valueOf = function() {return value.valueOf();}
-        this.toString = function() {return value.toString();}
+        this.valueOf = function() {return value ? value.valueOf() : "";}
+        this.toString = function() {return value ? value.toString() : "";}
       }
       mfHTML.prototype = new String;
       mfHTML.prototype.toHTML = function() {
         return Microformats.parser.defaultGetter(propnode, parentnode, "HTML");
       }
       return new mfHTML(Microformats.parser.defaultGetter(propnode, parentnode, "text"));
     },
     /**
@@ -790,49 +797,53 @@ var Microformats = {
      *
      * @param  in_mfnode The node to preProcess.
      * @return If the node had includes or headers, a cloned node otherwise
      *         the original node. You can check to see if the node was cloned
      *         by looking for .origNode in the new node.
      */
     preProcessMicroformat: function preProcessMicroformat(in_mfnode) {
       var mfnode;
-      var includes = Microformats.getElementsByClassName(in_mfnode, "include");
-      if ((includes.length > 0) || ((in_mfnode.nodeName.toLowerCase() == "td") && (in_mfnode.getAttribute("headers")))) {
+      if ((in_mfnode.nodeName.toLowerCase() == "td") && (in_mfnode.getAttribute("headers"))) {
         mfnode = in_mfnode.cloneNode(true);
         mfnode.origNode = in_mfnode;
-        if (includes.length > 0) {
-          includes = Microformats.getElementsByClassName(mfnode, "include");
-          var includeId;
-          var include_length = includes.length;
-          for (let i = include_length -1; i >= 0; i--) {
-            if (includes[i].nodeName.toLowerCase() == "a") {
-              includeId = includes[i].getAttribute("href").substr(1);
-            }
-            if (includes[i].nodeName.toLowerCase() == "object") {
-              includeId = includes[i].getAttribute("data").substr(1);
-            }
-            if (in_mfnode.ownerDocument.getElementById(includeId)) {
-              includes[i].parentNode.replaceChild(in_mfnode.ownerDocument.getElementById(includeId).cloneNode(true), includes[i]);
-            }
-          }
-        } else {
-          var headers = in_mfnode.getAttribute("headers").split(" ");
-          for (let i = 0; i < headers.length; i++) {
-            var tempNode = in_mfnode.ownerDocument.createElement("span");
-            var headerNode = in_mfnode.ownerDocument.getElementById(headers[i]);
-            if (headerNode) {
-              tempNode.innerHTML = headerNode.innerHTML;
-              tempNode.className = headerNode.className;
-              mfnode.appendChild(tempNode);
-            }
+        var headers = in_mfnode.getAttribute("headers").split(" ");
+        for (let i = 0; i < headers.length; i++) {
+          var tempNode = in_mfnode.ownerDocument.createElement("span");
+          var headerNode = in_mfnode.ownerDocument.getElementById(headers[i]);
+          if (headerNode) {
+            tempNode.innerHTML = headerNode.innerHTML;
+            tempNode.className = headerNode.className;
+            mfnode.appendChild(tempNode);
           }
         }
       } else {
         mfnode = in_mfnode;
+      }
+      var includes = Microformats.getElementsByClassName(mfnode, "include");
+      if (includes.length > 0) {
+        /* If we didn't clone, clone now */
+        if (!mfnode.origNode) {
+          mfnode = in_mfnode.cloneNode(true);
+          mfnode.origNode = in_mfnode;
+        }
+        includes = Microformats.getElementsByClassName(mfnode, "include");
+        var includeId;
+        var include_length = includes.length;
+        for (let i = include_length -1; i >= 0; i--) {
+          if (includes[i].nodeName.toLowerCase() == "a") {
+            includeId = includes[i].getAttribute("href").substr(1);
+          }
+          if (includes[i].nodeName.toLowerCase() == "object") {
+            includeId = includes[i].getAttribute("data").substr(1);
+          }
+          if (in_mfnode.ownerDocument.getElementById(includeId)) {
+            includes[i].parentNode.replaceChild(in_mfnode.ownerDocument.getElementById(includeId).cloneNode(true), includes[i]);
+          }
+        }
       }
       return mfnode;
     },
     validate: function validate(mfnode, mfname) {
       var error = "";
       if (Microformats[mfname].validate) {
         return Microformats[mfname].validate(mfnode);
       } else if (Microformats[mfname].required) {
diff -r 8dcf83cc8500 toolkit/components/microformats/tests/test_Microformats.html
--- a/toolkit/components/microformats/tests/test_Microformats.html	Sun Sep 14 00:37:23 2008 -0700
+++ b/toolkit/components/microformats/tests/test_Microformats.html	Tue Sep 16 07:55:13 2008 -0500
@@ -89,16 +89,79 @@
     <div class="vcard">
       <span class="description">
         <span class="fn org">Mozilla</span>'s Birthday
       </span>
     </div>
     <span class="dtstart">1998-01-22</span>
   </div>
   
+<div class="vcard" id="valuespace_1">
+<span class="fn">
+<span class="value">John</span>
+<span class="value"> </span>
+<span class="value">Doe</span>
+</span>
+</div>
+<div class="vcard" id="valuespace_2">
+<span class="fn">
+<span class="value">John</span>
+<span class="value">    </span>
+<span class="value">Doe</span>
+</span>
+</div>
+<div class="vcard" id="valuespace_3">
+<span class="fn">
+<span class="value">  John</span>
+<span class="value">    </span>
+<span class="value">Doe  </span>
+</span>
+</div>
+<div class="vcard" id="valuespace_4">
+<span class="fn">
+<span class="value">John    </span>
+<span class="value">    Doe</span>
+</span>
+</div>
+<div class="vcard" id="valuespace_5">
+<span class="fn">
+<span class="value">    John</span>
+<span class="value">    Doe    </span>
+</span>
+<div class="vcard" id="valuespace_6">
+<span class="fn">
+<span class="value">John
+</span>
+<span class="value">
+Doe</span>
+</span>
+</div>
+<div class="vcard" id="valuespace_7">
+<span class="fn">
+<span class="value">John</span>
+<span class="value">Doe</span>
+</span>
+</div>
+ 
+  <span id="austin" class="location">Austin - Sixth Street</span>
+  <table summary="Timetable">
+    <thead>
+      <tr>
+        <th id="location-1"><a href="#austin" class="include"></a>New York</th>
+      </tr>
+    </thead>
+    <tbody>
+      <tr>
+        <th id="time-1"><abbr title="2008-01-01" class="dtstart">Jan 1, 2008</abbr></th>
+        <td id="nested_header_include" class="vevent" headers="time-1 location-1"><div class="summary">New Years Party</div></td>
+      </tr>
+    </tbody>
+  </table>
+
+ 
 </div>
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
 test_Microformats();
 test_hCard();
 
 function test_Microformats() {
@@ -159,16 +222,37 @@ function test_Microformats() {
   
   var dateCal = new hCalendar(document.getElementById("date_vcal"));
   jsdate = Microformats.dateFromISO8601(dateCal.dtstart);
   origdate = Microformats.iso8601FromDate(jsdate, true);
   is(dateCal.dtstart, origdate, "date round trip");
 
   var dateCal = new hCalendar(document.getElementById("vcal_vcard"));
   is(dateCal.description, "Mozilla's Birthday", "vcard in vcal");
+
+  var nestedCal = new hCalendar(document.getElementById("nested_header_include"));
+  is(nestedCal.dtstart, "2008-01-01", "nested_header_include - dtstart");
+  is(nestedCal.location, "Austin - Sixth Street", "nested_header_include - location");
+  is(nestedCal.summary, "New Years Party", "nested_header_include - summary");
+
+  var valueCard = new hCard(document.getElementById("valuespace_1"));
+  is(valueCard.fn, "John Doe", "valuespace_1");
+  var valueCard = new hCard(document.getElementById("valuespace_2"));
+  is(valueCard.fn, "John Doe", "valuespace_2");
+  var valueCard = new hCard(document.getElementById("valuespace_3"));
+  is(valueCard.fn, "John Doe", "valuespace_3");
+  var valueCard = new hCard(document.getElementById("valuespace_4"));
+  is(valueCard.fn, "John Doe", "valuespace_4");
+  var valueCard = new hCard(document.getElementById("valuespace_5"));
+  is(valueCard.fn, "John Doe", "valuespace_5");
+  var valueCard = new hCard(document.getElementById("valuespace_6"));
+  is(valueCard.fn, "John Doe", "valuespace_6");
+  var valueCard = new hCard(document.getElementById("valuespace_7"));
+  is(valueCard.fn, "JohnDoe", "valuespace_7");
+
 }
 
 function test_hCard() {
   netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
 
   Components.utils.import("resource://gre/modules/Microformats.js");
   
   var hCards = Microformats.get("hCard", document.getElementById("test_1"),  {showHidden: true}); 
diff -r 8dcf83cc8500 toolkit/components/microformats/tests/test_Microformats_hCalendar.html
--- a/toolkit/components/microformats/tests/test_Microformats_hCalendar.html	Sun Sep 14 00:37:23 2008 -0700
+++ b/toolkit/components/microformats/tests/test_Microformats_hCalendar.html	Tue Sep 16 07:55:13 2008 -0500
@@ -169,16 +169,21 @@
           <ul>
               <li><a class="attach" href="http://microformats.org/img/logo.gif">microformats logo</a></li>
               <li><a class="attach" type="application/postscript" href="ftp://xyzCorp.com/pub/conf/bkgrnd.ps">ftp://xyzCorp.com/pub/conf/bkgrnd.ps</a></li>
           </ul>
       </div>
     </div>
   </div>
 
+  <div class="vevent" id="empty-description">
+    <span class="description"></span>
+  </div>
+
+
 </div>
 
 <pre id="test">
 <script class="testbody" type="text/javascript">
 
 test_Microformats();
 test_hCard();
 
@@ -290,14 +295,17 @@ function test_hCard() {
 
   hcalendar = new hCalendar(document.getElementById("18-component-vevent-uid.3"));
 
   hcalendar = new hCalendar(document.getElementById("18-component-vevent-uid.4"));
 
   hcalendar = new hCalendar(document.getElementById("18-component-vevent-uid.5"));
 
   hcalendar = new hCalendar(document.getElementById("19-calendar-attachments"));
+
+  hcalendar = new hCalendar(document.getElementById("empty-description"));
+  is (hcalendar.description, "", "Empty description");
 }
 
 </script>
 </pre>
 </body>
 </html>
diff -r 8dcf83cc8500 toolkit/components/viewsource/content/viewSourceUtils.js
--- a/toolkit/components/viewsource/content/viewSourceUtils.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/toolkit/components/viewsource/content/viewSourceUtils.js	Tue Sep 16 07:55:13 2008 -0500
@@ -166,38 +166,36 @@ var gViewSourceUtils = {
     } else if (aCallBack) {
       aCallBack(result, data);
     }
   },
 
   // Returns nsIProcess of the external view source editor or null
   getExternalViewSourceEditor: function()
   {
-    var editor = null;
-    var viewSourceAppPath = null;
     try {
-      var prefs = Components.classes["@mozilla.org/preferences-service;1"]
-                            .getService(Components.interfaces.nsIPrefBranch);
-      var prefPath = prefs.getCharPref("view_source.editor.path");
-      if (prefPath.length > 0) {
-        viewSourceAppPath = Components.classes["@mozilla.org/file/local;1"]
-                                      .createInstance(Components.interfaces.nsILocalFile);
-        viewSourceAppPath.initWithPath(prefPath);
-        // it's gotta be executable
-        if (viewSourceAppPath.exists() && viewSourceAppPath.isExecutable()) {
-          editor = Components.classes['@mozilla.org/process/util;1']
+      let prefPath =
+          Components.classes["@mozilla.org/preferences-service;1"]
+                    .getService(Components.interfaces.nsIPrefBranch)
+                    .getCharPref("view_source.editor.path");
+      let viewSourceAppPath =
+              Components.classes["@mozilla.org/file/local;1"]
+                        .createInstance(Components.interfaces.nsILocalFile);
+      viewSourceAppPath.initWithPath(prefPath);
+      let editor = Components.classes['@mozilla.org/process/util;1']
                              .createInstance(Components.interfaces.nsIProcess);
-          editor.init(viewSourceAppPath);
-        }
-      }
+      editor.init(viewSourceAppPath);
+
+      return editor;
     }
     catch (ex) {
       Components.utils.reportError(ex);
     }
-    return editor;
+
+    return null;
   },
 
   viewSourceProgressListener: {
 
     mnsIWebProgressListener: Components.interfaces.nsIWebProgressListener,
 
     QueryInterface: function(aIID) {
      if (aIID.equals(this.mnsIWebProgressListener) ||
diff -r 8dcf83cc8500 toolkit/mozapps/extensions/test/unit/test_bug299716.js
--- a/toolkit/mozapps/extensions/test/unit/test_bug299716.js	Sun Sep 14 00:37:23 2008 -0700
+++ b/toolkit/mozapps/extensions/test/unit/test_bug299716.js	Tue Sep 16 07:55:13 2008 -0500
@@ -30,30 +30,16 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL
  *
  * ***** END LICENSE BLOCK *****
  */
-
-/* XXX ajvincent XPCOM_DEBUG_BREAK automatically causes a xpcshell test to crash
-   if a NS_ASSERTION fires.  However, the assertions this testcase triggers are
-   unrelated to the actual test, and the component this test runs against is
-   JavaScript-based - so assertions here do not apply against the tested
-   component.  I am (reluctantly) turning the assertions into stack warnings in
-   order to prevent test failures at this point which are not the fault of the
-   code being tested or the test script.
-
-   At present, the assertions fired are for calls which aren't thread-safe.
-*/
-var env = Components.classes["@mozilla.org/process/environment;1"]
-                    .getService(Components.interfaces.nsIEnvironment);
-env.set("XPCOM_DEBUG_BREAK", "stack");
 
 // Disables security checking our updates which haven't been signed
 gPrefs.setBoolPref("extensions.checkUpdateSecurity", false);
 
 // This allows the EM to attempt to display errors to the user without failing.
 var promptService = {
   // nsIPromptService
   alert: function alert(aParent,
@@ -463,12 +449,9 @@ function run_test_pt4() {
   dump("\n\n*** FINAL CHECKS\n\n");
   for (var i = 0; i < ADDONS.length; i++) {
     var item = gEM.getItemForID(ADDONS[i].id);
     do_check_item(item, "0.2", ADDONS[i]);
   }
   do_test_finished();
 
   testserver.stop();
-
-  // If we've gotten this far, then the test has passed.
-  env.set("XPCOM_DEBUG_BREAK", "abort");
 }
diff -r 8dcf83cc8500 toolkit/themes/pinstripe/mozapps/plugins/missingPlugin.css
--- a/toolkit/themes/pinstripe/mozapps/plugins/missingPlugin.css	Sun Sep 14 00:37:23 2008 -0700
+++ b/toolkit/themes/pinstripe/mozapps/plugins/missingPlugin.css	Tue Sep 16 07:55:13 2008 -0500
@@ -1,14 +1,26 @@
 /*
  * This file's style only applies to broken objects, not the rest
  * of the page.
  */
 
 @namespace html url(http://www.w3.org/1999/xhtml);
+
+html|object:not([width]), html|object[width=""],
+html|embed:not([width]), html|embed[width=""],
+html|applet:not([width]), html|applet[width=""] {
+  width: 240px;
+}
+
+html|object:not([height]), html|object[height=""],
+html|embed:not([height]), html|embed[height=""],
+html|applet:not([height]), html|applet[height=""] {
+  height: 200px;
+}
 
 html|object > *|*,
 html|embed > *|*,
 html|applet > *|* {
   width: inherit;
   height: inherit;
 }
 
diff -r 8dcf83cc8500 toolkit/xre/Makefile.in
--- a/toolkit/xre/Makefile.in	Sun Sep 14 00:37:23 2008 -0700
+++ b/toolkit/xre/Makefile.in	Tue Sep 16 07:55:13 2008 -0500
@@ -96,27 +96,23 @@ XPIDLSRCS += nsIWinAppHelper.idl
 XPIDLSRCS += nsIWinAppHelper.idl
 endif
 
 EXPORTS = \
 	xrecore.h \
 	nsXULAppAPI.h \
 	$(NULL)
 
-SHAREDCPPSRCS = \
-	showOSAlert.cpp \
-	$(NULL)
-
 CPPSRCS = \
-	$(SHAREDCPPSRCS) \
 	nsAppRunner.cpp \
 	nsConsoleWriter.cpp \
 	nsXREDirProvider.cpp \
 	nsNativeAppSupportBase.cpp \
 	nsAppData.cpp \
+	showOSAlert.cpp \
 	$(NULL)
 
 DEFINES += -DIMPL_XREAPI
 
 ifndef BUILD_STATIC_LIBS
 CPPSRCS += nsEmbedFunctions.cpp
 endif
 
@@ -159,22 +155,17 @@ OS_CXXFLAGS += -fexceptions
 OS_CXXFLAGS += -fexceptions
 SHARED_LIBRARY_LIBS += $(DEPTH)/xpfe/bootstrap/appleevents/$(LIB_PREFIX)appleevents_s.$(LIB_SUFFIX)
 endif
 ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
 CMMSRCS += MacApplicationDelegate.mm
 endif
 
 ifneq (,$(filter-out OS2 WINNT,$(OS_ARCH)))
-SHAREDCPPSRCS	  += nsSigHandlers.cpp
-endif
-
-GARBAGE += $(SHAREDCPPSRCS) $(wildcard *.$(OBJ_SUFFIX))
-ifneq (,$(filter WINCE WINNT,$(OS_ARCH)))
-GARBAGE	+= $(addprefix $(srcdir)/,$(SHAREDCPPSRCS))
+CPPSRCS	  += nsSigHandlers.cpp
 endif
 
 SHARED_LIBRARY_LIBS += ../profile/src/$(LIB_PREFIX)profile_s.$(LIB_SUFFIX)
 
 ifdef MOZ_ENABLE_XREMOTE
 SHARED_LIBRARY_LIBS += $(DEPTH)/widget/src/xremoteclient/$(LIB_PREFIX)xremote_client_s.$(LIB_SUFFIX)
 LOCAL_INCLUDES += -I$(topsrcdir)/widget/src/xremoteclient
 endif
@@ -251,19 +242,16 @@ endif
 endif
 
 ifeq ($(OS_ARCH),Linux)
 ifneq (,$(findstring lib64,$(libdir)))
 DEFINES     += -DHAVE_USR_LIB64_DIR
 endif
 endif
 
-export:: $(addprefix $(topsrcdir)/xpfe/bootstrap/, $(SHAREDCPPSRCS))
-	$(INSTALL) $^ .
-
 platform.ini: FORCE
 	$(PYTHON) $(srcdir)/make-platformini.py --buildid=$(shell cat $(DEPTH)/config/buildid) $(topsrcdir)/config/milestone.txt > $@
 
 GARBAGE += platform.ini
 
 libs:: platform.ini
 	$(INSTALL) $^ $(DIST)/bin
 
diff -r 8dcf83cc8500 toolkit/xre/nsSigHandlers.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/xre/nsSigHandlers.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,289 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Jerry.Kirk@Nexwarecorp.com
+ *   Chris Seawood <cls@seawood.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * This module is supposed to abstract signal handling away from the other
+ * platforms that do not support it.
+ */
+
+#include <signal.h>
+#include <stdio.h>
+#include <string.h>
+#include "prthread.h"
+#include "plstr.h"
+#include "prenv.h"
+#include "nsDebug.h"
+
+#if defined(LINUX)
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <unistd.h>
+#include <stdlib.h> // atoi
+#endif
+
+#if defined(SOLARIS)
+#include <sys/resource.h>
+#endif
+
+#ifdef XP_BEOS
+#include <be/app/Application.h>
+#include <string.h>
+#include "nsCOMPtr.h"
+#include "nsIServiceManager.h"
+#include "nsIAppStartup.h"
+#include "nsXPFEComponentsCID.h"
+#endif
+
+#ifdef MOZ_WIDGET_PHOTON
+#include <photon/PhProto.h>
+#endif
+
+static char _progname[1024] = "huh?";
+static unsigned int _gdb_sleep_duration = 300;
+
+#if defined(LINUX) && defined(DEBUG) && \
+      (defined(__i386) || defined(__x86_64) || defined(PPC))
+#define CRAWL_STACK_ON_SIGSEGV
+#endif
+
+#ifdef MOZ_WIDGET_PHOTON
+void abnormal_exit_handler(int signum)
+{
+  /* Free any shared memory that has been allocated */
+  PgShmemCleanup();
+
+#if defined(DEBUG)
+  if (    (signum == SIGSEGV)
+       || (signum == SIGILL)
+       || (signum == SIGABRT)
+       || (signum == SIGFPE)
+     )
+  {
+    printf("prog = %s\npid = %d\nsignal = %s\n", 
+           _progname, getpid(), strsignal(signum));
+
+    printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
+    printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
+           _progname, getpid());
+
+    sleep(_gdb_sleep_duration);
+
+    printf("Done sleeping...\n");
+  }
+#endif
+
+  _exit(1);
+}
+#elif defined(CRAWL_STACK_ON_SIGSEGV)
+
+#include <unistd.h>
+#include "nsISupportsUtils.h"
+#include "nsStackWalk.h"
+
+extern "C" {
+
+PR_STATIC_CALLBACK(void) PrintStackFrame(void *aPC, void *aClosure)
+{
+  char buf[1024];
+  nsCodeAddressDetails details;
+
+  NS_DescribeCodeAddress(aPC, &details);
+  NS_FormatCodeAddressDetails(aPC, &details, buf, sizeof(buf));
+  fprintf(stdout, buf);
+}
+
+}
+
+void
+ah_crap_handler(int signum)
+{
+  printf("\nProgram %s (pid = %d) received signal %d.\n",
+         _progname,
+         getpid(),
+         signum);
+
+  printf("Stack:\n");
+  NS_StackWalk(PrintStackFrame, 2, nsnull);
+
+  printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
+  printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
+         _progname,
+         getpid());
+
+  sleep(_gdb_sleep_duration);
+
+  printf("Done sleeping...\n");
+}
+#endif // CRAWL_STACK_ON_SIGSEGV
+
+#ifdef XP_BEOS
+void beos_signal_handler(int signum) {
+#ifdef DEBUG
+	fprintf(stderr, "beos_signal_handler: %d\n", signum);
+#endif
+	nsresult rv;
+	nsCOMPtr<nsIAppStartup> appStartup(do_GetService(NS_APPSTARTUP_CONTRACTID, &rv));
+	if (NS_FAILED(rv)) {
+		// Failed to get the appstartup service so shutdown the hard way
+#ifdef DEBUG
+		fprintf(stderr, "beos_signal_handler: appShell->do_GetService() failed\n");
+#endif
+		exit(13);
+	}
+
+	// Exit the appshell so that the app can shutdown normally
+	appStartup->Quit(nsIAppStartup::eAttemptQuit);
+}
+#endif
+
+#ifdef MOZ_WIDGET_GTK2
+// Need this include for version test below.
+#include <glib.h>
+#endif
+
+#if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
+
+static GLogFunc orig_log_func = NULL;
+
+extern "C" {
+static void
+my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
+                 const gchar *message, gpointer user_data);
+}
+
+/* static */ void
+my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
+                 const gchar *message, gpointer user_data)
+{
+  if (log_level & (G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION)) {
+    NS_DebugBreak(NS_DEBUG_ASSERTION, message, "glib assertion", __FILE__, __LINE__);
+  } else if (log_level & (G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)) {
+    NS_DebugBreak(NS_DEBUG_WARNING, message, "glib warning", __FILE__, __LINE__);
+  }
+
+  orig_log_func(log_domain, log_level, message, NULL);
+}
+
+#endif
+
+void InstallUnixSignalHandlers(const char *ProgramName)
+{
+  PL_strncpy(_progname,ProgramName, (sizeof(_progname)-1) );
+
+  const char *gdbSleep = PR_GetEnv("MOZ_GDB_SLEEP");
+  if (gdbSleep && *gdbSleep)
+  {
+    unsigned int s;
+    if (1 == sscanf(gdbSleep, "%u", &s)) {
+      _gdb_sleep_duration = s;
+    }
+  }
+
+#if defined(MOZ_WIDGET_PHOTON)
+ /* Neutrino need this to free shared memory in case of a crash */
+  signal(SIGTERM, abnormal_exit_handler);
+  signal(SIGQUIT, abnormal_exit_handler);
+  signal(SIGINT,  abnormal_exit_handler);
+  signal(SIGHUP,  abnormal_exit_handler);
+  signal(SIGSEGV, abnormal_exit_handler);
+  signal(SIGILL,  abnormal_exit_handler);
+  signal(SIGABRT, abnormal_exit_handler);
+  signal(SIGFPE,  abnormal_exit_handler);
+
+#elif defined(CRAWL_STACK_ON_SIGSEGV)
+  signal(SIGSEGV, ah_crap_handler);
+  signal(SIGILL, ah_crap_handler);
+  signal(SIGABRT, ah_crap_handler);
+  signal(SIGFPE, ah_crap_handler);
+#endif // CRAWL_STACK_ON_SIGSEGV
+
+#if defined(DEBUG) && defined(LINUX)
+  const char *memLimit = PR_GetEnv("MOZ_MEM_LIMIT");
+  if (memLimit && *memLimit)
+  {
+    long m = atoi(memLimit);
+    m *= (1024*1024);
+    struct rlimit r;
+    r.rlim_cur = m;
+    r.rlim_max = m;
+    setrlimit(RLIMIT_AS, &r);
+  }
+#endif
+
+#if defined(SOLARIS)
+#define NOFILES 512
+
+    // Boost Solaris file descriptors
+    {
+	struct rlimit rl;
+	
+	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
+
+	    if (rl.rlim_cur < NOFILES) {
+		rl.rlim_cur = NOFILES;
+
+		if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
+		    perror("setrlimit(RLIMIT_NOFILE)");
+		    fprintf(stderr, "Cannot exceed hard limit for open files");
+		}
+#if defined(DEBUG)
+	    	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
+		    printf("File descriptors set to %d\n", rl.rlim_cur);
+#endif //DEBUG
+	    }
+    }
+#endif //SOLARIS
+
+#ifdef XP_BEOS
+	signal(SIGTERM, beos_signal_handler);
+#endif
+
+#if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
+  const char *assertString = PR_GetEnv("XPCOM_DEBUG_BREAK");
+  if (assertString &&
+      (!strcmp(assertString, "suspend") ||
+       !strcmp(assertString, "stack") ||
+       !strcmp(assertString, "abort") ||
+       !strcmp(assertString, "trap") ||
+       !strcmp(assertString, "break"))) {
+    // Override the default glib logging function so we get stacks for it too.
+    orig_log_func = g_log_set_default_handler(my_glib_log_func, NULL);
+  }
+#endif
+}
diff -r 8dcf83cc8500 toolkit/xre/showOSAlert.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/toolkit/xre/showOSAlert.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Communicator client code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Don Bragg <dbragg@netscape.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include  <stdio.h>
+#include  <string.h>
+#include "nscore.h"
+
+//defines and includes for previous installation cleanup process
+#if defined (XP_WIN)
+#include <windows.h>
+#elif defined (XP_MAC)
+#include <Dialogs.h>
+#include <TextUtils.h>
+#elif defined (XP_OS2)
+#define INCL_DOS
+#define INCL_WIN
+#include <os2.h>
+#endif
+
+extern "C" void ShowOSAlert(const char* aMessage);
+
+
+// The maximum allowed length of aMessage is 255 characters!
+void ShowOSAlert(const char* aMessage)
+{
+#ifdef DEBUG_dbragg
+printf("\n****Inside ShowOSAlert ***\n");	
+#endif 
+
+    const PRInt32 max_len = 255;
+    char message_copy[max_len+1] = { 0 };
+    PRInt32 input_len = strlen(aMessage);
+    PRInt32 copy_len = (input_len > max_len) ? max_len : input_len;
+    strncpy(message_copy, aMessage, copy_len);
+    message_copy[copy_len] = 0;
+
+#if defined (XP_WIN)
+    MessageBoxA(NULL, message_copy, NULL, MB_OK | MB_ICONERROR | MB_SETFOREGROUND );
+#elif (XP_MAC)
+    short buttonClicked;
+    StandardAlert(kAlertStopAlert, c2pstr(message_copy), nil, nil, &buttonClicked);
+#elif defined (XP_OS2)
+    /* Set our app to be a PM app before attempting Win calls */
+    PPIB ppib;
+    PTIB ptib;
+    DosGetInfoBlocks(&ptib, &ppib);
+    ppib->pib_ultype = 3;
+    HAB hab = WinInitialize(0);
+    HMQ hmq = WinCreateMsgQueue(hmq,0);
+    WinMessageBox( HWND_DESKTOP, HWND_DESKTOP, message_copy, "", 0, MB_OK);
+    WinDestroyMsgQueue(hmq);
+    WinTerminate(hab);
+#endif
+    // It can't hurt to display the message on the console in any case,
+    // even if we have already tried to display it in a GUI window.
+    fprintf(stdout, "%s\n", aMessage);
+}
diff -r 8dcf83cc8500 widget/src/cocoa/nsChildView.mm
--- a/widget/src/cocoa/nsChildView.mm	Sun Sep 14 00:37:23 2008 -0700
+++ b/widget/src/cocoa/nsChildView.mm	Tue Sep 16 07:55:13 2008 -0500
@@ -3105,16 +3105,20 @@ NSEvent* gLastDragEvent = nil;
   if (![self ensureCorrectMouseEventTarget:theEvent])
     return;
 
   if (!mGeckoChild)
     return;
 
   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
+  if ([theEvent modifierFlags] & NSControlKeyMask)
+    geckoEvent.button = nsMouseEvent::eRightButton;
+  else
+    geckoEvent.button = nsMouseEvent::eLeftButton;
 
   // create native EventRecord for use by plugins
   EventRecord macEvent;
   macEvent.what = mouseUp;
   macEvent.message = 0;
   macEvent.when = ::TickCount();
   ::GetGlobalMouse(&macEvent.where);
   macEvent.modifiers = ::GetCurrentEventKeyModifiers();
diff -r 8dcf83cc8500 widget/src/gtk2/nsNativeThemeGTK.cpp
--- a/widget/src/gtk2/nsNativeThemeGTK.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/widget/src/gtk2/nsNativeThemeGTK.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -125,17 +125,17 @@ nsNativeThemeGTK::RefreshWidgetWindow(ns
   nsIViewManager* vm = shell->GetViewManager();
   if (!vm)
     return;
  
   vm->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
 }
 
 static PRBool IsWidgetTypeDisabled(PRUint8* aDisabledVector, PRUint8 aWidgetType) {
-  return aDisabledVector[aWidgetType >> 3] & (1 << (aWidgetType & 7));
+  return (aDisabledVector[aWidgetType >> 3] & (1 << (aWidgetType & 7))) != 0;
 }
 
 static void SetWidgetTypeDisabled(PRUint8* aDisabledVector, PRUint8 aWidgetType) {
   aDisabledVector[aWidgetType >> 3] |= (1 << (aWidgetType & 7));
 }
 
 static inline PRUint16
 GetWidgetStateKey(PRUint8 aWidgetType, GtkWidgetState *aWidgetState)
@@ -148,17 +148,17 @@ GetWidgetStateKey(PRUint8 aWidgetType, G
           aWidgetType << 5);
 }
 
 static PRBool IsWidgetStateSafe(PRUint8* aSafeVector,
                                 PRUint8 aWidgetType,
                                 GtkWidgetState *aWidgetState)
 {
   PRUint8 key = GetWidgetStateKey(aWidgetType, aWidgetState);
-  return aSafeVector[key >> 3] & (1 << (key & 7));
+  return (aSafeVector[key >> 3] & (1 << (key & 7))) != 0;
 }
 
 static void SetWidgetStateSafe(PRUint8 *aSafeVector,
                                PRUint8 aWidgetType,
                                GtkWidgetState *aWidgetState)
 {
   PRUint8 key = GetWidgetStateKey(aWidgetType, aWidgetState);
   aSafeVector[key >> 3] |= (1 << (key & 7));
diff -r 8dcf83cc8500 widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/widget/src/gtk2/nsWindow.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -285,16 +285,19 @@ static PRBool                      gCons
 
 #ifdef USE_XIM
 
 static nsWindow    *gIMEFocusWindow = NULL;
 static GdkEventKey *gKeyEvent = NULL;
 static PRBool       gKeyEventCommitted = PR_FALSE;
 static PRBool       gKeyEventChanged = PR_FALSE;
 static PRBool       gIMESuppressCommit = PR_FALSE;
+#ifdef MOZ_PLATFORM_HILDON
+static PRBool       gIMEVirtualKeyboardOpened = PR_FALSE;
+#endif
 
 static void IM_commit_cb              (GtkIMContext *aContext,
                                        const gchar *aString,
                                        nsWindow *aWindow);
 static void IM_commit_cb_internal     (const gchar *aString,
                                        nsWindow *aWindow);
 static void IM_preedit_changed_cb     (GtkIMContext *aContext,
                                        nsWindow *aWindow);
@@ -2790,16 +2793,27 @@ void
 void
 nsWindow::OnVisibilityNotifyEvent(GtkWidget *aWidget,
                                   GdkEventVisibility *aEvent)
 {
     switch (aEvent->state) {
     case GDK_VISIBILITY_UNOBSCURED:
     case GDK_VISIBILITY_PARTIAL:
         mIsVisible = PR_TRUE;
+#ifdef MOZ_PLATFORM_HILDON
+#ifdef USE_XIM
+        // In Hildon/Maemo, a browser window will get into 'patially visible' state wheneven an
+        // autocomplete feature is dropped down (from urlbar or from an entry form completion),
+        // and there are no much further ways for that to happen in the plaftorm. In such cases, if hildon
+        // virtual keyboard is up, we can not grab focus to any dropdown list. Reason: nsWindow::EnsureGrabs()
+        // calls gdk_pointer_grab() which grabs the pointer (usually a mouse) so that all events are passed
+        // to this it until the pointer is ungrabbed.
+        if(!gIMEVirtualKeyboardOpened)
+#endif // USE_XIM
+#endif // MOZ_PLATFORM_HILDON
         // if we have to retry the grab, retry it.
         EnsureGrabs();
         break;
     default: // includes GDK_VISIBILITY_FULLY_OBSCURED
         mIsVisible = PR_FALSE;
         break;
     }
 }
@@ -3568,17 +3582,17 @@ nsWindow::NativeCreate(nsIWidget        
 #ifdef ACCESSIBILITY
     nsresult rv;
     if (!sAccessibilityChecked) {
         sAccessibilityChecked = PR_TRUE;
 
         //check if accessibility enabled/disabled by environment variable
         const char *envValue = PR_GetEnv(sAccEnv);
         if (envValue) {
-            sAccessibilityEnabled = atoi(envValue);
+            sAccessibilityEnabled = atoi(envValue) != 0;
             LOG(("Accessibility Env %s=%s\n", sAccEnv, envValue));
         }
         //check gconf-2 setting
         else {
             nsCOMPtr<nsIPrefBranch> sysPrefService =
                 do_GetService(sSysPrefService, &rv);
             if (NS_SUCCEEDED(rv) && sysPrefService) {
 
@@ -6115,20 +6129,23 @@ nsWindow::SetIMEEnabled(PRUint32 aState)
         }
 
         mIMEData->mEnabled = aState;
 
         // Even when aState is not PR_TRUE, we need to set IME focus.
         // Because some IMs are updating the status bar of them in this time.
         focusedWin->IMESetFocus();
 #ifdef MOZ_PLATFORM_HILDON
-        if (mIMEData->mEnabled)
+        if (mIMEData->mEnabled) {
+            gIMEVirtualKeyboardOpened = PR_TRUE;
             hildon_gtk_im_context_show (focusedIm);
-        else
+        } else {
+            gIMEVirtualKeyboardOpened = PR_FALSE;
             hildon_gtk_im_context_hide (focusedIm);
+        }
 #endif
         
     } else {
         if (IsIMEEditableState(mIMEData->mEnabled))
             ResetInputState();
         mIMEData->mEnabled = aState;
     }
 
diff -r 8dcf83cc8500 xpfe/appshell/src/nsContentTreeOwner.cpp
--- a/xpfe/appshell/src/nsContentTreeOwner.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/xpfe/appshell/src/nsContentTreeOwner.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -904,17 +904,17 @@ void nsContentTreeOwner::XULWindow(nsXUL
          docShellElement->GetAttribute(NS_LITERAL_STRING("contenttitlesetting"), contentTitleSetting);
          if(contentTitleSetting.EqualsLiteral("true"))
             {
             mContentTitleSetting = PR_TRUE;
             docShellElement->GetAttribute(NS_LITERAL_STRING("titledefault"), mTitleDefault);
             docShellElement->GetAttribute(NS_LITERAL_STRING("titlemodifier"), mWindowTitleModifier);
             docShellElement->GetAttribute(NS_LITERAL_STRING("titlepreface"), mTitlePreface);
             
-#if defined(XP_MACOSX) && defined(MOZ_XUL_APP)
+#if defined(XP_MACOSX)
             // On OS X, treat the titlemodifier like it's the titledefault, and don't ever append
             // the separator + appname.
             if (mTitleDefault.IsEmpty()) {
                 docShellElement->SetAttribute(NS_LITERAL_STRING("titledefault"),
                                               mWindowTitleModifier);
                 docShellElement->RemoveAttribute(NS_LITERAL_STRING("titlemodifier"));
                 mTitleDefault = mWindowTitleModifier;
                 mWindowTitleModifier.Truncate();
diff -r 8dcf83cc8500 xpfe/bootstrap/appleevents/nsAEApplicationClass.cpp
--- a/xpfe/bootstrap/appleevents/nsAEApplicationClass.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/xpfe/bootstrap/appleevents/nsAEApplicationClass.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -51,20 +51,17 @@
 #include "nsINativeAppSupport.h"
 #include "nsCommandLineServiceMac.h"
 #include "nsCOMPtr.h"
 #include "nsIAppStartup.h"
 #include "nsXPFEComponentsCID.h"
 
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
-
-#ifdef MOZ_XUL_APP
 #include "nsAppRunner.h"
-#endif
 
 /*----------------------------------------------------------------------------
 	AEApplicationClass 
 	
 ----------------------------------------------------------------------------*/
 AEApplicationClass::AEApplicationClass()
 :	AEGenericClass(cApplication, typeNull)
 {
@@ -328,28 +325,18 @@ void AEApplicationClass::HandleRun(AEDes
 	
 ----------------------------------------------------------------------------*/
 void AEApplicationClass::HandleReOpen(AEDesc *token, const AppleEvent *appleEvent, AppleEvent *reply)
 {
   OSErr	err = noErr;
   nsresult rv = NS_OK;
   nsCOMPtr<nsINativeAppSupport> nas;
 
-#ifdef MOZ_XUL_APP
   nas = do_CreateInstance(NS_NATIVEAPPSUPPORT_CONTRACTID);
   if (!nas) ThrowIfOSErr(errAEEventNotHandled);
-#else
-  nsCOMPtr<nsIAppStartup> appStartup(do_GetService(NS_APPSTARTUP_CONTRACTID));
-  NS_ASSERTION(appStartup, "Failed to get appstartup service");
-  if(!appStartup) ThrowIfOSErr(errAEEventNotHandled);
-  
-  rv = appStartup->GetNativeAppSupport(getter_AddRefs(nas));
-  NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to get NativeAppSupport");  
-  if(NS_FAILED(rv)) ThrowIfOSErr(errAEEventNotHandled);
-#endif
 
   rv = nas->ReOpen();
   if(NS_FAILED(rv)) ThrowIfOSErr(errAEEventNotHandled);    
 
 	err = CheckForUnusedParameters(appleEvent);
 	ThrowIfOSErr(err);
 }
 
diff -r 8dcf83cc8500 xpfe/bootstrap/nsSigHandlers.cpp
--- a/xpfe/bootstrap/nsSigHandlers.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,289 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Jerry.Kirk@Nexwarecorp.com
- *   Chris Seawood <cls@seawood.org>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-/*
- * This module is supposed to abstract signal handling away from the other
- * platforms that do not support it.
- */
-
-#include <signal.h>
-#include <stdio.h>
-#include <string.h>
-#include "prthread.h"
-#include "plstr.h"
-#include "prenv.h"
-#include "nsDebug.h"
-
-#if defined(LINUX)
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <unistd.h>
-#include <stdlib.h> // atoi
-#endif
-
-#if defined(SOLARIS)
-#include <sys/resource.h>
-#endif
-
-#ifdef XP_BEOS
-#include <be/app/Application.h>
-#include <string.h>
-#include "nsCOMPtr.h"
-#include "nsIServiceManager.h"
-#include "nsIAppStartup.h"
-#include "nsXPFEComponentsCID.h"
-#endif
-
-#ifdef MOZ_WIDGET_PHOTON
-#include <photon/PhProto.h>
-#endif
-
-static char _progname[1024] = "huh?";
-static unsigned int _gdb_sleep_duration = 300;
-
-#if defined(LINUX) && defined(DEBUG) && \
-      (defined(__i386) || defined(__x86_64) || defined(PPC))
-#define CRAWL_STACK_ON_SIGSEGV
-#endif
-
-#ifdef MOZ_WIDGET_PHOTON
-void abnormal_exit_handler(int signum)
-{
-  /* Free any shared memory that has been allocated */
-  PgShmemCleanup();
-
-#if defined(DEBUG)
-  if (    (signum == SIGSEGV)
-       || (signum == SIGILL)
-       || (signum == SIGABRT)
-       || (signum == SIGFPE)
-     )
-  {
-    printf("prog = %s\npid = %d\nsignal = %s\n", 
-           _progname, getpid(), strsignal(signum));
-
-    printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
-    printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
-           _progname, getpid());
-
-    sleep(_gdb_sleep_duration);
-
-    printf("Done sleeping...\n");
-  }
-#endif
-
-  _exit(1);
-}
-#elif defined(CRAWL_STACK_ON_SIGSEGV)
-
-#include <unistd.h>
-#include "nsISupportsUtils.h"
-#include "nsStackWalk.h"
-
-extern "C" {
-
-PR_STATIC_CALLBACK(void) PrintStackFrame(void *aPC, void *aClosure)
-{
-  char buf[1024];
-  nsCodeAddressDetails details;
-
-  NS_DescribeCodeAddress(aPC, &details);
-  NS_FormatCodeAddressDetails(aPC, &details, buf, sizeof(buf));
-  fprintf(stdout, buf);
-}
-
-}
-
-void
-ah_crap_handler(int signum)
-{
-  printf("\nProgram %s (pid = %d) received signal %d.\n",
-         _progname,
-         getpid(),
-         signum);
-
-  printf("Stack:\n");
-  NS_StackWalk(PrintStackFrame, 2, nsnull);
-
-  printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
-  printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
-         _progname,
-         getpid());
-
-  sleep(_gdb_sleep_duration);
-
-  printf("Done sleeping...\n");
-}
-#endif // CRAWL_STACK_ON_SIGSEGV
-
-#ifdef XP_BEOS
-void beos_signal_handler(int signum) {
-#ifdef DEBUG
-	fprintf(stderr, "beos_signal_handler: %d\n", signum);
-#endif
-	nsresult rv;
-	nsCOMPtr<nsIAppStartup> appStartup(do_GetService(NS_APPSTARTUP_CONTRACTID, &rv));
-	if (NS_FAILED(rv)) {
-		// Failed to get the appstartup service so shutdown the hard way
-#ifdef DEBUG
-		fprintf(stderr, "beos_signal_handler: appShell->do_GetService() failed\n");
-#endif
-		exit(13);
-	}
-
-	// Exit the appshell so that the app can shutdown normally
-	appStartup->Quit(nsIAppStartup::eAttemptQuit);
-}
-#endif
-
-#ifdef MOZ_WIDGET_GTK2
-// Need this include for version test below.
-#include <glib.h>
-#endif
-
-#if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
-
-static GLogFunc orig_log_func = NULL;
-
-extern "C" {
-static void
-my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
-                 const gchar *message, gpointer user_data);
-}
-
-/* static */ void
-my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
-                 const gchar *message, gpointer user_data)
-{
-  if (log_level & (G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION)) {
-    NS_DebugBreak(NS_DEBUG_ASSERTION, message, "glib assertion", __FILE__, __LINE__);
-  } else if (log_level & (G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)) {
-    NS_DebugBreak(NS_DEBUG_WARNING, message, "glib warning", __FILE__, __LINE__);
-  }
-
-  orig_log_func(log_domain, log_level, message, NULL);
-}
-
-#endif
-
-void InstallUnixSignalHandlers(const char *ProgramName)
-{
-  PL_strncpy(_progname,ProgramName, (sizeof(_progname)-1) );
-
-  const char *gdbSleep = PR_GetEnv("MOZ_GDB_SLEEP");
-  if (gdbSleep && *gdbSleep)
-  {
-    unsigned int s;
-    if (1 == sscanf(gdbSleep, "%u", &s)) {
-      _gdb_sleep_duration = s;
-    }
-  }
-
-#if defined(MOZ_WIDGET_PHOTON)
- /* Neutrino need this to free shared memory in case of a crash */
-  signal(SIGTERM, abnormal_exit_handler);
-  signal(SIGQUIT, abnormal_exit_handler);
-  signal(SIGINT,  abnormal_exit_handler);
-  signal(SIGHUP,  abnormal_exit_handler);
-  signal(SIGSEGV, abnormal_exit_handler);
-  signal(SIGILL,  abnormal_exit_handler);
-  signal(SIGABRT, abnormal_exit_handler);
-  signal(SIGFPE,  abnormal_exit_handler);
-
-#elif defined(CRAWL_STACK_ON_SIGSEGV)
-  signal(SIGSEGV, ah_crap_handler);
-  signal(SIGILL, ah_crap_handler);
-  signal(SIGABRT, ah_crap_handler);
-  signal(SIGFPE, ah_crap_handler);
-#endif // CRAWL_STACK_ON_SIGSEGV
-
-#if defined(DEBUG) && defined(LINUX)
-  const char *memLimit = PR_GetEnv("MOZ_MEM_LIMIT");
-  if (memLimit && *memLimit)
-  {
-    long m = atoi(memLimit);
-    m *= (1024*1024);
-    struct rlimit r;
-    r.rlim_cur = m;
-    r.rlim_max = m;
-    setrlimit(RLIMIT_AS, &r);
-  }
-#endif
-
-#if defined(SOLARIS)
-#define NOFILES 512
-
-    // Boost Solaris file descriptors
-    {
-	struct rlimit rl;
-	
-	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
-
-	    if (rl.rlim_cur < NOFILES) {
-		rl.rlim_cur = NOFILES;
-
-		if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
-		    perror("setrlimit(RLIMIT_NOFILE)");
-		    fprintf(stderr, "Cannot exceed hard limit for open files");
-		}
-#if defined(DEBUG)
-	    	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
-		    printf("File descriptors set to %d\n", rl.rlim_cur);
-#endif //DEBUG
-	    }
-    }
-#endif //SOLARIS
-
-#ifdef XP_BEOS
-	signal(SIGTERM, beos_signal_handler);
-#endif
-
-#if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
-  const char *assertString = PR_GetEnv("XPCOM_DEBUG_BREAK");
-  if (assertString &&
-      (!strcmp(assertString, "suspend") ||
-       !strcmp(assertString, "stack") ||
-       !strcmp(assertString, "abort") ||
-       !strcmp(assertString, "trap") ||
-       !strcmp(assertString, "break"))) {
-    // Override the default glib logging function so we get stacks for it too.
-    orig_log_func = g_log_set_default_handler(my_glib_log_func, NULL);
-  }
-#endif
-}
diff -r 8dcf83cc8500 xpfe/bootstrap/showOSAlert.cpp
--- a/xpfe/bootstrap/showOSAlert.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,92 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Communicator client code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications Corporation.
- * Portions created by the Initial Developer are Copyright (C) 1998
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Don Bragg <dbragg@netscape.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either of the GNU General Public License Version 2 or later (the "GPL"),
- * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include  <stdio.h>
-#include  <string.h>
-#include "nscore.h"
-
-//defines and includes for previous installation cleanup process
-#if defined (XP_WIN)
-#include <windows.h>
-#elif defined (XP_MAC)
-#include <Dialogs.h>
-#include <TextUtils.h>
-#elif defined (XP_OS2)
-#define INCL_DOS
-#define INCL_WIN
-#include <os2.h>
-#endif
-
-extern "C" void ShowOSAlert(const char* aMessage);
-
-
-// The maximum allowed length of aMessage is 255 characters!
-void ShowOSAlert(const char* aMessage)
-{
-#ifdef DEBUG_dbragg
-printf("\n****Inside ShowOSAlert ***\n");	
-#endif 
-
-    const PRInt32 max_len = 255;
-    char message_copy[max_len+1] = { 0 };
-    PRInt32 input_len = strlen(aMessage);
-    PRInt32 copy_len = (input_len > max_len) ? max_len : input_len;
-    strncpy(message_copy, aMessage, copy_len);
-    message_copy[copy_len] = 0;
-
-#if defined (XP_WIN)
-    MessageBoxA(NULL, message_copy, NULL, MB_OK | MB_ICONERROR | MB_SETFOREGROUND );
-#elif (XP_MAC)
-    short buttonClicked;
-    StandardAlert(kAlertStopAlert, c2pstr(message_copy), nil, nil, &buttonClicked);
-#elif defined (XP_OS2)
-    /* Set our app to be a PM app before attempting Win calls */
-    PPIB ppib;
-    PTIB ptib;
-    DosGetInfoBlocks(&ptib, &ppib);
-    ppib->pib_ultype = 3;
-    HAB hab = WinInitialize(0);
-    HMQ hmq = WinCreateMsgQueue(hmq,0);
-    WinMessageBox( HWND_DESKTOP, HWND_DESKTOP, message_copy, "", 0, MB_OK);
-    WinDestroyMsgQueue(hmq);
-    WinTerminate(hab);
-#endif
-    // It can't hurt to display the message on the console in any case,
-    // even if we have already tried to display it in a GUI window.
-    fprintf(stdout, "%s\n", aMessage);
-}
diff -r 8dcf83cc8500 xpfe/browser/src/nsBrowserInstance.cpp
--- a/xpfe/browser/src/nsBrowserInstance.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/xpfe/browser/src/nsBrowserInstance.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -88,20 +88,16 @@
 #include "nsDocShellCID.h"
 
 #include "nsIObserverService.h"
 
 #include "nsILocalFile.h"
 #include "nsDirectoryServiceDefs.h"
 
 #include "nsNetUtil.h"
-#ifndef MOZ_XUL_APP
-#include "nsIBrowserHistory.h"
-#include "nsICmdLineService.h"
-#endif
 
 // Stuff to implement file download dialog.
 #include "nsIProxyObjectManager.h" 
 
 #include "nsXPFEComponentsCID.h"
 
 // If DEBUG, NS_BUILD_REFCNT_LOGGING, MOZ_PERF_METRICS, or MOZ_JPROF is
 // defined, enable the PageCycler.
@@ -493,67 +489,16 @@ nsBrowserInstance::GetCmdLineURLUsed(PRB
   *aCmdLineURLUsed = sCmdLineURLUsed;
   return NS_OK;
 }
 
 NS_IMETHODIMP    
 nsBrowserInstance::StartPageCycler(PRBool* aIsPageCycling)
 {
   *aIsPageCycling = PR_FALSE;
-
-#ifndef MOZ_XUL_APP
-  nsresult rv;
-
-  if (!sCmdLineURLUsed) {
-    nsCOMPtr<nsICmdLineService> cmdLineArgs = 
-             do_GetService(NS_COMMANDLINESERVICE_CONTRACTID, &rv);
-    if (NS_FAILED(rv)) {
-      if (APP_DEBUG) fprintf(stderr, "Could not obtain CmdLine processing service\n");
-      return NS_ERROR_FAILURE;
-    }
-
-#ifdef ENABLE_PAGE_CYCLER
-    // First, check if there's a URL file to load (for testing), and if there 
-    // is, process it instead of anything else.
-    nsAutoString urlstr;
-    nsXPIDLCString file;
-    rv = cmdLineArgs->GetCmdLineValue("-f", getter_Copies(file));
-    if (NS_SUCCEEDED(rv) && (const char*)file) {
-
-      // see if we have a timeout value corresponding to the url-file
-      nsXPIDLCString timeoutVal;
-      rv = cmdLineArgs->GetCmdLineValue("-ftimeout", getter_Copies(timeoutVal));
-      // see if we have a wait value corresponding to the url-file
-      nsXPIDLCString waitVal;
-      rv = cmdLineArgs->GetCmdLineValue("-fwait", getter_Copies(waitVal));
-      // cereate the cool PageCycler instance
-      PageCycler* bb = new PageCycler(this, timeoutVal, waitVal);
-      if (bb == nsnull)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-      NS_ADDREF(bb);
-      rv = bb->Init(file);
-      if (NS_FAILED(rv)) return rv;
-
-      rv = bb->GetNextURL(urlstr);
-      NS_RELEASE(bb);
-
-      *aIsPageCycling = PR_TRUE;
-    }
-
-    if (!urlstr.IsEmpty()) {
-      // A url was provided. Load it
-      if (APP_DEBUG) printf("Got Command line URL to load %s\n", NS_ConvertUTF16toUTF8(urlstr).get());
-      rv = LoadUrl( urlstr.get() );
-      sCmdLineURLUsed = PR_TRUE;
-      return rv;
-    }
-#endif //ENABLE_PAGE_CYCLER
-  }
-#endif // MOZ_XUL_APP
   return NS_OK;
 }
 
 
 NS_IMETHODIMP    
 nsBrowserInstance::SetWebShellWindow(nsIDOMWindowInternal* aWin)
 {
   NS_ENSURE_ARG(aWin);
@@ -588,246 +533,8 @@ nsBrowserInstance::Close()
   if (mIsClosed) 
     return NS_OK;
   else
     mIsClosed = PR_TRUE;
 
   return NS_OK;
 }
 
-#ifndef MOZ_XUL_APP
-//*****************************************************************************
-// nsBrowserInstance: Helpers
-//*****************************************************************************
-
-////////////////////////////////////////////////////////////////////////
-// browserCntHandler is a content handler component that registers
-// the browse as the preferred content handler for various content
-// types like text/html, image/jpeg, etc. When the uri loader
-// has a content type that no currently open window wants to handle, 
-// it will ask the registry for a registered content handler for this
-// type. If the browser is registered to handle that type, we'll end
-// up in here where we create a new browser window for the url.
-//
-// I had intially written this as a JS component and would like to do
-// so again. However, JS components can't access xpconnect objects that
-// return DOM objects. And we need a dom window to bootstrap the browser
-/////////////////////////////////////////////////////////////////////////
-
-NS_IMPL_ISUPPORTS1(nsChromeStartupHandler, nsICmdLineHandler)
-CMDLINEHANDLER_IMPL(nsChromeStartupHandler, "-chrome", "", "",
-                    "Load the specified chrome.",
-                    NS_CHROMESTARTUPHANDLER_CONTRACTID,
-                    "Chrome Startup Handler", PR_TRUE, "", PR_FALSE)
-
-NS_IMPL_ISUPPORTS2(nsBrowserContentHandler, nsIContentHandler, nsICmdLineHandler)
-CMDLINEHANDLER_OTHERS_IMPL(nsBrowserContentHandler, "-browser",
-                           "general.startup.browser", "Load the browser.",
-                           PR_TRUE, PR_TRUE)
-CMDLINEHANDLER_REGISTERPROC_IMPL(nsBrowserContentHandler,
-                                 "Browser Startup Handler",
-                                 NS_BROWSERSTARTUPHANDLER_CONTRACTID)
-NS_IMETHODIMP nsBrowserContentHandler::GetChromeUrlForTask(char **aChromeUrlForTask) {
-
-  if (!aChromeUrlForTask)
-    return NS_ERROR_NULL_POINTER;
-
-  nsresult rv = NS_ERROR_FAILURE;
-  nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
-  if (prefs) {
-    rv = prefs->GetCharPref("browser.chromeURL", aChromeUrlForTask);
-    if (NS_SUCCEEDED(rv) && (*aChromeUrlForTask)[0] == '\0') {
-      PL_strfree(*aChromeUrlForTask);
-      rv = NS_ERROR_FAILURE;
-    }
-  }
-  if (NS_FAILED(rv))
-    *aChromeUrlForTask = PL_strdup("chrome://navigator/content/navigator.xul");
-
-  return NS_OK;
-}
-
-PRBool nsBrowserContentHandler::NeedHomepageOverride(nsIPrefBranch *aPrefService)
-{
-  NS_ASSERTION(aPrefService, "Null pointer to prefs service!");
-
-  // get saved milestone from user's prefs
-  nsXPIDLCString savedMilestone;
-  aPrefService->GetCharPref(PREF_HOMEPAGE_OVERRIDE_MSTONE, 
-                            getter_Copies(savedMilestone));
-  // Mozilla never saves this value, but a fed-up advanced user might
-  if (savedMilestone.Equals(kIgnoreOverrideMilestone))
-    return PR_FALSE;
-
-  // get browser's current milestone
-  nsCOMPtr<nsIHttpProtocolHandler> httpHandler(
-      do_GetService("@mozilla.org/network/protocol;1?name=http"));
-  if (!httpHandler)
-    return PR_TRUE;
-
-  nsCAutoString currMilestone;
-  httpHandler->GetMisc(currMilestone);
-
-  // failed to get pref -or- saved milestone older than current milestone, 
-  // write out known current milestone and show URL this time
-  if (!(currMilestone.Equals(savedMilestone))) {
-    // update milestone in "homepage override" pref
-    aPrefService->SetCharPref(PREF_HOMEPAGE_OVERRIDE_MSTONE, 
-                              currMilestone.get());
-    return PR_TRUE;
-  }
-  
-  // don't override if saved and current are same
-  return PR_FALSE;
-}
-
-nsresult GetHomePageGroup(nsIPrefBranch* aPref, PRUnichar** aResult)
-{
-  nsresult rv;
-
-  nsCOMPtr<nsIPrefLocalizedString> uri;
-  rv = aPref->GetComplexValue(PREF_BROWSER_STARTUP_HOMEPAGE,
-                              NS_GET_IID(nsIPrefLocalizedString),
-                              getter_AddRefs(uri));
-  if (NS_FAILED(rv))
-    return rv;
-
-  PRInt32 count = 0;
-  rv = aPref->GetIntPref("browser.startup.homepage.count", &count);
-
-  // if we couldn't get the pref (unlikely) or only have one homepage
-  if (NS_FAILED(rv) || count <= 1) {
-    return uri->ToString(aResult);
-  }
-
-  // The "homepage" is a group of pages, put them in uriList separated by '\n'
-  nsString uriList;
-  rv = uri->GetData(getter_Copies(uriList));
-  if (NS_FAILED(rv))
-    return rv;
-
-  for (PRInt32 i = 1; i < count; ++i) {
-    nsCAutoString pref(NS_LITERAL_CSTRING("browser.startup.homepage."));
-    pref.AppendInt(i);
-
-    rv = aPref->GetComplexValue(pref.get(),
-                                NS_GET_IID(nsIPrefLocalizedString),
-                                getter_AddRefs(uri));
-    if (NS_FAILED(rv))
-      return rv;
-
-    nsString uriString;
-    rv = uri->GetData(getter_Copies(uriString));
-    if (NS_FAILED(rv))
-      return rv;
-
-    uriList.Append(PRUnichar('\n'));
-    uriList.Append(uriString);
-  }
-
-  *aResult = ToNewUnicode(uriList);
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsBrowserContentHandler::GetDefaultArgs(PRUnichar **aDefaultArgs)
-{
-  if (!aDefaultArgs)
-    return NS_ERROR_NULL_POINTER;
-
-  nsresult rv;
-
-  nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
-  if (prefs) {
-    if (NeedHomepageOverride(prefs)) {
-      nsCOMPtr<nsIPrefLocalizedString> overrideURL;
-      rv = prefs->GetComplexValue(PREF_HOMEPAGE_OVERRIDE_URL,
-                                  NS_GET_IID(nsIPrefLocalizedString),
-                                  getter_AddRefs(overrideURL));
-      if (NS_SUCCEEDED(rv)) {
-        rv = overrideURL->ToString(aDefaultArgs);
-        if (NS_SUCCEEDED(rv) && *aDefaultArgs)
-          return NS_OK;
-      }
-    }
-
-    PRInt32 choice = 0;
-    rv = prefs->GetIntPref(PREF_BROWSER_STARTUP_PAGE, &choice);
-    if (NS_SUCCEEDED(rv)) {
-      switch (choice) {
-        case 1: {
-          // skip the code below
-          rv = GetHomePageGroup(prefs, aDefaultArgs);
-          if (NS_SUCCEEDED(rv) && *aDefaultArgs)
-            return NS_OK;
-        }
-        case 2: {
-          nsCOMPtr<nsIBrowserHistory> history(do_GetService(NS_GLOBALHISTORY2_CONTRACTID));
-          if (history) {
-            nsCAutoString curl;
-            rv = history->GetLastPageVisited(curl);
-            if (NS_SUCCEEDED(rv)) {
-              *aDefaultArgs = UTF8ToNewUnicode(curl);
-              if (*aDefaultArgs) return NS_OK;
-            }
-          }
-        }
-      }
-    }
-  }
-    
-  // the default, in case we fail somewhere
-  *aDefaultArgs = ToNewUnicode(NS_LITERAL_STRING("about:blank"));
-  if (!*aDefaultArgs) return NS_ERROR_OUT_OF_MEMORY;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsBrowserContentHandler::HandleContent(const char * aContentType,
-                                                     nsIInterfaceRequestor * aWindowContext,
-                                                     nsIRequest * aRequest)
-{
-  NS_PRECONDITION(aContentType, "Must have a content type");
-
-  // Verify that we can handle this content, to avoid infinite window opening
-  // loops
-  nsresult rv;
-  nsCOMPtr<nsIWebNavigationInfo> webNavInfo =
-    do_GetService(NS_WEBNAVIGATION_INFO_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  PRUint32 typeSupported;
-  rv = webNavInfo->IsTypeSupported(nsDependentCString(aContentType), nsnull,
-                                   &typeSupported);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  if (!typeSupported)
-      return NS_ERROR_WONT_HANDLE_CONTENT;
-
-  // create a new browser window to handle the content
-  NS_ENSURE_ARG(aRequest);
-  nsCOMPtr<nsIDOMWindow> parentWindow;
-
-  if (aWindowContext)
-    parentWindow = do_GetInterface(aWindowContext);
-
-  nsCOMPtr<nsIChannel> aChannel = do_QueryInterface(aRequest);
-  if (!aChannel) return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIURI> uri;
-  aChannel->GetURI(getter_AddRefs(uri));
-  NS_ENSURE_TRUE(uri, NS_ERROR_FAILURE);
-  nsCAutoString spec;
-  uri->GetSpec(spec);
-
-  nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
-  if (wwatch) {
-    nsCOMPtr<nsIDOMWindow> newWindow;
-    wwatch->OpenWindow(parentWindow, spec.get(), "", 0, 0,
-              getter_AddRefs(newWindow));
-  }
-
-  // now abort the current channel load...
-  aRequest->Cancel(NS_BINDING_ABORTED);
-
-  return NS_OK;
-}
-
-#endif // MOZ_XUL_APP
diff -r 8dcf83cc8500 xpfe/browser/src/nsBrowserInstance.h
--- a/xpfe/browser/src/nsBrowserInstance.h	Sun Sep 14 00:37:23 2008 -0700
+++ b/xpfe/browser/src/nsBrowserInstance.h	Tue Sep 16 07:55:13 2008 -0500
@@ -42,22 +42,16 @@
 #include "nsWeakReference.h"
 
 // Interfaces Needed
 #include "nsIBrowserInstance.h"
 
 #include "nscore.h"
 #include "nsISupports.h"
 
-#ifndef MOZ_XUL_APP
-// for nsBrowserStatusHandler
-#include "nsIContentHandler.h"
-#include "nsICmdLineHandler.h"
-#endif
-
 class nsIDocShell;
 class nsIDOMWindowInternal;
 class nsIPrefBranch;
 
 ////////////////////////////////////////////////////////////////////////////////
 // nsBrowserInstance:
 ////////////////////////////////////////////////////////////////////////////////
 
@@ -91,31 +85,9 @@ class nsBrowserInstance : public nsIBrow
 
     nsIDOMWindowInternal*       mDOMWindow;                         // weak reference
 
 #ifdef DEBUG_warren
     PRIntervalTime      mLoadStartTime;
 #endif
 };
 
-#ifndef MOZ_XUL_APP
-class nsChromeStartupHandler : public nsICmdLineHandler
-{
-public:
-  NS_DECL_NSICMDLINEHANDLER
-  NS_DECL_ISUPPORTS
-  CMDLINEHANDLER_REGISTERPROC_DECLS
-};
-
-class nsBrowserContentHandler : public nsIContentHandler, public nsICmdLineHandler
-{
-public:
-  NS_DECL_NSICONTENTHANDLER
-  NS_DECL_NSICMDLINEHANDLER
-  NS_DECL_ISUPPORTS
-  CMDLINEHANDLER_REGISTERPROC_DECLS
-
-protected:
-  PRBool NeedHomepageOverride(nsIPrefBranch *aPrefService);
-};
-#endif
-
 #endif // nsBrowserInstance_h___
diff -r 8dcf83cc8500 xpfe/components/build/nsModule.cpp
--- a/xpfe/components/build/nsModule.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/xpfe/components/build/nsModule.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -94,22 +94,16 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsDownloa
 #endif
 
 #if !defined(MOZ_PLACES)
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsGlobalHistory, Init)
 #endif
 
 #endif // MOZ_SUITE
 
-#if (!defined(MOZ_XUL_APP)) && !defined(MOZ_MACBROWSER)
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsBrowserContentHandler)
-NS_GENERIC_FACTORY_CONSTRUCTOR(nsChromeStartupHandler)
-#endif
-
-
 static NS_METHOD
 RegisterProc(nsIComponentManager *aCompMgr,
              nsIFile *aPath,
              const char *registryLocation,
              const char *componentType,
              const nsModuleComponentInfo *info)
 {
     nsresult rv;
@@ -178,119 +172,11 @@ static const nsModuleComponentInfo compo
     },
     { "nsBrowserInstance",
       NS_BROWSERINSTANCE_CID,
       NS_BROWSERINSTANCE_CONTRACTID,
       nsBrowserInstanceConstructor
     },
 #endif
 
-#if (!defined(MOZ_XUL_APP)) && !defined(MOZ_MACBROWSER)
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"text/html",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"application/vnd.mozilla.xul+xml",
-    nsBrowserContentHandlerConstructor
-  },
-#ifdef MOZ_SVG
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/svg+xml",
-    nsBrowserContentHandlerConstructor
-  },
-#endif // MOZ_SVG
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"text/rdf",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"text/xml",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"application/xml",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"application/xhtml+xml",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"text/css",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"text/plain",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/gif",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/jpeg",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/jpg",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/png",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/bmp",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/x-icon",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/vnd.microsoft.icon",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"image/x-xbitmap",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Content Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_CONTENT_HANDLER_CONTRACTID_PREFIX"application/http-index-format",
-    nsBrowserContentHandlerConstructor
-  },
-  { "Browser Startup Handler",
-    NS_BROWSERCONTENTHANDLER_CID,
-    NS_BROWSERSTARTUPHANDLER_CONTRACTID,
-    nsBrowserContentHandlerConstructor,
-    nsBrowserContentHandler::RegisterProc,
-    nsBrowserContentHandler::UnregisterProc,
-  },
-  { "Chrome Startup Handler",
-    NS_CHROMESTARTUPHANDLER_CID,
-    NS_CHROMESTARTUPHANDLER_CONTRACTID,
-    nsChromeStartupHandlerConstructor,
-    nsChromeStartupHandler::RegisterProc,
-    nsChromeStartupHandler::UnregisterProc
-  },
-#endif //!defined(MOZ_XUL_APP) && !defined(MOZ_MACBROWSER)
 };
 
 NS_IMPL_NSGETMODULE(application, components)
diff -r 8dcf83cc8500 xpfe/components/download-manager/src/nsDownloadManager.cpp
--- a/xpfe/components/download-manager/src/nsDownloadManager.cpp	Sun Sep 14 00:37:23 2008 -0700
+++ b/xpfe/components/download-manager/src/nsDownloadManager.cpp	Tue Sep 16 07:55:13 2008 -0500
@@ -59,19 +59,17 @@
 #include "nsIPromptService.h"
 #include "nsIObserverService.h"
 #include "nsIProfileChangeStatus.h"
 #include "nsIPrefService.h"
 #include "nsIFileURL.h"
 #include "nsIAlertsService.h"
 #include "nsEmbedCID.h"
 #include "nsInt64.h"
-#ifdef MOZ_XUL_APP
 #include "nsToolkitCompsCID.h" 
-#endif
 
 /* Outstanding issues/todo:
  * 1. Implement pause/resume.
  */
   
 #define DOWNLOAD_MANAGER_FE_URL "chrome://communicator/content/downloadmanager/downloadmanager.xul"
 #define DOWNLOAD_MANAGER_BUNDLE "chrome://communicator/locale/downloadmanager/downloadmanager.properties"
 
diff -r 8dcf83cc8500 xulrunner/app/Makefile.in
--- a/xulrunner/app/Makefile.in	Sun Sep 14 00:37:23 2008 -0700
+++ b/xulrunner/app/Makefile.in	Tue Sep 16 07:55:13 2008 -0500
@@ -169,21 +169,17 @@ RESFILE=splashos2.res
 RESFILE=splashos2.res
 RCFLAGS += -DMOZ_XULRUNNER
 ifdef DEBUG
 RCFLAGS += -DDEBUG
 endif
 RCFLAGS += -DXULRUNNER_ICO=\"$(DIST)/branding/xulrunner.ico\" -DDOCUMENT_ICO=\"$(DIST)/branding/document.ico\"
 endif
 
-ifdef MOZ_MEMORY
-ifneq ($(OS_ARCH),WINNT)
-LIBS += $(call EXPAND_LIBNAME_PATH,jemalloc,$(DEPTH)/memory/jemalloc)
-endif
-endif
+LIBS += $(JEMALLOC_LIBS)
 
 include $(topsrcdir)/config/rules.mk
 
 DEFINES += -DXULRUNNER_ICO=\"$(DIST)/branding/xulrunner.ico\" -DDOCUMENT_ICO=\"$(DIST)/branding/document.ico\"
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),photon)
 LIBS += -lphexlib
 endif
diff -r 8dcf83cc8500 xulrunner/stub/Makefile.in
--- a/xulrunner/stub/Makefile.in	Sun Sep 14 00:37:23 2008 -0700
+++ b/xulrunner/stub/Makefile.in	Tue Sep 16 07:55:13 2008 -0500
@@ -92,19 +92,15 @@ endif
 endif
 
 include $(topsrcdir)/config/config.mk
 
 ifdef _MSC_VER
 WIN32_EXE_LDFLAGS += -ENTRY:wmainCRTStartup
 endif
 
-ifdef MOZ_MEMORY
-ifneq ($(OS_ARCH),WINNT)
-LIBS += $(call EXPAND_LIBNAME_PATH,jemalloc,$(DEPTH)/memory/jemalloc)
-endif
-endif
+LIBS += $(JEMALLOC_LIBS)
 
 include $(topsrcdir)/config/rules.mk
 
 ifeq ($(OS_ARCH),WINNT)
 OS_LIBS += $(call EXPAND_LIBNAME,shell32)
 endif
