<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" > 
<HTML>

<head>
    <title>DOM API for visual traversal</title>
    
      

<meta name="description" content="">
<meta name="robots" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="/Brander?f=Skin.css&amp;v=v26n"/>
<link rel="stylesheet" type="text/css" href="/Brander?f=ButtonStyles.css&amp;v=dvgf"/>
<link rel="shortcut icon" href="/favicon.ico">
    
<script language="JavaScript" type="text/javascript">
  var PY_newDocCommand;
  
  var useNewInsertImageDialog = true;
  var gUntitled = 'Untitled';
  var lUntitled = 'Untitled';
  var SitePrefix = "";
  var SiteFaqUrl = "http://docs.google.com/support/?hl=en";
  var USE_NEW_DIALOGS = true;
  var INCLUDE_BRITANNICA_INTEGRATION = false;
  var INCLUDE_TABLE_OF_CONTENTS = false;
  function GetSiteRootURL() { return SitePrefix + "/"; }
  function DasherizeURL(url) {
    // add prefix to URL if we have a prefix to add, and URL doesn't already
    // start with it
    var siteRootUrl = GetSiteRootURL();
    if (SitePrefix && url.indexOf(siteRootUrl) != 0) {
      return siteRootUrl + url;
    }
    return url;
  }
</script>


  <script language="JavaScript" type="text/javascript">
var DIALOG_VERSIONS = {
  BlogSettings: 'v5kn',
  ChangeCell: 'vwf4',
  ChangeColumn: 'vt9w',
  ChangeList: 'vthb',
  ChangeRow: 'vtnb',
  CommentSettings: 'vn25',
  DocSettings: 'whp9',
  EmailDocument: 'v78m',
  EmailMsg: 'kgj',
  FindReplace: 'vrf5',
  InsertBookmark: 'vswm',
  InsertChar: 'v46p',
  InsertImage: 'v8jk',
  InsertLink: 'wdrg',
  InsertTable: 'v6xw',
  MiscTextBox: 'vnds',
  NewInsertImage: 'wqvp',
  PresentationSettings: 'vrwp',
  WordCount: 'vq35'
};
</script>

  <script type="text/javascript" src="/js/497712281-EditTab.js"></script>


<script language="JavaScript" type="text/javascript" src="/javascript/async.js?v=vg6h"></script>
<script language="JavaScript" type="text/javascript" src="/javascript/ActionMenu.js?v=wgjc"></script>
<script language="JavaScript" type="text/javascript" src="/javascript/Utilities.js?v=zzv2"></script>

<script language="JavaScript" type="text/javascript" src="/Localizer?f=AllMsgs.hdf&amp;v=wcvf"></script>



<script language="JavaScript" type="text/javascript">

var action = '';
var rssAuthToken = '';

var IsRSSOK = !!0;
var IsLeftly = true;
var onLocalServer = false;
var userID = "dhmd4jxt";
var userName = "Timeless";

var BlogUrl = "";
var BlogName = "";
var BlogType = "blogger";
var BlogPermalink = "";
var UserName = "";
var CustomBlog = !!0;


  var DocID = "dhmd4jxt_40hgb5x6";
  var Tab = "";
  
    var TabIsEditor = false;
  
	      
  var IsShared = !!1;
  var IsOwner = !!1;
  var IsPublished = !!1;
  var IsPublic = !!1;
  var IsPosted = !!0;
  var IsUnconfirmed = !!0;
  var IsBidiOn = !!0;
  var IsDocRTL = !!0;
  var AllowOpenInvites = !!1;
  var AllowOpenCollaboration = !!1;



  
  initPostToken();

  function refreshPostToken() {
    
    initPostToken();
  }
  function initPostToken() {
    if (typeof(setPostToken) != "undefined") {
      setPostToken('MQo6tBMBAAA.yEYkz8Wymik3oDlNsnC-nf4i1hjXLLXqfep4oKuJcb4.sncRDQURThmgCFI5lDPtIw');
    }
  }
</script>

    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <meta name="description" content="Web word processing and spreadsheets">
    
      
<style>
BODY, P, DIV, H1, H2, H3, H4, H5, H6, ADDRESS, OL, UL, TITLE, TD, OPTION, SELECT {
 font-family: Verdana;
 
}

BODY, P, DIV, ADDRESS, OL, UL, LI, TITLE, TD, OPTION, SELECT {  
  font-size: 10.0pt;
  margin-top:0pt;  
  margin-bottom:0pt;  
} 

BODY, P {
  margin-left:0pt; 
  margin-right:0pt;
}

BODY {
  line-height: ;

  margin: 6px;
  padding: 0px;
}

h6 { font-size: 10pt }
h5 { font-size: 11pt }
h4 { font-size: 12pt }
h3 { font-size: 13pt }
h2 { font-size: 14pt }
h1 { font-size: 16pt }

blockquote {padding: 10px; border: 1px #DDDDDD dashed }

a img {border: 0}

</style>


    
		

		
  <script>
      var RedirectMessage = "";
      
      function ShowMessageIfAny() {
        if (RedirectMessage.length > 0) {
          alert(RedirectMessage);
        }

        
      }
      
      function HideFileMenu() {
        if (typeof(window.parent) != "undefined" && 
            window.parent != null && 
            typeof(window.parent.HideMenus) != "undefined") {
      	  window.parent.HideMenus(true);
      	}
      }
  </script>
</head>
	
<body topmargin=0 rightmargin=0 leftmargin=0 bottommargin=0 
    style="margin: 0px; padding: 0px; " 
    onclick="HideFileMenu();" onload="ShowMessageIfAny();">
    



  
    <table width=100% cellSpacing="0" cellPadding="0" border="0" id=navigation>
      <tr>
        <td align=center width="80%"><div class=smalltext style="padding: 8px">
          
            (You are viewing the published version of this document.)
          
        </div></td>
        
      </tr>

      <tr>
        <td bgcolor="#676767"><img src="/images/blankdot.gif" height=1></td>
        
      </tr>
    </table>
  


<div style="padding: 8px" >
    
    <h3>
  Goals
</h3>
<p>
  Enable implementation of efficient spatial navigation algorithms

</p>
<h3>
  Interface&nbsp;
</h3>
<p>
  <em>interface</em> <strong>VisualRegion</strong><strong></strong> {<br/>
</p>
<p>
  /**

</p>
<p>
  &nbsp;* <strong>originX</strong> is the starting point's X coordinate (in
  pixels)
</p>
<p>
  &nbsp;* <strong>originY</strong> is the starting point's&nbsp;Y coordinate (in
  pixels)<br/>
</p>

<p>
  &nbsp;* <strong>range</strong> (in pixels) if 0 this means find the object
  that's actually at the specified point.
</p>
<p>
  &nbsp;*
</p>
<p>
  &nbsp;* <strong>@returns</strong> null if no visible object lies between
  minimum and maximum range from the specified point.

</p>
<p>
  &nbsp;* <b>@returns</b> unordered list of all DOMNodes for which one point of
  the node is within <strong>range </strong>of the origin point. Includes
  objects that are not at the top of the z-stack.<br/>
</p>
<p>
  &nbsp;* <strong>throws</strong> invalid_range if minimum is greater than
  maximum

</p>
<p>
  &nbsp;*
</p>
<p>
  &nbsp;* calling getNodesAroundPoint(x, y) could be treated as
  getNodesAroundPoint(x, y, 0) which is legal and would return all dom objects
  at the point x,y.
</p>
<p>
  &nbsp;*/
</p>
<p>
  <i><b>DOMCollection</b></i> getNodesAroundPoint(<em>in int</em>

  <strong>originX</strong>, <em>in int</em>
  <strong>originY</strong>,&nbsp;<em>in int</em> <strong>range</strong>);<br/>
</p>
<br/>
<br/>
<p>

  /**
</p>
<p>
  &nbsp;* <b style="BACKGROUND-COLOR:#ff6666">@status obsolete</b><br/>
</p>
<p>
  &nbsp;* <strong>originX</strong> is the starting point's X coordinate (in
  pixels)
</p>
<p>

  &nbsp;* <strong>originY</strong> is the starting point's&nbsp;Y coordinate (in
  pixels)
</p>
<p>
  &nbsp;* <strong>minimumDistance</strong> (in pixels) enables one to start
  checking at some distance from a point. Partially to enable continuing a
  search that had ended at some previously specified maximumDistance
</p>
<p>
  &nbsp;* <strong>maximumDistance</strong> (in pixels) if 0 this means find the
  object that's actually at the specified point.

</p>
<p>
  &nbsp;*
</p>
<p>
  &nbsp;* <strong>@returns</strong> null if no visible object lies between
  minimum and maximum range from the specified point.
</p>
<p>
  &nbsp;* <b>@returns</b> unordered list of all DOMNodes for which one point of
  the node is between <strong>minimumDistance</strong> and
  <strong>maximumDistance </strong>of the origin point. Includes objects that
  are not at the top of the z-stack.<br/>

</p>
<p>
  &nbsp;* <strong>throws</strong> invalid_range if minimum is greater than
  maximum
</p>
<p>
  &nbsp;*
</p>
<p>
  &nbsp;* calling getNodesInRangeOfPoint(x, y) could be treated as
  getNodesInRangeOfPoint(x, y, 0, 0) which is legal and would return all dom
  objects at the point x,y.
</p>
<p>

  &nbsp;*/
</p>
<p>
  <i><b>DOMCollection</b></i> getNodesInRangeOfPoint(<em>in int</em>
  <strong>originX</strong>, <em>in int</em>
  <strong>originY</strong>,&nbsp;<em>in int</em>

  <strong>minimumDistance</strong>, <em>in int</em>
  <strong>maximumDistance</strong>);<br/>
</p>
<br/>
<p>
  /**
</p>
<p>
  &nbsp;* <b style="BACKGROUND-COLOR:#ff6666">@status obsolete</b><br/>

</p>
<p>
  &nbsp;* <strong>originX</strong> is the starting point's X coordinate (in
  pixels)
</p>
<p>
  &nbsp;* <strong>originY</strong> is the starting point's&nbsp;Y coordinate (in
  pixels)
</p>
<p>

  &nbsp;* <strong>orientationAngle</strong> has 0 and 360&nbsp;as straight up. -
  If someone prefers using 0 as right instead, I'm not really picky. I would
  rather use degrees than radians as it's easier to express cardinal and other
  basic compass points in degrees using javascript and other normal languages.
</p>
<p>
  &nbsp;* <strong>minimumDistance</strong> enables one to start checking at some
  distance from a point. Partially to enable continuing a search that had ended
  at some previously specified maximumDistance
</p>
<p>
  &nbsp;* <strong>maximumDistance</strong> if 0 this means find the object
  that's actually at the specified point.

</p>
<p>
  &nbsp;*
</p>
<p>
  &nbsp;* <strong>returns</strong> null if no visible object lies along the path
  within the specified distances
</p>
<p>
  &nbsp;* <strong>throws</strong> invalid_range if minimum is greater than
  maximum

</p>
<p>
  &nbsp;*
</p>
<p>
  &nbsp;* calling getVisibleNodeAlongPath(x, y) could be treated as
  getVisibleNodeAlongPath(x, y, 0, 0, 0) which is legal and would return the
  topmost visible dom object at the point x,y.
</p>
<p>
  &nbsp;*/
</p>
<p>
  <i><strong>DOMNode</strong></i>

  <strong>getVisibleNodeAlongPath</strong>(<em>in int</em>
  <strong>originX</strong>, <em>in int</em> <strong>originY</strong>, <em>in
  float</em> <strong>orientationAngleInDegrees</strong>, <em>in int</em>

  <strong>minimumDistance</strong>, <em>in int</em>
  <strong>maximumDistance</strong>);
</p>
<p>
  &nbsp;
</p>
<p>
  /**
</p>

<p>
  &nbsp;* I'd like to be able to get another smaller visualregion from the
  current visual region. coordinates are document coordinates, not relative to
  the current visual region.
</p>
<p>
  &nbsp;* left
</p>
<p>
  &nbsp;* top
</p>
<p>
  &nbsp;* right
</p>
<p>

  &nbsp;* bottom
</p>
<p>
  &nbsp;*
</p>
<p>
  &nbsp;* <strong>throws</strong> if coordinates are outside the visual region
</p>
<p>
  &nbsp;*

</p>
<p>
  &nbsp;*/
</p>
<p>
  <i>&nbsp;<strong>VisualRegion</strong></i>
  <strong>getVisualRegion</strong>(<em>in int</em> left, <em>in </em>int<em>

  </em>top, <em>in int</em> right,&nbsp;<em>in int</em> bottom);
</p>
<p>
  }
</p>
<p>
  &nbsp;
</p>

<p>
  <em>interface</em> Something {
</p>
<p>
  /**
</p>
<p>
  &nbsp;* left
</p>
<p>
  &nbsp;* top

</p>
<p>
  &nbsp;* right
</p>
<p>
  &nbsp;* bottom
</p>
<p>
  &nbsp;*/
</p>
<p>
  &nbsp;<i><strong>VisualRegion</strong></i>

  <strong>getVisualRegion</strong>(<em>in int</em> left, <em>in </em>int<em>
  </em>top, <em>in int</em> right,&nbsp;<em>in int</em> bottom);

</p>
<p>
  }
</p>
<p>
  <br/>
  &nbsp;
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
<br/>
<h3>

  Debugging help
</h3>
function Trace()<br/>
{<br/>
<br/>
&nbsp;&nbsp;&nbsp; function setupLoggers() {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var prlog = {log:(function () {})},
mclog;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mclog = dump;<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log = (function log(module, level,
message) {message = module + ":" + level + "&nbsp;&nbsp;&nbsp; " +
message;prlog.log(module, level, message);mclog(message);});<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maybeBreak = function(){};<br/>
&nbsp;&nbsp;&nbsp; }<br/>
<br/>
&nbsp;&nbsp;&nbsp; setupLoggers();<br/>
<br/>
&nbsp;&nbsp;&nbsp; var logger = (typeof log != "undefined") ? log : (function
(a, b, c) {dump([a, b, c].toString());});<br/>

&nbsp;&nbsp;&nbsp; var trace = (function trace(args) {maybeBreak();function
toArray(ary) {var o = new trace.Array(), i;for (i = 0; i &lt; ary.length; ++i)
{o[i] = ary[i];}return o;}function stack() {try {var stackArray = [];var Stack =
Components.stack.caller.caller;while (Stack)
{stackArray.push(Stack.toString());Stack = Stack.caller;}} catch (e) {}return
stackArray;}logger("jsconsole", 5, args.callee.name + "(" + toArray(args) +
"){/*" + stack().join("\n") + "*/\r\n");});<br/>
&nbsp;&nbsp;&nbsp; trace.Array = Array;<br/>
&nbsp;&nbsp;&nbsp; return trace;<br/>
}<br/>
var trace = Trace();<br/>
<br/>
<hr size="2" width="100%"/> /* to use */<br/>

function something() {<br/>
trace(arguments);<br/>
print(1);<br/>
}<br/>
function something2(a, b) {<br/>
trace(arguments);<br/>
something(b, a, arguments.length);<br/>
}<br/>
something2(1,2,4,6,8);<br/>

&nbsp;<br/>
<br/>
1<br/>
1<br/>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
1<br/>
<br/>
<b>Debugging with a browser</b><br/>
<p>
  <br/>

</p>
<p>
  Save this html code to snav.html and the javascript on this page to snav.js.
</p>
<p>
  Then load the page with Firefox and use Venkman or whatever debugger you want
  to use.<br/>
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
&lt;html&gt;<br/>
&lt;head&gt;<br/>

&lt;title&gt;debug snav algorithm&lt;/title&gt;<br/>
&lt;/head&gt;<br/>
&lt;body&gt;<br/>
&lt;form id=travels&gt;<br/>
&nbsp; &lt;select id=heading&gt;<br/>
&nbsp;&nbsp;&nbsp; &lt;option value=0&gt;east<br/>

&nbsp;&nbsp;&nbsp; &lt;option value=1&gt;north<br/>
&nbsp;&nbsp;&nbsp; &lt;option value=2&gt;west<br/>
&nbsp;&nbsp;&nbsp; &lt;option value=3&gt;south<br/>
&nbsp; &lt;/select&gt;<br/>
&nbsp; &lt;button onclick="document.getElementById('cell').value =
sn.traverse(document.getElementById('heading').value-0); return false;"&gt;<br/>

&nbsp;&nbsp;&nbsp; Traverse<br/>
&nbsp; &lt;/button&gt;<br/>
&nbsp; &lt;button onclick="document.getElementById('cell').value =
sn.insertFocus(document.getElementById('heading').value-0); return false;"&gt;<br/>
&nbsp;&nbsp;&nbsp; Insert Focus<br/>
&nbsp; &lt;/button&gt;<br/>
&nbsp; &lt;button onclick="document.forms.travels.routes.value=testWalk();
return false;"&gt;<br/>

&nbsp;&nbsp;&nbsp; Test Walk<br/>
&nbsp; &lt;/button&gt;<br/>
&nbsp; &lt;button onclick="document.forms.travels.routes.value='';
document.getElementById('cell').value=''; return false;"&gt;<br/>
&nbsp;&nbsp;&nbsp; Clear<br/>
&nbsp; &lt;/button&gt;&lt;br&gt;<br/>
&nbsp; &lt;input id=cell&gt;&lt;br&gt;<br/>

&nbsp; &lt;textarea id=routes rows=20 cols=40&gt;<br/>
&nbsp; &lt;/textarea&gt;&lt;br&gt;<br/>
&nbsp; &lt;textarea id=console rows=20 cols=40&gt;<br/>
&nbsp; &lt;/textarea&gt;<br/>
&lt;/form&gt;<br/>
&lt;script&gt;<br/>

&nbsp;function print() {<br/>
&nbsp;&nbsp; document.forms.travels.console.value+="\r\n";<br/>
&nbsp;}<br/>
&nbsp;function dump() {<br/>
&nbsp;&nbsp; var a = "";<br/>
&nbsp;&nbsp; for (var i = 0 ; i &lt; arguments.length; ++i)<br/>

&nbsp;&nbsp;&nbsp; a += arguments[i];<br/>
&nbsp;&nbsp; document.forms.travels.console.value+=a;<br/>
&nbsp;}<br/>
&lt;/script&gt;<br/>
&lt;script src="snav.js"&gt;&lt;/script&gt;<br/>
&lt;/body&gt;<br/>
&lt;/html&gt;<br/>

<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
<p>
  <br/>
</p>
<h2>
  Preferences to control basic things
</h2>
<p>
  user_pref("snav.enabled", true);<br/>
  user_pref("snav.ignoreTextFields", false);<br/>

  user_pref("snav.keyCode.down", 40);<br/>
  user_pref("snav.keyCode.left", 37);<br/>
  user_pref("snav.keyCode.modifier", 0);<br/>
  user_pref("snav.keyCode.right", 39);<br/>
  user_pref("snav.keyCode.up", 38);<br/>
</p>
<p>

  <br/>
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
<p>
  1
</p>
<div>
  <table border="0" cellpadding="3" cellspacing="0">
    <tbody>
    <tr>

      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        166<br/>
        a<br/>
      </td>
      <td width="16%">

        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        button<br/>
        191<br/>

      </td>
      <td width="16%">
        191<br/>
      </td>
    </tr>
    <tr>
      <td width="16%">
        194<br/>

        input<br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>

      <td width="16%">
        181<br/>
        a<br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">

        <br/>
      </td>
    </tr>
    <tr>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>

      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        162<br/>
        a<br/>
      </td>

      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="16%">

        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        176<br/>
        button
      </td>

      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>

    </tr>
    <tr>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">

        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        187<br/>
        input<br/>

      </td>
      <td width="16%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="16%">
        <br/>
      </td>

      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>

      <td width="16%">
        <br/>
      </td>
      <td width="16%">
        <br/>
      </td>
    </tr>
    </tbody>
  </table>

</div>
<p>
  1
</p>
<p>
  <br/>
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  &nbsp;
</p>
<h2>
  Spatial Navigation
</h2>

<p>
  &nbsp;The current algorithm that mozilla's extensions/spatialnavigation uses
  doesn't work very well... I'm not going to describe it at all.
</p>
<h3>
  Goals
</h3>
<ul>
  <li>
    Walking left and then right should take you back to where you were.
    Similarly for up and down.
    <li>
      Finding objects should be done such that points along a straight line from
      the origin are favored over points that aren't. Distance is generally
      calculated as the distance between two vertical or horizontal lines (the
      lines being perpendicular to the orientation being scanned). A point that
      is at the same distance but away from the axis being scanned is still
      closer than a point at a greater distance directly on the axis.
      <li>

        Use perpendicular non overlapping boxes to set grid boundary for search
        in orientation and reverse[orientation] and stop searching along the
        perpendicular direction once an iteration finds such a boundary. - The
        limit for scanning away from the axis should be based on the first non
        overlapping boxes reachable by walking perpendicular to the orientation
        direction. Essentially it's a grid search where the grid line boundary
        is based on what other boxes are reachable in the other direction.
        You're drawing rows and scanning whole rows, with the next row being
        defined by the next reachable row by walking from the origin along the
        column.
      </li>
</ul>
<p>
  <br/>
</p>
<p>
  1
</p>
<p>
  1
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">

  <br/>
</p>
<p>
  1
</p>
<p>
  For reference, the directional system is based on this picture, with cardinal
  directions rotated 45 degrees counter clockwise to get their numbering (just
  to be confusing). So east is positive x-axis.<br/>
</p>
<p>
  <img src="http://content.answers.com/main/content/wp/en/thumb/e/e1/324px-Cartesian_coordinates_2D.svg.png"/><br/>
</p>
<p>

  1
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
<p>
  1
</p>
<p>
  1
</p>
<p>
  <br/>

</p>
<p>
  This is a pair of overlapping objects, "Narrow" and "Tall and Wide". The
  overlap is colored Orange.<br/>
</p>
<div>
  <table border="1" bordercolor="#000000" cellpadding="3" cellspacing="0">
    <tbody>
    <tr bgcolor="#ffffff">
      <td width="20%">
        <br/>

      </td>
      <td width="20%">
        <br/>
      </td>
      <td bgcolor="#66cccc" width="20%">
        North<br/>
      </td>
      <td bgcolor="#ffffff" width="20%">

        <br/>
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <br/>

      </td>
      <td width="20%">
        <br/>
      </td>
      <td bgcolor="#ff0000" width="20%">
        Tall and Wide<br/>
      </td>
      <td bgcolor="#ff0000" width="20%">

        Tall and Wide
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td bgcolor="#66cccc" width="20%">
        West<br/>

      </td>
      <td bgcolor="#ffff66" width="20%">
        Narrow<br/>
      </td>
      <td bgcolor="#ff9900" width="20%">
        Tall and Wide<br/>
        Narrow<br/>

      </td>
      <td bgcolor="#ff0000" width="20%">
        Tall and Wide
      </td>
      <td bgcolor="#66cccc" width="20%">
        East<br/>
      </td>
    </tr>
    <tr>

      <td width="20%">
        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>
      <td bgcolor="#ff0000" width="20%">
        Tall and Wide
      </td>

      <td bgcolor="#ff0000" width="20%">
        Tall and Wide
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    <tr bgcolor="#ffffff">
      <td width="20%">

        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>
      <td bgcolor="#66cccc" width="20%">
        South<br/>
      </td>

      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    </tbody>
  </table>

</div>
<p>
  Navigation rules:
</p>
<div>
  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
    <tr>
      <td width="20%">
        <b>Origin<br/>

        </b>
      </td>
      <td width="20%">
        <b>Traverse<br/>
        </b>
      </td>
      <td width="20%">
        <b>First<br/>

        </b>
      </td>
      <td width="20%">
        <b>Second<br/>
        </b>
      </td>
      <td width="20%">
        <b>Third<br/>

        </b>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>North<br/>
        </b>
      </td>

      <td width="20%">
        <i>South<br/>
        </i>
      </td>
      <td width="20%">
        Tall and Wide<br/>
      </td>
      <td width="20%">

        South<br/>
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">

        <b>West<br/>
        </b>
      </td>
      <td width="20%">
        <i>East<br/>
        </i>
      </td>
      <td width="20%">

        Narrow<br/>
      </td>
      <td width="20%">
        Tall and Wide<br/>
      </td>
      <td width="20%">
        East<br/>

      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>South<br/>
        </b>
      </td>
      <td width="20%">

        <i>North<br/>
        </i>
      </td>
      <td width="20%">
        Tall and Wide
      </td>
      <td width="20%">
        North
      </td>

      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>East </b>
      </td>

      <td width="20%">
        <i>West </i>
      </td>
      <td width="20%">
        Tall and Wide
      </td>
      <td width="20%">
        Narrow
      </td>

      <td width="20%">
        West
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Narrow<br/>
        </b>
      </td>

      <td width="20%">
        <i>West<br/>
        </i>
      </td>
      <td width="20%">
        West<br/>
      </td>
      <td width="20%">

        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Narrow<br/>

        </b>
      </td>
      <td width="20%">
        <i>East<br/>
        </i>
      </td>
      <td width="20%">
        Tall and Wide<br/>

      </td>
      <td width="20%">
        East
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>

      <td width="20%">
        <b>Narrow<br/>
        </b>
      </td>
      <td width="20%">
        <i>North<br/>
        </i>
      </td>

      <td width="20%">
        Tall and Wide
      </td>
      <td width="20%">
        North
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>

    <tr>
      <td width="20%">
        <b>Narrow<br/>
        </b>
      </td>
      <td width="20%">
        <i>South<br/>
        </i>

      </td>
      <td width="20%">
        South<br/>
      </td>
      <td width="20%">
        <br/>
      </td>
      <td width="20%">

        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Tall and Wide<br/>
        </b>
      </td>

      <td width="20%">
        <i>North<br/>
        </i>
      </td>
      <td width="20%">
        North<br/>
      </td>
      <td width="20%">

        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Tall and Wide </b>

      </td>
      <td width="20%">
        <i>South </i>
      </td>
      <td width="20%">
        South
      </td>
      <td width="20%">
        <br/>

      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Tall and Wide </b>

      </td>
      <td width="20%">
        <i>East<br/>
        </i>
      </td>
      <td width="20%">
        East<br/>
      </td>

      <td width="20%">
        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">

        <b>Tall and Wide </b>
      </td>
      <td width="20%">
        <i>West<br/>
        </i>
      </td>
      <td width="20%">
        Narrow<br/>

      </td>
      <td width="20%">
        West<br/>
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>

    </tbody>
  </table>
</div>
<p>
  <br/>
</p>
<p>
  &nbsp;
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>

<p>
  <br/>
</p>
<p>
  This is an object containing another object, "Outer" and "Inner". The overlap
  is colored Orange.<br/>
</p>
<div>
  <table border="1" bordercolor="#000000" cellpadding="3" cellspacing="0">
    <tbody>
    <tr bgcolor="#ffffff">
      <td width="20%">

        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>
      <td bgcolor="#66cccc" width="20%">
        North<br/>
      </td>

      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">

        <br/>
      </td>
      <td bgcolor="#ff0000" width="20%">
        Outer<br/>
      </td>
      <td bgcolor="#ff0000" width="20%">
        Outer<br/>
      </td>

      <td bgcolor="#ff0000" width="20%">
        Outer
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td bgcolor="#66cccc" width="20%">

        West<br/>
      </td>
      <td bgcolor="#ff0000" width="20%">
        Outer
      </td>
      <td bgcolor="#ff9900" width="20%">
        Outer<br/>
        Inner<br/>

      </td>
      <td bgcolor="#ff0000" width="20%">
        Outer
      </td>
      <td bgcolor="#66cccc" width="20%">
        East<br/>
      </td>
    </tr>
    <tr>

      <td width="20%">
        <br/>
      </td>
      <td bgcolor="#ff0000" width="20%">
        Outer
      </td>
      <td bgcolor="#ff0000" width="20%">
        Outer
      </td>
      <td bgcolor="#ff0000" width="20%">

        Outer
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    <tr bgcolor="#ffffff">
      <td width="20%">
        <br/>

      </td>
      <td width="20%">
        <br/>
      </td>
      <td bgcolor="#66cccc" width="20%">
        South<br/>
      </td>
      <td bgcolor="#ffffff" width="20%">

        <br/>
      </td>
      <td bgcolor="#ffffff" width="20%">
        <br/>
      </td>
    </tr>
    </tbody>
  </table>
</div>

<p>
  Navigation rules (these favor escaping nested messes if you are unfortunate
  enough to start in one - normally you shouldn't start in a nesting point):
</p>
<ul>
  <li>
    Inner always skips outer if it's the origin. You should (we hope) be able to
    get back to inner by turning once, backtracking (that's mostly guaranteed)
    and returning towards inner.
    <li>
      Outer always skips inner if it's the origin. You should (we hope) be able
      to get back to inner by turning once, backtracking (that's mostly
      guaranteed) and returning towards outer and continuing in that direction
      an additional step.<br/>
    </li>
</ul>
<div>

  <table border="1" cellpadding="3" cellspacing="0">
    <tbody>
    <tr>
      <td width="20%">
        <b>Origin<br/>
        </b>
      </td>
      <td width="20%">

        <b>Traverse<br/>
        </b>
      </td>
      <td width="20%">
        <b>First<br/>
        </b>
      </td>
      <td width="20%">

        <b>Second<br/>
        </b>
      </td>
      <td width="20%">
        <b>Third<br/>
        </b>
      </td>
    </tr>

    <tr>
      <td width="20%">
        <b>North<br/>
        </b>
      </td>
      <td width="20%">
        <i>South<br/>
        </i>

      </td>
      <td width="20%">
        Outer<br/>
      </td>
      <td width="20%">
        Inner<br/>
      </td>
      <td width="20%">

        South<br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>West<br/>
        </b>
      </td>

      <td width="20%">
        <i>East<br/>
        </i>
      </td>
      <td width="20%">
        Outer<br/>
      </td>
      <td width="20%">

        Inner<br/>
      </td>
      <td width="20%">
        East<br/>
      </td>
    </tr>
    <tr>
      <td width="20%">

        <b>South<br/>
        </b>
      </td>
      <td width="20%">
        <i>North<br/>
        </i>
      </td>
      <td width="20%">

        Outer
      </td>
      <td width="20%">
        Inner
      </td>
      <td width="20%">
        North<br/>
      </td>
    </tr>

    <tr>
      <td width="20%">
        <b>East </b>
      </td>
      <td width="20%">
        <i>West </i>
      </td>
      <td width="20%">

        Outer
      </td>
      <td width="20%">
        Inner
      </td>
      <td width="20%">
        West
      </td>
    </tr>
    <tr>

      <td width="20%">
        <b>Inner<br/>
        </b>
      </td>
      <td width="20%">
        <i>West<br/>
        </i>
      </td>

      <td width="20%">
        West<br/>
      </td>
      <td width="20%">
        <br/>
      </td>
      <td width="20%">
        <br/>

      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Inner </b>
      </td>
      <td width="20%">
        <i>East<br/>

        </i>
      </td>
      <td width="20%">
        East
      </td>
      <td width="20%">
        <br/>
      </td>
      <td width="20%">

        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Inner </b>
      </td>
      <td width="20%">

        <i>North<br/>
        </i>
      </td>
      <td width="20%">
        North<br/>
      </td>
      <td width="20%">
        <br/>

      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Inner </b>

      </td>
      <td width="20%">
        <i>South<br/>
        </i>
      </td>
      <td width="20%">
        South<br/>
      </td>

      <td width="20%">
        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">

        <b>Outer<br/>
        </b>
      </td>
      <td width="20%">
        <i>North<br/>
        </i>
      </td>
      <td width="20%">

        North<br/>
      </td>
      <td width="20%">
        <br/>
      </td>
      <td width="20%">
        <br/>
      </td>

    </tr>
    <tr>
      <td width="20%">
        <b>Outer </b>
      </td>
      <td width="20%">
        <i>South </i>
      </td>

      <td width="20%">
        South<br/>
      </td>
      <td width="20%">
        <br/>
      </td>
      <td width="20%">
        <br/>

      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Outer </b>
      </td>
      <td width="20%">
        <i>East<br/>

        </i>
      </td>
      <td width="20%">
        East<br/>
      </td>
      <td width="20%">
        <br/>
      </td>

      <td width="20%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="20%">
        <b>Outer </b>
      </td>

      <td width="20%">
        <i>West<br/>
        </i>
      </td>
      <td width="20%">
        West
      </td>
      <td width="20%">
        <br/>

      </td>
      <td width="20%">
        <br/>
      </td>
    </tr>
    </tbody>
  </table>
</div>
<p>
  Demo

</p>
<div>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
    <tbody>
    <tr>
      <td width="100%">
        <a href="http://www.google.com/">This is hot</a><br/>
      </td>
    </tr>

    </tbody>
  </table>
</div>
<p>
  &nbsp;
</p>
<p>
  &nbsp; Annoying flavor
</p>
<div>
  <table border="1" cellpadding="3" cellspacing="0">

    <tbody>
    <tr>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">

        <br/>
      </td>
      <td width="14%">
        North<br/>
      </td>
      <td width="14%">
        <br/>
      </td>

      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="14%">

        <br/>
      </td>
      <td bgcolor="#ff0000" width="14%">
        Outer
      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">
        Outer<br/>

      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">
        <br/>
      </td>

    </tr>
    <tr>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        Outer
      </td>
      <td bgcolor="#ff9900" width="14%">

        Outer<br/>
        Inner
      </td>
      <td width="14%">
        Outer<br/>
        Inner<br/>
      </td>
      <td width="14%">

        Outer<br/>
        Inner
      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">
        <br/>
      </td>

    </tr>
    <tr>
      <td bgcolor="#66cccc" width="14%">
        West<br/>
      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">

        Outer<br/>
        Inner
      </td>
      <td bgcolor="#33ff33" width="14%">
        Outer<br/>
        Inner<br/>
        Origin<br/>

      </td>
      <td width="14%">
        Outer<br/>
        Inner
      </td>
      <td width="14%">
        Outer
      </td>
      <td bgcolor="#66cccc" width="14%">

        East<br/>
      </td>
    </tr>
    <tr>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">

        Outer
      </td>
      <td width="14%">
        Outer<br/>
        Inner
      </td>
      <td width="14%">
        Outer<br/>
        Inner
      </td>

      <td width="14%">
        Outer<br/>
        Inner
      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">
        <br/>

      </td>
    </tr>
    <tr>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        Outer
      </td>

      <td width="14%">
        Outer
      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">
        Outer
      </td>
      <td width="14%">

        Outer
      </td>
      <td width="14%">
        <br/>
      </td>
    </tr>
    <tr>
      <td width="14%">
        <br/>

      </td>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        South<br/>

      </td>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        <br/>
      </td>
      <td width="14%">
        <br/>

      </td>
    </tr>
    </tbody>
  </table>
</div>
<div>
</div>
<p>
  &nbsp;
</p>
<p>
  &nbsp;

</p>
<div>
</div>
<p>
  &nbsp; 1
</p>
<p>
  1
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
<p>

  <br/>
</p>
<p>
  Future enhancement<br/>
</p>
<ul>
  <li>
    Deal with framesets, iframe, object
    <ul>
      <li>
        framesets and iframes should be handled by densely populating the entire
        grid of the frame/iframe with pointers that indicate a nested grid for
        the nested document. location is remembered by global coordinates on the
        outer document, but the search will find the pointers to the nested
        grid. the search in the nested grid will translate the coordinates to
        search its grid and collect as many unique objects as it can according
        to the algorithm this will include allowing it to scroll the nested
        frame if possible. Focus insertion will only happen after focus is
        cleared by scrolling to the absolute edge of the browser (not a frame).<br/>

      </li>
    </ul>
    <li>
      Deal with &lt;enter&gt; dispatching and dual mode
    </li>
</ul>
<p>
  &nbsp;
</p>

<p>
  Provide insertion and directional hinting.
</p>
<p>
  Rules
</p>
<ul>
  <li>
    Hints are shown for 30 seconds, after which they disappear
    <li>
      Focusing the web browser shows the hints again
      <li>

        Hints are shown when the web browser stops scrolling
      </li>
</ul>
<br/>
<p>
  <br/>
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  &nbsp;
</p>
<p>
  function MyNode(type, value, x, y, width, height, parent) {
</p>

<p>
  &nbsp;&nbsp;&nbsp;if (type=="QTree")
</p>
<p>
  &nbsp;&nbsp;&nbsp;&nbsp; return new QTree(value, x, y, width, height, parent);
</p>
<p>
  &nbsp;&nbsp; this.init.apply(this, arguments);
</p>
<p>
  &nbsp;&nbsp; return this;<br/>

</p>
<p>
  }
</p>
<p>
  function IDirected() {}<br/>
  IDirected.prototype = {<br/>
  &nbsp;constructor: IDirected,<br/>
  /* This is a 0 based equivalent of the Cartesian coordinate system<br/>

  &nbsp;*
  http://www.answers.com/topic/cartesian-coordinate-system#Two-dimensional_coordinate_system<br/>
  &nbsp;*/<br/>
  &nbsp;EAST: 0,<br/>
  &nbsp;NORTH: 1,<br/>
  &nbsp;WEST: 2,<br/>
  &nbsp;SOUTH: 3,<br/>

  &nbsp; /* center of box */<br/>
  &nbsp;HCENTER: 4,<br/>
  &nbsp;VCENTER: 5,
</p>
<p>
  &nbsp;/* getVectorsFromNode has alternate inflexible boundary conditions
  defined from origin */<br/>
  &nbsp;BOUND_MIN: 6,<br/>

  &nbsp;BOUND_MAX: 7,<br/>
  &nbsp;ACROSS: 8,<br/>
</p>
<p>
  &nbsp;/* DOMNodes *stack* which means that conceptually up/down really should
  refer to zorder*/<br/>
  &nbsp;UP: 4,<br/>
  &nbsp;DOWN: 5,<br/>

  &nbsp;ENGLISH: [<br/>
  &nbsp; "EAST",<br/>
  &nbsp; "NORTH",<br/>
  &nbsp; "WEST",<br/>
  &nbsp; "SOUTH",<br/>

  &nbsp; "HCENTER",<br/>
  &nbsp; "VCENTER",<br/>
  &nbsp; "BOUND_MIN",<br/>
  &nbsp; "BOUND_MAX",<br/>
  &nbsp;],<br/>

  &nbsp;cw: null,<br/>
  &nbsp;ccw: null,<br/>
  &nbsp;reverse: null,<br/>
</p>
<p>
  &nbsp;upper: null,<br/>
  &nbsp;lower: null,<br/>

  &nbsp;concat: function IDirected_concat(array, more) {<br/>
  &nbsp; if (!more)<br/>
  &nbsp;&nbsp; return;<br/>
  &nbsp; array.push.apply(array,more);<br/>
  &nbsp;},<br/>

  &nbsp;isPerpendicular: function IDirected_isPerpendicular(orientation,
  direction) {<br/>
  &nbsp; return orientation % 2 != direction % 2;<br/>
  &nbsp;},<br/>
</p>
<p>
  &nbsp;removeDuplicates: function IDirected_removeDuplicates(array) {<br/>
  &nbsp; for (var x = array.length; x--; ) {<br/>

  &nbsp;&nbsp; for (var y = x + 1; y &lt; array.length; ++y) {<br/>
  &nbsp;&nbsp;&nbsp; if (array[x] === array[y])<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; array.splice(y, 1);<br/>
  &nbsp;&nbsp; }<br/>

  &nbsp; }<br/>
  &nbsp;},
</p>
<p>
  &nbsp;init: function IDirected_init() {<br/>
  &nbsp; this.cw = [this.SOUTH, this.EAST, this.NORTH, this.WEST];<br/>
  &nbsp; this.ccw = [this.NORTH, this.WEST, this.SOUTH, this.EAST];<br/>

  &nbsp; this.reverse = [this.WEST, this.SOUTH, this.EAST, this.NORTH];
</p>
<p>
  &nbsp; /* 4-3*(orient % 2) */<br/>
  &nbsp; this.lower = [this.WEST, this.NORTH, this.WEST, this.NORTH];<br/>
  &nbsp; /* 3*(orient % 2) */<br/>

  &nbsp; this.upper = [this.EAST, this.SOUTH, this.EAST, this.SOUTH];<br/>
</p>
<p>
  &nbsp;}<br/>
  }<br/>
  IDirected.prototype.init();<br/>
</p>
<p>

  <br/>
</p>
<p>
  MyNode.prototype = {
</p>
<p>
  constructor: MyNode,<br/>
</p>
<p>
  __proto__: new IDirected,
</p>
<p>

  offsetParent: null,
</p>
get offsetLeft() {return this.x;},<br/>
get offsetTop() {return this.y;},<br/>
get offsetHeight() {return this.height;},<br/>
get offsetWidth() {return this.width;},<br/>
<p>
  nextObject: 0,
</p>
init: function MyNode_init(type, value, x, y, width, height, parent) {<br/>

&nbsp;&nbsp; this.objectId = ++MyNode.prototype.nextObject;<br/>
&nbsp;&nbsp; this.type = type;<br/>
&nbsp;&nbsp; this.value = value;<br/>
&nbsp;&nbsp; this.x = x &gt;&gt; 0;<br/>
&nbsp;&nbsp; this.y = y &gt;&gt; 0;<br/>

&nbsp;&nbsp; this.width = width &gt;&gt; 0;<br/>
&nbsp;&nbsp; this.height = height &gt;&gt; 0;<br/>
&nbsp;&nbsp; this.parent = parent;<br/>
},<br/>
get left() {return this.x;},<br/>

get right() {return this.x + this.width;},<br/>
get top() {return this.y;},<br/>
get bottom() {return this.y + this.height;},<br/>
get vcenter() {return this.y + (this.height / 2) &gt;&gt; 0},<br/>
get hcenter() {return this.x + (this.width / 2) &gt;&gt; 0},<br/>
getLeft: function MyNode_getLeft(node) {if (node instanceof XML) return
node.left; return node.offsetLeft + (node &amp;&amp; node.offsetParent ?
this.getLeft(node.offsetParent) : 0)},<br/>

getRight: function MyNode_getRight(node) {if (node instanceof XML) return
node.left + node.width; return this.getLeft(node) + node.offsetWidth},<br/>
getTop: function MyNode_getTop(node) {if (node instanceof XML) return node.top;
return node.offsetTop + (node &amp;&amp; node.offsetParent ?
this.getTop(node.offsetParent) : 0)},<br/>
<p>
  getBottom: function MyNode_getBottom(node) {if (node instanceof XML) return
  node.top + node.height; return this.getTop(node) + node.offsetHeight},
</p>
<p>
  getVCenter: function MyNode_getVCenter(node) {return (this.getTop(node) +
  node.offsetHeight / 2) &gt;&gt; 0},
</p>
getHCenter: function MyNode_getHCenter(node) {return (this.getLeft(node) +
node.offsetWidth / 2) &gt;&gt; 0},<br/>

getIndentedNodeString: function MyNode_getIndentedNodeString(node) {<br/>
&nbsp; return (""+node).replace(/^/mg, "&nbsp; ");<br/>
},<br/>
getContainerString: function MyNode_getContainerString(x) {<br/>
&nbsp; if (!this.children[x])<br/>
&nbsp;&nbsp;&nbsp; return "";<br/>

&nbsp; return " &lt;QCell left="+this.getCellLeft(x)+<br/>
" right="+this.getCellRight(x)+<br/>
" top="+this.getCellTop(x)+<br/>
" bottom="+this.getCellBottom(x)+"&gt;\n"+<br/>
this.getIndentedNodeString(this.children[x])+<br/>
"\n &lt;/QCell&gt;\n";<br/>

},<br/>
toString: function MyNode_toString() {<br/>
&nbsp; var children = '';<br/>
&nbsp; if (this.children) {<br/>
&nbsp;&nbsp; for (var x = 0; x &lt; 4; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; children += this.getContainerString(x);<br/>

&nbsp;&nbsp; if (this.children[4]) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; children += " &lt;QStack&gt;\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp; for (var x = 5; x &lt; this.children.length; ++x)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; children +=
this.getIndentedNodeString(this.children[x])+"\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp; children += " &lt;/QStack&gt;\n";<br/>

&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp; return "&lt;"+this.type+" objectId="+this.objectId+<br/>
&nbsp;&nbsp;&nbsp; (this.value?" value='"+this.value+"'":"")+<br/>
&nbsp;&nbsp;&nbsp; " area="+this.width*this.height+<br/>
&nbsp;&nbsp;&nbsp; " left="+this.left+" right="+this.right+<br/>

&nbsp;&nbsp;&nbsp; " top="+this.top+" bottom="+this.bottom+<br/>
&nbsp;&nbsp;&nbsp; "&gt;\n"+children+"&lt;/"+this.type+"&gt;";<br/>
&nbsp;}<br/>
}<br/>
function Grid(value, x, y, width, height, parent) {<br/>
&nbsp; this.init(this.constructor.name, value, x, y, width, height, parent);<br/>

}<br/>
Grid.prototype = {<br/>
__proto__: new MyNode,<br/>
constructor: Grid,<br/>
children: null,<br/>
unhandled: null,<br/>
addNodeToArray: function Grid_addNodeToArray(array, i, node) {<br/>
&nbsp;if (!array[i])<br/>
&nbsp; array[i] = [];<br/>

&nbsp;if (node)<br/>
&nbsp; array[i].push(node);<br/>
&nbsp;return array[i];<br/>
},<br/>
getCell: function Grid_getCell(x, y) {<br/>
&nbsp;x = (x / this.x) &gt;&gt; 0;<br/>
&nbsp;y = (y / this.y) &gt;&gt; 0;<br/>

&nbsp;var range = this.addNodeToArray(this.children, x);<br/>
&nbsp;return this.addNodeToArray(range, y);<br/>
},<br/>
/* edges and orientations are equivalent, each box has a north, south, east,
west edge */<br/>
getCellBound: function Grid_getCellBound(x, y, edge) {<br/>
&nbsp;if (edge % 2)<br/>
&nbsp; return this.y * (y + ((edge - 1) / 2));<br/>
&nbsp;return this.x * (x + (3 - edge) / 2);<br/>

},<br/>
getNodeBound: function Grid_getNodeBound(node, edge) {<br/>
&nbsp;switch (edge) {<br/>
&nbsp;case this.WEST:<br/>
&nbsp; return (this.getLeft(node) / this.x) &gt;&gt; 0;<br/>
&nbsp; break;<br/>
&nbsp;case this.EAST:<br/>

&nbsp; return (this.getRight(node) / this.x) &gt;&gt; 0;<br/>
&nbsp; break;<br/>
&nbsp;case this.NORTH:<br/>
&nbsp; return (this.getTop(node) / this.y) &gt;&gt; 0;<br/>
&nbsp; break;<br/>

&nbsp;case this.SOUTH:<br/>
&nbsp; return (this.getBottom(node) / this.y) &gt;&gt; 0;<br/>
&nbsp; break;<br/>
&nbsp;case this.HCENTER:<br/>
&nbsp; return ((this.getLeft(node) + this.getRight(node)) / this.x) &gt;&gt; 1;<br/>

&nbsp; break;<br/>
&nbsp;case this.VCENTER:<br/>
&nbsp; return ((this.getTop(node) + this.getBottom(node)) / this.y) &gt;&gt; 1;<br/>
&nbsp; break;<br/>
&nbsp;default:<br/>
&nbsp;}<br/>

&nbsp;return NaN;<br/>
},<br/>
addNode: function Grid_addNode(node) {<br/>
&nbsp;var west = this.getNodeBound(node, this.WEST);<br/>
&nbsp;var east = this.getNodeBound(node, this.EAST);<br/>
&nbsp;var north = this.getNodeBound(node, this.NORTH);<br/>
&nbsp;var south = this.getNodeBound(node, this.SOUTH);<br/>
&nbsp;if (0) {<br/>
&nbsp; this.unhandled.push(node);<br/>

&nbsp; return;<br/>
&nbsp;}<br/>
&nbsp;/* we intentionally start one to the right of west,<br/>
&nbsp; * and stop one to the left of east, the following loop<br/>
&nbsp; * operates on west and east directly.<br/>
&nbsp; * A picture, first pass we do --s, second pass we do |s.<br/>
&nbsp; * |-|<br/>

&nbsp; * | |<br/>
&nbsp; * |-|<br/>
&nbsp; */<br/>
&nbsp;for (var x = west + 1; x &lt; east; ++x) {<br/>
&nbsp; var range = this.addNodeToArray(this.children, x, null);<br/>
&nbsp; this.addNodeToArray(range, north, node);<br/>

&nbsp; if (north == south)<br/>
&nbsp;&nbsp; continue;<br/>
&nbsp; this.addNodeToArray(range, south, node);<br/>
&nbsp;}<br/>
&nbsp;east = east == west ? null : this.addNodeToArray(this.children, east,
null);<br/>
&nbsp;west = this.addNodeToArray(this.children, west, null);<br/>
&nbsp;for (var y = north; y &lt;= south; ++y) {<br/>

&nbsp; this.addNodeToArray(west, y, node);<br/>
&nbsp; if (!east)<br/>
&nbsp;&nbsp; continue;<br/>
&nbsp; this.addNodeToArray(east, y, node);<br/>
&nbsp;}<br/>
},<br/>
gets: [<br/>

&nbsp;"getRight",<br/>
&nbsp;"getTop",<br/>
&nbsp;"getLeft",<br/>
&nbsp;"getBottom",<br/>
&nbsp;"getHCenter",<br/>
&nbsp;"getVCenter",<br/>
],<br/>
sorts: [<br/>
&nbsp;function rightSort(a, b) {<br/>

&nbsp; return MyNode.prototype.getRight(a) - MyNode.prototype.getRight(b);<br/>
&nbsp;},<br/>
&nbsp;function topSort(a, b) {<br/>
&nbsp; return MyNode.prototype.getTop(a) - MyNode.prototype.getTop(b);<br/>
&nbsp;},<br/>
&nbsp;function leftSort(a, b) {<br/>
&nbsp; return MyNode.prototype.getLeft(a) - MyNode.prototype.getLeft(b);<br/>

&nbsp;},<br/>
&nbsp;function bottomSort(a, b) {<br/>
&nbsp; return MyNode.prototype.getBottom(a) - MyNode.prototype.getBottom(b);<br/>
&nbsp;},<br/>
],<br/>
maybeAdd: function Grid_maybeAdd(controls, orient, cand, dims, bounds, val) {<br/>
&nbsp;switch (orient) {<br/>
&nbsp;case this.WEST:<br/>

&nbsp;case this.NORTH:<br/>
&nbsp; if (val &gt; dims[orient])<br/>
&nbsp;&nbsp; return false;<br/>
&nbsp; break;<br/>
&nbsp;case this.EAST:<br/>
&nbsp;case this.SOUTH:<br/>

&nbsp; if (val &lt; dims[orient])<br/>
&nbsp;&nbsp; return false;<br/>
&nbsp; break;<br/>
&nbsp;}<br/>
&nbsp;switch (orient) {<br/>
&nbsp;case this.EAST:<br/>

&nbsp;case this.WEST:<br/>
&nbsp; if ((this.getBottom(cand) &lt; bounds[this.BOUND_MIN]) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (this.getTop(cand) &gt; bounds[this.BOUND_MAX]))<br/>
&nbsp;&nbsp; return false;<br/>
&nbsp; break;<br/>

&nbsp;case this.NORTH:<br/>
&nbsp;case this.SOUTH:<br/>
&nbsp; if ((this.getRight(cand) &lt; bounds[this.BOUND_MIN]) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (this.getLeft(cand) &gt; bounds[this.BOUND_MAX]))<br/>
&nbsp;&nbsp; return false;<br/>

&nbsp; break;<br/>
&nbsp;}<br/>
&nbsp;var skip = controls[4];<br/>
&nbsp;for (var i = 0; i &lt; skip.length; ++i) {<br/>
&nbsp; if (skip[i] == cand)<br/>
&nbsp;&nbsp; return false;<br/>

&nbsp;}<br/>
&nbsp;switch (orient) {<br/>
&nbsp;case this.EAST:<br/>
&nbsp;case this.SOUTH:<br/>
&nbsp; bounds[this.BOUND_MAX] = Math.min(bounds[this.BOUND_MAX] || Infinity,
val);<br/>
&nbsp; break;<br/>
&nbsp;case this.NORTH:<br/>
&nbsp;case this.WEST:<br/>

&nbsp; bounds[this.BOUND_MIN] = Math.max(bounds[this.BOUND_MIN] || -Infinity,
val);<br/>
&nbsp; break;<br/>
&nbsp;}<br/>
&nbsp;controls[orient].push(cand);<br/>
&nbsp;skip.push(cand);<br/>
&nbsp;return true;<br/>
},<br/>
ensureGridXY: function Grid_ensureGridXY(x, y) {<br/>

&nbsp;return this.children[x] &amp;&amp; this.children[x][y];<br/>
},<br/>
northwestTilt: [<br/>
&nbsp;1, -1, -1, 1,<br/>
],<br/>
ensureGridXY2: function Grid_ensureGridXY2(bounds, orient, k, j, delta) {<br/>
&nbsp;var i = bounds[this.HCENTER + orient % 2] + k * j;<br/>
&nbsp;var l = bounds[this.VCENTER - orient % 2] + this.northwestTilt[orient] *
delta;<br/>

&nbsp;switch (orient) {<br/>
&nbsp;case this.EAST:<br/>
&nbsp;case this.WEST:<br/>
&nbsp; return this.ensureGridXY(l, i);<br/>
&nbsp;case this.NORTH:<br/>
&nbsp;case this.SOUTH:<br/>
&nbsp; return this.ensureGridXY(i, l);<br/>
&nbsp;}<br/>

&nbsp;return null;<br/>
},<br/>
getNodesAroundPoint: function Grid_getNodesAroundPoint(originX, originY, range,
limit) {<br/>
&nbsp;var found = [];<br/>
&nbsp;/* XXX we assert that this.x == this.y == this.scale */<br/>
&nbsp;range = (range / this.x) &gt;&gt; 0;<br/>
<br/>
&nbsp;var dims = [];<br/>

&nbsp;var x = (originX / this.x) &gt;&gt; 0;<br/>
&nbsp;var y = (originY / this.y) &gt;&gt; 0;<br/>
&nbsp;var bounds = [x, y, x, y, x, y];<br/>
&nbsp;var j, k, orient;<br/>
&nbsp;this.concat(found, this.ensureGridXY(bounds[this.HCENTER],
bounds[this.VCENTER]));<br/>
&nbsp;for (var delta = 0; delta &lt;= range &amp;&amp; found.length &lt; limit;
++delta) {<br/>

&nbsp; for (j = 1; j &lt; delta + 1; ++j) {<br/>
&nbsp;&nbsp; for (k = -1; k &lt;= 1; k += 2) {<br/>
&nbsp;&nbsp;&nbsp; for (orient = this.EAST; orient &lt;= this.SOUTH; ++orient) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.concat(found, this.ensureGridXY2(bounds, orient,
k, j, delta));<br/>
&nbsp;&nbsp;&nbsp; }<br/>

&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp;}<br/>
&nbsp;this.removeDuplicates(found);<br/>
&nbsp;return found;<br/>
},<br/>
getVectorsFromNode: function Grid_getVectorsFromNode(node, controls,
orientation, turning, limit) {<br/>
&nbsp;var delta = 0;<br/>

&nbsp;var done = false;<br/>
&nbsp;var dims = [];<br/>
&nbsp;var bounds = [];<br/>
&nbsp;var i, j, k, l, x, y, range, orient, cand;<br/>
&nbsp;for (i = this.EAST; i &lt;= this.VCENTER; ++i) {<br/>
&nbsp; dims[i] = this[this.gets[i]](node);<br/>
&nbsp; bounds[i] = this.getNodeBound(node, i);<br/>

&nbsp;}<br/>
&nbsp;bounds.length = 8;<br/>
<br/>
&nbsp;/* we favor progressing south, then east, then north, then west.<br/>
&nbsp; * to do this, nodes which can be found in the opposing directions are
sorted<br/>
&nbsp; * to them instead.<br/>
&nbsp; *<br/>
&nbsp; * we favor cardinals over secondary cardinals so we work our way out like
a vibrating straw.<br/>

&nbsp; */<br/>
&nbsp;var orientations = [this.WEST, this.NORTH, this.EAST, this.SOUTH];<br/>
if (0) {<br/>
&nbsp;/**<br/>
&nbsp; * we only want to look at orientations where there isn't navigation
information<br/>
&nbsp; */<br/>
&nbsp;if (turning) {<br/>

&nbsp; controls[this.cw[orientation]].length = 0;<br/>
&nbsp; controls[this.ccw[orientation]].length = 0;<br/>
&nbsp;}<br/>
&nbsp;for (var i = 0; i &lt; 4; ++i) {<br/>
&nbsp; orient = orientations[i];<br/>
&nbsp; if (controls[orient].length &lt; 3)<br/>

&nbsp;&nbsp; orientations.push(orient);<br/>
&nbsp;}<br/>
&nbsp;orientations.splice(0, 4);<br/>
&nbsp;if (0) {<br/>
&nbsp; if (!headings[orientation].length) {<br/>
&nbsp; } else {<br/>
&nbsp; }<br/>

&nbsp;}<br/>
} else {<br/>
&nbsp;/* east..south, skip */<br/>
&nbsp;for (i = 0; i &lt;= 4; ++i) {<br/>
&nbsp; controls[i] = [node];<br/>
&nbsp;}<br/>
}<br/>
&nbsp;do {<br/>

&nbsp; orient = orientation;<br/>
&nbsp; var neworientations = orientations.concat();<br/>
&nbsp; for (j = 0; j &lt;= delta; ++j) {<br/>
&nbsp;&nbsp; for (k = -1; k &lt;= 1; k += 2) {<br/>
&nbsp;&nbsp;&nbsp; for (l = 0; l &lt; orientations.length; ++l) {<br/>

&nbsp;&nbsp;&nbsp;&nbsp; orient = orientations[l];<br/>
&nbsp;&nbsp;&nbsp;&nbsp; range = this.ensureGridXY2(bounds, orient, k, j,
delta);<br/>
&nbsp;&nbsp;&nbsp;&nbsp; if (!range)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br/>
&nbsp;&nbsp; &nbsp; for (i = 0; i &lt; range.length; ++i) {<br/>

&nbsp;&nbsp;&nbsp; &nbsp; cand = range[i];<br/>
&nbsp;&nbsp; &nbsp;&nbsp; if (cand == node)<br/>
&nbsp; &nbsp;&nbsp; &nbsp; continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var getNatural = this.gets[orient];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this.maybeAdd(controls, orient, cand, dims,
bounds, this[getNatural](cand)) &amp;&amp;<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.isPerpendicular(orient, orientation)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* we're looking for a box that doesn't
intersect with our box<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * such a box is used to create a
search boundaries in |orient| when we look in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * |orientation| or
|reverse[orientation]|.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var val =
this[this.gets[this.reverse[orient]]](cand);<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var edge = this[getNatural](node);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var curBound;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (orient) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case this.EAST:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case this.SOUTH:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val &gt; edge &amp;&amp;

((curBound = bounds[this.BOUND_MAX]) == undefined || val &lt; curBound)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds[this.BOUND_MAX] = val;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curBound == undefined)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neworientations.splice(l,
1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case this.WEST:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case this.NORTH:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (val &lt; edge &amp;&amp;
((curBound = bounds[this.BOUND_MIN]) == undefined || val &gt; curBound)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds[this.BOUND_MIN] = val;<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (curBound == undefined)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neworientations.splice(l,
1);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>

&nbsp; &nbsp; &nbsp; }<br/>
&nbsp; &nbsp;&nbsp; }<br/>
&nbsp; &nbsp; }<br/>
&nbsp;&nbsp; }<br/>
&nbsp; }<br/>

&nbsp; orientations = neworientations;<br/>
&nbsp; delta++;<br/>
&nbsp; done = (delta &gt; 25) || (controls[4].length &gt; limit);<br/>
&nbsp;} while (!done);<br/>
&nbsp;var bounds = this.getRealNodeBounds(node);<br/>

&nbsp;for (orient = this.EAST; orient &lt;= this.SOUTH; ++orient) {<br/>
&nbsp; range = controls[orient];<br/>
&nbsp; range.sort(this.sorts[orient]);<br/>
&nbsp; if (range[0] == node)<br/>
&nbsp;&nbsp; range.shift();<br/>
&nbsp; else if (range[range.length-1] == node)<br/>

&nbsp;&nbsp; range.length--;<br/>
&nbsp;}<br/>
/* this should be integrated into the main loop */<br/>
&nbsp;var orientations = [this.WEST, this.NORTH, this.EAST, this.SOUTH];<br/>
&nbsp;for (i = 0; orientations.length; i++) {<br/>
&nbsp; for (j = 0; j &lt; orientations.length; ++j) {<br/>
&nbsp;&nbsp; orient = orientations[j];<br/>

&nbsp;&nbsp; range = controls[orient];<br/>
&nbsp;&nbsp; if (i &gt;= range.length) {<br/>
&nbsp;&nbsp;&nbsp; /* we're removing the current orientation<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * and going back to what will be here<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>
&nbsp;&nbsp;&nbsp; orientations.splice(j--, 1);<br/>

&nbsp;&nbsp;&nbsp; continue;<br/>
&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; if (this.shouldDropParallelNode(bounds, range, i, orient)) {<br/>
&nbsp;&nbsp;&nbsp; /* we're removing the current node<br/>
&nbsp;&nbsp;&nbsp;&nbsp; * and going back to what will be here<br/>
&nbsp;&nbsp;&nbsp;&nbsp; */<br/>

&nbsp;&nbsp;&nbsp; range.splice(i--, 1);<br/>
&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp;}<br/>
},<br/>
getRealNodeBounds: function Grid_getRealNodeBounds(node) {<br/>
&nbsp;return [<br/>

&nbsp; this.getRight(node),<br/>
&nbsp; this.getTop(node),<br/>
&nbsp; this.getLeft(node),<br/>
&nbsp; this.getBottom(node),<br/>
&nbsp;];<br/>
},<br/>
shouldDropParallelNode: function Grid_shouldDropParallelNode(bounds, range, i,
orient) {<br/>

&nbsp;var node = range[i];<br/>
&nbsp;var bound = this.getRealNodeBounds(node);<br/>
&nbsp;var val;<br/>
&nbsp;var upper = this.upper[orient];<br/>
&nbsp;var lower = this.lower[orient];<br/>
&nbsp;var rotated = this.cw[orient];<br/>
&nbsp;if (bounds[upper] &gt; bound[upper] &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; bounds[lower] &lt; bound[lower] &amp;&amp;<br/>

&nbsp;&nbsp;&nbsp;&nbsp; (((val = bounds[this.BOUND_MIN]) != undefined
&amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val &gt; bound[this.upper[rotated]])
||<br/>
&nbsp;&nbsp;&nbsp;&nbsp; ((val = bounds[this.BOUND_MAX]) != undefined &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val &lt; bound[this.lower[rotated]]))<br/>
&nbsp;) {<br/>

&nbsp; return true;<br/>
&nbsp;}<br/>
&nbsp;bounds[orient] = bound[orient];<br/>
&nbsp;return false;<br/>
},<br/>
init: function Grid_init(type, value, x, y, width, height, parent) {<br/>
&nbsp;this.children = [];<br/>
&nbsp;this.unhandled = [];<br/>

&nbsp;MyNode.prototype.init.apply(this, arguments);<br/>
}<br/>
}<br/>
function QTree(value, x, y, width, height, parent) {
<p>
  &nbsp; this.init(this.constructor.name, value, x, y, width, height, parent);
</p>
<p>
  }
</p>
<p>

  QTree.prototype = {
</p>
<p>
  __proto__: new MyNode,
</p>
<p>
  constructor: QTree,
</p>
<p>
  children: null,
</p>
<p>
  TOP_RIGHT: 0,

</p>
<p>
  TOP_LEFT: 1,
</p>
<p>
  BOTTOM_LEFT: 2,
</p>
<p>
  BOTTOM_RIGHT: 3,&nbsp;<br/>
</p>
<p>
  FULL_NODE: 4,

</p>
<p>
  MINIMUM_CELL_SIZE: 4,<br/>
</p>
<p>
  /* cells should really have numbers
</p>
<p>
  &nbsp;10
</p>
<p>
  &nbsp;23

</p>
<p>
  is probably a reasonable numbering.
</p>
<p>
  I wonder what the odds are that the algorithm actually matches :)
</p>
<p>
  &nbsp;*/
</p>
<p>
  getCell: function QTree_getCell(x, y) {
</p>

<p>
  &nbsp;&nbsp;if (y &gt; this.bottom || x &gt; this.right || y &lt; this.top ||
  x &lt; this.left)
</p>
<p>
  &nbsp;&nbsp;&nbsp; return -1;
</p>

<p>
  &nbsp;&nbsp;return 2 * (y &gt; this.vcenter) + ((x &lt; this.hcenter) ^ (y
  &gt; this.vcenter)) ;<br/>
</p>
<p>
  },
</p>
<p>
  getCellLeft: function QTree_getCellLeft(index) {<br/>

  &nbsp;switch (index) {<br/>
  &nbsp;case this.TOP_LEFT:<br/>
  &nbsp;case this.BOTTOM_LEFT:<br/>
  &nbsp;case this.FULL_NODE:
</p>
<p>
  &nbsp;default:<br/>
  &nbsp; return this.left;<br/>

  &nbsp;case this.TOP_RIGHT:<br/>
  &nbsp;case this.BOTTOM_RIGHT:<br/>
  &nbsp; return this.hcenter;<br/>
  &nbsp;}<br/>
  },<br/>
  getCellRight: function QTree_getCellRight(index) {<br/>

  &nbsp;switch (index) {<br/>
  &nbsp;case this.TOP_LEFT:<br/>
  &nbsp;case this.BOTTOM_LEFT:<br/>
  &nbsp; return this.hcenter;<br/>
  &nbsp;case this.TOP_RIGHT:<br/>
  &nbsp;case this.BOTTOM_RIGHT:<br/>

  &nbsp;case this.FULL_NODE:<br/>
  &nbsp;default:<br/>
  &nbsp; return this.right;<br/>
  &nbsp;}<br/>
  },<br/>
  getCellTop: function QTree_getCellTop(index) {<br/>

  &nbsp;switch (index) {<br/>
  &nbsp;case this.TOP_LEFT:<br/>
  &nbsp;case this.TOP_RIGHT:<br/>
  &nbsp;case this.FULL_NODE:<br/>
  &nbsp;default:<br/>
  &nbsp; return this.top;<br/>

  &nbsp;case this.BOTTOM_LEFT:<br/>
  &nbsp;case this.BOTTOM_RIGHT:<br/>
  &nbsp; return this.vcenter;<br/>
  &nbsp;}<br/>
  },<br/>
  getCellBottom: function QTree_getCellBottom(index) {<br/>

  &nbsp;switch (index) {<br/>
  &nbsp;case this.TOP_LEFT:<br/>
  &nbsp;case this.TOP_RIGHT:<br/>
  &nbsp; return this.vcenter;<br/>
  &nbsp;case this.BOTTOM_LEFT:<br/>
  &nbsp;case this.BOTTOM_RIGHT:<br/>

  &nbsp;case this.FULL_NODE:<br/>
  &nbsp;default:<br/>
  &nbsp; return this.bottom;<br/>
  &nbsp;}<br/>
  },
</p>
<p>

  insertNode: function QTree_insertNode(idx, node) {<br/>
  &nbsp;&nbsp; if (idx == -1)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; return;<br/>
  &nbsp;&nbsp; do {<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; if (!this.children[idx]) {<br/>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.children[idx] = node;<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; }<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; if (this.children[idx] == node)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br/>

  &nbsp;&nbsp;&nbsp;&nbsp; if (idx &gt;= this.FULL_NODE)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++idx;<br/>
  &nbsp;&nbsp; } while (idx &gt; this.FULL_NODE);<br/>
  &nbsp;&nbsp; if (this.children[idx] instanceof QTree) {<br/>

  &nbsp;&nbsp;&nbsp;&nbsp; this.children[idx].addChild(node);<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; return;<br/>
  &nbsp;&nbsp; }<br/>
  &nbsp;&nbsp; var width = this.width / 2;<br/>
  &nbsp;&nbsp; var height = this.height / 2;<br/>

  &nbsp;&nbsp; if (width &lt; this.MINIMUM_CELL_SIZE || height &lt;
  this.MINIMUM_CELL_SIZE) {<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; this.insertNode(this.FULL_NODE, node);<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; return;<br/>

  &nbsp;&nbsp; }<br/>
  &nbsp;&nbsp; var oldChild = this.children[idx];<br/>
  &nbsp;&nbsp; this.children[idx] = null;<br/>
  /*print("new QTree(" 0, this.getCellLeft(idx), this.getCellTop(idx), width,
  height, this, "); ");*/<br/>
  &nbsp;&nbsp; var child = new QTree(0, this.getCellLeft(idx),
  this.getCellTop(idx), width, height, this);

</p>
<p>
  &nbsp;&nbsp; child.addChild(oldChild);
</p>
<p>
  &nbsp;&nbsp; child.addChild(node);
</p>
<p>
  &nbsp;&nbsp; this.children[idx] = child;
</p>
<p>

  },
</p>
<p>
  addChild: function QTree_addChild(child) {
</p>
&nbsp;&nbsp; var left = MyNode.prototype.getLeft(child);<br/>
&nbsp;&nbsp; var right = MyNode.prototype.getRight(child);<br/>
&nbsp;&nbsp; var top = MyNode.prototype.getTop(child);<br/>
&nbsp;&nbsp; var bottom = MyNode.prototype.getBottom(child);<br/>

&nbsp;&nbsp; if (this.left &gt;= left &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.right &lt;= right &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.top &gt;= top &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.bottom &lt;= bottom)<br/>
&nbsp;&nbsp; {

<p>
  &nbsp;&nbsp;&nbsp;&nbsp; this.insertNode(this.FULL_NODE, child);
</p>
<p>
  &nbsp;&nbsp;&nbsp;&nbsp; return;
</p>
<p>
  &nbsp;&nbsp; }<br/>
</p>
&nbsp;&nbsp; var coords = [<br/>

&nbsp;&nbsp;&nbsp;&nbsp; this.getCell(right, top),<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.getCell(left, top),<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.getCell(left, bottom),<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.getCell(right, bottom),<br/>
&nbsp;&nbsp; ];<br/>
&nbsp;&nbsp; var cell;<br/>

&nbsp;&nbsp; var maxcell = -1;<br/>
&nbsp;&nbsp; for (var i = 0; i &lt; 4; ++i) {<br/>
&nbsp;&nbsp;&nbsp; if ((cell = coords[i]) &gt; -1 &amp;&amp; cell &gt; maxcell)<br/>

&nbsp;&nbsp;&nbsp;&nbsp; this.insertNode(maxcell = cell, child);<br/>
&nbsp;&nbsp; }<br/>
<p>
  },
</p>
<p>
  init: function QTree_init(type, value, x, y, width, height, parent) {
</p>
<p>
  &nbsp;&nbsp; this.children = [];

</p>
<p>
  &nbsp;&nbsp;&nbsp;this.children.length = 5;
</p>
<p>
  &nbsp;&nbsp;&nbsp;MyNode.prototype.init.apply(this, arguments);
</p>
<p>
  }&nbsp;
</p>
<p>
  }

</p>
<br/>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  <br/>
</p>
<p>
  function ISpatialNavigation() {}
</p>
<p>
  ISpatialNavigation.prototype = {
</p>
<p>
  &nbsp;constructor: ISpatialNavigation,

</p>
&nbsp;__proto__: new IDirected,
<p>
  &nbsp;TRAVERSAL_DIRECTIONS: 6,<br/>
</p>
<p>
  &nbsp;NAVIGABLE_INCREMENT: 128,<br/>
</p>
<p>
  &nbsp;NAVIGABLE_WIDTH: 275,
</p>
<p>

  &nbsp;NAVIGABLE_HEIGHT: 200,<br/>
</p>
<p>
  &nbsp;INSERTION_FACTOR: .3
</p>
<p>
  }
</p>
<p>
  <br/>
</p>
<p>

  &nbsp;
</p>
<p>
  function SpatialNavigator(service, window) {
</p>
<p>
  &nbsp;if ("nsISpatialNavigation" in Components.interfaces)<br/>
  &nbsp; this.interfaces.push(Components.interfaces.nsISpatialNavigation);<br/>
  &nbsp;this.mService = service;<br/>

  &nbsp;this.init(window);<br/>
</p>
<p>
  }
</p>
<p>
  SpatialNavigator.prototype = {
</p>
<p>
  constructor: SpatialNavigator,
</p>
<p>

  interfaces: [<br/>
  &nbsp;Components.interfaces.nsISupports,<br/>
  &nbsp;Components.interfaces.nsIDOMEventListener,<br/>
  &nbsp;Components.interfaces.nsIWebProgressListener,<br/>
  &nbsp;Components.interfaces.nsISupportsWeakReference,
</p>
<p>
  ],<br/>

  QueryInterface: QI,<br/>
  __proto__: new ISpatialNavigation,<br/>
</p>
<p>
  /* nsISpatialNavigation */<br/>
  init: function SpatialNavigator_init(window) {<br/>
  &nbsp;this.availableNodes = [];<br/>

  &nbsp;this.availableNodes.length =
  ISpatialNavigation.prototype.TRAVERSAL_DIRECTIONS;
</p>
<p>
  &nbsp;this.mTopWindow = window;
</p>
<p>
  &nbsp;try {<br/>
  &nbsp; var target = this.mTopWindow;<br/>
  &nbsp; target.addEventListener("keypress", this, false);<br/>

  &nbsp; target.addEventListener("scroll", this, false);<br/>
  &nbsp;
  this.mTopWindow.QueryInterface(Components.interfaces.nsIInterfaceRequestor)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  .getInterface(Components.interfaces.nsIWebNavigation)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  .QueryInterface(Components.interfaces.nsIWebProgress)<br/>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addProgressListener(this, 0x000000ff);<br/>
  &nbsp;} catch (e) {}<br/>
  &nbsp;try {<br/>
  &nbsp; this.mFlasher =
  Components.classes["@mozilla.org/inspector/flasher;1"].getService(Components.interfaces.inIFlasher);<br/>
  &nbsp;} catch (e) {<br/>

  &nbsp; this.mFlasher = {<br/>
  &nbsp;&nbsp; scrollElementIntoView: function (){},<br/>
  &nbsp;&nbsp; drawElementOutline: function (){},<br/>
  &nbsp;&nbsp; repaintElement: function (){}<br/>
  &nbsp; };<br/>

  &nbsp;}<br/>
  &nbsp;this.flashes = [];<br/>
  },<br/>
  shutdown: function SpatialNavigator_shutdown() {<br/>
  /* getEventTargetFromWindow */<br/>
  &nbsp;try {<br/>

  &nbsp; var target = this.mTopWindow;<br/>
  &nbsp; target.removeEventListener("keypress", this, false);<br/>
  &nbsp;} catch (e) {}<br/>
  &nbsp;this.availableNodes = null;<br/>
  &nbsp;this.mTopWindow = null;<br/>

  },<br/>
  right: function SpatialNavigator_right() {<br/>
  &nbsp;return this.handleMove(this.EAST);<br/>
  },<br/>
  up: function SpatialNavigator_up() {<br/>
  &nbsp;return this.handleMove(this.NORTH);<br/>

  },<br/>
  left: function SpatialNavigator_left() {<br/>
  &nbsp;return this.handleMove(this.WEST);<br/>
  },<br/>
  down: function SpatialNavigator_down() {<br/>
  &nbsp;return this.handleMove(this.SOUTH);<br/>

  },<br/>
  handleMove: function SpatialNavigator_handleMove(direction) {
</p>
&nbsp;var node;<br/>
<p>
  &nbsp;if (!this.focussedElement) {
</p>
<p>
  &nbsp; /* logic for insertFocus goes here */
</p>

<p>
  &nbsp; node = this.insertFocus(direction);<br/>
</p>
<p>
  &nbsp;} else {<br/>
</p>
<p>
  &nbsp; node = this.traverse(direction);
</p>
<p>

  &nbsp;}
</p>
<p>
  &nbsp;this.previewNavigation(node);<br/>
  &nbsp;if (node)<br/>
  &nbsp; return node;<br/>
  &nbsp;// temporary until scrollWindow is implemented<br/>

  &nbsp;return false;<br/>
  &nbsp;this.scrollWindow(direction);
</p>
<p>
  &nbsp;return true;
</p>
<p>
  },<br/>
  cardinalColor: function SpatialNavigator_cardinalColor(direction, i) {<br/>

  &nbsp;var color = "66cc99";<br/>
  &nbsp;if (i) {<br/>
  &nbsp; i = i &lt;= 3 ? i : 3;
</p>
<p>
  &nbsp; switch (direction) {<br/>
  &nbsp; case this.WEST:<br/>

  &nbsp;&nbsp; color = "ffff" + (4-i)*33;<br/>
  &nbsp;&nbsp; break;<br/>
  &nbsp; case this.EAST:<br/>
  &nbsp;&nbsp; color = "00"+(0x33*(i+2)).toString(16)+"00";<br/>
  &nbsp;&nbsp; break;<br/>

  &nbsp; case this.NORTH:<br/>
  &nbsp;&nbsp; color = (0x33*(3+3-i)).toString(16) + "0000";<br/>
  &nbsp;&nbsp; break;<br/>
  &nbsp; case this.SOUTH:<br/>
  &nbsp;&nbsp; color = "ff"+(33*(i-1)+11)+"ff";<br/>

  &nbsp;&nbsp; break;<br/>
  &nbsp; default:<br/>
  &nbsp;&nbsp; return "gray";<br/>
  &nbsp; }<br/>
  &nbsp;}<br/>

  &nbsp;return "#" + color;<br/>
  },<br/>
  previewNavigation: function SpatialNavigator_previewNavigation(node) {
</p>
<p>
  &nbsp;if (node) {<br/>
  &nbsp; for (var direction = this.EAST; direction &lt;= this.SOUTH;
  direction++) {<br/>

  &nbsp;&nbsp; for (var i = 1; i &lt;= 3; ++i) {<br/>
  &nbsp;&nbsp;&nbsp; var preview = this.traverse(direction, i);<br/>
  &nbsp;&nbsp;&nbsp; if (!preview)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; break;<br/>

  &nbsp;&nbsp;&nbsp; this.addFlash(preview, 10, 3, true,
  this.cardinalColor(direction, i), 2*(4-i), false);<br/>
  &nbsp;&nbsp; }<br/>
  &nbsp; }
</p>
&nbsp;} else {<br/>
&nbsp; /* this is where this.insertFocus(_alldirections_, preview=true) should
be used */<br/>

<p>
  &nbsp;}<br/>
</p>
<p>
  },<br/>
  scrollWindow: function SpatialNavigator_scrollWindow(direction) {
</p>
<p>
  &nbsp;var contentWindow = this.mTopWindow;
</p>
<p>

  &nbsp;switch (direction) {<br/>
  &nbsp;case this.WEST:<br/>
  &nbsp; contentWindow.scrollBy(-1* this.mService.gScrollOffset, 0);<br/>
  &nbsp; break;<br/>
  &nbsp;case this.EAST:<br/>

  &nbsp; contentWindow.scrollBy(this.mService.gScrollOffset, 0);<br/>
  &nbsp; break;<br/>
  &nbsp;case this.NORTH:<br/>
  &nbsp; contentWindow.scrollBy(0, -1 * this.mService.gScrollOffset);<br/>
  &nbsp; break;<br/>

  &nbsp;case this.SOUTH:<br/>
  &nbsp; contentWindow.scrollBy(0, this.mService.gScrollOffset);<br/>
  &nbsp; break;<br/>
  &nbsp;}<br/>
  },<br/>

  addFlash: function SpatialNavigator_addFlash(node, aDuration, aSpeed, aHold,
  aColor, aThickness, aInvert)<br/>
  {
</p>
<p>
  &nbsp;if (!node)
</p>
<p>
  &nbsp; return -1;<br/>
</p>
<p>

  &nbsp;var flashRule = {<br/>
  &nbsp; element: node,<br/>
  &nbsp; stopTime: Date.now()+(aDuration||5)*1000,<br/>
  &nbsp; speed: aSpeed || 10,<br/>
  &nbsp; keep: aHold,<br/>

  &nbsp; color: aColor || "green",<br/>
  &nbsp; flashCount: 0,<br/>
  &nbsp; invert: aInvert,<br/>
  &nbsp; thickness: aThickness || 3<br/>
  &nbsp;};<br/>

  &nbsp;var i = this.flashes.push(flashRule) - 1;<br/>
  &nbsp;this.flash(i);<br/>
  &nbsp;return i;<br/>
  },<br/>
  flash: function SpatialNavigator_flash(rule) {<br/>
  &nbsp;var flashRules = (rule == "all")<br/>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  ? this.flashes<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  : [(rule - 0 == rule) ? this.flashes[rule] : rule];<br/>
  &nbsp;for (var i = 0; i &lt; flashRules.length; ++i) try {<br/>
  &nbsp; var flashRule = flashRules[i];<br/>

  &nbsp; this.mFlasher.color = flashRule.color;<br/>
  &nbsp; this.mFlasher.thickness = flashRule.thickness;<br/>
  &nbsp; this.mFlasher.invert = flashRule.invert;<br/>
  &nbsp; if (flashRule.keep || flashRule.flashCount % 2) {<br/>
  &nbsp;&nbsp; this.mFlasher.drawElementOutline(flashRule.element);<br/>

  &nbsp; } else {<br/>
  &nbsp;&nbsp; this.mFlasher.repaintElement(flashRule.element);<br/>
  &nbsp; }<br/>
  &nbsp; flashRule.flashCount++;<br/>
  &nbsp;} catch (e) {}

</p>
<p>
  },<br/>
  removeFlash: function SpatialNavigator_removeFlash(rule)<br/>
  {<br/>
  &nbsp;if (!this.flashes.length)<br/>
  &nbsp; return;

</p>
<p>
  &nbsp;var flashRules;<br/>
  &nbsp;if (rule == "all") {<br/>
  &nbsp; flashRules = this.flashes;<br/>
  &nbsp; this.flashes = [];<br/>
  &nbsp;} else {<br/>

  &nbsp; var i = rule - 0;
</p>
<p>
  &nbsp; var notFound = true;<br/>
  &nbsp; if (i != rule) {<br/>
  &nbsp;&nbsp; for (i = this.flashes.length; i &amp;&amp; (notFound =
  this.flashes[--i].element != rule); );<br/>

  &nbsp;&nbsp; if (notFound)
</p>
<p>
  &nbsp; &nbsp; return;<br/>
  &nbsp; }<br/>
  &nbsp; flashRules = this.flashes.splice(i, 1);<br/>

  &nbsp;}<br/>
  &nbsp;for (i = 0; i &lt; flashRules.length; ++i) {<br/>
  &nbsp; flashRule = flashRules[i];<br/>
  &nbsp; flashRule.keep = false;
</p>
<p>

  &nbsp; flashRule.flashCount = 0;<br/>
  &nbsp; try {
</p>
<p>
  &nbsp;&nbsp; this.flash(flashRule);<br/>
</p>
<p>
  &nbsp; } catch (e) {}<br/>

</p>
<p>
  &nbsp;}<br/>
</p>
<p>
  },<br/>
  /* nsIDOMEventListener */<br/>
  handleEvent: function SpatialNavigator_handleEvent(event) {
</p>
<p>

  &nbsp;if (!this.document)
</p>
<p>
  &nbsp; return;<br/>
</p>
<p>
  &nbsp;switch (event.type) {<br/>
  &nbsp;case "keyup":<br/>
  &nbsp; this.keyUp(event);<br/>

  &nbsp; break;<br/>
  &nbsp;case "keypress":<br/>
  &nbsp; this.keyPress(event);<br/>
  &nbsp; break;<br/>
  &nbsp;case "keydown":<br/>

  &nbsp; this.keyDown(event);<br/>
  &nbsp; break;
</p>
&nbsp;case "x-scroll":<br/>
&nbsp; this.visualRange = null;
<p>
  &nbsp; break;<br/>

</p>
<p>
  &nbsp;case "unload":<br/>
  &nbsp; if (event.target == this.mTopWindow.document ||<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.target ==
  this.mTopWindow.contentDocument)<br/>
  &nbsp; this.visualRange = null;<br/>

  &nbsp; break;<br/>
  &nbsp;case "load":<br/>
  &nbsp; if (event.target == this.mTopWindow.document ||<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.target ==
  this.mTopWindow.content.document) {<br/>
  &nbsp;&nbsp; this.document = event.target;<br/>

  &nbsp;&nbsp; this.visualRange = null;<br/>
  &nbsp; }<br/>
  &nbsp; break;<br/>
  &nbsp;}<br/>
  },<br/>

  keyUp: function SpatialNavigator_keyUp(event) {<br/>
  /* XXX should record the event to make press work better */<br/>
  },<br/>
  keyPress: function SpatialNavigator_keyPress(event) {<br/>
  /* XXX should check records of down and up and do work here */<br/>
  &nbsp;this.handleKey(event);<br/>

  },<br/>
  keyDown: function SpatialNavigator_keyDown(event) {<br/>
  /* XXX should record the event to make press work better */<br/>
  },<br/>
  handleKey: function SpatialNavigator_handleKey(event) {<br/>
  &nbsp;if (!this.mService.mEnabled)<br/>

  &nbsp; return;<br/>
  &nbsp;try {<br/>
  &nbsp; if (event instanceof Components.interfaces.nsIDOMNSUIEvent &amp;&amp;<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.getPreventDefault())<br/>
  &nbsp;&nbsp; return;<br/>

  &nbsp;} catch (e) {<br/>
  &nbsp;}<br/>
  &nbsp;var formControlType = -1;<br/>
  &nbsp;var eventInternal =
  event.QueryInterface(Components.interfaces.nsIDOMNSEvent);<br/>
  &nbsp;var domEventTarget = eventInternal.originalTarget;
</p>
<p>
  &nbsp;function nodeIsXUL(node) { return false; }<br/>

</p>
<p>
  &nbsp; if (nodeIsXUL(domEventTarget))<br/>
  &nbsp; return;<br/>
  &nbsp;if (this.mService.mIgnoreTextFields) {<br/>
  &nbsp; if (domEventTarget instanceof
  Components.interfaces.nsIDOMHTMLTextAreaElement ||<br/>

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (domEventTarget instanceof
  Components.interfaces.nsIDOMHTMLInputElement &amp;&amp;<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  (/^(?:|text|password|file)$/i.test(domEventTarget.type))) ||<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domEventTarget instanceof
  Components.interfaces.nsIDOMHTMLIsIndexElement<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; ) {<br/>

  &nbsp;&nbsp; return;<br/>
  &nbsp; }<br/>
  &nbsp;}<br/>
  &nbsp;var keyEvent =
  event.QueryInterface(Components.interfaces.nsIDOMKeyEvent);<br/>
  &nbsp;var keyCode = keyEvent.keyCode;<br/>

  &nbsp;const keyCodeModifier = this.mService.mKeyCodeModifier;<br/>
  &nbsp; // figure out what modifier to use&nbsp;<br/>
  &nbsp;<br/>
  <font face="Courier New">&nbsp;const
  SHIFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x00100000;<br/>
  &nbsp;const CONTROL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0x00001100;<br/>

  &nbsp;const
  ALT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =
  0x00000012;<br/>
  </font>&nbsp;<br/>
  &nbsp; if ((keyCodeModifier &amp; SHIFT) ^ keyEvent.shiftKey)<br/>
  &nbsp;&nbsp; return;<br/>

  &nbsp; if ((keyCodeModifier &amp; CONTROL) ^ keyEvent.ctrlKey)<br/>
  &nbsp;&nbsp; return;<br/>
  &nbsp; if ((keyCodeModifier &amp; ALT) ^ keyEvent.altKey)<br/>
  &nbsp;&nbsp; return;<br/>

  &nbsp;var action;<br/>
  &nbsp;var left = false;<br/>
  &nbsp;switch (keyCode) {<br/>
  &nbsp;case this.mService.mKeyCodeLeft:<br/>
  &nbsp; left = true;
</p>
<br/>

<p>
  &nbsp;case this.mService.mKeyCodeRight:
</p>
<p>
  /* ISINDEX!! */
</p>
<p>
  &nbsp; if (domEventTarget instanceof
  Components.interfaces.nsIDOMHTMLInputElement ||<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domEventTarget instanceof
  Components.interfaces.nsIDOMHTMLTextAreaElement) {<br/>

  &nbsp;&nbsp; if (left) {<br/>
  &nbsp;&nbsp;&nbsp; if (domEventTarget.textLength &amp;&amp;
  domEventTarget.selectionStart)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; return;<br/>
  &nbsp;&nbsp; } else {<br/>

  &nbsp;&nbsp;&nbsp; if (domEventTarget.textLength !=
  domEventTarget.selectionEnd)<br/>
  &nbsp;&nbsp;&nbsp;&nbsp; return;<br/>
  &nbsp;&nbsp; }<br/>
  &nbsp; }
</p>
<p>

  &nbsp; action = left ? "left" : "right";<br/>
  &nbsp; break;<br/>
  &nbsp;case this.mService.mKeyCodeUp:
</p>
<p>
  /* SELECT!! */
</p>
<p>
  &nbsp; action = "up";<br/>

  &nbsp; break;<br/>
  &nbsp;case this.mService.mKeyCodeDown:<br/>
</p>
<p>
  /* SELECT!! */
</p>
<p>
  &nbsp; action = "down";<br/>

  &nbsp; break;
</p>
<p>
  &nbsp;default:
</p>
<p>
  &nbsp; return;<br/>
</p>
<p>
  &nbsp;}<br/>

</p>
<p>
  &nbsp;var now = Date.now();<br/>
  &nbsp;var delta = now - this.last;<br/>
  &nbsp;this.last = now;<br/>
  &nbsp;if (delta &lt; 200)<br/>
  &nbsp; return;<br/>

</p>
<p>
  &nbsp;try {<br/>
  &nbsp; var node = this[action]();<br/>
  &nbsp;} catch (e) {}<br/>
  &nbsp;if (node) {
</p>
<p>
  &nbsp; event.stopPropagation();<br/>

  &nbsp; event.preventDefault();<br/>
  &nbsp;}<br/>
  },<br/>
  get attachedWindow() {
</p>
<p>
  &nbsp;return this.mTopWindow;<br/>

</p>
<p>
  },<br/>
</p>
get focussedElement() {<br/>
&nbsp;return this._focussedElement;<br/>
},<br/>
set focussedElement(node) {<br/>
&nbsp;var old = this.focussedElement;<br/>
&nbsp;if (old == node)<br/>

&nbsp; return;<br/>
&nbsp;if (old)<br/>
&nbsp; this.removeFlash("all");<br/>
&nbsp;if (node)<br/>
&nbsp; this.addFlash(node, 10, 3, true, this.cardinalColor(0, 0), 8, false);<br/>
&nbsp;this._focussedElement = node;<br/>
},<br/>

distanceBetweenPoints: function distanceBetweenPoints(x1, y1, x2, y2)<br/>
{<br/>
&nbsp;var xd = x1-x2;<br/>
&nbsp;var yd = y1-y2;<br/>
&nbsp;return xd*xd+yd*yd;<br/>
},<br/>
x:function x(){<br/>
/*<br/>
&nbsp;* this will return an array like creature which has a valueOf property
returning the smallest distance<br/>

&nbsp;* it will also have a direction property indicating which direction is the
smallest distance<br/>
&nbsp;* and as an array, it will have distances for each direction<br/>
&nbsp;*<br/>
&nbsp;* the direction argument will probably be ignored<br/>
&nbsp;*/<br/>
function distanceBetweenNodes(node1, node2, direction) {<br/>
&nbsp;if (MyNode.prototype.getLeft(node1) &lt;= MyNode.prototype.getLeft(node2)
&amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp; MyNode.prototype.getRight(node1) &gt;=
MyNode.prototype.getRight(node2)) {<br/>

&nbsp;&nbsp; /* ? */<br/>
&nbsp;}<br/>
&nbsp;var x2 = MyNode.prototype.getRight(node1);<br/>
&nbsp;var x3 = MyNode.prototype.getLeft(node2);<br/>
&nbsp;var x4 = node;<br/>
&nbsp;switch (direction) {<br/>
<p>
  &nbsp;case undefined:
</p>

<p>
  &nbsp;default:<br/>
  &nbsp;case this.DOWN:
</p>
&nbsp; break;<br/>
&nbsp;case this.EAST:<br/>
&nbsp; break;<br/>
&nbsp;case this.NORTH:<br/>

&nbsp; break;<br/>
&nbsp;case this.WEST:<br/>
&nbsp; break;<br/>
&nbsp;case this.SOUTH:<br/>
&nbsp; break;<br/>
<p>
  &nbsp;case this.UP:<br/>

</p>
<p>
  &nbsp; break;
</p>
&nbsp;}<br/>
&nbsp;<br/>
}<br/>
<br/>
/*<br/>
&nbsp;* favoritism<br/>
&nbsp;*<br/>

&nbsp;* If two objects are equally close to a third object but differ by
direction, we want to cause objects that are (in this order) to be seen as
closest<br/>
&nbsp;* West, North, East, South<br/>
&nbsp;* This is designed to cause the sorting system to put fewer objects
south/east of the origin and more objects north/west of the origin. This should
make it easier to progress down the page than up the page.<br/>
&nbsp;*<br/>
&nbsp;* If two objects are equally close to a third object in the same
direction, we want to favor South if going East, North if going West, East if
going South, West if going North.<br/>
&nbsp;* This should approximate the idea that South and East are progressing
"down a page", and West and North are progressing "up the page".<br/>
&nbsp;*/<br/>
function sortNodes(originNode, node1, node2) {<br/>
&nbsp; var originNodePosX = MyNode.prototype.getLeft(originNode);<br/>

&nbsp; var originNodePosY = MyNode.prototype.getTop(originNode);<br/>
<br/>
&nbsp; var node1PosX = MyNode.prototype.getLeft(node1);<br/>
&nbsp; var node1PosY = MyNode.prototype.getTop(node1);<br/>
&nbsp; var node2PosX = MyNode.prototype.getLeft(node2);<br/>
&nbsp; var node2PosY = MyNode.prototype.getTop(node2);<br/>
<br/>

&nbsp; var distanceOriginNode1X = originNodePosX - node1PosX;<br/>
&nbsp; var distanceOriginNode1Y = originNodePosY - node1PosY;<br/>
<br/>
&nbsp; var distanceOriginNode2X = originNodePosX - node2PosX;<br/>
&nbsp; var distanceOriginNode2Y = originNodePosY - node2PosY;<br/>
<br/>
&nbsp; /*<br/>

&nbsp;&nbsp; * Figure out in which directions the different nodes are.<br/>
&nbsp;&nbsp; */<br/>
&nbsp; return -1;<br/>
}<br/>
},<br/>
<span>get document() {<br/>
&nbsp;var window = </span><span>this.mTopWindow;</span><br/>

&nbsp;if (!window)<br/>
&nbsp; return null;<br/>
<span>&nbsp;var document = window.document;<br/>
&nbsp;if (!(document instanceof Components.interfaces.nsIDOMXULDocument))<br/>
&nbsp; return document;<br/>
&nbsp;return window.content &amp;&amp; window.content.document;</span><br/>
},<br/>

get viewport() {<br/>
&nbsp;if (!this.document)<br/>
&nbsp; return null;<br/>
&nbsp;return (this.document instanceof XML) ? this.mTopWindow.screen :
this.document.body;<br/>
},<br/>
get availWidth() {<br/>
&nbsp;return this.viewport.clientWidth;<br/>
},<br/>

get availHeight() {<br/>
&nbsp;return this.viewport.clientHeight;<br/>
},<br/>
get clientLeft() {<br/>
&nbsp;return this.viewport.scrollLeft;<br/>
},<br/>
get clientTop() {<br/>
&nbsp;return this.viewport.scrollTop;<br/>
},<br/>

insertFocus: function SpatialNavigator_insertFocus(direction) {<br/>
&nbsp;var horizontalFactor, verticalFactor;<br/>
&nbsp;switch (direction) {<br/>
&nbsp;case this.EAST:<br/>
&nbsp; horizontalFactor = .5+this.INSERTION_FACTOR;<br/>
&nbsp; verticalFactor = .5;<br/>
&nbsp; break;<br/>

&nbsp;case this.NORTH:<br/>
&nbsp; horizontalFactor = .5;<br/>
&nbsp; verticalFactor = .5-this.INSERTION_FACTOR;<br/>
&nbsp; break;<br/>
&nbsp;case this.WEST:<br/>
&nbsp; horizontalFactor = .5-this.INSERTION_FACTOR;<br/>
&nbsp; verticalFactor = .5;<br/>

&nbsp; break;<br/>
&nbsp;case this.SOUTH:<br/>
&nbsp; horizontalFactor = .5;<br/>
&nbsp; verticalFactor = .5+this.INSERTION_FACTOR;<br/>
&nbsp; break;<br/>
&nbsp;default:<br/>
&nbsp; horizontalFactor = .5;<br/>

&nbsp; verticalFactor = .5;<br/>
&nbsp; break;<br/>
&nbsp;}<br/>
&nbsp;if (!this.ensureVisualRange())<br/>
&nbsp; return null;<br/>
&nbsp;var nodes = this.visualRange.getNodesAroundPoint(<br/>
&nbsp;&nbsp;&nbsp; this.clientLeft + this.availWidth * horizontalFactor,<br/>

&nbsp; &nbsp; this.clientTop + this.availHeight * verticalFactor,<br/>
&nbsp; &nbsp; Math.max(this.NAVIGABLE_WIDTH, this.NAVIGABLE_HEIGHT),<br/>
&nbsp; &nbsp; 1);<br/>
&nbsp;var node = nodes[0];<br/>
&nbsp;this.focussedElement = node;<br/>
&nbsp;this.headings = null;<br/>

&nbsp;this.nextElementIsNull = null;<br/>
&nbsp;this.orientation = null;<br/>
&nbsp;print("insertFocus(" + this.ENGLISH[direction] + "): " + (node ?
node.toString() : "null") + "\n");<br/>
&nbsp;return node;<br/>
},<br/>
buildVisualRange: function SpatialNavigator_buildVisualRange() {<br/>
&nbsp;if (!this.document)<br/>
&nbsp; return;<br/>

&nbsp;var root = {addNode:function(){}};<br/>
&nbsp;var x = this.clientLeft;<br/>
&nbsp;var y = this.clientTop;<br/>
&nbsp;this.visualRange = root = new Grid("traversable grid", 32, 32,
this.availWidth, this.availHeight, null);<br/>
&nbsp;if (0) {<br/>
&nbsp; /* walking trees is probably faster but coding it requires a bit more
work. */<br/>
&nbsp; var walker = this.document.createTreeWalker(<br/>
&nbsp;&nbsp; this.document.firstChild,<br/>

&nbsp;&nbsp; Components.interfaces.nsIDOMNodeFilter.SHOW_ELEMENT,<br/>
&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp; acceptNode: function
SpatialNavigator_TreeWalker_acceptNode(node)<br/>
&nbsp;&nbsp;&nbsp; {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; return
Components.interfaces.nsIDOMNodeFilter.FILTER_ACCEPT;<br/>
&nbsp;&nbsp;&nbsp; }<br/>

&nbsp;&nbsp; },<br/>
&nbsp;&nbsp; false);<br/>
&nbsp; while ((node = walker.nextNode())) {<br/>
&nbsp;&nbsp; root.addNode(new MyNode(node.tagName,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MyNode.prototype.getLeft(node),<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
MyNode.prototype.getRight(node),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node.offsetWidth,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
node.offsetHeight));<br/>
&nbsp; }<br/>
&nbsp;} else {<br/>
&nbsp; var props = [<br/>

&nbsp;&nbsp; "textarea",<br/>
&nbsp;&nbsp; "input",<br/>
&nbsp;&nbsp; "isindex",<br/>
&nbsp;&nbsp; "button",<br/>
&nbsp;&nbsp; "select",<br/>
&nbsp; ];<br/>

&nbsp; var html = this.document instanceof
Components.interfaces.nsIDOMHTMLDocument;<br/>
&nbsp; if (html) {<br/>
function hack(node) {<br/>
&nbsp;if (node.firstChild instanceof
Components.interfaces.nsIDOMHTMLImageElement)<br/>
&nbsp; return node.firstChild;<br/>
&nbsp;return node;<br/>
}<br/>

&nbsp;&nbsp; var nodes = this.document.links;<br/>
&nbsp;&nbsp; for (var i = 0; i &lt; nodes.length; ++i) {<br/>
&nbsp;&nbsp;&nbsp; var node = hack(nodes[i]);<br/>
&nbsp;&nbsp;&nbsp; if (this.isVisible(node)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; root.addNode(node);<br/>

&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; }<br/>
&nbsp; } else {<br/>
&nbsp;&nbsp; props.push("a");<br/>
&nbsp; }<br/>
&nbsp; for (var j = 0; j &lt; props.length; ++j) {<br/>

&nbsp;&nbsp; nodes = html<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?
this.document.getElementsByTagName(props[j])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
this.document.getElementsByTagNameNS("http://www.w3.org/1999/xhtml", props[j]);<br/>
&nbsp;&nbsp; for (var i = 0; i &lt; nodes.length; ++i) {<br/>
&nbsp;&nbsp;&nbsp; node = nodes[i];<br/>

&nbsp;&nbsp;&nbsp; if (this.isVisible(node)) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; root.addNode(node);<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp;}<br/>

},<br/>
isVisible: function SpatialNavigator_isVisible(node) {<br/>
&nbsp;if (!node.scrollWidth || !node.scrollHeight)<br/>
&nbsp; return false;<br/>
&nbsp;var screen = node.ownerDocument.defaultView;<br/>
&nbsp;while (node instanceof Components.interfaces.nsIDOMElement) {<br/>
&nbsp; var style = screen.getComputedStyle(node, "");<br/>
&nbsp; if (style.display=="none" || style.visibility=="collapsed")<br/>

&nbsp;&nbsp; return false;<br/>
&nbsp; node = node.parentNode;<br/>
&nbsp;}<br/>
&nbsp;return true;<br/>
},<br/>
ensureVisualRange: function SpatialNavigator_ensureVisualRange() {<br/>
&nbsp;if (60000 + this.visualRangeInitializedTime&nbsp; &gt; Date.now()) {<br/>

&nbsp; this.visualRange = null;<br/>
&nbsp;}<br/>
&nbsp;if (!this.visualRange) {<br/>
&nbsp; this.buildVisualRange();<br/>
&nbsp;}<br/>
&nbsp;return this.visualRange;<br/>
},<br/>
traverse: function SpatialNavigator_traverse(orientation, preview) {<br/>

&nbsp;var node = this.focussedElement;<br/>
&nbsp;if (!node) {<br/>
&nbsp; print("SpatialNavigator_traverse called but !this.focussedElement");<br/>
&nbsp; return null;<br/>
&nbsp;}<br/>
&nbsp;if (!this.ensureVisualRange())<br/>
&nbsp; return null;<br/>

&nbsp;if (!preview) {<br/>
&nbsp; if (this.nextElementIsNull &amp;&amp; this.orientation == orientation) {<br/>
&nbsp;&nbsp; this.focussedElement = null;<br/>
&nbsp;&nbsp; this.headings = null;<br/>
&nbsp;&nbsp; this.orientation = null;<br/>
&nbsp;&nbsp; this.nextElementIsNull = null;<br/>

&nbsp; }<br/>
&nbsp; // this is strange<br/>
&nbsp; if (this.orientation == null) {<br/>
&nbsp;&nbsp; this.orientation = orientation;<br/>
&nbsp; }<br/>
&nbsp;}<br/>

&nbsp;if (!this.headings) {<br/>
&nbsp; this.headings = [[],[],[],[]];<br/>
&nbsp;}<br/>
&nbsp;var headings = this.headings;<br/>
&nbsp;var turning = this.isPerpendicular(this.orientation, orientation);<br/>
&nbsp;if (preview) {<br/>
&nbsp; return headings[orientation].length &gt; preview ?
headings[orientation][preview - 1] : null;<br/>

&nbsp;}<br/>
&nbsp;/* try always calling getVectorsFromNode instead of only sometimes */<br/>
&nbsp;if (!preview) {<br/>
&nbsp; if (!headings[orientation].length) {<br/>
&nbsp;&nbsp; this.visualRange.getVectorsFromNode(node, this.headings,
orientation, turning);<br/>
&nbsp; } else {<br/>
&nbsp;&nbsp; if (turning) {<br/>

&nbsp;&nbsp;&nbsp; headings[this.cw[orientation]].length = 0;<br/>
&nbsp;&nbsp;&nbsp; headings[this.ccw[orientation]].length = 0;<br/>
&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp;}<br/>
&nbsp;if (node)<br/>
&nbsp; headings[this.reverse[orientation]].unshift(node);<br/>

&nbsp;node = headings[orientation].shift();<br/>
&nbsp;this.orientation = orientation;<br/>
&nbsp;this.headings = headings;<br/>
&nbsp;if (!node) {<br/>
&nbsp; print("traverse(" + this.ENGLISH[orientation] + "): null\n");<br/>
&nbsp; this.nextElementIsNull = true;<br/>
&nbsp; return null;<br/>

&nbsp;}<br/>
&nbsp;print("traverse(" + this.ENGLISH[orientation] + "): " + (node ?
node.toString() : "null") + "\n");<br/>
&nbsp;this.focussedElement = node;<br/>
&nbsp;return node;<br/>
},<br/>
getNodesAroundPoint: function SpatialNavigator_getNodesAroundPoint(originX,
originY, range, limit) {<br/>
&nbsp;var found = [];<br/>
&nbsp;var parent;<br/>
&nbsp;var current;<br/>

&nbsp;var minX = originX - range;<br/>
&nbsp;var maxX = originX + range;<br/>
&nbsp;var minY = originY - range;<br/>
&nbsp;var maxY = originY + range;<br/>
&nbsp;while ((parent = toInspect.shift())) {<br/>
&nbsp;for (var x = 0; x &lt; parent.children.length; ++x) {<br/>
&nbsp; if (!(current = parent.children[x]))<br/>

&nbsp;&nbsp; continue;<br/>
<br/>
&nbsp; if (minX &gt; MyNode.prototype.getRight(current) ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxX &lt; MyNode.prototype.getLeft(current) ||<br/>
&nbsp; &nbsp; &nbsp; minY &gt; MyNode.prototype.getBottom(current) ||<br/>

&nbsp; &nbsp; &nbsp; maxY &lt; MyNode.prototype.getTop(current))<br/>
&nbsp;&nbsp; continue;<br/>
<br/>
&nbsp; if (current instanceof QTree)<br/>
&nbsp;&nbsp; toInspect.push(current);<br/>

&nbsp; else<br/>
&nbsp;&nbsp; found.push(current);<br/>
&nbsp;}<br/>
&nbsp;}<br/>
&nbsp;this.removeDuplicates(found);<br/>
&nbsp;return found;<br/>
},<br/>
getNodesInRangeOfPoint: function
SpatialNavigator_getNodesInRangeOfPoint(originX, originY, minimumDistance,
maximumDistance) {<br/>

&nbsp;var found = [];<br/>
&nbsp;var range = (maximumDistance - minimumDistance) / 2;<br/>
&nbsp;var offset = range + minimumDistance;<br/>
&nbsp;for (var x = -1 ; x &lt;= 1; ++x) {<br/>
&nbsp; for (var y = -1 ; y &lt;= 1; ++y) {<br/>
&nbsp;&nbsp; if (x || y) {<br/>
&nbsp; &nbsp; this.concat(found, this.getNodesAroundPoint(originX + x * offset,
originY + y * offset, range));<br/>

&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp;}<br/>
&nbsp;this.removeDuplicates(found);<br/>
&nbsp;return found;<br/>
},<br/>
getPathsAwayFromNode: function
SpatialNavigator_getPathsAwayFromNode(currentNode, range) {<br/>
&nbsp;var left = [];<br/>

&nbsp;var right = [];<br/>
&nbsp;var up = [];<br/>
&nbsp;var down = [];<br/>
&nbsp;&nbsp;<br/>
&nbsp;var nodes =
this.getNodesAroundPoint(MyNode.prototype.getLeft(currentNode),
MyNode.prototype.getTop(currentNode), range);<br/>
&nbsp;for (var i = 0; i &lt; nodes.length; ++i) {<br/>
&nbsp; var node = nodes[i];<br/>
<br/>

&nbsp; if (node == currentNode)<br/>
&nbsp;&nbsp; continue;<br/>
&nbsp;&nbsp;<br/>
&nbsp; if (MyNode.prototype.getRight(currentNode) &lt;=
MyNode.prototype.getLeft(currentNode) &amp;&amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyNode.prototype.getBottom(currentNode) &lt;=
MyNode.prototype.getTop(currentNode)) {<br/>
&nbsp;&nbsp; var x = MyNode.prototype.getLeft(currentNode) -
MyNode.prototype.getRight(currentNode);<br/>

&nbsp;&nbsp; var y = MyNode.prototype.getTop(currentNode) -
MyNode.prototype.getBottom(currentNode);<br/>
&nbsp;&nbsp; if (x &gt; y)<br/>
&nbsp;&nbsp;&nbsp; left.push(node);<br/>
&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp; up.push(node);<br/>

&nbsp;&nbsp; continue;<br/>
&nbsp; }<br/>
<br/>
&nbsp; if (MyNode.prototype.getLeft(node) &gt;=
MyNode.prototype.getRight(currentNode) &amp;&amp;<br/>
&nbsp; &nbsp; &nbsp; MyNode.prototype.getBottom(node) &lt;=
MyNode.prototype.getTop(currentNode)) {<br/>

&nbsp;&nbsp; var x = MyNode.prototype.getLeft(node) -
MyNode.prototype.getRight(currentNode);<br/>
&nbsp;&nbsp; var y = MyNode.prototype.getTop(currentNode) -
MyNode.prototype.getBottom(node);<br/>
&nbsp;&nbsp; if (x &gt; y)<br/>
&nbsp;&nbsp;&nbsp; right.push(node);<br/>
&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;<br/>

&nbsp;&nbsp;&nbsp; up.push(node);<br/>
&nbsp;&nbsp; continue;<br/>
&nbsp; }<br/>
<br/>
&nbsp; if (MyNode.prototype.getRight(node) &lt;=
MyNode.prototype.getLeft(currentNode) &amp;&amp;<br/>
&nbsp; &nbsp; &nbsp; MyNode.prototype.getTop(node) &gt;=
MyNode.prototype.getBottom(currentNode)) {<br/>

&nbsp;&nbsp; var x = MyNode.prototype.getLeft(currentNode) -
MyNode.prototype.getRight(node);<br/>
&nbsp;&nbsp; var y = MyNode.prototype.getTop(node) -
MyNode.prototype.getBottom(currentNode);<br/>
&nbsp;&nbsp; if (x &gt; y)<br/>
&nbsp;&nbsp;&nbsp; left.push(node);<br/>
&nbsp;&nbsp; else<br/>

&nbsp;&nbsp;&nbsp; down.push(node);<br/>
&nbsp;&nbsp; continue;<br/>
&nbsp; }<br/>
<br/>
&nbsp; if (MyNode.prototype.getLeft(node) &gt;=
MyNode.prototype.getRight(currentNode) &amp;&amp;<br/>
&nbsp; &nbsp; &nbsp; MyNode.prototype.getTop(node) &gt;=
MyNode.prototype.getBottom(currentNode)) {<br/>

&nbsp;&nbsp; var x = MyNode.prototype.getLeft(node) -
MyNode.prototype.getRight(currentNode);<br/>
&nbsp;&nbsp; var y = MyNode.prototype.getTop(node) -
MyNode.prototype.getBottom(currentNode);<br/>
&nbsp;&nbsp; if (x &gt; y)<br/>
&nbsp;&nbsp;&nbsp; right.push(node);<br/>
&nbsp;&nbsp; else<br/>

&nbsp;&nbsp;&nbsp; down.push(node);<br/>
&nbsp;&nbsp; continue;<br/>
&nbsp; }<br/>
<br/>
&nbsp; if ((MyNode.prototype.getTop(currentNode) &lt;=
MyNode.prototype.getBottom(node) &amp;&amp;<br/>
&nbsp; &nbsp; &nbsp;&nbsp; MyNode.prototype.getTop(currentNode) &gt;=
MyNode.prototype.getTop(node)) ||<br/>

&nbsp;&nbsp;&nbsp; (MyNode.prototype.getBottom(currentNode) &lt;=
MyNode.prototype.getBottom(node) &amp;&amp;<br/>
&nbsp; &nbsp;&nbsp; MyNode.prototype.getBottom(currentNode) &gt;=
MyNode.prototype.getTop(node))) {<br/>
&nbsp;&nbsp; if (MyNode.prototype.getRight(node) &lt;=
MyNode.prototype.getLeft(currentNode)) {<br/>
&nbsp;&nbsp;&nbsp; left.push(node);<br/>
&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<br/>

&nbsp;&nbsp; else {<br/>
&nbsp;&nbsp;&nbsp; right.push(node);<br/>
&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; continue;<br/>
&nbsp; }<br/>
<br/>
&nbsp; if ((MyNode.prototype.getLeft(currentNode) &lt;=
MyNode.prototype.getRight(node) &amp;&amp;<br/>

&nbsp; &nbsp; &nbsp;&nbsp; MyNode.prototype.getLeft(currentNode) &gt;=
MyNode.prototype.getLeft(node)) ||<br/>
&nbsp;&nbsp;&nbsp; (MyNode.prototype.getRight(currentNode) &lt;=
MyNode.prototype.getRight(node) &amp;&amp;<br/>
&nbsp; &nbsp;&nbsp; MyNode.prototype.getRight(currentNode) &gt;=
MyNode.prototype.getLeft(node))) {<br/>
&nbsp;&nbsp; if (MyNode.prototype.getBottom(node) &lt;=
MyNode.prototype.getTop(currentNode)) {<br/>

&nbsp;&nbsp;&nbsp; up.push(node);<br/>
&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; else {<br/>
&nbsp;&nbsp;&nbsp; down.push(node);<br/>
&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; continue;<br/>

&nbsp; }<br/>
&nbsp;}<br/>
/* this should describe cardinals */<br/>
&nbsp;var directions = [ right,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
up,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
left,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
down<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
];<br/>
<br/>
&nbsp;return directions;<br/>
},<br/>
/* nsIWebProgressListener */<br/>
onProgressChange: function () {},<br/>
onStateChange: function onStateChange(wp, req, flags, status) {<br/>
&nbsp;if (flags &amp; (Components.interfaces.nsIWebProgressListener.STATE_STOP |<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Components.interfaces.nsIWebProgressListener.STATE_IS_WINDOW)) {<br/>
&nbsp; if (wp.DOMWindow == this.mTopWindow ||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wp.DOMWindow == this.mTopWindow.content)<br/>
&nbsp; this.visualRange = null;<br/>
&nbsp;}<br/>
},<br/>
onLocationChange: function () {},<br/>

onStatusChange: function () {},<br/>
onSecurityChange: function () {},<br/>
availableNodes: null,<br/>
visualRange: null,<br/>
visualRangeInitializedTime: undefined<br/>
<p>
  }<br/>
</p>
function testWalk(map, reachedNodes, reachableNodes, node) {<br/>

&nbsp;if (!reachableNodes) {<br/>
&nbsp; map={};<br/>
&nbsp; reachableNodes=[];<br/>
&nbsp; testWalk(map, reachedNodes, reachableNodes, sn.visualRange);<br/>
&nbsp; reachedNodes=[];<br/>
&nbsp; map={};<br/>

&nbsp;} else if (!reachedNodes) {<br/>
&nbsp; var objectId, child;<br/>
&nbsp; for (var i = 0; i &lt; node.children.length; ++i) {<br/>
&nbsp;&nbsp; if (!(child = node.children[i])) continue;<br/>
&nbsp;&nbsp; if (child instanceof QTree) {<br/>
&nbsp;&nbsp;&nbsp; testWalk(map, reachedNodes, reachableNodes, child);<br/>

&nbsp;&nbsp; } else if (!((objectId = child.objectId) in map)) {<br/>
&nbsp;&nbsp;&nbsp; map[objectId] = child;<br/>
&nbsp;&nbsp;&nbsp; reachableNodes[reachableNodes.length] = child;<br/>
&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp; return null;<br/>

&nbsp;}<br/>
&nbsp;if (!node) {<br/>
&nbsp; map[null] = {node: null, objectId: null};<br/>
&nbsp; for (var direction = sn.EAST; direction &lt;= sn.SOUTH; ++direction) {<br/>
&nbsp;&nbsp; node = sn.insertFocus(direction)<br/>
&nbsp;&nbsp; var vector = [node];<br/>

&nbsp;&nbsp; vector.direction = direction;<br/>
&nbsp;&nbsp; map[null][direction] = vector;<br/>
&nbsp;&nbsp; if (node) {<br/>
&nbsp;&nbsp;&nbsp; if (node.objectId in map) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; continue;<br/>
&nbsp;&nbsp;&nbsp; }<br/>

&nbsp;&nbsp;&nbsp; testWalk(map, reachedNodes, reachableNodes, node);<br/>
&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp; return {<br/>
&nbsp;&nbsp; map: map,<br/>
&nbsp;&nbsp; reachedNodes: reachedNodes,<br/>

&nbsp;&nbsp; reachableNodes: reachableNodes,<br/>
&nbsp;&nbsp; toString: function map_toString() {<br/>
&nbsp;&nbsp;&nbsp; var x = "";<br/>
&nbsp;&nbsp;&nbsp; for (var nodeId in this.map) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (var direction = 0; direction
&lt; 4; ++direction) {<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var vector =
this.map[nodeId][direction];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!vector
|| !vector.length || !vector[0])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
continue;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += nodeId +
"\t"+ISpatialNavigation.prototype.ENGLISH[direction]+"\t";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (var a =
0; a &lt; 3; ++a) {<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var node = vector[a];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x += (node ? node.objectId : "null") + "\t";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += "\n";<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp;&nbsp; }<br/>

&nbsp;&nbsp;&nbsp; return x;<br/>
&nbsp;&nbsp; }<br/>
&nbsp; };<br/>
&nbsp;}<br/>
&nbsp;map[node.objectId] = {node: node};<br/>
/* walk 3 east, undo. walk 3 west, undo, walk 3 south, undo, walk 3 north<br/>
&nbsp;* if it can only walk 2 east and traverse returns null, then undo means
walking 2 west.<br/>

&nbsp;* note that temporarily traverse will do the wrong thing (currently it
returns null and nulls out focussedElement,<br/>
&nbsp;* when fixed, it will return null but only null out the focussedElement if
asked to repeat that task).<br/>
&nbsp;*/<br/>
&nbsp;for (var direction = sn.EAST; direction &lt;= sn.SOUTH; ++direction) {<br/>
&nbsp; sn.focussedElement = node;<br/>
&nbsp; map[node.objectId][direction] = [];<br/>
&nbsp; for (var y = 0; y &lt; 3; ++y) {<br/>

&nbsp;&nbsp; child = sn.traverse(direction);<br/>
&nbsp;&nbsp; if (!child) { y = 4; continue; }<br/>
&nbsp;&nbsp; map[node.objectId][direction].push(child);<br/>
&nbsp;&nbsp; if (!(child.objectId in map)) {<br/>
&nbsp;&nbsp;&nbsp; reachableNodes[reachableNodes.length] = child;<br/>
&nbsp;&nbsp;&nbsp; testWalk(map, reachedNodes, reachableNodes, child);<br/>

&nbsp;&nbsp; }<br/>
&nbsp; }<br/>
&nbsp;}<br/>
&nbsp;return null;<br/>
}<br/>
<br/>
function walk(root, nodeList) {<br/>
&nbsp;var nodes = nodeList || [];<br/>

&nbsp;for (var x = 0; x &lt; root.children.length; ++x) {<br/>
&nbsp; var node=root.children[x];<br/>
&nbsp; if (node instanceof QTree)<br/>
&nbsp;&nbsp; walk(node, nodes);<br/>
&nbsp; else if (node)<br/>
&nbsp;&nbsp; nodes.push(node);<br/>

&nbsp;}<br/>
&nbsp;if (nodeList)<br/>
&nbsp; return;<br/>
&nbsp;SpatialNavigator.prototype.removeDuplicates(nodes);<br/>
&nbsp;for (x = 0; x &lt; nodes.length; ++x) {<br/>
&nbsp; print (x, nodes[x], sn.getNodesAroundPoint(x.hcenter, x.vcenter,
20).length - 1);<br/>
&nbsp;}<br/>

}<br/>
<br/>
<p class="pb">
  <br/>
  <br/>
  <br/>
</p>
<br/>
function VisualRegion(window, x, y, width, height){<br/>
&nbsp;this.window = window;<br/>
&nbsp;this.x = x || 0;<br/>

&nbsp;this.y = y || 0;<br/>
&nbsp;this.width = width || 800;<br/>
&nbsp;this.height = height || 480;<br/>
}<br/>
/**/<br/>
<br/>
<p>
  &nbsp;
</p>
<p class="pb" style="PAGE-BREAK-AFTER:always">
  &nbsp;

</p>
<br/>
function SpatialNavigationService() {<br/>
&nbsp;this.mObjects = [];<br/>
}<br/>
SpatialNavigationService.prototype = {<br/>
&nbsp;constructor:SpatialNavigationService,<br/>
&nbsp;interfaces: [<br/>
&nbsp; Components.interfaces.nsISupports,<br/>

&nbsp; Components.interfaces.nsIObserver,<br/>
&nbsp;],<br/>
&nbsp;QueryInterface: QI,<br/>
&nbsp;observe: function SpatialNavigationService_observe(data, topic, subject) {<br/>
&nbsp; switch (topic) {<br/>
&nbsp; case "domwindowopened":<br/>
&nbsp;&nbsp; var chromeWindow =
data.QueryInterface(Components.interfaces.nsIDOMWindow);<br/>

&nbsp;&nbsp; var sn = new SpatialNavigator(this, chromeWindow);<br/>
&nbsp;&nbsp; this.mObjects[this.mObjects.length] = sn;<br/>
&nbsp;&nbsp; return;<br/>
&nbsp; case "domwindowclosed":<br/>
&nbsp;&nbsp; var chromeWindow =
data.QueryInterface(Components.interfaces.nsIDOMWindow);<br/>
&nbsp;&nbsp; var count = this.mObjects.length;<br/>

&nbsp;&nbsp; for (var i = 0 ; i &lt; count; ++i) {<br/>
&nbsp;&nbsp;&nbsp; var sn = this.mObjects[i];<br/>
&nbsp;&nbsp;&nbsp; if (sn.attachedWindow == chromeWindow) {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; sn.shutdown();<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mObjects.splice(i, 1);<br/>

&nbsp;&nbsp;&nbsp;&nbsp; return;<br/>
&nbsp;&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; return;<br/>
&nbsp; case "app-startup":<br/>
&nbsp;&nbsp; var windowWatcher =
Components.classes["@mozilla.org/embedcomp/window-watcher;1"].getService(Components.interfaces.nsIWindowWatcher);<br/>

&nbsp;&nbsp; windowWatcher.registerNotification(this);<br/>
&nbsp;&nbsp; var prefBranch =
Components.classes["@mozilla.org/preferences-service;1"].getService(Components.interfaces.nsIPrefBranch2);<br/>
&nbsp;&nbsp; prefBranch.addObserver("snav.", this, false);<br/>
&nbsp;&nbsp; var observerService =
Components.classes["@mozilla.org/observer-service;1"].getService(Components.interfaces.nsIObserverService);<br/>
&nbsp;&nbsp; observerService.addObserver(this, "profile-after-change", false);<br/>
&nbsp;&nbsp; return;<br/>

&nbsp; case "profile-after-change":<br/>
&nbsp;&nbsp; prefBranch =
Components.classes["@mozilla.org/preferences-service;1"].getService(Components.interfaces.nsIPrefBranch2);<br/>
&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp; this.mEnabled = prefBranch.getBoolPref("snav.enabled");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>

&nbsp;&nbsp;&nbsp; this.mIgnoreTextFields =
prefBranch.getBoolPref("snav.ignoreTextFields");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp; gDirectionalBias =
prefBranch.getIntPref("snav.directionalBias");<br/>
&nbsp;&nbsp;&nbsp; if (gDirectionalBias == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp; gDirectionalBias = 1;<br/>

&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp; this.mDisableJSWhenFocusing =
prefBranch.getBoolPref("snav.disableJS");<br/>
&nbsp;&nbsp;&nbsp; gRectFudge = prefBranch.getIntPref("snav.rectFudge");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>

&nbsp;&nbsp;&nbsp; this.mKeyCodeLeft =
prefBranch.getIntPref("snav.keyCode.left");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp; this.mKeyCodeRight =
prefBranch.getIntPref("snav.keyCode.right");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>

&nbsp;&nbsp;&nbsp; this.mKeyCodeUp = prefBranch.getIntPref("snav.keyCode.up");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp; this.mKeyCodeDown =
prefBranch.getIntPref("snav.keyCode.down");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; try {<br/>

&nbsp;&nbsp;&nbsp; this.mKeyCodeModifier =
prefBranch.getIntPref("snav.keyCode.modifier");<br/>
&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp; return;<br/>
&nbsp; case "nsPref:changed":<br/>
&nbsp;&nbsp; prefBranch =
Components.classes["@mozilla.org/preferences-service;1"].getService(Components.interfaces.nsIPrefBranch2);<br/>
&nbsp;&nbsp; switch (subject) {<br/>

&nbsp;&nbsp; case "snav.enabled":<br/>
&nbsp;&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mEnabled = prefBranch.getBoolPref("snav.enabled");<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.ignoreTextFields":<br/>

&nbsp;&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mIgnoreTextFields =
prefBranch.getBoolPref("snav.ignoreTextFields");<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.directionalBias":<br/>
&nbsp;&nbsp;&nbsp; try {<br/>

&nbsp;&nbsp;&nbsp;&nbsp; gDirectionalBias =
prefBranch.getIntPref("snav.directionalBias");<br/>
&nbsp;&nbsp;&nbsp;&nbsp; if (gDirectionalBias == 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gDirectionalBias = 1;<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.disableJS":<br/>

&nbsp;&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mDisableJSWhenFocusing =
prefBranch.getBoolPref("snav.disableJS");<br/>
&nbsp;&nbsp;&nbsp; gRectFudge = prefBranch.getIntPref("snav.rectFudge");<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.keyCode.left":<br/>

&nbsp;&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mKeyCodeLeft =
prefBranch.getIntPref("snav.keyCode.left");<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.keyCode.right":<br/>
&nbsp;&nbsp;&nbsp; try {<br/>

&nbsp;&nbsp;&nbsp;&nbsp; this.mKeyCodeRight =
prefBranch.getIntPref("snav.keyCode.right");<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.keyCode.up":<br/>
&nbsp;&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mKeyCodeUp =
prefBranch.getIntPref("snav.keyCode.up");<br/>

&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.keyCode.down":<br/>
&nbsp;&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mKeyCodeDown =
prefBranch.getIntPref("snav.keyCode.down");<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>

&nbsp;&nbsp;&nbsp; break;<br/>
&nbsp;&nbsp; case "snav.keyCode.modifier":<br/>
&nbsp;&nbsp;&nbsp; try {<br/>
&nbsp;&nbsp;&nbsp;&nbsp; this.mKeyCodeModifier =
prefBranch.getIntPref("snav.keyCode.modifier");<br/>
&nbsp;&nbsp;&nbsp; } catch (e) {}<br/>
&nbsp;&nbsp;&nbsp; break;<br/>

&nbsp;&nbsp; }<br/>
&nbsp;&nbsp; return;<br/>
&nbsp; }<br/>
&nbsp;}<br/>
}<br/>
const NS_CATEGORYMANAGER_CONTRACTID = "@mozilla.org/categorymanager;1";<br/>
function spatialNavigationServiceRegistration(aCompMgr, aPath, registryLocation,
componentType)<br/>

{<br/>
&nbsp; var servman =
aCompMgr.QueryInterface(Components.interfaces.nsIServiceManager);<br/>
&nbsp; var catman =
servman.getServiceByContractID(NS_CATEGORYMANAGER_CONTRACTID,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Components.interfaces.nsICategoryManager);<br/>
&nbsp; catman.addCategoryEntry("app-startup",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.name,<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.contractID,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
true,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
true);<br/>
}<br/>
function spatialNavigationServiceUnregistration(aCompMgr, aPath,
registryLocation)<br/>
{<br/>
&nbsp; var servman =
aCompMgr.QueryInterface(Components.interfaces.nsIServiceManager);<br/>

&nbsp; var catman =
servman.getServiceByContractID(NS_CATEGORYMANAGER_CONTRACTID,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Components.interfaces.nsICategoryManager);<br/>
&nbsp; catman.deleteCategoryEntry("app-startup",<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
this.name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
true);<br/>
}<br/>

<br/>
function QI(iface) {<br/>
&nbsp;for (var i = 0; i &lt; this.interfaces.length; ++i)<br/>
&nbsp; if (iface.equals(this.interfaces[i]))<br/>
&nbsp;&nbsp; return this;<br/>
&nbsp;throw Components.results.NS_ERROR_NO_INTERFACE;<br/>
}<br/>

function Factory(component) {<br/>
&nbsp;this.component = component;<br/>
}<br/>
Factory.prototype = {<br/>
&nbsp;constructor: Factory,<br/>
&nbsp;/* nsIClassInfo */<br/>
&nbsp;interfaces: [<br/>
&nbsp; Components.interfaces.nsISupports,<br/>

&nbsp; Components.interfaces.nsIFactory,<br/>
&nbsp;],<br/>
&nbsp;/* nsISupports */<br/>
&nbsp;QueryInterface: QI,<br/>
&nbsp;/* nsIFactory */<br/>
&nbsp;createInstance: function Factory_createInstance(outer, iid) {<br/>
&nbsp; if (outer)<br/>
&nbsp;&nbsp; throw Components.results.NS_ERROR_NO_AGGREGATION;<br/>

&nbsp;<br/>
&nbsp; return (new this.component.constructor).QueryInterface(iid);<br/>
&nbsp;},&nbsp;<br/>
&nbsp;lockFactory: function Factory_lock(lock) {<br/>
&nbsp;&nbsp; /* no-op */<br/>
&nbsp;}<br/>
}<br/>
<br/>
function SpatialNavigationModule(){<br/>

&nbsp;this.initModule();<br/>
}<br/>
SpatialNavigationModule.prototype = {<br/>
&nbsp;constructor: SpatialNavigationModule,<br/>
&nbsp;/* nsIClassInfo */<br/>
&nbsp;interfaces: [<br/>
&nbsp; Components.interfaces.nsISupports,<br/>
&nbsp; Components.interfaces.nsIModule,<br/>

&nbsp;],<br/>
&nbsp;/* nsISupports */<br/>
&nbsp;QueryInterface: QI,<br/>
&nbsp;/* nsIModule */<br/>
&nbsp;components: [{<br/>
&nbsp; name: "SpatialNavigationService",<br/>
&nbsp; cid: Components.ID("{3f4bbf92-39d2-4783-bacd-e8d58b02ba4b}"),<br/>
&nbsp; contractID: "@mozilla.org/spatialnavigation/service",<br/>

&nbsp; constructor: SpatialNavigationService,<br/>
&nbsp; register: spatialNavigationServiceRegistration,<br/>
&nbsp; unregister: spatialNavigationServiceUnregistration<br/>
&nbsp;}],<br/>
&nbsp;initModule: function SpatialNavigationModule_initModule() {<br/>
&nbsp; for (var i = 0; i &lt; this.components.length; ++i) {<br/>

&nbsp;&nbsp; this.components[this.components[i].cid] = new
Factory(this.components[i]);<br/>
&nbsp; }<br/>
&nbsp;},<br/>
&nbsp;getClassObject: function SpatialNavigationModule_getClassObject(aCompMgr,
aClass, aIID) {<br/>
&nbsp; if (!(aClass in this.components))<br/>
&nbsp;&nbsp; throw Components.results.NS_ERROR_NOT_IMPLEMENTED;<br/>
&nbsp; return this.components[aClass].QueryInterface(aIID);<br/>

&nbsp;},<br/>
&nbsp;registerSelf: function SpatialNavigationModule_registerSelf(aCompMgr,
aLocation, aLoaderStr, aType) {<br/>
&nbsp; aCompMgr =
aCompMgr.QueryInterface(Components.interfaces.nsIComponentRegistrar);<br/>
&nbsp; for (var i = 0; i &lt; this.components.length; ++i) {<br/>
&nbsp;&nbsp; var component = this.components[i];<br/>
&nbsp;&nbsp; aCompMgr.registerFactoryLocation(component.cid,<br/>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
component.name,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
component.contractID,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
aLocation,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
aLoaderStr,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
aType);<br/>
&nbsp;&nbsp; if (component.register)<br/>

&nbsp;&nbsp;&nbsp; component.register(aCompMgr, aLocation, aLoaderStr, aType);<br/>
&nbsp; }<br/>
&nbsp;},<br/>
&nbsp;unregisterSelf: function SpatialNavigationModule_unregisterSelf(aCompMgr,
aLocation, aLoaderStr) {<br/>
&nbsp; aCompMgr =
aCompMgr.QueryInterface(Components.interfaces.nsIComponentRegistrar);<br/>
&nbsp; for (var i = 0; i &lt; this.components.length; ++i) {<br/>

&nbsp;&nbsp; var component = this.components[i];<br/>
&nbsp;&nbsp; aCompMgr.unregisterFactoryLocation(component.cid,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
aLocation);<br/>
&nbsp;&nbsp; if (component.unregister)<br/>
&nbsp;&nbsp;&nbsp; component.unregister(aCompMgr, aLocation, aLoaderStr);<br/>
&nbsp; }<br/>

&nbsp;},<br/>
&nbsp;canUnload: function SpatialNavigationModule_function(aCompMgr) {<br/>
&nbsp; return true;<br/>
&nbsp;}<br/>
};<br/>
var module = new SpatialNavigationModule;<br/>
function NSGetModule() {<br/>
&nbsp; return module;<br/>

}<br/>
<br/>
if (dump &amp;&amp; typeof print=="undefined") {<br/>
&nbsp;print = dump;<br/>
}<br/> 
</div>


  <table width=100% cellSpacing="0" cellPadding="0" border="0" id=navigation>
    <tr><td bgcolor="#676767"><img src="/images/blankdot.gif" height=1></td></tr>

    <tr><td align=center>
      <table width=100% cellSpacing="0" cellPadding="8" border="0" style="direction: ltr"><tr>
        <td class=smalltext style="padding-top:4px; direction: ltr">
          <a title="Learn more about Google Docs &amp; Spreadsheets" class=smalllink href="/">Google Docs &amp; Spreadsheets -- Web word processing and spreadsheets.</a>
        </td>
        <td class=smalltext style="padding-top:4px; direction: ltr" align=right>
          <!-- a class=smalllink target=_blank href="http://digg.com/submit?phase=2&url=http%3A%2F%2Fdocs.google.com%2FDoc%3Fid%3Ddhmd4jxt_40hgb5x6"><b>Digg this</b></a><span class=graytext> | </span -->

          
            <a title="Edit this page" onclick="if (self.parent.frames.length != 0) { self.parent.location = GetMashedURL('Edit', '?tab=edit&dr=true&docid=dhmd4jxt_40hgb5x6'); return false; }" class=smalllink href="Edit?tab=edit&dr=true&docid=dhmd4jxt_40hgb5x6">Edit this page (you have permission)</a>
          
        </td>
      </tr></table>
    </td></tr>
  </table>
	  


<script src="https://ssl.google-analytics.com/urchin.js" type="text/javascript"></script>


<script type="text/javascript">
  
  _uacct="UA-18065-1";
  _uanchor=1;
  urchinTracker();
  
</script>

</body>
</HTML>


