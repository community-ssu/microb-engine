Index: xpcom/ds/nsPersistentProperties.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/ds/nsPersistentProperties.cpp,v
retrieving revision 1.56
diff -u -8 -p -d -r1.56 nsPersistentProperties.cpp
--- mozilla/xpcom/ds/nsPersistentProperties.cpp	21 Feb 2008 20:39:23 -0000	1.56
+++ mozilla/xpcom/ds/nsPersistentProperties.cpp	26 May 2008 21:59:31 -0000
@@ -40,16 +40,17 @@
 #include "nsCRT.h"
 #include "nsReadableUtils.h"
 #include "nsIInputStream.h"
 #include "nsUnicharInputStream.h"
 #include "pratom.h"
 #include "nsEnumeratorUtils.h"
 #include "nsReadableUtils.h"
 #include "nsPrintfCString.h"
+#include "nsDependentString.h"
 
 #define PL_ARENA_CONST_ALIGN_MASK 3
 #include "nsPersistentProperties.h"
 #include "nsIProperties.h"
 #include "nsISupportsArray.h"
 #include "nsProperties.h"
 
 struct PropertyTableEntry : public PLDHashEntryHdr
@@ -92,16 +93,380 @@ static const struct PLDHashTableOps prop
   PL_DHashStringKey,
   PL_DHashMatchStringKey,
   PL_DHashMoveEntryStub,
   PL_DHashClearEntryStub,
   PL_DHashFinalizeStub,
   nsnull,
 };
 
+//
+// parser stuff
+//
+enum EParserState {
+  eParserState_AwaitingKey,
+  eParserState_Key,
+  eParserState_AwaitingValue,
+  eParserState_Value,
+  eParserState_Comment
+};
+
+enum EParserSpecial {
+  eParserSpecial_None,          // not parsing a special character
+  eParserSpecial_Escaped,       // awaiting a special character
+  eParserSpecial_Unicode        // parsing a \Uxxx value
+};
+
+class nsPropertiesParser
+{
+public:
+  nsPropertiesParser(nsIPersistentProperties* aProps) :
+    mHaveMultiLine(PR_FALSE), mState(eParserState_AwaitingKey),
+    mProps(aProps) {}
+
+  void FinishValueState(nsAString& aOldValue) {
+    static const char trimThese[] = " \t";
+    mKey.Trim(trimThese, PR_FALSE, PR_TRUE);
+
+    // This is really ugly hack but it should be fast
+    PRUnichar backup_char;
+    if (mMinLength)
+    {
+      backup_char = mValue[mMinLength-1];
+      mValue.SetCharAt('x', mMinLength-1);
+    }
+    mValue.Trim(trimThese, PR_FALSE, PR_TRUE);
+    if (mMinLength)
+      mValue.SetCharAt(backup_char, mMinLength-1);
+
+    mProps->SetStringProperty(NS_ConvertUTF16toUTF8(mKey), mValue, aOldValue);
+    mSpecialState = eParserSpecial_None;
+    WaitForKey();
+  }
+
+  EParserState GetState() { return mState; }
+
+  static nsresult SegmentWriter(nsIUnicharInputStream* aStream,
+                                void* aClosure,
+                                const PRUnichar *aFromSegment,
+                                PRUint32 aToOffset,
+                                PRUint32 aCount,
+                                PRUint32 *aWriteCount);
+
+  nsresult ParseBuffer(const PRUnichar* aBuffer, PRUint32 aBufferLength);
+
+private:
+  PRBool ParseValueCharacter(PRUnichar c, const PRUnichar* cur,
+                             const PRUnichar* &tokenStart, nsAString& oldValue);
+
+  void WaitForKey() {
+    mState = eParserState_AwaitingKey;
+  }
+
+  void EnterKeyState() {
+    mKey.Truncate();
+    mState = eParserState_Key;
+  }
+
+  void WaitForValue() {
+    mState = eParserState_AwaitingValue;
+  }
+
+  void EnterValueState() {
+    mValue.Truncate();
+    mMinLength = 0;
+    mState = eParserState_Value;
+    mSpecialState = eParserSpecial_None;
+  }
+
+  void EnterCommentState() {
+    mState = eParserState_Comment;
+  }
+
+  nsAutoString mKey;
+  nsAutoString mValue;
+
+  PRUint32  mUnicodeValuesRead; // should be 4!
+  PRUnichar mUnicodeValue;      // currently parsed unicode value
+  PRBool    mHaveMultiLine;     // if this key is multi-line
+  PRBool    mMultiLineCanSkipN; // TRUE if "\\\r" was detected
+  PRUint32  mMinLength;         // limit right trimming at the end to not trim
+                                // escaped whitespaces
+  EParserState mState;
+  // if we see a '\' then we enter this special state
+  EParserSpecial mSpecialState;
+  nsIPersistentProperties* mProps;
+};
+
+inline PRBool IsWhiteSpace(PRUnichar aChar)
+{
+  return (((aChar) == ' ') || ((aChar) == '\t') ||
+          ((aChar) == '\r') || ((aChar) == '\n'));
+}
+
+inline PRBool IsEOL(PRUnichar aChar)
+{
+  return (((aChar) == '\r') || ((aChar) == '\n'));
+}
+
+
+PRBool nsPropertiesParser::ParseValueCharacter(
+    PRUnichar c, const PRUnichar* cur, const PRUnichar* &tokenStart,
+    nsAString& oldValue)
+{
+  switch (mSpecialState) {
+
+    // the normal state - look for special characters
+  case eParserSpecial_None:
+    switch (c) {
+    case '\\':
+      // handle multilines - since this is the beginning of a line,
+      // there's no value to append
+      if (mHaveMultiLine)
+        mHaveMultiLine = PR_FALSE;
+      else
+        mValue += Substring(tokenStart, cur);
+
+      mSpecialState = eParserSpecial_Escaped;
+      break;
+
+    case '\n':
+      // ignore sequential line endings
+      if (mHaveMultiLine && mMultiLineCanSkipN) {
+        // don't allow another '\n' to be skipped
+        mMultiLineCanSkipN = PR_FALSE;
+        // if this will be at the buffer, characters from tokenStart to end
+        // are appended at the end of ParseBuffer()
+        tokenStart = cur+1;
+        break;
+      }
+      // no break
+
+    case '\r':
+      // we're done! We have a key and value
+      mValue += Substring(tokenStart, cur);
+      FinishValueState(oldValue);
+      break;
+
+    default:
+      // there is nothing to do with normal characters,
+      // but handle multilines correctly
+      if (mHaveMultiLine) {
+        if (c == ' ' || c == '\t') {
+          // don't allow another '\n' to be skipped
+          mMultiLineCanSkipN = PR_FALSE;
+        // if this will be at the buffer, characters from tokenStart to end
+        // are appended at the end of ParseBuffer()
+        tokenStart = cur+1;
+          break;
+        }
+        mHaveMultiLine = PR_FALSE;
+        tokenStart = cur;
+      }
+      break;
+    }
+    break;
+
+    // saw a \ character, so parse the character after that
+  case eParserSpecial_Escaped:
+    // probably want to start parsing at the next token
+    // other characters, like 'u' might override this
+    tokenStart = cur+1;
+    mSpecialState = eParserSpecial_None;
+
+    switch (c) {
+
+      // the easy characters - \t, \n, and so forth
+    case 't':
+      mValue += PRUnichar('\t');
+      mMinLength = mValue.Length();
+      break;
+    case 'n':
+      mValue += PRUnichar('\n');
+      mMinLength = mValue.Length();
+      break;
+    case 'r':
+      mValue += PRUnichar('\r');
+      mMinLength = mValue.Length();
+      break;
+    case '\\':
+      mValue += PRUnichar('\\');
+      break;
+
+      // switch to unicode mode!
+    case 'u':
+    case 'U':
+      mSpecialState = eParserSpecial_Unicode;
+      mUnicodeValuesRead = 0;
+      mUnicodeValue = 0;
+      break;
+
+      // a \ immediately followed by a newline means we're going multiline
+    case '\r':
+    case '\n':
+      mHaveMultiLine = PR_TRUE;
+      mMultiLineCanSkipN = (c == '\r');
+      mSpecialState = eParserSpecial_None;
+      break;
+
+    default:
+      // don't recognize the character, so just append it
+      mValue += c;
+      break;
+    }
+    break;
+
+    // we're in the middle of parsing a 4-character unicode value
+    // like \u5f39
+  case eParserSpecial_Unicode:
+
+    if(('0' <= c) && (c <= '9'))
+      mUnicodeValue =
+        (mUnicodeValue << 4) | (c - '0');
+    else if(('a' <= c) && (c <= 'f'))
+      mUnicodeValue =
+        (mUnicodeValue << 4) | (c - 'a' + 0x0a);
+    else if(('A' <= c) && (c <= 'F'))
+      mUnicodeValue =
+        (mUnicodeValue << 4) | (c - 'A' + 0x0a);
+    else {
+      // non-hex character. Append what we have, and move on.
+      mValue += mUnicodeValue;
+      mMinLength = mValue.Length();
+      mSpecialState = eParserSpecial_None;
+
+      // leave tokenStart at this unknown character, so it gets appended
+      tokenStart = cur;
+
+      // ensure parsing this non-hex character again
+      return PR_FALSE;
+    }
+
+    if (++mUnicodeValuesRead >= 4) {
+      tokenStart = cur+1;
+      mSpecialState = eParserSpecial_None;
+      mValue += mUnicodeValue;
+      mMinLength = mValue.Length();
+    }
+
+    break;
+  }
+
+  return PR_TRUE;
+}
+
+nsresult nsPropertiesParser::SegmentWriter(nsIUnicharInputStream* aStream,
+                                           void* aClosure,
+                                           const PRUnichar *aFromSegment,
+                                           PRUint32 aToOffset,
+                                           PRUint32 aCount,
+                                           PRUint32 *aWriteCount)
+{
+  nsPropertiesParser *parser = 
+    static_cast<nsPropertiesParser *>(aClosure);
+  
+  parser->ParseBuffer(aFromSegment + aToOffset, aCount);
+
+  *aWriteCount = aCount;
+  return NS_OK;
+}
+
+nsresult nsPropertiesParser::ParseBuffer(const PRUnichar* aBuffer,
+                                         PRUint32 aBufferLength)
+{
+  const PRUnichar* cur = aBuffer;
+  const PRUnichar* end = aBuffer + aBufferLength;
+
+  // points the start/end of the current key or value
+  const PRUnichar* tokenStart = nsnull;
+
+  // if we're in the middle of parsing a key or value, make sure
+  // the current token points to the beginning of the current buffer
+  if (mState == eParserState_Key ||
+      mState == eParserState_Value) {
+    tokenStart = aBuffer;
+  }
+
+  nsAutoString oldValue;
+
+  while (cur != end) {
+
+    PRUnichar c = *cur;
+
+    switch (mState) {
+    case eParserState_AwaitingKey:
+      if (c == '#' || c == '!')
+        EnterCommentState();
+
+      else if (!IsWhiteSpace(c)) {
+        // not a comment, not whitespace, we must have found a key!
+        EnterKeyState();
+        tokenStart = cur;
+      }
+      break;
+
+    case eParserState_Key:
+      if (c == '=' || c == ':') {
+        mKey += Substring(tokenStart, cur);
+        WaitForValue();
+      }
+      break;
+
+    case eParserState_AwaitingValue:
+      if (IsEOL(c)) {
+        // no value at all! mimic the normal value-ending4
+        EnterValueState();
+        FinishValueState(oldValue);
+      }
+
+      // ignore white space leading up to the value
+      else if (!IsWhiteSpace(c)) {
+        tokenStart = cur;
+        EnterValueState();
+
+        // make sure to handle this first character
+        if (ParseValueCharacter(c, cur, tokenStart, oldValue))
+          cur++;
+        // If the character isn't consumed, don't do cur++ and parse
+        // the character again. This can happen f.e. for char 'X' in sequence
+        // "\u00X". This character can be control character and must be
+        // processed again.
+        continue;
+      }
+      break;
+
+    case eParserState_Value:
+      if (ParseValueCharacter(c, cur, tokenStart, oldValue))
+        cur++;
+      // See few lines above for reason of doing this
+      continue;
+
+    case eParserState_Comment:
+      // stay in this state till we hit EOL
+      if (c == '\r' || c== '\n')
+        WaitForKey();
+      break;
+    }
+
+    // finally, advance to the next character
+    cur++;
+  }
+
+  // if we're still parsing the value and are in eParserSpecial_None, then
+  // append whatever we have..
+  if (mState == eParserState_Value && tokenStart &&
+      mSpecialState == eParserSpecial_None)
+    mValue += Substring(tokenStart, cur);
+  // if we're still parsing the key, then append whatever we have..
+  else if (mState == eParserState_Key && tokenStart)
+    mKey += Substring(tokenStart, cur);
+
+  return NS_OK;
+}
+
 nsPersistentProperties::nsPersistentProperties()
 : mIn(nsnull)
 {
   mSubclass = static_cast<nsIPersistentProperties*>(this);
   mTable.ops = nsnull;
   PL_INIT_ARENA_POOL(&mArena, "PersistentPropertyArena", 2048);
 }
 
@@ -141,159 +506,45 @@ nsPersistentProperties::Create(nsISuppor
   return rv;
 }
 
 NS_IMPL_THREADSAFE_ISUPPORTS2(nsPersistentProperties, nsIPersistentProperties, nsIProperties)
 
 NS_IMETHODIMP
 nsPersistentProperties::Load(nsIInputStream *aIn)
 {
-  PRInt32  c;
   nsresult ret = nsSimpleUnicharStreamFactory::GetInstance()->
-    CreateInstanceFromUTF8Stream(aIn, &mIn);
+    CreateInstanceFromUTF8Stream(aIn, getter_AddRefs(mIn));
 
   if (ret != NS_OK) {
-    NS_WARNING("NS_NewUTF8ConverterStream failed");
+    NS_WARNING("Error creating UnicharInputStream");
     return NS_ERROR_FAILURE;
   }
-  c = Read();
-  while (1) {
-    c = SkipWhiteSpace(c);
-    if (c < 0) {
-      break;
-    }
-    else if ((c == '#') || (c == '!')) {
-      c = SkipLine(c);
-      continue;
-    }
-    else {
-      nsAutoString key;
-      while ((c >= 0) && (c != '=') && (c != ':')) {
-        key.Append(PRUnichar(c));
-        c = Read();
-      }
-      if (c < 0) {
-        break;
-      }
-      static const char trimThese[] = " \t";
-      key.Trim(trimThese, PR_FALSE, PR_TRUE);
-      c = Read();
-      nsAutoString value, tempValue;
-      while ((c >= 0) && (c != '\r') && (c != '\n')) {
-        if (c == '\\') {
-          c = Read();
-          switch(c) {
-            case '\r':
-            case '\n':
-              // Only skip first EOL characters and then next line's
-              // whitespace characters. Skipping all EOL characters
-              // and all upcoming whitespace is too agressive.
-              if (c == '\r')
-                c = Read();
-              if (c == '\n')
-                c = Read();
-              while (c == ' ' || c == '\t')
-                c = Read();
-              continue;
-            default:
-              tempValue.Append((PRUnichar) '\\');
-              tempValue.Append((PRUnichar) c);
-          } // switch(c)
-        } else {
-          tempValue.Append((PRUnichar) c);
-        }
-        c = Read();
-      }
-      tempValue.Trim(trimThese, PR_TRUE, PR_TRUE);
 
-      PRUint32 state  = 0;
-      PRUnichar uchar = 0;
-      for (PRUint32 i = 0; i < tempValue.Length(); ++i) {
-        PRUnichar ch = tempValue[i];
-        switch(state) {
-          case 0:
-           if (ch == '\\') {
-             ++i;
-             if (i == tempValue.Length())
-               break;
-             ch = tempValue[i];
-             switch(ch) {
-               case 'u':
-               case 'U':
-                 state = 1;
-                 uchar=0;
-                 break;
-               case 't':
-                 value.Append(PRUnichar('\t'));
-                 break;
-               case 'n':
-                 value.Append(PRUnichar('\n'));
-                 break;
-               case 'r':
-                 value.Append(PRUnichar('\r'));
-                 break;
-               default:
-                 value.Append(ch);
-             } // switch(ch)
-           } else {
-             value.Append(ch);
-           }
-           continue;
-         case 1:
-         case 2:
-         case 3:
-         case 4:
-           if (('0' <= ch) && (ch <= '9')) {
-               uchar = (uchar << 4) | (ch - '0');
-              state++;
-              continue;
-           }
-           if (('a' <= ch) && (ch <= 'f')) {
-              uchar = (uchar << 4) | (ch - 'a' + 0x0a);
-              state++;
-              continue;
-           }
-           if (('A' <= ch) && (ch <= 'F')) {
-              uchar = (uchar << 4) | (ch - 'A' + 0x0a);
-              state++;
-              continue;
-           }
-           // if not hex digit, fall through
-         case 5:
-           value.Append((PRUnichar) uchar);
-           state = 0;
-           --i;
-           break;
-        }
-      }
-      if (state != 0) {
-        value.Append((PRUnichar) uchar);
-        state = 0;
-      }
-      
-      nsAutoString oldValue;
-      mSubclass->SetStringProperty(NS_ConvertUTF16toUTF8(key), value, oldValue);
-    }
+  nsPropertiesParser parser(mSubclass);
+
+  PRUint32 nProcessed;
+  while (NS_SUCCEEDED(mIn->ReadSegments(nsPropertiesParser::SegmentWriter, &parser, 2048, &nProcessed)) &&
+         nProcessed != 0);
+
+  // We may have an unprocessed value at this point
+  // if the last line did not have a proper line ending.
+  if (parser.GetState() == eParserState_Value) {
+    nsAutoString oldValue;  
+    parser.FinishValueState(oldValue);
   }
-  mIn->Close();
-  NS_RELEASE(mIn);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPersistentProperties::SetStringProperty(const nsACString& aKey,
                                           const nsAString& aNewValue,
                                           nsAString& aOldValue)
 {
-#if 0
-  cout << "will add " << aKey.get() << "=" <<
-    NS_LossyConvertUCS2ToASCII(aNewValue).get() << endl;
-#endif
-
   const nsAFlatCString&  flatKey = PromiseFlatCString(aKey);
   PropertyTableEntry *entry =
     static_cast<PropertyTableEntry*>
                (PL_DHashTableOperate(&mTable, flatKey.get(), PL_DHASH_ADD));
 
   if (entry->mKey) {
     aOldValue = entry->mValue;
     NS_WARNING(nsPrintfCString(aKey.Length() + 30,
@@ -365,72 +616,27 @@ nsPersistentProperties::Enumerate(nsISim
 {
   nsCOMPtr<nsISupportsArray> propArray;
   nsresult rv = NS_NewISupportsArray(getter_AddRefs(propArray));
   if (NS_FAILED(rv))
     return rv;
 
   // We know the necessary size; we can avoid growing it while adding elements
   if (!propArray->SizeTo(mTable.entryCount))
-   return NS_ERROR_OUT_OF_MEMORY;
+    return NS_ERROR_OUT_OF_MEMORY;
 
   // Step through hash entries populating a transient array
   PRUint32 n =
     PL_DHashTableEnumerate(&mTable, AddElemToArray, (void *)propArray);
   if (n < mTable.entryCount)
-      return NS_ERROR_OUT_OF_MEMORY;
+    return NS_ERROR_OUT_OF_MEMORY;
 
   return NS_NewArrayEnumerator(aResult, propArray);
 }
 
-
-PRInt32
-nsPersistentProperties::Read()
-{
-  PRUnichar  c;
-  PRUint32  nRead;
-  nsresult  ret;
-
-  ret = mIn->Read(&c, 1, &nRead);
-  if (ret == NS_OK && nRead == 1) {
-    return c;
-  }
-
-  return -1;
-}
-
-#define IS_WHITE_SPACE(c) \
-  (((c) == ' ') || ((c) == '\t') || ((c) == '\r') || ((c) == '\n'))
-
-PRInt32
-nsPersistentProperties::SkipWhiteSpace(PRInt32 c)
-{
-  while (IS_WHITE_SPACE(c)) {
-    c = Read();
-  }
-
-  return c;
-}
-
-PRInt32
-nsPersistentProperties::SkipLine(PRInt32 c)
-{
-  while ((c >= 0) && (c != '\r') && (c != '\n')) {
-    c = Read();
-  }
-  if (c == '\r') {
-    c = Read();
-  }
-  if (c == '\n') {
-    c = Read();
-  }
-
-  return c;
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // XXX Some day we'll unify the nsIPersistentProperties interface with
 // nsIProperties, but until now...
 
 NS_IMETHODIMP
 nsPersistentProperties::Get(const char* prop, const nsIID & uuid, void* *result)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
@@ -445,30 +651,35 @@ NS_IMETHODIMP
 nsPersistentProperties::Undefine(const char* prop)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 nsPersistentProperties::Has(const char* prop, PRBool *result)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  PropertyTableEntry *entry =
+    static_cast<PropertyTableEntry*>
+               (PL_DHashTableOperate(&mTable, prop, PL_DHASH_LOOKUP));
+
+  *result = (entry && PL_DHASH_ENTRY_IS_BUSY(entry));
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPersistentProperties::GetKeys(PRUint32 *count, char ***keys)
 {
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // PropertyElement
 ////////////////////////////////////////////////////////////////////////////////
 
-
 NS_METHOD
 nsPropertyElement::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
 {
   if (aOuter)
     return NS_ERROR_NO_AGGREGATION;
   nsPropertyElement* propElem = new nsPropertyElement();
   if (propElem == nsnull)
     return NS_ERROR_OUT_OF_MEMORY;
Index: xpcom/ds/nsPersistentProperties.h
===================================================================
RCS file: /cvsroot/mozilla/xpcom/ds/nsPersistentProperties.h,v
retrieving revision 1.16
diff -u -8 -p -d -r1.16 nsPersistentProperties.h
--- mozilla/xpcom/ds/nsPersistentProperties.h	18 Apr 2004 14:18:13 -0000	1.16
+++ mozilla/xpcom/ds/nsPersistentProperties.h	26 May 2008 21:59:32 -0000
@@ -37,52 +37,46 @@
 
 #ifndef nsPersistentProperties_h___
 #define nsPersistentProperties_h___
 
 #include "nsIPersistentProperties2.h"
 #include "pldhash.h"
 #include "plarena.h"
 #include "nsString.h"
+#include "nsCOMPtr.h"
 
-class nsIUnicharInputStream;
+#include "nsIUnicharInputStream.h"
 
 
 class nsPersistentProperties : public nsIPersistentProperties
 {
 public:
   nsPersistentProperties();
   nsresult Init();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIPROPERTIES
   NS_DECL_NSIPERSISTENTPROPERTIES
 
-
-  // nsPersistentProperties methods:
-  PRInt32 Read();
-  PRInt32 SkipLine(PRInt32 c);
-  PRInt32 SkipWhiteSpace(PRInt32 c);
-
   static NS_METHOD
   Create(nsISupports *aOuter, REFNSIID aIID, void **aResult);
 
 private:
   ~nsPersistentProperties();
 
 protected:
-  nsIUnicharInputStream* mIn;
-  PRUint32 mBufferPos;
-  PRUint32 mBufferLength;
+  nsCOMPtr<nsIUnicharInputStream> mIn;
+
   nsIPersistentProperties* mSubclass;
   struct PLDHashTable mTable;
   PLArenaPool mArena;
 };
 
-class nsPropertyElement : public nsIPropertyElement 
+class nsPropertyElement : public nsIPropertyElement
 {
 public:
   nsPropertyElement()
   {
   }
 
   nsPropertyElement(const nsACString& aKey, const nsAString& aValue)
     : mKey(aKey), mValue(aValue)
