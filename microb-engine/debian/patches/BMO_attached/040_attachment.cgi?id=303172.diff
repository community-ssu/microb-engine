? xpcom/io/.nsStreamUtils.cpp.swp
? xpcom/io/1
Index: netwerk/base/public/nsIBufferedStreams.idl
===================================================================
--- mozilla/netwerk/base/public/nsIBufferedStreams.idl.orig
+++ mozilla/netwerk/base/public/nsIBufferedStreams.idl
@@ -12,16 +12,31 @@
      * @param fillFromStream - add buffering to this stream
      * @param bufferSize     - specifies the maximum buffer size
      */
     void init(in nsIInputStream fillFromStream,
               in unsigned long bufferSize);
 };
 
 /**
+ * An input stream that reads ahead and keeps a buffer coming from another input
+ * stream so that fewer accesses to the underlying stream are necessary.
+ */
+[scriptable, uuid(04bb8018-6fb9-49c0-83fd-b4217f145034)]
+interface nsIMmapInputStream : nsIInputStream
+{
+    /**
+     * @param fillFromStream - add buffering to this stream
+     * @param bufferSize     - specifies the maximum buffer size
+     */
+    void init(in nsIInputStream fillFromStream,
+              in unsigned long bufferSize);
+};
+
+/**
  * An output stream that stores up data to write out to another output stream
  * and does the entire write only when the buffer is full, so that fewer writes
  * to the underlying output stream are necessary.
  */
 [scriptable, uuid(6476378a-da09-11d3-8cda-0060b0fc14a3)]
 interface nsIBufferedOutputStream : nsIOutputStream
 {
     /**
Index: netwerk/base/public/nsIFileStreams.idl
===================================================================
--- mozilla/netwerk/base/public/nsIFileStreams.idl.orig
+++ mozilla/netwerk/base/public/nsIFileStreams.idl
@@ -79,16 +79,59 @@
      * If this is set, the file will be reopened whenever Seek(0) occurs.  If
      * the file is already open and the seek occurs, it will happen naturally.
      * (The file will only be reopened if it is closed for some reason.)
      */
     const long REOPEN_ON_REWIND = 1<<3;
 };
 
 /**
+ * An input stream that allows you to read from an mmap-ed file.
+ */
+[scriptable, uuid(7ea8f99c-8585-422c-9dd5-eefcd3c1ce61)]
+interface nsIMmapFileInputStream : nsIInputStream
+{
+    /**
+     * @param file          file to read from (must QI to nsILocalFile)
+     * @param ioFlags       file open flags listed in prio.h (see
+     *                      PR_Open documentation) or -1 to open the
+     *                      file in default mode (PR_RDONLY).
+     * @param perm          file mode bits listed in prio.h or -1 to
+     *                      use the default value (0)
+     * @param behaviorFlags flags specifying various behaviors of the class
+     *        (see enumerations in the class)
+     */
+    void init(in nsIFile file, in long ioFlags, in long perm,
+              in long behaviorFlags);
+
+    /**
+     * If this is set, the file will be deleted by the time the stream is
+     * closed.  It may be removed before the stream is closed if it is possible
+     * to delete it and still read from it.
+     *
+     * If OPEN_ON_READ is defined, and the file was recreated after the first
+     * delete, the file will be deleted again when it is closed again.
+     */
+    const long DELETE_ON_CLOSE = 1<<1;
+
+    /**
+     * If this is set, the file will close automatically when the end of the
+     * file is reached.
+     */
+    const long CLOSE_ON_EOF = 1<<2;
+
+    /**
+     * If this is set, the file will be reopened whenever Seek(0) occurs.  If
+     * the file is already open and the seek occurs, it will happen naturally.
+     * (The file will only be reopened if it is closed for some reason.)
+     */
+    const long REOPEN_ON_REWIND = 1<<3;
+};
+
+/**
  * An output stream that lets you stream to a file.
  */
 [scriptable, uuid(e6f68040-c7ec-11d3-8cda-0060b0fc14a3)]
 interface nsIFileOutputStream : nsIOutputStream
 {
     /**
      * @param file          file to write to (must QI to nsILocalFile)
      * @param ioFlags       file open flags listed in prio.h (see
Index: netwerk/base/public/nsNetUtil.h
===================================================================
--- mozilla/netwerk/base/public/nsNetUtil.h.orig
+++ mozilla/netwerk/base/public/nsNetUtil.h
@@ -852,16 +852,36 @@
     if (NS_SUCCEEDED(rv)) {
         rv = in->Init(file, ioFlags, perm, behaviorFlags);
         if (NS_SUCCEEDED(rv))
             NS_ADDREF(*result = in);  // cannot use nsCOMPtr::swap
     }
     return rv;
 }
 
+#ifdef HAVE_PR_MEMMAP
+inline nsresult
+NS_NewMmapFileInputStream(nsIInputStream **result,
+                           nsIFile         *file,
+                           PRInt32          ioFlags       = -1,
+                           PRInt32          perm          = -1,
+                           PRInt32          behaviorFlags = 0)
+{
+    nsresult rv;
+    nsCOMPtr<nsIMmapFileInputStream> in =
+        do_CreateInstance(NS_MMAPFILEINPUTSTREAM_CONTRACTID, &rv);
+    if (NS_SUCCEEDED(rv)) {
+        rv = in->Init(file, ioFlags, perm, behaviorFlags);
+        if (NS_SUCCEEDED(rv))
+            NS_ADDREF(*result = in);  // cannot use nsCOMPtr::swap
+    }
+    return rv;
+}
+#endif // HAVE_PR_MEMMAP
+
 inline nsresult
 NS_NewLocalFileOutputStream(nsIOutputStream **result,
                             nsIFile          *file,
                             PRInt32           ioFlags       = -1,
                             PRInt32           perm          = -1,
                             PRInt32           behaviorFlags = 0)
 {
     nsresult rv;
@@ -953,16 +973,34 @@
     if (NS_SUCCEEDED(rv)) {
         rv = in->Init(str, bufferSize);
         if (NS_SUCCEEDED(rv))
             NS_ADDREF(*result = in);  // cannot use nsCOMPtr::swap
     }
     return rv;
 }
 
+#ifdef HAVE_PR_MEMMAP
+inline nsresult
+NS_NewMmapInputStream(nsIInputStream **result,
+                          nsIInputStream  *str,
+                          PRUint32         bufferSize)
+{
+    nsresult rv;
+    nsCOMPtr<nsIMmapInputStream> in =
+        do_CreateInstance(NS_MMAPINPUTSTREAM_CONTRACTID, &rv);
+    if (NS_SUCCEEDED(rv)) {
+        rv = in->Init(str, bufferSize);
+        if (NS_SUCCEEDED(rv))
+            NS_ADDREF(*result = in);  // cannot use nsCOMPtr::swap
+    }
+    return rv;
+}
+#endif // HAVE_PR_MEMMAP
+
 // note: the resulting stream can be QI'ed to nsISafeOutputStream iff the
 // provided stream supports it.
 inline nsresult
 NS_NewBufferedOutputStream(nsIOutputStream **result,
                            nsIOutputStream  *str,
                            PRUint32          bufferSize)
 {
     nsresult rv;
Index: netwerk/base/src/nsBufferedStreams.cpp
===================================================================
--- mozilla/netwerk/base/src/nsBufferedStreams.cpp.orig
+++ mozilla/netwerk/base/src/nsBufferedStreams.cpp
@@ -461,16 +461,193 @@
     mBufferStartOffset += mCursor;
     mFillPoint = mCursor = 0;
 
     *aStream = mStream;
     NS_IF_ADDREF(*aStream);
     return NS_OK;
 }
 
+#ifdef HAVE_PR_MEMMAP
+////////////////////////////////////////////////////////////////////////////////
+// nsMmapInputStream
+// Mimicks nsBufferedInputStream interface using an MMAP IO stream.
+// Implemented to replace nsBufferedInputStream, when MMAP file IO is
+// available.
+
+NS_IMPL_ISUPPORTS_INHERITED3(nsMmapInputStream,
+                             nsBufferedStream,
+                             nsIInputStream,
+                             nsIMmapInputStream,
+                             nsIStreamBufferAccess)
+
+NS_METHOD
+nsMmapInputStream::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
+{
+    NS_ENSURE_NO_AGGREGATION(aOuter);
+
+    nsMmapInputStream* stream = new nsMmapInputStream();
+    if (stream == nsnull)
+        return NS_ERROR_OUT_OF_MEMORY;
+    NS_ADDREF(stream);
+    nsresult rv = stream->QueryInterface(aIID, aResult);
+    NS_RELEASE(stream);
+    return rv;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::Init(nsIInputStream* stream, PRUint32 bufferSize)
+{
+    NS_ASSERTION(stream, "need to supply a stream");
+    NS_ASSERTION(mStream == nsnull, "already inited");
+    mStream = stream;
+    NS_IF_ADDREF(mStream);
+
+    //return nsBufferedStream::Init(stream, bufferSize);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::Close()
+{
+    nsresult rv1 = NS_OK, rv2;
+    if (mStream) {
+        rv1 = Source()->Close();
+        NS_RELEASE(mStream);
+    }
+    rv2 = nsBufferedStream::Close();
+    if (NS_FAILED(rv1)) return rv1;
+    return rv2;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::Available(PRUint32 *result)
+{
+    nsresult rv = NS_OK;
+    *result = 0;
+    if (mStream) {
+        rv = Source()->Available(result);
+    }
+    return rv;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::Read(char * buf, PRUint32 count, PRUint32 *result)
+{
+    return Source()->Read(buf, count, result);
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::ReadSegments(nsWriteSegmentFun writer, void *closure,
+                                    PRUint32 count, PRUint32 *result)
+{
+    *result = 0;
+
+    if (!mStream)
+        return NS_OK;
+
+    /* XXX Can we do better?
+     */
+    char * temp_buf = new char [count];
+    PRUint32 read = 0;
+
+    Source ()->Read (temp_buf, count, result);
+
+    nsresult rv = NS_OK;
+
+    rv = writer(this, closure, temp_buf, 0, *result, &read);
+
+    delete temp_buf;
+
+    return (*result > 0) ? NS_OK : rv;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::IsNonBlocking(PRBool *aNonBlocking)
+{
+    if (mStream)
+        return Source()->IsNonBlocking(aNonBlocking);
+    return NS_ERROR_NOT_INITIALIZED;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::Fill()
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(char*)
+nsMmapInputStream::GetBuffer(PRUint32 aLength, PRUint32 aAlignMask)
+{
+    /* Can we do better?
+     */
+    return nsnull;
+}
+
+NS_IMETHODIMP_(void)
+nsMmapInputStream::PutBuffer(char* aBuffer, PRUint32 aLength)
+{
+    /* Can we do better?
+     */
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::DisableBuffering()
+{
+    /* Can we do better?
+     */
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::EnableBuffering()
+{
+    /* Can we do better?
+     */
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::GetUnbufferedStream(nsISupports* *aStream)
+{
+    *aStream = mStream;
+    NS_IF_ADDREF(*aStream);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::Seek(PRInt32 whence, PRInt64 offset)
+{
+    if (mStream == nsnull)
+        return NS_BASE_STREAM_CLOSED;
+
+    // If the underlying stream isn't a random access store, then fail early.
+    // We could possibly succeed for the case where the seek position denotes
+    // something that happens to be read into the buffer, but that would make
+    // the failure data-dependent.
+    nsresult rv;
+    nsCOMPtr<nsISeekableStream> ras = do_QueryInterface(mStream, &rv);
+    if (NS_FAILED(rv)) return rv;
+
+    return ras->Seek(whence, offset);
+}
+
+NS_IMETHODIMP
+nsMmapInputStream::Tell(PRInt64 *result)
+{
+    if (mStream == nsnull)
+        return NS_BASE_STREAM_CLOSED;
+
+    nsresult rv;
+    nsCOMPtr<nsISeekableStream> ras = do_QueryInterface(mStream, &rv);
+    if (NS_FAILED(rv)) return rv;
+    return ras->Tell (result);
+}
+#endif // HAVE_PR_MEMMAP
+
 ////////////////////////////////////////////////////////////////////////////////
 // nsBufferedOutputStream
 
 NS_IMPL_ADDREF_INHERITED(nsBufferedOutputStream, nsBufferedStream)
 NS_IMPL_RELEASE_INHERITED(nsBufferedOutputStream, nsBufferedStream)
 // This QI uses NS_INTERFACE_MAP_ENTRY_CONDITIONAL to check for
 // non-nullness of mSafeStream.
 NS_INTERFACE_MAP_BEGIN(nsBufferedOutputStream)
Index: netwerk/base/src/nsBufferedStreams.h
===================================================================
--- mozilla/netwerk/base/src/nsBufferedStreams.h.orig
+++ mozilla/netwerk/base/src/nsBufferedStreams.h
@@ -107,16 +107,47 @@
         return (nsIInputStream*)mStream;
     }
 
 protected:
     NS_IMETHOD Fill();
     NS_IMETHOD Flush() { return NS_OK; } // no-op for input streams
 };
 
+#ifdef HAVE_PR_MEMMAP
+////////////////////////////////////////////////////////////////////////////////
+
+class nsMmapInputStream : public nsBufferedStream,
+                              public nsIMmapInputStream,
+                              public nsIStreamBufferAccess
+{
+public:
+    NS_DECL_ISUPPORTS_INHERITED
+    NS_DECL_NSIINPUTSTREAM
+    NS_DECL_NSIMMAPINPUTSTREAM
+    NS_DECL_NSISTREAMBUFFERACCESS
+
+    nsMmapInputStream() : nsBufferedStream() {}
+    virtual ~nsMmapInputStream() {}
+
+    static NS_METHOD
+    Create(nsISupports *aOuter, REFNSIID aIID, void **aResult);
+
+    nsIInputStream* Source() {
+        return (nsIInputStream*)mStream;
+    }
+    NS_METHOD Seek(PRInt32 whence, PRInt64 offset);
+    NS_METHOD Tell(PRInt64 * result);
+
+protected:
+    NS_IMETHOD Fill();
+    NS_IMETHOD Flush() { return NS_OK; } // no-op for input streams
+};
+#endif // HAVE_PR_MEMMAP
+
 ////////////////////////////////////////////////////////////////////////////////
 
 class nsBufferedOutputStream : public nsBufferedStream, 
                                public nsISafeOutputStream,
                                public nsIBufferedOutputStream,
                                public nsIStreamBufferAccess
 {
 public:
Index: netwerk/base/src/nsFileStreams.cpp
===================================================================
--- mozilla/netwerk/base/src/nsFileStreams.cpp.orig
+++ mozilla/netwerk/base/src/nsFileStreams.cpp
@@ -350,16 +350,319 @@
         } else {
             return NS_BASE_STREAM_CLOSED;
         }
     }
 
     return nsFileStream::Seek(aWhence, aOffset);
 }
 
+#ifdef HAVE_PR_MEMMAP
+////////////////////////////////////////////////////////////////////////////////
+// nsMmapFileInputStream
+// XXX Some code copied from nsFileInputStream. If there is a bug fix in
+// nsFileInputStream, please check this too and apply.
+
+
+NS_IMPL_ISUPPORTS_INHERITED2(nsMmapFileInputStream,
+                             nsFileStream,
+                             nsIInputStream,
+                             nsIMmapFileInputStream)
+
+
+NS_METHOD
+nsMmapFileInputStream::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
+{
+    NS_ENSURE_NO_AGGREGATION(aOuter);
+
+    nsMmapFileInputStream* stream = new nsMmapFileInputStream();
+    if (stream == nsnull)
+        return NS_ERROR_OUT_OF_MEMORY;
+    NS_ADDREF(stream);
+    nsresult rv = stream->QueryInterface(aIID, aResult);
+    NS_RELEASE(stream);
+    return rv;
+}
+
+
+nsresult
+nsMmapFileInputStream::Open(nsIFile* aFile, PRInt32 aIOFlags, PRInt32 aPerm)
+{
+    nsresult rv = NS_OK;
+
+    // If the previous file is open, close it
+    if (mFD) {
+        PR_MemUnmap (mmapBuf, mmapLen);
+        rv = Close();
+        if (NS_FAILED(rv)) return rv;
+    }
+
+    // Open the file
+    nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(aFile, &rv);
+    if (NS_FAILED(rv)) return rv;
+    if (aIOFlags == -1)
+        aIOFlags = PR_RDONLY;
+    if (aPerm == -1)
+        aPerm = 0;
+
+    PRFileDesc* fd;
+    rv = localFile->OpenNSPRFileDesc(aIOFlags, aPerm, &fd);
+    if (NS_FAILED(rv)) return rv;
+
+    mFD = fd;
+    PRInt64 fileSize;
+
+    localFile->GetFileSize (&fileSize);
+
+    PRFileMap * map = PR_CreateFileMap (fd, fileSize, PR_PROT_READONLY);
+
+    if (!map)
+        return NS_ERROR_FAILURE;
+
+    PRUint32 fsz;
+    LL_L2UI (fsz, fileSize);
+
+    mMap = map;
+    mmapBuf = PR_MemMap (map, 0, fsz);
+
+    if (!mmapBuf)
+        return NS_ERROR_FAILURE;
+
+    mmapLen = fsz;
+    mCurOffset = 0;
+
+    if (mBehaviorFlags & DELETE_ON_CLOSE) {
+        // POSIX compatible filesystems allow a file to be unlinked while a
+        // file descriptor is still referencing the file.  since we've already
+        // opened the file descriptor, we'll try to remove the file.  if that
+        // fails, then we'll just remember the nsIFile and remove it after we
+        // close the file descriptor.
+        rv = aFile->Remove(PR_FALSE);
+        if (NS_FAILED(rv) && !(mBehaviorFlags & REOPEN_ON_REWIND)) {
+            // If REOPEN_ON_REWIND is not happenin', we haven't saved the file yet
+            mFile = aFile;
+        }
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapFileInputStream::Init(nsIFile* aFile, PRInt32 aIOFlags, PRInt32 aPerm,
+                        PRInt32 aBehaviorFlags)
+{
+    NS_ENSURE_TRUE(!mFD, NS_ERROR_ALREADY_INITIALIZED);
+    NS_ENSURE_TRUE(!mParent, NS_ERROR_ALREADY_INITIALIZED);
+
+    mBehaviorFlags = aBehaviorFlags;
+
+    // If the file will be reopened on rewind, save the info to open the file
+    if (mBehaviorFlags & REOPEN_ON_REWIND) {
+        mFile = aFile;
+        mIOFlags = aIOFlags;
+        mPerm = aPerm;
+    }
+
+    return Open(aFile, aIOFlags, aPerm);
+}
+
+NS_IMETHODIMP
+nsMmapFileInputStream::Close()
+{
+    if (mmapBuf) {
+        PR_MemUnmap (mmapBuf, mmapLen);
+        PR_CloseFileMap (mMap);
+        mmapBuf = 0;
+        mmapLen = 0;
+    }
+
+    nsresult rv = nsFileStream::Close();
+    if (NS_FAILED(rv)) return rv;
+    if (mFile && (mBehaviorFlags & DELETE_ON_CLOSE)) {
+        rv = mFile->Remove(PR_FALSE);
+        NS_ASSERTION(NS_SUCCEEDED(rv), "failed to delete file");
+        // If we don't need to save the file for reopening, free it up
+        if (!(mBehaviorFlags & REOPEN_ON_REWIND)) {
+          mFile = nsnull;
+        }
+    }
+
+    return rv;
+}
+
+void
+nsMmapFileInputStream::CheckNRemap ()
+{
+    PRUint32 cnt = PR_Seek (mFD, 0, PR_SEEK_END);
+    if (cnt == -1)
+    {
+        // XXX What should we do now?
+        return;
+    }
+
+    if (cnt != mmapLen)
+    {
+        //Need to remap
+        PR_MemUnmap (mmapBuf, mmapLen);
+        PR_CloseFileMap (mMap);
+
+        PRInt64 fsz;
+        LL_I2L (cnt, fsz);
+        mMap = PR_CreateFileMap (mFD, fsz, PR_PROT_READONLY);
+
+        mmapBuf = PR_MemMap (mMap, 0, cnt);
+        mmapLen = cnt;
+        if (mCurOffset > cnt)
+            mCurOffset = mmapLen;
+    }
+}
+
+NS_IMETHODIMP
+nsMmapFileInputStream::Available(PRUint32* aResult)
+{
+    if (!mFD) {
+        return NS_BASE_STREAM_CLOSED;
+    }
+
+    CheckNRemap ();
+
+    *aResult = mmapLen - mCurOffset;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapFileInputStream::Read(char* aBuf, PRUint32 aCount, PRUint32* aResult)
+{
+    if (!mFD) {
+        *aResult = 0;
+        return NS_OK;
+    }
+
+    PRInt32 bytesRead = aCount;
+
+    if (mCurOffset + aCount > mmapLen)
+    {
+        CheckNRemap ();
+        if (mCurOffset + aCount > mmapLen)
+        {
+            bytesRead = mmapLen - mCurOffset;
+        }
+    }
+
+    memcpy (aBuf, (char *)mmapBuf + mCurOffset, bytesRead);
+
+    mCurOffset += bytesRead;
+
+    // Check if we're at the end of file and need to close
+    if (mBehaviorFlags & CLOSE_ON_EOF) {
+        if (mCurOffset == mmapLen) {
+            Close();
+        }
+    }
+
+    *aResult = bytesRead;
+
+    return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsMmapFileInputStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                                PRUint32 aCount, PRUint32* aResult)
+{
+    // ReadSegments is not implemented because it would be inefficient when
+    // the writer does not consume all data.  If you want to call ReadSegments,
+    // wrap a BufferedInputStream around the file stream.  That will call
+    // Read().
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMmapFileInputStream::IsNonBlocking(PRBool *aNonBlocking)
+{
+    *aNonBlocking = PR_FALSE;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapFileInputStream::Seek(PRInt32 aWhence, PRInt64 aOffset)
+{
+    if (!mFD) {
+        if (mBehaviorFlags & REOPEN_ON_REWIND) {
+            nsresult rv = Reopen();
+            if (NS_FAILED(rv)) {
+                return rv;
+            }
+        } else {
+            return NS_BASE_STREAM_CLOSED;
+        }
+    }
+    PRInt32 newoffset;
+    LL_L2I (newoffset, aOffset);
+
+    if (aWhence == nsISeekableStream::NS_SEEK_CUR)
+    {
+        newoffset += mCurOffset;
+    }
+    else if (aWhence == nsISeekableStream::NS_SEEK_END)
+    {
+        //NS_SEEK_END
+        newoffset += mmapLen;
+    }
+
+    if (newoffset <= mmapLen)
+    {
+        //mCurOffset = newoffset;
+        mCurOffset = newoffset;
+        return NS_OK;
+    }
+    else
+    {
+        CheckNRemap ();
+        if (aWhence == nsISeekableStream::NS_SEEK_END)
+        {
+            LL_L2I (newoffset, aOffset);
+            newoffset += mmapLen;
+        }
+        if (newoffset <= mmapLen)
+        {
+            mCurOffset = newoffset;
+            return NS_OK;
+
+        }
+        else
+        {
+            return NS_ERROR_FAILURE;
+        }
+    }
+}
+NS_IMETHODIMP
+nsMmapFileInputStream::Tell(PRInt64 *result)
+{
+    if (mFD == nsnull)
+        return NS_BASE_STREAM_CLOSED;
+
+    LL_UI2L (*result, mCurOffset);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMmapFileInputStream::SetEOF()
+{
+    if (mFD == nsnull)
+        return NS_BASE_STREAM_CLOSED;
+
+    PR_Seek (mFD, mCurOffset, PR_SEEK_SET);
+
+    mmapLen = mCurOffset;
+
+    return nsFileStream::SetEOF ();
+}
+#endif // HAVE_PR_MEMMAP
+
 ////////////////////////////////////////////////////////////////////////////////
 // nsFileOutputStream
 
 NS_IMPL_ISUPPORTS_INHERITED2(nsFileOutputStream, 
                              nsFileStream,
                              nsIOutputStream,
                              nsIFileOutputStream)
  
Index: netwerk/base/src/nsFileStreams.h
===================================================================
--- mozilla/netwerk/base/src/nsFileStreams.h.orig
+++ mozilla/netwerk/base/src/nsFileStreams.h
@@ -130,16 +130,96 @@
      */
     nsresult Open(nsIFile* file, PRInt32 ioFlags, PRInt32 perm);
     /**
      * Reopen the file (for OPEN_ON_READ only!)
      */
     nsresult Reopen() { return Open(mFile, mIOFlags, mPerm); }
 };
 
+#ifdef HAVE_PR_MEMMAP
+////////////////////////////////////////////////////////////////////////////////
+// Some code is copied from nsFileInputStream. So, if there is a bug fix
+// for nsFileInputStream, please check this class too.
+
+
+class nsMmapFileInputStream : public nsFileStream,
+                          public nsIMmapFileInputStream
+{
+public:
+    NS_DECL_ISUPPORTS_INHERITED
+    NS_DECL_NSIINPUTSTREAM
+    NS_DECL_NSIMMAPFILEINPUTSTREAM
+
+    // Overrided from nsFileStream
+    NS_IMETHOD Seek(PRInt32 aWhence, PRInt64 aOffset);
+    NS_IMETHODIMP Tell(PRInt64 *result);
+    NS_IMETHODIMP SetEOF();
+
+    nsMmapFileInputStream() : nsFileStream()
+    {
+        mmapBuf = 0;
+        mmapLen = 0;
+        mCurOffset = 0;
+
+        mBehaviorFlags = 0;
+    }
+    virtual ~nsMmapFileInputStream()
+    {
+        Close();
+    }
+
+    static NS_METHOD
+    Create(nsISupports *aOuter, REFNSIID aIID, void **aResult);
+
+protected:
+    /**
+     * The file being opened.  Only stored when DELETE_ON_CLOSE or
+     * REOPEN_ON_REWIND are true.
+     */
+    nsCOMPtr<nsIFile> mFile;
+
+    void * mmapBuf;
+
+    PRFileMap * mMap;
+
+    PRUint32 mmapLen;
+
+    PRUint32 mCurOffset;
+
+    /**
+     * The IO flags passed to Init() for the file open.
+     * Only set for REOPEN_ON_REWIND.
+     */
+    PRInt32 mIOFlags;
+    /**
+     * The permissions passed to Init() for the file open.
+     * Only set for REOPEN_ON_REWIND.
+     */
+    PRInt32 mPerm;
+    /**
+     * Flags describing our behavior.  See the IDL file for possible values.
+     */
+    PRInt32 mBehaviorFlags;
+
+protected:
+    /**
+     * Internal, called to open a file.  Parameters are the same as their
+     * Init() analogues.
+     */
+    nsresult Open(nsIFile* file, PRInt32 ioFlags, PRInt32 perm);
+    /**
+     * Reopen the file (for OPEN_ON_READ only!)
+     */
+    nsresult Reopen() { return Open(mFile, mIOFlags, mPerm); }
+private:
+    void CheckNRemap (void);
+};
+#endif // HAVE_PR_MEMMAP
+
 ////////////////////////////////////////////////////////////////////////////////
 
 class nsFileOutputStream : public nsFileStream,
                            public nsIFileOutputStream
 {
 public:
     NS_DECL_ISUPPORTS_INHERITED
     NS_DECL_NSIOUTPUTSTREAM
Index: netwerk/build/nsNetCID.h
===================================================================
--- mozilla/netwerk/build/nsNetCID.h.orig
+++ mozilla/netwerk/build/nsNetCID.h
@@ -376,16 +376,28 @@
 #define NS_LOCALFILEINPUTSTREAM_CID                  \
 { /* be9a53ae-c7e9-11d3-8cda-0060b0fc14a3 */         \
     0xbe9a53ae,                                      \
     0xc7e9,                                          \
     0x11d3,                                          \
     {0x8c, 0xda, 0x00, 0x60, 0xb0, 0xfc, 0x14, 0xa3} \
 }
 
+#define NS_MMAPFILEINPUTSTREAM_CLASSNAME \
+    "nsMmapFileInputStream"
+#define NS_MMAPFILEINPUTSTREAM_CONTRACTID \
+    "@mozilla.org/network/mmapf-input-stream;1"
+#define NS_MMAPFILEINPUTSTREAM_CID                   \
+{ /* 0a8306aa-cc27-4b44-b2a3-2449121eb080 */         \
+    0x0a8306aa,                                      \
+    0xcc27,                                          \
+    0x4b44,                                          \
+    {0xb2, 0xa3, 0x24, 0x49, 0x12, 0x1e, 0xb0, 0x80} \
+}
+
 #define NS_LOCALFILEOUTPUTSTREAM_CLASSNAME \
     "nsFileOutputStream"
 #define NS_LOCALFILEOUTPUTSTREAM_CONTRACTID \
     "@mozilla.org/network/file-output-stream;1"
 #define NS_LOCALFILEOUTPUTSTREAM_CID                 \
 { /* c272fee0-c7e9-11d3-8cda-0060b0fc14a3 */         \
     0xc272fee0,                                      \
     0xc7e9,                                          \
@@ -400,16 +412,28 @@
 #define NS_BUFFEREDINPUTSTREAM_CID                   \
 { /* 9226888e-da08-11d3-8cda-0060b0fc14a3 */         \
     0x9226888e,                                      \
     0xda08,                                          \
     0x11d3,                                          \
     {0x8c, 0xda, 0x00, 0x60, 0xb0, 0xfc, 0x14, 0xa3} \
 }
 
+#define NS_MMAPINPUTSTREAM_CLASSNAME \
+    "nsMmapInputStream"
+#define NS_MMAPINPUTSTREAM_CONTRACTID \
+    "@mozilla.org/network/mmap-input-stream;1"
+#define NS_MMAPINPUTSTREAM_CID                       \
+{ /* c2310f1c-de7a-4775-aeea-c89d20c4fce8 */         \
+    0xc2310f1c,                                      \
+    0xde7a,                                          \
+    0x4775,                                          \
+    {0xae, 0xea, 0xc8, 0x9d, 0x20, 0xc4, 0xfc, 0xe8} \
+}
+
 #define NS_BUFFEREDOUTPUTSTREAM_CLASSNAME \
     "nsBufferedOutputStream"
 #define NS_BUFFEREDOUTPUTSTREAM_CONTRACTID \
     "@mozilla.org/network/buffered-output-stream;1"
 #define NS_BUFFEREDOUTPUTSTREAM_CID                  \
 { /* 9868b4ce-da08-11d3-8cda-0060b0fc14a3 */         \
     0x9868b4ce,                                      \
     0xda08,                                          \
Index: netwerk/build/nsNetModule.cpp
===================================================================
--- mozilla/netwerk/build/nsNetModule.cpp.orig
+++ mozilla/netwerk/build/nsNetModule.cpp
@@ -704,16 +704,22 @@
     { NS_LOADGROUP_CLASSNAME,
       NS_LOADGROUP_CID,
       NS_LOADGROUP_CONTRACTID,
       nsLoadGroupConstructor },
     { NS_LOCALFILEINPUTSTREAM_CLASSNAME, 
       NS_LOCALFILEINPUTSTREAM_CID,
       NS_LOCALFILEINPUTSTREAM_CONTRACTID,
       nsFileInputStream::Create },
+#ifdef HAVE_PR_MEMMAP
+    { NS_MMAPFILEINPUTSTREAM_CLASSNAME,
+      NS_MMAPFILEINPUTSTREAM_CID,
+      NS_MMAPFILEINPUTSTREAM_CONTRACTID,
+      nsMmapFileInputStream::Create },
+#endif // HAVE_PR_MEMMAP
     { NS_LOCALFILEOUTPUTSTREAM_CLASSNAME, 
       NS_LOCALFILEOUTPUTSTREAM_CID,
       NS_LOCALFILEOUTPUTSTREAM_CONTRACTID,
       nsFileOutputStream::Create },
     { NS_SAFELOCALFILEOUTPUTSTREAM_CLASSNAME,
       NS_SAFELOCALFILEOUTPUTSTREAM_CID,
       NS_SAFELOCALFILEOUTPUTSTREAM_CONTRACTID,
       nsSafeFileOutputStreamConstructor
@@ -750,16 +756,24 @@
       NS_STANDARDURL_CID,
       NS_STANDARDURL_CONTRACTID,
       nsStandardURLConstructor },
 
     { NS_BUFFEREDINPUTSTREAM_CLASSNAME, 
       NS_BUFFEREDINPUTSTREAM_CID,
       NS_BUFFEREDINPUTSTREAM_CONTRACTID,
       nsBufferedInputStream::Create },
+
+#ifdef HAVE_PR_MEMMAP
+    { NS_MMAPINPUTSTREAM_CLASSNAME,
+      NS_MMAPINPUTSTREAM_CID,
+      NS_MMAPINPUTSTREAM_CONTRACTID,
+      nsMmapInputStream::Create },
+#endif // HAVE_PR_MEMMAP
+
     { NS_BUFFEREDOUTPUTSTREAM_CLASSNAME, 
       NS_BUFFEREDOUTPUTSTREAM_CID,
       NS_BUFFEREDOUTPUTSTREAM_CONTRACTID,
       nsBufferedOutputStream::Create },
     { NS_MIMEINPUTSTREAM_CLASSNAME,
       NS_MIMEINPUTSTREAM_CID,
       NS_MIMEINPUTSTREAM_CONTRACTID,
       nsMIMEInputStreamConstructor },
Index: xpcom/io/nsFastLoadFile.cpp
===================================================================
--- mozilla/xpcom/io/nsFastLoadFile.cpp.orig
+++ mozilla/xpcom/io/nsFastLoadFile.cpp
@@ -277,24 +277,70 @@
     if (NS_FAILED(rv))
         return rv;
 
     if (bytesRead != sizeof *aHeader ||
         memcmp(aHeader->mMagic, magic, MFL_FILE_MAGIC_SIZE)) {
         return NS_ERROR_UNEXPECTED;
     }
 
+#ifdef ALWAYS_BIG_ENDIAN
     aHeader->mChecksum     = NS_SWAP32(aHeader->mChecksum);
     aHeader->mVersion      = NS_SWAP32(aHeader->mVersion);
     aHeader->mFooterOffset = NS_SWAP32(aHeader->mFooterOffset);
     aHeader->mFileSize     = NS_SWAP32(aHeader->mFileSize);
+#endif //ALWAYS_BIG_ENDIAN
 
     return NS_OK;
 }
 
+#ifndef ALWAYS_BIG_ENDIAN
+
+nsresult
+nsFastLoadFileReader::Read16 (PRUint16 * a16)
+{
+    nsresult rv;
+    PRUint32 bytesRead;
+
+    rv = Read(reinterpret_cast<char*>(a16), sizeof *a16, &bytesRead);
+    if (NS_FAILED(rv)) return rv;
+    if (bytesRead != sizeof *a16)
+        return NS_ERROR_FAILURE;
+    //*a16 = NS_SWAP16(*a16);
+    return rv;
+}
+
+nsresult
+nsFastLoadFileReader::Read32 (PRUint32 * a32)
+{
+    nsresult rv;
+    PRUint32 bytesRead;
+
+    rv = Read(reinterpret_cast<char*>(a32), sizeof *a32, &bytesRead);
+    if (NS_FAILED(rv)) return rv;
+    if (bytesRead != sizeof *a32)
+        return NS_ERROR_FAILURE;
+    //*a32 = NS_SWAP32(*a32);
+    return rv;
+}
+NS_IMETHODIMP
+nsFastLoadFileReader::Read64(PRUint64* a64)
+{
+    nsresult rv;
+    PRUint32 bytesRead;
+
+    rv = Read(reinterpret_cast<char*>(a64), sizeof *a64, &bytesRead);
+    if (NS_FAILED(rv)) return rv;
+    if (bytesRead != sizeof *a64)
+        return NS_ERROR_FAILURE;
+    return rv;
+}
+
+#endif // ALWAYS_BIG_ENDIAN
+
 // nsIFastLoadFileControl methods:
 
 NS_IMETHODIMP
 nsFastLoadFileReader::GetChecksum(PRUint32 *aChecksum)
 {
     *aChecksum = mHeader.mChecksum;
     return NS_OK;
 }
@@ -832,39 +878,54 @@
     aFooter->mDependencies = readDeps;
     return NS_OK;
 }
 
 nsresult
 nsFastLoadFileReader::ReadFooterPrefix(nsFastLoadFooterPrefix *aFooterPrefix)
 {
     nsresult rv;
+
+#ifdef  USE_PACKED_STRUCTS
+    PRUint32 bytesRead;
 
+    rv = Read(reinterpret_cast<char*>(aFooterPrefix), sizeof *aFooterPrefix, &bytesRead);
+    if (NS_FAILED(rv))
+        return rv;
+
+    if (bytesRead != sizeof *aFooterPrefix) {
+        return NS_ERROR_UNEXPECTED;
+    }
+
+#else
     rv = Read32(&aFooterPrefix->mNumIDs);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Read32(&aFooterPrefix->mNumSharpObjects);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Read32(&aFooterPrefix->mNumMuxedDocuments);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Read32(&aFooterPrefix->mNumDependencies);
     if (NS_FAILED(rv))
         return rv;
 
+#endif // USE_PACKED_STRUCTS
+
     return NS_OK;
 }
 
 nsresult
 nsFastLoadFileReader::ReadSlowID(nsID *aID)
 {
+#ifndef USE_PACKED_STRUCTS
     nsresult rv;
 
     rv = Read32(&aID->m0);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Read16(&aID->m1);
     if (NS_FAILED(rv))
@@ -876,47 +937,77 @@
 
     PRUint32 bytesRead;
     rv = Read(reinterpret_cast<char*>(aID->m3), sizeof aID->m3, &bytesRead);
     if (NS_FAILED(rv))
         return rv;
 
     if (bytesRead != sizeof aID->m3)
         return NS_ERROR_FAILURE;
+#else
+    nsresult rv;
+    PRUint32 bytesRead;
+
+    rv = Read(reinterpret_cast<char*>(aID), sizeof *aID, &bytesRead);
+    if (NS_FAILED(rv))
+        return rv;
+
+    if (bytesRead != sizeof *aID) {
+        return NS_ERROR_UNEXPECTED;
+    }
+#endif // USE_PACKED_STRUCTS
+
     return NS_OK;
 }
 
 nsresult
 nsFastLoadFileReader::ReadFastID(NSFastLoadID *aID)
 {
     nsresult rv = Read32(aID);
     if (NS_SUCCEEDED(rv))
         *aID ^= MFL_ID_XOR_KEY;
     return rv;
 }
 
 nsresult
 nsFastLoadFileReader::ReadSharpObjectInfo(nsFastLoadSharpObjectInfo *aInfo)
 {
+#ifndef USE_PACKED_STRUCTS
     nsresult rv;
 
     rv = Read32(&aInfo->mCIDOffset);
     if (NS_FAILED(rv))
         return rv;
 
     NS_ASSERTION(aInfo->mCIDOffset != 0,
                  "fastload reader: mCIDOffset cannot be zero!");
 
     rv = Read16(&aInfo->mStrongRefCnt);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Read16(&aInfo->mWeakRefCnt);
     if (NS_FAILED(rv))
         return rv;
+#else
+    nsresult rv;
+    PRUint32 bytesRead;
+
+    rv = Read(reinterpret_cast<char*>(aInfo), sizeof *aInfo, &bytesRead);
+    if (NS_FAILED(rv))
+        return rv;
+
+    if (bytesRead != sizeof *aInfo) {
+        return NS_ERROR_UNEXPECTED;
+    }
+
+    NS_ASSERTION(aInfo->mCIDOffset != 0,
+                 "fastload reader: mCIDOffset cannot be zero!");
+
+#endif // USE_PACKED_STRUCTS
 
     return NS_OK;
 }
 
 nsresult
 nsFastLoadFileReader::ReadMuxedDocumentInfo(nsFastLoadMuxedDocumentInfo *aInfo)
 {
     nsresult rv;
@@ -1270,16 +1361,44 @@
     idmap_HashKey,
     idmap_MatchEntry,
     PL_DHashMoveEntryStub,
     PL_DHashClearEntryStub,
     PL_DHashFinalizeStub,
     NULL
 };
 
+#ifndef ALWAYS_BIG_ENDIAN
+
+NS_IMETHODIMP
+nsFastLoadFileWriter::Write16(PRUint16 a16)
+{
+    return WriteFully((const char*)&a16, sizeof a16);
+}
+
+NS_IMETHODIMP
+nsFastLoadFileWriter::Write32(PRUint32 a32)
+{
+    return WriteFully((const char*)&a32, sizeof a32);
+}
+
+NS_IMETHODIMP
+nsFastLoadFileWriter::Write64(PRUint64 a64)
+{
+    nsresult rv;
+    PRUint32 bytesWritten;
+
+    rv = Write(reinterpret_cast<char*>(&a64), sizeof a64, &bytesWritten);
+    if (NS_FAILED(rv)) return rv;
+    if (bytesWritten != sizeof a64)
+        return NS_ERROR_FAILURE;
+    return rv;
+}
+#endif // ALWAYS_BIG_ENDIAN
+
 nsresult
 nsFastLoadFileWriter::MapID(const nsID& aSlowID, NSFastLoadID *aResult)
 {
     nsIDMapEntry* entry =
         static_cast<nsIDMapEntry*>
                    (PL_DHashTableOperate(&mIDMap, &aSlowID, PL_DHASH_ADD));
     if (!entry)
         return NS_ERROR_OUT_OF_MEMORY;
@@ -1294,16 +1413,17 @@
 }
 
 nsresult
 nsFastLoadFileWriter::WriteHeader(nsFastLoadHeader *aHeader)
 {
     nsresult rv;
     PRUint32 bytesWritten;
 
+#ifndef USE_PACKED_STRUCTS
     rv = Write(aHeader->mMagic, MFL_FILE_MAGIC_SIZE, &bytesWritten);
     if (NS_FAILED(rv))
         return rv;
 
     if (bytesWritten != MFL_FILE_MAGIC_SIZE)
         return NS_ERROR_FAILURE;
 
     rv = Write32(aHeader->mChecksum);
@@ -1317,16 +1437,27 @@
     rv = Write32(aHeader->mFooterOffset);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Write32(aHeader->mFileSize);
     if (NS_FAILED(rv))
         return rv;
 
+#else
+    rv = Write(reinterpret_cast<char*>(aHeader), sizeof *aHeader, &bytesWritten);
+    if (NS_FAILED(rv))
+        return rv;
+
+    if (bytesWritten != sizeof *aHeader) {
+        return NS_ERROR_UNEXPECTED;
+    }
+
+#endif //USE_PACKED_STRUCTS
+
     return NS_OK;
 }
 
 // nsIFastLoadFileControl methods:
 
 NS_IMETHODIMP
 nsFastLoadFileWriter::GetChecksum(PRUint32 *aChecksum)
 {
@@ -1648,16 +1779,17 @@
         return rv;
 
     return NS_OK;
 }
 
 nsresult
 nsFastLoadFileWriter::WriteSlowID(const nsID& aID)
 {
+#ifndef USE_PACKED_STRUCTS
     nsresult rv;
 
     rv = Write32(aID.m0);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Write16(aID.m1);
     if (NS_FAILED(rv))
@@ -1670,28 +1802,42 @@
     PRUint32 bytesWritten;
     rv = Write(reinterpret_cast<const char*>(aID.m3), sizeof aID.m3,
                &bytesWritten);
     if (NS_FAILED(rv))
         return rv;
 
     if (bytesWritten != sizeof aID.m3)
         return NS_ERROR_FAILURE;
+#else
+    nsresult rv;
+    PRUint32 bytesWritten;
+
+    rv = Write((char*)(&aID), sizeof aID, &bytesWritten);
+    if (NS_FAILED(rv))
+        return rv;
+
+    if (bytesWritten != sizeof aID) {
+        return NS_ERROR_UNEXPECTED;
+    }
+#endif //USE_PACKED_STRUCTS
+
     return NS_OK;
 }
 
 nsresult
 nsFastLoadFileWriter::WriteFastID(NSFastLoadID aID)
 {
     return Write32(aID ^ MFL_ID_XOR_KEY);
 }
 
 nsresult
 nsFastLoadFileWriter::WriteSharpObjectInfo(const nsFastLoadSharpObjectInfo& aInfo)
 {
+#ifndef USE_PACKED_STRUCTS
     nsresult rv;
 
     NS_ASSERTION(aInfo.mCIDOffset != 0,
                  "fastload writer: mCIDOffset cannot be zero!");
 
     rv = Write32(aInfo.mCIDOffset);
     if (NS_FAILED(rv))
         return rv;
@@ -1699,16 +1845,33 @@
     rv = Write16(aInfo.mStrongRefCnt);
     if (NS_FAILED(rv))
         return rv;
 
     rv = Write16(aInfo.mWeakRefCnt);
     if (NS_FAILED(rv))
         return rv;
 
+#else
+
+    nsresult rv;
+    PRUint32 bytesWritten;
+
+    NS_ASSERTION(aInfo.mCIDOffset != 0,
+                 "fastload writer: mCIDOffset cannot be zero!");
+
+    rv = Write((char*)(&aInfo), sizeof aInfo, &bytesWritten);
+    if (NS_FAILED(rv))
+        return rv;
+
+    if (bytesWritten != sizeof aInfo) {
+        return NS_ERROR_UNEXPECTED;
+    }
+#endif // USE_PACKED_STRUCTS
+
     return NS_OK;
 }
 
 nsresult
 nsFastLoadFileWriter::WriteMuxedDocumentInfo(const nsFastLoadMuxedDocumentInfo& aInfo)
 {
     nsresult rv;
 
@@ -2044,17 +2207,19 @@
         // mHeader.mChecksum, for GetChecksum.
         seekable = do_QueryInterface(output);
         rv = seekable->Seek(nsISeekableStream::NS_SEEK_SET,
                             offsetof(nsFastLoadHeader, mChecksum));
         if (NS_FAILED(rv))
             return rv;
 
         mHeader.mChecksum = checksum;
+#ifdef ALWAYS_BIG_ENDIAN
         checksum = NS_SWAP32(checksum);
+#endif // ALWAYS_BIG_ENDIAN
         PRUint32 bytesWritten;
         rv = output->Write(reinterpret_cast<char*>(&checksum),
                            sizeof checksum,
                            &bytesWritten);
         if (NS_FAILED(rv))
             return rv;
         if (bytesWritten != sizeof checksum)
             return NS_ERROR_FAILURE;
Index: xpcom/io/nsFastLoadFile.h
===================================================================
--- mozilla/xpcom/io/nsFastLoadFile.h.orig
+++ mozilla/xpcom/io/nsFastLoadFile.h
@@ -183,43 +183,58 @@
 NS_AccumulateFastLoadChecksum(PRUint32 *aChecksum,
                               const PRUint8* aBuffer,
                               PRUint32 aLength,
                               PRBool aLastBuffer);
 
 NS_COM PRUint32
 NS_AddFastLoadChecksums(PRUint32 sum1, PRUint32 sum2, PRUint32 sum2ByteCount);
 
+#define USE_PACKED_STRUCTS
+
 /**
  * Header at the start of a FastLoad file.
  */
 struct nsFastLoadHeader {
     char        mMagic[MFL_FILE_MAGIC_SIZE];
     PRUint32    mChecksum;
     PRUint32    mVersion;
     PRUint32    mFooterOffset;
     PRUint32    mFileSize;
-};
+}
+#ifdef USE_PACKED_STRUCTS
+__attribute__((__packed__))
+#endif
+;
+
 
 /**
  * Footer prefix structure (footer header, ugh), after which come arrays of
  * structures or strings counted by these members.
  */
 struct nsFastLoadFooterPrefix {
     PRUint32    mNumIDs;
     PRUint32    mNumSharpObjects;
     PRUint32    mNumMuxedDocuments;
     PRUint32    mNumDependencies;
-};
+}
+#ifdef USE_PACKED_STRUCTS
+__attribute__((__packed__))
+#endif
+;
 
 struct nsFastLoadSharpObjectInfo {
     PRUint32    mCIDOffset;     // offset of object's NSFastLoadID and data
     PRUint16    mStrongRefCnt;
     PRUint16    mWeakRefCnt;    // high bit is singleton flag, see below
-};
+}
+#ifdef USE_PACKED_STRUCTS
+__attribute__((__packed__))
+#endif
+;
 
 #define MFL_SINGLETON_FLAG          0x8000
 #define MFL_WEAK_REFCNT_MASK        0x7fff
 
 #define MFL_GET_SINGLETON_FLAG(ip)  ((ip)->mWeakRefCnt & MFL_SINGLETON_FLAG)
 #define MFL_GET_WEAK_REFCNT(ip)     ((ip)->mWeakRefCnt & MFL_WEAK_REFCNT_MASK)
 
 #define MFL_SET_SINGLETON_FLAG(ip)                                            \
@@ -380,16 +395,21 @@
 
     nsresult ReadFooter(nsFastLoadFooter *aFooter);
     nsresult ReadFooterPrefix(nsFastLoadFooterPrefix *aFooterPrefix);
     nsresult ReadSlowID(nsID *aID);
     nsresult ReadFastID(NSFastLoadID *aID);
     nsresult ReadSharpObjectInfo(nsFastLoadSharpObjectInfo *aInfo);
     nsresult ReadMuxedDocumentInfo(nsFastLoadMuxedDocumentInfo *aInfo);
     nsresult DeserializeObject(nsISupports* *aObject);
+#ifndef ALWAYS_BIG_ENDIAN
+    nsresult Read32 (PRUint32 * a32);
+    nsresult Read64(PRUint64* a64);
+    nsresult Read16(PRUint16* a16);
+#endif //ALWAYS_BIG_ENDIAN
 
     nsresult   Open();
     NS_IMETHOD Close();
 
   protected:
     // Kept in sync with mInputStream to avoid repeated QI
     nsCOMPtr<nsISeekableStream> mSeekableInput;
 
@@ -472,16 +492,22 @@
     nsresult WriteHeader(nsFastLoadHeader *aHeader);
     nsresult WriteFooter();
     nsresult WriteFooterPrefix(const nsFastLoadFooterPrefix& aFooterPrefix);
     nsresult WriteSlowID(const nsID& aID);
     nsresult WriteFastID(NSFastLoadID aID);
     nsresult WriteSharpObjectInfo(const nsFastLoadSharpObjectInfo& aInfo);
     nsresult WriteMuxedDocumentInfo(const nsFastLoadMuxedDocumentInfo& aInfo);
 
+#ifndef ALWAYS_BIG_ENDIAN
+    nsresult Write16(PRUint16 a16);
+    nsresult Write32(PRUint32 a32);
+    nsresult Write64(PRUint64 a64);
+#endif //ALWAYS_BIG_ENDIAN
+
     nsresult   Init();
     nsresult   Open();
     NS_IMETHOD Close();
 
     nsresult WriteObjectCommon(nsISupports* aObject,
                                PRBool aIsStrongRef,
                                PRUint32 aQITag);
 
Index: xpcom/base/nscore.h
===================================================================
--- mozilla/xpcom/base/nscore.h.orig
+++ mozilla/xpcom/base/nscore.h
@@ -506,9 +506,15 @@
 # define NS_INOUTPARAM __attribute__((user("NS_inoutparam")))
 #else
 # define NS_SCRIPTABLE
 # define NS_INPARAM
 # define NS_OUTPARAM
 # define NS_INOUTPARAM
 #endif
 
+/* Some platforms don't have an implementation of PR_MemMap(). */
+/* See bug 318077 for WinCE.                                   */
+#if !defined(XP_BEOS) && !defined(XP_OS2) && !defined(WINCE)
+#define HAVE_PR_MEMMAP
+#endif
+
 #endif /* nscore_h___ */
Index: content/xul/document/src/nsXULPrototypeCache.cpp
===================================================================
--- mozilla/content/xul/document/src/nsXULPrototypeCache.cpp.orig
+++ mozilla/content/xul/document/src/nsXULPrototypeCache.cpp
@@ -629,22 +629,32 @@
 
 
 NS_IMETHODIMP
 nsXULFastLoadFileIO::GetInputStream(nsIInputStream** aResult)
 {
     if (! mInputStream) {
         nsresult rv;
         nsCOMPtr<nsIInputStream> fileInput;
+
+#ifndef HAVE_PR_MEMMAP
         rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInput), mFile);
         if (NS_FAILED(rv)) return rv;
 
         rv = NS_NewBufferedInputStream(getter_AddRefs(mInputStream),
                                        fileInput,
                                        XUL_DESERIALIZATION_BUFFER_SIZE);
+#else
+        rv = NS_NewMmapFileInputStream(getter_AddRefs(fileInput), mFile);
+        if (NS_FAILED(rv)) return rv;
+
+        rv = NS_NewMmapInputStream(getter_AddRefs(mInputStream),
+                                       fileInput,
+                                       XUL_DESERIALIZATION_BUFFER_SIZE);
+#endif
         if (NS_FAILED(rv)) return rv;
     }
 
     NS_ADDREF(*aResult = mInputStream);
     return NS_OK;
 }
 
 
Index: js/src/xpconnect/loader/mozJSComponentLoader.cpp
===================================================================
--- mozilla/js/src/xpconnect/loader/mozJSComponentLoader.cpp.orig
+++ mozilla/js/src/xpconnect/loader/mozJSComponentLoader.cpp
@@ -86,22 +86,16 @@
 #ifdef MOZ_SHARK
 #include "jsdbgapi.h"
 #endif
 
 static const char kJSRuntimeServiceContractID[] = "@mozilla.org/js/xpc/RuntimeService;1";
 static const char kXPConnectServiceContractID[] = "@mozilla.org/js/xpc/XPConnect;1";
 static const char kObserverServiceContractID[] = "@mozilla.org/observer-service;1";
 
-/* Some platforms don't have an implementation of PR_MemMap(). */
-/* See bug 318077 for WinCE.                                   */
-#if !defined(XP_BEOS) && !defined(XP_OS2) && !defined(WINCE)
-#define HAVE_PR_MEMMAP
-#endif
-
 /**
  * Buffer sizes for serialization and deserialization of scripts.
  * FIXME: bug #411579 (tune this macro!) Last updated: Jan 2008
  */
 #define XPC_SERIALIZATION_BUFFER_SIZE   (64 * 1024)
 #define XPC_DESERIALIZATION_BUFFER_SIZE (12 * 8192)
 
 // Inactivity delay before closing our fastload file stream.
@@ -315,24 +309,37 @@
 
 NS_IMPL_ISUPPORTS1(nsXPCFastLoadIO, nsIFastLoadFileIO)
 
 NS_IMETHODIMP
 nsXPCFastLoadIO::GetInputStream(nsIInputStream **_retval)
 {
     if (! mInputStream) {
         nsCOMPtr<nsIInputStream> fileInput;
+
+#ifndef HAVE_PR_MEMMAP
         nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInput),
                                                  mFile);
         NS_ENSURE_SUCCESS(rv, rv);
 
         rv = NS_NewBufferedInputStream(getter_AddRefs(mInputStream),
                                        fileInput,
                                        XPC_DESERIALIZATION_BUFFER_SIZE);
         NS_ENSURE_SUCCESS(rv, rv);
+#else
+        nsresult rv = NS_NewMmapFileInputStream(getter_AddRefs(fileInput),
+                                                 mFile);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        rv = NS_NewMmapInputStream(getter_AddRefs(mInputStream),
+                                       fileInput,
+                                       XPC_DESERIALIZATION_BUFFER_SIZE);
+        NS_ENSURE_SUCCESS(rv, rv);
+#endif //HAVE_PR_MEMMAP
+
     }
 
     NS_ADDREF(*_retval = mInputStream);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsXPCFastLoadIO::GetOutputStream(nsIOutputStream **_retval)
