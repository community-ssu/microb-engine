# Int reflow bug 67752
Index: mozilla/content/base/public/mozFlushType.h
===================================================================
--- mozilla.orig/content/base/public/mozFlushType.h
+++ mozilla/content/base/public/mozFlushType.h
@@ -43,13 +43,17 @@
  */
 enum mozFlushType {
   Flush_Content          = 1, /* flush the content model construction */
   Flush_ContentAndNotify = 2, /* As above, plus flush the frame model
                                  construction and other nsIMutationObserver
                                  notifications. */
   Flush_Style            = 3, /* As above, plus flush style reresolution */
   Flush_Frames           = Flush_Style,
-  Flush_Layout           = 4, /* As above, plus flush reflow */
-  Flush_Display          = 5  /* As above, plus flush painting */
+  Flush_InterruptibleLayout = 4, /* As above, plus flush reflow,
+                                    but allow it to be interrupted (so
+                                    an incomplete layout may result) */
+  Flush_Layout           = 5, /* As above, but layout must run to
+                                 completion */
+  Flush_Display          = 6  /* As above, plus flush painting */
 };
 
 #endif /* mozFlushType_h___ */
Index: mozilla/content/base/src/nsDocument.cpp
===================================================================
--- mozilla.orig/content/base/src/nsDocument.cpp
+++ mozilla/content/base/src/nsDocument.cpp
@@ -6210,20 +6210,17 @@
   // flush ourselves, then don't flush the parent, since that can cause things
   // like resizes of our frame's widget, which we can't handle while flushing
   // is unsafe.
   // Since media queries mean that a size change of our container can
   // affect style, we need to promote a style flush on ourself to a
   // layout flush on our parent, since we need our container to be the
   // correct size to determine the correct style.
   if (mParentDocument && IsSafeToFlush()) {
-    mozFlushType parentType = aType;
-    if (aType == Flush_Style)
-      parentType = Flush_Layout;
-    mParentDocument->FlushPendingNotifications(parentType);
+    mParentDocument->FlushPendingNotifications(PR_MAX(aType, Flush_Layout));
   }
 
   nsPresShellIterator iter(this);
   nsCOMPtr<nsIPresShell> shell;
   while ((shell = iter.GetNextShell())) {
     shell->FlushPendingNotifications(aType);
   }
 }
Index: mozilla/content/events/src/nsEventStateManager.cpp
===================================================================
--- mozilla.orig/content/events/src/nsEventStateManager.cpp
+++ mozilla/content/events/src/nsEventStateManager.cpp
@@ -5471,17 +5471,17 @@
 }
 
 void
 nsEventStateManager::FlushPendingEvents(nsPresContext* aPresContext)
 {
   NS_PRECONDITION(nsnull != aPresContext, "nsnull ptr");
   nsIPresShell *shell = aPresContext->GetPresShell();
   if (shell) {
-    shell->FlushPendingNotifications(Flush_Display);
+    shell->FlushPendingNotifications(Flush_InterruptibleLayout);
   }
 }
 
 nsresult
 nsEventStateManager::GetDocSelectionLocation(nsIContent **aStartContent,
                                              nsIContent **aEndContent,
                                              nsIFrame **aStartFrame,
                                              PRUint32* aStartOffset)
Index: mozilla/content/html/content/src/nsGenericHTMLElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsGenericHTMLElement.cpp
+++ mozilla/content/html/content/src/nsGenericHTMLElement.cpp
@@ -1317,17 +1317,17 @@
 nsIFormControlFrame*
 nsGenericHTMLElement::GetFormControlFrameFor(nsIContent* aContent,
                                              nsIDocument* aDocument,
                                              PRBool aFlushContent)
 {
   if (aFlushContent) {
     // Cause a flush of content, so we get up-to-date frame
     // information
-    aDocument->FlushPendingNotifications(Flush_Layout);
+    aDocument->FlushPendingNotifications(Flush_Frames);
   }
   nsIFrame* frame = GetPrimaryFrameFor(aContent, aDocument);
   if (frame) {
     nsIFormControlFrame* form_frame = nsnull;
     CallQueryInterface(frame, &form_frame);
     if (form_frame) {
       return form_frame;
     }
Index: mozilla/content/html/document/src/nsHTMLContentSink.cpp
===================================================================
--- mozilla.orig/content/html/document/src/nsHTMLContentSink.cpp
+++ mozilla/content/html/document/src/nsHTMLContentSink.cpp
@@ -3186,17 +3186,17 @@
   // (since we aren't reentrant)
   if (!mInNotification) {
     if (aType >= Flush_ContentAndNotify) {
       FlushTags();
     }
     else if (mCurrentContext) {
       mCurrentContext->FlushText();
     }
-    if (aType >= Flush_Layout) {
+    if (aType >= Flush_InterruptibleLayout) {
       // Make sure that layout has started so that the reflow flush
       // will actually happen.
       StartLayout(PR_TRUE);
     }
   }
 }
 
 nsresult
Index: mozilla/content/xml/document/src/nsXMLContentSink.cpp
===================================================================
--- mozilla.orig/content/xml/document/src/nsXMLContentSink.cpp
+++ mozilla/content/xml/document/src/nsXMLContentSink.cpp
@@ -1615,17 +1615,17 @@
   // (since we aren't reentrant)
   if (!mInNotification) {
     if (aType >= Flush_ContentAndNotify) {
       FlushTags();
     }
     else {
       FlushText(PR_FALSE);
     }
-    if (aType >= Flush_Layout) {
+    if (aType >= Flush_InterruptibleLayout) {
       // Make sure that layout has started so that the reflow flush
       // will actually happen.
       MaybeStartLayout(PR_TRUE);
     }
   }
 }
 
 /**
Index: mozilla/layout/base/nsIPresShell.h
===================================================================
--- mozilla.orig/layout/base/nsIPresShell.h
+++ mozilla/layout/base/nsIPresShell.h
@@ -97,20 +97,20 @@
 class nsWeakFrame;
 class nsIScrollableFrame;
 class gfxASurface;
 class gfxContext;
 
 typedef short SelectionType;
 typedef PRUint32 nsFrameState;
 
-// 5c103bc2-788e-4bbe-b82e-635bea34e78f
+// 4fb87dae-8986-429f-b6ba-f040750e3ee8
 #define NS_IPRESSHELL_IID \
-{ 0x5c103bc2, 0x788e, 0x4bbe, \
-  { 0xb8, 0x2e, 0x63, 0x5b, 0xea, 0x34, 0xe7, 0x8f } }
+  { 0x4fb87dae, 0x8986, 0x429f, \
+    { 0xb6, 0xba, 0xf0, 0x40, 0x75, 0x0e, 0x3e, 0xe8 } }
 
 // Constants for ScrollContentIntoView() function
 #define NS_PRESSHELL_SCROLL_TOP      0
 #define NS_PRESSHELL_SCROLL_BOTTOM   100
 #define NS_PRESSHELL_SCROLL_LEFT     0
 #define NS_PRESSHELL_SCROLL_RIGHT    100
 #define NS_PRESSHELL_SCROLL_CENTER   50
 #define NS_PRESSHELL_SCROLL_ANYWHERE -1
Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -80,16 +80,17 @@
 #include "nsIViewManager.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsStyleChangeList.h"
 #include "nsRuleNode.h"
 #include "nsEventDispatcher.h"
 #include "gfxUserFontSet.h"
 #include "nsIEventListenerManager.h"
+#include "nsIAppShell.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif // IBMBIDI
 
 #include "nsContentUtils.h"
 
 // Needed for Start/Stop of Image Animation
@@ -1689,8 +1690,49 @@
                                           &nsPresContext::FireDOMPaintEvent);
     NS_DispatchToCurrentThread(ev);
   }
 
   nsRegion* r = aIsCrossDoc ? &mCrossDocDirtyRegion : &mSameDocDirtyRegion;
   r->Or(*r, aRect);
   r->SimplifyOutward(10);
 }
+
+#define INTERRUPT_CHECKS_PER_EVENT_LOOP_PEEK 200
+
+static PRBool HavePendingInputEvent()
+{
+  static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
+  nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
+  if (!appShell)
+    return PR_FALSE;
+  PRBool result;
+  appShell->GetHasPendingInputEvent(&result);
+  return result;
+}
+
+void
+nsPresContext::SetInterruptState(PRBool aInterruptible)
+{
+  mInterruptsEnabled = aInterruptible;
+  mHasPendingInterrupt = HavePendingInputEvent();
+  mInterruptChecksToSkip = INTERRUPT_CHECKS_PER_EVENT_LOOP_PEEK;
+}
+
+PRBool
+nsPresContext::CheckForInterrupt()
+{
+  if (mHasPendingInterrupt)
+    return PR_TRUE;
+  if (mInterruptChecksToSkip > 0) {
+    --mInterruptChecksToSkip;
+    return PR_FALSE;
+  }
+  mInterruptChecksToSkip = INTERRUPT_CHECKS_PER_EVENT_LOOP_PEEK;
+  if (!mInterruptsEnabled)
+    return PR_FALSE;
+
+  mHasPendingInterrupt = HavePendingInputEvent();
+  if (mHasPendingInterrupt) {
+    //printf("*** DETECTED pending interrupt (time=%ld)\n", PR_Now());
+  }
+  return mHasPendingInterrupt;
+}
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -745,16 +745,35 @@
   PRInt32          ScreenWidth() const { return mScreenWidth; }
   
   gfxUserFontSet* GetUserFontSet();
   void SetUserFontSet(gfxUserFontSet *aUserFontSet);
 
   void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
   void FireDOMPaintEvent();
 
+  /**
+   * Set the interruptibility of this presContext. If aInterruptible
+   * is false then CheckForInterrupt and HasPendingInterrupt will always
+   * return false. If aInterruptible is true then CheckForInterrupt
+   * will return true when a pending event is detected.
+   */
+  void SetInterruptState(PRBool aInterruptible);
+  /**
+   * Check for interrupts. This may return true if a pending event
+   * is detected. Once it has returned true, it will keep returning true
+   * until SetInterruptState is called again.
+   */
+  PRBool CheckForInterrupt();
+  /**
+   * Returns true if CheckForInterrupt has returned true since the last
+   * SetInterruptState. Cannot itself trigger an interrupt check.
+   */
+  PRBool HasPendingInterrupt() { return mHasPendingInterrupt; }
+
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
   
   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
   NS_HIDDEN_(void) GetDocumentColorPreferences();
 
@@ -846,16 +865,20 @@
   nsFont                mDefaultSerifFont;
   nsFont                mDefaultSansSerifFont;
   nsFont                mDefaultMonospaceFont;
   nsFont                mDefaultCursiveFont;
   nsFont                mDefaultFantasyFont;
 
   nscoord               mBorderWidthTable[3];
 
+  PRUint32              mInterruptChecksToSkip;
+  PRPackedBool          mHasPendingInterrupt;
+  PRPackedBool          mInterruptsEnabled;
+
   unsigned              mUseDocumentFonts : 1;
   unsigned              mUseDocumentColors : 1;
   unsigned              mUnderlineLinks : 1;
   unsigned              mUseFocusColors : 1;
   unsigned              mFocusRingOnAnything : 1;
   unsigned              mFocusRingStyle : 1;
   unsigned              mDrawImageBackground : 1;
   unsigned              mDrawColorBackground : 1;
Index: mozilla/layout/base/nsPresShell.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresShell.cpp
+++ mozilla/layout/base/nsPresShell.cpp
@@ -1028,17 +1028,17 @@
   friend class nsAutoCauseReflowNotifier;
 
   void     WillDoReflow();
   void     DidDoReflow();
   nsresult ProcessReflowCommands(PRBool aInterruptible);
   void     ClearReflowEventStatus();
   void     PostReflowEvent();
   
-  void DoReflow(nsIFrame* aFrame);
+  void DoReflow(nsIFrame* aFrame, PRBool aInterruptible, PRBool* aInterrupted);
 #ifdef DEBUG
   void DoVerifyReflow();
   void VerifyHasDirtyRootAncestor(nsIFrame* aFrame);
 #endif
 
   friend class nsPresShellEventCB;
 
   class ReflowEvent;
@@ -1117,21 +1117,16 @@
   void RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet);
 
   // Hide a view if it is a popup
   void HideViewIfPopup(nsIView* aView);
 
   // Utility method to restore the root scrollframe state
   void RestoreRootScrollPosition();
 
-  // Method to handle actually flushing.  This allows the caller to control
-  // whether the reflow flush (if any) should be interruptible.
-  nsresult DoFlushPendingNotifications(mozFlushType aType,
-                                       PRBool aInterruptibleReflow);
-
   nsCOMPtr<nsICSSStyleSheet> mPrefStyleSheet; // mStyleSet owns it but we
                                               // maintain a ref, may be null
 #ifdef DEBUG
   PRUint32                  mUpdateCount;
 #endif
   // reflow roots that need to be reflowed, as both a queue and a hashtable
   nsVoidArray mDirtyRoots;
 
@@ -1160,16 +1155,18 @@
   StackArena                    mStackArena;
   nsCOMPtr<nsIDragService>      mDragService;
   
   nsRevocableEventPtr<ReflowEvent> mReflowEvent;
 
   nsCallbackEventRequest* mFirstCallbackEventRequest;
   nsCallbackEventRequest* mLastCallbackEventRequest;
 
+  PRPackedBool      mSuppressInterruptibleReflows;
+
   PRPackedBool      mIsThemeSupportDisabled;  // Whether or not form controls should use nsITheme in this shell.
 
   PRPackedBool      mIsDocumentGone;      // We've been disconnected from the document.
   PRPackedBool      mPaintingSuppressed;  // For all documents we initially lock down painting.
                                           // We will refuse to paint the document until either
                                           // (a) our timer fires or (b) all frames are constructed.
   PRPackedBool      mShouldUnsuppressPainting;  // Indicates that it is safe to unlock painting once all pending
                                                 // reflows have been processed.
@@ -2558,21 +2555,20 @@
       // the way don't have region accumulation issues?
 
       {
         nsAutoCauseReflowNotifier crNotifier(this);
         WillDoReflow();
 
         // Kick off a top-down reflow
         AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
-        mIsReflowing = PR_TRUE;
 
         mDirtyRoots.RemoveElement(rootFrame);
-        DoReflow(rootFrame);
-        mIsReflowing = PR_FALSE;
+        PRBool interrupted;
+        DoReflow(rootFrame, PR_TRUE, &interrupted);
       }
 
       DidDoReflow();
     }
 
     batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
   }
 
@@ -3174,17 +3170,18 @@
                 "reflowed?");
 }
 #endif
 
 NS_IMETHODIMP
 PresShell::FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
                             nsFrameState aBitToAdd)
 {
-  NS_PRECONDITION(aBitToAdd == NS_FRAME_IS_DIRTY ||
+  NS_PRECONDITION(aBitToAdd == 0 ||
+                  aBitToAdd == NS_FRAME_IS_DIRTY ||
                   aBitToAdd == NS_FRAME_HAS_DIRTY_CHILDREN,
                   "Unexpected bits being added");
 
   NS_ASSERTION(!mIsReflowing, "can't mark frame dirty during reflow");
 
   // If we've not yet done the initial reflow, then don't bother
   // enqueuing a reflow command yet.
   if (! mDidInitialReflow)
@@ -3210,16 +3207,18 @@
       }
     }
   }  
 #endif
 
   // Grab |wasDirty| now so we can go ahead and update the bits on aFrame.
   PRBool wasDirty = NS_SUBTREE_DIRTY(aFrame);
   aFrame->AddStateBits(aBitToAdd);
+  NS_ASSERTION(aFrame->GetStateBits() & (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN),
+               "Frame should be dirty now!");
 
   // Now if aFrame is a reflow root we can cut off this reflow at it if the bit
   // being added is NS_FRAME_HAS_DIRTY_CHILDREN.
   PRBool targetFrameDirty = (aBitToAdd == NS_FRAME_IS_DIRTY);
 
 #define FRAME_IS_REFLOW_ROOT(_f)                   \
   ((_f->GetStateBits() & NS_FRAME_REFLOW_ROOT) &&  \
    (_f != aFrame || !targetFrameDirty))
@@ -3973,17 +3972,17 @@
 PresShell::ScrollContentIntoView(nsIContent* aContent,
                                  PRIntn      aVPercent,
                                  PRIntn      aHPercent) const
 {
   nsCOMPtr<nsIContent> content = aContent; // Keep content alive while flushing.
   NS_ENSURE_TRUE(content, NS_ERROR_NULL_POINTER);
   nsCOMPtr<nsIDocument> currentDoc = content->GetCurrentDoc();
   NS_ENSURE_STATE(currentDoc);
-  currentDoc->FlushPendingNotifications(Flush_Layout);
+  currentDoc->FlushPendingNotifications(Flush_InterruptibleLayout);
   nsIFrame* frame = GetPrimaryFrameFor(content);
   if (!frame) {
     return NS_ERROR_NULL_POINTER;
   }
 
   // Before we scroll the frame into view, ask the command dispatcher
   // if we're resetting focus because a window just got an activate
   // event. If we are, we do not want to scroll the frame into view.
@@ -4466,17 +4465,17 @@
      if (callback) {
        if (callback->ReflowFinished()) {
          shouldFlush = PR_TRUE;
        }
      }
    }
 
    if (shouldFlush)
-     FlushPendingNotifications(Flush_Layout);
+     FlushPendingNotifications(Flush_InterruptibleLayout);
 }
 
 NS_IMETHODIMP 
 PresShell::IsSafeToFlush(PRBool& aIsSafeToFlush)
 {
   // XXX technically we don't need to check anything but
   // nsContentUtils::IsSafeToRunScript here since that should be false
   // if any of the other flags are set.
@@ -4499,26 +4498,19 @@
 
   NS_ASSERTION(aIsSafeToFlush == nsContentUtils::IsSafeToRunScript(),
                "Someone forgot to block scripts");
 
   return NS_OK;
 }
 
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 PresShell::FlushPendingNotifications(mozFlushType aType)
 {
-  return DoFlushPendingNotifications(aType, PR_FALSE);
-}
-
-nsresult
-PresShell::DoFlushPendingNotifications(mozFlushType aType,
-                                       PRBool aInterruptibleReflow)
-{
   NS_ASSERTION(aType >= Flush_Frames, "Why did we get called?");
   
   PRBool isSafeToFlush;
   IsSafeToFlush(isSafeToFlush);
 
   NS_ASSERTION(!isSafeToFlush || mViewManager, "Must have view manager");
   // Make sure the view manager stays alive while batching view updates.
   nsCOMPtr<nsIViewManager> viewManagerDeathGrip = mViewManager;
@@ -4561,21 +4553,22 @@
     // the frame type.
     if (!mIsDestroying) {
       mFrameConstructor->ProcessPendingRestyles();
     }
 
     // There might be more pending constructors now, but we're not going to
     // worry about them.  They can't be triggered during reflow, so we should
     // be good.
-    
-    if (aType >= Flush_Layout && !mIsDestroying) {
+
+    if (aType >= (mSuppressInterruptibleReflows ? Flush_Layout : Flush_InterruptibleLayout) &&
+        !mIsDestroying) {
       mFrameConstructor->RecalcQuotesAndCounters();
       mViewManager->FlushDelayedResize();
-      ProcessReflowCommands(aInterruptibleReflow);
+      ProcessReflowCommands(aType < Flush_Layout);
     }
 
     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
     if (aType >= Flush_Display) {
       // Flushing paints, so perform the invalidates and drawing
       // immediately
       updateFlags = NS_VMREFRESH_IMMEDIATE;
     }
@@ -6017,17 +6010,17 @@
   if (mIsReflowing || mChangeNestCount || mPaintingSuppressed) {
     return;
   }
   
   // Process reflows, if we have them, to reduce flicker due to invalidates and
   // reflow being interspersed.  Note that we _do_ allow this to be
   // interruptible; if we can't do all the reflows it's better to flicker a bit
   // than to freeze up.
-  DoFlushPendingNotifications(Flush_Layout, PR_TRUE);
+  FlushPendingNotifications(Flush_InterruptibleLayout);
 }
 
 nsresult
 PresShell::GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets)
 {
   aSheets.Clear();
   PRInt32 sheetCount = mStyleSet->SheetCount(nsStyleSet::eAgentSheet);
 
@@ -6182,18 +6175,21 @@
     }
 #endif
     // NOTE: the ReflowEvent class is a friend of the PresShell class
     ps->ClearReflowEventStatus();
     // Set a kung fu death grip on the view manager associated with the pres shell
     // before processing that pres shell's reflow commands.  Fixes bug 54868.
     nsCOMPtr<nsIViewManager> viewManager = ps->GetViewManager();
 
-    ps->DoFlushPendingNotifications(Flush_Layout, PR_TRUE);
+    ps->mSuppressInterruptibleReflows = PR_FALSE;
+    //printf("*** Entering reflow event (time=%ld)\n", PR_Now());
+    ps->FlushPendingNotifications(Flush_InterruptibleLayout);
 
+    //printf("*** Returning from reflow event (time=%ld)\n", PR_Now());
     // Now, explicitly release the pres shell before the view manager
     ps = nsnull;
     viewManager = nsnull;
   }
   return NS_OK;
 }
 
 //-------------- End Reflow Event Definition ---------------------------
@@ -6264,18 +6260,20 @@
     // Update the caret's position now to account for any changes created by
     // the reflow.
     mCaret->InvalidateOutsideCaret();
     mCaret->UpdateCaretPosition();
   }
 }
 
 void
-PresShell::DoReflow(nsIFrame* target)
+PresShell::DoReflow(nsIFrame* target, PRBool aInterruptible, PRBool* aInterrupted)
 {
+  *aInterrupted = PR_FALSE;
+
   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
 
   nsCOMPtr<nsIRenderingContext> rcx;
   // Always create the rendering context relative to the root frame during
   // reflow; otherwise, it crashes on the mac (I'm not quite sure why)
   nsresult rv = CreateRenderingContext(rootFrame, getter_AddRefs(rcx));
   if (NS_FAILED(rv)) {
    NS_NOTREACHED("CreateRenderingContext failure");
@@ -6315,16 +6313,19 @@
     computedHeight = PR_MAX(computedHeight, 0);
     reflowState.SetComputedHeight(computedHeight);
   }
   NS_ASSERTION(reflowState.ComputedWidth() ==
                  size.width -
                    reflowState.mComputedBorderPadding.LeftRight(),
                "reflow state computed incorrect width");
 
+  mPresContext->SetInterruptState(aInterruptible);
+  mIsReflowing = PR_TRUE;
+
   nsReflowStatus status;
   nsHTMLReflowMetrics desiredSize;
   target->Reflow(mPresContext, desiredSize, reflowState, status);
 
   // If an incremental reflow is initiated at a frame other than the
   // root frame, then its desired size had better not change!  If it's
   // initiated at the root, then the size better not change unless its
   // height was unconstrained to start with.
@@ -6346,16 +6347,31 @@
                                              target->GetView(),
                                              &desiredSize.mOverflowArea);
 
   target->DidReflow(mPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
   if (target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) {
     mPresContext->SetVisibleArea(nsRect(0, 0, desiredSize.width,
                                         desiredSize.height));
   }
+
+  mIsReflowing = PR_FALSE;
+  if (mPresContext->HasPendingInterrupt()) {
+    *aInterrupted = PR_TRUE;
+    // Make sure target gets reflowed again.
+    // target->DidReflow will not have cleared the dirty bits, so we
+    // don't need to set any here.
+    mDirtyRoots.AppendElement(target);
+    // Any FlushPendingNotifications with interruptible reflows
+    // should be suppressed now. We don't want to do extra reflow work
+    // before our reflow event happens.
+    mSuppressInterruptibleReflows = PR_TRUE;
+    PostReflowEvent();
+  }
+  mPresContext->SetInterruptState(PR_FALSE);
 }
 
 #ifdef DEBUG
 void
 PresShell::DoVerifyReflow()
 {
   if (nsIFrameDebug::GetVerifyTreeEnable()) {
     nsIFrameDebug*  frameDebug;
@@ -6408,42 +6424,40 @@
     const PRIntervalTime deadline = aInterruptible
         ? PR_IntervalNow() + PR_MicrosecondsToInterval(gMaxRCProcessingTime)
         : (PRIntervalTime)0;
 
     // Scope for the reflow entry point
     {
       nsAutoScriptBlocker scriptBlocker;
       AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
-      mIsReflowing = PR_TRUE;
 
+      PRBool interrupted = PR_FALSE;
       do {
         // Send an incremental reflow notification to the target frame.
         PRInt32 idx = mDirtyRoots.Count() - 1;
         nsIFrame *target = static_cast<nsIFrame*>(mDirtyRoots[idx]);
         mDirtyRoots.RemoveElementAt(idx);
 
         if (!NS_SUBTREE_DIRTY(target)) {
           // It's not dirty anymore, which probably means the notification
           // was posted in the middle of a reflow (perhaps with a reflow
           // root in the middle).  Don't do anything.
           continue;
         }
 
-        DoReflow(target);
+        DoReflow(target, aInterruptible, &interrupted);
 
         // Keep going until we're out of reflow commands, or we've run
-        // past our deadline.
-      } while (mDirtyRoots.Count() &&
+        // past our deadline, or we're interrupted.
+      } while (!interrupted && mDirtyRoots.Count() &&
                (!aInterruptible || PR_IntervalNow() < deadline));
 
       // XXXwaterson for interruptible reflow, examine the tree and
       // re-enqueue any unflowed reflow targets.
-
-      mIsReflowing = PR_FALSE;
     }
 
     // Exiting the scriptblocker might have killed us
     if (!mIsDestroying) {
       DidDoReflow();
     }
 
     // DidDoReflow might have killed us
Index: mozilla/layout/generic/nsBlockFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsBlockFrame.cpp
+++ mozilla/layout/generic/nsBlockFrame.cpp
@@ -1145,17 +1145,18 @@
   // XXX checking oldSize is bogus, there are various reasons we might have
   // reflowed but our size might not have been changed to what we
   // asked for (e.g., we ended up being pushed to a new page)
   // When WillReflowAgainForClearance is true, we will reflow again without
   // resetting the size. Because of this, we must not reflow our abs-pos children
   // in that situation --- what we think is our "new size"
   // will not be our real new size. This also happens to be more efficient.
   if (mAbsoluteContainer.HasAbsoluteFrames()) {
-    if (aReflowState.WillReflowAgainForClearance()) {
+    if (aReflowState.WillReflowAgainForClearance() ||
+        aPresContext->HasPendingInterrupt()) {
       // Make sure that when we reflow again we'll actually reflow all the abs
       // pos frames that might conceivably depend on our size.  Sadly, we can't
       // do much better than that, because we don't really know what our size
       // will be, and it might in fact not change on the followup reflow!
       mAbsoluteContainer.MarkSizeDependentFramesDirty();
     } else {
       nsRect childBounds;
       nsSize containingBlockSize =
@@ -2018,16 +2019,21 @@
       inlineFloatBreakType = line->GetBreakTypeAfter();
     }
 
     if (LineHasClear(line.get())) {
       foundAnyClears = PR_TRUE;
     }
 
     DumpLine(aState, line, deltaY, -1);
+
+    if (aState.mPresContext->CheckForInterrupt()) {
+      line->MarkDirty();
+      willReflowAgain = PR_TRUE;
+    }
   }
 
   // Handle BR-clearance from the last line of the block
   if (inlineFloatBreakType != NS_STYLE_CLEAR_NONE) {
     aState.mY = aState.ClearFloats(aState.mY, inlineFloatBreakType);
   }
 
   if (needToRecoverState) {
Index: mozilla/layout/generic/nsFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsFrame.cpp
+++ mozilla/layout/generic/nsFrame.cpp
@@ -3300,18 +3300,21 @@
 NS_IMETHODIMP
 nsFrame::DidReflow(nsPresContext*           aPresContext,
                    const nsHTMLReflowState*  aReflowState,
                    nsDidReflowStatus         aStatus)
 {
   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
                      ("nsFrame::DidReflow: aStatus=%d", aStatus));
   if (NS_FRAME_REFLOW_FINISHED == aStatus) {
-    mState &= ~(NS_FRAME_IN_REFLOW | NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
-                NS_FRAME_HAS_DIRTY_CHILDREN);
+    PRUint32 bitsToClear = NS_FRAME_IN_REFLOW | NS_FRAME_FIRST_REFLOW;
+    if (!aPresContext->HasPendingInterrupt()) {
+      bitsToClear |= NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN;
+    }
+    mState &= ~bitsToClear;
   }
 
   // Notify the percent height observer if there is a percent height.
   // The observer may be able to initiate another reflow with a computed
   // height. This happens in the case where a table cell has no computed
   // height but can fabricate one when the cell height is known.
   if (aReflowState && aReflowState->mPercentHeightObserver &&
       (eStyleUnit_Percent == aReflowState->mStylePosition->mHeight.GetUnit())) {
Index: mozilla/layout/generic/nsGfxScrollFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsGfxScrollFrame.cpp
+++ mozilla/layout/generic/nsGfxScrollFrame.cpp
@@ -1962,17 +1962,17 @@
   }
 }
 
 NS_IMETHODIMP
 nsGfxScrollFrameInner::AsyncScrollPortEvent::Run()
 {
   if (mInner) {
     mInner->mOuter->PresContext()->GetPresShell()->
-      FlushPendingNotifications(Flush_Layout);
+      FlushPendingNotifications(Flush_InterruptibleLayout);
   }
   return mInner ? mInner->FireScrollPortEvent() : NS_OK;
 }
 
 PRBool
 nsXULScrollFrame::AddHorizontalScrollbar(nsBoxLayoutState& aState,
                                          nsRect& aScrollAreaSize, PRBool aOnTop)
 {
Index: mozilla/layout/tables/nsTableFrame.cpp
===================================================================
--- mozilla.orig/layout/tables/nsTableFrame.cpp
+++ mozilla/layout/tables/nsTableFrame.cpp
@@ -4716,21 +4716,21 @@
 
   const nsStyleBorder* oldStyleData = static_cast<const nsStyleBorder*>
                         (aOldStyleContext->PeekStyleData(eStyleStruct_Border));
   if (!oldStyleData)
     return PR_FALSE;
 
   const nsStyleBorder* newStyleData = aNewStyleContext->GetStyleBorder();
   nsChangeHint change = newStyleData->CalcDifference(*oldStyleData);
-  if (change == NS_STYLE_HINT_NONE)
+  if (!change)
     return PR_FALSE;
-  if ((change & NS_STYLE_HINT_REFLOW) == NS_STYLE_HINT_REFLOW)
+  if (change & nsChangeHint_ReflowFrame)
     return PR_TRUE; // the caller only needs to mark the bc damage area
-  if ((change & NS_STYLE_HINT_VISUAL) == NS_STYLE_HINT_VISUAL) {
+  if (change & nsChangeHint_RepaintFrame) {
     // we need to recompute the borders and the caller needs to mark
     // the bc damage area
     // XXX In principle this should only be necessary for border style changes
     // However the bc painting code tries to maximize the drawn border segments
     // so it stores in the cellmap where a new border segment starts and this
     // introduces a unwanted cellmap data dependence on color
     nsCOMPtr<nsIRunnable> evt = new nsDelayedCalcBCBorders(this);
     NS_DispatchToCurrentThread(evt);
Index: mozilla/widget/public/nsIAppShell.idl
===================================================================
--- mozilla.orig/widget/public/nsIAppShell.idl
+++ mozilla/widget/public/nsIAppShell.idl
@@ -98,12 +98,22 @@
   void resumeNative();
 
   /**
    * Will call DoNextNativeEvent for proceeding native event loop
    */
   void wakeupNative(in boolean mayWait);
 
   /**
+   * Check if there is any input pending to any window for this application.
+   * (If there is, we probably want to return to the event loop as
+   * soon as possible.) "Input" should include keypresses and
+   * mouse button up/down, and mouse moves with a button down, but
+   * not mouse moves with no button down.
+   * This should be cheap but we try not to call it too often.
+   */
+  readonly attribute boolean hasPendingInputEvent;
+
+  /**
    * The current event loop nesting level.
    */
   readonly attribute unsigned long eventloopNestingLevel;
 };
Index: mozilla/widget/public/nsIWidget.h
===================================================================
--- mozilla.orig/widget/public/nsIWidget.h
+++ mozilla/widget/public/nsIWidget.h
@@ -88,20 +88,20 @@
 #define NS_NATIVE_PLUGIN_PORT 8
 #define NS_NATIVE_SCREEN      9
 #define NS_NATIVE_SHELLWIDGET 10      // Get the shell GtkWidget
 #ifdef XP_MACOSX
 #define NS_NATIVE_PLUGIN_PORT_QD    100
 #define NS_NATIVE_PLUGIN_PORT_CG    101
 #endif
 
-// 7E01D11D-DAFC-4A5E-8C0A-7442A2E17252
+// 0b019a9e-d552-4d5b-8b87-6bdb05f0732a
 #define NS_IWIDGET_IID \
-{ 0x7E01D11D, 0xDAFC, 0x4A5E, \
-  { 0x8C, 0x0A, 0x74, 0x42, 0xA2, 0xE1, 0x72, 0x52 } }
+  { 0x0b019a9e, 0xd552, 0x4d5b, \
+    { 0x8b, 0x87, 0x6b, 0xdb, 0x05, 0xf0, 0x73, 0x2a } }
 
 // Hide the native window systems real window type so as to avoid
 // including native window system types and APIs. This is necessary
 // to ensure cross-platform code.
 typedef void* nsNativeWidget;
 
 /*
  * Window shadow styles
@@ -1235,16 +1235,19 @@
      * NS_VK_SCROLL_LOCK.
      * aLEDState is the result for current LED state of the key.
      * If the LED is 'ON', it returns TRUE, otherwise, FALSE.
      * If the platform doesn't support the LED state (or we cannot get the
      * state), this method returns NS_ERROR_NOT_IMPLEMENTED.
      */
     NS_IMETHOD GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState) = 0;
 
+    virtual void ResetAppInputPendingState() {}
+    virtual PRBool IsAppInputPending() { return PR_FALSE; }
+
 protected:
     // keep the list of children.  We also keep track of our siblings.
     // The ownership model is as follows: parent holds a strong ref to
     // the first element of the list, and each element holds a strong
     // ref to the next element in the list.  The prevsibling and
     // lastchild pointers are weak, which is fine as long as they are
     // maintained properly.
     nsCOMPtr<nsIWidget> mFirstChild;
Index: mozilla/widget/src/cocoa/nsAppShell.h
===================================================================
--- mozilla.orig/widget/src/cocoa/nsAppShell.h
+++ mozilla/widget/src/cocoa/nsAppShell.h
@@ -77,16 +77,18 @@
 
   NS_IMETHOD Run(void);
   NS_IMETHOD Exit(void);
   NS_IMETHOD OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,
                                 PRUint32 aRecursionDepth);
   NS_IMETHOD AfterProcessNextEvent(nsIThreadInternal *aThread,
                                    PRUint32 aRecursionDepth);
 
+  NS_IMETHOD GetHasPendingInputEvent(PRBool *aResult);
+
   // public only to be visible to Objective-C code that must call it
   void WillTerminate();
 
 protected:
   virtual ~nsAppShell();
 
   virtual void ScheduleNativeEventCallback();
   virtual PRBool ProcessNextNativeEvent(PRBool aMayWait);
@@ -104,23 +106,16 @@
   CFRunLoopSourceRef mCFRunLoopSource;
 
   PRPackedBool       mRunningEventLoop;
   PRPackedBool       mStarted;
   PRPackedBool       mTerminated;
   PRPackedBool       mNotifiedWillTerminate;
   PRPackedBool       mSkippedNativeCallback;
 
-  // mHadMoreEventsCount and kHadMoreEventsCountMax are used in
-  // ProcessNextNativeEvent().
-  PRUint32               mHadMoreEventsCount;
-  // Setting kHadMoreEventsCountMax to '10' contributed to a fairly large
-  // (about 10%) increase in the number of calls to malloc (though without
-  // effecting the total amount of memory used).  Cutting it to '3'
-  // reduced the number of calls by 6%-7% (reducing the original regression
-  // to 3%-4%).  See bmo bug 395397.
-  static const PRUint32  kHadMoreEventsCountMax = 3;
+  // Used by GetHasPendingInputEvent
+  PRIntervalTime     mLastNativeEventTime;
 
   PRInt32            mRecursionDepth;
   PRInt32            mNativeEventCallbackDepth;
 };
 
 #endif // nsAppShell_h_
Index: mozilla/widget/src/cocoa/nsAppShell.mm
===================================================================
--- mozilla.orig/widget/src/cocoa/nsAppShell.mm
+++ mozilla/widget/src/cocoa/nsAppShell.mm
@@ -36,16 +36,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 /*
  * Runs the main native Cocoa run loop, interrupting it as needed to process
  * Gecko events.
  */
 
 #import <Cocoa/Cocoa.h>
+#include "ApplicationServices/ApplicationServices.h"
 
 #include "nsAppShell.h"
 #include "nsCOMPtr.h"
 #include "nsIFile.h"
 #include "nsDirectoryServiceDefs.h"
 #include "nsString.h"
 #include "nsIRollupListener.h"
 #include "nsIWidget.h"
@@ -170,17 +171,17 @@
 , mDelegate(nsnull)
 , mCFRunLoop(NULL)
 , mCFRunLoopSource(NULL)
 , mRunningEventLoop(PR_FALSE)
 , mStarted(PR_FALSE)
 , mTerminated(PR_FALSE)
 , mNotifiedWillTerminate(PR_FALSE)
 , mSkippedNativeCallback(PR_FALSE)
-, mHadMoreEventsCount(0)
+, mLastNativeEventTime(0)
 , mRecursionDepth(0)
 , mNativeEventCallbackDepth(0)
 {
   // mMainPool sits low on the autorelease pool stack to serve as a catch-all
   // for autoreleased objects on this thread.  Because it won't be popped
   // until the appshell is destroyed, objects attached to this pool will
   // be leaked until app shutdown.  You probably don't want this!
   //
@@ -465,27 +466,20 @@
 
 // ProcessNextNativeEvent
 //
 // If aMayWait is false, process a single native event.  If it is true, run
 // the native run loop until stopped by ProcessGeckoEvents.
 //
 // Returns true if more events are waiting in the native event queue.
 //
-// But (now that we're using [NSRunLoop runMode:beforeDate:]) it's too
-// expensive to call ProcessNextNativeEvent() many times in a row (in a
-// tight loop), so we never return true more than kHadMoreEventsCountMax
-// times in a row.  This doesn't seem to cause native event starvation.
-//
 // protected virtual
 PRBool
 nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)
 {
-  PRBool moreEvents = PR_FALSE;
-
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   PRBool eventProcessed = PR_FALSE;
   NSString* currentMode = nil;
 
   if (mTerminated)
     return PR_FALSE;
 
@@ -511,25 +505,16 @@
     // demand (via ProcessGeckoEvents()), as opposed to processing Gecko
     // events in a tight loop (via nsBaseAppShell::Run()):  Particularly in
     // Camino, mouse-down events sometimes got dropped (or mis-handled), so
     // that (for example) you sometimes needed to click more than once on a
     // button to make it work (the zoom button was particularly susceptible).
     // You also sometimes had to ctrl-click or right-click multiple times to
     // bring up a context menu.)
 
-    // Now that we're using [NSRunLoop runMode:beforeDate:], it's too
-    // expensive to call ProcessNextNativeEvent() many times in a row, so we
-    // never return true more than kHadMoreEventsCountMax in a row.  I'm not
-    // entirely sure why [NSRunLoop runMode:beforeDate:] is too expensive,
-    // since it and its cousin [NSRunLoop acceptInputForMode:beforeDate:] are
-    // designed to be called in a tight loop.  Possibly the problem is due to
-    // combining [NSRunLoop runMode:beforeDate] with [NSApp
-    // nextEventMatchingMask:...].
-
     // We special-case timer events (events of type NSPeriodic) to avoid
     // starving them.  Apple's documentation is very scanty, and it's now
     // more scanty than it used to be.  But it appears that [NSRunLoop
     // acceptInputForMode:beforeDate:] doesn't process timer events at all,
     // that it is called from [NSRunLoop runMode:beforeDate:], and that
     // [NSRunLoop runMode:beforeDate:], though it does process timer events,
     // doesn't return after doing so.  To get around this, when aWait is
     // PR_FALSE we check for timer events and process them using [NSApp
@@ -544,16 +529,18 @@
     // If the current mode is something else than NSDefaultRunLoopMode, look
     // for events in that mode.
     currentMode = [currentRunLoop currentMode];
     if (!currentMode)
       currentMode = NSDefaultRunLoopMode;
 
     NSEvent* nextEvent = nil;
 
+    mLastNativeEventTime = PR_IntervalNow();
+
     // If we're running modal (or not in a Gecko "main" event loop) we still
     // need to use nextEventMatchingMask and sendEvent -- otherwise (in
     // Minefield) the modal window (or non-main event loop) won't receive key
     // events or most mouse events.
     if ([NSApp _isRunningModal] || !InGeckoMainEventLoop()) {
       if ((nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask
                                           untilDate:waitUntil
                                              inMode:currentMode
@@ -613,36 +600,28 @@
         } else {
           [currentRunLoop runMode:currentMode beforeDate:waitUntil];
         }
         eventProcessed = PR_TRUE;
       }
     }
   } while (mRunningEventLoop);
 
-  if (eventProcessed && (mHadMoreEventsCount < kHadMoreEventsCountMax)) {
-    moreEvents = ([NSApp nextEventMatchingMask:NSAnyEventMask
-                                     untilDate:nil
-                                        inMode:currentMode
-                                       dequeue:NO] != nil);
-  }
-
-  if (moreEvents) {
-    // Once this reaches kHadMoreEventsCountMax, it will be reset to 0 the
-    // next time through (whether or not we process any events then).
-    ++mHadMoreEventsCount;
-  } else {
-    mHadMoreEventsCount = 0;
-  }
-
   mRunningEventLoop = wasRunningEventLoop;
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 
-  return moreEvents;
+  return PR_FALSE;
+}
+
+NS_IMETHODIMP
+nsAppShell::GetHasPendingInputEvent(PRBool *aResult)
+{
+  *aResult = PR_IntervalToMilliseconds(PR_IntervalNow() - mLastNativeEventTime) > 500;
+  return NS_OK;
 }
 
 // Returns PR_TRUE if Gecko events are currently being processed in its "main"
 // event loop (or one of its "main" event loops).  Returns PR_FALSE if Gecko
 // events are being processed in a "nested" event loop, or if we're not
 // running in any sort of Gecko event loop.  How we process native events in
 // ProcessNextNativeEvent() turns on our decision (and if we make the wrong
 // choice, the result may be a hang).
Index: mozilla/widget/src/cocoa/nsChildView.h
===================================================================
--- mozilla.orig/widget/src/cocoa/nsChildView.h
+++ mozilla/widget/src/cocoa/nsChildView.h
@@ -422,17 +422,18 @@
 #ifdef ACCESSIBILITY
   void              GetDocumentAccessible(nsIAccessible** aAccessible);
 #endif
 
   virtual gfxASurface* GetThebesSurface();
 
   NS_IMETHOD BeginSecureKeyboardInput();
   NS_IMETHOD EndSecureKeyboardInput();
-
+  void              ResetAppInputPendingState();
+  PRBool            IsAppInputPending();
   void              HidePlugin();
 
 protected:
 
   PRBool            ReportDestroyEvent();
   PRBool            ReportMoveEvent();
   PRBool            ReportSizeEvent();
 
Index: mozilla/widget/src/cocoa/nsChildView.mm
===================================================================
--- mozilla.orig/widget/src/cocoa/nsChildView.mm
+++ mozilla/widget/src/cocoa/nsChildView.mm
@@ -76,16 +76,18 @@
 
 #include "nsIDOMSimpleGestureEvent.h"
 
 #include "gfxContext.h"
 #include "gfxQuartzSurface.h"
 
 #include <dlfcn.h>
 
+#include "ApplicationServices/ApplicationServices.h"
+
 #undef DEBUG_IME
 #undef DEBUG_UPDATE
 #undef INVALIDATE_DEBUGGING  // flash areas as they are invalidated
 
 #ifdef MOZ_LOGGING
 #define FORCE_PR_LOG
 #endif
 #include "prlog.h"
@@ -2289,17 +2291,16 @@
   }
   PRUint32 modifierFlags = ::GetCurrentEventKeyModifiers();
   *aLEDState = (modifierFlags & key) != 0;
   return NS_OK;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
-
 #pragma mark -
 
 
 gfxASurface*
 nsChildView::GetThebesSurface()
 {
   if (!mTempThebesSurface) {
     mTempThebesSurface = new gfxQuartzSurface(gfxSize(1, 1), gfxASurface::ImageFormatARGB32);
@@ -2331,16 +2332,29 @@
   nsresult rv = nsBaseWidget::EndSecureKeyboardInput();
   if (NS_SUCCEEDED(rv))
     ::DisableSecureEventInput();
   return rv;
 
   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
 
+static PRUint32 gEventCount;
+
+void nsChildView::ResetAppInputPendingState()
+{
+  gEventCount = CGEventSourceCounterForEventType(
+    kCGEventSourceStateCombinedSessionState, kCGAnyInputEventType);
+}
+
+PRBool nsChildView::IsAppInputPending()
+{
+  return gEventCount != CGEventSourceCounterForEventType(
+    kCGEventSourceStateCombinedSessionState, kCGAnyInputEventType);
+}
 
 #ifdef ACCESSIBILITY
 void
 nsChildView::GetDocumentAccessible(nsIAccessible** aAccessible)
 {
   *aAccessible = nsnull;
   
   nsCOMPtr<nsIAccessible> accessible = do_QueryReferent(mAccessible);
Index: mozilla/widget/src/gtk2/nsAppShell.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsAppShell.cpp
+++ mozilla/widget/src/gtk2/nsAppShell.cpp
@@ -36,16 +36,19 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include <sys/types.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <gdk/gdkwindow.h>
+#ifdef MOZ_X11
+#include <gdk/gdkx.h>
+#endif
 #include "nsAppShell.h"
 #include "nsWindow.h"
 #include "prlog.h"
 #include "prenv.h"
 
 #define NOTIFY_TOKEN 0xFA
 
 #ifdef PR_LOGGING
@@ -155,8 +158,15 @@
     write(mPipeFDs[1], buf, 1);
 }
 
 PRBool
 nsAppShell::ProcessNextNativeEvent(PRBool mayWait)
 {
     return g_main_context_iteration(NULL, mayWait);
 }
+
+NS_IMETHODIMP
+nsAppShell::GetHasPendingInputEvent(PRBool *aResult)
+{
+    *aResult = gdk_events_pending();
+    return NS_OK;
+}
Index: mozilla/widget/src/gtk2/nsAppShell.h
===================================================================
--- mozilla.orig/widget/src/gtk2/nsAppShell.h
+++ mozilla/widget/src/gtk2/nsAppShell.h
@@ -37,30 +37,33 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsAppShell_h__
 #define nsAppShell_h__
 
 #include <glib.h>
 #include "nsBaseAppShell.h"
 #include "nsCOMPtr.h"
+#include "prinrval.h"
 
 class nsAppShell : public nsBaseAppShell {
 public:
     NS_IMETHODIMP ResumeNative(void);
 
     nsAppShell() : mTag(0), mSkippedNativeCallback(PR_FALSE) {
         mPipeFDs[0] = mPipeFDs[1] = 0;
     }
 
     // nsBaseAppShell overrides:
     nsresult Init();
     virtual void ScheduleNativeEventCallback();
     virtual PRBool ProcessNextNativeEvent(PRBool mayWait);
 
+    NS_IMETHOD GetHasPendingInputEvent(PRBool *aResult);
+
 private:
     virtual ~nsAppShell();
 
     static gboolean EventProcessorCallback(GIOChannel *source,
                                            GIOCondition condition,
                                            gpointer data);
 
     int mPipeFDs[2];
Index: mozilla/widget/src/xpwidgets/nsBaseAppShell.cpp
===================================================================
--- mozilla.orig/widget/src/xpwidgets/nsBaseAppShell.cpp
+++ mozilla/widget/src/xpwidgets/nsBaseAppShell.cpp
@@ -312,16 +312,23 @@
     if (!mDummyEvent)
       mDummyEvent = new nsRunnable();
     thr->Dispatch(mDummyEvent, NS_DISPATCH_NORMAL);
   }
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsBaseAppShell::GetHasPendingInputEvent(PRBool *aResult)
+{
+  *aResult = PR_FALSE;
+  return NS_OK;
+}
+
 // Called from the main thread
 NS_IMETHODIMP
 nsBaseAppShell::AfterProcessNextEvent(nsIThreadInternal *thr,
                                       PRUint32 recursionDepth)
 {
   return NS_OK;
 }
 
