Index: netwerk/base/public/nsIInputStreamChannel.idl
===================================================================
--- netwerk/base/public/nsIInputStreamChannel.idl.orig
+++ netwerk/base/public/nsIInputStreamChannel.idl
@@ -33,25 +33,26 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIChannel.idl"
 
 interface nsIInputStream;
+interface nsIOutputStream;
 
 /**
- * nsIInputStreamChannel
+ * nsIChannelStreamAdaptor
  *
  * This interface provides methods to initialize an input stream channel.
  * The input stream channel serves as a data pump for an input stream.
  */
 [scriptable, uuid(274c4d7a-2447-4ceb-a6de-80db1b83f5d2)]
-interface nsIInputStreamChannel : nsISupports
+interface nsIChannelStreamAdaptor : nsISupports
 {
     /**
      * Sets the URI for this channel.  This must be called before the
      * channel is opened, and it may only be called once.
      */
     void setURI(in nsIURI aURI);
 
     /**
@@ -64,9 +65,25 @@
      *
      * This attribute must be set before the channel is opened, and it may
      * only be set once.
      *
      * @throws NS_ERROR_IN_PROGRESS if the setter is called after the channel
      * has been opened.
      */
     attribute nsIInputStream contentStream;
+
+    /**
+     * Get/set the output stream
+     *
+     * This stream is the destination for data pushed to the channel
+     * If the stream is non-blocking and supports the nsIAsyncOutputStream
+     * interface, then the stream will be written to directly.
+     * Otherwise, the stream will be written to on a background thread.
+     *
+     * This attribute must be set before the channel is opened, and it may
+     * only be set once.
+     *
+     * @throws NS_ERROR_IN_PROGRESS if the setter is called after the channel
+     * has been opened.
+     */
+    attribute nsIOutputStream outputStream;
 };
Index: netwerk/base/public/nsNetUtil.h
===================================================================
--- netwerk/base/public/nsNetUtil.h.orig
+++ netwerk/base/public/nsNetUtil.h
@@ -366,29 +366,31 @@
     rv = aURI->GetScheme(scheme);
     if (NS_FAILED(rv))
         return -1;
 
     return NS_GetDefaultPort(scheme.get());
 }
 
 inline nsresult
-NS_NewInputStreamChannel(nsIChannel      **result,
-                         nsIURI           *uri,
-                         nsIInputStream   *stream,
-                         const nsACString &contentType,
-                         const nsACString *contentCharset)
+NS_NewChannelStreamAdaptor(nsIChannel      **result,
+                           nsIURI           *uri,
+                           nsIInputStream   *stream,
+                           nsIOutputStream  *outputStream,
+                           const nsACString &contentType,
+                           const nsACString *contentCharset)
 {
     nsresult rv;
-    nsCOMPtr<nsIInputStreamChannel> isc =
+    nsCOMPtr<nsIChannelStreamAdaptor> isc =
         do_CreateInstance(NS_INPUTSTREAMCHANNEL_CONTRACTID, &rv);
     if (NS_FAILED(rv))
         return rv;
     rv |= isc->SetURI(uri);
     rv |= isc->SetContentStream(stream);
+    rv |= isc->SetOutputStream(outputStream);
     if (NS_FAILED(rv))
         return rv;
     nsCOMPtr<nsIChannel> chan = do_QueryInterface(isc, &rv);
     if (NS_FAILED(rv))
         return rv;
     if (!contentType.IsEmpty())
         rv |= chan->SetContentType(contentType);
     if (contentCharset && !contentCharset->IsEmpty())
@@ -399,30 +401,45 @@
     }
     return rv;
 }
 
 inline nsresult
 NS_NewInputStreamChannel(nsIChannel      **result,
                          nsIURI           *uri,
                          nsIInputStream   *stream,
+                         const nsACString &contentType,
+                         const nsACString *contentCharset)
+{
+    return
+      NS_NewChannelStreamAdaptor(
+        result, uri, stream, nsnull, contentType, contentCharset);
+}
+
+inline nsresult
+NS_NewInputStreamChannel(nsIChannel      **result,
+                         nsIURI           *uri,
+                         nsIInputStream   *stream,
                          const nsACString &contentType    = EmptyCString())
 {
-    return NS_NewInputStreamChannel(result, uri, stream, contentType, nsnull);
+    return
+      NS_NewChannelStreamAdaptor(
+        result, uri, stream, nsnull, contentType, nsnull);
 }
 
 inline nsresult
 NS_NewInputStreamChannel(nsIChannel      **result,
                          nsIURI           *uri,
                          nsIInputStream   *stream,
                          const nsACString &contentType,
                          const nsACString &contentCharset)
 {
-    return NS_NewInputStreamChannel(result, uri, stream, contentType,
-                                    &contentCharset);
+    return
+      NS_NewChannelStreamAdaptor(
+        result, uri, stream, nsnull, contentType, &contentCharset);
 }
 
 inline nsresult
 NS_NewInputStreamPump(nsIInputStreamPump **result,
                       nsIInputStream      *stream,
                       PRInt64              streamPos = nsInt64(-1),
                       PRInt64              streamLen = nsInt64(-1),
                       PRUint32             segsize = 0,
Index: netwerk/base/src/nsInputStreamChannel.cpp
===================================================================
--- netwerk/base/src/nsInputStreamChannel.cpp.orig
+++ netwerk/base/src/nsInputStreamChannel.cpp
@@ -31,24 +31,272 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsInputStreamChannel.h"
+#include "nsBaseContentStream.h"
+#include "nsThreadUtils.h"
+#include "nsTransportUtils.h"
+#include "nsStreamUtils.h"
+#include "nsMimeTypes.h"
+#include "nsNetUtil.h"
+#include "nsNetSegmentUtils.h"
+#include "nsProxyRelease.h"
 
 //-----------------------------------------------------------------------------
-// nsInputStreamChannel
+
+class nsGenericCopyEvent : public nsRunnable {
+public:
+  nsGenericCopyEvent(nsIOutputStream *dest, nsIInputStream *source, PRInt64 len)
+    : mDest(dest)
+    , mSource(source)
+    , mLen(len)
+    , mStatus(NS_OK)
+    , mInterruptStatus(NS_OK) {
+  }
+
+  // Read the current status of the Generic copy operation.
+  nsresult Status() { return mStatus; }
+
+  // Call this method to perform the Generic copy synchronously.
+  void DoCopy();
+
+  // Call this method to perform the Generic copy on a background thread.  The
+  // callback is dispatched when the Generic copy completes.
+  nsresult Dispatch(nsIRunnable *callback,
+                    nsITransportEventSink *sink,
+                    nsIEventTarget *target);
+
+  // Call this method to interrupt a Generic copy operation that is occuring on
+  // a background thread.  The status parameter passed to this function must
+  // be a failure code and is set as the status of this Generic copy operation.
+  void Interrupt(nsresult status) {
+    NS_ASSERTION(NS_FAILED(status), "must be a failure code");
+    mInterruptStatus = status;
+  }
+
+  NS_IMETHOD Run() {
+    DoCopy();
+    return NS_OK;
+  }
+
+private:
+  nsCOMPtr<nsIEventTarget> mCallbackTarget;
+  nsCOMPtr<nsIRunnable> mCallback;
+  nsCOMPtr<nsITransportEventSink> mSink;
+  nsCOMPtr<nsIOutputStream> mDest;
+  nsCOMPtr<nsIInputStream> mSource;
+  PRInt64 mLen;
+  nsresult mStatus;           // modified on i/o thread only
+  nsresult mInterruptStatus;  // modified on main thread only
+};
+
+void
+nsGenericCopyEvent::DoCopy()
+{
+  // We'll copy in chunks this large by default.  This size affects how
+  // frequently we'll check for interrupts.
+  const PRInt32 chunk = NET_DEFAULT_SEGMENT_SIZE * NET_DEFAULT_SEGMENT_COUNT;
+
+  nsresult rv = NS_OK;
+
+  PRInt64 len = mLen, progress = 0;
+  while (len) {
+    // If we've been interrupted, then stop copying.
+    rv = mInterruptStatus;
+    if (NS_FAILED(rv))
+      break;
+
+    PRInt32 num = PR_MIN((PRInt32) len, chunk);
+
+    PRUint32 result;
+    rv = mSource->ReadSegments(NS_CopySegmentToStream, mDest, num, &result);
+    if (NS_FAILED(rv))
+      break;
+    if (result != (PRUint32) num) {
+      rv = NS_ERROR_FILE_DISK_FULL;  // stopped prematurely (out of disk space)
+      break;
+    }
+
+    // Dispatch progress notification
+    if (mSink) {
+      progress += num;
+      mSink->OnTransportStatus(nsnull, nsITransport::STATUS_WRITING, progress,
+                               mLen);
+    }
+
+    len -= num;
+  }
+
+  if (NS_FAILED(rv))
+    mStatus = rv;
+
+  // Close the output stream before notifying our callback so that others may
+  // freely "play" with the Generic.
+  mDest->Close();
+
+  // Notify completion
+  if (mCallback) {
+    mCallbackTarget->Dispatch(mCallback, NS_DISPATCH_NORMAL);
+
+    // Release the callback on the target thread to avoid destroying stuff on
+    // the wrong thread.
+    nsIRunnable *doomed = nsnull;
+    mCallback.swap(doomed);
+    NS_ProxyRelease(mCallbackTarget, doomed);
+  }
+}
+
+nsresult
+nsGenericCopyEvent::Dispatch(nsIRunnable *callback,
+	 													 nsITransportEventSink *sink,
+														 nsIEventTarget *target)
+{
+  // Use the supplied event target for all asynchronous operations.
+
+  mCallback = callback;
+  mCallbackTarget = target;
+
+  // Build a coalescing proxy for progress events
+  nsresult rv = net_NewTransportEventSinkProxy(getter_AddRefs(mSink), sink,
+                                               target, PR_TRUE);
+  if (NS_FAILED(rv))
+    return rv;
+
+  // Dispatch ourselves to I/O thread pool...
+  nsCOMPtr<nsIEventTarget> pool =
+      do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  return pool->Dispatch(this, NS_DISPATCH_NORMAL);
+}
+
+//-----------------------------------------------------------------------------
+// This is a dummy input stream that when read, performs the Generic copy.  The
+// copy happens on a background thread via mCopyEvent.
+
+class nsGenericUploadContentStream : public nsBaseContentStream {
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+
+  nsGenericUploadContentStream(PRBool nonBlocking,
+                            nsIOutputStream *dest,
+                            nsIInputStream *source,
+                            PRInt64 len,
+                            nsITransportEventSink *sink)
+    : nsBaseContentStream(nonBlocking)
+    , mCopyEvent(new nsGenericCopyEvent(dest, source, len))
+    , mSink(sink) {
+  }
+
+  PRBool IsInitialized() {
+    return mCopyEvent != nsnull;
+  }
+
+  NS_IMETHODIMP ReadSegments(nsWriteSegmentFun fun, void *closure,
+                             PRUint32 count, PRUint32 *result);
+  NS_IMETHODIMP AsyncWait(nsIInputStreamCallback *callback, PRUint32 flags,
+                          PRUint32 count, nsIEventTarget *target);
+
+private:
+  void OnCopyComplete();
+
+  nsRefPtr<nsGenericCopyEvent> mCopyEvent;
+  nsCOMPtr<nsITransportEventSink> mSink;
+};
+
+NS_IMPL_ISUPPORTS_INHERITED0(nsGenericUploadContentStream,
+                             nsBaseContentStream)
+
+NS_IMETHODIMP
+nsGenericUploadContentStream::ReadSegments(nsWriteSegmentFun fun, void *closure,
+                                        PRUint32 count, PRUint32 *result)
+{
+  *result = 0;  // nothing is ever actually read from this stream
+
+  if (IsClosed())
+    return NS_OK;
+
+  if (IsNonBlocking()) {
+    // Inform the caller that they will have to wait for the copy operation to
+    // complete asynchronously.  We'll kick of the copy operation once they
+    // call AsyncWait.
+    return NS_BASE_STREAM_WOULD_BLOCK;
+  }
+
+  // Perform copy synchronously, and then close out the stream.
+  mCopyEvent->DoCopy();
+  nsresult status = mCopyEvent->Status();
+  CloseWithStatus(NS_FAILED(status) ? status : NS_BASE_STREAM_CLOSED);
+  return status;
+}
+
+NS_IMETHODIMP
+nsGenericUploadContentStream::AsyncWait(nsIInputStreamCallback *callback,
+                                     PRUint32 flags, PRUint32 count,
+                                     nsIEventTarget *target)
+{
+  nsresult rv = nsBaseContentStream::AsyncWait(callback, flags, count, target);
+  if (NS_FAILED(rv) || IsClosed())
+    return rv;
+
+  if (IsNonBlocking()) {
+    nsCOMPtr<nsIRunnable> callback =
+        NS_NEW_RUNNABLE_METHOD(nsGenericUploadContentStream, this,
+                               OnCopyComplete);
+    mCopyEvent->Dispatch(callback, mSink, target);
+  }
+
+  return NS_OK;
+}
+
+void
+nsGenericUploadContentStream::OnCopyComplete()
+{
+  // This method is being called to indicate that we are done copying.
+  nsresult status = mCopyEvent->Status();
+
+  CloseWithStatus(NS_FAILED(status) ? status : NS_BASE_STREAM_CLOSED);
+}
+
+//-----------------------------------------------------------------------------
+// nsChannelStreamAdaptor
 
 nsresult
-nsInputStreamChannel::OpenContentStream(PRBool async, nsIInputStream **result,
-                                        nsIChannel** channel)
+nsChannelStreamAdaptor::OpenContentStream(PRBool async, nsIInputStream **result, nsIChannel** channel)
 {
+  if (mUploadStream) {
+    nsGenericUploadContentStream *uploadStream =
+        new nsGenericUploadContentStream(async, mOutputStream, mUploadStream,
+                                      mUploadLength, this);
+    if (!uploadStream || !uploadStream->IsInitialized()) {
+      delete uploadStream;
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+    nsCOMPtr<nsIInputStream> stream = uploadStream;
+
+    SetContentLength64(0);
+
+    // Since there isn't any content to speak of we just set the content-type
+    // to something other than "unknown" to avoid triggering the content-type
+    // sniffer code in nsBaseChannel.
+    // However, don't override explicitly set types.
+    if (!HasContentTypeHint())
+      SetContentType(NS_LITERAL_CSTRING(APPLICATION_OCTET_STREAM));
+
+    *result = nsnull;
+    stream.swap(*result);
+    return NS_OK;
+  }
+
   NS_ENSURE_TRUE(mContentStream, NS_ERROR_NOT_INITIALIZED);
 
   // If content length is unknown, then we must guess.  In this case, we assume
   // the stream can tell us.  If the stream is a pipe, then this will not work.
 
   PRInt64 len = ContentLength64();
   if (len < 0) {
     PRUint32 avail;
@@ -64,39 +312,73 @@
 
   EnableSynthesizedProgressEvents(PR_TRUE);
   
   NS_ADDREF(*result = mContentStream);
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
-// nsInputStreamChannel::nsISupports
+// nsChannelStreamAdaptor::nsISupports
+
+NS_IMPL_ADDREF(nsChannelStreamAdaptor)
+NS_IMPL_RELEASE(nsChannelStreamAdaptor)
 
-NS_IMPL_ISUPPORTS_INHERITED1(nsInputStreamChannel,
-                             nsBaseChannel,
-                             nsIInputStreamChannel)
+NS_INTERFACE_MAP_BEGIN(nsChannelStreamAdaptor)
+NS_INTERFACE_MAP_ENTRY(nsIChannelStreamAdaptor)
+NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIUploadChannel, mOutputStream)
+NS_INTERFACE_MAP_END_INHERITING(nsBaseChannel)
 
 //-----------------------------------------------------------------------------
-// nsInputStreamChannel::nsIInputStreamChannel
+// nsChannelStreamAdaptor::nsIChannelStreamAdaptor
 
 NS_IMETHODIMP
-nsInputStreamChannel::SetURI(nsIURI *uri)
+nsChannelStreamAdaptor::SetURI(nsIURI *uri)
 {
   NS_ENSURE_TRUE(!URI(), NS_ERROR_ALREADY_INITIALIZED);
   nsBaseChannel::SetURI(uri);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsInputStreamChannel::GetContentStream(nsIInputStream **stream)
+nsChannelStreamAdaptor::GetContentStream(nsIInputStream **stream)
 {
   NS_IF_ADDREF(*stream = mContentStream);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsInputStreamChannel::SetContentStream(nsIInputStream *stream)
+nsChannelStreamAdaptor::SetContentStream(nsIInputStream *stream)
 {
   NS_ENSURE_TRUE(!mContentStream, NS_ERROR_ALREADY_INITIALIZED);
   mContentStream = stream;
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsChannelStreamAdaptor::GetUploadStream(nsIInputStream **stream)
+{
+  NS_IF_ADDREF(*stream = mUploadStream);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsChannelStreamAdaptor::SetUploadStream(nsIInputStream *stream, const nsACString &aContentType, PRInt32 aContentLength)
+{
+  NS_ENSURE_TRUE(!mUploadStream, NS_ERROR_ALREADY_INITIALIZED);
+  mUploadStream = stream;
+  mUploadLength = aContentLength;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsChannelStreamAdaptor::SetOutputStream(nsIOutputStream *stream)
+{
+  mOutputStream = stream;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsChannelStreamAdaptor::GetOutputStream(nsIOutputStream **stream)
+{
+  NS_IF_ADDREF(*stream = mOutputStream);
+  return NS_OK;
+}
Index: netwerk/base/src/nsInputStreamChannel.h
===================================================================
--- netwerk/base/src/nsInputStreamChannel.h.orig
+++ netwerk/base/src/nsInputStreamChannel.h
@@ -30,36 +30,45 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#ifndef nsInputStreamChannel_h__
-#define nsInputStreamChannel_h__
+#ifndef nsChannelStreamAdaptor_h__
+#define nsChannelStreamAdaptor_h__
 
 #include "nsBaseChannel.h"
 #include "nsIInputStreamChannel.h"
 
+#include "nsIOutputStream.h"
+#include "nsIUploadChannel.h"
+#include "nsISupportsIterators.h"
+
 //-----------------------------------------------------------------------------
 
-class nsInputStreamChannel : public nsBaseChannel
-                           , public nsIInputStreamChannel
+class nsChannelStreamAdaptor : public nsBaseChannel
+                           , public nsIChannelStreamAdaptor
+                           , public nsIUploadChannel
 {
 public:
     NS_DECL_ISUPPORTS_INHERITED
-    NS_DECL_NSIINPUTSTREAMCHANNEL
+    NS_DECL_NSICHANNELSTREAMADAPTOR
+    NS_DECL_NSIUPLOADCHANNEL
 
-    nsInputStreamChannel() {}
+    nsChannelStreamAdaptor() {}
 
 protected:
-    virtual ~nsInputStreamChannel() {}
+    virtual ~nsChannelStreamAdaptor() {}
 
     virtual nsresult OpenContentStream(PRBool async, nsIInputStream **result,
                                        nsIChannel** channel);
 
 private:
     nsCOMPtr<nsIInputStream> mContentStream;
+    nsCOMPtr<nsIOutputStream> mOutputStream;
+    nsCOMPtr<nsIInputStream> mUploadStream;
+    PRInt64 mUploadLength;
 };
 
-#endif // !nsInputStreamChannel_h__
+#endif // !nsChannelStreamAdaptor_h__
Index: netwerk/build/nsNetModule.cpp
===================================================================
--- netwerk/build/nsNetModule.cpp.orig
+++ netwerk/build/nsNetModule.cpp
@@ -96,17 +96,17 @@
 
 #include "nsAsyncStreamCopier.h"
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsAsyncStreamCopier)
 
 #include "nsInputStreamPump.h"
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsInputStreamPump)
 
 #include "nsInputStreamChannel.h"
-NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsInputStreamChannel, Init)
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsChannelStreamAdaptor, Init)
 
 #include "nsDownloader.h"
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsDownloader)
 
 #include "nsSyncStreamListener.h"
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsSyncStreamListener, Init)
 
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsSafeFileOutputStream)
@@ -676,17 +676,17 @@
       nsAsyncStreamCopierConstructor },
     { NS_INPUTSTREAMPUMP_CLASSNAME,
       NS_INPUTSTREAMPUMP_CID,
       NS_INPUTSTREAMPUMP_CONTRACTID,
       nsInputStreamPumpConstructor },
     { NS_INPUTSTREAMCHANNEL_CLASSNAME,
       NS_INPUTSTREAMCHANNEL_CID,
       NS_INPUTSTREAMCHANNEL_CONTRACTID,
-      nsInputStreamChannelConstructor },
+      nsChannelStreamAdaptorConstructor },
     { NS_STREAMLOADER_CLASSNAME, 
       NS_STREAMLOADER_CID,
       NS_STREAMLOADER_CONTRACTID,
       nsStreamLoader::Create },
     { NS_UNICHARSTREAMLOADER_CLASSNAME, 
       NS_UNICHARSTREAMLOADER_CID,
       NS_UNICHARSTREAMLOADER_CONTRACTID,
       nsUnicharStreamLoader::Create },
Index: extensions/gnomevfs/nsGnomeVFSProtocolHandler.cpp
===================================================================
--- extensions/gnomevfs/nsGnomeVFSProtocolHandler.cpp.orig
+++ extensions/gnomevfs/nsGnomeVFSProtocolHandler.cpp
@@ -53,16 +53,17 @@
 #include "nsProxyRelease.h"
 #include "nsIAuthPrompt.h"
 #include "nsIStringBundle.h"
 #include "nsIStandardURL.h"
 #include "nsIURL.h"
 #include "nsMimeTypes.h"
 #include "nsNetUtil.h"
 #include "nsINetUtil.h"
+#include "nsISupportsIterators.h"
 #include "nsAutoPtr.h"
 #include "nsError.h"
 #include "prlog.h"
 #include "prtime.h"
 #include "prprf.h"
 #include "plstr.h"
 
 #define MOZ_GNOMEVFS_SCHEME              "moz-gnomevfs"
@@ -697,16 +698,20 @@
 }
 
 NS_IMETHODIMP
 nsGnomeVFSInputStream::Available(PRUint32 *aResult)
 {
   if (NS_FAILED(mStatus))
     return mStatus;
 
+  // If this is our first-time through here, then open the URI.
+  if (!mHandle && !mDirOpen)
+    GnomeVFSResult rv = DoOpen();
+
   *aResult = mBytesRemaining;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsGnomeVFSInputStream::Read(char *aBuf,
                             PRUint32 aCount,
                             PRUint32 *aCountRead)
@@ -757,16 +762,282 @@
 nsGnomeVFSInputStream::IsNonBlocking(PRBool *aResult)
 {
   *aResult = PR_FALSE;
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 
+class nsGnomeVFSOutputStream : public nsIOutputStream
+{
+  public:
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIOUTPUTSTREAM
+
+    nsGnomeVFSOutputStream(const nsCString &uriSpec)
+      : mSpec(uriSpec)
+      , mChannel(nsnull)
+      , mHandle(nsnull)
+      , mBytesRemaining(PR_UINT32_MAX)
+      , mStatus(NS_OK)
+      , mDirList(nsnull)
+      , mDirListPtr(nsnull)
+      , mDirBufCursor(0)
+      , mDirOpen(PR_FALSE) {}
+
+   ~nsGnomeVFSOutputStream() { Close(); }
+
+    void SetChannel(nsIChannel *channel)
+    {
+      // We need to hold an owning reference to our channel.  This is done
+      // so we can access the channel's notification callbacks to acquire
+      // a reference to a nsIAuthPrompt if we need to handle a GnomeVFS
+      // authentication callback.
+      //
+      // However, the channel can only be accessed on the main thread, so
+      // we have to be very careful with ownership.  Moreover, it doesn't
+      // support threadsafe addref/release, so proxying is the answer.
+      //
+      // Also, it's important to note that this likely creates a reference
+      // cycle since the channel likely owns this stream.  This reference
+      // cycle is broken in our Close method.
+
+      NS_ADDREF(mChannel = channel);
+    }
+
+  private:
+    GnomeVFSResult DoOpen();
+    GnomeVFSResult DoWrite(const char *aBuf, PRUint32 aCount, PRUint32 *aCountWritten);
+    nsresult       SetContentTypeOfChannel(const char *contentType);
+
+  private:
+    nsCString                mSpec;
+    nsIChannel              *mChannel; // manually refcounted
+    GnomeVFSHandle          *mHandle;
+    PRUint32                 mBytesRemaining;
+    nsresult                 mStatus;
+    GList                   *mDirList;
+    GList                   *mDirListPtr;
+    nsCString                mDirBuf;
+    PRUint32                 mDirBufCursor;
+    PRPackedBool             mDirOpen;
+};
+
+GnomeVFSResult
+nsGnomeVFSOutputStream::DoOpen()
+{
+  GnomeVFSResult rv;
+
+  NS_ASSERTION(mHandle == nsnull, "already open");
+
+  // Push a callback handler on the stack for this thread, so we can intercept
+  // authentication requests from GnomeVFS.  We'll use the channel to get a
+  // nsIAuthPrompt instance.
+
+  gnome_vfs_module_callback_push(GNOME_VFS_MODULE_CALLBACK_AUTHENTICATION,
+                                 AuthCallback, mChannel, NULL);
+
+  // Query the mime type first (this could return NULL).
+  //
+  // XXX We need to do this up-front in order to determine how to open the URI.
+  //     Unfortunately, the error code GNOME_VFS_ERROR_IS_DIRECTORY is not
+  //     always returned by gnome_vfs_open when we pass it a URI to a directory!
+  //     Otherwise, we could have used that as a way to failover to opening the
+  //     URI as a directory.  Also, it would have been ideal if
+  //     gnome_vfs_get_file_info_from_handle were actually implemented by the
+  //     smb:// module, since that would have allowed us to potentially save a
+  //     round trip to the server to discover the mime type of the document in
+  //     the case where gnome_vfs_open would have been used.  (Oh well!  /me
+  //     throws hands up in the air and moves on...)
+
+  GnomeVFSFileInfo info = {0};
+  rv = gnome_vfs_get_file_info(mSpec.get(), &info, GNOME_VFS_FILE_INFO_DEFAULT);
+  if (rv == GNOME_VFS_OK)
+  {
+    if (info.type == GNOME_VFS_FILE_TYPE_DIRECTORY)
+    {
+      rv = GNOME_VFS_ERROR_IS_DIRECTORY;
+    }
+    else
+    {
+      rv = gnome_vfs_open(&mHandle, mSpec.get(), GNOME_VFS_OPEN_WRITE);
+
+      LOG(("gnomevfs: gnome_vfs_open returned %d (%s) [spec=\"%s\"]\n",
+          rv, gnome_vfs_result_to_string(rv), mSpec.get()));
+    }
+  }
+  else if (rv == GNOME_VFS_ERROR_NOT_FOUND)
+  {
+    rv = gnome_vfs_create(&mHandle, mSpec.get(), GNOME_VFS_OPEN_WRITE, 1, 0644);
+
+    LOG(("gnomevfs: gnome_vfs_create returned %d (%s) [spec=\"%s\"]\n",
+        rv, gnome_vfs_result_to_string(rv), mSpec.get()));
+  }
+
+  gnome_vfs_module_callback_pop(GNOME_VFS_MODULE_CALLBACK_AUTHENTICATION);
+
+  gnome_vfs_file_info_clear(&info);
+  return rv;
+}
+
+GnomeVFSResult
+nsGnomeVFSOutputStream::DoWrite(const char *aBuf, PRUint32 aCount, PRUint32 *aCountWritten)
+{
+  GnomeVFSResult rv;
+
+  if (mHandle)
+  {
+    GnomeVFSFileSize bytesWritten;
+    rv = gnome_vfs_write(mHandle, aBuf, aCount, &bytesWritten);
+    if (rv == GNOME_VFS_OK)
+    {
+      *aCountWritten = bytesWritten;
+    }
+  }
+  else
+  {
+    NS_NOTREACHED("writing to what?");
+    rv = GNOME_VFS_ERROR_GENERIC;
+  }
+
+  return rv;
+}
+
+nsresult
+nsGnomeVFSOutputStream::SetContentTypeOfChannel(const char *contentType)
+{
+  // We need to proxy this call over to the main thread.  We post an
+  // asynchronous event in this case so that we don't delay reading data, and
+  // we know that this is safe to do since the channel's reference will be
+  // released asynchronously as well.  We trust the ordering of the main
+  // thread's event queue to protect us against memory corruption.
+
+  nsresult rv;
+  nsCOMPtr<nsIRunnable> ev =
+      new nsGnomeVFSSetContentTypeEvent(mChannel, contentType);
+  if (!ev)
+  {
+    rv = NS_ERROR_OUT_OF_MEMORY;
+  }
+  else
+  {
+    rv = NS_DispatchToMainThread(ev);
+  }
+  return rv;
+}
+
+NS_IMPL_THREADSAFE_ISUPPORTS1(nsGnomeVFSOutputStream, nsIOutputStream)
+
+NS_IMETHODIMP
+nsGnomeVFSOutputStream::Close()
+{
+  if (mHandle)
+  {
+    gnome_vfs_close(mHandle);
+    mHandle = nsnull;
+  }
+
+  if (mDirList)
+  {
+    // Destroy the list of GnomeVFSFileInfo objects...
+    g_list_foreach(mDirList, (GFunc) gnome_vfs_file_info_unref, nsnull);
+    g_list_free(mDirList);
+    mDirList = nsnull;
+    mDirListPtr = nsnull;
+  }
+
+  if (mChannel)
+  {
+    nsresult rv = NS_OK;
+
+    nsCOMPtr<nsIThread> thread = do_GetMainThread();
+    if (thread)
+      rv = NS_ProxyRelease(thread, mChannel);
+
+    NS_ASSERTION(thread && NS_SUCCEEDED(rv), "leaking channel reference");
+    mChannel = nsnull;
+  }
+
+  mSpec.Truncate(); // free memory
+
+  // Prevent future reads from re-opening the handle.
+  if (NS_SUCCEEDED(mStatus))
+    mStatus = NS_BASE_STREAM_CLOSED;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGnomeVFSOutputStream::Flush()
+{
+  /* GnomeVFS is Sync */
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGnomeVFSOutputStream::Write(const char *aBuf,
+                             PRUint32 aCount,
+                             PRUint32 *aWritten)
+{
+  if (mStatus == NS_BASE_STREAM_CLOSED)
+    return NS_OK;
+  if (NS_FAILED(mStatus))
+    return mStatus;
+
+  GnomeVFSResult rv = GNOME_VFS_OK;
+
+  // If this is our first-time through here, then open the URI.
+  if (!mHandle && !mDirOpen)
+    rv = DoOpen();
+
+  if (rv == GNOME_VFS_OK)
+    rv = DoWrite(aBuf, aCount, aWritten);
+
+  if (rv != GNOME_VFS_OK)
+  {
+    // If we reach here, we hit some kind of error.  EOF is not an error.
+    mStatus = MapGnomeVFSResult(rv);
+    if (mStatus == NS_BASE_STREAM_CLOSED)
+      return NS_OK;
+
+    LOG(("gnomevfs: result %d [%s] mapped to 0x%x\n",
+        rv, gnome_vfs_result_to_string(rv), mStatus));
+  }
+  return mStatus;
+}
+
+NS_IMETHODIMP
+nsGnomeVFSOutputStream::WriteFrom(nsIInputStream *aFromStream,
+                                  PRUint32 aCount,
+                                  PRUint32 *aWritten)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsGnomeVFSOutputStream::WriteSegments(nsReadSegmentFun aWriter,
+                                    void *aClosure,
+                                    PRUint32 aCount,
+                                    PRUint32 *aWritten)
+{
+  // There is no way to implement this using GnomeVFS, but fortunately
+  // that doesn't matter.  Because we are a blocking input stream, Necko
+  // isn't going to call our WriteSegments method.
+  NS_NOTREACHED("nsGnomeVFSOutputStream::WriteSegments");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsGnomeVFSOutputStream::IsNonBlocking(PRBool *aResult)
+{
+  *aResult = PR_FALSE;
+  return NS_OK;
+}
+
 class nsGnomeVFSProtocolHandler : public nsIProtocolHandler
                                 , public nsIObserver
 {
   public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSIPROTOCOLHANDLER
     NS_DECL_NSIOBSERVER
 
@@ -930,28 +1201,31 @@
 
   nsCAutoString spec;
   rv = aURI->GetSpec(spec);
   if (NS_FAILED(rv))
     return rv;
 
   nsRefPtr<nsGnomeVFSInputStream> stream = new nsGnomeVFSInputStream(spec);
   if (!stream)
-  {
-    rv = NS_ERROR_OUT_OF_MEMORY;
-  }
-  else
-  {
-    // start out assuming an unknown content-type.  we'll set the content-type
-    // to something better once we open the URI.
-    rv = NS_NewInputStreamChannel(aResult, aURI, stream,
-                                  NS_LITERAL_CSTRING(UNKNOWN_CONTENT_TYPE));
-    if (NS_SUCCEEDED(rv))
-      stream->SetChannel(*aResult);
-  }
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  nsRefPtr<nsGnomeVFSOutputStream> outputStream
+    = new nsGnomeVFSOutputStream(spec);
+
+  // start out assuming an unknown content-type.  we'll set the content-type
+  // to something better once we open the URI.
+  rv = NS_NewChannelStreamAdaptor(aResult, aURI, stream, outputStream,
+                                  NS_LITERAL_CSTRING(UNKNOWN_CONTENT_TYPE),
+                                  nsnull);
+  if (NS_FAILED(rv))
+    return rv;
+  stream->SetChannel(*aResult);
+  outputStream->SetChannel(*aResult);
+
   return rv;
 }
 
 NS_IMETHODIMP
 nsGnomeVFSProtocolHandler::AllowPort(PRInt32 aPort,
                                      const char *aScheme,
                                      PRBool *aResult)
 {
