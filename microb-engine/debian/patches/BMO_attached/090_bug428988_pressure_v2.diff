diff -r 2ab8ad95e549 content/base/src/nsGenericElement.cpp
--- a/content/base/src/nsGenericElement.cpp	Sun Nov 23 14:12:23 2008 -0500
+++ b/content/base/src/nsGenericElement.cpp	Sun Nov 23 14:22:06 2008 -0500
@@ -3408,19 +3408,23 @@ nsGenericElement::DispatchClickEvent(nsP
   NS_PRECONDITION(aTarget, "Must have target");
   NS_PRECONDITION(aSourceEvent, "Must have source event");
   NS_PRECONDITION(aStatus, "Null out param?");
 
   nsMouseEvent event(NS_IS_TRUSTED_EVENT(aSourceEvent), NS_MOUSE_CLICK,
                      aSourceEvent->widget, nsMouseEvent::eReal);
   event.refPoint = aSourceEvent->refPoint;
   PRUint32 clickCount = 1;
+  float  pressure = 0;
+
   if (aSourceEvent->eventStructType == NS_MOUSE_EVENT) {
     clickCount = static_cast<nsMouseEvent*>(aSourceEvent)->clickCount;
-  }
+    pressure = static_cast<nsMouseEvent*>(aSourceEvent)->pressure;
+  }
+  event.pressure = pressure;
   event.clickCount = clickCount;
   event.isShift = aSourceEvent->isShift;
   event.isControl = aSourceEvent->isControl;
   event.isAlt = aSourceEvent->isAlt;
   event.isMeta = aSourceEvent->isMeta;
 
   return DispatchEvent(aPresContext, &event, aTarget, aFullDispatch, aStatus);
 }
diff -r 2ab8ad95e549 content/events/src/nsDOMEvent.cpp
--- a/content/events/src/nsDOMEvent.cpp	Sun Nov 23 14:12:23 2008 -0500
+++ b/content/events/src/nsDOMEvent.cpp	Sun Nov 23 14:22:06 2008 -0500
@@ -812,16 +812,17 @@ NS_METHOD nsDOMEvent::DuplicatePrivateDa
         new nsMouseEvent(PR_FALSE, msg, nsnull, oldMouseEvent->reason);
       NS_ENSURE_TRUE(mouseEvent, NS_ERROR_OUT_OF_MEMORY);
       isInputEvent = PR_TRUE;
       mouseEvent->clickCount = oldMouseEvent->clickCount;
       mouseEvent->acceptActivation = oldMouseEvent->acceptActivation;
       mouseEvent->context = oldMouseEvent->context;
       mouseEvent->relatedTarget = oldMouseEvent->relatedTarget;
       mouseEvent->button = oldMouseEvent->button;
+      mouseEvent->pressure = oldMouseEvent->pressure;
       newEvent = mouseEvent;
       break;
     }
     case NS_DRAG_EVENT:
     {
       nsDragEvent* oldDragEvent = static_cast<nsDragEvent*>(mEvent);
       nsDragEvent* dragEvent =
         new nsDragEvent(PR_FALSE, msg, nsnull);
diff -r 2ab8ad95e549 content/events/src/nsDOMMouseEvent.cpp
--- a/content/events/src/nsDOMMouseEvent.cpp	Sun Nov 23 14:12:23 2008 -0500
+++ b/content/events/src/nsDOMMouseEvent.cpp	Sun Nov 23 14:22:06 2008 -0500
@@ -244,19 +244,46 @@ nsDOMMouseEvent::GetWhich(PRUint32* aWhi
 {
   NS_ENSURE_ARG_POINTER(aWhich);
   PRUint16 button;
   (void) GetButton(&button);
   *aWhich = button + 1;
   return NS_OK;
 }
 
+
+nsDOMMouseWithPressureEvent::nsDOMMouseWithPressureEvent(nsPresContext* aPresContext,
+                                                         nsInputEvent* aEvent)
+  : nsDOMMouseEvent(aPresContext, aEvent)
+{
+}
+
+nsDOMMouseWithPressureEvent::~nsDOMMouseWithPressureEvent()
+{
+}
+
+NS_IMPL_ADDREF_INHERITED(nsDOMMouseWithPressureEvent, nsDOMMouseEvent)
+NS_IMPL_RELEASE_INHERITED(nsDOMMouseWithPressureEvent, nsDOMMouseEvent)
+
+NS_INTERFACE_MAP_BEGIN(nsDOMMouseWithPressureEvent)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMMouseWithPressureEvent)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(MouseWithPressureEvent)
+NS_INTERFACE_MAP_END_INHERITING(nsDOMMouseEvent)
+
+NS_IMETHODIMP
+nsDOMMouseWithPressureEvent::GetPressure(float* aPressure)
+{
+  NS_ENSURE_ARG_POINTER(aPressure);
+  *aPressure = ((nsMouseEvent*)mEvent)->pressure;
+  return NS_OK;
+}
+
 nsresult NS_NewDOMMouseEvent(nsIDOMEvent** aInstancePtrResult,
                              nsPresContext* aPresContext,
                              nsInputEvent *aEvent) 
 {
-  nsDOMMouseEvent* it = new nsDOMMouseEvent(aPresContext, aEvent);
+  nsDOMMouseWithPressureEvent* it = new nsDOMMouseWithPressureEvent(aPresContext, aEvent);
   if (nsnull == it) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   return CallQueryInterface(it, aInstancePtrResult);
 }
diff -r 2ab8ad95e549 content/events/src/nsDOMMouseEvent.h
--- a/content/events/src/nsDOMMouseEvent.h	Sun Nov 23 14:12:23 2008 -0500
+++ b/content/events/src/nsDOMMouseEvent.h	Sun Nov 23 14:22:06 2008 -0500
@@ -35,16 +35,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsDOMMouseEvent_h__
 #define nsDOMMouseEvent_h__
 
 #include "nsIDOMMouseEvent.h"
+#include "nsIDOMMouseWithPressureEvent.h"
 #include "nsDOMUIEvent.h"
 
 class nsIContent;
 class nsIScrollableView;
 class nsEvent;
 
 class nsDOMMouseEvent : public nsIDOMMouseEvent,
                         public nsDOMUIEvent
@@ -60,13 +61,32 @@ public:
   
   // Forward to base class
   NS_FORWARD_TO_NSDOMUIEVENT
 
   // Specific implementation for a mouse event.
   NS_IMETHOD GetWhich(PRUint32 *aWhich);
 };
 
+class nsDOMMouseWithPressureEvent: public nsIDOMMouseWithPressureEvent, public nsDOMMouseEvent
+{
+public:
+  nsDOMMouseWithPressureEvent(nsPresContext* aPresContext, nsInputEvent* aEvent);
+  virtual ~nsDOMMouseWithPressureEvent();
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+  // nsIDOMMouseWithPressureEvent Interface
+  NS_DECL_NSIDOMMOUSEWITHPRESSUREEVENT
+
+  // Forward to base class
+  NS_FORWARD_NSIDOMMOUSEEVENT(nsDOMMouseEvent::)
+
+  // Forward to base class
+  NS_FORWARD_TO_NSDOMUIEVENT
+
+};
+
 #define NS_FORWARD_TO_NSDOMMOUSEEVENT         \
   NS_FORWARD_NSIDOMMOUSEEVENT(nsDOMMouseEvent::) \
   NS_FORWARD_TO_NSDOMUIEVENT
 
 #endif // nsDOMMouseEvent_h__
diff -r 2ab8ad95e549 dom/public/idl/events/Makefile.in
--- a/dom/public/idl/events/Makefile.in	Sun Nov 23 14:12:23 2008 -0500
+++ b/dom/public/idl/events/Makefile.in	Sun Nov 23 14:22:06 2008 -0500
@@ -52,16 +52,17 @@ SDK_XPIDLSRCS =                         
 	nsIDOMEventTarget.idl			\
 	nsIDOMEventListener.idl			\
 	nsIDOM3DocumentEvent.idl		\
 	nsIDOM3EventTarget.idl			\
 	nsIDOMEventGroup.idl			\
 	nsIDOMMouseEvent.idl			\
 	nsIDOMMouseScrollEvent.idl      \
 	nsIDOMUIEvent.idl			\
+	nsIDOMMouseWithPressureEvent.idl        \
 	nsIDOMProgressEvent.idl			\
 	$(NULL)
 
 XPIDLSRCS =					\
 	nsIDOMNSEvent.idl			\
 	nsIDOMDataContainerEvent.idl	\
 	nsIDOMKeyEvent.idl			\
 	nsIDOMMutationEvent.idl			\
diff -r 2ab8ad95e549 dom/public/nsDOMClassInfoID.h
--- a/dom/public/nsDOMClassInfoID.h	Sun Nov 23 14:12:23 2008 -0500
+++ b/dom/public/nsDOMClassInfoID.h	Sun Nov 23 14:22:06 2008 -0500
@@ -455,16 +455,19 @@ enum nsDOMClassInfoID {
   eDOMClassInfo_SimpleGestureEvent_id,
 
 #ifdef MOZ_MATHML
   eDOMClassInfo_MathMLElement_id,
 #endif
 
   eDOMClassInfo_Worker_id,
 
+  // Mouse Pressure Events
+  eDOMClassInfo_MouseWithPressureEvent_id,
+
   // This one better be the last one in this list
   eDOMClassInfoIDCount
 };
 
 /**
  * nsIClassInfo helper macros
  */
 
diff -r 2ab8ad95e549 dom/src/base/nsDOMClassInfo.cpp
--- a/dom/src/base/nsDOMClassInfo.cpp	Sun Nov 23 14:12:23 2008 -0500
+++ b/dom/src/base/nsDOMClassInfo.cpp	Sun Nov 23 14:22:06 2008 -0500
@@ -229,16 +229,17 @@
 #include "nsIDOMComment.h"
 #include "nsIDOMCDATASection.h"
 #include "nsIDOMProcessingInstruction.h"
 #include "nsIDOMNotation.h"
 #include "nsIDOMNSEvent.h"
 #include "nsIDOMDataContainerEvent.h"
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMMouseEvent.h"
+#include "nsIDOMMouseWithPressureEvent.h"
 #include "nsIDOMMouseScrollEvent.h"
 #include "nsIDOMDragEvent.h"
 #include "nsIDOMCommandEvent.h"
 #include "nsIDOMPopupBlockedEvent.h"
 #include "nsIDOMBeforeUnloadEvent.h"
 #include "nsIDOMMutationEvent.h"
 #include "nsIDOMSmartCardEvent.h"
 #include "nsIDOMXULCommandEvent.h"
@@ -1305,16 +1306,19 @@ static nsDOMClassInfoData sClassInfoData
 
 #ifdef MOZ_MATHML
   NS_DEFINE_CLASSINFO_DATA_WITH_NAME(MathMLElement, Element, nsElementSH,
                                      ELEMENT_SCRIPTABLE_FLAGS)
 #endif
 
   NS_DEFINE_CLASSINFO_DATA(Worker, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
+
+  NS_DEFINE_CLASSINFO_DATA(MouseWithPressureEvent, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
 };
 
 // Objects that shuld be constructable through |new Name();|
 struct nsContractIDMapData
 {
   PRInt32 mDOMClassInfoID;
   const char *mContractID;
 };
@@ -3578,16 +3582,21 @@ nsDOMClassInfo::Init()
 #endif
 
   DOM_CLASSINFO_MAP_BEGIN(Worker, nsIWorker)
     DOM_CLASSINFO_MAP_ENTRY(nsIWorker)
     DOM_CLASSINFO_MAP_ENTRY(nsIAbstractWorker)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMEventTarget)
   DOM_CLASSINFO_MAP_END
 
+  DOM_CLASSINFO_MAP_BEGIN(MouseWithPressureEvent, nsIDOMMouseWithPressureEvent)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMMouseWithPressureEvent)
+    DOM_CLASSINFO_UI_EVENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
 #ifdef NS_DEBUG
   {
     PRUint32 i = NS_ARRAY_LENGTH(sClassInfoData);
 
     if (i != eDOMClassInfoIDCount) {
       NS_ERROR("The number of items in sClassInfoData doesn't match the "
                "number of nsIDOMClassInfo ID's, this is bad! Fix it!");
 
diff -r 2ab8ad95e549 widget/public/nsGUIEvent.h
--- a/widget/public/nsGUIEvent.h	Sun Nov 23 14:12:23 2008 -0500
+++ b/widget/public/nsGUIEvent.h	Sun Nov 23 14:22:06 2008 -0500
@@ -674,22 +674,25 @@ public:
 /**
  * Mouse event
  */
 
 class nsMouseEvent_base : public nsInputEvent
 {
 public:
   nsMouseEvent_base(PRBool isTrusted, PRUint32 msg, nsIWidget *w, PRUint8 type)
-  : nsInputEvent(isTrusted, msg, w, type), button(0) {}
+  : nsInputEvent(isTrusted, msg, w, type), button(0), pressure(0) {}
 
   /// The possible related target
   nsCOMPtr<nsISupports> relatedTarget;
 
   PRInt16               button;
+
+  // Finger or touch pressure of event
+  float                 pressure;
 };
 
 class nsMouseEvent : public nsMouseEvent_base
 {
 public:
   enum buttonType  { eLeftButton = 0, eMiddleButton = 1, eRightButton = 2 };
   enum reasonType  { eReal, eSynthesized };
   enum contextType { eNormal, eContextMenuKey };
diff -r 2ab8ad95e549 widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp	Sun Nov 23 14:12:23 2008 -0500
+++ b/widget/src/gtk2/nsWindow.cpp	Sun Nov 23 14:22:06 2008 -0500
@@ -393,16 +393,17 @@ nsWindow::nsWindow()
     if (mLastDragMotionWindow == this)
         mLastDragMotionWindow = NULL;
     mDragMotionWidget = 0;
     mDragMotionContext = 0;
     mDragMotionX = 0;
     mDragMotionY = 0;
     mDragMotionTime = 0;
     mDragMotionTimerID = 0;
+    mLastMotionPressure = 0;
 
 #ifdef USE_XIM
     mIMEData = nsnull;
 #endif
 
 #ifdef ACCESSIBILITY
     mRootAccessible  = nsnull;
 #endif
@@ -2524,16 +2525,23 @@ nsWindow::OnMotionNotifyEvent(GtkWidget 
 
 
     // when we receive this, it must be that the gtk dragging is over,
     // it is dropped either in or out of mozilla, clear the flag
     sIsDraggingOutOf = PR_FALSE;
 
     nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, this, nsMouseEvent::eReal);
 
+    // should we move this into !synthEvent?
+    gdouble pressure = 0;
+    gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+    if (pressure)
+      mLastMotionPressure = pressure;
+    event.pressure = mLastMotionPressure;
+
     nsRect windowRect;
     ScreenToWidget(nsRect(nscoord(cursorX), nscoord(cursorY), 1, 1), windowRect);
 
     event.refPoint.x = windowRect.x;
     event.refPoint.y = windowRect.y;
 
     event.isShift   = (aEvent->state & GDK_SHIFT_MASK)
         ? PR_TRUE : PR_FALSE;
@@ -2576,16 +2584,22 @@ nsWindow::OnMotionNotifyEvent(GtkWidget 
     // if plugins still keeps the focus, get it back
     if (gPluginFocusWindow && gPluginFocusWindow != this) {
         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
     }
 #endif /* MOZ_X11 */
 
     nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, this, nsMouseEvent::eReal);
+
+    gdouble pressure = 0;
+    gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+    if (pressure)
+      mLastMotionPressure = pressure;
+    event.pressure = mLastMotionPressure;
 
     if (synthEvent) {
 #ifdef MOZ_X11
         event.refPoint.x = nscoord(xevent.xmotion.x);
         event.refPoint.y = nscoord(xevent.xmotion.y);
 
         event.isShift   = (xevent.xmotion.state & GDK_SHIFT_MASK)
             ? PR_TRUE : PR_FALSE;
@@ -2705,32 +2719,37 @@ nsWindow::OnButtonPressEvent(GtkWidget *
         DispatchActivateEvent();
     }
 
     PRBool rolledUp = check_for_rollup(aEvent->window, aEvent->x_root,
                                        aEvent->y_root, PR_FALSE);
     if (gConsumeRollupEvent && rolledUp)
             return;
 
+    gdouble pressure = 0;
+    gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+    mLastMotionPressure = pressure;
+
     PRUint16 domButton;
     switch (aEvent->button) {
     case 1:
         domButton = nsMouseEvent::eLeftButton;
         break;
     case 2:
         domButton = nsMouseEvent::eMiddleButton;
         break;
     case 3:
         domButton = nsMouseEvent::eRightButton;
         break;
     // These are mapped to horizontal scroll
     case 6:
     case 7:
         {
             nsMouseScrollEvent event(PR_TRUE, NS_MOUSE_SCROLL, this);
+            event.pressure = mLastMotionPressure;
             event.scrollFlags = nsMouseScrollEvent::kIsHorizontal;
             event.refPoint.x = nscoord(aEvent->x);
             event.refPoint.y = nscoord(aEvent->y);
             event.delta = (aEvent->button == 6) ? -2 : 2;
 
             event.isShift   = (aEvent->state & GDK_SHIFT_MASK) != 0;
             event.isControl = (aEvent->state & GDK_CONTROL_MASK) != 0;
             event.isAlt     = (aEvent->state & GDK_MOD1_MASK) != 0;
@@ -2751,25 +2770,27 @@ nsWindow::OnButtonPressEvent(GtkWidget *
         return;
     default:
         return;
     }
 
     nsMouseEvent event(PR_TRUE, NS_MOUSE_BUTTON_DOWN, this, nsMouseEvent::eReal);
     event.button = domButton;
     InitButtonEvent(event, aEvent);
+    event.pressure = mLastMotionPressure;
 
     DispatchEvent(&event, status);
 
     // right menu click on linux should also pop up a context menu
     if (domButton == nsMouseEvent::eRightButton &&
         NS_LIKELY(!mIsDestroyed)) {
         nsMouseEvent contextMenuEvent(PR_TRUE, NS_CONTEXTMENU, this,
                                       nsMouseEvent::eReal);
         InitButtonEvent(contextMenuEvent, aEvent);
+        contextMenuEvent.pressure = mLastMotionPressure;
         DispatchEvent(&contextMenuEvent, status);
     }
 }
 
 void
 nsWindow::OnButtonReleaseEvent(GtkWidget *aWidget, GdkEventButton *aEvent)
 {
     PRUint16 domButton;
@@ -2787,19 +2808,23 @@ nsWindow::OnButtonReleaseEvent(GtkWidget
         break;
     default:
         return;
     }
 
     nsMouseEvent event(PR_TRUE, NS_MOUSE_BUTTON_UP, this, nsMouseEvent::eReal);
     event.button = domButton;
     InitButtonEvent(event, aEvent);
-
-    nsEventStatus status;
-    DispatchEvent(&event, status);
+    gdouble pressure = 0;
+    gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+    event.pressure = pressure ? pressure : mLastMotionPressure;
+
+    nsEventStatus status;
+    DispatchEvent(&event, status);
+    mLastMotionPressure = pressure;
 }
 
 void
 nsWindow::OnContainerFocusInEvent(GtkWidget *aWidget, GdkEventFocus *aEvent)
 {
     LOGFOCUS(("OnContainerFocusInEvent [%p]\n", (void *)this));
     // Return if someone has blocked events for this widget.  This will
     // happen if someone has called gtk_widget_grab_focus() from
@@ -3941,16 +3966,18 @@
                                "notify::gtk-theme-name",
                                G_CALLBACK(theme_changed_cb), this);
         g_signal_connect_after(default_settings,
                                "notify::gtk-font-name",
                                G_CALLBACK(theme_changed_cb), this);
     }
 
     if (mContainer) {
+        gtk_widget_set_extension_events (GTK_WIDGET(mContainer),
+                                         GDK_EXTENSION_EVENTS_ALL);
         g_signal_connect(G_OBJECT(mContainer), "style_set",
                          G_CALLBACK(theme_changed_cb), this);
         g_signal_connect_after(G_OBJECT(mContainer), "size_allocate",
                                G_CALLBACK(size_allocate_cb), NULL);
         g_signal_connect(G_OBJECT(mContainer), "expose_event",
                          G_CALLBACK(expose_event_cb), NULL);
         g_signal_connect_after(G_OBJECT(mContainer), "enter_notify_event",
                          G_CALLBACK(enter_notify_event_cb), NULL);
@@ -5342,16 +5369,18 @@ button_press_event_cb(GtkWidget *widget,
 button_press_event_cb(GtkWidget *widget, GdkEventButton *event)
 {
     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
     if (!window)
         return FALSE;
 
     window->OnButtonPressEvent(widget, event);
 
+    gtk_widget_set_extension_events (GTK_WIDGET(widget),
+                                     GDK_EXTENSION_EVENTS_ALL);
     return TRUE;
 }
 
 /* static */
 gboolean
 button_release_event_cb(GtkWidget *widget, GdkEventButton *event)
 {
     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
diff -r 2ab8ad95e549 dom/public/idl/events/nsIDOMMouseWithPressureEvent.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/public/idl/events/nsIDOMMouseWithPressureEvent.idl	Sun Nov 23 14:40:19 2008 -0500
@@ -0,0 +1,51 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2000
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Doug Turner <dougt@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMMouseEvent.idl"
+
+/**
+ * The nsIDOMMouseEventPressure interface extends nsIDOMMouseEvent
+ * by providing pressure information related to the mouse event.
+ */
+
+[scriptable, uuid(25e47b17-a0df-4ac1-aa1b-fda7d5701447)]
+interface nsIDOMMouseWithPressureEvent : nsIDOMMouseEvent
+{
+  readonly attribute float pressure;
+};
+
diff -r 2ab8ad95e549 widget/src/gtk2/nsWindow.h
--- a/widget/src/gtk2/nsWindow.h	Sun Nov 23 14:12:23 2008 -0500
+++ b/widget/src/gtk2/nsWindow.h	Sun Nov 23 14:22:06 2008 -0500
@@ -545,16 +545,17 @@ private:
     // repeatedly
     GtkWidget         *mDragMotionWidget;
     GdkDragContext    *mDragMotionContext;
     gint               mDragMotionX;
     gint               mDragMotionY;
     guint              mDragMotionTime;
     guint              mDragMotionTimerID;
     nsCOMPtr<nsITimer> mDragLeaveTimer;
+    float              mLastMotionPressure;
 
     static PRBool      sIsDraggingOutOf;
     // drag in progress
     static PRBool DragInProgress(void);
 
     void         ResetDragMotionTimer     (GtkWidget      *aWidget,
                                            GdkDragContext *aDragContext,
                                            gint           aX,
