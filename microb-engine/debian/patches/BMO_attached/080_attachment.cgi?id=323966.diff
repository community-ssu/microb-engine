b=436932, add imageRenderingQuality property to 2D canvas

Index: mozilla/content/canvas/src/nsCanvasRenderingContext2D.cpp
===================================================================
--- mozilla.orig/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ mozilla/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -347,16 +347,17 @@
         STYLE_MAX
     };
 
     nsresult SetStyleFromVariant(nsIVariant* aStyle, Style aWhichStyle);
     void StyleColorToString(const nscolor& aColor, nsAString& aStr);
 
     void DirtyAllStyles();
     void ApplyStyle(Style aWhichStyle);
+    void ApplyQualityHints();
     
     // If aPrincipal is not subsumed by this canvas element, then
     // we make the canvas write-only so bad guys can't extract the pixel
     // data.  If forceWriteOnly is set, we force write only to be set
     // and ignore aPrincipal.  (This is used for when the original data came
     // from a <canvas> that had write-only set.)
     void DoDrawImageSecurityCheck(nsIPrincipal* aPrincipal,
                                   PRBool forceWriteOnly);
@@ -422,33 +423,41 @@
      */
     nsresult DrawOrMeasureText(const nsAString& text,
                                float x,
                                float y,
                                float maxWidth,
                                TextDrawOperation op,
                                float* aWidth);
  
+    typedef enum {
+        Auto,
+        OptimizeSpeed,
+        OptimizeQuality
+    } ImageRenderingQuality;
+
     // style handling
     /*
      * The previous set style. Is equal to STYLE_MAX when there is no valid
      * previous style.
      */
     Style mLastStyle;
     PRPackedBool mDirtyStyle[STYLE_MAX];
 
     // state stack handling
     class ContextState {
     public:
         ContextState() : globalAlpha(1.0),
+                         imageRenderingQuality(Auto),
                          textAlign(TEXT_ALIGN_START),
                          textBaseline(TEXT_BASELINE_ALPHABETIC) { }
 
         ContextState(const ContextState& other)
             : globalAlpha(other.globalAlpha),
+              imageRenderingQuality(other.imageRenderingQuality),
               font(other.font),
               fontGroup(other.fontGroup),
               textAlign(other.textAlign),
               textBaseline(other.textBaseline)
         {
             for (int i = 0; i < STYLE_MAX; i++) {
                 colorStyles[i] = other.colorStyles[i];
                 gradientStyles[i] = other.gradientStyles[i];
@@ -477,16 +486,17 @@
         nsString font;
         nsRefPtr<gfxFontGroup> fontGroup;
         TextAlign textAlign;
         TextBaseline textBaseline;
 
         nscolor colorStyles[STYLE_MAX];
         nsCOMPtr<nsCanvasGradient> gradientStyles[STYLE_MAX];
         nsCOMPtr<nsCanvasPattern> patternStyles[STYLE_MAX];
+        nsCanvasRenderingContext2D::ImageRenderingQuality imageRenderingQuality;
     };
 
     nsTArray<ContextState> mStyleStack;
 
     inline ContextState& CurrentState() {
         return mStyleStack[mSaveCount];
     }
 
@@ -726,21 +736,23 @@
     nsCanvasPattern* pattern = CurrentState().patternStyles[aWhichStyle];
     if (pattern) {
         if (!mCanvasElement)
             return;
 
         DoDrawImageSecurityCheck(pattern->Principal(),
                                  pattern->GetForceWriteOnly());
         pattern->Apply(mThebes);
+        ApplyQualityHints();
         return;
     }
 
     if (CurrentState().gradientStyles[aWhichStyle]) {
         CurrentState().gradientStyles[aWhichStyle]->Apply(mThebes);
+        ApplyQualityHints();
         return;
     }
 
     SetThebesColor(CurrentState().colorStyles[aWhichStyle]);
 }
 
 nsresult
 nsCanvasRenderingContext2D::Redraw()
@@ -2590,16 +2602,17 @@
     pattern = new gfxPattern(imgsurf);
     pattern->SetMatrix(matrix);
 
     path = mThebes->CopyPath();
 
     mThebes->Save();
     mThebes->Translate(gfxPoint(dx, dy));
     mThebes->SetPattern(pattern);
+    ApplyQualityHints();
     mThebes->Clip(gfxRect(0, 0, dw, dh));
     mThebes->Paint(CurrentState().globalAlpha);
     mThebes->Restore();
 
 #if 1
     // XXX cairo bug workaround; force a clip update on mThebes.
     // Otherwise, a pixman clip gets left around somewhere, and pixman
     // (Render) does source clipping as well -- so we end up
@@ -3141,16 +3154,69 @@
     jsval *retvalPtr;
     ncc->GetRetValPtr(&retvalPtr);
     *retvalPtr = OBJECT_TO_JSVAL(result);
     ncc->SetReturnValueWasSet(PR_TRUE);
 
     return NS_OK;
 }
 
+NS_IMETHODIMP
+nsCanvasRenderingContext2D::GetImageRenderingQuality(nsAString& value)
+{
+    switch (CurrentState().imageRenderingQuality) {
+        case OptimizeQuality:
+            value.AssignLiteral("optimizeQuality");
+            break;
+        case OptimizeSpeed:
+            value.AssignLiteral("optimizeSpeed");
+            break;
+        default:
+        case Auto:
+            value.AssignLiteral("auto");
+            break;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsCanvasRenderingContext2D::SetImageRenderingQuality(const nsAString& value)
+{
+    ImageRenderingQuality irq;
+    if (value.EqualsLiteral("auto"))
+        irq = Auto;
+    else if (value.EqualsLiteral("optimizeQuality"))
+        irq = OptimizeQuality;
+    else if (value.EqualsLiteral("optimizeSpeed"))
+        irq = OptimizeSpeed;
+    else
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (CurrentState().imageRenderingQuality != irq) {
+        CurrentState().imageRenderingQuality = irq;
+        DirtyAllStyles();
+    }
+
+    return NS_OK;
+}
+
+void
+nsCanvasRenderingContext2D::ApplyQualityHints()
+{
+    nsRefPtr<gfxPattern> pat = new gfxPattern(mSurface);
+    if (CurrentState().imageRenderingQuality == OptimizeSpeed)
+        pat->SetFilter(0);
+    else if (CurrentState().imageRenderingQuality == OptimizeQuality)
+        pat->SetFilter(2);
+    else
+        pat->SetFilter(1);
+    mThebes->SetPattern(pat);
+}
+
 extern "C" {
 #include "jstypes.h"
 JS_FRIEND_API(JSBool)
 js_ArrayToJSUint8Buffer(JSContext *cx, JSObject *obj, jsuint offset, jsuint count,
                         JSUint8 *dest);
 }
 
 // void putImageData (in ImageData d, in float x, in float y);
Index: mozilla/content/canvas/test/test_2d.imageRenderingQuality.html
===================================================================
--- /dev/null
+++ mozilla/content/canvas/test/test_2d.imageRenderingQuality.html
@@ -0,0 +1,65 @@
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>Canvas test: 2d.imageRenderingQuality</title>
+<script src="/MochiKit/MochiKit.js"></script>
+<script src="/tests/SimpleTest/SimpleTest.js"></script>
+<script type="text/javascript">
+
+var _deferred = false;
+
+function setup() {
+  var c2 = document.getElementById("c2");
+  var cx2 = c2.getContext("2d");
+
+  cx2.fillStyle = "red";
+  cx2.fillRect(0, 0, 2, 2);
+
+  cx2.fillStyle = "rgb(0,255,0)";
+  cx2.fillRect(0, 0, 1, 1);
+}
+
+function f() {
+  setup();
+
+  var c = document.getElementById("c");
+  var c2 = document.getElementById("c2");
+
+  var cx = c.getContext("2d");
+
+  ok(cx.imageRenderingQuality == "auto", "initial imageRenderingQuality is auto");
+
+  // check that imageRenderingQuality is part of the context
+  cx.save();
+  cx.imageRenderingQuality = "optimizeSpeed";
+  ok(cx.imageRenderingQuality == "optimizeSpeed", "imageRenderingQuality is optimizeSpeed after setting");
+  cx.restore();
+  ok(cx.imageRenderingQuality == "auto", "imageRenderingQuality is auto after restore");
+
+  // check that optimizeSpeed works
+  cx.imageRenderingQuality = "optimizeSpeed";
+
+  cx.scale(10,10);
+  cx.drawImage(c2, 0, 0);
+
+  // this should be all red
+  var data = cx.getImageData(9, 9, 1, 1);
+  var pixels = data.data;
+  ok (pixels[0] == 0 &&
+      pixels[1] == 255 &&
+      pixels[2] == 0 &&
+      pixels[3] == 255,
+      "pixel is " + pixels.toSource() + " (expected [0,255,0,255])");
+
+  if (!_deferred) SimpleTest.finish();
+}
+
+SimpleTest.waitForExplicitFinish();
+MochiKit.DOM.addLoadEvent(f);
+</script>
+</head>
+<body>
+<canvas id="c" width="10" height="10"></canvas><br>
+<canvas style="visibility: hidden" id="c2" width="2" height="2"></canvas>
+</body>
+</html>
Index: mozilla/dom/public/idl/canvas/nsIDOMCanvasRenderingContext2D.idl
===================================================================
--- mozilla.orig/dom/public/idl/canvas/nsIDOMCanvasRenderingContext2D.idl
+++ mozilla/dom/public/idl/canvas/nsIDOMCanvasRenderingContext2D.idl
@@ -153,16 +153,20 @@
   // pixel manipulation
   // ImageData getImageData (in float x, in float y, in float width, in float height);
   // void putImageData (in ImageData d, in float x, in float y);
   // ImageData = { width: #, height: #, data: [r, g, b, a, ...] }
 
   void getImageData();
   void putImageData();
 
+  // image rendering quality hint, similar to SVG CSS 'image-rendering' property.
+  // 'auto', 'optimizeSpeed', 'optimizeQuality'.  Default 'auto'.
+  attribute DOMString imageRenderingQuality;
+
   // ImageData createImageData(in float w, in float h);
   void createImageData();
 
   /**
    * Renders a region of a window into the canvas.  The contents of
    * the window's viewport are rendered, ignoring viewport clipping
    * and scrolling.
    *
