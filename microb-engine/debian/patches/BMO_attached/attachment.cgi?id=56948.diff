#From: L. David Baron <dbaron@dbaron.org>
#
#Don't reduce the height we're checking while we reflow for floats.  (Bug 494332)
#
diff --git a/layout/generic/crashtests/494332-1.html b/layout/generic/crashtests/494332-1.html
new file mode 100644
--- /dev/null
+++ b/layout/generic/crashtests/494332-1.html
@@ -0,0 +1,7 @@
+<html>
+<head>
+</head>
+<body>
+<div style="width: 1ch;"><div style="height: 2em;">1 2<div style="float: left; padding: 0pt 1px; display: list-item;"></div></div><span></span> g h i</div>
+</body>
+</html>
diff --git a/layout/generic/crashtests/crashtests.list b/layout/generic/crashtests/crashtests.list
--- a/layout/generic/crashtests/crashtests.list
+++ b/layout/generic/crashtests/crashtests.list
@@ -209,8 +209,9 @@ load 463741-1.html
 load 465651-1.html
 load 467487-1.html
 load 468207-1.html
 load 472774-1.html
 load 472776-1.html
 load 472950-1.html
 load 477928.html
 load 480345-1.html
+load 494332-1.html
diff --git a/layout/generic/nsBlockFrame.cpp b/layout/generic/nsBlockFrame.cpp
--- a/layout/generic/nsBlockFrame.cpp
+++ b/layout/generic/nsBlockFrame.cpp
@@ -3407,78 +3407,83 @@ nsBlockFrame::ReflowInlineFrames(nsBlock
   }
   nsFlowAreaRect floatAvailableSpace = aState.GetFloatAvailableSpace();
 
 #ifdef DEBUG
   PRInt32 spins = 0;
 #endif
   LineReflowStatus lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
   do {
-    PRBool allowPullUp = PR_TRUE;
-    nsIContent* forceBreakInContent = nsnull;
-    PRInt32 forceBreakOffset = -1;
-    gfxBreakPriority forceBreakPriority = eNoBreak;
+    nscoord availableSpaceHeight = 0;
     do {
-      nsFloatManager::SavedState floatManagerState;
-      aState.mReflowState.mFloatManager->PushState(&floatManagerState);
-
-      // Once upon a time we allocated the first 30 nsLineLayout objects
-      // on the stack, and then we switched to the heap.  At that time
-      // these objects were large (1100 bytes on a 32 bit system).
-      // Then the nsLineLayout object was shrunk to 156 bytes by
-      // removing some internal buffers.  Given that it is so much
-      // smaller, the complexity of 2 different ways of allocating
-      // no longer makes sense.  Now we always allocate on the stack.
-      nsLineLayout lineLayout(aState.mPresContext,
-                              aState.mReflowState.mFloatManager,
-                              &aState.mReflowState, &aLine);
-      lineLayout.Init(&aState, aState.mMinLineHeight, aState.mLineNumber);
-      if (forceBreakInContent) {
-        lineLayout.ForceBreakAtPosition(forceBreakInContent, forceBreakOffset);
-      }
-      rv = DoReflowInlineFrames(aState, lineLayout, aLine,
-                                floatAvailableSpace, &floatManagerState,
-                                aKeepReflowGoing, &lineReflowStatus,
-                                allowPullUp);
-      lineLayout.EndLineReflow();
-
-      if (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus ||
-          LINE_REFLOW_REDO_MORE_FLOATS == lineReflowStatus ||
-          LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
-        if (lineLayout.NeedsBackup()) {
-          NS_ASSERTION(!forceBreakInContent, "Backing up twice; this should never be necessary");
-          // If there is no saved break position, then this will set
-          // set forceBreakInContent to null and we won't back up, which is
-          // correct.
-          forceBreakInContent = lineLayout.GetLastOptionalBreakPosition(&forceBreakOffset, &forceBreakPriority);
-        } else {
-          forceBreakInContent = nsnull;
-        }
-        // restore the float manager state
-        aState.mReflowState.mFloatManager->PopState(&floatManagerState);
-        // Clear out float lists
-        aState.mCurrentLineFloats.DeleteAll();
-        aState.mBelowCurrentLineFloats.DeleteAll();
-      }
-      
-#ifdef DEBUG
-      spins++;
-      if (1000 == spins) {
-        ListTag(stdout);
-        printf(": yikes! spinning on a line over 1000 times!\n");
-        NS_ABORT();
-      }
-#endif
-
-      // Don't allow pullup on a subsequent LINE_REFLOW_REDO_NO_PULL pass
-      allowPullUp = PR_FALSE;
-    } while (NS_SUCCEEDED(rv) && LINE_REFLOW_REDO_NO_PULL == lineReflowStatus);
-  } while (NS_SUCCEEDED(rv) &&
-           (LINE_REFLOW_REDO_MORE_FLOATS == lineReflowStatus ||
-            LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus));
+      PRBool allowPullUp = PR_TRUE;
+      nsIContent* forceBreakInContent = nsnull;
+      PRInt32 forceBreakOffset = -1;
+      gfxBreakPriority forceBreakPriority = eNoBreak;
+      do {
+        nsFloatManager::SavedState floatManagerState;
+        aState.mReflowState.mFloatManager->PushState(&floatManagerState);
+
+        // Once upon a time we allocated the first 30 nsLineLayout objects
+        // on the stack, and then we switched to the heap.  At that time
+        // these objects were large (1100 bytes on a 32 bit system).
+        // Then the nsLineLayout object was shrunk to 156 bytes by
+        // removing some internal buffers.  Given that it is so much
+        // smaller, the complexity of 2 different ways of allocating
+        // no longer makes sense.  Now we always allocate on the stack.
+        nsLineLayout lineLayout(aState.mPresContext,
+                                aState.mReflowState.mFloatManager,
+                                &aState.mReflowState, &aLine);
+        lineLayout.Init(&aState, aState.mMinLineHeight, aState.mLineNumber);
+        if (forceBreakInContent) {
+          lineLayout.ForceBreakAtPosition(forceBreakInContent, forceBreakOffset);
+        }
+        rv = DoReflowInlineFrames(aState, lineLayout, aLine,
+                                  floatAvailableSpace, availableSpaceHeight,
+                                  &floatManagerState, aKeepReflowGoing,
+                                  &lineReflowStatus, allowPullUp);
+        lineLayout.EndLineReflow();
+
+        if (NS_FAILED(rv)) {
+          return rv;
+        }
+
+        if (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus ||
+            LINE_REFLOW_REDO_MORE_FLOATS == lineReflowStatus ||
+            LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
+          if (lineLayout.NeedsBackup()) {
+            NS_ASSERTION(!forceBreakInContent, "Backing up twice; this should never be necessary");
+            // If there is no saved break position, then this will set
+            // set forceBreakInContent to null and we won't back up, which is
+            // correct.
+            forceBreakInContent = lineLayout.GetLastOptionalBreakPosition(&forceBreakOffset, &forceBreakPriority);
+          } else {
+            forceBreakInContent = nsnull;
+          }
+          // restore the float manager state
+          aState.mReflowState.mFloatManager->PopState(&floatManagerState);
+          // Clear out float lists
+          aState.mCurrentLineFloats.DeleteAll();
+          aState.mBelowCurrentLineFloats.DeleteAll();
+        }
+        
+  #ifdef DEBUG
+        spins++;
+        if (1000 == spins) {
+          ListTag(stdout);
+          printf(": yikes! spinning on a line over 1000 times!\n");
+          NS_ABORT();
+        }
+  #endif
+
+        // Don't allow pullup on a subsequent LINE_REFLOW_REDO_NO_PULL pass
+        allowPullUp = PR_FALSE;
+      } while (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus);
+    } while (LINE_REFLOW_REDO_MORE_FLOATS == lineReflowStatus);
+  } while (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus);
 
   return rv;
 }
 
 // If at least one float on the line was complete, not at the top of
 // page, but was truncated, then restore the overflow floats to what
 // they were before and push the line.  The floats that will be removed
 // from the list aren't yet known by the block's next in flow.  
@@ -3502,16 +3507,17 @@ static const char* LineReflowStatusNames
 };
 #endif
 
 nsresult
 nsBlockFrame::DoReflowInlineFrames(nsBlockReflowState& aState,
                                    nsLineLayout& aLineLayout,
                                    line_iterator aLine,
                                    nsFlowAreaRect& aFloatAvailableSpace,
+                                   nscoord& aAvailableSpaceHeight,
                                    nsFloatManager::SavedState*
                                      aFloatStateBeforeLine,
                                    PRBool* aKeepReflowGoing,
                                    LineReflowStatus* aLineReflowStatus,
                                    PRBool aAllowPullUp)
 {
   // Forget all of the floats on the line
   aLine->FreeFloats(aState.mFloatCacheFreeList);
@@ -3714,17 +3720,18 @@ nsBlockFrame::DoReflowInlineFrames(nsBlo
     // past the float.
   }
   else if (LINE_REFLOW_TRUNCATED != lineReflowStatus &&
            LINE_REFLOW_REDO_NO_PULL != lineReflowStatus) {
     // If we are propagating out a break-before status then there is
     // no point in placing the line.
     if (!NS_INLINE_IS_BREAK_BEFORE(aState.mReflowStatus)) {
       if (!PlaceLine(aState, aLineLayout, aLine, aFloatStateBeforeLine,
-                     aFloatAvailableSpace.mRect, aKeepReflowGoing)) {
+                     aFloatAvailableSpace.mRect, aAvailableSpaceHeight,
+                     aKeepReflowGoing)) {
         lineReflowStatus = LINE_REFLOW_REDO_MORE_FLOATS;
         // PlaceLine already called GetAvailableSpaceForHeight for us.
       }
     }
   }
 #ifdef DEBUG
   if (gNoisyReflow) {
     printf("Line reflow status = %s\n", LineReflowStatusNames[lineReflowStatus]);
@@ -4103,16 +4110,17 @@ nsBlockFrame::ShouldJustifyLine(nsBlockR
 }
 
 PRBool
 nsBlockFrame::PlaceLine(nsBlockReflowState& aState,
                         nsLineLayout&       aLineLayout,
                         line_iterator       aLine,
                         nsFloatManager::SavedState *aFloatStateBeforeLine,
                         nsRect&             aFloatAvailableSpace,
+                        nscoord&            aAvailableSpaceHeight,
                         PRBool*             aKeepReflowGoing)
 {
   // Trim extra white-space from the line before placing the frames
   aLineLayout.TrimTrailingWhiteSpace();
 
   // Vertically align the frames on this line.
   //
   // According to the CSS2 spec, section 12.6.1, the "marker" box
@@ -4137,19 +4145,22 @@ nsBlockFrame::PlaceLine(nsBlockReflowSta
   aLineLayout.VerticalAlignLine();
 
   // We want to compare to the available space that we would have had in
   // the line's height *before* we placed any floats in the line itself.
   // Floats that are in the line are handled during line reflow (and may
   // result in floats being pushed to below the line or (I HOPE???) in a
   // reflow with a forced break position).
   nsRect oldFloatAvailableSpace(aFloatAvailableSpace);
+  // As we redo for floats, we can't reduce the amount of height we're
+  // checking.
+  aAvailableSpaceHeight = PR_MAX(aAvailableSpaceHeight, aLine->mBounds.height);
   aFloatAvailableSpace = 
     aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y,
-                                           aLine->mBounds.height,
+                                           aAvailableSpaceHeight,
                                            aFloatStateBeforeLine).mRect;
   NS_ASSERTION(aFloatAvailableSpace.y == oldFloatAvailableSpace.y, "yikes");
   // Restore the height to the position of the next band.
   aFloatAvailableSpace.height = oldFloatAvailableSpace.height;
   // If the available space between the floats is smaller now that we
   // know the height, return false (and cause another pass with
   // LINE_REFLOW_REDO_MORE_FLOATS).
   if (AvailableSpaceShrunk(oldFloatAvailableSpace, aFloatAvailableSpace)) {
diff --git a/layout/generic/nsBlockFrame.h b/layout/generic/nsBlockFrame.h
--- a/layout/generic/nsBlockFrame.h
+++ b/layout/generic/nsBlockFrame.h
@@ -487,16 +487,17 @@ protected:
   // Return false if it needs another reflow because of reduced space
   // between floats that are next to it (but not next to its top), and
   // return true otherwise.
   PRBool PlaceLine(nsBlockReflowState& aState,
                    nsLineLayout&       aLineLayout,
                    line_iterator       aLine,
                    nsFloatManager::SavedState* aFloatStateBeforeLine,
                    nsRect&             aFloatAvailableSpace, /* in-out */
+                   nscoord&            aAvailableSpaceHeight, /* in-out */
                    PRBool*             aKeepReflowGoing);
 
   /**
    * Mark |aLine| dirty, and, if necessary because of possible
    * pull-up, mark the previous line dirty as well. Also invalidates textruns
    * on those lines because the text in the lines might have changed due to
    * addition/removal of frames.
    * @param aLine the line to mark dirty
@@ -527,16 +528,17 @@ protected:
   nsresult ReflowInlineFrames(nsBlockReflowState& aState,
                               line_iterator aLine,
                               PRBool* aKeepLineGoing);
 
   nsresult DoReflowInlineFrames(nsBlockReflowState& aState,
                                 nsLineLayout& aLineLayout,
                                 line_iterator aLine,
                                 nsFlowAreaRect& aFloatAvailableSpace,
+                                nscoord& aAvailableSpaceHeight,
                                 nsFloatManager::SavedState*
                                   aFloatStateBeforeLine,
                                 PRBool* aKeepReflowGoing,
                                 LineReflowStatus* aLineReflowStatus,
                                 PRBool aAllowPullUp);
 
   nsresult ReflowInlineFrame(nsBlockReflowState& aState,
                              nsLineLayout& aLineLayout,
