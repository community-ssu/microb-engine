# API for improving fingerability
#https://projects.maemo.org/bugzilla/show_bug.cgi?id=132170
diff -r d17589c2203a layout/base/nsIPresShell.h
--- a/layout/base/nsIPresShell.h	Sun Aug 09 20:29:55 2009 +0300
+++ b/layout/base/nsIPresShell.h	Mon Aug 10 15:06:20 2009 +0300
@@ -64,6 +64,7 @@
 #include "mozFlushType.h"
 #include "nsWeakReference.h"
 #include <stdio.h> // for FILE definition
+#include "nsTArray.h"
 
 class nsIAtom;
 class nsIContent;
@@ -97,14 +98,16 @@ class nsIScrollableFrame;
 class gfxASurface;
 class gfxContext;
 class nsPIDOMEventTarget;
+class nsISupportsArray;
 
 typedef short SelectionType;
 typedef PRUint32 nsFrameState;
 
 // 41FE90F8-88DF-476E-A3B0-60916234F791
+// 1d3cff4d-acf2-4bed-bc87-f5369efd588f
 #define NS_IPRESSHELL_IID \
-{ 0x41fe90f8, 0x88df, 0x476e, \
-  { 0xa3, 0xb0, 0x60, 0x91, 0x62, 0x34, 0xf7, 0x91 } }
+{ 0x1d3cff4d, 0xacf2, 0x4bed, \
+  { 0xbc, 0x87, 0xf5, 0x36, 0x9e, 0xfd, 0x58, 0x8f } }
 
 // Constants for ScrollContentIntoView() function
 #define NS_PRESSHELL_SCROLL_TOP      0
@@ -821,6 +824,11 @@ public:
     return mObservesMutationsForPrint;
   }
 
+  NS_IMETHOD GetNodesForArea(nsRect aRect, nsISupportsArray **aOutNodes,
+                             const nsTArray<nsPoint> *aPoints = nsnull,
+                             PRBool aShouldIgnoreSuppression = PR_FALSE,
+                             PRBool aIgnoreRootScrollFrame = PR_FALSE) = 0;
+
 protected:
   // IMPORTANT: The ownership implicit in the following member variables
   // has been explicitly checked.  If you add any members to this class,
diff -r d17589c2203a layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp	Sun Aug 09 20:29:55 2009 +0300
+++ b/layout/base/nsLayoutUtils.cpp	Mon Aug 10 15:06:20 2009 +0300
@@ -942,6 +942,65 @@ nsLayoutUtils::GetFrameForPoint(nsIFrame
   return result;
 }
 
+nsresult
+nsLayoutUtils::GetFramesForArea(nsIFrame* aFrame, nsRect aRect,
+                                nsTArray<nsIFrame*> &aOutFrames,
+                                const nsTArray<nsPoint> *aPoints,
+                                PRBool aShouldIgnoreSuppression,
+                                PRBool aIgnoreRootScrollFrame)
+{
+  nsDisplayListBuilder builder(aFrame, PR_TRUE, PR_FALSE);
+  nsDisplayList list;
+
+  if (aShouldIgnoreSuppression)
+    builder.IgnorePaintSuppression();
+
+  if (aIgnoreRootScrollFrame) {
+    nsIFrame* rootScrollFrame =
+      aFrame->PresContext()->PresShell()->GetRootScrollFrame();
+    if (rootScrollFrame) {
+      builder.SetIgnoreScrollFrame(rootScrollFrame);
+    }
+  }
+
+  builder.EnterPresShell(aFrame, aRect);
+
+  nsresult rv =
+    aFrame->BuildDisplayListForStackingContext(&builder, aRect, &list);
+
+  builder.LeavePresShell(aFrame, aRect);
+  NS_ENSURE_SUCCESS(rv, nsnull);
+
+  if (aPoints) {
+    PRUint32 index;
+    for (index = 0; index < aPoints->Length(); index++) {
+      nsPoint pt = aPoints->ElementAt(index);
+      pt.x = nsPresContext::CSSPixelsToAppUnits(pt.x);
+      pt.y = nsPresContext::CSSPixelsToAppUnits(pt.y);
+      nsDisplayItem::HitTestState hitTestState;
+      nsIFrame* result = list.HitTest(&builder, pt, &hitTestState);
+      if (result && !aOutFrames.Contains(result))
+        aOutFrames.AppendElement(result);
+    }
+  } else {
+    nsDisplayItem::HitTestState hitTestState;
+    // Insert center rect point as first
+    nsPoint pt(aRect.x + aRect.width/2, aRect.y + aRect.height/2);
+    nsIFrame* result = list.HitTest(&builder, pt, &hitTestState);
+    aOutFrames.AppendElement(result);
+    // Append the rest of elements
+    for (nsDisplayItem* i = list.GetBottom(); i != nsnull; i = i->GetAbove()) {
+      nsIFrame* f = i->GetUnderlyingFrame();
+      if (f && !aOutFrames.Contains(f))
+        aOutFrames.AppendElement(f);
+    }
+  }
+
+  list.DeleteAll();
+  return NS_OK;
+}
+
+
 /**
  * Remove all leaf display items that are not for descendants of
  * aBuilder->GetReferenceFrame() from aList, and move all nsDisplayClip
diff -r d17589c2203a layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h	Sun Aug 09 20:29:55 2009 +0300
+++ b/layout/base/nsLayoutUtils.h	Mon Aug 10 15:06:20 2009 +0300
@@ -417,6 +417,12 @@ public:
                                     PRBool aShouldIgnoreSuppression = PR_FALSE,
                                     PRBool aIgnoreRootScrollFrame = PR_FALSE);
 
+  static nsresult GetFramesForArea(nsIFrame* aFrame, nsRect aRect,
+                                   nsTArray<nsIFrame*> &aOutFrames,
+                                   const nsTArray<nsPoint> *aPoints = nsnull,
+                                   PRBool aShouldIgnoreSuppression = PR_FALSE,
+                                   PRBool aIgnoreRootScrollFrame = PR_FALSE);
+
   /**
    * Given a point in the global coordinate space, returns that point expressed
    * in the coordinate system of aFrame.  This effectively inverts all transforms
diff -r d17589c2203a layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp	Sun Aug 09 20:29:55 2009 +0300
+++ b/layout/base/nsPresShell.cpp	Mon Aug 10 15:06:20 2009 +0300
@@ -208,6 +208,7 @@
 #include "nsIContentViewer.h"
 #include "imgIEncoder.h"
 #include "gfxPlatform.h"
+#include "nsIMutableArray.h"
 
 #include "nsContentCID.h"
 static NS_DEFINE_CID(kCSSStyleSheetCID, NS_CSS_STYLESHEET_CID);
@@ -1026,6 +1027,11 @@ public:
 
   virtual void UpdateCanvasBackground();
 
+  NS_IMETHOD GetNodesForArea(nsRect aRect, nsISupportsArray **aOutNodes,
+                             const nsTArray<nsPoint> *aPoints = nsnull,
+                             PRBool aShouldIgnoreSuppression = PR_FALSE,
+                             PRBool aIgnoreRootScrollFrame = PR_FALSE);
+
 protected:
   virtual ~PresShell();
 
@@ -3240,6 +3246,105 @@ PresShell::GetFrameForPoint(nsIFrame* aF
   return nsLayoutUtils::GetFrameForPoint(aFrame, aPt);
 }
 
+static nsresult
+CheckAncestryAndGetFrame(nsIDocument *thisDocument, nsIDocument* aDocument, nsIContent **aContent)
+{
+  nsIDocument* parentDoc;
+  for (parentDoc = aDocument->GetParentDocument();
+       parentDoc != static_cast<const nsIDocument* const>(thisDocument);
+       parentDoc = parentDoc->GetParentDocument()) {
+    if (!parentDoc)
+      return NS_ERROR_FAILURE;
+
+    aDocument = parentDoc;
+  }
+
+  // In a child document.  Get the appropriate frame.
+  nsPIDOMWindow* currentWindow = aDocument->GetWindow();
+  if (!currentWindow)
+    return NS_ERROR_FAILURE;
+
+  nsIDOMElement* frameElement = currentWindow->GetFrameElementInternal();
+  if (!frameElement)
+    return NS_ERROR_FAILURE;
+
+  // Sanity check result
+  nsCOMPtr<nsIDOMDocument> domDocument;
+  frameElement->GetOwnerDocument(getter_AddRefs(domDocument));
+  nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(thisDocument);
+  if (domDocument != doc) {
+    NS_ERROR("Child documents should live in windows the parent owns");
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIContent> content = do_QueryInterface(frameElement);
+  NS_ADDREF(*aContent = content);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+PresShell::GetNodesForArea(nsRect aRect, nsISupportsArray **aOutNodes,
+                           const nsTArray<nsPoint> *aPoints,
+                           PRBool aShouldIgnoreSuppression,
+                           PRBool aIgnoreRootScrollFrame)
+{
+  NS_ENSURE_ARG_POINTER(aOutNodes);
+
+  nsIFrame *rootFrame = GetRootFrame();
+
+  // XUL docs, unlike HTML, have no frame tree until everything's done loading
+  if (!rootFrame)
+    return NS_OK; // return null to premature XUL callers as a reminder to wait
+
+  nsTArray<nsIFrame*> frames;
+
+  nsRect rect(nsPresContext::CSSPixelsToAppUnits(aRect.x),
+              nsPresContext::CSSPixelsToAppUnits(aRect.y),
+              nsPresContext::CSSPixelsToAppUnits(aRect.width),
+              nsPresContext::CSSPixelsToAppUnits(aRect.height));
+
+  nsLayoutUtils::GetFramesForArea(rootFrame, rect, frames, aPoints, aShouldIgnoreSuppression, aIgnoreRootScrollFrame);
+  if (!frames.Length())
+    return NS_OK;
+
+  nsCOMPtr<nsISupportsArray> nodes;
+  NS_NewISupportsArray(getter_AddRefs(nodes));
+  if (!nodes) return NS_ERROR_OUT_OF_MEMORY;
+  
+  PRUint32 index;
+  for (index = 0; index < frames.Length(); index++) {
+    nsCOMPtr<nsIContent> ptContent = frames.ElementAt(index)->GetContent();
+    if (!ptContent)
+      continue;
+
+    // If the content is in a subdocument, try to get the element from |this| doc
+    nsIDocument *currentDoc = ptContent->GetCurrentDoc();
+    if (currentDoc && (currentDoc != mDocument)) {
+      nsCOMPtr<nsIContent> content;
+      CheckAncestryAndGetFrame(mDocument, currentDoc, getter_AddRefs(content));
+      if (-1 == nodes->IndexOf(content))
+        nodes->AppendElement(content);
+      continue;
+    }
+
+    // If we have an anonymous element (such as an internal div from a textbox),
+    // or a node that isn't an element (such as a text frame node),
+    // replace it with the first non-anonymous parent node of type element.
+    while (ptContent &&
+           (!ptContent->IsNodeOfType(nsINode::eELEMENT) ||
+            ptContent->IsInAnonymousSubtree())) {
+      // XXXldb: Faster to jump to GetBindingParent if non-null?
+      ptContent = ptContent->GetParent();
+    }
+
+    if (-1 == nodes->IndexOf(ptContent))
+      nodes->AppendElement(ptContent);
+  }
+  NS_ADDREF(*aOutNodes = nodes);
+
+  return NS_OK;
+}
+
 void
 PresShell::BeginUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
 {
