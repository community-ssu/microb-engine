Index: mozilla/content/base/src/nsContentUtils.cpp
===================================================================
--- mozilla.orig/content/base/src/nsContentUtils.cpp
+++ mozilla/content/base/src/nsContentUtils.cpp
@@ -439,29 +439,29 @@
     { &nsGkAtoms::ondragdrop,                    { NS_DRAGDROP_DRAGDROP, EventNameType_XUL }},
     { &nsGkAtoms::ondraggesture,                 { NS_DRAGDROP_GESTURE, EventNameType_XUL }},
     { &nsGkAtoms::ondrag,                        { NS_DRAGDROP_DRAG, EventNameType_HTMLXUL }},
     { &nsGkAtoms::ondragend,                     { NS_DRAGDROP_END, EventNameType_HTMLXUL }},
     { &nsGkAtoms::ondragstart,                   { NS_DRAGDROP_START, EventNameType_HTMLXUL }},
     { &nsGkAtoms::ondragleave,                   { NS_DRAGDROP_LEAVE_SYNTH, EventNameType_HTMLXUL }},
     { &nsGkAtoms::ondrop,                        { NS_DRAGDROP_DROP, EventNameType_HTMLXUL }},
     { &nsGkAtoms::onoverflow,                    { NS_SCROLLPORT_OVERFLOW, EventNameType_XUL }},
-    { &nsGkAtoms::onunderflow,                   { NS_SCROLLPORT_UNDERFLOW, EventNameType_XUL }}
+    { &nsGkAtoms::onunderflow,                   { NS_SCROLLPORT_UNDERFLOW, EventNameType_XUL }},
 #ifdef MOZ_SVG
-   ,{ &nsGkAtoms::onSVGLoad,                     { NS_SVG_LOAD, EventNameType_None }},
+    { &nsGkAtoms::onSVGLoad,                     { NS_SVG_LOAD, EventNameType_None }},
     { &nsGkAtoms::onSVGUnload,                   { NS_SVG_UNLOAD, EventNameType_None }},
     { &nsGkAtoms::onSVGAbort,                    { NS_SVG_ABORT, EventNameType_None }},
     { &nsGkAtoms::onSVGError,                    { NS_SVG_ERROR, EventNameType_None }},
     { &nsGkAtoms::onSVGResize,                   { NS_SVG_RESIZE, EventNameType_None }},
     { &nsGkAtoms::onSVGScroll,                   { NS_SVG_SCROLL, EventNameType_None }},
     { &nsGkAtoms::onSVGZoom,                     { NS_SVG_ZOOM, EventNameType_None }},
-    { &nsGkAtoms::onzoom,                        { NS_SVG_ZOOM, EventNameType_SVGSVG }}
+    { &nsGkAtoms::onzoom,                        { NS_SVG_ZOOM, EventNameType_SVGSVG }},
 #endif // MOZ_SVG
 #ifdef MOZ_MEDIA 
-   ,{ &nsGkAtoms::onloadstart,                   { NS_LOADSTART, EventNameType_HTML }},
+    { &nsGkAtoms::onloadstart,                   { NS_LOADSTART, EventNameType_HTML }},
     { &nsGkAtoms::onprogress,                    { NS_PROGRESS, EventNameType_HTML }},
     { &nsGkAtoms::onloadedmetadata,              { NS_LOADEDMETADATA, EventNameType_HTML }},
     { &nsGkAtoms::onloadedfirstframe,            { NS_LOADEDFIRSTFRAME, EventNameType_HTML }},
     { &nsGkAtoms::onemptied,                     { NS_EMPTIED, EventNameType_HTML }},
     { &nsGkAtoms::onstalled,                     { NS_STALLED, EventNameType_HTML }},
     { &nsGkAtoms::onplay,                        { NS_PLAY, EventNameType_HTML }},
     { &nsGkAtoms::onpause,                       { NS_PAUSE, EventNameType_HTML }},
     { &nsGkAtoms::onwaiting,                     { NS_WAITING, EventNameType_HTML }},
@@ -472,16 +472,17 @@
     { &nsGkAtoms::ondataunavailable,             { NS_DATAUNAVAILABLE, EventNameType_HTML }},
     { &nsGkAtoms::oncanshowcurrentframe,         { NS_CANSHOWCURRENTFRAME, EventNameType_HTML }},
     { &nsGkAtoms::oncanplay,                     { NS_CANPLAY, EventNameType_HTML }},
     { &nsGkAtoms::oncanplaythrough,              { NS_CANPLAYTHROUGH, EventNameType_HTML }},
     { &nsGkAtoms::onratechange,                  { NS_RATECHANGE, EventNameType_HTML }},
     { &nsGkAtoms::ondurationchange,              { NS_DURATIONCHANGE, EventNameType_HTML }},
     { &nsGkAtoms::onvolumechange,                { NS_VOLUMECHANGE, EventNameType_HTML }},
 #endif //MOZ_MEDIA
+    { &nsGkAtoms::onMozAfterPaint,               { NS_AFTERPAINT, EventNameType_None }}
   };
 
   sEventTable = new nsDataHashtable<nsISupportsHashKey, EventNameMapping>;
   if (!sEventTable ||
       !sEventTable->Init(int(NS_ARRAY_LENGTH(eventArray) / 0.75) + 1)) {
     delete sEventTable;
     sEventTable = nsnull;
     return PR_FALSE;
Index: mozilla/content/base/src/nsGenericElement.cpp
===================================================================
--- mozilla.orig/content/base/src/nsGenericElement.cpp
+++ mozilla/content/base/src/nsGenericElement.cpp
@@ -1284,38 +1284,16 @@
   while (aFrame->GetParent() &&
          !aFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)) {
     aFrame = aFrame->GetParent();
   }
 
   return aFrame;
 }
 
-static double
-RoundFloat(double aValue)
-{
-  return floor(aValue + 0.5);
-}
-
-static void
-SetClientRect(const nsRect& aLayoutRect, nsPresContext* aPresContext,
-              nsClientRect* aRect)
-{
-  double scale = 65536.0;
-  // Round to the nearest 1/scale units. We choose scale so it can be represented
-  // exactly by machine floating point.
-  double scaleInv = 1/scale;
-  double t2pScaled = scale/aPresContext->AppUnitsPerCSSPixel();
-  double x = RoundFloat(aLayoutRect.x*t2pScaled)*scaleInv;
-  double y = RoundFloat(aLayoutRect.y*t2pScaled)*scaleInv;
-  aRect->SetRect(x, y,
-                 RoundFloat(aLayoutRect.XMost()*t2pScaled)*scaleInv - x,
-                 RoundFloat(aLayoutRect.YMost()*t2pScaled)*scaleInv - y);
-}
-
 NS_IMETHODIMP
 nsNSElementTearoff::GetBoundingClientRect(nsIDOMClientRect** aResult)
 {
   // Weak ref, since we addref it below
   nsClientRect* rect = new nsClientRect();
   if (!rect)
     return NS_ERROR_OUT_OF_MEMORY;
 
@@ -1325,17 +1303,17 @@
   if (!frame) {
     // display:none, perhaps? Return the empty rect
     return NS_OK;
   }
 
   nsPresContext* presContext = frame->PresContext();
   nsRect r = nsLayoutUtils::GetAllInFlowRectsUnion(frame,
           GetContainingBlockForClientRect(frame));
-  SetClientRect(r, presContext, rect);
+  rect->SetLayoutRect(r, presContext);
   return NS_OK;
 }
 
 struct RectListBuilder : public nsLayoutUtils::RectCallback {
   nsPresContext*    mPresContext;
   nsClientRectList* mRectList;
   nsresult          mRV;
 
@@ -1345,17 +1323,17 @@
 
   virtual void AddRect(const nsRect& aRect) {
     nsRefPtr<nsClientRect> rect = new nsClientRect();
     if (!rect) {
       mRV = NS_ERROR_OUT_OF_MEMORY;
       return;
     }
     
-    SetClientRect(aRect, mPresContext, rect);
+    rect->SetLayoutRect(aRect, mPresContext);
     mRectList->Append(rect);
   }
 };
 
 NS_IMETHODIMP
 nsNSElementTearoff::GetClientRects(nsIDOMClientRectList** aResult)
 {
   *aResult = nsnull;
Index: mozilla/content/base/src/nsGkAtomList.h
===================================================================
--- mozilla.orig/content/base/src/nsGkAtomList.h
+++ mozilla/content/base/src/nsGkAtomList.h
@@ -637,16 +637,17 @@
 GK_ATOM(onload, "onload")
 GK_ATOM(only, "only")               // this one is not an event
 GK_ATOM(onmousedown, "onmousedown")
 GK_ATOM(onmousemove, "onmousemove")
 GK_ATOM(onmouseout, "onmouseout")
 GK_ATOM(onmouseover, "onmouseover")
 GK_ATOM(onmouseup, "onmouseup")
 GK_ATOM(onMozMousePixelScroll, "onMozMousePixelScroll")
+GK_ATOM(onMozAfterPaint, "onMozAfterPaint")
 GK_ATOM(ononline, "ononline")
 GK_ATOM(onoffline, "onoffline")
 GK_ATOM(onoverflow, "onoverflow")
 GK_ATOM(onoverflowchanged, "onoverflowchanged")
 GK_ATOM(onpagehide, "onpagehide")
 GK_ATOM(onpageshow, "onpageshow")
 GK_ATOM(onpaint, "onpaint")
 GK_ATOM(onpaste, "onpaste")
Index: mozilla/content/events/public/nsIPrivateDOMEvent.h
===================================================================
--- mozilla.orig/content/events/public/nsIPrivateDOMEvent.h
+++ mozilla/content/events/public/nsIPrivateDOMEvent.h
@@ -105,9 +105,11 @@
 nsresult
 NS_NewDOMXULCommandEvent(nsIDOMEvent** aResult, nsPresContext* aPresContext, class nsXULCommandEvent* aEvent);
 nsresult
 NS_NewDOMCommandEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, nsCommandEvent* aEvent);
 nsresult
 NS_NewDOMMessageEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, class nsEvent* aEvent);
 nsresult
 NS_NewDOMProgressEvent(nsIDOMEvent** aInstancePtrResult, nsPresContext* aPresContext, class nsEvent* aEvent);
+nsresult
+NS_NewDOMNotifyPaintEvent(nsIDOMEvent** aResult, nsPresContext* aPresContext, class nsNotifyPaintEvent* aEvent);
 #endif // nsIPrivateDOMEvent_h__
Index: mozilla/content/events/src/Makefile.in
===================================================================
--- mozilla.orig/content/events/src/Makefile.in
+++ mozilla/content/events/src/Makefile.in
@@ -89,16 +89,17 @@
 		nsXMLEventsManager.cpp \
 		nsXMLEventsElement.cpp \
 		nsPLDOMEvent.cpp \
 		nsEventDispatcher.cpp \
 		nsIMEStateManager.cpp \
 		nsQueryContentEventHandler.cpp \
 		nsDOMProgressEvent.cpp \
 		nsDOMDataTransfer.cpp \
+		nsDOMNotifyPaintEvent.cpp \
 		$(NULL)
 
 # we don't want the shared lib, but we want to force the creation of a static lib.
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	= \
Index: mozilla/content/events/src/nsDOMEvent.cpp
===================================================================
--- mozilla.orig/content/events/src/nsDOMEvent.cpp
+++ mozilla/content/events/src/nsDOMEvent.cpp
@@ -66,30 +66,29 @@
   "dragenter", "dragover", "dragexit", "dragdrop", "draggesture",
   "drag", "dragend", "dragstart", "dragleave", "drop", "resize",
   "scroll", "overflow", "underflow", "overflowchanged",
   "DOMSubtreeModified", "DOMNodeInserted", "DOMNodeRemoved", 
   "DOMNodeRemovedFromDocument", "DOMNodeInsertedIntoDocument",
   "DOMAttrModified", "DOMCharacterDataModified",
   "DOMActivate", "DOMFocusIn", "DOMFocusOut",
   "pageshow", "pagehide", "DOMMouseScroll", "MozMousePixelScroll",
-  "offline", "online", "copy", "cut", "paste"
+  "offline", "online", "copy", "cut", "paste",
 #ifdef MOZ_SVG
- ,
   "SVGLoad", "SVGUnload", "SVGAbort", "SVGError", "SVGResize", "SVGScroll",
-  "SVGZoom"
+  "SVGZoom",
 #endif // MOZ_SVG
 #ifdef MOZ_MEDIA
-  ,
   "loadstart", "progress", "loadedmetadata", "loadedfirstframe",
   "emptied", "stalled", "play", "pause",
   "waiting", "seeking", "seeked", "timeupdate", "ended", "dataunavailable",
   "canshowcurrentframe", "canplay", "canplaythrough", "ratechange",
-  "durationchange", "volumechange"
+  "durationchange", "volumechange",
 #endif // MOZ_MEDIA
+  "MozAfterPaint"
 };
 
 static char *sPopupAllowedEvents;
 
 
 nsDOMEvent::nsDOMEvent(nsPresContext* aPresContext, nsEvent* aEvent)
 {
   mPresContext = aPresContext;
@@ -650,16 +649,21 @@
     else if (atom == nsGkAtoms::onload)
       mEvent->message = NS_LOAD;
     else if (atom == nsGkAtoms::onabort)
       mEvent->message = NS_MEDIA_ABORT;
     else if (atom == nsGkAtoms::onerror)
       mEvent->message = NS_MEDIA_ERROR;
   }
 #endif // MOZ_MEDIA
+  else if (mEvent->eventStructType == NS_NOTIFYPAINT_EVENT) {
+    if (atom == nsGkAtoms::onMozAfterPaint)
+      mEvent->message = NS_AFTERPAINT;
+  }
+
   if (mEvent->message == NS_USER_DEFINED_EVENT)
     mEvent->userType = atom;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMEvent::InitEvent(const nsAString& aEventTypeArg, PRBool aCanBubbleArg, PRBool aCancelableArg)
@@ -964,16 +968,24 @@
       newEvent = new nsXULCommandEvent(PR_FALSE, msg, nsnull);
       NS_ENSURE_TRUE(newEvent, NS_ERROR_OUT_OF_MEMORY);
       isInputEvent = PR_TRUE;
       newEvent->eventStructType = NS_XUL_COMMAND_EVENT;
        static_cast<nsXULCommandEvent*>(newEvent)->sourceEvent =
          static_cast<nsXULCommandEvent*>(mEvent)->sourceEvent;
       break;
     }
+    case NS_NOTIFYPAINT_EVENT:
+    {
+      nsNotifyPaintEvent* event = static_cast<nsNotifyPaintEvent*>(mEvent);
+      newEvent =
+        new nsNotifyPaintEvent(PR_FALSE, msg,
+                               event->sameDocRegion, event->crossDocRegion);
+      break;
+    }
     default:
     {
       NS_WARNING("Unknown event type!!!");
       return NS_ERROR_FAILURE;
     }
   }
 
   NS_ENSURE_TRUE(newEvent, NS_ERROR_OUT_OF_MEMORY);
@@ -1468,16 +1480,18 @@
     return sEventNames[eDOMEvents_canplaythrough];
   case NS_RATECHANGE:
     return sEventNames[eDOMEvents_ratechange];
   case NS_DURATIONCHANGE:
     return sEventNames[eDOMEvents_durationchange];
   case NS_VOLUMECHANGE:
     return sEventNames[eDOMEvents_volumechange];
 #endif
+  case NS_AFTERPAINT:
+    return sEventNames[eDOMEvents_afterpaint];
   default:
     break;
   }
   // XXXldb We can hit this case for nsEvent objects that we didn't
   // create and that are not user defined events since this function and
   // SetEventType are incomplete.  (But fixing that requires fixing the
   // arrays in nsEventListenerManager too, since the events for which
   // this is a problem generally *are* created by nsDOMEvent.)
Index: mozilla/content/events/src/nsDOMEvent.h
===================================================================
--- mozilla.orig/content/events/src/nsDOMEvent.h
+++ mozilla/content/events/src/nsDOMEvent.h
@@ -124,29 +124,27 @@
     eDOMEvents_pageshow,
     eDOMEvents_pagehide,
     eDOMEvents_DOMMouseScroll,
     eDOMEvents_MozMousePixelScroll,
     eDOMEvents_offline,
     eDOMEvents_online,
     eDOMEvents_copy,
     eDOMEvents_cut,
-    eDOMEvents_paste
+    eDOMEvents_paste,
 #ifdef MOZ_SVG
-   ,
     eDOMEvents_SVGLoad,
     eDOMEvents_SVGUnload,
     eDOMEvents_SVGAbort,
     eDOMEvents_SVGError,
     eDOMEvents_SVGResize,
     eDOMEvents_SVGScroll,
-    eDOMEvents_SVGZoom
+    eDOMEvents_SVGZoom,
 #endif // MOZ_SVG
 #ifdef MOZ_MEDIA
-    ,
     eDOMEvents_loadstart,
     eDOMEvents_progress,
     eDOMEvents_loadedmetadata,
     eDOMEvents_loadedfirstframe,
     eDOMEvents_emptied,
     eDOMEvents_stalled,
     eDOMEvents_play,
     eDOMEvents_pause,
@@ -156,18 +154,19 @@
     eDOMEvents_timeupdate,
     eDOMEvents_ended,
     eDOMEvents_dataunavailable,
     eDOMEvents_canshowcurrentframe,
     eDOMEvents_canplay,
     eDOMEvents_canplaythrough,
     eDOMEvents_ratechange,
     eDOMEvents_durationchange,
-    eDOMEvents_volumechange
+    eDOMEvents_volumechange,
 #endif
+    eDOMEvents_afterpaint
   };
 
   nsDOMEvent(nsPresContext* aPresContext, nsEvent* aEvent);
   virtual ~nsDOMEvent();
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDOMEvent, nsIDOMEvent)
 
Index: mozilla/content/events/src/nsDOMNotifyPaintEvent.cpp
===================================================================
--- /dev/null
+++ mozilla/content/events/src/nsDOMNotifyPaintEvent.cpp
@@ -0,0 +1,139 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Robert O'Callahan <robert@ocallahan.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsDOMNotifyPaintEvent.h"
+#include "nsContentUtils.h"
+#include "nsClientRect.h"
+
+nsDOMNotifyPaintEvent::nsDOMNotifyPaintEvent(nsPresContext* aPresContext,
+                                             nsNotifyPaintEvent* aEvent)
+  : nsDOMEvent(aPresContext, aEvent ? aEvent :
+               new nsNotifyPaintEvent(PR_FALSE, 0, nsRegion(), nsRegion()))
+{
+  if (aEvent) {
+    mEventIsInternal = PR_FALSE;
+  }
+  else
+  {
+    mEventIsInternal = PR_TRUE;
+    mEvent->time = PR_Now();
+  }
+}
+
+nsDOMNotifyPaintEvent::~nsDOMNotifyPaintEvent()
+{
+  if (mEventIsInternal) {
+    if (mEvent->eventStructType == NS_NOTIFYPAINT_EVENT) {
+      delete static_cast<nsNotifyPaintEvent*>(mEvent);
+      mEvent = nsnull;
+    }
+  }
+}
+
+NS_INTERFACE_MAP_BEGIN(nsDOMNotifyPaintEvent)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNotifyPaintEvent)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NotifyPaintEvent)
+NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)
+
+NS_IMPL_ADDREF_INHERITED(nsDOMNotifyPaintEvent, nsDOMEvent)
+NS_IMPL_RELEASE_INHERITED(nsDOMNotifyPaintEvent, nsDOMEvent)
+
+nsRegion
+nsDOMNotifyPaintEvent::GetRegion()
+{
+  nsNotifyPaintEvent* event = static_cast<nsNotifyPaintEvent*>(mEvent);
+
+  nsRegion r;
+  if (nsContentUtils::IsCallerTrustedForRead()) {
+    r.Or(event->sameDocRegion, event->crossDocRegion);
+  } else {
+    r = event->sameDocRegion;
+  }
+  return r;
+}
+
+NS_IMETHODIMP
+nsDOMNotifyPaintEvent::GetBoundingClientRect(nsIDOMClientRect** aResult)
+{
+  // Weak ref, since we addref it below
+  nsClientRect* rect = new nsClientRect();
+  if (!rect)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  NS_ADDREF(*aResult = rect);
+  if (!mPresContext)
+    return NS_OK;
+
+  rect->SetLayoutRect(GetRegion().GetBounds(), mPresContext);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsDOMNotifyPaintEvent::GetClientRects(nsIDOMClientRectList** aResult)
+{
+  nsRefPtr<nsClientRectList> rectList = new nsClientRectList();
+  if (!rectList)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  nsRegion r = GetRegion();
+  nsRegionRectIterator iter(r);
+  for (const nsRect* rgnRect = iter.Next(); rgnRect; rgnRect = iter.Next()) {
+    nsRefPtr<nsClientRect> rect = new nsClientRect();
+    if (!rect)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    rect->SetLayoutRect(*rgnRect, mPresContext);
+    rectList->Append(rect);
+  }
+
+  *aResult = rectList.forget().get();
+  return NS_OK;
+}
+
+nsresult NS_NewDOMNotifyPaintEvent(nsIDOMEvent** aInstancePtrResult,
+                                   nsPresContext* aPresContext,
+                                   nsNotifyPaintEvent *aEvent)
+{
+  nsDOMNotifyPaintEvent* it =
+    new nsDOMNotifyPaintEvent(aPresContext, aEvent);
+  if (nsnull == it) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  return CallQueryInterface(it, aInstancePtrResult);
+}
Index: mozilla/content/events/src/nsDOMNotifyPaintEvent.h
===================================================================
--- /dev/null
+++ mozilla/content/events/src/nsDOMNotifyPaintEvent.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License
+ * Version 1.1 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Robert O'Callahan <robert@ocallahan.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsDOMNotifyPaintEvent_h_
+#define nsDOMNotifyPaintEvent_h_
+
+#include "nsIDOMNotifyPaintEvent.h"
+#include "nsDOMEvent.h"
+
+class nsDOMNotifyPaintEvent : public nsIDOMNotifyPaintEvent,
+                              public nsDOMEvent
+{
+public:
+  nsDOMNotifyPaintEvent(nsPresContext* aPresContext,
+                        nsNotifyPaintEvent* aEvent);
+  virtual ~nsDOMNotifyPaintEvent();
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+  NS_DECL_NSIDOMNOTIFYPAINTEVENT
+
+  // Forward to base class
+  NS_FORWARD_TO_NSDOMEVENT
+
+private:
+  nsRegion GetRegion();
+};
+
+#endif // nsDOMNotifyPaintEvent_h_
Index: mozilla/content/events/src/nsEventDispatcher.cpp
===================================================================
--- mozilla.orig/content/events/src/nsEventDispatcher.cpp
+++ mozilla/content/events/src/nsEventDispatcher.cpp
@@ -606,16 +606,20 @@
 
     case NS_XUL_COMMAND_EVENT:
       return NS_NewDOMXULCommandEvent(aDOMEvent, aPresContext,
                                       static_cast<nsXULCommandEvent*>
                                                  (aEvent));
     case NS_COMMAND_EVENT:
       return NS_NewDOMCommandEvent(aDOMEvent, aPresContext,
                                    static_cast<nsCommandEvent*>(aEvent));
+    case NS_NOTIFYPAINT_EVENT:
+      return NS_NewDOMNotifyPaintEvent(aDOMEvent, aPresContext,
+                                       static_cast<nsNotifyPaintEvent*>
+                                                     (aEvent));
     }
 
     // For all other types of events, create a vanilla event object.
     return NS_NewDOMEvent(aDOMEvent, aPresContext, aEvent);
   }
 
   // And if we didn't get an event, check the type argument.
 
@@ -662,11 +666,13 @@
     return NS_NewDOMCommandEvent(aDOMEvent, aPresContext, nsnull);
   if (aEventType.LowerCaseEqualsLiteral("datacontainerevent") ||
       aEventType.LowerCaseEqualsLiteral("datacontainerevents"))
     return NS_NewDOMDataContainerEvent(aDOMEvent, aPresContext, nsnull);
   if (aEventType.LowerCaseEqualsLiteral("messageevent"))
     return NS_NewDOMMessageEvent(aDOMEvent, aPresContext, nsnull);
   if (aEventType.LowerCaseEqualsLiteral("progressevent"))
     return NS_NewDOMProgressEvent(aDOMEvent, aPresContext, nsnull);
+  if (aEventType.LowerCaseEqualsLiteral("notifypaintevent"))
+    return NS_NewDOMNotifyPaintEvent(aDOMEvent, aPresContext, nsnull);
 
   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 }
Index: mozilla/content/html/content/src/Makefile.in
===================================================================
--- mozilla.orig/content/html/content/src/Makefile.in
+++ mozilla/content/html/content/src/Makefile.in
@@ -73,16 +73,17 @@
 		  chardet \
 		  uconv \
 		  intl \
 		  plugin \
 		  $(NULL)
 
 EXPORTS		= \
 		nsImageMapUtils.h \
+		nsClientRect.h \
 		$(NULL)
 
 CPPSRCS		= \
 		nsClientRect.cpp \
 		nsGenericHTMLElement.cpp \
 		nsFormSubmission.cpp \
 		nsImageMapUtils.cpp \
 		nsHTMLAnchorElement.cpp \
Index: mozilla/content/html/content/src/nsClientRect.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsClientRect.cpp
+++ mozilla/content/html/content/src/nsClientRect.cpp
@@ -35,16 +35,18 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsClientRect.h"
 #include "nsContentUtils.h"
 #include "nsDOMClassInfoID.h"
 
+#include "nsPresContext.h"
+
 NS_INTERFACE_TABLE_HEAD(nsClientRect)
   NS_INTERFACE_TABLE1(nsClientRect, nsIDOMClientRect)
   NS_INTERFACE_TABLE_TO_MAP_SEGUE
   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ClientRect)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_ADDREF(nsClientRect)
 NS_IMPL_RELEASE(nsClientRect)
@@ -119,8 +121,28 @@
   if (aIndex >= PRUint32(mArray.Count())) {
     *aReturn = nsnull;
     return NS_OK;
   } 
   
   NS_IF_ADDREF(*aReturn = mArray.ObjectAt(aIndex));
   return NS_OK;
 }
+
+static double
+RoundFloat(double aValue)
+{
+  return floor(aValue + 0.5);
+}
+
+void
+nsClientRect::SetLayoutRect(const nsRect& aLayoutRect, nsPresContext* aPresContext)
+{
+  double scale = 65536.0;
+  // Round to the nearest 1/scale units. We choose scale so it can be represented
+  // exactly by machine floating point.
+  double scaleInv = 1/scale;
+  double t2pScaled = scale/aPresContext->AppUnitsPerCSSPixel();
+  double x = RoundFloat(aLayoutRect.x*t2pScaled)*scaleInv;
+  double y = RoundFloat(aLayoutRect.y*t2pScaled)*scaleInv;
+  SetRect(x, y, RoundFloat(aLayoutRect.XMost()*t2pScaled)*scaleInv - x,
+          RoundFloat(aLayoutRect.YMost()*t2pScaled)*scaleInv - y);
+}
Index: mozilla/content/html/content/src/nsClientRect.h
===================================================================
--- mozilla.orig/content/html/content/src/nsClientRect.h
+++ mozilla/content/html/content/src/nsClientRect.h
@@ -37,30 +37,35 @@
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef NSCLIENTRECT_H_
 #define NSCLIENTRECT_H_
 
 #include "nsIDOMClientRect.h"
 #include "nsIDOMClientRectList.h"
 #include "nsCOMArray.h"
+#include "nsRect.h"
+
+class nsPresContext;
 
 class nsClientRect : public nsIDOMClientRect
 {
 public:
   NS_DECL_ISUPPORTS
 
   nsClientRect();
   void SetRect(float aX, float aY, float aWidth, float aHeight) {
     mX = aX; mY = aY; mWidth = aWidth; mHeight = aHeight;
   }
   virtual ~nsClientRect() {}
   
   NS_DECL_NSIDOMCLIENTRECT
 
+  void SetLayoutRect(const nsRect& aLayoutRect, nsPresContext* aPresContext);
+
 protected:
   float mX, mY, mWidth, mHeight;
 };
 
 class nsClientRectList : public nsIDOMClientRectList
 {
 public:
   nsClientRectList() {}
Index: mozilla/content/html/content/src/nsHTMLCanvasElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsHTMLCanvasElement.cpp
+++ mozilla/content/html/content/src/nsHTMLCanvasElement.cpp
@@ -547,28 +547,28 @@
 
 NS_IMETHODIMP
 nsHTMLCanvasElement::InvalidateFrame()
 {
   nsIFrame *frame = GetPrimaryFrame(Flush_Frames);
   if (frame) {
     nsRect r = frame->GetRect();
     r.x = r.y = 0;
-    frame->Invalidate(r, PR_FALSE);
+    frame->Invalidate(r);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsHTMLCanvasElement::InvalidateFrameSubrect(const nsRect& damageRect)
 {
   nsIFrame *frame = GetPrimaryFrame(Flush_Frames);
   if (frame) {
-    frame->Invalidate(damageRect, PR_FALSE);
+    frame->Invalidate(damageRect);
   }
 
   return NS_OK;
 }
 
 PRInt32
 nsHTMLCanvasElement::CountContexts()
 {
Index: mozilla/content/media/video/src/nsVideoDecoder.cpp
===================================================================
--- mozilla.orig/content/media/video/src/nsVideoDecoder.cpp
+++ mozilla/content/media/video/src/nsVideoDecoder.cpp
@@ -135,17 +135,17 @@
       nsPresContext* presContext = frame->PresContext();      
       nsIPresShell *presShell = presContext->PresShell();
       presShell->FrameNeedsReflow(frame, 
                                   nsIPresShell::eStyleChange,
                                   NS_FRAME_IS_DIRTY);
     }
   }
   nsRect r(nsPoint(0,0), frame->GetSize());
-  frame->Invalidate(r, PR_FALSE);
+  frame->Invalidate(r);
 }
 
 static void ProgressCallback(nsITimer* aTimer, void* aClosure)
 {
   nsVideoDecoder* decoder = static_cast<nsVideoDecoder*>(aClosure);
   decoder->Progress();
 }
 
Index: mozilla/dom/public/idl/events/Makefile.in
===================================================================
--- mozilla.orig/dom/public/idl/events/Makefile.in
+++ mozilla/dom/public/idl/events/Makefile.in
@@ -72,11 +72,12 @@
 	nsIDOMDataTransfer.idl  			\
 	nsIDOMPopupBlockedEvent.idl		\
 	nsIDOMBeforeUnloadEvent.idl		\
 	nsIDOMNSEventTarget.idl			\
 	nsIDOMSmartCardEvent.idl                \
 	nsIDOMPageTransitionEvent.idl		\
 	nsIDOMCommandEvent.idl			\
 	nsIDOMMessageEvent.idl			\
+	nsIDOMNotifyPaintEvent.idl              \
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
Index: mozilla/dom/public/idl/events/nsIDOMNotifyPaintEvent.idl
===================================================================
--- /dev/null
+++ mozilla/dom/public/idl/events/nsIDOMNotifyPaintEvent.idl
@@ -0,0 +1,67 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2008
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Robert O'Callahan <robert@ocallahan.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMEvent.idl"
+
+/**
+ * The nsIDOMNotifyPaintEvent interface is used for the MozDOMAfterPaint
+ * event, which fires at a window when painting has happened in
+ * that window.
+ */
+
+[scriptable, uuid(dec5582e-5cea-412f-bf98-6b27480fb46a)]
+interface nsIDOMNotifyPaintEvent : nsIDOMEvent
+{
+  /**
+   * Get a list of rectangles which are affected. The rectangles are in CSS pixels
+   * relative to the viewport origin.
+   * If the caller is not trusted (e.g., regular Web content) then only painting
+   * caused by the current document is reported; in particular, painting in subdocuments
+   * is not reported.
+   */
+  readonly attribute nsIDOMClientRectList clientRects;
+  /**
+   * Get the bounding box of the rectangles which are affected. The rectangle
+   * is in CSS pixels relative to the viewport origin.
+   * If the caller is not trusted (e.g., regular Web content) then only painting
+   * caused by the current document is reported; in particular, painting in subdocuments
+   * is not reported.
+   */
+  readonly attribute nsIDOMClientRect boundingClientRect;
+};
+
Index: mozilla/dom/public/nsDOMClassInfoID.h
===================================================================
--- mozilla.orig/dom/public/nsDOMClassInfoID.h
+++ mozilla/dom/public/nsDOMClassInfoID.h
@@ -447,16 +447,18 @@
 
   eDOMClassInfo_XMLHttpRequestUpload_id,
 
   // DOM Traversal NodeIterator class
   eDOMClassInfo_NodeIterator_id,
 
   eDOMClassInfo_DataTransfer_id,
 
+  eDOMClassInfo_NotifyPaintEvent_id,
+
   // This one better be the last one in this list
   eDOMClassInfoIDCount
 };
 
 /**
  * nsIClassInfo helper macros
  */
 
Index: mozilla/dom/src/base/nsDOMClassInfo.cpp
===================================================================
--- mozilla.orig/dom/src/base/nsDOMClassInfo.cpp
+++ mozilla/dom/src/base/nsDOMClassInfo.cpp
@@ -238,16 +238,17 @@
 #include "nsIDOMCommandEvent.h"
 #include "nsIDOMPopupBlockedEvent.h"
 #include "nsIDOMBeforeUnloadEvent.h"
 #include "nsIDOMMutationEvent.h"
 #include "nsIDOMSmartCardEvent.h"
 #include "nsIDOMXULCommandEvent.h"
 #include "nsIDOMPageTransitionEvent.h"
 #include "nsIDOMMessageEvent.h"
+#include "nsIDOMNotifyPaintEvent.h"
 #include "nsIDOMNSDocumentStyle.h"
 #include "nsIDOMDocumentRange.h"
 #include "nsIDOMDocumentTraversal.h"
 #include "nsIDOMDocumentXBL.h"
 #include "nsIDOMDocumentView.h"
 #include "nsIDOMElementCSSInlineStyle.h"
 #include "nsIDOMLinkStyle.h"
 #include "nsIDOMHTMLDocument.h"
@@ -1288,16 +1289,18 @@
   // DOM Traversal NodeIterator class  
   NS_DEFINE_CLASSINFO_DATA(NodeIterator, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   // data transfer for drag and drop
   NS_DEFINE_CLASSINFO_DATA(DataTransfer, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
+  NS_DEFINE_CLASSINFO_DATA(NotifyPaintEvent, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
 };
 
 // Objects that shuld be constructable through |new Name();|
 struct nsContractIDMapData
 {
   PRInt32 mDOMClassInfoID;
   const char *mContractID;
 };
@@ -3532,16 +3535,21 @@
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMEventTarget)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(DataTransfer, nsIDOMDataTransfer)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMDataTransfer)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNSDataTransfer)
   DOM_CLASSINFO_MAP_END
 
+  DOM_CLASSINFO_MAP_BEGIN(NotifyPaintEvent, nsIDOMNotifyPaintEvent)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMNotifyPaintEvent)
+    DOM_CLASSINFO_EVENT_MAP_ENTRIES
+  DOM_CLASSINFO_MAP_END
+
 #ifdef NS_DEBUG
   {
     PRUint32 i = NS_ARRAY_LENGTH(sClassInfoData);
 
     if (i != eDOMClassInfoIDCount) {
       NS_ERROR("The number of items in sClassInfoData doesn't match the "
                "number of nsIDOMClassInfo ID's, this is bad! Fix it!");
 
Index: mozilla/dom/src/base/nsDOMWindowUtils.cpp
===================================================================
--- mozilla.orig/dom/src/base/nsDOMWindowUtils.cpp
+++ mozilla/dom/src/base/nsDOMWindowUtils.cpp
@@ -173,17 +173,17 @@
       nsIFrame *rootFrame = presShell->GetRootFrame();
 
       if (rootFrame) {
         nsRect r(nsPoint(0, 0), rootFrame->GetSize());
 
         PRIntervalTime iStart = PR_IntervalNow();
 
         for (PRUint32 i = 0; i < aCount; i++)
-          rootFrame->Invalidate(r, PR_TRUE);
+          rootFrame->InvalidateWithFlags(r, nsIFrame::INVALIDATE_IMMEDIATE);
 
 #if defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2)
         XSync(GDK_DISPLAY(), False);
 #endif
 
         *aDurationOut = PR_IntervalToMilliseconds(PR_IntervalNow() - iStart);
 
         return NS_OK;
Index: mozilla/layout/base/nsCaret.cpp
===================================================================
--- mozilla.orig/layout/base/nsCaret.cpp
+++ mozilla/layout/base/nsCaret.cpp
@@ -1273,17 +1273,17 @@
 
 // static
 void nsCaret::InvalidateRects(const nsRect &aRect, const nsRect &aHook,
                               nsIFrame *aFrame)
 {
   NS_ASSERTION(aFrame, "Must have a frame to invalidate");
   nsRect rect;
   rect.UnionRect(aRect, aHook);
-  aFrame->Invalidate(rect, PR_FALSE);
+  aFrame->Invalidate(rect);
 }
 
 //-----------------------------------------------------------------------------
 /* static */
 void nsCaret::CaretBlinkCallback(nsITimer *aTimer, void *aClosure)
 {
   nsCaret   *theCaret = reinterpret_cast<nsCaret*>(aClosure);
   if (!theCaret) return;
Index: mozilla/layout/base/nsImageLoader.cpp
===================================================================
--- mozilla.orig/layout/base/nsImageLoader.cpp
+++ mozilla/layout/base/nsImageLoader.cpp
@@ -252,10 +252,10 @@
 
     if (aDamageRect) {
       bounds.IntersectRect(*aDamageRect, bounds);
     }
   }
 
 #endif
 
-  mFrame->Invalidate(bounds, PR_FALSE);
+  mFrame->Invalidate(bounds);
 }
Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -77,16 +77,17 @@
 #include "nsThreadUtils.h"
 #include "nsFrameManager.h"
 #include "nsLayoutUtils.h"
 #include "nsIViewManager.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsCSSRuleProcessor.h"
 #include "nsStyleChangeList.h"
 #include "nsRuleNode.h"
+#include "nsEventDispatcher.h"
 
 #ifdef IBMBIDI
 #include "nsBidiPresUtils.h"
 #endif // IBMBIDI
 
 #include "nsContentUtils.h"
 
 // Needed for Start/Stop of Image Animation
@@ -1564,8 +1565,59 @@
 }
 
 /* virtual */ PRBool
 nsPresContext::HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const
 {
   return nsRuleNode::
     HasAuthorSpecifiedRules(aFrame->GetStyleContext(), ruleTypeMask);
 }
+
+void
+nsPresContext::FireDOMPaintEvent()
+{
+  nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
+  if (!docShell)
+    return;
+  nsCOMPtr<nsPIDOMWindow> ourWindow = do_GetInterface(docShell);
+  nsISupports* eventTarget = ourWindow;
+  if (mSameDocDirtyRegion.IsEmpty() && !IsChrome()) {
+    // Don't tell the window about this event, it should not know that
+    // something happened in a subdocument. Tell only the chrome event handler.
+    // (Events sent to the window get propagated to the chrome event handler
+    // automatically.)
+    eventTarget = ourWindow->GetChromeEventHandler();
+  }
+  // Events sent to the window get propagated to the chrome event handler
+  // automatically.
+
+  nsNotifyPaintEvent event(PR_TRUE, NS_AFTERPAINT, mSameDocDirtyRegion,
+                           mCrossDocDirtyRegion);
+  // Empty our regions now in case dispatching the event causes more damage
+  // (hopefully it won't, or we're likely to get an infinite loop! At least
+  // it won't be blocking app execution though).
+  mSameDocDirtyRegion.SetEmpty();
+  mCrossDocDirtyRegion.SetEmpty();
+  // Even if we're not telling the window about the event (so eventTarget is
+  // the chrome event handler, not the window), the window is still
+  // logically the event target.
+  event.target = do_QueryInterface(ourWindow);
+  nsEventDispatcher::Dispatch(eventTarget, this, &event);
+}
+
+void
+nsPresContext::NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc)
+{
+  if (aRect.IsEmpty())
+    return;
+
+  if (mSameDocDirtyRegion.IsEmpty() && mCrossDocDirtyRegion.IsEmpty()) {
+    // No event is pending. Dispatch one now.
+    nsCOMPtr<nsIRunnable> ev =
+      new nsRunnableMethod<nsPresContext>(this,
+                                          &nsPresContext::FireDOMPaintEvent);
+    NS_DispatchToCurrentThread(ev);
+  }
+
+  nsRegion* r = aIsCrossDoc ? &mCrossDocDirtyRegion : &mSameDocDirtyRegion;
+  r->Or(*r, aRect);
+  r->SimplifyOutward(10);
+}
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -60,16 +60,17 @@
 #include "nsPropertyTable.h"
 #include "nsGkAtoms.h"
 #include "nsIDocument.h"
 #include "nsInterfaceHashtable.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsChangeHint.h"
 // This also pulls in gfxTypes.h, which we cannot include directly.
 #include "gfxRect.h"
+#include "nsRegion.h"
 class nsImageLoader;
 #ifdef IBMBIDI
 class nsBidiPresUtils;
 #endif // IBMBIDI
 
 struct nsRect;
 
 class imgIRequest;
@@ -773,16 +774,19 @@
 
   // Is it OK to let the page specify colors and backgrounds?
   PRBool UseDocumentColors() const {
     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
 
+  void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
+  void FireDOMPaintEvent();
+
 protected:
   friend class nsRunnableMethod<nsPresContext>;
   NS_HIDDEN_(void) ThemeChangedInternal();
   NS_HIDDEN_(void) SysColorChangedInternal();
   
   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
   NS_HIDDEN_(void) GetDocumentColorPreferences();
 
@@ -833,16 +837,19 @@
 
   nsCOMPtr<nsITheme> mTheme;
   nsCOMPtr<nsILanguageAtomService> mLangService;
   nsCOMPtr<nsIPrintSettings> mPrintSettings;
   nsCOMPtr<nsITimer>    mPrefChangedTimer;
 
   nsPropertyTable       mPropertyTable;
 
+  nsRegion              mSameDocDirtyRegion;
+  nsRegion              mCrossDocDirtyRegion;
+
   nsLanguageSpecificTransformType mLanguageSpecificTransformType;
   PRInt32               mFontScaler;
   nscoord               mMinimumFontSize;
 
   nsRect                mVisibleArea;
   nsSize                mPageSize;
   float                 mPageScale;
   float                 mPPScale;
Index: mozilla/layout/base/nsPresShell.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresShell.cpp
+++ mozilla/layout/base/nsPresShell.cpp
@@ -4311,17 +4311,17 @@
     return;
   }
   
   mPaintingSuppressed = PR_FALSE;
   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
   if (rootFrame) {
     // let's assume that outline on a root frame is not supported
     nsRect rect(nsPoint(0, 0), rootFrame->GetSize());
-    rootFrame->Invalidate(rect, gPaintDelay < -1 ? PR_TRUE : PR_FALSE);
+    rootFrame->Invalidate(rect);
   }
 
   // This makes sure to get the same thing that nsPresContext::EnsureVisible()
   // got.
   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
   nsCOMPtr<nsPIDOMWindow> ourWindow = do_GetInterface(container);
   nsCOMPtr<nsIFocusController> focusController =
     ourWindow ? ourWindow->GetRootFocusController() : nsnull;
Index: mozilla/layout/base/tests/Makefile.in
===================================================================
--- mozilla.orig/layout/base/tests/Makefile.in
+++ mozilla/layout/base/tests/Makefile.in
@@ -87,15 +87,16 @@
 		test_bug399284.html \
 		test_bug399951.html \
 		test_bug404209.xhtml \
 		test_bug416896.html \
 		test_bug420499.xul \
 		test_bug423523.html \
 		test_bug445810.html \
 		test_bug449781.html \
+		test_bug450930.xhtml \
 		$(NULL)
 # test_bug396024.html is currently disabled because it interacts badly with
 # the "You can't print-preview while the page is loading" dialog.
 # (See bug 407080)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
Index: mozilla/layout/base/tests/test_bug450930.xhtml
===================================================================
--- /dev/null
+++ mozilla/layout/base/tests/test_bug450930.xhtml
@@ -0,0 +1,211 @@
+<html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg">
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=450930
+-->
+<head>
+  <title>Test for Bug 450930</title>
+  <script type="text/javascript" src="/MochiKit/packed.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=450930">Mozilla Bug 450930</a>
+<div id="display">
+  <div id="d" style="width:400px; height:200px;"></div>
+  <iframe id="iframe" style="width:400px; height:200px;"
+   src="data:text/html,&lt;div id='d'&gt;Hello&lt;/div&gt;&lt;div style='margin-top:500px' id='d2'&gt;Hello&lt;/div>"></iframe>
+  <svg:svg style="width:410px; height:210px;" id="svg">
+    <svg:foreignObject width="100%" height="100%">
+      <iframe id="iframe2" style="width:400px; height:200px;"
+       src="data:text/html,&lt;div id='d'&gt;Hello&lt;/div&gt;&lt;div style='margin-top:500px' id='d2'&gt;Hello&lt;/div>"></iframe>
+    </svg:foreignObject>
+  </svg:svg>
+</div>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript"><![CDATA[
+
+/** Test for Bug 450930 **/
+SimpleTest.waitForExplicitFinish();
+
+function flash(doc, name) {
+  var d = doc.getElementById(name);
+  d.style.backgroundColor = d.style.backgroundColor == "blue" ? "yellow" : "blue";
+}
+
+function le(v1, v2, s) {
+  ok(v1 <= v2, s + " (" + v1 + "," + v2 + ")");
+}
+
+function checkContains(r1, r2, s) {
+  le(r1.left, r2.left, "Left edges out" + s);
+  le(r2.right, r1.right, "Right edges out" + s);
+  le(r1.top, r2.top, "Top edges out" + s);
+  le(r2.bottom, r1.bottom, "Bottom edges out" + s);
+}
+
+function isRect(r1, r2) {
+  return r1.left == r2.left && r1.right == r2.right &&
+         r1.top == r2.top && r1.bottom == r2.bottom;
+}
+
+function isRectInList(r, list) {
+  for (var i = 0; i < list.length; ++i) {
+    if (isRect(r, list[i]))
+      return true;
+  }
+  return false;
+}
+
+function doesRectContain(r1, r2) {
+  return r1.left <= r2.left && r2.right <= r1.right &&
+         r1.top <= r2.top && r2.bottom <= r1.bottom;
+}
+
+function rectToString(r) {
+  return "(" + r.left + "," + r.top + "," + r.right + "," + r.bottom + ")";
+}
+
+function doesRectContainListElement(r, list) {
+  dump("Incoming rect: " + rectToString(r) + "\n");
+  for (var i = 0; i < list.length; ++i) {
+    dump("List rect " + i + ": " + rectToString(list[i]));
+    if (doesRectContain(r, list[i])) {
+      dump(" FOUND\n");
+      return true;
+    }
+    dump("\n");
+  }
+  dump("NOT FOUND\n");
+  return false;
+}
+
+function checkGotSubdoc(list, container) {
+  var r = container.getBoundingClientRect();
+  return doesRectContainListElement(r, list);
+}
+
+function runTest1() {
+  // test basic functionality
+  var iterations = 0;
+  var foundExactRect = false;
+
+  function listener(event) {
+    var r = event.boundingClientRect;
+    var bounds = document.getElementById('d').getBoundingClientRect();
+    checkContains(r, bounds, "");
+    if (isRectInList(bounds, event.clientRects)) {
+      foundExactRect = true;
+    }
+    window.removeEventListener("MozAfterPaint", listener, false);
+    ++iterations;
+    if (iterations < 4) {
+      setTimeout(triggerPaint, 100);
+    } else {
+      ok(foundExactRect, "Found exact rect");
+      runNext();
+    }
+  }
+
+  function triggerPaint() {
+    window.addEventListener("MozAfterPaint", listener, false);
+    flash(document, 'd');
+  }
+  triggerPaint();
+}
+
+function runTest2(frameID, containerID) {
+  // test reporting of painting in subdocuments
+  var fired = false;
+  var gotSubdocPrivileged = false;
+  var gotSubdocNonprivileged = false;
+  var iframe = document.getElementById(frameID);
+  var container = document.getElementById(containerID);
+
+  function listener(event) {
+    fired = true;
+    if (checkGotSubdoc(event.clientRects, container))
+      gotSubdocNonprivileged = true;
+
+    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+    if (checkGotSubdoc(event.clientRects, container))
+      gotSubdocPrivileged = true;
+  }
+
+  function check() {
+    ok(fired, "Event fired (" + frameID + ")");
+    ok(gotSubdocPrivileged, "Didn't get subdoc invalidation while we were privileged (" + frameID + ")");
+    ok(!gotSubdocNonprivileged, "Got subdoc invalidation while we were not privileged (" + frameID + ")");
+    window.removeEventListener("MozAfterPaint", listener, false);
+    runNext();
+  }
+
+  function triggerPaint() {
+    window.addEventListener("MozAfterPaint", listener, false);
+    setTimeout(check, 100);
+    document.body.offsetTop;
+    flash(iframe.contentDocument, 'd');
+    // make sure an event fires; since we're not using a chrome event handler, even though we
+    // can get privileges we wouldn't get the event
+    flash(document, 'd');
+  }
+  triggerPaint();
+}
+
+function runTest3() {
+  // test reporting of painting of scrolled-out-of-view areas
+  var gotScrolledOutInMainDoc = false;
+  var gotScrolledOutInSubdoc = false;
+  var iframe = document.getElementById("iframe");
+
+  function listener(event) {
+    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
+    if (checkGotSubdoc(event.clientRects, iframe))
+      gotScrolledOutInMainDoc = true;
+  }
+
+  function IFRAMEListener(event) {
+    if (doesRectContainListElement(
+          iframe.contentDocument.getElementById("d2").getBoundingClientRect(), event.clientRects))
+      gotScrolledOutInSubdoc = true;
+  }
+
+  function check() {
+    ok(!gotScrolledOutInMainDoc, "scrolled-out invalidation should not propagate to main doc");
+    ok(gotScrolledOutInSubdoc, "scrolled-out invalidation should notify in subdoc");
+    window.removeEventListener("MozAfterPaint", listener, false);
+    iframe.contentWindow.removeEventListener("MozAfterPaint", IFRAMEListener, false);
+    runNext();
+  }
+
+  function triggerPaint() {
+    window.addEventListener("MozAfterPaint", listener, false);
+    iframe.contentWindow.addEventListener("MozAfterPaint", IFRAMEListener, false);
+    setTimeout(check, 100);
+    flash(iframe.contentDocument, 'd2');
+  }
+  triggerPaint();
+}
+
+var test = 0;
+var tests = [runTest1,
+             function() { runTest2("iframe", "iframe") },
+             function() { runTest2("iframe2", "svg") },
+             runTest3];
+function runNext() {
+  if (test < tests.length) {
+    ++test;
+    tests[test - 1]();
+  } else {
+    SimpleTest.finish();
+  }
+}
+
+window.onload = runNext();
+]]></script>
+</pre>
+</body>
+</html>
+
Index: mozilla/layout/forms/nsComboboxControlFrame.cpp
===================================================================
--- mozilla.orig/layout/forms/nsComboboxControlFrame.cpp
+++ mozilla/layout/forms/nsComboboxControlFrame.cpp
@@ -355,17 +355,17 @@
 
   if (!weakFrame.IsAlive()) {
     return;
   }
 
   // This is needed on a temporary basis. It causes the focus
   // rect to be drawn. This is much faster than ReResolvingStyle
   // Bug 32920
-  Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_FALSE);
+  Invalidate(nsRect(0,0,mRect.width,mRect.height));
 
   // Make sure the content area gets updated for where the dropdown was
   // This is only needed for embedding, the focus may go to 
   // the chrome that is not part of the Gecko system (Bug 83493)
   // XXX this is rather inefficient
   nsIViewManager* vm = PresContext()->GetViewManager();
   if (vm) {
     vm->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
Index: mozilla/layout/forms/nsGfxCheckboxControlFrame.cpp
===================================================================
--- mozilla.orig/layout/forms/nsGfxCheckboxControlFrame.cpp
+++ mozilla/layout/forms/nsGfxCheckboxControlFrame.cpp
@@ -160,17 +160,17 @@
 }
 
 
 //------------------------------------------------------------
 NS_IMETHODIMP
 nsGfxCheckboxControlFrame::OnChecked(nsPresContext* aPresContext,
                                      PRBool aChecked)
 {
-  Invalidate(GetOverflowRect(), PR_FALSE);
+  InvalidateOverflowRect();
   return NS_OK;
 }
 
 static void PaintCheckMarkFromStyle(nsIFrame* aFrame,
      nsIRenderingContext* aCtx, const nsRect& aDirtyRect, nsPoint aPt) {
   static_cast<nsGfxCheckboxControlFrame*>(aFrame)
     ->PaintCheckBoxFromStyle(*aCtx, aPt, aDirtyRect);
 }
Index: mozilla/layout/forms/nsGfxRadioControlFrame.cpp
===================================================================
--- mozilla.orig/layout/forms/nsGfxRadioControlFrame.cpp
+++ mozilla/layout/forms/nsGfxRadioControlFrame.cpp
@@ -211,12 +211,12 @@
 }
 
 
 //--------------------------------------------------------------
 NS_IMETHODIMP
 nsGfxRadioControlFrame::OnChecked(nsPresContext* aPresContext,
                                   PRBool aChecked)
 {
-  Invalidate(GetOverflowRect(), PR_FALSE);
+  InvalidateOverflowRect();
   return NS_OK;
 }
 
Index: mozilla/layout/forms/nsListControlFrame.cpp
===================================================================
--- mozilla.orig/layout/forms/nsListControlFrame.cpp
+++ mozilla/layout/forms/nsListControlFrame.cpp
@@ -1813,21 +1813,23 @@
   // certainly not use our parent block (or worse yet our parent combobox) for
   // their sizing.
   return PR_TRUE;
 }
 
 void
 nsListControlFrame::InvalidateInternal(const nsRect& aDamageRect,
                                        nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                       PRBool aImmediate)
+                                       PRUint32 aFlags)
 {
-  if (!IsInDropDownMode())
-    nsHTMLScrollFrame::InvalidateInternal(aDamageRect, aX, aY, this, aImmediate);
-  InvalidateRoot(aDamageRect, aX, aY, aImmediate);
+  if (!IsInDropDownMode()) {
+    nsHTMLScrollFrame::InvalidateInternal(aDamageRect, aX, aY, this, aFlags);
+    return;
+  }
+  InvalidateRoot(aDamageRect + nsPoint(aX, aY), aFlags);
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 nsListControlFrame::GetFrameName(nsAString& aResult) const
 {
   return MakeFrameName(NS_LITERAL_STRING("ListControl"), aResult);
 }
Index: mozilla/layout/forms/nsListControlFrame.h
===================================================================
--- mozilla.orig/layout/forms/nsListControlFrame.h
+++ mozilla/layout/forms/nsListControlFrame.h
@@ -126,17 +126,17 @@
     return nsHTMLScrollFrame::IsFrameOfType(aFlags &
       ~(nsIFrame::eReplaced | nsIFrame::eReplacedContainsBlock));
   }
 
   virtual PRBool IsContainingBlock() const;
 
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate);
+                                  PRUint32 aFlags);
 
 #ifdef DEBUG
     // nsIFrameDebug
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
 
     // nsIFormControlFrame
   virtual nsresult SetFormProperty(nsIAtom* aName, const nsAString& aValue);
Index: mozilla/layout/generic/nsBlockFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsBlockFrame.cpp
+++ mozilla/layout/generic/nsBlockFrame.cpp
@@ -479,33 +479,33 @@
 nsBlockFrame::GetType() const
 {
   return nsGkAtoms::blockFrame;
 }
 
 void
 nsBlockFrame::InvalidateInternal(const nsRect& aDamageRect,
                                  nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                 PRBool aImmediate)
+                                 PRUint32 aFlags)
 {
   // Optimize by suppressing invalidation of areas that are clipped out
   // with CSS 'clip'.
   const nsStyleDisplay* disp = GetStyleDisplay();
   nsRect absPosClipRect;
   if (GetAbsPosClipRect(disp, &absPosClipRect, GetSize())) {
     // Restrict the invalidated area to abs-pos clip rect
     // abs-pos clipping clips everything in the frame
     nsRect r;
     if (r.IntersectRect(aDamageRect, absPosClipRect - nsPoint(aX, aY))) {
-      nsBlockFrameSuper::InvalidateInternal(r, aX, aY, this, aImmediate);
+      nsBlockFrameSuper::InvalidateInternal(r, aX, aY, this, aFlags);
     }
     return;
   }
 
-  nsBlockFrameSuper::InvalidateInternal(aDamageRect, aX, aY, this, aImmediate);
+  nsBlockFrameSuper::InvalidateInternal(aDamageRect, aX, aY, this, aFlags);
 }
 
 nscoord
 nsBlockFrame::GetBaseline() const
 {
   NS_ASSERTION(!NS_SUBTREE_DIRTY(this), "frame must not be dirty");
   nscoord result;
   if (nsLayoutUtils::GetLastLineBaseline(this, &result))
Index: mozilla/layout/generic/nsBlockFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsBlockFrame.h
+++ mozilla/layout/generic/nsBlockFrame.h
@@ -182,17 +182,17 @@
   virtual nsSplittableType GetSplittableType() const;
   virtual PRBool IsContainingBlock() const;
   virtual PRBool IsFloatContainingBlock() const;
   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                               const nsRect&           aDirtyRect,
                               const nsDisplayListSet& aLists);
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate);
+                                  PRUint32 aFlags);
   virtual nsIAtom* GetType() const;
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
   {
     return nsContainerFrame::IsFrameOfType(aFlags &
              ~(nsIFrame::eCanContainOverflowContainers |
                nsIFrame::eBlockFrame));
   }
 
Index: mozilla/layout/generic/nsBulletFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsBulletFrame.cpp
+++ mozilla/layout/generic/nsBulletFrame.cpp
@@ -1462,17 +1462,17 @@
 
 NS_IMETHODIMP nsBulletFrame::OnDataAvailable(imgIRequest *aRequest,
                                              gfxIImageFrame *aFrame,
                                              const nsRect *aRect)
 {
   // The image has changed.
   // Invalidate the entire content area. Maybe it's not optimal but it's simple and
   // always correct, and I'll be a stunned mullet if it ever matters for performance
-  Invalidate(nsRect(0, 0, mRect.width, mRect.height), PR_FALSE);
+  Invalidate(nsRect(0, 0, mRect.width, mRect.height));
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsBulletFrame::OnStopDecode(imgIRequest *aRequest,
                                           nsresult aStatus,
                                           const PRUnichar *aStatusArg)
 {
@@ -1492,17 +1492,17 @@
 }
 
 NS_IMETHODIMP nsBulletFrame::FrameChanged(imgIContainer *aContainer,
                                           gfxIImageFrame *aNewFrame,
                                           nsRect *aDirtyRect)
 {
   // Invalidate the entire content area. Maybe it's not optimal but it's simple and
   // always correct.
-  Invalidate(nsRect(0, 0, mRect.width, mRect.height), PR_FALSE);
+  Invalidate(nsRect(0, 0, mRect.width, mRect.height));
 
   return NS_OK;
 }
 
 void
 nsBulletFrame::GetLoadGroup(nsPresContext *aPresContext, nsILoadGroup **aLoadGroup)
 {
   if (!aPresContext)
Index: mozilla/layout/generic/nsFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsFrame.cpp
+++ mozilla/layout/generic/nsFrame.cpp
@@ -3629,50 +3629,49 @@
 
 PRBool
 nsIFrame::IsLeaf() const
 {
   return PR_TRUE;
 }
 
 void
-nsIFrame::Invalidate(const nsRect& aDamageRect,
-                     PRBool        aImmediate)
+nsIFrame::InvalidateWithFlags(const nsRect& aDamageRect, PRUint32 aFlags)
 {
   if (aDamageRect.IsEmpty()) {
     return;
   }
 
   // Don't allow invalidates to do anything when
   // painting is suppressed.
   nsIPresShell *shell = PresContext()->GetPresShell();
   if (shell) {
     PRBool suppressed = PR_FALSE;
     shell->IsPaintingSuppressed(&suppressed);
     if (suppressed)
       return;
   }
   
-  InvalidateInternal(aDamageRect, 0, 0, nsnull, aImmediate);
+  InvalidateInternal(aDamageRect, 0, 0, nsnull, aFlags);
 }
 
 /**
  * Helper function that funnels an InvalidateInternal request up to the
  * parent.  This function is used so that if MOZ_SVG is not defined, we still
  * have unified control paths in the InvalidateInternal chain.
  *
  * @param aDamageRect The rect to invalidate.
  * @param aX The x offset from the origin of this frame to the rectangle.
  * @param aY The y offset from the origin of this frame to the rectangle.
  * @param aImmediate Whether to redraw immediately.
  * @return None, though this funnels the request up to the parent frame.
  */
 void
 nsIFrame::InvalidateInternalAfterResize(const nsRect& aDamageRect, nscoord aX,
-                                        nscoord aY, PRBool aImmediate)
+                                        nscoord aY, PRUint32 aFlags)
 {
   /* If we're a transformed frame, then we need to apply our transform to the
    * damage rectangle so that the redraw correctly redraws the transformed
    * region.  We're moved over aX and aY from our origin, but since this aX
    * and aY is contained within our border, we need to scoot back by -aX and
    * -aY to get back to the origin of the transform.
    *
    * There's one more problem, though, and that's that we don't know what
@@ -3687,41 +3686,41 @@
    */
   if ((mState & NS_FRAME_MAY_BE_TRANSFORMED) &&
       GetStyleDisplay()->HasTransform()) {
     nsRect newDamageRect;
     newDamageRect.UnionRect(nsDisplayTransform::TransformRect
                             (aDamageRect, this, nsPoint(-aX, -aY)), aDamageRect);
     GetParent()->
       InvalidateInternal(newDamageRect, aX + mRect.x, aY + mRect.y, this,
-                         aImmediate);
+                         aFlags);
   }
   else 
     GetParent()->
-      InvalidateInternal(aDamageRect, aX + mRect.x, aY + mRect.y, this, aImmediate);
+      InvalidateInternal(aDamageRect, aX + mRect.x, aY + mRect.y, this, aFlags);
 }
 
 void
 nsIFrame::InvalidateInternal(const nsRect& aDamageRect, nscoord aX, nscoord aY,
-                             nsIFrame* aForChild, PRBool aImmediate)
+                             nsIFrame* aForChild, PRUint32 aFlags)
 {
 #ifdef MOZ_SVG
   if (nsSVGIntegrationUtils::UsingEffectsForFrame(this)) {
     nsRect r = nsSVGIntegrationUtils::GetInvalidAreaForChangedSource(this,
             aDamageRect + nsPoint(aX, aY));
     /* Rectangle is now in our own local space, so aX and aY are effectively
      * zero.  Thus we'll pretend that the entire time this was in our own
      * local coordinate space and do any remaining processing.
      */
-    InvalidateInternalAfterResize(r, 0, 0, aImmediate);
+    InvalidateInternalAfterResize(r, 0, 0, aFlags);
     return;
   }
 #endif
   
-  InvalidateInternalAfterResize(aDamageRect, aX, aY, aImmediate);
+  InvalidateInternalAfterResize(aDamageRect, aX, aY, aFlags);
 }
 
 gfxMatrix
 nsIFrame::GetTransformMatrix(nsIFrame **aOutAncestor)
 {
   NS_PRECONDITION(aOutAncestor, "Need a place to put the ancestor!");
 
   /* Whether or not we're transformed, the matrix will be relative to our
@@ -3795,23 +3794,26 @@
 
 void
 nsIFrame::InvalidateOverflowRect()
 {
   Invalidate(GetOverflowRect());
 }
 
 void
-nsIFrame::InvalidateRoot(const nsRect& aDamageRect,
-                         nscoord aX, nscoord aY, PRBool aImmediate)
+nsIFrame::InvalidateRoot(const nsRect& aDamageRect, PRUint32 aFlags)
 {
-  PRUint32 flags = aImmediate ? NS_VMREFRESH_IMMEDIATE : NS_VMREFRESH_NO_SYNC;
+  if (aFlags & INVALIDATE_NOTIFY_ONLY)
+    return;
+
+  PRUint32 flags =
+    (aFlags & INVALIDATE_IMMEDIATE) ? NS_VMREFRESH_IMMEDIATE : NS_VMREFRESH_NO_SYNC;
   nsIView* view = GetView();
   NS_ASSERTION(view, "This can only be called on frames with views");
-  view->GetViewManager()->UpdateView(view, aDamageRect + nsPoint(aX, aY), flags);
+  view->GetViewManager()->UpdateView(view, aDamageRect, flags);
 }
 
 static void
 DestroyRectFunc(void*    aFrame,
                 nsIAtom* aPropertyName,
                 void*    aPropertyValue,
                 void*    aDtorData)
 {
@@ -4438,17 +4440,17 @@
 */
   if ( aSelected ){
     AddStateBits(NS_FRAME_SELECTED_CONTENT);
   }
   else
     RemoveStateBits(NS_FRAME_SELECTED_CONTENT);
 
   // Repaint this frame subtree's entire area
-  Invalidate(GetOverflowRect(), PR_FALSE);
+  InvalidateOverflowRect();
 
 #ifdef IBMBIDI
   PRInt32 start, end;
   nsIFrame* frame = GetNextSibling();
   if (frame) {
     GetFirstLeaf(aPresContext, &frame);
     GetOffsets(start, end);
     if (start && end) {
Index: mozilla/layout/generic/nsFrameFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsFrameFrame.cpp
+++ mozilla/layout/generic/nsFrameFrame.cpp
@@ -562,17 +562,17 @@
   // Determine if we need to repaint our border, background or outline
   CheckInvalidateSizeChange(aDesiredSize);
 
   FinishAndStoreOverflow(&aDesiredSize);
 
   // Invalidate the frame contents
   // XXX is this really needed?
   nsRect rect(nsPoint(0, 0), GetSize());
-  Invalidate(rect, PR_FALSE);
+  Invalidate(rect);
 
   if (!aPresContext->IsPaginated() && !mPostedReflowCallback) {
     PresContext()->PresShell()->PostReflowCallback(this);
     mPostedReflowCallback = PR_TRUE;
   }
 
   // printf("OuterFrame::Reflow DONE %X (%d,%d)\n", this,
   //        aDesiredSize.width, aDesiredSize.height);
Index: mozilla/layout/generic/nsGfxScrollFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsGfxScrollFrame.cpp
+++ mozilla/layout/generic/nsGfxScrollFrame.cpp
@@ -222,29 +222,40 @@
 nsHTMLScrollFrame::GetType() const
 {
   return nsGkAtoms::scrollFrame; 
 }
 
 void
 nsHTMLScrollFrame::InvalidateInternal(const nsRect& aDamageRect,
                                       nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                      PRBool aImmediate)
+                                      PRUint32 aFlags)
 {
-  if (aForChild == mInner.mScrolledFrame) {
+  if (aForChild == mInner.mScrolledFrame && !(aFlags & INVALIDATE_NOTIFY_ONLY)) {
     // restrict aDamageRect to the scrollable view's bounds
+    nsRect damage = aDamageRect + nsPoint(aX, aY);
     nsRect r;
-    if (r.IntersectRect(aDamageRect + nsPoint(aX, aY),
-                        mInner.mScrollableView->View()->GetBounds())) {
-      nsHTMLContainerFrame::InvalidateInternal(r, 0, 0, aForChild, aImmediate);
+    if (r.IntersectRect(damage, mInner.mScrollableView->View()->GetBounds())) {
+      nsHTMLContainerFrame::InvalidateInternal(r, 0, 0, aForChild, aFlags);
+    }
+    if (mInner.mIsRoot && r != damage) {
+      // Make sure we notify our prescontext about invalidations outside
+      // viewport clipping.
+      // This is important for things that are snapshotting the viewport,
+      // possibly outside the scrolled bounds.
+      // We don't need to propagate this any further up, though. Anyone who
+      // cares about scrolled-out-of-view invalidates had better be listening
+      // to our window directly.
+      PresContext()->NotifyInvalidation(damage,
+          (aFlags & INVALIDATE_CROSS_DOC) != 0);
     }
     return;
   }
   
-  nsHTMLContainerFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aImmediate);
+  nsHTMLContainerFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aFlags);
 }
 
 /**
  HTML scrolling implementation
 
  All other things being equal, we prefer layouts with fewer scrollbars showing.
 */
 
@@ -1092,29 +1103,29 @@
 nsXULScrollFrame::GetType() const
 {
   return nsGkAtoms::scrollFrame; 
 }
 
 void
 nsXULScrollFrame::InvalidateInternal(const nsRect& aDamageRect,
                                      nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                     PRBool aImmediate)
+                                     PRUint32 aFlags)
 {
   if (aForChild == mInner.mScrolledFrame) {
     // restrict aDamageRect to the scrollable view's bounds
     nsRect r;
     if (r.IntersectRect(aDamageRect + nsPoint(aX, aY),
                         mInner.mScrollableView->View()->GetBounds())) {
-      nsBoxFrame::InvalidateInternal(r, 0, 0, aForChild, aImmediate);
+      nsBoxFrame::InvalidateInternal(r, 0, 0, aForChild, aFlags);
     }
     return;
   }
   
-  nsBoxFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aImmediate);
+  nsBoxFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aFlags);
 }
 
 nscoord
 nsXULScrollFrame::GetBoxAscent(nsBoxLayoutState& aState)
 {
   if (!mInner.mScrolledFrame)
     return 0;
 
@@ -1814,19 +1825,22 @@
 NS_IMETHODIMP
 nsGfxScrollFrameInner::ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY)
 {
   NS_ASSERTION(!mViewInitiatedScroll, "Cannot reenter ScrollPositionDidChange");
 
   mViewInitiatedScroll = PR_TRUE;
   InternalScrollPositionDidChange(aX, aY);
   mViewInitiatedScroll = PR_FALSE;
-  
+
   PostScrollEvent();
-  
+
+  // Notify that the display has changed
+  mOuter->InvalidateWithFlags(nsRect(nsPoint(0, 0), mOuter->GetSize()),
+                              nsIFrame::INVALIDATE_NOTIFY_ONLY);
   return NS_OK;
 }
 
 void nsGfxScrollFrameInner::CurPosAttributeChanged(nsIContent* aContent)
 {
   NS_ASSERTION(aContent, "aContent must not be null");
   NS_ASSERTION((mHScrollbarBox && mHScrollbarBox->GetContent() == aContent) ||
                (mVScrollbarBox && mVScrollbarBox->GetContent() == aContent),
Index: mozilla/layout/generic/nsGfxScrollFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsGfxScrollFrame.h
+++ mozilla/layout/generic/nsGfxScrollFrame.h
@@ -308,17 +308,17 @@
   }
 
   virtual nsIView* GetMouseCapturer() const {
     return mInner.GetScrolledFrame()->GetView();
   }
 
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate);
+                                  PRUint32 aFlags);
 
   virtual PRBool NeedsView() { return PR_TRUE; }
   virtual PRBool DoesClipChildren() { return PR_TRUE; }
   virtual nsSplittableType GetSplittableType() const;
 
   virtual nsPoint GetPositionOfChildIgnoringScrolling(nsIFrame* aChild)
   { nsPoint pt = aChild->GetPosition();
     if (aChild == mInner.GetScrolledFrame()) pt += GetScrollPosition();
@@ -473,17 +473,17 @@
   }
 
   virtual nsIView* GetMouseCapturer() const {
     return mInner.GetScrolledFrame()->GetView();
   }
 
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate);
+                                  PRUint32 aFlags);
 
   virtual PRBool NeedsView() { return PR_TRUE; }
   virtual PRBool DoesClipChildren() { return PR_TRUE; }
   virtual nsSplittableType GetSplittableType() const;
 
   virtual nsPoint GetPositionOfChildIgnoringScrolling(nsIFrame* aChild)
   { nsPoint pt = aChild->GetPosition();
     if (aChild == mInner.GetScrolledFrame()) pt += GetScrollPosition();
Index: mozilla/layout/generic/nsHTMLCanvasFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsHTMLCanvasFrame.cpp
+++ mozilla/layout/generic/nsHTMLCanvasFrame.cpp
@@ -155,17 +155,17 @@
     aMetrics.height -= y + mBorderPadding.top;
     aMetrics.height = PR_MAX(0, aMetrics.height);
   }
 
   aMetrics.mOverflowArea.SetRect(0, 0, aMetrics.width, aMetrics.height);
   FinishAndStoreOverflow(&aMetrics);
 
   if (mRect.width != aMetrics.width || mRect.height != aMetrics.height) {
-    Invalidate(nsRect(0, 0, mRect.width, mRect.height), PR_FALSE);
+    Invalidate(nsRect(0, 0, mRect.width, mRect.height));
   }
 
   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
                   ("exit nsHTMLCanvasFrame::Reflow: size=%d,%d",
                   aMetrics.width, aMetrics.height));
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
   return NS_OK;
 }
Index: mozilla/layout/generic/nsHTMLFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsHTMLFrame.cpp
+++ mozilla/layout/generic/nsHTMLFrame.cpp
@@ -365,17 +365,17 @@
     // We only support the unnamed principal child list
     rv = NS_ERROR_INVALID_ARG;
   
   } else if (aOldFrame == mFrames.FirstChild()) {
     // It's our one and only child frame
     // Damage the area occupied by the deleted frame
     // The child of the canvas probably can't have an outline, but why bother
     // thinking about that?
-    Invalidate(aOldFrame->GetOverflowRect() + aOldFrame->GetPosition(), PR_FALSE);
+    Invalidate(aOldFrame->GetOverflowRect() + aOldFrame->GetPosition());
 
     // Remove the frame and destroy it
     mFrames.DestroyFrame(aOldFrame);
 
     rv = PresContext()->PresShell()->
            FrameNeedsReflow(this, nsIPresShell::eTreeChange,
                             NS_FRAME_HAS_DIRTY_CHILDREN);
   } else {
Index: mozilla/layout/generic/nsIFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsIFrame.h
+++ mozilla/layout/generic/nsIFrame.h
@@ -100,20 +100,20 @@
 struct nsPoint;
 struct nsRect;
 struct nsSize;
 struct nsMargin;
 
 typedef class nsIFrame nsIBox;
 
 // IID for the nsIFrame interface
-// bc99463c-5ff7-4ff3-b2c8-b4172646f793
+// 626a1563-1bae-4a6e-8d2c-2dc2c13048dd
 #define NS_IFRAME_IID \
-{ 0xbc99463c, 0x5ff7, 0x4ff3, \
-  { 0xb2, 0xc8, 0xb4, 0x17, 0x26, 0x46, 0xf7, 0x93 } }
+  { 0x626a1563, 0x1bae, 0x4a6e, \
+    { 0x8d, 0x2c, 0x2d, 0xc2, 0xc1, 0x30, 0x48, 0xdd } }
 
 /**
  * Indication of how the frame can be split. This is used when doing runaround
  * of floats, and when pulling up child frames from a next-in-flow.
  *
  * The choices are splittable, not splittable at all, and splittable in
  * a non-rectangular fashion. This last type only applies to block-level
  * elements, and indicates whether splitting can be used when doing runaround.
@@ -1648,65 +1648,75 @@
    * Does this frame want to capture the mouse when the user clicks in
    * it or its children? If so, return the view which should be
    * targeted for mouse capture. The view need not be this frame's view,
    * it could be the view on a child.
    */
   virtual nsIView* GetMouseCapturer() const { return nsnull; }
 
   /**
+   * @param aFlags see InvalidateInternal below
+   */
+  void InvalidateWithFlags(const nsRect& aDamageRect, PRUint32 aFlags);
+
+  /**
    * Invalidate part of the frame by asking the view manager to repaint.
    * aDamageRect is allowed to extend outside the frame's bounds. We'll do the right
    * thing.
    * We deliberately don't have an Invalidate() method that defaults to the frame's bounds.
    * We want all callers to *think* about what has changed in the frame and what area might
    * need to be repainted.
    *
    * @param aDamageRect is in the frame's local coordinate space
-   * @param aImmediate repaint now if true, repaint later if false.
-   *   In case it's true, pending notifications will be flushed which
-   *   could cause frames to be deleted (including |this|).
    */
-  void Invalidate(const nsRect& aDamageRect, PRBool aImmediate = PR_FALSE);
+  void Invalidate(const nsRect& aDamageRect)
+  { return InvalidateWithFlags(aDamageRect, 0); }
 
   /**
    * Helper function that can be overridden by frame classes. The rectangle
    * (plus aOffsetX/aOffsetY) is relative to this frame.
    * 
    * The offset is given as two coords rather than as an nsPoint because
    * gcc optimizes it better that way, in particular in the default
    * implementation that passes the area to the parent frame becomes a tail
    * call.
    *
    * The default implementation will crash if the frame has no parent so
    * frames without parents MUST* override.
    * 
    * @param aForChild if the invalidation is coming from a child frame, this
    * is the frame; otherwise, this is null.
-   * @param aImmediate repaint now if true, repaint later if false.
+   * @param aFlags INVALIDATE_IMMEDIATE: repaint now if true, repaint later if false.
    *   In case it's true, pending notifications will be flushed which
    *   could cause frames to be deleted (including |this|).
-   */  
+   * @param aFlags INVALIDATE_CROSS_DOC: true if the invalidation
+   *   originated in a subdocument
+   */
+  enum {
+  	INVALIDATE_IMMEDIATE = 0x1,
+  	INVALIDATE_CROSS_DOC = 0x2,
+  	INVALIDATE_NOTIFY_ONLY = 0x4
+  };
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aOffsetX, nscoord aOffsetY,
-                                  nsIFrame* aForChild, PRBool aImmediate);
+                                  nsIFrame* aForChild, PRUint32 aFlags);
 
   /**
    * Helper function that funnels an InvalidateInternal request up to the
    * parent.  This function is used so that if MOZ_SVG is not defined, we still
    * have unified control paths in the InvalidateInternal chain.
    *
    * @param aDamageRect The rect to invalidate.
    * @param aX The x offset from the origin of this frame to the rectangle.
    * @param aY The y offset from the origin of this frame to the rectangle.
    * @param aImmediate Whether to redraw immediately.
    * @return None, though this funnels the request up to the parent frame.
    */
   void InvalidateInternalAfterResize(const nsRect& aDamageRect, nscoord aX,
-                                     nscoord aY, PRBool aImmediate);
+                                     nscoord aY, PRUint32 aFlags);
 
   /**
    * Take two rectangles in the coordinate system of this frame which
    * have the same origin and invalidate the difference between them.
    * This is a helper method to be used when a frame is being resized.
    *
    * @param aR1 the first rectangle
    * @param aR2 the second rectangle
@@ -2216,19 +2226,17 @@
   nsIFrame*        mNextSibling;  // singly-linked list of frames
   nsFrameState     mState;
   
   // Helpers
   /**
    * For frames that have top-level windows (top-level viewports,
    * comboboxes, menupoups) this function will invalidate the window.
    */
-  void InvalidateRoot(const nsRect& aDamageRect,
-                      nscoord aOffsetX, nscoord aOffsetY,
-                      PRBool aImmediate);
+  void InvalidateRoot(const nsRect& aDamageRect, PRUint32 aFlags);
 
   /**
    * Gets the overflow area for any properties that are common to all types of frames
    * e.g. outlines.
    */
   nsRect GetAdditionalOverflow(const nsRect& aOverflowArea, const nsSize& aNewSize);
 
   /**
Index: mozilla/layout/generic/nsImageFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsImageFrame.cpp
+++ mozilla/layout/generic/nsImageFrame.cpp
@@ -547,17 +547,17 @@
   
   // XXX We really need to round this out, now that we're doing better
   // image scaling!
   nsRect r = SourceRectToDest(*aRect);
 
   // handle iconLoads first...
   if (HandleIconLoads(aRequest, PR_FALSE)) {
     // Image changed, invalidate
-    Invalidate(r, PR_FALSE);
+    Invalidate(r);
     return NS_OK;
   }
 
   if (IsPendingLoad(aRequest)) {
     // We don't care
     return NS_OK;
   }
 
@@ -575,17 +575,17 @@
   }
 
 #ifdef DEBUG_decode
   printf("Source rect (%d,%d,%d,%d) -> invalidate dest rect (%d,%d,%d,%d)\n",
          aRect->x, aRect->y, aRect->width, aRect->height,
          r.x, r.y, r.width, r.height);
 #endif
 
-  Invalidate(r, PR_FALSE);
+  Invalidate(r);
   
   return NS_OK;
 }
 
 nsresult
 nsImageFrame::OnStopDecode(imgIRequest *aRequest,
                            nsresult aStatus,
                            const PRUnichar *aStatusArg)
@@ -628,17 +628,17 @@
         if (presShell) { 
           presShell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
                                       NS_FRAME_IS_DIRTY);
         }
       } else {
         nsSize s = GetSize();
         nsRect r(0, 0, s.width, s.height);
         // Update border+content to account for image change
-        Invalidate(r, PR_FALSE);
+        Invalidate(r);
       }
     }
   }
 
   return NS_OK;
 }
 
 nsresult
@@ -653,17 +653,17 @@
   if (IsPendingLoad(aContainer)) {
     // We don't care about it
     return NS_OK;
   }
   
   nsRect r = SourceRectToDest(*aDirtyRect);
 
   // Update border+content to account for image change
-  Invalidate(r, PR_FALSE);
+  Invalidate(r);
   return NS_OK;
 }
 
 void
 nsImageFrame::EnsureIntrinsicSize(nsPresContext* aPresContext)
 {
   // if mIntrinsicSize.width and height are 0, then we should
   // check to see if the size is already known by the image container.
@@ -844,17 +844,17 @@
   FinishAndStoreOverflow(&aMetrics);
 
   // Now that that's all done, check whether we're resizing... if we are,
   // invalidate our rect.
   // XXXbz we really only want to do this when reflow is completely done, but
   // we have no way to detect when mRect changes (since SetRect is non-virtual,
   // so this is the best we can do).
   if (mRect.width != aMetrics.width || mRect.height != aMetrics.height) {
-    Invalidate(nsRect(0, 0, mRect.width, mRect.height), PR_FALSE);
+    Invalidate(nsRect(0, 0, mRect.width, mRect.height));
   }
 
   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
                   ("exit nsImageFrame::Reflow: size=%d,%d",
                   aMetrics.width, aMetrics.height));
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
   return NS_OK;
 }
Index: mozilla/layout/generic/nsImageMap.cpp
===================================================================
--- mozilla.orig/layout/generic/nsImageMap.cpp
+++ mozilla/layout/generic/nsImageMap.cpp
@@ -1019,17 +1019,17 @@
           //This check is necessary to see if we're still attached to the doc
           if (doc) {
             nsIPresShell *presShell = doc->GetPrimaryShell();
             if (presShell) {
               nsIFrame* imgFrame = presShell->GetPrimaryFrameFor(targetContent);
               if (imgFrame) {
                 nsRect dmgRect;
                 area->GetRect(imgFrame, dmgRect);
-                imgFrame->Invalidate(dmgRect, PR_FALSE);
+                imgFrame->Invalidate(dmgRect);
               }
             }
           }
           break;
         }
       }
     }
   }
Index: mozilla/layout/generic/nsTextFrameThebes.cpp
===================================================================
--- mozilla.orig/layout/generic/nsTextFrameThebes.cpp
+++ mozilla/layout/generic/nsTextFrameThebes.cpp
@@ -2751,17 +2751,17 @@
 
   PRInt32 i, n = mFrames.Count();
   for (i = 0; i < n; i++) {
     FrameData* frameData = (FrameData*) mFrames.ElementAt(i);
 
     // Determine damaged area and tell view manager to redraw it
     // blink doesn't blink outline ... I hope
     nsRect bounds(nsPoint(0, 0), frameData->mFrame->GetSize());
-    frameData->mFrame->Invalidate(bounds, PR_FALSE);
+    frameData->mFrame->Invalidate(bounds);
   }
   return NS_OK;
 }
 
 
 // static
 nsresult nsBlinkTimer::AddBlinkFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
 {
@@ -4695,17 +4695,17 @@
     PRBool willHaveSelectionUnderline =
              aSelected && HasSelectionOverflowingDecorations(PresContext());
     if (didHaveSelectionUnderline != willHaveSelectionUnderline) {
       PresContext()->PresShell()->FrameNeedsReflow(this,
                                                    nsIPresShell::eStyleChange,
                                                    NS_FRAME_IS_DIRTY);
     }
     // Selection might change anything. Invalidate the overflow area.
-    Invalidate(GetOverflowRect(), PR_FALSE);
+    InvalidateOverflowRect();
   }
   if (aSpread == eSpreadDown)
   {
     nsIFrame* frame = GetPrevContinuation();
     while(frame){
       frame->SetSelected(aPresContext, aRange,aSelected,eSpreadNone, aType);
       frame = frame->GetPrevContinuation();
     }
Index: mozilla/layout/generic/nsVideoFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsVideoFrame.cpp
+++ mozilla/layout/generic/nsVideoFrame.cpp
@@ -177,17 +177,17 @@
                                      aReflowState.ComputedWidth(), aReflowState.ComputedHeight()));
   }
 
   aMetrics.mOverflowArea.SetRect(0, 0, aMetrics.width, aMetrics.height);
 
   FinishAndStoreOverflow(&aMetrics);
 
   if (mRect.width != aMetrics.width || mRect.height != aMetrics.height) {
-    Invalidate(nsRect(0, 0, mRect.width, mRect.height), PR_FALSE);
+    Invalidate(nsRect(0, 0, mRect.width, mRect.height));
   }
 
   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
                   ("exit nsVideoFrame::Reflow: size=%d,%d",
                   aMetrics.width, aMetrics.height));
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
 
   return NS_OK;
Index: mozilla/layout/generic/nsViewportFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsViewportFrame.cpp
+++ mozilla/layout/generic/nsViewportFrame.cpp
@@ -316,17 +316,17 @@
   rv = mFixedContainer.Reflow(this, aPresContext, reflowState, aStatus,
                               reflowState.ComputedWidth(),
                               reflowState.ComputedHeight(),
                               PR_FALSE, PR_TRUE, PR_TRUE); // XXX could be optimized
 
   // If we were dirty then do a repaint
   if (GetStateBits() & NS_FRAME_IS_DIRTY) {
     nsRect damageRect(0, 0, aDesiredSize.width, aDesiredSize.height);
-    Invalidate(damageRect, PR_FALSE);
+    Invalidate(damageRect);
   }
 
   // XXX Should we do something to clip our children to this?
   aDesiredSize.mOverflowArea =
     nsRect(nsPoint(0, 0), nsSize(aDesiredSize.width, aDesiredSize.height));
 
   NS_FRAME_TRACE_REFLOW_OUT("ViewportFrame::Reflow", aStatus);
   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
@@ -343,25 +343,29 @@
 ViewportFrame::IsContainingBlock() const
 {
   return PR_TRUE;
 }
 
 void
 ViewportFrame::InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate)
+                                  PRUint32 aFlags)
 {
+  nsRect r = aDamageRect + nsPoint(aX, aY);
+  PresContext()->NotifyInvalidation(r, (aFlags & INVALIDATE_CROSS_DOC) != 0);
+
   nsIFrame* parent = nsLayoutUtils::GetCrossDocParentFrame(this);
   if (parent) {
     nsPoint pt = GetOffsetTo(parent);
-    parent->InvalidateInternal(aDamageRect, aX + pt.x, aY + pt.y, this, aImmediate);
+    parent->InvalidateInternal(r, pt.x, pt.y, this,
+                               aFlags | INVALIDATE_CROSS_DOC);
     return;
   }
-  InvalidateRoot(aDamageRect, aX, aY, aImmediate);
+  InvalidateRoot(r, aFlags);
 }
 
 #ifdef DEBUG
 NS_IMETHODIMP
 ViewportFrame::GetFrameName(nsAString& aResult) const
 {
   return MakeFrameName(NS_LITERAL_STRING("Viewport"), aResult);
 }
Index: mozilla/layout/generic/nsViewportFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsViewportFrame.h
+++ mozilla/layout/generic/nsViewportFrame.h
@@ -105,17 +105,17 @@
    * @see nsGkAtoms::viewportFrame
    */
   virtual nsIAtom* GetType() const;
   
   virtual PRBool IsContainingBlock() const;
 
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate);
+                                  PRUint32 aFlags);
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
 
 protected:
   nsPoint AdjustReflowStateForScrollbars(nsHTMLReflowState* aReflowState) const;
 
Index: mozilla/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
===================================================================
--- mozilla.orig/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
+++ mozilla/layout/svg/base/src/nsSVGForeignObjectFrame.cpp
@@ -167,22 +167,24 @@
 
   return NS_OK;
 }
 
 void
 nsSVGForeignObjectFrame::InvalidateInternal(const nsRect& aDamageRect,
                                             nscoord aX, nscoord aY,
                                             nsIFrame* aForChild,
-                                            PRBool aImmediate)
+                                            PRUint32 aFlags)
 {
   if (mParent->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)
     return;
 
-  mDirtyRegion.Or(mDirtyRegion, aDamageRect + nsPoint(aX, aY));
+  nsRegion* region = (aFlags & INVALIDATE_CROSS_DOC)
+    ? &mCrossDocDirtyRegion : &mSameDocDirtyRegion;
+  region->Or(*region, aDamageRect + nsPoint(aX, aY));
   FlushDirtyRegion();
 }
 
 
 //----------------------------------------------------------------------
 // nsISVGChildFrame methods
 
 /**
@@ -590,17 +592,18 @@
   PresContext()->PresShell()->FrameNeedsReflow(kid, aType, NS_FRAME_IS_DIRTY);
 }
 
 void nsSVGForeignObjectFrame::UpdateGraphic()
 {
   nsSVGUtils::UpdateGraphic(this);
 
   // Clear any layout dirty region since we invalidated our whole area.
-  mDirtyRegion.SetEmpty();
+  mSameDocDirtyRegion.SetEmpty();
+  mCrossDocDirtyRegion.SetEmpty();
 }
 
 void
 nsSVGForeignObjectFrame::MaybeReflowFromOuterSVGFrame()
 {
   // If we're already scheduled to reflow (i.e. our kid is dirty) we don't
   // want to reflow now or else our presShell will do extra work trying to
   // reflow us a second time. (It will also complain if it finds that a reflow
@@ -684,37 +687,51 @@
   FinishReflowChild(kid, presContext, &reflowState, desiredSize, 0, 0,
                     NS_FRAME_NO_MOVE_FRAME);
   
   mInReflow = PR_FALSE;
   FlushDirtyRegion();
 }
 
 void
+nsSVGForeignObjectFrame::InvalidateDirtyRect(nsSVGOuterSVGFrame* aOuter,
+    const nsRect& aRect, PRUint32 aFlags)
+{
+  if (aRect.IsEmpty())
+    return;
+
+  nsPresContext* presContext = PresContext();
+  nsCOMPtr<nsIDOMSVGMatrix> tm = GetTMIncludingOffset();
+  nsIntRect r = aRect;
+  r.ScaleRoundOut(1.0f / presContext->AppUnitsPerDevPixel());
+  float x = r.x, y = r.y, w = r.width, h = r.height;
+  nsRect rect = GetTransformedRegion(x, y, w, h, tm, presContext);
+
+  // XXX invalidate the entire covered region
+  // See bug 418063
+  rect.UnionRect(rect, mRect);
+
+  rect = nsSVGUtils::FindFilterInvalidation(this, rect);
+  aOuter->InvalidateWithFlags(rect, aFlags);
+}
+
+void
 nsSVGForeignObjectFrame::FlushDirtyRegion()
 {
-  if (mDirtyRegion.IsEmpty() || mInReflow)
+  if ((mSameDocDirtyRegion.IsEmpty() && mCrossDocDirtyRegion.IsEmpty()) ||
+      mInReflow)
     return;
 
   nsSVGOuterSVGFrame *outerSVGFrame = nsSVGUtils::GetOuterSVGFrame(this);
   if (!outerSVGFrame) {
     NS_ERROR("null outerSVGFrame");
     return;
   }
 
   if (outerSVGFrame->IsRedrawSuspended())
     return;
 
-  nsCOMPtr<nsIDOMSVGMatrix> tm = GetTMIncludingOffset();
-  nsIntRect r = mDirtyRegion.GetBounds();
-  r.ScaleRoundOut(1.0f / PresContext()->AppUnitsPerDevPixel());
-  float x = r.x, y = r.y, w = r.width, h = r.height;
-  nsRect rect = GetTransformedRegion(x, y, w, h, tm, PresContext());
-
-  // XXX invalidate the entire covered region
-  // See bug 418063
-  rect.UnionRect(rect, mRect);
-
-  rect = nsSVGUtils::FindFilterInvalidation(this, rect);
-  outerSVGFrame->Invalidate(rect);
+  InvalidateDirtyRect(outerSVGFrame, mSameDocDirtyRegion.GetBounds(), 0);
+  InvalidateDirtyRect(outerSVGFrame, mCrossDocDirtyRegion.GetBounds(), INVALIDATE_CROSS_DOC);
 
-  mDirtyRegion.SetEmpty();
+  mSameDocDirtyRegion.SetEmpty();
+  mCrossDocDirtyRegion.SetEmpty();
 }
Index: mozilla/layout/svg/base/src/nsSVGForeignObjectFrame.h
===================================================================
--- mozilla.orig/layout/svg/base/src/nsSVGForeignObjectFrame.h
+++ mozilla/layout/svg/base/src/nsSVGForeignObjectFrame.h
@@ -40,16 +40,18 @@
 #define NSSVGFOREIGNOBJECTFRAME_H__
 
 #include "nsContainerFrame.h"
 #include "nsISVGChildFrame.h"
 #include "nsIDOMSVGMatrix.h"
 #include "nsRegion.h"
 #include "nsIPresShell.h"
 
+class nsSVGOuterSVGFrame;
+
 typedef nsContainerFrame nsSVGForeignObjectFrameBase;
 
 class nsSVGForeignObjectFrame : public nsSVGForeignObjectFrameBase,
                                 public nsISVGChildFrame
 {
   friend nsIFrame*
   NS_NewSVGForeignObjectFrame(nsIPresShell* aPresShell, nsIContent* aContent, nsStyleContext* aContext);
 protected:
@@ -103,17 +105,17 @@
   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
   {
     return nsSVGForeignObjectFrameBase::IsFrameOfType(aFlags &
       ~(nsIFrame::eSVG | nsIFrame::eSVGForeignObject));
   }
 
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate);
+                                  PRUint32 aFlags);
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const
   {
     return MakeFrameName(NS_LITERAL_STRING("SVGForeignObject"), aResult);
   }
 #endif
 
@@ -148,22 +150,27 @@
 
 protected:
   // implementation helpers:
   void DoReflow();
   void RequestReflow(nsIPresShell::IntrinsicDirty aType);
   void UpdateGraphic();
   already_AddRefed<nsIDOMSVGMatrix> GetTMIncludingOffset();
   nsresult TransformPointFromOuterPx(const nsPoint &aIn, nsPoint* aOut);
+  void InvalidateDirtyRect(nsSVGOuterSVGFrame* aOuter,
+                           const nsRect& aRect, PRUint32 aFlags);
   void FlushDirtyRegion();
 
   // If width or height is less than or equal to zero we must disable rendering
   PRBool IsDisabled() const { return mRect.width <= 0 || mRect.height <= 0; }
 
   nsCOMPtr<nsIDOMSVGMatrix> mCanvasTM;
   nsCOMPtr<nsIDOMSVGMatrix> mOverrideCTM;
-  nsRegion                  mDirtyRegion;
+  // Damage area due to in-this-doc invalidation
+  nsRegion mSameDocDirtyRegion;
+  // Damage area due to cross-doc invalidation
+  nsRegion mCrossDocDirtyRegion;
 
   PRPackedBool mPropagateTransform;
   PRPackedBool mInReflow;
 };
 
 #endif
Index: mozilla/layout/svg/base/src/nsSVGOuterSVGFrame.cpp
===================================================================
--- mozilla.orig/layout/svg/base/src/nsSVGOuterSVGFrame.cpp
+++ mozilla/layout/svg/base/src/nsSVGOuterSVGFrame.cpp
@@ -587,23 +587,32 @@
     // It's not really clear what area to invalidate here. We might have
     // stuffed up rendering for the entire window in this paint pass,
     // so we can't just invalidate our own rect. Invalidate everything
     // in sight.
     // This won't work for printing, by the way, but failure to print the
     // odd document is probably no worse than printing horribly for all
     // documents. Better to fix things so we don't need fallback.
     nsIFrame* frame = this;
+    nsPresContext* presContext = PresContext();
+    PRUint32 flags = 0;
     while (PR_TRUE) {
       nsIFrame* next = nsLayoutUtils::GetCrossDocParentFrame(frame);
       if (!next)
         break;
+      if (frame->GetParent() != next) {
+        // We're crossing a document boundary. Logically, the invalidation is
+        // being triggered by a subdocument of the root document. This will
+        // prevent an untrusted root document being told about invalidation
+        // that happened because a child was using SVG...
+        flags |= INVALIDATE_CROSS_DOC;
+      }
       frame = next;
     }
-    frame->Invalidate(nsRect(nsPoint(0, 0), frame->GetSize()));
+    frame->InvalidateWithFlags(nsRect(nsPoint(0, 0), frame->GetSize()), flags);
   }
 #endif
 
 #if defined(DEBUG) && defined(SVG_DEBUG_PAINT_TIMING)
   PRTime end = PR_Now();
   printf("SVG Paint Timing: %f ms\n", (end-start)/1000.0);
 #endif
   
Index: mozilla/layout/tables/nsTableCellFrame.cpp
===================================================================
--- mozilla.orig/layout/tables/nsTableCellFrame.cpp
+++ mozilla/layout/tables/nsTableCellFrame.cpp
@@ -512,17 +512,17 @@
   // Note that in current version, aRange and aSpread are ignored,
   //   only this frame is considered
   nsFrame::SetSelected(aPresContext, aRange, aSelected, aSpread, aType);
 
   nsCOMPtr<nsFrameSelection> frameSelection =
     aPresContext->PresShell()->FrameSelection();
   if (frameSelection->GetTableCellSelection()) {
     // Selection can affect content, border and outline
-    Invalidate(GetOverflowRect(), PR_FALSE);
+    InvalidateOverflowRect();
   }
   return NS_OK;
 }
 
 PRIntn
 nsTableCellFrame::GetSkipSides() const
 {
   PRIntn skip = 0;
@@ -928,17 +928,17 @@
     // Don't pass OVERFLOW_INCOMPLETE through tables until they can actually handle it
     //XXX should paginate overflow as overflow, but not in this patch (bug 379349)
     NS_FRAME_SET_INCOMPLETE(aStatus);
     printf("Set table cell incomplete %p\n", this);
   }
 
   // XXXbz is this invalidate actually needed, really?
   if (GetStateBits() & NS_FRAME_IS_DIRTY) {
-    Invalidate(GetOverflowRect(), PR_FALSE);
+    InvalidateOverflowRect();
   }
 
 #ifdef NS_DEBUG
   DebugCheckChildSize(firstKid, kidSize, availSize);
 #endif
 
   // 0 dimensioned cells need to be treated specially in Standard/NavQuirks mode 
   // see testcase "emptyCells.html"
Index: mozilla/layout/xul/base/src/nsBox.cpp
===================================================================
--- mozilla.orig/layout/xul/base/src/nsBox.cpp
+++ mozilla/layout/xul/base/src/nsBox.cpp
@@ -651,17 +651,17 @@
     return NS_OK;
 
   nsRect damageRect(0,0,0,0);
   if (aDamageRect)
     damageRect = *aDamageRect;
   else
     damageRect = GetOverflowRect();
 
-  Invalidate(damageRect, aImmediate);
+  InvalidateWithFlags(damageRect, aImmediate ? INVALIDATE_IMMEDIATE : 0);
 
   return NS_OK;
 }
 
 PRBool 
 nsIBox::AddCSSPrefSize(nsBoxLayoutState& aState, nsIBox* aBox, nsSize& aSize)
 {
     PRBool widthSet = PR_FALSE, heightSet = PR_FALSE;
Index: mozilla/layout/xul/base/src/nsMenuPopupFrame.cpp
===================================================================
--- mozilla.orig/layout/xul/base/src/nsMenuPopupFrame.cpp
+++ mozilla/layout/xul/base/src/nsMenuPopupFrame.cpp
@@ -679,19 +679,19 @@
   if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
     (static_cast<nsMenuFrame*>(parent))->PopupClosed(aDeselectMenu);
   }
 }
 
 void
 nsMenuPopupFrame::InvalidateInternal(const nsRect& aDamageRect,
                                      nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                     PRBool aImmediate)
+                                     PRUint32 aFlags)
 {
-  InvalidateRoot(aDamageRect, aX, aY, aImmediate);
+  InvalidateRoot(aDamageRect + nsPoint(aX, aY), aFlags);
 }
 
 void
 nsMenuPopupFrame::GetLayoutFlags(PRUint32& aFlags)
 {
   aFlags = NS_FRAME_NO_SIZE_VIEW | NS_FRAME_NO_MOVE_VIEW | NS_FRAME_NO_VISIBILITY;
 }
 
Index: mozilla/layout/xul/base/src/nsMenuPopupFrame.h
===================================================================
--- mozilla.orig/layout/xul/base/src/nsMenuPopupFrame.h
+++ mozilla/layout/xul/base/src/nsMenuPopupFrame.h
@@ -169,17 +169,17 @@
   NS_IMETHOD AttributeChanged(PRInt32 aNameSpaceID,
                               nsIAtom* aAttribute,
                               PRInt32 aModType);
 
   virtual void Destroy();
 
   virtual void InvalidateInternal(const nsRect& aDamageRect,
                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
-                                  PRBool aImmediate);
+                                  PRUint32 aFlags);
 
   // returns true if the popup is a panel with the noautohide attribute set to
   // true. These panels do not roll up automatically.
   PRBool IsNoAutoHide();
 
   // returns true if the popup is a top-most window. Otherwise, the
   // panel appears in front of the parent window.
   PRBool IsTopMost();
Index: mozilla/layout/xul/base/src/nsSliderFrame.cpp
===================================================================
--- mozilla.orig/layout/xul/base/src/nsSliderFrame.cpp
+++ mozilla/layout/xul/base/src/nsSliderFrame.cpp
@@ -679,17 +679,17 @@
      newThumbRect.x = clientRect.x + nscoord(float(pos * onePixel) * mRatio);
   else
      newThumbRect.y = clientRect.y + nscoord(float(pos * onePixel) * mRatio);
 
   // set the rect
   thumbFrame->SetRect(newThumbRect);
 
   // Redraw the scrollbar
-  Invalidate(clientRect, aImmediateRedraw);
+  InvalidateWithFlags(clientRect, aImmediateRedraw ? INVALIDATE_IMMEDIATE : 0);
 
   if (mScrollbarListener)
     mScrollbarListener->PositionChanged(aPresContext, mCurPos, curpospx);
 
   mCurPos = curpospx;
 
   return NS_OK;
 }
Index: mozilla/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
===================================================================
--- mozilla.orig/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
+++ mozilla/layout/xul/base/src/tree/src/nsTreeBodyFrame.cpp
@@ -687,17 +687,17 @@
 }
 
 NS_IMETHODIMP
 nsTreeBodyFrame::Invalidate()
 {
   if (mUpdateBatchNest)
     return NS_OK;
 
-  nsIFrame::Invalidate(GetOverflowRect(), PR_FALSE);
+  InvalidateOverflowRect();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsTreeBodyFrame::InvalidateColumn(nsITreeColumn* aCol)
 {
   if (mUpdateBatchNest)
@@ -714,17 +714,17 @@
 #endif
 
   nsRect columnRect;
   nsresult rv = col->GetRect(this, mInnerBox.y, mInnerBox.height, &columnRect);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // When false then column is out of view
   if (OffsetForHorzScroll(columnRect, PR_TRUE))
-      nsIFrame::Invalidate(columnRect, PR_FALSE);
+      nsIFrame::Invalidate(columnRect);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsTreeBodyFrame::InvalidateRow(PRInt32 aIndex)
 {
   if (mUpdateBatchNest)
@@ -736,17 +736,17 @@
     FireInvalidateEvent(aIndex, aIndex, nsnull, nsnull);
 #endif
 
   aIndex -= mTopRowIndex;
   if (aIndex < 0 || aIndex > mPageLength)
     return NS_OK;
 
   nsRect rowRect(mInnerBox.x, mInnerBox.y+mRowHeight*aIndex, mInnerBox.width, mRowHeight);
-  nsLeafBoxFrame::Invalidate(rowRect, PR_FALSE);
+  nsLeafBoxFrame::Invalidate(rowRect);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsTreeBodyFrame::InvalidateCell(PRInt32 aIndex, nsITreeColumn* aCol)
 {
   if (mUpdateBatchNest)
@@ -767,17 +767,17 @@
     return NS_ERROR_INVALID_ARG;
 
   nsRect cellRect;
   nsresult rv = col->GetRect(this, mInnerBox.y+mRowHeight*aIndex, mRowHeight,
                              &cellRect);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (OffsetForHorzScroll(cellRect, PR_TRUE))
-    nsIFrame::Invalidate(cellRect, PR_FALSE);
+    nsIFrame::Invalidate(cellRect);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsTreeBodyFrame::InvalidateRange(PRInt32 aStart, PRInt32 aEnd)
 {
   if (mUpdateBatchNest)
@@ -801,17 +801,17 @@
   if (presShell->IsAccessibilityActive()) {
     PRInt32 end =
       mRowCount > 0 ? ((mRowCount <= aEnd) ? mRowCount - 1 : aEnd) : 0;
     FireInvalidateEvent(aStart, end, nsnull, nsnull);
   }
 #endif
 
   nsRect rangeRect(mInnerBox.x, mInnerBox.y+mRowHeight*(aStart-mTopRowIndex), mInnerBox.width, mRowHeight*(aEnd-aStart+1));
-  nsIFrame::Invalidate(rangeRect, PR_FALSE);
+  nsIFrame::Invalidate(rangeRect);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsTreeBodyFrame::InvalidateColumnRange(PRInt32 aStart, PRInt32 aEnd, nsITreeColumn* aCol)
 {
   if (mUpdateBatchNest)
@@ -845,17 +845,17 @@
 
   nsRect rangeRect;
   nsresult rv = col->GetRect(this, 
                              mInnerBox.y+mRowHeight*(aStart-mTopRowIndex),
                              mRowHeight*(aEnd-aStart+1),
                              &rangeRect);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  nsIFrame::Invalidate(rangeRect, PR_FALSE);
+  nsIFrame::Invalidate(rangeRect);
 
   return NS_OK;
 }
 
 static void
 FindScrollParts(nsIFrame* aCurrFrame, nsTreeBodyFrame::ScrollParts* aResult)
 {
   if (!aResult->mColumnsScrollableView) {
Index: mozilla/widget/public/nsGUIEvent.h
===================================================================
--- mozilla.orig/widget/public/nsGUIEvent.h
+++ mozilla/widget/public/nsGUIEvent.h
@@ -37,16 +37,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsGUIEvent_h__
 #define nsGUIEvent_h__
 
 #include "nsPoint.h"
 #include "nsRect.h"
+#include "nsRegion.h"
 #include "nsEvent.h"
 #include "nsStringGlue.h"
 #include "nsCOMPtr.h"
 #include "nsIAtom.h"
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMDataTransfer.h"
 #include "nsWeakPtr.h"
 #include "nsIWidget.h"
@@ -96,16 +97,17 @@
 #define NS_SVGZOOM_EVENT                  31
 #endif // MOZ_SVG
 #define NS_XUL_COMMAND_EVENT              32
 #define NS_QUERY_CONTENT_EVENT            33
 #ifdef MOZ_MEDIA
 #define NS_MEDIA_EVENT                    34
 #endif // MOZ_MEDIA
 #define NS_DRAG_EVENT                     35
+#define NS_NOTIFYPAINT_EVENT              36
 
 // These flags are sort of a mess. They're sort of shared between event
 // listener flags and event flags, but only some of them. You've been
 // warned!
 #define NS_EVENT_FLAG_NONE                0x0000
 #define NS_EVENT_FLAG_TRUSTED             0x0001
 #define NS_EVENT_FLAG_BUBBLE              0x0002
 #define NS_EVENT_FLAG_CAPTURE             0x0004
@@ -371,16 +373,20 @@
 #define NS_CANPLAYTHROUGH      (NS_MEDIA_EVENT_START+16)
 #define NS_RATECHANGE          (NS_MEDIA_EVENT_START+17)
 #define NS_DURATIONCHANGE      (NS_MEDIA_EVENT_START+18)
 #define NS_VOLUMECHANGE        (NS_MEDIA_EVENT_START+19)
 #define NS_MEDIA_ABORT         (NS_MEDIA_EVENT_START+20)
 #define NS_MEDIA_ERROR         (NS_MEDIA_EVENT_START+21)
 #endif // MOZ_MEDIA
 
+// paint notification events
+#define NS_NOTIFYPAINT_START    3400
+#define NS_AFTERPAINT           (NS_NOTIFYPAINT_START)
+
 /**
  * Return status for event processors, nsEventStatus, is defined in
  * nsEvent.h.
  */
 
 /**
  * sizemode is an adjunct to widget size
  */
@@ -1067,16 +1073,33 @@
       detail(d)
   {
   }
 
   PRInt32 detail;
 };
 
 /**
+ * NotifyPaint event
+ */
+class nsNotifyPaintEvent : public nsEvent
+{
+public:
+  nsNotifyPaintEvent(PRBool isTrusted, PRUint32 msg,
+                     const nsRegion& aSameDocRegion, const nsRegion& aCrossDocRegion)
+    : nsEvent(isTrusted, msg, NS_NOTIFYPAINT_EVENT),
+      sameDocRegion(aSameDocRegion), crossDocRegion(aCrossDocRegion)
+  {
+  }
+
+  nsRegion sameDocRegion;
+  nsRegion crossDocRegion;
+};
+
+/**
  * PageTransition event
  */
 class nsPageTransitionEvent : public nsEvent
 {
 public:
   nsPageTransitionEvent(PRBool isTrusted, PRUint32 msg, PRBool p)
     : nsEvent(isTrusted, msg, NS_PAGETRANSITION_EVENT),
       persisted(p)
