#Bug 369722  prdtoa.c jsnum.h txDouble.h not required IEEE_ARM define on Codesourcery EABI gcc3.4.4 compiler
Index: content/xslt/public/txDouble.h
===================================================================
--- content/xslt/public/txDouble.h.orig
+++ content/xslt/public/txDouble.h
@@ -57,47 +57,48 @@ fp_except_t oldmask = fpsetmask(~allmask
 
 /**
  * Stefan Hanske <sh990154@mail.uni-greifswald.de> reports:
  *  ARM is a little endian architecture but 64 bit double words are stored
  * differently: the 32 bit words are in little endian byte order, the two words
  * are stored in big endian`s way.
  */
 
-#if defined(__arm) || defined(__arm32__) || defined(__arm26__) || defined(__arm__)
-#define CPU_IS_ARM
+#if !defined(__ARM_EABI__) && \
+    (defined(__arm) || defined(__arm32__) || defined(__arm26__) || defined(__arm__))
+#define IEEE_ARM
 #endif
 
 #if (__GNUC__ == 2 && __GNUC_MINOR__ > 95) || __GNUC__ > 2
 /**
  * This version of the macros is safe for the alias optimizations
  * that gcc does, but uses gcc-specific extensions.
  */
 
 typedef union txdpun {
     PRFloat64 d;
     struct {
-#if defined(IS_LITTLE_ENDIAN) && !defined(CPU_IS_ARM)
+#if defined(IS_LITTLE_ENDIAN) && !defined(IEEE_ARM)
         PRUint32 lo, hi;
 #else
         PRUint32 hi, lo;
 #endif
     } s;
 } txdpun;
 
 #define TX_DOUBLE_HI32(x) (__extension__ ({ txdpun u; u.d = (x); u.s.hi; }))
 #define TX_DOUBLE_LO32(x) (__extension__ ({ txdpun u; u.d = (x); u.s.lo; }))
 
 #else // __GNUC__
 
 /* We don't know of any non-gcc compilers that perform alias optimization,
  * so this code should work.
  */
 
-#if defined(IS_LITTLE_ENDIAN) && !defined(CPU_IS_ARM)
+#if defined(IS_LITTLE_ENDIAN) && !defined(IEEE_ARM)
 #define TX_DOUBLE_HI32(x)        (((PRUint32 *)&(x))[1])
 #define TX_DOUBLE_LO32(x)        (((PRUint32 *)&(x))[0])
 #else
 #define TX_DOUBLE_HI32(x)        (((PRUint32 *)&(x))[0])
 #define TX_DOUBLE_LO32(x)        (((PRUint32 *)&(x))[1])
 #endif
 
 #endif // __GNUC__
Index: js/src/jsnum.h
===================================================================
--- js/src/jsnum.h.orig
+++ js/src/jsnum.h
@@ -52,23 +52,24 @@ JS_BEGIN_EXTERN_C
 
 /*
  * Stefan Hanske <sh990154@mail.uni-greifswald.de> reports:
  *  ARM is a little endian architecture but 64 bit double words are stored
  * differently: the 32 bit words are in little endian byte order, the two words
  * are stored in big endian`s way.
  */
 
-#if defined(__arm) || defined(__arm32__) || defined(__arm26__) || defined(__arm__)
-#define CPU_IS_ARM
+#if !defined(__ARM_EABI__) && \
+    (defined(__arm) || defined(__arm32__) || defined(__arm26__) || defined(__arm__))
+#define IEEE_ARM
 #endif
 
 typedef union jsdpun {
     struct {
-#if defined(IS_LITTLE_ENDIAN) && !defined(CPU_IS_ARM)
+#if defined(IS_LITTLE_ENDIAN) && !defined(IEEE_ARM)
         uint32 lo, hi;
 #else
         uint32 hi, lo;
 #endif
     } s;
     jsdouble d;
 } jsdpun;
 
@@ -87,17 +88,17 @@ typedef union jsdpun {
 
 #else /* not or old GNUC */
 
 /*
  * We don't know of any non-gcc compilers that perform alias optimization,
  * so this code should work.
  */
 
-#if defined(IS_LITTLE_ENDIAN) && !defined(CPU_IS_ARM)
+#if defined(IS_LITTLE_ENDIAN) && !defined(IEEE_ARM)
 #define JSDOUBLE_HI32(x)        (((uint32 *)&(x))[1])
 #define JSDOUBLE_LO32(x)        (((uint32 *)&(x))[0])
 #else
 #define JSDOUBLE_HI32(x)        (((uint32 *)&(x))[0])
 #define JSDOUBLE_LO32(x)        (((uint32 *)&(x))[1])
 #endif
 
 #define JSDOUBLE_SET_HI32(x, y) (JSDOUBLE_HI32(x)=(y))
