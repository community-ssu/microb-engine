Index: mozilla/embedding/browser/gtk/src/EmbedCertificates.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedCertificates.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedCertificates.cpp
@@ -70,42 +70,44 @@
 #include "EmbedCertificates.h"
 #include "nsIKeygenThread.h"
 #include "nsIX509CertValidity.h"
 #include "nsICRLInfo.h"
 #include "gtkmozembed.h"
 
 #define PIPSTRING_BUNDLE_URL "chrome://pippki/locale/pippki.properties"
 
+static NS_DEFINE_CID(kCStringBundleServiceCID,  NS_STRINGBUNDLESERVICE_CID);
+
 EmbedCertificates::EmbedCertificates(void)
 {
 }
 
 EmbedCertificates::~EmbedCertificates()
 {
 }
 
 NS_IMPL_THREADSAFE_ADDREF(EmbedCertificates)
 NS_IMPL_THREADSAFE_RELEASE(EmbedCertificates)
 NS_INTERFACE_MAP_BEGIN(EmbedCertificates)
 NS_INTERFACE_MAP_ENTRY(nsITokenPasswordDialogs)
+NS_INTERFACE_MAP_ENTRY(nsIBadCertListener2)
 NS_INTERFACE_MAP_ENTRY(nsICertificateDialogs)
 NS_INTERFACE_MAP_ENTRY(nsIClientAuthDialogs)
 NS_INTERFACE_MAP_ENTRY(nsICertPickDialogs)
 NS_INTERFACE_MAP_ENTRY(nsITokenDialogs)
 NS_INTERFACE_MAP_ENTRY(nsIGeneratingKeypairInfoDialogs)
 NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMCryptoDialogs)
 NS_INTERFACE_MAP_END
 
 nsresult
 EmbedCertificates::Init(void)
 {
   nsresult rv;
-  nsCOMPtr<nsIStringBundleService> service =
-           do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
+  nsCOMPtr<nsIStringBundleService> service = do_GetService(kCStringBundleServiceCID, &rv);
   if (NS_FAILED(rv)) return NS_OK;
   rv = service->CreateBundle(PIPSTRING_BUNDLE_URL,
                              getter_AddRefs(mPIPStringBundle));
   return NS_OK;
 }
 
 nsresult
 EmbedCertificates::SetPassword(nsIInterfaceRequestor *ctx,
@@ -235,8 +237,98 @@
 /* boolean ConfirmKeyEscrow (in nsIX509Cert escrowAuthority); */
 NS_IMETHODIMP
 EmbedCertificates::ConfirmKeyEscrow(nsIX509Cert *escrowAuthority, PRBool *_retval)
 {
   *_retval = PR_TRUE;
   return NS_OK;
 }
 
+#ifdef BAD_CERT_LISTENER21
+NS_IMETHODIMP
+EmbedCertificates::ConfirmBadCertificate(
+  nsIInterfaceRequestor *ctx,
+  nsIX509Cert *cert,
+  PRBool aSecSuccess,
+  PRUint32 aError,
+  PRBool *_retval)
+{
+  nsresult rv;
+  gpointer pCert = NULL;
+  guint messint = 0;
+  nsCOMPtr<nsIDOMWindow> parent(do_GetInterface(ctx));
+
+  GtkMozEmbedCommon * common = nsnull;
+  GtkMozEmbed *parentWidget = GTK_MOZ_EMBED(GetGtkWidgetForDOMWindow(parent));
+
+  if (parentWidget) {
+    EmbedCommon * embedcommon = EmbedCommon::GetInstance();
+    if (embedcommon)
+      common = GTK_MOZ_EMBED_COMMON(embedcommon->mCommon);
+  }
+
+  if (!(aError & nsIX509Cert::VERIFIED_OK)) {
+    pCert = (gpointer)cert;
+    messint = GTK_MOZ_EMBED_CERT_VERIFIED_OK;
+    if (aError & nsIX509Cert::NOT_VERIFIED_UNKNOWN) {
+      messint |= GTK_MOZ_EMBED_CERT_NOT_VERIFIED_UNKNOWN;
+    }
+    if (aError & nsIX509Cert::CERT_EXPIRED || aError & nsIX509Cert::CERT_REVOKED) {
+      nsCOMPtr<nsIX509CertValidity> validity;
+      rv = cert->GetValidity(getter_AddRefs(validity));
+      if (NS_SUCCEEDED(rv)) {
+        PRTime notBefore, notAfter, timeToUse;
+        PRTime now = PR_Now();
+        rv = validity->GetNotBefore(&notBefore);
+        if (NS_FAILED(rv))
+          return rv;
+        rv = validity->GetNotAfter(&notAfter);
+        if (NS_FAILED(rv))
+          return rv;
+        if (LL_CMP(now, >, notAfter)) {
+          messint |= GTK_MOZ_EMBED_CERT_EXPIRED;
+          timeToUse = notAfter;
+        } else {
+          messint |= GTK_MOZ_EMBED_CERT_REVOKED;
+          timeToUse = notBefore;
+        }
+      }
+    }
+    if (aError & nsIX509Cert::CERT_NOT_TRUSTED) {
+      messint |= GTK_MOZ_EMBED_CERT_UNTRUSTED;
+    }
+    if (aError & nsIX509Cert::ISSUER_UNKNOWN) {
+      messint |= GTK_MOZ_EMBED_CERT_ISSUER_UNKNOWN;
+    }
+    if (aError & nsIX509Cert::ISSUER_NOT_TRUSTED) {
+      messint |= GTK_MOZ_EMBED_CERT_ISSUER_UNTRUSTED;
+    }
+    if (aError & nsIX509Cert::INVALID_CA) {
+      messint |= GTK_MOZ_EMBED_CERT_INVALID_CA;
+    }
+    if (aError & nsIX509Cert::USAGE_NOT_ALLOWED) {
+    }
+    PRBool retVal = PR_FALSE;
+    if (common) {
+      g_signal_emit_by_name(common, "certificate-error", pCert, messint, &retVal);
+    }
+    if (retVal == PR_TRUE) {
+      *_retval = PR_FALSE;
+      rv = NS_ERROR_FAILURE;
+    } else {
+      rv = NS_OK;
+      *_retval = PR_TRUE;
+    }
+    pCert = NULL;
+  } else {
+    rv = NS_OK;
+    *_retval = PR_TRUE;
+  }
+  return rv;
+}
+#endif
+
+NS_IMETHODIMP
+EmbedCertificates::NotifyCertProblem(nsIInterfaceRequestor *socketInfo, nsISSLStatus *status, const nsACString & targetSite, PRBool *_retval)
+{
+    *_retval = PR_TRUE;
+    return NS_OK;
+}
Index: mozilla/embedding/browser/gtk/src/EmbedCertificates.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedCertificates.h
+++ mozilla/embedding/browser/gtk/src/EmbedCertificates.h
@@ -39,46 +39,53 @@
  *
  * ***** END LICENSE BLOCK ***** */
 /**
  * Derived from nsNSSDialogs http://landfill.mozilla.org/mxr-test/seamonkey/source/security/manager/pki/src/nsNSSDialogs.h
  */
 #ifndef __EmbedCertificates_h
 #define __EmbedCertificates_h
 #include "nsITokenPasswordDialogs.h"
+#include "nsIBadCertListener2.h"
+#include "nsISSLStatus.h"
 #include "nsICertificateDialogs.h"
 #include "nsIClientAuthDialogs.h"
 #include "nsICertPickDialogs.h"
 #include "nsITokenDialogs.h"
 #include "nsIDOMCryptoDialogs.h"
 #include "nsIGenKeypairInfoDlg.h"
 #include "nsCOMPtr.h"
 #include "nsIStringBundle.h"
+
 #define EMBED_CERTIFICATES_CID \
   { 0x518e071f, 0x1dd2, 0x11b2, \
   { 0x93, 0x7e, 0xc4, 0x5f, 0x14, 0xde, 0xf7, 0x78 }}
 #define EMBED_CERTIFICATES_DESCRIPTION "Certificates Listener Impl"
+
 class EmbedPrivate;
 class EmbedCertificates
 : public nsITokenPasswordDialogs,
+  public nsIBadCertListener2,
   public nsICertificateDialogs,
   public nsIClientAuthDialogs,
   public nsICertPickDialogs,
   public nsITokenDialogs,
   public nsIDOMCryptoDialogs,
   public nsIGeneratingKeypairInfoDialogs
 {
   public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSITOKENPASSWORDDIALOGS
+    NS_DECL_NSIBADCERTLISTENER2
     NS_DECL_NSICERTIFICATEDIALOGS
     NS_DECL_NSICLIENTAUTHDIALOGS
     NS_DECL_NSICERTPICKDIALOGS
     NS_DECL_NSITOKENDIALOGS
     NS_DECL_NSIDOMCRYPTODIALOGS
     NS_DECL_NSIGENERATINGKEYPAIRINFODIALOGS
     EmbedCertificates();
     virtual ~EmbedCertificates();
     nsresult Init(void);
+//    NS_IMETHOD NotifyCertProblem(nsIInterfaceRequestor *socketInfo, nsISSLStatus *status, const nsACString & targetSite, PRBool *_retval);
   protected:
   nsCOMPtr<nsIStringBundle> mPIPStringBundle;
 };
 #endif /* __EmbedCertificates_h */
Index: mozilla/embedding/browser/gtk/src/EmbedContentListener.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContentListener.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedContentListener.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
Index: mozilla/embedding/browser/gtk/src/EmbedContentListener.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContentListener.h
+++ mozilla/embedding/browser/gtk/src/EmbedContentListener.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
Index: mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp
@@ -12,17 +12,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin.
+ * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -32,16 +32,17 @@
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
+
 #include "EmbedContextMenuInfo.h"
 #include "nsIImageLoadingContent.h"
 #include "imgILoader.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMHTMLElement.h"
 #include "nsIDOMHTMLHtmlElement.h"
 #include "nsIDOMHTMLAnchorElement.h"
@@ -68,48 +69,58 @@
 #include "nsIDOMNSHTMLInputElement.h"
 #include "nsIDOMNSHTMLTextAreaElement.h"
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMNSHTMLDocument.h"
 #include "nsIDOMNodeList.h"
 #include "nsISelection.h"
 #include "nsIDocument.h"
+#include "nsIWidget.h"
+#include "nsIScrollableView.h"
+#include "nsIScrollableViewProvider.h"
+#include "nsIView.h"
+#include "nsIScrollableFrame.h"
+#include "nsIDOMWindowInternal.h"
 #include "EmbedPrivate.h"
+#include "nsGUIEvent.h"
 #include <stdio.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <glib.h>
 #if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
 #include "nsIFrame.h"
 #endif
+#include "gfxIImageFrame.h"
 
 //*****************************************************************************
 // class EmbedContextMenuInfo
 //*****************************************************************************
 EmbedContextMenuInfo::EmbedContextMenuInfo(EmbedPrivate *aOwner) : mCtxFrameNum(-1), mEmbedCtxType(0)
 {
   mOwner = aOwner;
   mEventNode = nsnull;
   mCtxDocument = nsnull;
   mNSHHTMLElement = nsnull;
-  mNSHHTMLElementSc = nsnull;
   mCtxEvent = nsnull;
   mEventNode = nsnull;
   mFormRect = nsRect(0,0,0,0);
+  mIsScrollableElement = PR_TRUE;
+  mCtxScrollable = nsnull;
+  mIsJSHandledElement = 0;
 }
 
 EmbedContextMenuInfo::~EmbedContextMenuInfo(void)
 {
   mEventNode = nsnull;
   mCtxDocument = nsnull;
   mNSHHTMLElement = nsnull;
-  mNSHHTMLElementSc = nsnull;
   mCtxEvent = nsnull;
   mEventNode = nsnull;
+  mCtxScrollable = nsnull;
 }
 
 NS_IMPL_ADDREF(EmbedContextMenuInfo)
 NS_IMPL_RELEASE(EmbedContextMenuInfo)
 NS_INTERFACE_MAP_BEGIN(EmbedContextMenuInfo)
 NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
@@ -133,16 +144,37 @@
         mCtxDocTitle = doc->GetDocumentTitle();
       return NS_OK;
     }
   }
   return NS_ERROR_FAILURE;
 }
 
 nsresult
+EmbedContextMenuInfo::GetJSHandledInfo(nsIDOMEvent *aEvent, PRInt32 *aIsJSHandled)
+{
+  if (!aEvent && !aIsJSHandled)
+    return NS_ERROR_FAILURE;
+  nsresult rv = NS_ERROR_FAILURE;
+  if (aEvent) {
+    PRUint32 flags;
+    rv = aEvent->GetPrivateFlags(&flags);
+    if (NS_SUCCEEDED(rv) && (flags & NS_PRIV_EVENT_FLAG_SCRIPT)) {
+      mIsJSHandledElement = aIsJSHandled?*aIsJSHandled:1;
+    } else {
+      mIsJSHandledElement = 0;
+      rv = NS_ERROR_FAILURE;
+    }
+  }
+  if (aIsJSHandled)
+    *aIsJSHandled = mIsJSHandledElement;
+  return rv;
+}
+
+nsresult
 EmbedContextMenuInfo::GetFormControlType(nsIDOMEvent* aEvent)
 {
   if (!aEvent)
     return NS_OK;
   nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
   nsCOMPtr<nsIDOMEventTarget> target;
   nsevent->GetOriginalTarget(getter_AddRefs(target));
   //    mOrigTarget  = target;
@@ -180,94 +212,102 @@
   return NS_ERROR_FAILURE;
 }
 
 nsresult
 EmbedContextMenuInfo::SetFormControlType(nsIDOMEventTarget *originalTarget)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsCOMPtr<nsIContent> targetContent = do_QueryInterface(originalTarget);
+  if(!targetContent)
+    return rv;
+
   mCtxFormType = 0;
 #ifdef MOZILLA_1_8_BRANCH
-  if (targetContent && targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
+  if (targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
 #else
-  if (targetContent && targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
+  if (targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
 #endif
     nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(targetContent));
     if (formControl) {
       mCtxFormType = formControl->GetType();
       rv = NS_OK;
       //#ifdef MOZ_LOGGING
       switch (mCtxFormType) {
       case NS_FORM_BUTTON_BUTTON:
         break;
       case NS_FORM_BUTTON_RESET:
         break;
       case NS_FORM_BUTTON_SUBMIT:
         break;
       case NS_FORM_INPUT_BUTTON:
+        //  mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
         break;
       case NS_FORM_INPUT_CHECKBOX:
         break;
+      case NS_FORM_INPUT_RADIO:
+        break;
       case NS_FORM_INPUT_FILE:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
         break;
       case NS_FORM_INPUT_HIDDEN:
         break;
       case NS_FORM_INPUT_RESET:
         break;
       case NS_FORM_INPUT_IMAGE:
         break;
       case NS_FORM_INPUT_PASSWORD:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
         mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IPASSWORD;
         break;
-      case NS_FORM_INPUT_RADIO:
-        break;
       case NS_FORM_INPUT_SUBMIT:
         break;
       case NS_FORM_INPUT_TEXT:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
         break;
       case NS_FORM_LABEL:
         break;
       case NS_FORM_OPTION:
         break;
       case NS_FORM_OPTGROUP:
         break;
       case NS_FORM_LEGEND:
         break;
       case NS_FORM_SELECT:
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_SELECT;
+        mIsScrollableElement = PR_FALSE;
         break;
       case NS_FORM_TEXTAREA:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_MULTILINE;
         break;
       case NS_FORM_OBJECT:
         break;
       default:
         break;
       }
-      if (mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      if (mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
         PRBool rdonly = PR_FALSE;
         if (mCtxFormType == NS_FORM_TEXTAREA) {
           nsCOMPtr<nsIDOMHTMLTextAreaElement> input;
           input = do_QueryInterface(mEventNode, &rv);
           if (!NS_FAILED(rv) && input)
             rv = input->GetReadOnly(&rdonly);
-          if (!NS_FAILED(rv) && rdonly) {
+          if (!NS_FAILED(rv) && rdonly)
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_ROINPUT;
-          }
+          else
+            mIsScrollableElement = PR_FALSE;
         } else {
           nsCOMPtr<nsIDOMHTMLInputElement> input;
           input = do_QueryInterface(mEventNode, &rv);
           if (!NS_FAILED(rv) && input)
             rv = input->GetReadOnly(&rdonly);
-          if (!NS_FAILED(rv) && rdonly) {
+          if (!NS_FAILED(rv) && rdonly)
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_ROINPUT;
-          }
+          else
+            mIsScrollableElement = PR_FALSE;
         }
       }
       //#endif
     }
   }
   return rv;
 }
 
@@ -322,30 +362,38 @@
   if (rv == NS_OK) {
     return NS_ConvertUTF16toUTF8(cString).get();
   }
   return nsnull;
 }
 
 nsresult
 EmbedContextMenuInfo::CheckDomImageElement(nsIDOMNode *node, nsString& aHref,
-                                           PRInt32 *aWidth, PRInt32 *aHeight)
+                                           PRInt32 *aWidth, PRInt32 *aHeight, PRUint32 *aSize)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsCOMPtr<nsIDOMHTMLImageElement> image =
     do_QueryInterface(node, &rv);
-  if (image) {
-    rv = image->GetSrc(aHref);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    rv = image->GetWidth(aWidth);
-    rv = image->GetHeight(aHeight);
-    rv = NS_OK;
-  }
+  NS_ENSURE_TRUE(image, rv);
+  rv = image->GetSrc(aHref);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = NS_OK;
+  image->GetWidth(aWidth);
+  image->GetHeight(aHeight);
+  if (!aSize) return rv;
+  nsCOMPtr<imgIRequest> request;
+  GetImageRequest(getter_AddRefs(request), node);
+  NS_ENSURE_TRUE(request, rv);
+  nsCOMPtr<imgIContainer> imgCont;
+  request->GetImage(getter_AddRefs(imgCont));
+  NS_ENSURE_TRUE(imgCont, rv);
+  nsCOMPtr<gfxIImageFrame> currentFrame;
+  imgCont->GetCurrentFrame(getter_AddRefs(currentFrame));
+  NS_ENSURE_TRUE(currentFrame, rv);
+  currentFrame->GetImageDataLength(aSize);
   return rv;
 }
 
 nsresult
 EmbedContextMenuInfo::GetImageRequest(imgIRequest **aRequest, nsIDOMNode *aDOMNode)
 {
   NS_ENSURE_ARG(aDOMNode);
   NS_ENSURE_ARG_POINTER(aRequest);
@@ -360,43 +408,34 @@
 
 nsresult
 EmbedContextMenuInfo::CheckDomHtmlNode(nsIDOMNode *aNode)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsString uTag;
   PRUint16 dnode_type;
 
-  nsCOMPtr<nsIDOMNode> node;
-  if (!aNode && mEventNode)
-    node = mEventNode;
-  nsCOMPtr<nsIDOMHTMLElement> element  = do_QueryInterface(node, &rv);
-  if (!element) {
-    element = do_QueryInterface(mOrigNode, &rv);
-    if (element) {
-      node = mOrigNode;
-      element  = do_QueryInterface(node, &rv);
-    }
-  }
+  nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode, &rv);
+  NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
 
   rv = node->GetNodeType(&dnode_type);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  if (!((nsIDOMNode::ELEMENT_NODE == dnode_type) && element)) {
+  if (!((nsIDOMNode::ELEMENT_NODE == dnode_type))) {
     return rv;
   }
   nsCOMPtr<nsIDOMNSHTMLElement> nodeElement = do_QueryInterface(node, &rv);
   if (NS_SUCCEEDED(rv) && nodeElement) {
     mNSHHTMLElement = nodeElement;
   } else {
     mNSHHTMLElement = nsnull;
   }
-  rv = element->GetLocalName(uTag);
+  rv = node->GetLocalName(uTag);
   if (NS_FAILED(rv)) {
     return rv;
   }
   if (uTag.LowerCaseEqualsLiteral("object")) {
   }
   else if (uTag.LowerCaseEqualsLiteral("html")) {
   }
   else if (uTag.LowerCaseEqualsLiteral("a")) {
@@ -410,16 +449,23 @@
         if (childNode) {
           PRInt32 width, height;
           rv = CheckDomImageElement(node, mCtxImgHref, &width, &height);
           if (NS_SUCCEEDED(rv))
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IMAGE;
         }
       } else if (StringBeginsWith(mCtxHref, NS_LITERAL_STRING("mailto:"))) {
         mEmbedCtxType |= GTK_MOZ_EMBED_CTX_EMAIL;
+      } else {
+        nsCOMPtr<nsIDOMNode> childNode;
+        node->GetFirstChild(getter_AddRefs(childNode));
+        if (childNode) {
+          childNode->GetLocalName(uTag);
+          mIsScrollableElement = !uTag.LowerCaseEqualsLiteral("div");
+        }
       }
     }
   }
   else if (uTag.LowerCaseEqualsLiteral("area")) {
     nsCOMPtr<nsIDOMHTMLAreaElement> area = do_QueryInterface(node, &rv);
     if (NS_SUCCEEDED(rv) && area) {
       PRBool aNoHref = PR_FALSE;
       rv = area->GetNoHref(&aNoHref);
@@ -437,62 +483,192 @@
     if (NS_SUCCEEDED(rv))
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IMAGE;
   } else {
     rv = NS_ERROR_FAILURE;
   }
   return rv;
 }
 
-nsresult
-EmbedContextMenuInfo::UpdateContextData(void *aEvent)
+static nsIFrame*
+GetParentFrameToScroll(nsPresContext* aPresContext, nsIFrame* aFrame)
 {
-  NS_ENSURE_ARG_POINTER(aEvent);
+  if (!aPresContext || !aFrame)
+    return nsnull;
+
+  if (aFrame->GetStyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED)
+    return aPresContext->GetPresShell()->GetRootScrollFrame();
+
+  return aFrame->GetParent();
+}
+
+static PRBool
+ViewIsScrollable(nsIScrollableView* aScrollView)
+{
+  // Can it crash?
+  nsIFrame *frame = static_cast<nsIFrame*>(aScrollView->View()->GetParent()->GetClientData());
+  NS_ENSURE_TRUE(frame, PR_FALSE);
+  nsIScrollableFrame *sf = nsnull;
+  CallQueryInterface(frame, &sf);
+  NS_ENSURE_TRUE(sf, PR_FALSE);
+  nsPresContext::ScrollbarStyles ss = sf->GetScrollbarStyles();
+  if (NS_STYLE_OVERFLOW_HIDDEN != ss.mHorizontal
+      || NS_STYLE_OVERFLOW_HIDDEN != ss.mVertical)
+    return PR_TRUE;
+  return PR_FALSE;
+}
+
+static nsresult
+FindScrollableView(nsPresContext* aPresContext,
+                   nsIFrame* aTargetFrame,
+                   nsIScrollableViewProvider* *aSvp)
+{
+  nsIScrollableView* scrollView = nsnull;
+  nsIFrame* scrollFrame = aTargetFrame;
+  PRBool passToParent = PR_TRUE;
+  for (; scrollFrame && passToParent;
+       scrollFrame = GetParentFrameToScroll(aPresContext, scrollFrame)) {
+    scrollView = nsnull;
+    nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(scrollFrame);
+    if (svp)
+      scrollView = svp->GetScrollableView();
+
+    if (!scrollView)
+      continue;
+    else
+      if (aSvp)
+        NS_ADDREF(*aSvp = svp);
+
+    if (!ViewIsScrollable(scrollView))
+      continue;
+
+    // Check if the scrollable view can be scrolled any further.
+    nscoord lineHeight;
+    scrollView->GetLineHeight(&lineHeight);
+    if (lineHeight != 0) {
+      PRBool canScroll;
+      if ((NS_SUCCEEDED(scrollView->CanScroll(PR_FALSE, PR_TRUE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_TRUE, PR_TRUE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_TRUE, PR_FALSE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_FALSE, PR_FALSE, canScroll)) && canScroll)
+         ) {
+        passToParent = PR_FALSE;
+        return NS_OK;
+      }
+    }
+  }
+  return NS_ERROR_FAILURE;
+}
+
+static PRBool
+IsScrollableWindow(nsIDOMWindow *win)
+{
+  if (!win) return PR_FALSE;
+  nsCOMPtr<nsIDOMWindowInternal> winint = do_QueryInterface(win);
+  if (!winint) return PR_FALSE;
+  PRInt32 maxScrollX = 0, maxScrollY = 0;
+  winint->GetScrollMaxX(&maxScrollX);
+  winint->GetScrollMaxY(&maxScrollY);
+  return maxScrollX || maxScrollY;
+}
+
+inline PRBool
+EmbedContextMenuInfo::GetScrollableViewByNode(void)
+{
+  if (!mEventNode) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
+    NS_ENSURE_TRUE(mCtxDomWindow, PR_FALSE);
+    nsCOMPtr<nsIDOMDocument> document;
+    mCtxDomWindow->GetDocument(getter_AddRefs(document));
+    NS_ENSURE_TRUE(document, PR_FALSE);
+    nsCOMPtr<nsIDOMElement> el;
+    document->GetDocumentElement(getter_AddRefs(el));
+    mEventNode = do_QueryInterface(el);
+    NS_ENSURE_TRUE(mEventNode, PR_FALSE);
+  }
   nsresult rv;
-  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface((nsISupports*)aEvent, &rv);
-  if (NS_FAILED(rv) || !event)
-    return NS_ERROR_FAILURE;
-  return UpdateContextData(event);
+  nsIFrame* frame = nsnull;
+  mCtxScrollable = nsnull;
+  nsCOMPtr<nsIContent> iContent = do_QueryInterface(mEventNode, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  nsCOMPtr<nsIPresShell> presShell;
+  nsCOMPtr<nsIDOMDocument> doc;
+  mEventNode->GetOwnerDocument(getter_AddRefs(doc));
+  nsCOMPtr<nsIDocument> iDoc = do_QueryInterface(doc);
+  NS_ENSURE_TRUE(iDoc, PR_FALSE);
+  presShell = iDoc->GetPrimaryShell();
+  NS_ENSURE_TRUE(presShell, PR_FALSE);
+  frame = presShell->GetPrimaryFrameFor(iContent);
+  NS_ENSURE_TRUE(frame, PR_FALSE);
+  nsPresContext *context = presShell->GetPresContext();
+  NS_ENSURE_TRUE(context, PR_FALSE);
+  nsCOMPtr<nsIScrollableViewProvider> svp;
+  if (NS_SUCCEEDED(FindScrollableView(context, frame, getter_AddRefs(svp)))
+      && svp && (mCtxScrollable = svp))
+    return PR_TRUE;
+  return PR_FALSE;
+}
+
+PRBool
+EmbedContextMenuInfo::GetScrollableView(void)
+{
+  if (GetScrollableViewByNode())
+    return PR_TRUE;
+  if (!mCtxDomWindow) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
+  }
+  NS_ENSURE_TRUE(mCtxDomWindow, PR_FALSE);
+  nsCOMPtr<nsIDOMWindow> cur = mCtxDomWindow;
+  nsCOMPtr<nsIDOMWindow> parent = nsnull;
+  if (IsScrollableWindow(cur)) {
+    mCtxScrollable = cur;
+    return PR_TRUE;
+  }
+  while (cur && cur != parent) {
+    cur->GetParent(getter_AddRefs(parent));
+    cur = parent;
+    if (IsScrollableWindow(cur)) {
+      mCtxScrollable = cur;
+      return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
 }
 
 nsresult
-EmbedContextMenuInfo::GetElementForScroll(nsIDOMEvent *aEvent)
+EmbedContextMenuInfo::ScrollScrollableView(PRInt32 subX, PRInt32 subY)
 {
-  if (!aEvent) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
-  nsCOMPtr<nsIDOMEventTarget> target;
-  nsevent->GetOriginalTarget(getter_AddRefs(target));
-  if (!target) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMNode> targetDOMNode(do_QueryInterface(target));
-  if (!targetDOMNode) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMDocument> targetDOMDocument;
-  targetDOMNode->GetOwnerDocument(getter_AddRefs(targetDOMDocument));
-  if (!targetDOMDocument) return NS_ERROR_UNEXPECTED;
-  return GetElementForScroll(targetDOMDocument);
+  nsresult rv;
+  nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(mCtxScrollable, &rv);
+  if (svp && !NS_FAILED(rv)) {
+    nsIScrollableView* scrollView = svp->GetScrollableView();
+    NS_ENSURE_TRUE(scrollView, NS_ERROR_FAILURE);
+    return scrollView->ScrollByPixels(subX, subY);
+  }
+
+  nsCOMPtr<nsIDOMWindow> win = do_QueryInterface(mCtxScrollable, &rv);
+  if (!win || NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  return win->ScrollBy(subX, subY);
 }
 
 nsresult
-EmbedContextMenuInfo::GetElementForScroll(nsIDOMDocument *targetDOMDocument)
+EmbedContextMenuInfo::UpdateContextData(void *aEvent)
 {
-  nsCOMPtr<nsIDOMElement> targetDOMElement;
-  targetDOMDocument->GetDocumentElement(getter_AddRefs(targetDOMElement));
-  if (!targetDOMElement) return NS_ERROR_UNEXPECTED;
-  nsString bodyName(NS_LITERAL_STRING("body"));
-  nsCOMPtr<nsIDOMNodeList> bodyList;
-  targetDOMElement->GetElementsByTagName(bodyName, getter_AddRefs(bodyList));
-  PRUint32 i = 0;
-  bodyList->GetLength(&i);
-  if (i) {
-    nsCOMPtr<nsIDOMNode> domBodyNode;
-    bodyList->Item(0, getter_AddRefs(domBodyNode));
-    if (!domBodyNode) return NS_ERROR_UNEXPECTED;
-    mNSHHTMLElementSc = do_QueryInterface(domBodyNode);
-    if (!mNSHHTMLElementSc) return NS_ERROR_UNEXPECTED;
-  }
-  return NS_OK;
+  NS_ENSURE_ARG_POINTER(aEvent);
+  nsresult rv;
+  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface((nsISupports*)aEvent, &rv);
+  if (NS_FAILED(rv) || !event)
+    return NS_ERROR_FAILURE;
+  return UpdateContextData(event);
 }
 
 nsresult
 EmbedContextMenuInfo::UpdateContextData(nsIDOMEvent *aDOMEvent)
 {
   if (mCtxEvent == aDOMEvent)
     return NS_OK;
 
@@ -533,49 +709,59 @@
   mEmbedCtxType = GTK_MOZ_EMBED_CTX_NONE;
   mOrigNode = originalNode;
   if (mOrigNode) {
     nsString SOrigNode;
     mOrigNode->GetNodeName(SOrigNode);
     if (SOrigNode.EqualsLiteral("#document"))
       return NS_OK;
     if (SOrigNode.EqualsLiteral("xul:thumb")
-        || SOrigNode.EqualsLiteral("xul:slider")
-        || SOrigNode.EqualsLiteral("xul:scrollbarbutton")
         || SOrigNode.EqualsLiteral("xul:vbox")
         || SOrigNode.EqualsLiteral("xul:spacer")) {
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = PR_FALSE;
+      return NS_OK;
+    } else
+    if (SOrigNode.EqualsLiteral("xul:slider")) {
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = 2;
+      return NS_OK;
+    } else
+    if (SOrigNode.EqualsLiteral("xul:scrollbarbutton")) {
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = 3;
       return NS_OK;
     }
   }
+  mIsScrollableElement = PR_TRUE;
   if (mCtxEvent)
     rv = mCtxEvent->GetTarget(getter_AddRefs(mEventTarget));
   if (NS_FAILED(rv) || !mEventTarget) {
     return NS_OK;
   }
   nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(mEventTarget, &rv);
   mEventNode = eventNode;
   //Frame Stuff
   nsCOMPtr<nsIDOMDocument> domDoc;
   if (mEventNode)
     rv = mEventNode->GetOwnerDocument(getter_AddRefs(domDoc));
   if (!NS_SUCCEEDED(rv) || !domDoc) {
     //  return NS_OK;
   }
   if (NS_SUCCEEDED(rv) && domDoc && mCtxDocument != domDoc) {
     mCtxDocument = domDoc;
-    mNSHHTMLElementSc = nsnull;
     nsCOMPtr<nsIDOM3Document> docuri = do_QueryInterface(mCtxDocument);
     docuri->GetDocumentURI(mCtxURI);
     NS_ENSURE_ARG_POINTER(mOwner);
     nsCOMPtr<nsIWebBrowser> webBrowser;
     mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
     webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
     nsCOMPtr<nsIDOMDocument> mainDocument;
     mCtxDomWindow->GetDocument(getter_AddRefs(mainDocument));
+
     if (!mainDocument) {
       return NS_OK;
     }
     mCtxFrameNum = -1;
     if (mainDocument != domDoc) {
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IFRAME;
       SetFrameIndex();
     }
@@ -583,18 +769,20 @@
   nsCOMPtr<nsIDOMElement> targetDOMElement;
   mCtxDocument->GetDocumentElement(getter_AddRefs(targetDOMElement));
   if (!targetDOMElement) return NS_ERROR_UNEXPECTED;
   nsCOMPtr<nsIDOMNSHTMLDocument> htmlDoc = do_QueryInterface(mCtxDocument);
   if (htmlDoc) {
     nsString DMode;
     htmlDoc->GetDesignMode(DMode);
     if (DMode.EqualsLiteral("on")) {
-      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_RICHEDIT;
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_MULTILINE;
+      mIsScrollableElement = PR_FALSE;
     }
   }
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(mCtxDocument);
   if (!doc)
     return NS_OK;
   nsIPresShell *presShell = doc->GetPrimaryShell();
   if (!presShell)
     return NS_OK;
@@ -613,22 +801,31 @@
   }
   if (frame) {
     mFormRect = frame->GetScreenRectExternal();
   }
 #endif
   if (NS_SUCCEEDED(SetFormControlType(mEventTarget))) {
     return NS_OK;
   }
-  CheckDomHtmlNode();
-  nsCOMPtr<nsIDOMNode> node = mEventNode;
+
+  nsCOMPtr<nsIDOMNode> node;
   nsCOMPtr<nsIDOMNode> parentNode;
+
+  nsCOMPtr<nsIDOMHTMLElement> element = do_QueryInterface(mEventNode, &rv);
+  if (element)
+    node = do_QueryInterface(mEventNode, &rv);
+  else /* Fallback to XML/XSLT content */
+    node = do_QueryInterface(mOrigNode, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  CheckDomHtmlNode(node);
   node->GetParentNode(getter_AddRefs(parentNode));
   node = parentNode;
   while (node) {
-    if (NS_FAILED(CheckDomHtmlNode()))
+    if (NS_FAILED(CheckDomHtmlNode(node)))
       break;
     node->GetParentNode(getter_AddRefs(parentNode));
     node = parentNode;
   }
   mEmbedCtxType |= GTK_MOZ_EMBED_CTX_DOCUMENT;
   return NS_OK;
 }
Index: mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContextMenuInfo.h
+++ mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.h
@@ -14,17 +14,17 @@
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is the Mozilla browser.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin.
+ * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -64,36 +64,40 @@
 public:
   EmbedContextMenuInfo(EmbedPrivate *aOwner);
   virtual ~EmbedContextMenuInfo(void);
   NS_DECL_ISUPPORTS
   nsresult          GetFormControlType(nsIDOMEvent *aDOMEvent);
   nsresult          UpdateContextData(nsIDOMEvent *aDOMEvent);
   nsresult          UpdateContextData(void *aEvent);
   const char*       GetSelectedText();
-  nsresult          GetElementForScroll(nsIDOMDocument *targetDOMDocument);
-  nsresult          GetElementForScroll(nsIDOMEvent *aEvent);
   nsresult          CheckDomImageElement(nsIDOMNode *node, nsString& aHref,
-                                       PRInt32 *aWidth, PRInt32 *aHeight);
+                                       PRInt32 *aWidth, PRInt32 *aHeight, PRUint32 *aSize = nsnull);
   nsresult          GetImageRequest(imgIRequest **aRequest, nsIDOMNode *aDOMNode);
   nsString          GetCtxDocTitle(void) { return mCtxDocTitle; }
+  PRBool            GetScrollableView(void);
+  PRBool            GetScrollableViewByNode(void);
+  nsresult          ScrollScrollableView(PRInt32 subX, PRInt32 subY);
+  nsresult          GetJSHandledInfo(nsIDOMEvent *aEvent, PRInt32 *aIsJSHandled = nsnull);
 
 
   PRInt32                 mX, mY, mObjWidth, mObjHeight, mCtxFrameNum;
   nsString                mCtxURI, mCtxHref, mCtxImgHref;
   PRUint32                mEmbedCtxType;
   PRInt32 mCtxFormType;
   nsCOMPtr<nsIDOMNode>    mEventNode;
   nsCOMPtr<nsIDOMEventTarget> mEventTarget;
   nsCOMPtr<nsIDOMDocument>mCtxDocument;
   nsRect               mFormRect;
   nsCOMPtr<nsIDOMWindow>  mCtxDomWindow;
   nsCOMPtr<nsIDOMEvent>   mCtxEvent;
   nsCOMPtr<nsIDOMNSHTMLElement> mNSHHTMLElement;
-  nsCOMPtr<nsIDOMNSHTMLElement> mNSHHTMLElementSc;
+  nsISupports            *mCtxScrollable;
+  PRInt32                 mIsScrollableElement;
+  PRInt32                 mIsJSHandledElement;
 private:
   nsresult          SetFrameIndex();
   nsresult          SetFormControlType(nsIDOMEventTarget *originalTarget);
   nsresult          CheckDomHtmlNode(nsIDOMNode *aNode = nsnull);
 
   EmbedPrivate           *mOwner;
   nsCOMPtr<nsIDOMNode>    mOrigNode;
   nsString                mCtxDocTitle;
Index: mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedDownloadMgr.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.cpp
@@ -11,22 +11,24 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
+ *   Oleg Romashin <romaxa@gmail.com>
+ *   Antonio Gomes <tonikitoo@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -65,16 +67,18 @@
 #include "nsNetError.h"
 #include "nsIStreamListener.h"
 #include "nsIFile.h"
 #include "nsILocalFile.h"
 #include "nsNetCID.h"
 #include <unistd.h>
 #include "gtkmozembed_download.h"
 #include "nsIIOService.h"
+#include "nsIProgressEventSink.h"
+#include "nsNetUtil.h"
 
 #define UNKNOWN_FILE_SIZE -1
 
 class EmbedDownloadMgr;
 class ProgressListener : public nsIWebProgressListener2
 {
 public:
     ProgressListener(EmbedDownload *aDownload):mDownload(aDownload)
@@ -87,80 +91,122 @@
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIWEBPROGRESSLISTENER
     NS_DECL_NSIWEBPROGRESSLISTENER2
 
     EmbedDownload *mDownload;
 };
 
+class FetchObserver : public nsIRequestObserver
+                      ,public nsIProgressEventSink
+{
+public:
+    FetchObserver(EmbedDownload *aDownload):mDownload(aDownload)
+    {
+    }
+
+    ~FetchObserver(void)
+    {
+    }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIREQUESTOBSERVER
+    NS_DECL_NSIPROGRESSEVENTSINK
+    EmbedDownload *mDownload;
+};
+
+NS_IMPL_ISUPPORTS2(FetchObserver, nsIRequestObserver, nsIProgressEventSink)
+
 NS_IMPL_ISUPPORTS2(ProgressListener, nsIWebProgressListener2, nsIWebProgressListener)
 NS_IMPL_ISUPPORTS1(EmbedDownloadMgr, nsIHelperAppLauncherDialog)
 
+EmbedDownload::EmbedDownload(void)
+  : parent(nsnull), gtkMozEmbedParentWidget(nsnull), launcher(nsnull), request(nsnull), isCanceled(PR_FALSE)
+{
+}
+
+EmbedDownload::~EmbedDownload(void)
+{
+  isCanceled = PR_TRUE;
+  request = nsnull;
+}
+
 EmbedDownloadMgr::EmbedDownloadMgr(void)
 {
 }
 
 EmbedDownloadMgr::~EmbedDownloadMgr(void)
 {
+  if (!mDownload || !mDownload->parent)
+    return;
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  temp->is_paused = TRUE;
+  temp->data = NULL;
 }
 
-static gchar *
-RemoveSchemeFromFilePath(gchar *path)
+static char *
+RemoveSchemeFromFilePath(const char *path)
 {
-  gchar *new_path = path;
-
-  if (!strncmp(path, "file://", 7)) {
-    /* XXX this should really look for the first non / after file:/ instead of
-     * assuming file://tmp v. file:///tmp
-     */
-    new_path = g_strdup(path+sizeof("file:/"));
-    g_free(path);
-  }
-    
-  return new_path;
+  return g_strdup(g_str_has_prefix(path, "file://")?&path[7]:path);
 }
 
 NS_IMETHODIMP
 EmbedDownloadMgr::Show(nsIHelperAppLauncher *aLauncher,
                        nsISupports *aContext,
                        PRUint32 aForced)
 {
   nsresult rv;
+  GtkObject* instance;
 
   /* create a Download object */
-  GtkObject* instance = gtk_moz_embed_download_new();
+  instance = gtk_moz_embed_download_get_restart_flag () ?
+                gtk_moz_embed_download_get_latest_object () : gtk_moz_embed_download_new();
+
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
   mDownload = (EmbedDownload *) GTK_MOZ_EMBED_DOWNLOAD(instance)->data;
+  if (!mDownload)
+    return NS_ERROR_FAILURE;
   mDownload->parent = instance;
 
   rv = GetDownloadInfo(aLauncher, aContext);
 
   /* Retrieve GtkMozEmbed object from DOM Window */
   nsCOMPtr<nsIDOMWindow> parentDOMWindow = do_GetInterface(aContext);
   mDownload->gtkMozEmbedParentWidget = GetGtkWidgetForDOMWindow(parentDOMWindow);
 
+  // avoiding some casts.
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+
   gtk_signal_emit(GTK_OBJECT(mDownload->gtkMozEmbedParentWidget),
                   moz_embed_signals[DOWNLOAD_REQUEST],
-                  mDownload->server,
-                  mDownload->file_name,
-                  mDownload->file_type,
-                  (gulong) mDownload->file_size,
+                  temp->server,
+                  temp->file_name,
+                  temp->file_type,
+                  (gulong) temp->file_size,
                    1);
 
   gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                   moz_embed_download_signals[DOWNLOAD_STARTED_SIGNAL],
-                  &mDownload->file_name_with_path);
+                  & temp->file_name_with_path);
 
-  if (!mDownload->file_name_with_path) {
+  if (!temp->file_name_with_path) {
     gtk_moz_embed_download_do_command(GTK_MOZ_EMBED_DOWNLOAD(mDownload->parent),
                                       GTK_MOZ_EMBED_DOWNLOAD_CANCEL);
     return NS_OK;
   }
 
-  mDownload->file_name_with_path = RemoveSchemeFromFilePath(mDownload->file_name_with_path);
+  char * path = RemoveSchemeFromFilePath(temp->file_name_with_path);
+  NS_Free(temp->file_name_with_path);
+  temp->file_name_with_path = path;
 
   return aLauncher->SaveToDisk(nsnull, PR_FALSE);
 }
 
 NS_METHOD
 EmbedDownloadMgr::GetDownloadInfo(nsIHelperAppLauncher *aLauncher,
                                   nsISupports *aContext)
 {
@@ -191,37 +237,62 @@
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
   nsCAutoString spec;
   rv = uri->Resolve(NS_LITERAL_CSTRING("."), spec);
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
+  PRInt64 mContentLength;
+  rv = aLauncher->GetContentLength(&mContentLength);
+  if (NS_FAILED(rv))
+    return rv;
+
+  /* avoiding some casts */
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+
   /* Sets download object to keep control of each download. */
   mDownload->launcher = aLauncher;
-  mDownload->downloaded_size = -1;
-  mDownload->file_name = g_strdup((gchar *) tempFileName.get());
-  mDownload->server = g_strconcat(spec.get(), (gchar *) mDownload->file_name, NULL);
-  mDownload->file_type = g_strdup(mimeType.get());
-  mDownload->file_size = UNKNOWN_FILE_SIZE;
+  mDownload->incr_launcher = nsnull;
+  temp->downloaded_size = -1;
+  temp->file_name = g_strdup((gchar *) tempFileName.get());
+  temp->server = g_strconcat(spec.get(), (gchar *) temp->file_name, NULL);
+  temp->file_type = g_strdup(mimeType.get());
+  temp->file_size = (mContentLength > 0)? mContentLength : UNKNOWN_FILE_SIZE;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP EmbedDownloadMgr::PromptForSaveToFile(nsIHelperAppLauncher *aLauncher,
                                                     nsISupports *aWindowContext,
                                                     const PRUnichar *aDefaultFile,
                                                     const PRUnichar *aSuggestedFileExtension,
                                                     nsILocalFile **_retval)
 {
   *_retval = nsnull;
 
   nsCAutoString filePath;
-  filePath.Assign(mDownload->file_name_with_path);
+  filePath.Assign(((GtkMozEmbedDownload *) mDownload->parent)->file_name_with_path);
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  if (temp) {
+    if (temp->file_name && !strlen(temp->file_name)) {
+      NS_Free(temp->file_name);
+      if (!NS_ConvertUTF16toUTF8(aDefaultFile).IsEmpty())
+        temp->file_name = NS_strdup(NS_ConvertUTF16toUTF8(aDefaultFile).get());
+      else
+        temp->file_name = g_strdup_printf("_temp_file%s", NS_ConvertUTF16toUTF8(aSuggestedFileExtension).get());
+      if (temp->file_name_with_path) {
+        filePath.AppendLiteral(temp->file_name);
+        NS_Free(temp->file_name_with_path);
+        temp->file_name_with_path = NS_strdup(filePath.get());
+      }
+    }
+  }
 
   nsCOMPtr<nsILocalFile> destFile;
   NS_NewNativeLocalFile(filePath,
                         PR_TRUE,
                         getter_AddRefs(destFile));
   if (!destFile)
     return NS_ERROR_OUT_OF_MEMORY;
 
@@ -244,17 +315,17 @@
                                                    nsISupports *aWindowContext,
                                                    const PRUnichar *aDefaultFile,
                                                    const PRUnichar *aSuggestedFileExtension,
                                                    nsIURI **_retval)
 {
   nsresult rv;
 
   nsCAutoString file_path;
-  file_path.Assign (mDownload->file_name_with_path);
+  file_path.Assign (((GtkMozEmbedDownload *) mDownload->parent)->file_name_with_path);
   nsCOMPtr<nsIIOService> ios (do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios)
     return FALSE;
 
   nsCOMPtr<nsIURI> uri;
   rv = ios->NewURI(file_path, "", nsnull, getter_AddRefs(uri));
   if (!uri)
     return FALSE;
@@ -274,18 +345,33 @@
 
 /* nsIWebProgressListener Functions
    all these methods must be here due to nsIWebProgressListener/2 inheritance */
 NS_IMETHODIMP ProgressListener::OnStatusChange(nsIWebProgress *aWebProgress,
                                                nsIRequest *aRequest,
                                                nsresult aStatus,
                                                const PRUnichar *aMessage)
 {
+  switch (aStatus)
+  {
+    case NS_ERROR_OUT_OF_MEMORY:     // No memory
+    case NS_ERROR_FILE_DISK_FULL:    // Out of space on target volume.
+    case NS_ERROR_FILE_NO_DEVICE_SPACE:
+    case NS_ERROR_FILE_READ_ONLY:     // Attempt to write to read/only file.
+    case NS_ERROR_FILE_ACCESS_DENIED: // Attempt to write without sufficient permissions.
+    case NS_ERROR_FILE_NOT_FOUND:     // Helper app not found, let's verify this happened on launch
+    case NS_ERROR_FILE_TARGET_DOES_NOT_EXIST:
+    case NS_ERROR_FILE_UNRECOGNIZED_PATH:
+    default:
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent), moz_embed_download_signals[DOWNLOAD_DESTROYED_SIGNAL]);
+      break;
+  }
+
   if (NS_SUCCEEDED(aStatus))
-    return NS_OK;
+      return NS_OK;
 
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP ProgressListener::OnStateChange(nsIWebProgress *aWebProgress,
                                               nsIRequest *aRequest, PRUint32 aStateFlags,
                                               nsresult aStatus)
 {
@@ -338,22 +424,173 @@
                     (gulong) aCurSelfProgress, (gulong) aMaxSelfProgress, 1);
   }
   else {
     gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                     moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
                     (gulong) aCurSelfProgress, 0, 1);
   }
 
+
   /* storing current downloaded size. */
-  mDownload->downloaded_size = (gulong) aCurSelfProgress;
+  ((GtkMozEmbedDownload *) mDownload->parent)->downloaded_size = (gulong) aCurSelfProgress;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP ProgressListener::OnRefreshAttempted(nsIWebProgress *aWebProgress,
                                                    nsIURI *aUri, PRInt32 aDelay,
                                                    PRBool aSameUri,
                                                    PRBool *allowRefresh)
 {
   *allowRefresh = PR_TRUE;
   return NS_OK;
 }
+
+NS_IMETHODIMP
+EmbedDownloadMgr::CreateIncrementalDownload(const char *aUrl,
+                                            const char *aDestination,
+                                            PRBool aHidden)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+
+  GtkObject* instance;
+  /* create a Download object */
+  instance = gtk_moz_embed_download_get_restart_flag () ?
+                gtk_moz_embed_download_get_latest_object () : gtk_moz_embed_download_new();
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
+  EmbedDownload *Download = (EmbedDownload *) GTK_MOZ_EMBED_DOWNLOAD(instance)->data;
+  if (!Download)
+    return NS_ERROR_FAILURE;
+  Download->parent = instance;
+  /* Sets download object to keep control of each download. */
+  Download->launcher = nsnull;
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) Download->parent;
+  temp->downloaded_size = -1;
+  temp->file_size = UNKNOWN_FILE_SIZE;
+  temp->server = NS_strdup(aUrl);
+  temp->file_name_with_path = NS_strdup(aDestination);
+  temp->file_name = RemoveSchemeFromFilePath(aDestination);
+
+  return EmbedDownloadMgr::CreateIncrementalDownload(Download);
+}
+
+NS_IMETHODIMP
+EmbedDownloadMgr::CreateIncrementalDownload(EmbedDownload *Download)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+
+  GtkObject* instance = Download->parent;
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
+  /* Sets download object to keep control of each download. */
+  Download->launcher = nsnull;
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) Download->parent;
+
+  nsCOMPtr<nsILocalFile> resultFile;
+  char *new_path = RemoveSchemeFromFilePath(temp->file_name_with_path);
+  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(new_path),
+                                      PR_FALSE, getter_AddRefs(resultFile));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewURI(getter_AddRefs(uri), temp->server);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr <nsIRequestObserver> observer = new FetchObserver(Download);
+  NS_ENSURE_TRUE(observer, rv);
+
+  nsCOMPtr<nsIIncrementalDownload> download =
+      do_CreateInstance(NS_INCREMENTALDOWNLOAD_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  Download->incr_launcher = download;
+
+  rv = download->Init(uri, resultFile, -1, 0);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = download->Start(observer, nsnull);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+FetchObserver::OnStartRequest(nsIRequest *request, nsISupports *context)
+{
+  //printf("FetchObserver::OnStartRequest\n");
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                  moz_embed_download_signals[DOWNLOAD_STARTED_SIGNAL], temp->file_name);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnProgress(nsIRequest *request, nsISupports *context,
+                          PRUint64 progress, PRUint64 progressMax)
+{
+  //printf("FetchObserver::OnProgress [%lu/%lu]\n",PRUint32(progress), PRUint32(progressMax));
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  if (mDownload->isCanceled)
+    return NS_OK;
+  if (progressMax != UNKNOWN_FILE_SIZE)
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                    moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
+                    (gulong) progress, (gulong) progressMax, 1);
+  else
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                    moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
+                    (gulong) progress, 0, 1);
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  temp->downloaded_size = progress;
+  temp->file_size = progressMax;
+
+  /* storing current downloaded size. */
+  ((GtkMozEmbedDownload *) mDownload->parent)->downloaded_size = (gulong) progress;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnStatus(nsIRequest *request, nsISupports *context,
+                        nsresult status, const PRUnichar *statusText)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnStopRequest(nsIRequest *request, nsISupports *context,
+                             nsresult status)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s, [status=%x]\n",  __LINE__, __FUNCTION__, status);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = nsnull;
+  GtkMozEmbedDownload *parent = (GtkMozEmbedDownload *) mDownload->parent;
+  if (mDownload->isCanceled)
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent), moz_embed_download_signals[DOWNLOAD_DESTROYED_SIGNAL]);
+  else if (!parent->is_paused) {
+    if (NS_FAILED(status)) {
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                      moz_embed_download_signals[DOWNLOAD_FAILED_SIGNAL]);    //error
+      // DOWNLOAD_FAILED_SIGNAL, DOWNLOAD_DESTROYED_SIGNAL, DOWNLOAD_COMPLETED_SIGNAL, DOWNLOAD_STOPPED_SIGNAL,
+      gtk_moz_embed_load_url (EmbedCommon::GetAnyLiveWidget(), parent->server);
+    }
+    else
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                      moz_embed_download_signals[DOWNLOAD_COMPLETED_SIGNAL]);
+  }
+
+  return NS_OK;
+}
Index: mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedDownloadMgr.h
+++ mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.h
@@ -9,17 +9,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -42,56 +42,53 @@
 
 #include "EmbedPrivate.h"
 #include "nsIHelperAppLauncherDialog.h"
 #include "nsIMIMEInfo.h"
 #include "nsCOMPtr.h"
 #include "nsIExternalHelperAppService.h"
 #include "nsIRequest.h"
 #include "nsILocalFile.h"
+#include "nsIIncrementalDownload.h"
+#include "nsIRequestObserver.h"
 
 #include "nsWeakReference.h"
 #define EMBED_DOWNLOADMGR_DESCRIPTION "MicroB Download Manager"
 #define EMBED_DOWNLOADMGR_CID {0x53df12a2, 0x1f4a, 0x4382, {0x99, 0x4e, 0xed, 0x62, 0xcf, 0x0d, 0x6b, 0x3a}}
 
 class nsIURI;
 class nsIFile;
 class nsIFactory;
 class nsExternalAppHandler;
 
-typedef struct _EmbedDownload EmbedDownload;
-
-struct _EmbedDownload
+class EmbedDownload
 {
+public:
+  EmbedDownload();
+  ~EmbedDownload();
   GtkObject*  parent;
   GtkWidget*  gtkMozEmbedParentWidget;/** Associated gtkmozembed widget */
 
-  char*       file_name;             /** < The file's name */
-  char*       file_name_with_path;   /** < The file's name */
-  const char* server;                /** < The server's name */
-  const char* file_type;             /** < The file's type */
-  const char* handler_app;           /** < The application's name */
-  PRInt64     file_size;             /** < The file's size */
-  PRInt64     downloaded_size;       /** < The download's size */
-  gboolean    is_paused;             /** < If download is paused or not */
-  gboolean    open_with;             /** < If the file can be opened by other application */
-
   /* Pointer to mozilla interfaces */
   nsIHelperAppLauncher* launcher;    /** < The mozilla's download dialog */
+  nsCOMPtr <nsIIncrementalDownload> incr_launcher;
   nsIRequest* request;               /** < The download request */
+  PRBool isCanceled;
 };
 
 class EmbedDownloadMgr : public nsIHelperAppLauncherDialog
 {
   public:
     EmbedDownloadMgr();
     virtual ~EmbedDownloadMgr();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIHELPERAPPLAUNCHERDIALOG
+    static nsresult CreateIncrementalDownload(const char *aUrl, const char *aDestination, PRBool aHidden = PR_FALSE);
+    static nsresult CreateIncrementalDownload(EmbedDownload *download);
 
   private:
     /** Gets all informations about a file which is being downloaded.
     */
     NS_METHOD GetDownloadInfo(nsIHelperAppLauncher *aLauncher, nsISupports *aContext);
 
     EmbedDownload *mDownload;
 };
Index: mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedEventListener.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp
@@ -11,23 +11,24 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Oleg Romashin <romaxa@gmail.com>
+ *   Anton Rogaynis <rogainis@gmail.com>
  *   Tomaz Noleto <tnoleto@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
@@ -45,34 +46,56 @@
 #include "nsIDOMNSEvent.h"
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMUIEvent.h"
 #include "nsIDOMDocument.h"
 #include "nsIDocument.h"
 #include "nsIContent.h"
 #include "nsIPresShell.h"
 #include "nsIDOMNodeList.h"
+#include "nsIPrefService.h"
 
 #include "EmbedEventListener.h"
 #include "EmbedPrivate.h"
 #include "gtkmozembed_internal.h"
+#include "nsIDOMPopupBlockedEvent.h"
 
 static PRInt32 sLongPressTimer = 0, mLongMPressDelay = 1000;
-static PRInt32 sX = 0, sY = 0;
-static PRBool  sMPressed = PR_FALSE, sIsScrolling = PR_FALSE;
+static PRInt32 spX = 0, spY = 0, sScrollStep = 2;
+static PRInt32 sgX = 0, sgY = 0;
+static PRBool  sMPressed = PR_FALSE, sForcePan = PR_FALSE;
+static PRBool sDirectPan = PR_TRUE;
+static PRInt16 sIsScrolling = 0, sXulType = 0;
 static char* gFavLocation = NULL;
+#define START_PANNING_STEP 8
+
+static gboolean
+motion_notify_event_cb (GtkWidget *widget, GdkEventMotion *event, EmbedEventListener *self);
+static gboolean
+button_release_event_cb(GtkWidget *widget, GdkEvent *event, EmbedPrivate *self);
+static gboolean
+button_press_event_cb(GtkWidget *widget, GdkEvent *event, EmbedPrivate *self);
+static gboolean
+enter_notify_event_cb  (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self);
+static gboolean
+leave_notify_event_cb  (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self);
 
 EmbedEventListener::EmbedEventListener(void)
 {
   mOwner = nsnull;
+  mAddonSignals = PR_FALSE;
+  mXSLTransformed = PR_FALSE;
 }
 
 EmbedEventListener::~EmbedEventListener()
 {
   delete mCtxInfo;
+  mOwner = nsnull;
+  mCtxInfo = nsnull;
+  mAddonSignals = PR_FALSE;
 }
 
 NS_IMPL_ADDREF(EmbedEventListener)
 NS_IMPL_RELEASE(EmbedEventListener)
 NS_INTERFACE_MAP_BEGIN(EmbedEventListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMKeyListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMKeyListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
@@ -81,21 +104,41 @@
   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseMotionListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMFocusListener)
   NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
 NS_INTERFACE_MAP_END
 
 nsresult
 EmbedEventListener::Init(EmbedPrivate *aOwner)
 {
+  nsresult rv;
   mOwner = aOwner;
   mCtxInfo = nsnull;
   mClickCount = 1;
   mCtxInfo = new EmbedContextMenuInfo(aOwner);
   mOwner->mNeedFav = PR_TRUE;
+  nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+  if (!prefs)
+    return NS_OK;
+
+  PRInt32 scrollStep = 0;
+  PRBool forcePan = PR_FALSE;
+  PRBool directPan = PR_TRUE;
+  rv = prefs->GetIntPref("gtkmozembed.mscroll.step", &scrollStep);
+  if (scrollStep && NS_SUCCEEDED(rv))
+    sScrollStep = scrollStep;
+
+  rv = prefs->GetBoolPref("gtkmozembed.mscroll.force", &forcePan);
+  if (scrollStep && NS_SUCCEEDED(rv))
+    sForcePan = forcePan;
+
+  rv = prefs->GetBoolPref("gtkmozembed.mscroll.direct", &directPan);
+  if (NS_SUCCEEDED(prefs->GetBoolPref("gtkmozembed.mscroll.direct", &directPan)) && !directPan)
+    sDirectPan = directPan;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleLink(nsIDOMNode* node)
 {
   nsresult rv;
 
@@ -147,40 +190,90 @@
            type.LowerCaseEqualsLiteral("application/rss+xml")) {
 
     NS_ConvertUTF16toUTF8 narrowTitle(title);
 
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[RSS_REQUEST],
                     (gchar *)url.get(),
                     narrowTitle.get());
+    mXSLTransformed = PR_FALSE;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleEvent(nsIDOMEvent* aDOMEvent)
 {
   nsString eventType;
   aDOMEvent->GetType(eventType);
 
+  if (mOwner->mWindow && eventType.EqualsLiteral("DOMLinkXSLParsed")) {
+    mXSLTransformed = PR_TRUE;
+    return NS_OK;
+  }
+
   if (eventType.EqualsLiteral("focus"))
     if (mCtxInfo->GetFormControlType(aDOMEvent)) {
-      if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
         gint return_val = FALSE;
         gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                         moz_embed_signals[DOM_FOCUS],
                         (void *)aDOMEvent, &return_val);
         if (return_val) {
           aDOMEvent->StopPropagation();
           aDOMEvent->PreventDefault();
         }
       }
     }
 
+  if (eventType.EqualsLiteral("DOMPopupBlocked")) {
+    nsCOMPtr<nsIDOMPopupBlockedEvent> popupEvent =
+      do_QueryInterface (aDOMEvent);
+    NS_ENSURE_TRUE (popupEvent, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIURI> popupWindowURI;
+    popupEvent->GetPopupWindowURI (getter_AddRefs (popupWindowURI));
+
+    nsCString popupWindowURIString;
+    nsCString Host;
+    nsresult rv;
+
+    if (popupWindowURI) {
+      rv = popupWindowURI->GetSpec (popupWindowURIString);
+      NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+      rv = popupWindowURI->GetHost (Host);
+      NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+    }
+
+    nsString popupWindowFeatures;
+    rv = popupEvent->GetPopupWindowFeatures (popupWindowFeatures);
+    NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+
+    nsCString popupWindowFeaturesString;
+    NS_UTF16ToCString (popupWindowFeatures,
+                       NS_CSTRING_ENCODING_UTF8,
+                       popupWindowFeaturesString);
+
+    nsCString popupWindowNameString;
+#ifdef HAVE_GECKO_1_9
+    nsString popupWindowName;
+    rv = popupEvent->GetPopupWindowName (popupWindowName);
+    NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+
+    NS_UTF16ToCString (popupWindowName,
+                       NS_CSTRING_ENCODING_UTF8,
+                       popupWindowNameString);
+#endif
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_CONTENT_BLOCKED],
+                    (void *)popupWindowURIString.get(),(void*)Host.get());
+    return NS_OK;
+  }
+
   if (eventType.EqualsLiteral("DOMLinkAdded")) {
 
     nsresult rv;
     nsCOMPtr<nsIDOMEventTarget> eventTarget;
 
     aDOMEvent->GetTarget(getter_AddRefs(eventTarget));
     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(eventTarget, &rv);
     if (NS_FAILED(rv) || !node)
@@ -196,38 +289,49 @@
     webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     if (!DOMWindow) return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMDocument> doc;
     DOMWindow->GetDocument(getter_AddRefs(doc));
     if (!doc) return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNodeList> nodelist = nsnull;
+
+    PRUint32 length = 0;
     doc->GetElementsByTagName( NS_LITERAL_STRING( "rss" ), getter_AddRefs( nodelist ));
-    if (nodelist) {
-      PRUint32 length = 0;
+    if (nodelist)
       nodelist->GetLength(&length);
-      if (length >= 1) {
+    if (!nodelist || length == 0) {
+      doc->GetElementsByTagName( NS_LITERAL_STRING( "feed" ), getter_AddRefs( nodelist ));
+      if (nodelist)
+        nodelist->GetLength(&length);
+    }
+    if (!nodelist || length == 0) {
+      doc->GetElementsByTagName( NS_LITERAL_STRING( "rdf:RDF" ), getter_AddRefs( nodelist ));
+      if (nodelist)
+        nodelist->GetLength(&length);
+    }
+    if (nodelist && length >= 1 || mXSLTransformed) {
         char *url = gtk_moz_embed_get_location(mOwner->mOwningWidget);
         char *title = gtk_moz_embed_get_title(mOwner->mOwningWidget);
         gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                         moz_embed_signals[RSS_REQUEST],
                         (gchar*)url,
                         (gchar*)title);
         if (url)
           NS_Free(url);
         if (title)
           NS_Free(title);
-      }
+        mXSLTransformed = PR_FALSE;
     }
   }
   else if (mOwner->mNeedFav) {
     mOwner->mNeedFav = PR_FALSE;
     nsCString favicon_url = mOwner->mPrePath;
-	favicon_url.AppendLiteral("/favicon.ico");
+    favicon_url.AppendLiteral("/favicon.ico");
     this->GetFaviconFromURI(favicon_url.get());
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::KeyDown(nsIDOMEvent* aDOMEvent)
 {
@@ -288,19 +392,31 @@
   }
   return NS_OK;
 }
 
 static gboolean
 sLongMPress(void *aOwningWidget)
 {
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (!sMPressed || sIsScrolling)
+  if (EmbedPrivate::sTermEmbedding) {
+      fprintf(stderr,"%s:Warning: Emit signal after destroy\n", __FUNCTION__);
+      return FALSE;
+  }
+
+  if (!sMPressed || sIsScrolling
+    || (ABS(spX-sgX) > START_PANNING_STEP + 3 || ABS(spY-sgY) > START_PANNING_STEP + 3)
+    )
     return FALSE;
+
   sMPressed = PR_FALSE;
+  spX = 0;
+  spY = 0;
+  sgX = 0;
+  sgY = 0;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(aOwningWidget),
                   moz_embed_signals[DOM_MOUSE_LONG_PRESS],
                   (void *)0, &return_val);
   if (return_val) {
     sMPressed = PR_FALSE;
   }
   return FALSE;
@@ -309,70 +425,145 @@
 NS_IMETHODIMP
 EmbedEventListener::MouseDown(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
 
-  // Return TRUE from your signal handler to mark the event as consumed.
-  sMPressed = PR_TRUE;
+  if(!(mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_SELECT))
+    sMPressed = PR_TRUE;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_DOWN],
                   (void *)mouseEvent, &return_val);
-  if (return_val) {
+  if (!return_val && !sForcePan) {
     mClickCount = 2;
     sMPressed = PR_FALSE;
 #if 1
-    if (sLongPressTimer)
-      g_source_remove(sLongPressTimer);
+    GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
 #else
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
 #endif
+    if (sDirectPan) {
+      spX = sgX;
+      spY = sgY;
+    }
   } else {
     mClickCount = 1;
     sLongPressTimer = g_timeout_add(mLongMPressDelay, sLongMPress, mOwner->mOwningWidget);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&sX);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&sY);
+
+    // Return TRUE from your signal handler to mark the event as consumed.
+    PRInt32 JSHandledInfo = DOM_MOUSE_DOWN;
+    if (mCtxInfo->mIsJSHandledElement == DOM_MOUSE_OVER
+        || mCtxInfo->mIsJSHandledElement == DOM_MOUSE_SCROLL) {
+      return NS_OK;
+    }
+    if (mCtxInfo && NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+        && JSHandledInfo == DOM_MOUSE_DOWN) {
+      return NS_OK;
+    }
+
+    ((nsIDOMMouseEvent*)mouseEvent)->GetClientX(&spX);
+    ((nsIDOMMouseEvent*)mouseEvent)->GetClientY(&spY);
+    if (sDirectPan) {
+      if (!mAddonSignals) {
+        GtkWidget * child = gtk_bin_get_child((GtkBin *)mOwner->mOwningWidget);
+        if (child) {
+          g_signal_connect(G_OBJECT(child), "motion_notify_event",
+                           G_CALLBACK(motion_notify_event_cb), this);
+          g_signal_connect(G_OBJECT(child), "button_release_event",
+                           G_CALLBACK(button_release_event_cb), mOwner);
+          g_signal_connect(G_OBJECT(child), "button_press_event",
+                           G_CALLBACK(button_press_event_cb), mOwner);
+          g_signal_connect(G_OBJECT(child), "enter_notify_event",
+                           G_CALLBACK(enter_notify_event_cb), this);
+          g_signal_connect(G_OBJECT(child), "leave_notify_event",
+                           G_CALLBACK(leave_notify_event_cb), this);
+          mAddonSignals = PR_TRUE;
+        }
+      }
+    }
   }
 
   // handling event internally.
   HandleSelection(mouseEvent);
 
+  if (mCtxInfo)
+    sXulType = mCtxInfo->mIsScrollableElement;
+
   return NS_OK;
 }
 
+static void
+PanStatesReset(EmbedPrivate *self, PRBool aFull = PR_TRUE)
+{
+  GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+  sMPressed = PR_FALSE;
+  if (self)
+    self->mOpenBlock = sIsScrolling > 2;
+  sIsScrolling = sMPressed;
+  spX = sgX;
+  spY = sgY;
+  sXulType = 0;
+
+  EmbedCommon::SuspendNative(PR_FALSE);
+
+  if (!aFull) return;
+  gint return_val = FALSE;
+  if (self)
+    gtk_signal_emit(GTK_OBJECT(self->mOwningWidget),
+                    moz_embed_signals[DOM_MOUSE_UP],
+                    (void *)nsnull, &return_val);
+}
+
 NS_IMETHODIMP
 EmbedEventListener::MouseUp(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
 
+#if 1
+    GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+#else
+    aDOMEvent->StopPropagation();
+    aDOMEvent->PreventDefault();
+#endif
+
   // handling event internally, first.
   HandleSelection(mouseEvent);
 
+  if (!sDirectPan)
+  PanStatesReset(mOwner, PR_FALSE);
+
+  mCtxInfo->mIsJSHandledElement = 0;
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (sLongPressTimer)
-    g_source_remove(sLongPressTimer);
-  sMPressed = PR_FALSE;
-  mOwner->mOpenBlock = sIsScrolling;
-  sIsScrolling = sMPressed;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_UP],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
+
+  if (mOwner->mLoadFinished && mOwner->mPluginSuspended) {
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+    if (enabled && success) {
+      mOwner->NotifyPlugins(3);
+      mOwner->mPluginSuspended = PR_FALSE;
+    }
+  }
+
+  gtk_widget_queue_draw(GTK_WIDGET(mOwner->mOwningWidget));
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseClick(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
@@ -383,29 +574,38 @@
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_CLICK],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
+
+  if (mOwner->mLoadFinished && mOwner->mPluginSuspended) {
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+    if (enabled && success) {
+      mOwner->NotifyPlugins(3);
+      mOwner->mPluginSuspended = PR_FALSE;
+    }
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseDblClick(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (sLongPressTimer)
-    g_source_remove(sLongPressTimer);
+  GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
   sMPressed = PR_FALSE;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_DBL_CLICK],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
@@ -415,16 +615,21 @@
 
 NS_IMETHODIMP
 EmbedEventListener::MouseOver(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
+  PRInt32 JSHandledInfo = DOM_MOUSE_OVER;
+  if (mCtxInfo && NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+      && JSHandledInfo == DOM_MOUSE_OVER)
+    return NS_OK;
+
   // Return TRUE from your signal handler to mark the event as consumed.
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_OVER],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
@@ -505,72 +710,89 @@
     aDOMEvent->PreventDefault();
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseMove(nsIDOMEvent* aDOMEvent)
 {
+  PRInt32 JSHandledInfo = DOM_MOUSE_SCROLL;
+  if (mCtxInfo && mCtxInfo->mIsJSHandledElement != DOM_MOUSE_OVER &&
+      NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+      && JSHandledInfo == DOM_MOUSE_SCROLL) {
+    return NS_OK;
+  }
+
+  if (sMPressed && mCtxInfo && (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL) && sXulType < 2)
+     EmbedCommon::SuspendNative(PR_TRUE);
+
   if (mCurSelCon)
     mCurSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
 
-  if (sMPressed &&
-      gtk_signal_handler_pending(GTK_OBJECT(mOwner->mOwningWidget),
-                                 moz_embed_signals[DOM_MOUSE_SCROLL], TRUE)) {
+  if (mCtxInfo &&
+      (sMPressed &&
+       (gtk_signal_handler_pending(GTK_OBJECT(mOwner->mOwningWidget),
+                                   moz_embed_signals[DOM_MOUSE_SCROLL], TRUE)
+        || sForcePan)
+       && (!(mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL && sXulType != 2))
+      )
+     ) {
     // Return TRUE from your signal handler to mark the event as consumed.
     nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aDOMEvent);
-    if (!mouseEvent)
-      return NS_OK;
     PRInt32  newX, newY, subX, subY;
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&newX);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&newY);
-    subX = newX - sX;
-    subY = newY - sY;
-    nsresult rv = NS_OK;
-    if (ABS(subX) > 10 || ABS(subY) > 10 || (sIsScrolling && sMPressed)) {
-      if (!sIsScrolling) {
-        gint return_val = FALSE;
-        gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                        moz_embed_signals[DOM_MOUSE_SCROLL],
-                        (void *)mouseEvent, &return_val);
-        if (!return_val) {
-          sIsScrolling = PR_TRUE;
-          if (mCtxInfo)
-            rv = mCtxInfo->GetElementForScroll(aDOMEvent);
-        } else {
-          sMPressed = PR_FALSE;
-          sIsScrolling = PR_FALSE;
+    if (sDirectPan) {
+      newX = sgX;
+      newY = sgY;
+    } else {
+      if (!mouseEvent)
+        return NS_OK;
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&newX);
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&newY);
+    }
+    subX = newX - spX;
+    subY = newY - spY;
+    if (!sIsScrolling
+        && (ABS(subX) > START_PANNING_STEP || ABS(subY) > START_PANNING_STEP)) {
+      gint return_val = FALSE;
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[DOM_MOUSE_SCROLL],
+                      (void *)mouseEvent, &return_val);
+      if ((!return_val || sXulType == 2) && mCtxInfo->GetScrollableView()) {
+        sIsScrolling = PR_TRUE;
+        if (sXulType < 2)
+          EmbedCommon::SuspendNative(PR_TRUE);
+
+        // suspend plugins when panning
+        // Only need to suspend when page is already loaded and at the FIRST movement
+        if ( mOwner->mLoadFinished && !mOwner->mPluginSuspended ) {
+          PRBool enabled = PR_TRUE;
+          gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+          if (success && enabled) {
+            // do suspend
+            mOwner->NotifyPlugins(4);
+            mOwner->mPluginSuspended = PR_TRUE;
+          }
         }
+      } else {
+        sMPressed = PR_FALSE;
+        sIsScrolling = PR_FALSE;
       }
-      if (sIsScrolling)
-      {
-        if (sLongPressTimer)
-          g_source_remove(sLongPressTimer);
-        if (mCtxInfo->mNSHHTMLElementSc) {
-          PRInt32 x, y;
-          mCtxInfo->mNSHHTMLElementSc->GetScrollTop(&y);
-          mCtxInfo->mNSHHTMLElementSc->GetScrollLeft(&x);
-#ifdef MOZ_SCROLL_TOP_LEFT_HACK
-          rv = mCtxInfo->mNSHHTMLElementSc->ScrollTopLeft(y - subY, x - subX);
-#endif
-        } else {
-          rv = NS_ERROR_UNEXPECTED;
-        }
-        if (rv == NS_ERROR_UNEXPECTED) {
-          nsCOMPtr<nsIDOMWindow> DOMWindow;
-          nsIWebBrowser *webBrowser = nsnull;
-          gtk_moz_embed_get_nsIWebBrowser(mOwner->mOwningWidget, &webBrowser);
-          webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
-          DOMWindow->ScrollBy(-subX, -subY);
-        }
+    }
+
+    if (sIsScrolling && (ABS(subX) >= sScrollStep || ABS(subY) >= sScrollStep)) {
+      spX = newX;
+      spY = newY;
+      if (!mCtxInfo->mIsScrollableElement)
+        return NS_OK;
+      GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+      if (mCtxInfo->mCtxScrollable && !(sDirectPan && aDOMEvent)) {
+        sIsScrolling++;
+        mCtxInfo->ScrollScrollableView(-subX, -subY);
       }
-      sX = newX;
-      sY = newY;
-      sIsScrolling = sMPressed;
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::DragMove(nsIDOMEvent* aMouseEvent)
 {
@@ -580,17 +802,17 @@
 NS_IMETHODIMP
 EmbedEventListener::Focus(nsIDOMEvent* aEvent)
 {
   nsString eventType;
   aEvent->GetType(eventType);
 
   if (eventType.EqualsLiteral("focus") &&
       mCtxInfo->GetFormControlType(aEvent) &&
-      mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
     gint return_val = FALSE;
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[DOM_FOCUS],
                     (void *)aEvent, &return_val);
     if (return_val) {
       aEvent->StopPropagation();
       aEvent->PreventDefault();
     }
@@ -598,81 +820,54 @@
 
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 EmbedEventListener::Blur(nsIDOMEvent* aEvent)
 {
-  gint return_val = FALSE;
   mFocusInternalFrame = PR_FALSE;
 
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
-  nsCOMPtr<nsIDOMEventTarget> target;
-  nsevent->GetOriginalTarget(getter_AddRefs(target));
-
-  if (!target)
-    return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(target);
-
-  if (targetContent) {
-#ifdef MOZILLA_1_8_BRANCH
-    if (targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
-#else
-    if (targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
-#endif
-      if (sLongPressTimer)
-        g_source_remove(sLongPressTimer);
-
-      sMPressed = sIsScrolling ? PR_FALSE : sMPressed;
-      sIsScrolling = PR_FALSE;
-    }
-  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleSelection(nsIDOMMouseEvent* aDOMMouseEvent)
 {
   nsresult rv;
 
   /* This function gets called everytime that a mousedown or a mouseup
    * event occurs.
    */
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aDOMMouseEvent));
+  nsCOMPtr<nsIDOMNSEvent> nsevent = do_QueryInterface(aDOMMouseEvent, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDOMEventTarget> target;
   rv = nsevent->GetOriginalTarget(getter_AddRefs(target));
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
-  nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(target);
+  nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(target, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMDocument> domDoc;
   rv = eventNode->GetOwnerDocument(getter_AddRefs(domDoc));
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc, &rv);
-  if (NS_FAILED(rv) || !doc)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsIPresShell *presShell = doc->GetPrimaryShell();
-
   /* Gets nsISelectionController interface for the current context */
-  mCurSelCon = do_QueryInterface(presShell);
-  if (!mCurSelCon)
-    return NS_ERROR_FAILURE;
+  mCurSelCon = do_QueryInterface(presShell, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   /* Gets event type */
   nsString eventType;
   rv = aDOMMouseEvent->GetType(eventType);
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   /* Updates context to check which context is being clicked on */
   mCtxInfo->UpdateContextData(aDOMMouseEvent);
 
   /* If a mousedown after 1 click is done (and if clicked context is not a XUL
    * one (e.g. scrollbar), the selection is disabled for that context.
    */
   if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL || mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_RICHEDIT)
@@ -691,28 +886,30 @@
    */
   if (eventType.EqualsLiteral("mouseup")) {
 
     /* Selection controller of current event context */
     if (mCurSelCon) {
       rv = mCurSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
       if (mClickCount == 1) {
         nsCOMPtr<nsISelection> domSel;
-        mCurSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
-                                 getter_AddRefs(domSel));
+        rv = mCurSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
+                                      getter_AddRefs(domSel));
+        NS_ENSURE_SUCCESS(rv, rv);
         rv = domSel->RemoveAllRanges();
       }
     }
     /* Selection controller of previous event context */
     if (mLastSelCon) {
       rv = mLastSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
       if (mClickCount == 1) {
         nsCOMPtr<nsISelection> domSel;
-        mLastSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
-                                  getter_AddRefs(domSel));
+        rv = mLastSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
+                                       getter_AddRefs(domSel));
+        NS_ENSURE_SUCCESS(rv, rv);
         rv = domSel->RemoveAllRanges();
       }
     }
 
     /* If 1 click was done (despite the event type), sets the last context's
      * selection controller with current one
      */
     if (mClickCount == 1)
@@ -750,157 +947,155 @@
                                    NS_GET_IID(nsIIOService),
                                    (void **)ioService);
   return rv;
 }
 
 void
 EmbedEventListener::GeneratePixBuf()
 {
+  if (!::gFavLocation)
+    return;
+
   GdkPixbuf *pixbuf = NULL;
   pixbuf = gdk_pixbuf_new_from_file(::gFavLocation, NULL);
-  if (!pixbuf) {
+  if (!pixbuf && mOwner->mOwningWidget) {
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[ICON_CHANGED],
                     NULL );
 
     // remove the wrong favicon
     // FIXME: need better impl...
     nsCOMPtr<nsILocalFile> faviconFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
 
     if (!faviconFile) {
-      NS_Free(::gFavLocation);
-      gFavLocation = nsnull;
+      if (::gFavLocation) {
+        NS_Free(::gFavLocation);
+        gFavLocation = nsnull;
+      }
       return;
     }
 
     nsCString faviconLocation(::gFavLocation);
     faviconFile->InitWithNativePath(faviconLocation);
     faviconFile->Remove(FALSE);
-    NS_Free(::gFavLocation);
-    gFavLocation = nsnull;
+
+    if (::gFavLocation) {
+      NS_Free(::gFavLocation);
+      gFavLocation = nsnull;
+    }
     return;
   }
 
+  if (!(mOwner && mOwner->mOwningWidget))
+    return;
+
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[ICON_CHANGED],
                   pixbuf );
   //mOwner->mNeedFav = PR_FALSE;
-  NS_Free(::gFavLocation);
-  gFavLocation = nsnull;
+  if (::gFavLocation) {
+    NS_Free(::gFavLocation);
+    gFavLocation = nsnull;
+  }
 }
 
 void
 EmbedEventListener::GetFaviconFromURI(const char* aURI)
 {
-  gchar *file_name = NS_strdup(aURI);
-  gchar *favicon_uri = NS_strdup(aURI);
+  nsresult rv = NS_OK;
 
-  gint i = 0;
-  gint rv = 0;
+  if (!aURI)
+    return;
 
-  nsCOMPtr<nsIWebBrowserPersist> persist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
-  if (!persist) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
+  gchar *file_name = NS_strdup(aURI);
+  if (!file_name)
     return;
-  }
-  persist->SetProgressListener(this);
 
+  gint i = 0;
   while (file_name[i] != '\0') {
     if (file_name[i] == '/' || file_name[i] == ':')
       file_name[i] = '_';
     i++;
   }
 
   nsCString fileName(file_name);
+  NS_Free(file_name);
 
-  nsCOMPtr<nsILocalFile> favicon_dir = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
-
-  if (!favicon_dir) {
-    NS_Free(favicon_uri);
-    NS_Free(file_name);
+  nsCOMPtr<nsIWebBrowserPersist> persist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
+  if (!persist)
     return;
-  }
+  persist->SetProgressListener(this);
 
-  nsCString faviconDir("~/.mozilla/favicon");
-  favicon_dir->InitWithNativePath(faviconDir);
+  nsCOMPtr<nsILocalFile> favicon_dir = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
+  if (!favicon_dir)
+    return;
+  favicon_dir->InitWithNativePath(NS_LITERAL_CSTRING("~/.mozilla/favicon"));
 
   PRBool isExist;
   rv = favicon_dir->Exists(&isExist);
   if (NS_SUCCEEDED(rv) && !isExist) {
     rv = favicon_dir->Create(nsIFile::DIRECTORY_TYPE,0775);
-    if (NS_FAILED(rv)) {
-      NS_Free(file_name);
-      NS_Free(favicon_uri);
+    if (NS_FAILED(rv))
       return;
-    }
   }
 
-  nsCAutoString favicon_path("~/.mozilla/favicon");
   nsCOMPtr<nsILocalFile> target_file = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
-  if (!target_file) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
+  if (!target_file)
     return;
-  }
-  target_file->InitWithNativePath(favicon_path);
+  target_file->InitWithNativePath(NS_LITERAL_CSTRING("~/.mozilla/favicon"));
   target_file->Append(NS_ConvertUTF8toUTF16(fileName));
 
   nsString path;
   target_file->GetPath(path);
   ::gFavLocation = NS_strdup(NS_ConvertUTF16toUTF8(path).get());
   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
-    NS_Free(::gFavLocation);
+    if (::gFavLocation)
+      NS_Free(::gFavLocation);
     gFavLocation = nsnull;
     return;
   }
 
   nsCOMPtr<nsIURI> uri;
-
-  rv = ios->NewURI(nsDependentCString(favicon_uri), "", nsnull, getter_AddRefs(uri));
+  rv = ios->NewURI(nsDependentCString(aURI), "", nsnull, getter_AddRefs(uri));
   if (!uri) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
-    NS_Free(::gFavLocation);
+    if (::gFavLocation)
+      NS_Free(::gFavLocation);
     gFavLocation = nsnull;
     return;
   }
-  NS_Free(file_name);
-  NS_Free(favicon_uri);
 
   // save the favicon if the icon does not exist
   rv = target_file->Exists(&isExist);
   if (NS_SUCCEEDED(rv) && !isExist) {
     rv = persist->SaveURI(uri, nsnull, nsnull, nsnull, "", target_file);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv))
       return;
-    }
   }
-  else {
+  else
     GeneratePixBuf();
-  }
-
 }
 
 NS_IMETHODIMP
 EmbedEventListener::OnStateChange(nsIWebProgress *aWebProgress,
                                   nsIRequest *aRequest,
                                   PRUint32 aStateFlags,
                                   nsresult aStatus)
 {
   /* if (!(aStateFlags & (STATE_STOP | STATE_IS_NETWORK | STATE_IS_DOCUMENT))){*/
 
+  if (EmbedPrivate::sTermEmbedding) {
+      fprintf(stderr,"%s:Warning: Emit signal after destroy\n", __FUNCTION__);
+      return NS_ERROR_FAILURE;
+  }
   if (aStateFlags & STATE_STOP)
     /* FINISH DOWNLOADING */
     /* XXX sometimes this==0x0 and it cause crash in GeneratePixBuf, need workaround check for this */
-    if (NS_SUCCEEDED(aStatus) && this)
+    if (NS_SUCCEEDED(aStatus) && this && aRequest && aWebProgress)
       GeneratePixBuf();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::OnProgressChange(nsIWebProgress *aWebProgress,
                                      nsIRequest *aRequest,
@@ -933,8 +1128,101 @@
 
 NS_IMETHODIMP
 EmbedEventListener::OnSecurityChange(nsIWebProgress *aWebProgress,
                                      nsIRequest *aRequest,
                                      PRUint32 aState)
 {
   return NS_OK;
 }
+
+void
+EmbedEventListener::DisableLongPressTimer(GtkWidget *aOwningWidget)
+{
+  gint return_val;
+
+  GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+
+  gtk_signal_emit(GTK_OBJECT(aOwningWidget),
+                  moz_embed_signals[DOM_MOUSE_UP],
+                  NULL, &return_val);
+
+  sMPressed = sIsScrolling ? PR_FALSE : sMPressed;
+  sIsScrolling = PR_FALSE;
+}
+
+#include <gdk/gdkx.h>
+/* static */
+gboolean
+motion_notify_event_cb (GtkWidget *widget, GdkEventMotion *event, EmbedEventListener *self)
+{
+  gint intx = nscoord(event->x);
+  gint inty = nscoord(event->y);
+  // Filtering all motion events, because our hardware is sh...
+  if (ABS(sgX - intx) < sScrollStep
+      && ABS(sgY - inty) < sScrollStep) {
+      //gdk_event_request_motions(event);
+      return TRUE;
+  }
+
+  sgX = intx;
+  sgY = inty;
+
+  if (sXulType == 3) {
+    //gdk_event_request_motions(event);
+    return TRUE;
+  }
+
+  if ((sIsScrolling || sXulType == 2) && sXulType != 0) {
+    XEvent xevent;
+    PRPackedBool synthEvent = PR_FALSE;
+    while (XCheckWindowEvent(GDK_WINDOW_XDISPLAY(event->window),
+                             GDK_WINDOW_XWINDOW(event->window),
+                             ButtonMotionMask, &xevent)) {
+      synthEvent = PR_TRUE;
+    }
+
+    if (sXulType == 2) {
+      self->MouseMove(nsnull);
+      return FALSE;
+    }
+    self->MouseMove(nsnull);
+    //gdk_event_request_motions(event);
+    return TRUE;
+  }
+  return FALSE;
+}
+
+/* static */
+gboolean
+button_release_event_cb (GtkWidget *widget, GdkEvent *event, EmbedPrivate *self)
+{
+  PanStatesReset(self);
+  return FALSE;
+}
+
+/* static */
+gboolean
+button_press_event_cb (GtkWidget *widget, GdkEvent *event, EmbedPrivate *self)
+{
+  spX = nscoord(((GdkEventButton*)event)->x);
+  spY = nscoord(((GdkEventButton*)event)->y);
+  return FALSE;
+}
+
+/* static */
+gboolean
+enter_notify_event_cb (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self)
+{
+  if (sXulType == 3)
+    return TRUE;
+  return FALSE;
+}
+
+/* static */
+gboolean
+leave_notify_event_cb (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self)
+{
+  if (sXulType == 3)
+    return TRUE;
+  return FALSE;
+}
+
Index: mozilla/embedding/browser/gtk/src/EmbedEventListener.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedEventListener.h
+++ mozilla/embedding/browser/gtk/src/EmbedEventListener.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -129,21 +129,25 @@
 
   nsresult   NewURI            (nsIURI **result,
                                 const char *spec);
   nsresult   GetIOService      (nsIIOService **ioService);
 
   void       GeneratePixBuf    ();
 
   void       GetFaviconFromURI (const char*  aURI);
+
+  static void DisableLongPressTimer(GtkWidget *aOwningWidget);
  private:
 
   EmbedPrivate *mOwner;
   EmbedContextMenuInfo *mCtxInfo;
 
   // Selection and some clipboard stuff
   nsCOMPtr<nsISelectionController> mCurSelCon;
   nsCOMPtr<nsISelectionController> mLastSelCon;
   PRBool mFocusInternalFrame;
   PRInt32 mClickCount;
+  PRBool mAddonSignals;
+  PRBool mXSLTransformed;
 };
 
 #endif /* __EmbedEventListener_h */
Index: mozilla/embedding/browser/gtk/src/EmbedFilePicker.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedFilePicker.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedFilePicker.cpp
@@ -11,21 +11,16 @@
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
- * The Initial Developer of the Original Code is
- * timeless <timeless@mozdev.org>.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
  * Contributor(s):
  *   Antonio Gomes <tonikitoo@gmail.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
Index: mozilla/embedding/browser/gtk/src/EmbedFilePicker.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedFilePicker.h
+++ mozilla/embedding/browser/gtk/src/EmbedFilePicker.h
@@ -11,21 +11,16 @@
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
- * The Initial Developer of the Original Code is
- * timeless <timeless@mozdev.org>.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
  * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
Index: mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGlobalHistory.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.cpp
@@ -18,16 +18,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Conrad Carlen <ccarlen@netscape.com>
  *   Oleg Romashin <romaxa@gmail.com>
+ *   Andre Pedralho <apedralho@gmail.com>
  *   (from original mozilla/embedding/lite/nsEmbedGlobalHistory.cpp)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
@@ -53,17 +54,17 @@
 #ifndef MOZILLA_INTERNAL_API
 #include "nsCRT.h"
 #endif
 #include "nsILineInputStream.h"
 
 // Constants
 #define defaultSeparator 1
 // Number of changes in history before automatic flush
-static const PRInt32 kNewEntriesBetweenFlush = 10;
+static const PRInt32 kNewEntriesBetweenFlush = 20;
 static const PRInt32 kMaxSafeReadEntriesCount = 2000;
 // Default expiration interval: used if can't get preference service value
 static const PRUint32 kDefaultExpirationIntervalDays = 7;
 // Mozilla and EAL standard are different each other
 static const PRInt64 kMSecsPerDay = LL_INIT(0, 60 * 60 * 24 * 1000);
 static const PRInt64 kOneThousand = LL_INIT(0, 1000);
 // The history list and the entries counter
 static GList *mURLList;                 /** < The history list */
@@ -151,29 +152,28 @@
 {
   g_return_val_if_fail(file_handle, false);
   nsresult rv;
   nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(file_handle, &rv);
   rv = seekable->SetEOF();
   return NS_SUCCEEDED(rv);
 }
 
-static guint64 file_handle_write(OUTPUT_STREAM *file_handle, gpointer line)
+static bool file_handle_write(OUTPUT_STREAM *file_handle, gpointer line)
 {
   g_return_val_if_fail(file_handle, 0);
   PRUint32 amt = 0;
   nsresult rv;
   rv = file_handle->Write((char*)line, strlen((char*)line), &amt);
-  /* XXX booleans are not equivalent to guint64 */
   return NS_SUCCEEDED(rv);
 }
 
 // Static Routine Prototypes
-//GnomeVFSHandle
 static nsresult writeEntry(OUTPUT_STREAM *file_handle, HistoryEntry *entry);
+
 // when an entry is visited
 nsresult OnVisited(HistoryEntry *entry)
 {
   NS_ENSURE_ARG(entry);
   entry->mLastVisitTime = PR_Now();
   LL_DIV(entry->mLastVisitTime, entry->mLastVisitTime, kOneThousand);
   return NS_OK;
 }
@@ -205,36 +205,49 @@
 nsresult SetIsWritten(HistoryEntry *entry)
 {
   NS_ENSURE_ARG(entry);
   entry->mWritten = PR_TRUE;
   return NS_OK;
 }
 
 // Change the entry title
-#define SET_TITLE(entry, aTitle) (entry->mTitle.Assign(aTitle))
-
-// Return the entry title
-#define GET_TITLE(entry) (entry && !entry->mTitle.IsEmpty() ? entry->mTitle.get() : "")
-
-// Change the entry title
 nsresult SET_URL(HistoryEntry *aEntry, const char *aUrl)
 {
   NS_ENSURE_ARG(aEntry);
   NS_ENSURE_ARG(aUrl);
   aEntry->mUrl.Assign(aUrl);
   return NS_OK;
 }
 
 // Return the entry url
 const char* GET_URL(HistoryEntry *aEntry)
 {
   return (aEntry && !aEntry->mUrl.IsEmpty()) ? aEntry->mUrl.get() : "";
 }
 
+// Return the entry url
+const char* GET_HOST(HistoryEntry *aEntry)
+{
+  nsCOMPtr<nsIURI> aURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(aURI), GET_URL(aEntry));
+  if (NS_FAILED(rv))
+    return GET_URL(aEntry);
+  aURI->GetHost(aEntry->mTitle);
+  if (aEntry->mTitle.IsEmpty())
+    return GET_URL(aEntry);
+  return aEntry->mTitle.get();
+}
+
+// Change the entry title
+#define SET_TITLE(entry, aTitle) (entry->mTitle.Assign(aTitle))
+
+// Return the entry title
+#define GET_TITLE(entry) (entry && !entry->mTitle.IsEmpty() ? entry->mTitle.get() : GET_HOST(entry))
+
 // Traverse the history list trying to find a frame
 int history_entry_find_exist(gconstpointer a, gconstpointer b)
 {
   return g_ascii_strcasecmp((char*)GET_URL((HistoryEntry *)a), (char *) b);
 }
 
 // Traverse the history list looking for the correct place to add a new item
 int find_insertion_place(gconstpointer a, gconstpointer b)
@@ -292,19 +305,17 @@
   return sEmbedGlobalHistory;
 }
 
 /* static */
 void
 EmbedGlobalHistory::DeleteInstance()
 {
   if (sEmbedGlobalHistory)
-  {
     delete sEmbedGlobalHistory;
-  }
 }
 
 // The global history component constructor
 EmbedGlobalHistory::EmbedGlobalHistory()
 : mFileHandle(nsnull)
 {
   if (!mURLList) {
     mDataIsLoaded = PR_FALSE;
@@ -315,52 +326,54 @@
     LL_MUL(mExpirationInterval, mExpirationInterval, kMSecsPerDay);
   }
 }
 
 // The global history component destructor
 EmbedGlobalHistory::~EmbedGlobalHistory()
 {
   LoadData();
-  FlushData(kFlushModeFullWrite);
+  mFlushModeFullWriteNeeded = PR_TRUE;
+  FlushData();
   if (mURLList) {
     g_list_foreach(mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
     g_list_free(mURLList);
     mURLList = NULL;
   }
   if (mFileHandle) {
     CLOSE_FILE_HANDLE(mFileHandle);
   }
   if (mHistoryFile) {
-    g_free(mHistoryFile);
+    NS_Free(mHistoryFile);
     mHistoryFile = nsnull;
   }
   if (sEmbedGlobalHistory)
     sEmbedGlobalHistory = nsnull;
 }
 
 // Initialize the global history component
 NS_IMETHODIMP EmbedGlobalHistory::Init()
 {
-  if (mURLList) return NS_OK;
+  if (mURLList)
+    return NS_OK;
   // Get Pref and convert to millisecs
 
   PRInt32 expireDays;
   int success = gtk_moz_embed_common_get_pref(G_TYPE_INT, EMBED_HISTORY_PREF_EXPIRE_DAYS, &expireDays);
   if (success) {
     LL_I2L(mExpirationInterval, expireDays);
     LL_MUL(mExpirationInterval, mExpirationInterval, kMSecsPerDay);
   }
   // register to observe profile changes
   nsCOMPtr<nsIObserverService> observerService =
     do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
   NS_ASSERTION(observerService, "failed to get observer service");
   if (observerService) {
     observerService->AddObserver(this, "quit-application", PR_FALSE);
-    observerService->AddObserver(this, "RemoveEntries", PR_FALSE);
+    observerService->AddObserver(this, "history-item-removed", PR_FALSE);
   }
   nsresult rv = InitFile();
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
   rv = LoadData();
   NS_ENSURE_SUCCESS(rv, rv);
   return rv;
 }
@@ -424,497 +437,667 @@
   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
   // Only get valid uri schemes
   if (!isHTTP && !isHTTPS)
   {
     /* the following blacklist is silly.
      * if there's some need to whitelist http(s) + ftp,
      * that's what we should do.
      */
-    PRBool isAbout, isImap, isNews, isMailbox, isViewSource, isChrome, isData, isJavascript;
+    PRBool isAbout, isImap, isNews, isMailbox, isViewSource, isChrome, isData, isJavascript, isLocal;
     rv  = aURI->SchemeIs("about", &isAbout);
     rv |= aURI->SchemeIs("imap", &isImap);
     rv |= aURI->SchemeIs("news", &isNews);
+    rv |= aURI->SchemeIs("file", &isLocal);
     rv |= aURI->SchemeIs("mailbox", &isMailbox);
     rv |= aURI->SchemeIs("view-source", &isViewSource);
     rv |= aURI->SchemeIs("chrome", &isChrome);
     rv |= aURI->SchemeIs("data", &isData);
     rv |= aURI->SchemeIs("javascript", &isJavascript);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     if (isAbout ||
         isImap ||
         isNews ||
+        isLocal ||
         isMailbox ||
         isViewSource ||
         isChrome ||
         isData ||
         isJavascript) {
       return NS_OK;
     }
   }
-#ifdef DEBUG
-  //  NS_WARNING("[HISTORY] Visited URL: %s\n", aURL);
-#endif
+
   rv = LoadData();
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_FAILED(rv))
+    return rv;
+
   GList *node = g_list_find_custom(mURLList, aURL, (GCompareFunc) history_entry_find_exist);
   HistoryEntry *entry = NULL;
   if (node && node->data)
     entry = (HistoryEntry *)(node->data);
   nsCAutoString hostname;
   aURI->GetHost(hostname);
 
-  // It is not in the history
+  // It is not in the history: add a new entry
   if (!entry) {
     entry = new HistoryEntry;
-    ALLOC_NOT_CHECKED(entry);
-    rv |= OnVisited(entry);
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    rv = OnVisited(entry);
+    if (NS_FAILED(rv)) {
+      NS_Free(entry);
+      return rv;
+    }
+
     SET_TITLE(entry, hostname);
-    rv |= SET_URL(entry, aURL);
-    BROKEN_RV_HANDLING_CODE(rv);
+    rv = SET_URL(entry, aURL);
+    if (NS_FAILED(rv)) {
+      NS_Free(entry);
+      return rv;
+    }
+
     unsigned int listSize = g_list_length(mURLList);
     if (listSize+1 > kDefaultMaxSize) {
       GList *last = g_list_last(mURLList);
       mURLList = g_list_remove(mURLList, last->data);
     }
     mURLList = g_list_insert_sorted(mURLList, entry,
                                     (GCompareFunc) find_insertion_place);
+
     // Flush after kNewEntriesBetweenFlush changes
-    BROKEN_RV_HANDLING_CODE(rv);
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeAppend);
-    // At this point, something understands there's a new global history item
-  } else {
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return rv;
+    }
+  }
+  // It is already in the history: just update the entry
+  else {
     // update the last visited time
-    rv |= OnVisited(entry);
+    rv = OnVisited(entry);
+    if (NS_FAILED(rv))
+      return rv;
+
     SET_TITLE(entry, hostname);
     // Move the element to the start of the list
-    BROKEN_RV_HANDLING_CODE(rv);
     mURLList = g_list_remove(mURLList, entry);
     mURLList = g_list_insert_sorted(mURLList, entry, (GCompareFunc) find_insertion_place);
+
     // Flush after kNewEntriesBetweenFlush changes
-    BROKEN_RV_HANDLING_CODE(rv);
-    
     mFlushModeFullWriteNeeded = PR_TRUE;
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeFullWrite);
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return rv;
+    }
   }
-  return rv;
+  return NS_OK;
 }
 
 // Return TRUE if the url is already in history
 NS_IMETHODIMP EmbedGlobalHistory::IsVisited(nsIURI *aURI, PRBool *_retval)
 {
   NS_ENSURE_ARG(aURI);
   NS_ENSURE_ARG_POINTER(_retval);
   nsCAutoString URISpec;
   aURI->GetSpec(URISpec);
   const char *aURL = URISpec.get();
   nsresult rv = LoadData();
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  // find the element in the history list
   GList *node = g_list_find_custom(mURLList, aURL,
                                    (GCompareFunc) history_entry_find_exist);
   *_retval = (node && node->data);
-  return rv;
+  return NS_OK;
 }
 
 // It is called when Mozilla get real name of a URL
 NS_IMETHODIMP EmbedGlobalHistory::SetPageTitle(nsIURI *aURI,
                                                const nsAString & aTitle)
 {
   NS_ENSURE_ARG(aURI);
   nsresult rv;
   // skip about: URIs to avoid reading in the db (about:blank, especially)
   PRBool isAbout;
   rv = aURI->SchemeIs("about", &isAbout);
   NS_ENSURE_SUCCESS(rv, rv);
   if (isAbout)
     return NS_OK;
+
+  // load the stored history
+  rv = LoadData();
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsCAutoString URISpec;
   aURI->GetSpec(URISpec);
   const char *aURL = URISpec.get();
-  rv |= LoadData();
-  BROKEN_RV_HANDLING_CODE(rv);
-  NS_ENSURE_SUCCESS(rv, rv);
 
+  // find the entry in the history list
   GList *node = g_list_find_custom(mURLList, aURL,
                                    (GCompareFunc) history_entry_find_exist);
   HistoryEntry *entry = NULL;
-  if (node)
-    entry = (HistoryEntry *)(node->data);
-  if (entry) {
+
+  // entry not found
+  if (!node)
+    return NS_ERROR_FAILURE;
+
+  entry = (HistoryEntry *)(node->data);
+
+  // change the entry content
+  if (!entry) {
+    return NS_ERROR_FAILURE;
+  }
+  else {
     SET_TITLE(entry, NS_ConvertUTF16toUTF8(aTitle).get());
-    BROKEN_RV_HANDLING_CODE(rv);
-    
+
+    // flush after kNewEntriesBetweenFlush entries found
     mFlushModeFullWriteNeeded = PR_TRUE;
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeFullWrite);
-    BROKEN_RV_HANDLING_CODE(rv);
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+    }
   }
-  return rv;
+
+  return NS_OK;
 }
 
 nsresult EmbedGlobalHistory::RemoveEntries(const PRUnichar *url, int time)
 {
-  nsresult rv = NS_ERROR_FAILURE;
+  nsresult rv;
+
+  // there is no history list
   if (!mURLList)
-    return rv;
+    return NS_ERROR_FAILURE;
 
+  // the item to be removed is a URL
   if (url) {
     GList *node = g_list_find_custom(mURLList, NS_ConvertUTF16toUTF8(url).get(), (GCompareFunc) history_entry_find_exist);
-    if (!node) return rv;
-    if (node->data) {
+    if (!node)
+      return NS_ERROR_FAILURE;
+    if (!(node->data)) {
+      return NS_ERROR_FAILURE;
+    }
+    else {
       HistoryEntry *entry = static_cast<HistoryEntry *>
-                                       (node->data);
+                                           (node->data);
 
       entry->mLastVisitTime = 0;
+      mURLList = g_list_remove_link(mURLList, node);
       delete entry;
-      mURLList = g_list_remove(mURLList, entry);
     }
-  } else {
+  }
+  // the item to be removed is a folder
+  else {
     g_list_foreach (mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
     g_list_free(mURLList);
     mURLList = NULL;
   }
 
+  // flush after kNewEntriesBetweenFlush changes
   mFlushModeFullWriteNeeded = PR_TRUE;
-  mEntriesAddedSinceFlush++;
-  rv = FlushData(kFlushModeFullWrite);
-
-  return rv;
+  if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+    rv = FlushData();
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
 }
 
 //*****************************************************************************
 // EmbedGlobalHistory::nsIObserver
 //*****************************************************************************
 NS_IMETHODIMP EmbedGlobalHistory::Observe(nsISupports *aSubject,
                                           const char *aTopic,
                                           const PRUnichar *aData)
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+
   // used when the browser is closed and the EmbedGlobalHistory destructor is not called
   if (strcmp(aTopic, "quit-application") == 0) {
+    // load the history data to ensure that all the history items stored in the file were properly loaded
     rv = LoadData();
-    // we have to sort the list before flush it
-    rv |= FlushData(kFlushModeFullWrite);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+    // flush the history data
+    rv = FlushData();
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+    // free the history list
     if (mURLList) {
       g_list_foreach(mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
       g_list_free(mURLList);
       mURLList = NULL;
     }
+    // close the history file
     if (mFileHandle) {
       CLOSE_FILE_HANDLE(mFileHandle);
     }
-  } else if (strcmp(aTopic, "RemoveEntries") == 0) {
-    rv |= RemoveEntries(aData, 0);
   }
-  return rv;
+  // used when the user wants to remove a history item
+  else if (strcmp(aTopic, "history-item-removed") == 0) {
+    rv = RemoveEntries(aData, 0);
+    if(NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
 }
 
 static nsresult
 GetHistoryFileName(char **aHistoryFile)
 {
   NS_ENSURE_ARG_POINTER(aHistoryFile);
   // Get the history file in our profile dir.
   // Notice we are not just getting NS_APP_HISTORY_50_FILE
   // because it is used by the "real" global history component.
+  nsCAutoString tempDirString;
+  // there is a profile set
   if (EmbedPrivate::sProfileDir) {
     nsCString path;
     EmbedPrivate::sProfileDir->GetNativePath(path);
-    *aHistoryFile = g_strdup_printf("%s/history.dat", path.get());
-    BROKEN_STRING_BUILDER(aHistoryFile);
-  } else {
-    *aHistoryFile = g_strdup_printf("%s/history.dat", g_get_tmp_dir());
-    BROKEN_STRING_BUILDER(aHistoryFile);
+
+    tempDirString.Assign(path.get());
+  }
+  // there is no profile set
+  else
+  {
+    // get the temporary directory
+    tempDirString.Assign(g_get_tmp_dir());
   }
+  // the history file name
+  tempDirString.Append(NS_LITERAL_CSTRING("/history.txt"));
+  // return the full history path
+  *aHistoryFile = ToNewCString(tempDirString);
+  if (!(*aHistoryFile))
+    return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
 }
+
 //*****************************************************************************
 // EmbedGlobalHistory
 //*****************************************************************************
-// Open/Create the history.dat file if it does not exist
+// Open/Create the history.txt file if it does not exist
 nsresult EmbedGlobalHistory::InitFile()
 {
-  if (!mHistoryFile) {
+  // the history file is not initialized
+  if (!mHistoryFile)
     if (NS_FAILED(GetHistoryFileName(&mHistoryFile)))
       return NS_ERROR_FAILURE;
-  }
 
   LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
   if (!uri)
     return NS_ERROR_FAILURE;
 
   gboolean rs = FALSE;
+  // there is not a history file
   if (!file_handle_uri_exists(uri)) {
+    // create the history file
     if (!file_handle_create_uri(&mFileHandle, uri)) {
-      NS_WARNING("Could not create a history file\n");
+      NS_WARNING("Could not create a history file");
       file_handle_uri_release(uri);
       return NS_ERROR_FAILURE;
     }
+    // close the history file
     CLOSE_FILE_HANDLE(mFileHandle);
   }
+  // open the history file
   rs = file_handle_open_uri(&mFileHandle, uri);
 
   file_handle_uri_release(uri);
 
   if (!rs) {
-    NS_WARNING("Could not open a history file\n");
+    NS_WARNING("Could not open a history file");
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
-// Get the data from history.dat file
+// Get the data from history.txt file
 nsresult EmbedGlobalHistory::LoadData()
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // the data is not loaded
   if (!mDataIsLoaded) {
-    mDataIsLoaded = PR_TRUE;
+    // create the history file handle
     LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
-    if (uri) {
-      rv |= ReadEntries(uri);
+    // could not create a history file handle
+    if (!uri) {
+      return NS_ERROR_FAILURE;
+    }
+    else {
+      rv = ReadEntries(uri);
+      // could not read the history entries
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
       file_handle_uri_release(uri);
     }
+    mDataIsLoaded = PR_TRUE;
   }
-  return rv;
+  return NS_OK;
 }
 
-// Call a function to write each entry in the history hash table
 nsresult EmbedGlobalHistory::WriteEntryIfWritten(GList *list, OUTPUT_STREAM *file_handle)
 {
-  if (!file_handle)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_ARG_POINTER(file_handle);
 
+  // get the history length;
   unsigned int counter = g_list_length(list);
+
+  // for each history entry
   while (counter > 0) {
+    // get a history entry
     HistoryEntry *entry = static_cast<HistoryEntry*>(g_list_nth_data(list, counter-1));
     counter--;
-    if (!entry || entryHasExpired(entry)) {
+
+    // could not get a history entry
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    // the entry has expired so does not store it in the history file
+    if (entryHasExpired(entry))
       continue;
-    }
+
+    // write the entry in the history file
     writeEntry(file_handle, entry);
   }
   return NS_OK;
 }
 
-// Call a function to write each unwritten entry in the history hash table
 nsresult EmbedGlobalHistory::WriteEntryIfUnwritten(GList *list, OUTPUT_STREAM *file_handle)
 {
-  if (!file_handle)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_ARG_POINTER(file_handle);
+
+  // get the history length;
   unsigned int counter = g_list_length(list);
+
+  // for each history entry
   while (counter > 0) {
+    // get a history entry
     HistoryEntry *entry = static_cast<HistoryEntry*>(g_list_nth_data(list, counter-1));
-    if (!entry || entryHasExpired(entry)) {
-      counter--;
+    counter--;
+
+    // could not get a history entry
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    // the entry has expired so don't store it in the history file
+    if(entryHasExpired(entry))
       continue;
-    }
+
+    // the entry has not been written
     if (!GetIsWritten(entry))
       writeEntry(file_handle, entry);
-    counter--;
   }
   return NS_OK;
 }
 
-// Write the history in history.dat file
-nsresult EmbedGlobalHistory::FlushData(PRIntn mode)
+nsresult EmbedGlobalHistory::FlushData()
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // there are no history entries to be added
   if (mEntriesAddedSinceFlush == 0)
     return NS_OK;
+
+  // there is no history file handle
   if (!mHistoryFile)
   {
+    // create the history file
     rv = InitFile();
     NS_ENSURE_SUCCESS(rv, rv);
-    rv = FlushData(kFlushModeFullWrite);
-    return rv;
-  }
-  LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
-  if (!uri) return NS_ERROR_FAILURE;
 
-  gboolean rs = file_handle_uri_exists(uri);
-  file_handle_uri_release(uri);
-
-  if (!rs && NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
+    mFlushModeFullWriteNeeded = PR_TRUE;
+    rv = FlushData();
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
 
-  if (mode == kFlushModeFullWrite || mFlushModeFullWriteNeeded == PR_TRUE)
+  if (mFlushModeFullWriteNeeded)
   {
     if (!file_handle_seek(mFileHandle, FALSE))
       return NS_ERROR_FAILURE;
     if (!file_handle_truncate(mFileHandle))
       return NS_ERROR_FAILURE;
     WriteEntryIfWritten(mURLList, mFileHandle);
     mFlushModeFullWriteNeeded = PR_FALSE;
   }
+  // just need to append some entries
   else
   {
+    // go to the end of the history file
     if (!file_handle_seek(mFileHandle, TRUE))
       return NS_ERROR_FAILURE;
     WriteEntryIfUnwritten(mURLList, mFileHandle);
   }
-
   mEntriesAddedSinceFlush = 0;
   return NS_OK;
 }
 
 // Split an entry in last visit time, title and url.
-// Add a stored entry in the history.dat file in the history hash table
-nsresult EmbedGlobalHistory::GetEntry(const char *entry)
+// Add a stored entry in the history.txt file in the history list
+nsresult EmbedGlobalHistory::GetEntry(nsCString& string)
 {
+  char *entry = string.BeginWriting();
+  PRInt32 str_len = string.Length();
   char separator = (char) defaultSeparator;
   int pos = 0;
   nsInt64 outValue = 0;
+  // get the last visit time from the given entry
   while (PR_TRUE) {
     PRInt32 digit;
+    // it is a separator: get the next digit
     if (entry[pos] == separator) {
       pos++;
       break;
     }
-    if (entry[pos] == '\0' || !isdigit(entry[pos]))
+    // it is the end of a word or is not a number
+    if (str_len <= pos || entry[pos] == '\0' || !isdigit(entry[pos]))
       return NS_ERROR_FAILURE;
     digit = entry[pos] - '0';
+    // add the new digit found to the previous ones
     outValue *= nsInt64(10);
     outValue += nsInt64(digit);
     pos++;
   }
-  char url[1024], title[1024];
+  char *url=&entry[pos];
   int urlLength= 0, titleLength= 0, numStrings=1;
-  // get the url and title
+  // get the url and title from the given entry
   // FIXME
   while(PR_TRUE) {
+    if (str_len <= pos) break;
+    // it is a separator: get the next character
     if (entry[pos] == separator) {
       numStrings++;
       pos++;
       continue;
     }
+    // there are no more strings to be found
     if (numStrings > 2)
       break;
-    if (numStrings==1) {
-      url[urlLength++] = entry[pos];
-    } else {
-      title[titleLength++] = entry[pos];
-  }
-  pos++;
+    // it is the first string found: the url
+    if (numStrings == 1)
+      urlLength++;
+    // it is the second string found: the title
+    else
+      titleLength++;
+    pos++;
   }
+  // terminate the strings properly
+  if (!urlLength || !titleLength)
+    return NS_ERROR_FAILURE;
+
   url[urlLength]='\0';
+  char *title=&url[urlLength + 1];
   title[titleLength]='\0';
+
+  // create a new history entry
   HistoryEntry *newEntry = new HistoryEntry;
   if (!newEntry)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // initialize the title of the new entry
   SET_TITLE(newEntry, title);
-  rv |= SetLastVisitTime(newEntry, outValue);
-  rv |= SetIsWritten(newEntry);
-  rv |= SET_URL(newEntry, url);
-  BROKEN_RV_HANDLING_CODE(rv);
-  // Check wheter the entry has expired
-  if (!entryHasExpired(newEntry)) {
+  // initialize the last visit time of the new entry
+  rv = SetLastVisitTime(newEntry, outValue);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+  // initialize the isWritten flag of the new entry: it is in the history file
+  rv = SetIsWritten(newEntry);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+  // initialize the url of the new entry
+  rv = SET_URL(newEntry, url);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  // Check whether the entry has expired and then add it to the history list
+  if (!entryHasExpired(newEntry))
     mURLList = g_list_prepend(mURLList, newEntry);
-  }
-  return rv;
+  return NS_OK;
 }
 
-
-// Get the history entries from history.dat file
+// Get the history entries from history.txt file
 nsresult EmbedGlobalHistory::ReadEntries(LOCAL_FILE *file_uri)
 {
+  // the history file handle has not been initialized
   if (!file_uri)
     return NS_ERROR_FAILURE;
 
   nsresult rv = NS_OK;
-
+  // create an input stream
   nsCOMPtr<nsIInputStream> fileStream;
   NS_NewLocalFileInputStream(getter_AddRefs(fileStream), file_uri);
   if (!fileStream)
     return NS_ERROR_OUT_OF_MEMORY;
   nsCOMPtr<nsILineInputStream> lineStream = do_QueryInterface(fileStream, &rv);
   NS_ASSERTION(lineStream, "File stream is not an nsILineInputStream");
   // Read the header
   nsCString utf8Buffer;
   PRBool moreData = PR_FALSE;
 
   PRInt32 safe_limit = 0;
+  // get the file content line by line
   do {
     rv = lineStream->ReadLine(utf8Buffer, &moreData);
     safe_limit++;
     if (NS_FAILED(rv))
-      return NS_OK;
+      break;
 
+    // go to the next line: might be a blank line in the file
     if (utf8Buffer.IsEmpty())
       continue;
-    rv = GetEntry(utf8Buffer.get());
+
+    // add the entry to the history
+    rv = GetEntry(utf8Buffer);
+    if (NS_FAILED(rv))
+      break;
   } while (moreData && safe_limit < kMaxSafeReadEntriesCount);
+  // close the file stream
   fileStream->Close();
-
   return rv;
 }
 
 //*****************************************************************************
 // Static Functions
 //*****************************************************************************
-// Get last visit time from a string
+// Transform the last visit time from a PRInt64 to a string
 static nsresult writePRInt64(char time[14], const PRInt64& inValue)
 {
   nsInt64 value(inValue);
+  // the inValue is 0, then return a "0" string
   if (value == nsInt64(0)) {
-    strcpy(time, "0");
+    strncpy(time, "0", 1);
     return NS_OK;
   }
   nsCAutoString tempString;
+  // transform the PRInt64 in a nsCAutoString, digit by digit
   while (value != nsInt64(0)) {
     PRInt32 ones = PRInt32(value % nsInt64(10));
     value /= nsInt64(10);
     tempString.Insert(char('0' + ones), 0);
   }
-  strcpy(time,(char *) tempString.get());
+  // transform the nsCAutoString to a string
+  strncpy(time,(char *) tempString.get(), 14);
   return NS_OK;
 }
 
-// Write an entry in the history.dat file
+// Write an entry in the history.txt file
 nsresult writeEntry(OUTPUT_STREAM *file_handle, HistoryEntry *entry)
 {
-  nsresult rv = NS_OK;
-  char sep = (char) defaultSeparator;
+  nsresult rv;
   char time[14];
+  nsCAutoString tempString;
+
+  // get the string equivalent to a PRInt64 value
   writePRInt64(time, GetLastVisitTime(entry));
-  char *line = g_strdup_printf("%s%c%s%c%s%c\n", time, sep, GET_URL(entry), sep, GET_TITLE(entry), sep);
-  BROKEN_STRING_BUILDER(line);
-  guint64 size = file_handle_write(file_handle, (gpointer)line);
-  if (size != strlen(line))
-    rv = NS_ERROR_FAILURE;
-  rv |= SetIsWritten(entry);
-  g_free(line);
-  return rv;
+
+  // add the time string to the entry line
+  tempString.Assign(time);
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the url string to the entry line
+  tempString.Append(GET_URL(entry));
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the title string to the entry line
+  tempString.Append(GET_TITLE(entry));
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the line separator to the entry line
+  tempString.Append("\n");
+
+  // write the new line to the file
+  guint64 size = file_handle_write(file_handle, (gpointer) tempString.get());
+
+  // could not write all the line to the file
+  if (size != tempString.Length())
+    rv = NS_ERROR_OUT_OF_MEMORY;
+  rv = SetIsWritten(entry);
+  if (NS_FAILED(rv))
+    return rv;
+  return NS_OK;
 }
 
-nsresult EmbedGlobalHistory::GetContentList(GtkMozHistoryItem **GtkHI, int *count)
+nsresult EmbedGlobalHistory::GetContentList(GtkMozHistoryItem **aHistoryVector, int *aCounter)
 {
-  if (!mURLList) return NS_ERROR_FAILURE;
+  // the history list has not been initialized
+  if (!mURLList)
+    return NS_ERROR_FAILURE;
 
-  unsigned int num_items = 0;
-  *GtkHI = g_new0(GtkMozHistoryItem, g_list_length(mURLList));
-  UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(*GtkHI);
-  GtkMozHistoryItem * item = (GtkMozHistoryItem *)*GtkHI;
-  while (num_items < g_list_length(mURLList)) {
+  // create a new history vector
+  *aHistoryVector = g_try_new0(GtkMozHistoryItem, g_list_length(mURLList));
+  if (!(*aHistoryVector))
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  GtkMozHistoryItem * aItem = (GtkMozHistoryItem *)*aHistoryVector;
+  // get the history items one by one
+  while ((uint)*aCounter < g_list_length(mURLList)) {
     HistoryEntry *entry = static_cast<HistoryEntry*>
-                                     (g_list_nth_data(mURLList, num_items));
+                                         (g_list_nth_data(mURLList, *aCounter));
     // verify if the entry has expired and discard it
-    if (entryHasExpired(entry)) {
+    if (entryHasExpired(entry))
       break;
-    }
+
     glong accessed;
+    // transform the last visit time to a readable value in microsecs
     PRInt64 temp, outValue;
     LL_MUL(outValue, GetLastVisitTime(entry), kOneThousand);
     LL_DIV(temp, outValue, PR_USEC_PER_SEC);
     LL_L2I(accessed, temp);
-    // Set the External history list
-    item[num_items].title = GET_TITLE(entry);
-    BROKEN_STRING_BUILDER(item[num_items].title);
-    item[num_items].url = GET_URL(entry);
-    item[num_items].accessed = accessed;
-    num_items++;
+    // set history vector title value
+    aItem[*aCounter].title = (const char *) GET_TITLE(entry);
+
+    if (!aItem[*aCounter].title)
+      return NS_ERROR_OUT_OF_MEMORY;
+    // set history vector url value
+    aItem[*aCounter].url = (const char *)GET_URL(entry);
+    if (!aItem[*aCounter].url)
+      return NS_ERROR_OUT_OF_MEMORY;
+    // set history vector accessed flag
+    aItem[*aCounter].accessed = accessed;
+    // count one more history item
+    (*aCounter)++;
   }
-  *count = num_items;
   return NS_OK;
 }
-
Index: mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGlobalHistory.h
+++ mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.h
@@ -16,17 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Conrad Carlen <ccarlen@netscape.com>
- *   Changes: andre.pedralho@indt.org.br (from original:  mozilla/embedding/lite/nsEmbedGlobalHistory.h)
+ *   Changes: apedralho@gmail.com (from original:  mozilla/embedding/lite/nsEmbedGlobalHistory.h)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -68,20 +68,16 @@
     NS_IMETHOD        Init();
     nsresult GetContentList(GtkMozHistoryItem**, int *count);
     NS_DECL_ISUPPORTS
     NS_DECL_NSIGLOBALHISTORY2
     NS_DECL_NSIOBSERVER
     nsresult RemoveEntries(const PRUnichar *url = nsnull, int time = 0);
 
     protected:
-    enum {
-        kFlushModeAppend,      /** < Add a new entry in the history file */
-        kFlushModeFullWrite    /** < Rewrite all history file */
-    };
 /** Initiates the history file
   * @return NS_OK on the success.
   */
     nsresult          InitFile();
 /** Loads the history file
   * @return NS_OK on the success.
   */
     nsresult          LoadData();
@@ -96,31 +92,31 @@
  * @param handle A Gnome VFS handle.
  * @return NS_OK on the success.
 */
     nsresult          WriteEntryIfUnwritten(GList *list, OUTPUT_STREAM *file_handle);
 /** Writes entries in the history file
   * @param mode How to write in the history file
   * @return NS_OK on the success.
   */
-    nsresult          FlushData(PRIntn mode = kFlushModeFullWrite);
+    nsresult          FlushData();
  /** Remove entries from the URL table
   * @return NS_OK on the success.
   */
     nsresult          ResetData();
 /** Reads the history entries using GnomeVFS
   * @param vfs_handle A Gnome VFS handle.
   * @return NS_OK on the success.
   */
     nsresult          ReadEntries(LOCAL_FILE *file_uri);
 /** Gets a history entry 
   * @param name The history entry name.
   * @return NS_OK if the history entry name was gotten.
   */
-    nsresult          GetEntry(const char *);
+    nsresult          GetEntry(nsCString &string);
     protected:
     OUTPUT_STREAM    *mFileHandle;              /** < The History File handle */
     PRBool            mDataIsLoaded;            /** < If the data is loaded */
     PRBool            mFlushModeFullWriteNeeded;/** < If needs a full flush */
     PRInt32           mEntriesAddedSinceFlush;  /** < Number of entries added since flush */
     gchar*            mHistoryFile;             /** < The history file path */
 };
 // Default maximum history entries
Index: mozilla/embedding/browser/gtk/src/EmbedGtkTools.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGtkTools.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedGtkTools.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin.
+ * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
Index: mozilla/embedding/browser/gtk/src/EmbedGtkTools.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGtkTools.h
+++ mozilla/embedding/browser/gtk/src/EmbedGtkTools.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin.
+ * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -59,9 +59,22 @@
 GetGtkWidgetForDOMWindow(nsIDOMWindow* aDOMWindow);
 
 GtkWindow*
 GetGtkWindowForDOMWindow(nsIDOMWindow* aDOMWindow);
 
 nsresult
 GetContentViewer(nsIWebBrowser *webBrowser, nsIContentViewer **aViewer);
 
+/* Helper Macros */
+
+#define GLIB_IF_PTR_FUNC_NULL(_ptr, _func) \
+  PR_BEGIN_MACRO                           \
+    if (_ptr) {                            \
+      _func(_ptr);                         \
+      (_ptr) = 0;                          \
+    }                                      \
+  PR_END_MACRO
+
+#define GLIB_SOURCE_IF_REMOVE(_ptr) GLIB_IF_PTR_FUNC_NULL(_ptr, g_source_remove)
+
 #endif /* __EmbedTools_h */
+
Index: mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPasswordMgr.cpp
+++ /dev/null
@@ -1,2067 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 tw=80 et cindent: */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Password Manager.
- *
- * The Initial Developer of the Original Code is
- * Brian Ryner.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Brian Ryner <bryner@brianryner.com>
- *   romaxa@gmail.com (Modified from original:  mozilla/toolkit/components/passwordmgr/base/nsPasswordManager.cpp)
- *   Antonio Gomes <tonikitoo@gmail.com>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-#include "EmbedPasswordMgr.h"
-#include "nsIFile.h"
-#include "nsNetUtil.h"
-#include "nsILineInputStream.h"
-#include "plbase64.h"
-#include "nsISecretDecoderRing.h"
-#include "nsIPrompt.h"
-#include "nsIPrefService.h"
-#include "nsIPrefBranch.h"
-#include "nsIPrefBranch2.h"
-#include "prmem.h"
-#include "nsIStringBundle.h"
-#ifdef MOZILLA_1_8_BRANCH
-#include "nsIArray.h"
-#include "nsObserverService.h"
-#else
-#include "nsIMutableArray.h"
-#endif
-#include "nsICategoryManager.h"
-#include "nsIObserverService.h"
-#include "nsIWebProgress.h"
-#include "nsIDOMDocument.h"
-#include "nsIDOMWindow.h"
-#include "nsIDOMHTMLDocument.h"
-#include "nsIDocument.h"
-#include "nsIDOMHTMLCollection.h"
-#include "nsIDOMHTMLInputElement.h"
-#include "nsIContent.h"
-#include "nsIFormControl.h"
-#include "nsIDOMWindowInternal.h"
-#include "nsCURILoader.h"
-#include "nsAppDirectoryServiceDefs.h"
-#include "nsIDOMEventTarget.h"
-#include "nsIDOMHTMLFormElement.h"
-#include "nsIPK11TokenDB.h"
-#include "nsIPK11Token.h"
-#include "nsUnicharUtils.h"
-#include "nsCOMArray.h"
-#include "nsIServiceManager.h"
-#include "nsIIDNService.h"
-#include "nsIAuthInformation.h"
-#include "nsIChannel.h"
-
-#include "nsIProxiedChannel.h"
-#include "nsIProxyInfo.h"
-#include "nsIURI.h"
-#include "nsNetUtil.h"
-#include "nsEmbedCID.h"
-#include "nsIPromptService2.h"
-#include "EmbedPrivate.h"
-#include "gtkmozembedprivate.h"
-#ifdef MOZILLA_INTERNAL_API
-#include "nsString.h"
-#include "nsXPIDLString.h"
-#else
-#include "nsDirectoryServiceUtils.h"
-#include "nsComponentManagerUtils.h"
-#include "nsStringAPI.h"
-#endif
-#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
-#include "nsPromptUtils.h"
-#include "nsIForm.h"
-#endif
-#include "nsIPassword.h"
-#include "nsIPasswordInternal.h"
-#include <string.h>
-
-
-static const char kPMPropertiesURL[] = "chrome://passwordmgr/locale/passwordmgr.properties";
-static PRBool sRememberPasswords = PR_FALSE;
-static PRBool sForceAutocompletion = PR_FALSE;
-static PRBool sPrefsInitialized = PR_FALSE;
-static nsIStringBundle* sPMBundle;
-static nsISecretDecoderRing* sDecoderRing;
-static EmbedPasswordMgr* sPasswordManager;
-class EmbedPasswordMgr::SignonDataEntry
-{
-public:
-  nsString userField;
-  nsString userValue;
-  nsString passField;
-  nsString passValue;
-  SignonDataEntry* next;
-  SignonDataEntry() : next(nsnull) { }
-  ~SignonDataEntry() {
-    delete next;
-  }
-};
-
-class EmbedPasswordMgr::SignonHashEntry
-{
-  // Wraps a pointer to the linked list of SignonDataEntry objects.
-  // This allows us to adjust the head of the linked list without a
-  // hashtable operation.
-public:
-  SignonDataEntry* head;
-  SignonHashEntry(SignonDataEntry* aEntry) : head(aEntry) { }
-  ~SignonHashEntry()
-  {
-    delete head;
-  }
-};
-
-class EmbedPasswordMgr::PasswordEntry : public nsIPasswordInternal
-{
-public:
-  PasswordEntry(const nsACString& aKey, SignonDataEntry* aData);
-  virtual ~PasswordEntry() { }
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIPASSWORD
-  NS_DECL_NSIPASSWORDINTERNAL
-protected:
-  nsCString mHost;
-  nsString  mUser;
-  nsString  mUserField;
-  nsString  mPassword;
-  nsString  mPasswordField;
-  PRBool  mDecrypted[2];
-};
-
-NS_IMPL_ISUPPORTS2(EmbedPasswordMgr::PasswordEntry,
-                   nsIPassword,
-                   nsIPasswordInternal)
-
-EmbedPasswordMgr::PasswordEntry::PasswordEntry(const nsACString& aKey,
-                                               SignonDataEntry* aData)
-: mHost(aKey)
-{
-  mDecrypted[0] = mDecrypted[1] = PR_FALSE;
-  if (aData) {
-    mUser.Assign(aData->userValue);
-    mUserField.Assign(aData->userField);
-    mPassword.Assign(aData->passValue);
-    mPasswordField.Assign(aData->passField);
-  }
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::PasswordEntry::GetHost(nsACString& aHost)
-{
-  aHost.Assign(mHost);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::PasswordEntry::GetUser(nsAString& aUser)
-{
-  if (!mUser.IsEmpty() && !mDecrypted[0]) {
-    if (NS_SUCCEEDED(DecryptData(mUser, mUser)))
-      mDecrypted[0] = PR_TRUE;
-    else
-      return NS_ERROR_FAILURE;
-  }
-  aUser.Assign(mUser);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::PasswordEntry::GetPassword(nsAString& aPassword)
-{
-  if (!mPassword.IsEmpty() && !mDecrypted[1]) {
-    if (NS_SUCCEEDED(DecryptData(mPassword, mPassword)))
-      mDecrypted[1] = PR_TRUE;
-    else
-      return NS_ERROR_FAILURE;
-  }
-  aPassword.Assign(mPassword);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::PasswordEntry::GetUserFieldName(nsAString& aField)
-{
-  aField.Assign(mUserField);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::PasswordEntry::GetPasswordFieldName(nsAString& aField)
-{
-  aField.Assign(mPasswordField);
-  return NS_OK;
-}
-
-NS_IMPL_ADDREF(EmbedPasswordMgr)
-NS_IMPL_RELEASE(EmbedPasswordMgr)
-NS_INTERFACE_MAP_BEGIN(EmbedPasswordMgr)
-  NS_INTERFACE_MAP_ENTRY(nsIPasswordManager)
-  NS_INTERFACE_MAP_ENTRY(nsIPasswordManagerInternal)
-  NS_INTERFACE_MAP_ENTRY(nsIObserver)
-  NS_INTERFACE_MAP_ENTRY(nsIFormSubmitObserver)
-  NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMFocusListener)
-  NS_INTERFACE_MAP_ENTRY(nsIDOMLoadListener)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMFocusListener)
-  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIPasswordManager)
-  NS_INTERFACE_MAP_ENTRY(nsIPromptFactory)
-NS_INTERFACE_MAP_END
-
-EmbedPasswordMgr::EmbedPasswordMgr()
-: mAutoCompletingField(nsnull), mCommonObject(nsnull)
-{
-}
-
-EmbedPasswordMgr::~EmbedPasswordMgr()
-{
-}
-
-/* static */
-EmbedPasswordMgr*
-EmbedPasswordMgr::GetInstance()
-{
-  if (!sPasswordManager) {
-    sPasswordManager = new EmbedPasswordMgr();
-    if (!sPasswordManager)
-      return nsnull;
-    NS_ADDREF(sPasswordManager);   // addref the global
-    if (NS_FAILED(sPasswordManager->Init())) {
-      NS_RELEASE(sPasswordManager);
-      return nsnull;
-    }
-  }
-  NS_ADDREF(sPasswordManager);   // addref the return result
-  return sPasswordManager;
-}
-
-nsresult
-EmbedPasswordMgr::Init()
-{
-  mSignonTable.Init();
-  mRejectTable.Init();
-  mAutoCompleteInputs.Init();
-  sPrefsInitialized = PR_TRUE;
-  nsCOMPtr<nsIPrefService> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
-  NS_ASSERTION(prefService, "No pref service");
-  prefService->GetBranch("signon.", getter_AddRefs(mPrefBranch));
-  NS_ASSERTION(mPrefBranch, "No pref branch");
-  mPrefBranch->GetBoolPref("rememberSignons", &sRememberPasswords);
-  mPrefBranch->GetBoolPref("forceAutocompletion", &sForceAutocompletion);
-  nsCOMPtr<nsIPrefBranch2> branchInternal = do_QueryInterface(mPrefBranch);
-  // Have the pref service hold a weak reference; the service manager
-  // will be holding a strong reference.
-  branchInternal->AddObserver("rememberSignons", this, PR_TRUE);
-  branchInternal->AddObserver("forceAutocompletion", this, PR_TRUE);
-  // Be a form submit and web progress observer so that we can save and
-  // prefill passwords.
-  nsCOMPtr<nsIObserverService> obsService = do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
-  NS_ASSERTION(obsService, "No observer service");
-  obsService->AddObserver(this, NS_FORMSUBMIT_SUBJECT, PR_TRUE);
-  nsCOMPtr<nsIWebProgress> progress = do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
-  NS_ASSERTION(progress, "No web progress service");
-  progress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_DOCUMENT);
-  // Now read in the signon file
-  char* signonFile = nsnull;
-  mPrefBranch->GetCharPref("SignonFileName", &signonFile);
-  NS_ASSERTION(signonFile, "Fallback for signon filename not present");
-  NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(mSignonFile));
-  NS_ENSURE_TRUE(mSignonFile, NS_ERROR_FAILURE);
-  mSignonFile->AppendNative(nsCString(signonFile));
-  nsCString path;
-  mSignonFile->GetNativePath(path);
-  ReadPasswords(mSignonFile);
-  return NS_OK;
-}
-
-/* static */ PRBool
-EmbedPasswordMgr::SingleSignonEnabled()
-{
-  if (!sPrefsInitialized) {
-    // Create the PasswordManager service to initialize the prefs and callback
-    nsCOMPtr<nsIPasswordManager> manager = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
-  }
-  return sRememberPasswords;
-}
-
-/* static */ NS_METHOD
-EmbedPasswordMgr::Register(nsIComponentManager* aCompMgr,
-                           nsIFile* aPath,
-                           const char* aRegistryLocation,
-                           const char* aComponentType,
-                           const nsModuleComponentInfo* aInfo)
-{
-  // By registering in NS_PASSWORDMANAGER_CATEGORY, an instance of the password
-  // manager will be created when a password input is added to a form.  We
-  // can then register that singleton instance as a form submission observer.
-  nsresult rv;
-  nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  char* prevEntry;
-  catman->AddCategoryEntry(NS_PASSWORDMANAGER_CATEGORY,
-                           "MicroB Password Manager",
-                           NS_PASSWORDMANAGER_CONTRACTID,
-                           PR_TRUE,
-                           PR_TRUE,
-                           &prevEntry);
-
-  catman->AddCategoryEntry("app-startup",
-                           "MicroB Password Manager",
-                           NS_PASSWORDMANAGER_CONTRACTID,
-                           PR_TRUE,
-                           PR_TRUE,
-                           &prevEntry);
-
-  return NS_OK;
-}
-
-/* static */ NS_METHOD
-EmbedPasswordMgr::Unregister(nsIComponentManager* aCompMgr,
-                             nsIFile* aPath,
-                             const char* aRegistryLocation,
-                             const nsModuleComponentInfo* aInfo)
-{
-  nsresult rv;
-  nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-  catman->DeleteCategoryEntry(NS_PASSWORDMANAGER_CATEGORY,
-                              NS_PASSWORDMANAGER_CONTRACTID,
-                              PR_TRUE);
-  return NS_OK;
-}
-
-/* static */ void
-EmbedPasswordMgr::Shutdown()
-{
-  NS_IF_RELEASE(sDecoderRing);
-  NS_IF_RELEASE(sPMBundle);
-  NS_IF_RELEASE(sPasswordManager);
-}
-
-// nsIPasswordManager implementation
-NS_IMETHODIMP
-EmbedPasswordMgr::AddUser(const nsACString& aHost,
-                          const nsAString& aUser,
-                          const nsAString& aPassword)
-{
-  // Silently ignore an empty username/password entry.
-  // There's no point in taking up space in the signon file with this.
-  if (aUser.IsEmpty() && aPassword.IsEmpty())
-    return NS_OK;
-  // Check for an existing entry for this host + user
-  if (!aHost.IsEmpty()) {
-    SignonHashEntry *hashEnt;
-    if (mSignonTable.Get(aHost, &hashEnt)) {
-      nsString empty;
-      SignonDataEntry *entry = nsnull;
-      FindPasswordEntryInternal(hashEnt->head, aUser, empty, empty, &entry);
-      if (entry) {
-        // Just change the password
-        return EncryptDataUCS2(aPassword, entry->passValue);
-      }
-    }
-  }
-  SignonDataEntry* entry = new SignonDataEntry();
-  if (NS_FAILED(EncryptDataUCS2(aUser, entry->userValue)) ||
-      NS_FAILED(EncryptDataUCS2(aPassword, entry->passValue))) {
-    delete entry;
-    return NS_ERROR_FAILURE;
-  }
-  AddSignonData(aHost, entry);
-  WritePasswords(mSignonFile);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::InsertLogin(const char* username, const char* password)
-{
-  if (username && mGlobalUserField)
-    mGlobalUserField->SetValue(NS_ConvertUTF8toUTF16(username));
-  else
-    return NS_ERROR_FAILURE;
-
-  if (password && mGlobalPassField)
-    mGlobalPassField->SetValue(NS_ConvertUTF8toUTF16(password));
-  else
-    FillPassword();
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::RemovePasswordsByIndex(PRUint32 aIndex)
-{
-  nsCOMPtr<nsIPasswordManager> passwordManager = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
-  if (!passwordManager)
-    return NS_ERROR_NULL_POINTER;
-  nsCOMPtr<nsIIDNService> idnService(do_GetService("@mozilla.org/network/idn-service;1"));
-  if (!idnService)
-    return NS_ERROR_NULL_POINTER;
-  nsCOMPtr<nsISimpleEnumerator> passwordEnumerator;
-  nsresult rv = passwordManager->GetEnumerator(getter_AddRefs(passwordEnumerator));
-  if (NS_FAILED(rv))
-    return rv;
-  PRBool enumResult;
-  PRUint32 i = 0;
-  nsCOMPtr<nsIPassword> nsPassword;
-  for (passwordEnumerator->HasMoreElements(&enumResult);
-       enumResult == PR_TRUE && i <= aIndex;
-       passwordEnumerator->HasMoreElements(&enumResult)) {
-
-    rv = passwordEnumerator->GetNext(getter_AddRefs(nsPassword));
-    if (NS_FAILED(rv) || !nsPassword)
-      return rv;
-
-    nsCString host;
-    nsPassword->GetHost(host);
-
-    if (StringBeginsWith(host, mLastHostQuery))
-      i++;
-  }
-
-  // if we found the right object to delete
-  if (nsPassword) {
-
-    nsCString host, idn_host;
-    nsString unicodeName;
-
-    nsPassword->GetHost(host);
-    nsPassword->GetUser(unicodeName);
-    rv = idnService->ConvertUTF8toACE(host, idn_host);
-
-    rv = passwordManager->RemoveUser(idn_host, unicodeName);
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::RemovePasswords(const char *aHostName, const char *aUserName)
-{
-  nsCOMPtr<nsIPasswordManager> passwordManager = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
-  if (!passwordManager)
-    return NS_ERROR_NULL_POINTER;
-  nsCOMPtr<nsIIDNService> idnService(do_GetService("@mozilla.org/network/idn-service;1"));
-  if (!idnService)
-    return NS_ERROR_NULL_POINTER;
-  nsCOMPtr<nsISimpleEnumerator> passwordEnumerator;
-  nsresult rv = passwordManager->GetEnumerator(getter_AddRefs(passwordEnumerator));
-  if (NS_FAILED(rv))
-    return rv;
-  PRBool enumResult;
-  for (passwordEnumerator->HasMoreElements(&enumResult);
-       enumResult;
-       passwordEnumerator->HasMoreElements(&enumResult)) {
-    nsCOMPtr<nsIPassword> nsPassword;
-    rv = passwordEnumerator->GetNext(getter_AddRefs(nsPassword));
-    /* XXX XXX FALSE = NS_OK this is almost certainly wrong */
-    if (NS_FAILED(rv)) return FALSE;
-    nsCString host, idn_host;
-
-    nsPassword->GetHost(host);
-    nsString unicodeName;
-    nsPassword->GetUser(unicodeName);
-    rv = idnService->ConvertUTF8toACE(host, idn_host);
-    rv = passwordManager->RemoveUser(idn_host, unicodeName);
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::RemoveUser(const nsACString& aHost, const nsAString& aUser)
-{
-  SignonDataEntry* entry, *prevEntry = nsnull;
-  SignonHashEntry* hashEnt;
-  if (!mSignonTable.Get(aHost, &hashEnt))
-    return NS_ERROR_FAILURE;
-  for (entry = hashEnt->head; entry; prevEntry = entry, entry = entry->next) {
-    nsAutoString ptUser;
-    if (!entry->userValue.IsEmpty() &&
-        NS_FAILED(DecryptData(entry->userValue, ptUser)))
-      break;
-    if (ptUser.Equals(aUser)) {
-      if (prevEntry)
-        prevEntry->next = entry->next;
-      else
-        hashEnt->head = entry->next;
-      entry->next = nsnull;
-      delete entry;
-      if (!hashEnt->head)
-        mSignonTable.Remove(aHost);  // deletes hashEnt
-      WritePasswords(mSignonFile);
-      return NS_OK;
-    }
-  }
-  return NS_ERROR_FAILURE;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::AddReject(const nsACString& aHost)
-{
-  mRejectTable.Put(aHost, 1);
-  WritePasswords(mSignonFile);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::RemoveReject(const nsACString& aHost)
-{
-  mRejectTable.Remove(aHost);
-  WritePasswords(mSignonFile);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::IsEqualToLastHostQuery(nsCString& aHost)
-{
-  return StringBeginsWith(aHost, mLastHostQuery);
-}
-
-/* static */ PLDHashOperator PR_CALLBACK
-EmbedPasswordMgr::BuildArrayEnumerator(const nsACString& aKey,
-                                       SignonHashEntry* aEntry,
-                                       void* aUserData)
-{
-  nsIMutableArray* array = static_cast<nsIMutableArray*>(aUserData);
-  for (SignonDataEntry* e = aEntry->head; e; e = e->next)
-    array->AppendElement(new PasswordEntry(aKey, e), PR_FALSE);
-  return PL_DHASH_NEXT;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::GetEnumerator(nsISimpleEnumerator** aEnumerator)
-{
-  // Build an array out of the hashtable
-  nsCOMPtr<nsIMutableArray> signonArray =
-    do_CreateInstance(NS_ARRAY_CONTRACTID);
-  NS_ENSURE_STATE(signonArray);
-  mSignonTable.EnumerateRead(BuildArrayEnumerator, signonArray);
-  return signonArray->Enumerate(aEnumerator);
-}
-
-/* static */ PLDHashOperator PR_CALLBACK
-EmbedPasswordMgr::BuildRejectArrayEnumerator(const nsACString& aKey,
-                                             PRInt32 aEntry,
-                                             void* aUserData)
-{
-  nsIMutableArray* array = static_cast<nsIMutableArray*>(aUserData);
-  nsCOMPtr<nsIPassword> passwordEntry = new PasswordEntry(aKey, nsnull);
-  //  if (!passwordEntry) {
-  //    // XXX handle oom
-  //  }
-  array->AppendElement(passwordEntry, PR_FALSE);
-  return PL_DHASH_NEXT;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::GetRejectEnumerator(nsISimpleEnumerator** aEnumerator)
-{
-  // Build an array out of the hashtable
-  nsCOMPtr<nsIMutableArray> rejectArray =
-    do_CreateInstance(NS_ARRAY_CONTRACTID);
-  NS_ENSURE_STATE(rejectArray);
-  mRejectTable.EnumerateRead(BuildRejectArrayEnumerator, rejectArray);
-  return rejectArray->Enumerate(aEnumerator);
-}
-
-// nsIPasswordManagerInternal implementation
-struct findEntryContext {EmbedPasswordMgr* manager;
-  const nsACString& hostURI;
-  const nsAString&  username;
-  const nsAString&  password;
-  nsACString& hostURIFound;
-  nsAString&  usernameFound;
-  nsAString&  passwordFound;
-  PRBool matched;
-
-  findEntryContext(EmbedPasswordMgr* aManager,
-                   const nsACString& aHostURI,
-                   const nsAString&  aUsername,
-                   const nsAString&  aPassword,
-                   nsACString& aHostURIFound,
-                   nsAString&  aUsernameFound,
-                   nsAString&  aPasswordFound)
-    : manager(aManager), hostURI(aHostURI), username(aUsername),
-    password(aPassword), hostURIFound(aHostURIFound),
-    usernameFound(aUsernameFound), passwordFound(aPasswordFound),
-    matched(PR_FALSE) {}
-};
-
-/* static */
-PLDHashOperator PR_CALLBACK
-EmbedPasswordMgr::FindEntryEnumerator(const nsACString& aKey,
-                                      SignonHashEntry* aEntry,
-                                      void* aUserData)
-{
-  findEntryContext* context = static_cast<findEntryContext*>(aUserData);
-  EmbedPasswordMgr* manager = context->manager;
-  nsresult rv;
-  SignonDataEntry* entry = nsnull;
-  rv = manager->FindPasswordEntryInternal(aEntry->head,
-                                          context->username,
-                                          context->password,
-                                          EmptyString(),
-                                          &entry);
-  if (NS_SUCCEEDED(rv) && entry) {
-    if (NS_SUCCEEDED(DecryptData(entry->userValue, context->usernameFound)) &&
-        NS_SUCCEEDED(DecryptData(entry->passValue, context->passwordFound))) {
-      context->matched = PR_TRUE;
-      context->hostURIFound.Assign(context->hostURI);
-    }
-    /* XXX The logic here doesn't make sense, but the author
-     * returned STOP instead of NEXT, so ...
-     */
-    return PL_DHASH_STOP;
-  }
-  return PL_DHASH_NEXT;
-}
-
-
-NS_IMETHODIMP
-EmbedPasswordMgr::FindPasswordEntry(const nsACString& aHostURI,
-                                    const nsAString&  aUsername,
-                                    const nsAString&  aPassword,
-                                    nsACString& aHostURIFound,
-                                    nsAString&  aUsernameFound,
-                                    nsAString&  aPasswordFound)
-{
-  if (!aHostURI.IsEmpty()) {
-    SignonHashEntry* hashEnt;
-    if (mSignonTable.Get(aHostURI, &hashEnt)) {
-      SignonDataEntry* entry;
-      nsresult rv =
-        FindPasswordEntryInternal(hashEnt->head,
-                                  aUsername,
-                                  aPassword,
-                                  EmptyString(),
-                                  &entry);
-      if (NS_SUCCEEDED(rv) && entry) {
-        if (NS_SUCCEEDED(DecryptData(entry->userValue, aUsernameFound)) &&
-            NS_SUCCEEDED(DecryptData(entry->passValue, aPasswordFound))) {
-          aHostURIFound.Assign(aHostURI);
-        } else {
-          return NS_ERROR_FAILURE;
-        }
-      }
-      return rv;
-    }
-    return NS_ERROR_FAILURE;
-  }
-  // No host given, so enumerate all entries in the hashtable
-  findEntryContext context(this, aHostURI, aUsername, aPassword,
-                           aHostURIFound, aUsernameFound, aPasswordFound);
-  mSignonTable.EnumerateRead(FindEntryEnumerator, &context);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::AddUserFull(const nsACString& aKey,
-                              const nsAString& aUser,
-                              const nsAString& aPassword,
-                              const nsAString& aUserFieldName,
-                              const nsAString& aPassFieldName)
-{
-  // Silently ignore an empty username/password entry.
-  // There's no point in taking up space in the signon file with this.
-  if (aUser.IsEmpty() && aPassword.IsEmpty())
-    return NS_OK;
-  // Check for an existing entry for this host + user
-  if (!aKey.IsEmpty()) {
-    SignonHashEntry *hashEnt;
-    if (mSignonTable.Get(aKey, &hashEnt)) {
-      nsString empty;
-      SignonDataEntry *entry = nsnull;
-      FindPasswordEntryInternal(hashEnt->head, aUser, empty, empty, &entry);
-      if (entry) {
-        // Just change the password
-        EncryptDataUCS2(aPassword, entry->passValue);
-        // ... and update the field names...s
-        entry->userField.Assign(aUserFieldName);
-        entry->passField.Assign(aPassFieldName);
-        return NS_OK;
-      }
-    }
-  }
-  SignonDataEntry* entry = new SignonDataEntry();
-  //  if (!entry) {
-  //    // XXX handle oom
-  //  }
-  entry->userField.Assign(aUserFieldName);
-  entry->passField.Assign(aPassFieldName);
-  EncryptDataUCS2(aUser, entry->userValue);
-  EncryptDataUCS2(aPassword, entry->passValue);
-  AddSignonData(aKey, entry);
-  WritePasswords(mSignonFile);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::ReadPasswords(nsIFile* aPasswordFile)
-{
-  nsCOMPtr<nsIInputStream> fileStream;
-  NS_NewLocalFileInputStream(getter_AddRefs(fileStream), aPasswordFile);
-  if (!fileStream)
-    return NS_ERROR_OUT_OF_MEMORY;
-  nsCOMPtr<nsILineInputStream> lineStream = do_QueryInterface(fileStream);
-  NS_ASSERTION(lineStream, "File stream is not an nsILineInputStream");
-  // Read the header
-  nsCAutoString utf8Buffer;
-  PRBool moreData = PR_FALSE;
-  nsresult rv = lineStream->ReadLine(utf8Buffer, &moreData);
-  if (NS_FAILED(rv))
-    return NS_OK;
-  if (!utf8Buffer.Equals("#2c")) {
-    NS_ERROR("Unexpected version header in signon file");
-    return NS_OK;
-  }
-  enum {
-    STATE_REJECT,
-    STATE_REALM,
-    STATE_USERFIELD,
-    STATE_USERVALUE,
-    STATE_PASSFIELD,
-    STATE_PASSVALUE
-  } state = STATE_REJECT;
-  nsCAutoString realm;
-  SignonDataEntry* entry = nsnull;
-  PRBool writeOnFinish = PR_FALSE;
-  do {
-    rv = lineStream->ReadLine(utf8Buffer, &moreData);
-    if (NS_FAILED(rv))
-      return NS_OK;
-    switch (state) {
-    case STATE_REJECT:
-      if (utf8Buffer.Equals(NS_LITERAL_CSTRING(".")))
-        state = STATE_REALM;
-      else
-        mRejectTable.Put(utf8Buffer, 1);
-      break;
-    case STATE_REALM:
-      realm.Assign(utf8Buffer);
-      state = STATE_USERFIELD;
-      break;
-    case STATE_USERFIELD:
-      // Commit any completed entry
-      if (entry) {
-        // Weed out empty username+password entries from corrupted signon files
-        if (entry->userValue.IsEmpty() && entry->passValue.IsEmpty()) {
-          NS_WARNING("Discarding empty password entry");
-          writeOnFinish = PR_TRUE; // so we won't get this on the next startup
-          delete entry;
-        } else {
-          AddSignonData(realm, entry);
-        }
-      }
-      // If the line is a ., we've reached the end of this realm's entries.
-      if (utf8Buffer.Equals(NS_LITERAL_CSTRING("."))) {
-        entry = nsnull;
-        state = STATE_REALM;
-      } else {
-        entry = new SignonDataEntry();
-        if (!entry) {
-          /* XXX handle oom */
-        }
-        CopyUTF8toUTF16(utf8Buffer, entry->userField);
-        state = STATE_USERVALUE;
-      }
-      break;
-    case STATE_USERVALUE:
-      NS_ASSERTION(entry, "bad state");
-      CopyUTF8toUTF16(utf8Buffer, entry->userValue);
-      state = STATE_PASSFIELD;
-      break;
-    case STATE_PASSFIELD:
-      NS_ASSERTION(entry, "bad state");
-      // Strip off the leading "*" character
-      CopyUTF8toUTF16(Substring(utf8Buffer, 1, utf8Buffer.Length() - 1),
-                      entry->passField);
-      state = STATE_PASSVALUE;
-      break;
-    case STATE_PASSVALUE:
-      NS_ASSERTION(entry, "bad state");
-      CopyUTF8toUTF16(utf8Buffer, entry->passValue);
-      state = STATE_USERFIELD;
-      break;
-    }
-  } while (moreData);
-  // Don't leak if the file ended unexpectedly
-  delete entry;
-  if (writeOnFinish) {
-    fileStream->Close();
-    WritePasswords(mSignonFile);
-  }
-  return NS_OK;
-}
-
-// nsIObserver implementation
-NS_IMETHODIMP
-EmbedPasswordMgr::Observe(nsISupports* aSubject,
-                          const char* aTopic,
-                          const PRUnichar* aData)
-{
-  if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
-    nsCOMPtr<nsIPrefBranch> branch = do_QueryInterface(aSubject);
-    NS_ASSERTION(branch == mPrefBranch, "unexpected pref change notification");
-    branch->GetBoolPref("rememberSignons", &sRememberPasswords);
-  }
-  return NS_OK;
-}
-
-// nsIWebProgressListener implementation
-NS_IMETHODIMP
-EmbedPasswordMgr::OnStateChange(nsIWebProgress* aWebProgress,
-                                nsIRequest* aRequest,
-                                PRUint32 aStateFlags,
-                                nsresult aStatus)
-{
-  // We're only interested in successful document loads.
-  if (NS_FAILED(aStatus) ||
-      !(aStateFlags & nsIWebProgressListener::STATE_IS_DOCUMENT) ||
-      !(aStateFlags & nsIWebProgressListener::STATE_STOP))
-    return NS_OK;
-  // Don't do anything if the global signon pref is disabled
-  if (!SingleSignonEnabled())
-    return NS_OK;
-  nsCOMPtr<nsIDOMWindow> domWin;
-  nsresult rv = aWebProgress->GetDOMWindow(getter_AddRefs(domWin));
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!mCommonObject)
-    mCommonObject = EmbedCommon::GetInstance();
-  nsCOMPtr<nsIDOMDocument> domDoc;
-  domWin->GetDocument(getter_AddRefs(domDoc));
-  NS_ASSERTION(domDoc, "DOM window should always have a document!");
-  // For now, only prefill forms in HTML documents.
-  nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(domDoc);
-  if (!htmlDoc)
-    return NS_OK;
-  nsCOMPtr<nsIDOMHTMLCollection> forms;
-  htmlDoc->GetForms(getter_AddRefs(forms));
-  nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
-  nsCAutoString realm;
-  if (!GetPasswordRealm(doc->GetDocumentURI(), realm))
-    return NS_OK;
-
-  mLastHostQuery.Assign(realm);
-
-  SignonHashEntry* hashEnt;
-  if (!mSignonTable.Get(realm, &hashEnt))
-    return NS_OK;
-  PRUint32 formCount;
-  forms->GetLength(&formCount);
-  // check to see if we should formfill.  failure is non-fatal
-  PRBool prefillForm = PR_TRUE;
-  mPrefBranch->GetBoolPref("autofillForms", &prefillForm);
-
-  // We can auto-prefill the username and password if there is only
-  // one stored login that matches the username and password field names
-  // on the form in question.  Note that we only need to worry about a
-  // single login per form.
-#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
-  for (PRUint32 i = 0; i < formCount; ++i) {
-    nsCOMPtr<nsIDOMNode> formNode;
-    forms->Item(i, getter_AddRefs(formNode));
-    nsCOMPtr<nsIForm> form = do_QueryInterface(formNode);
-    SignonDataEntry* firstMatch = nsnull;
-    PRBool attachedToInput = PR_FALSE;
-    PRBool prefilledUser = PR_FALSE;
-    nsCOMPtr<nsIDOMHTMLInputElement> userField, passField;
-    nsCOMPtr<nsIDOMHTMLInputElement> temp;
-    nsAutoString fieldType;
-    for (SignonDataEntry* e = hashEnt->head; e; e = e->next) {
-      nsCOMPtr<nsISupports> foundNode;
-      if (!(e->userField).IsEmpty()) {
-        form->ResolveName(e->userField, getter_AddRefs(foundNode));
-        temp = do_QueryInterface(foundNode);
-      }
-      nsAutoString oldUserValue;
-      if (temp) {
-        temp->GetType(fieldType);
-        if (!fieldType.Equals(NS_LITERAL_STRING("text")))
-          continue;
-        temp->GetValue(oldUserValue);
-        userField = temp;
-      }
-      if (!(e->passField).IsEmpty()) {
-        form->ResolveName(e->passField, getter_AddRefs(foundNode));
-        temp = do_QueryInterface(foundNode);
-      } else if (userField) {
-        // No password field name was supplied, try to locate one in the form,
-        // but only if we have a username field.
-        nsCOMPtr<nsIFormControl> fc(do_QueryInterface(foundNode));
-        PRInt32 index = -1;
-        form->IndexOfControl(fc, &index);
-        if (index >= 0) {
-          PRUint32 count;
-          form->GetElementCount(&count);
-          PRUint32 i;
-          temp = nsnull;
-          // Search forwards
-          nsCOMPtr<nsIFormControl> passField;
-          for (i = index + 1; i < count; ++i) {
-            form->GetElementAt(i, getter_AddRefs(passField));
-            if (passField && passField->GetType() == NS_FORM_INPUT_PASSWORD) {
-              foundNode = passField;
-              temp = do_QueryInterface(foundNode);
-            }
-          }
-          if (!temp && index != 0) {
-            // Search backwards
-            i = index;
-            do {
-              form->GetElementAt(i, getter_AddRefs(passField));
-              if (passField && passField->GetType() == NS_FORM_INPUT_PASSWORD) {
-                foundNode = passField;
-                temp = do_QueryInterface(foundNode);
-              }
-            } while (i-- != 0);
-          }
-        }
-      }
-      nsAutoString oldPassValue;
-      if (temp) {
-        temp->GetType(fieldType);
-        if (!fieldType.Equals(NS_LITERAL_STRING("password")))
-          continue;
-        temp->GetValue(oldPassValue);
-        passField = temp;
-      } else {
-        continue;
-      }
-      if (!oldUserValue.IsEmpty() && prefillForm) {
-        // The page has prefilled a username.
-        // If it matches any of our saved usernames, prefill the password
-        // for that username.  If there are multiple saved usernames,
-        // we will also attach the autocomplete listener.
-        prefilledUser = PR_TRUE;
-        nsAutoString userValue;
-        if (NS_FAILED(DecryptData(e->userValue, userValue)))
-          goto done;
-        if (userValue.Equals(oldUserValue)) {
-          nsAutoString passValue;
-          if (NS_FAILED(DecryptData(e->passValue, passValue)))
-            goto done;
-          passField->SetValue(passValue);
-        }
-      }
-      if (firstMatch && userField && !attachedToInput) {
-        // We've found more than one possible signon for this form.
-        // Listen for blur and autocomplete events on the username field so
-        // that we can attempt to prefill the password after the user has
-        // entered the username.
-        mFormAttachCount = true;
-        AttachToInput(userField);
-        attachedToInput = PR_TRUE;
-      } else {
-        firstMatch = e;
-      }
-    }
-    // If we found more than one match, attachedToInput will be true,
-    // but if we found just one, we need to attach the autocomplete listener,
-    // and fill in the username and password  only if the HTML didn't prefill
-    // the username.
-    if (firstMatch && !attachedToInput) {
-      if (userField) {
-        AttachToInput(userField);
-      }
-      if (!prefilledUser && prefillForm) {
-        nsAutoString buffer;
-        if (userField) {
-          if (NS_FAILED(DecryptData(firstMatch->userValue, buffer)))
-            goto done;
-          userField->SetValue(buffer);
-        }
-        if (NS_FAILED(DecryptData(firstMatch->passValue, buffer)))
-          goto done;
-        passField->SetValue(buffer);
-      } else {
-
-        nsString buffer;
-        if (userField) {
-          if (NS_FAILED(DecryptData(firstMatch->userValue, buffer)))
-            goto done;
-        }
-
-        if (!prefilledUser) {
-          GList * logins = nsnull;
-          NS_ConvertUTF16toUTF8 login(buffer);
-          logins = g_list_append(logins, login.BeginWriting());
-          gint retval = -1;
-          gtk_signal_emit(GTK_OBJECT(mCommonObject->mCommon),
-                          moz_embed_common_signals[COMMON_SELECT_LOGIN],
-                          logins, &retval);
-
-          g_list_free(logins);
-
-          if (retval != -1) {
-            userField->SetValue(buffer);
-            if (NS_FAILED(DecryptData(firstMatch->passValue, buffer)))
-              goto done;
-            passField->SetValue(buffer);
-          }
-        }
-      }
-    }
-    mGlobalUserField = userField;
-    mGlobalPassField = passField;
-  }
-#endif
-done:
-  nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(domDoc);
-  targ->AddEventListener(
-      NS_LITERAL_STRING("unload"),
-      static_cast<nsIDOMLoadListener*>(this),
-      PR_FALSE);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::OnProgressChange(nsIWebProgress* aWebProgress,
-                                   nsIRequest* aRequest,
-                                   PRInt32 aCurSelfProgress,
-                                   PRInt32 aMaxSelfProgress,
-                                   PRInt32 aCurTotalProgress,
-                                   PRInt32 aMaxTotalProgress)
-{
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::OnLocationChange(nsIWebProgress* aWebProgress,
-                                   nsIRequest* aRequest,
-                                   nsIURI* aLocation)
-{
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::OnStatusChange(nsIWebProgress* aWebProgress,
-                                 nsIRequest* aRequest,
-                                 nsresult aStatus,
-                                 const PRUnichar* aMessage)
-{
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::OnSecurityChange(nsIWebProgress* aWebProgress,
-                                   nsIRequest* aRequest,
-                                   PRUint32 aState)
-{
-  return NS_OK;
-}
-
-// nsIFormSubmitObserver implementation
-NS_IMETHODIMP
-EmbedPasswordMgr::Notify(nsIDOMHTMLFormElement* aDOMForm,
-                         nsIDOMWindowInternal* aWindow,
-                         nsIURI* aActionURL,
-                         PRBool* aCancelSubmit)
-{
-  nsCOMPtr<nsIContent> formNode = do_QueryInterface(aDOMForm);
-
-  // This function must never return a failure code or the form submit
-  // will be cancelled.
-  NS_ENSURE_TRUE(aWindow, NS_OK);
-  // Don't do anything if the global signon pref is disabled
-  if (!SingleSignonEnabled())
-    return NS_OK;
-  // Check the reject list
-  nsCAutoString realm;
-  // XXX bug 281125: GetDocument() could sometimes be null here, hinting
-  // XXX at a problem with document teardown while a modal dialog is posted.
-  if (!GetPasswordRealm(formNode->GetOwnerDoc()->GetDocumentURI(), realm))
-    return NS_OK;
-  PRInt32 rejectValue;
-  if (mRejectTable.Get(realm, &rejectValue)) {
-    // The user has opted to never save passwords for this site.
-    return NS_OK;
-  }
-#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
-  nsCOMPtr<nsIForm> formElement = do_QueryInterface(formNode);
-  PRUint32 numControls;
-  formElement->GetElementCount(&numControls);
-  // Count the number of password fields in the form.
-  nsCOMPtr<nsIDOMHTMLInputElement> userField;
-  nsCOMArray<nsIDOMHTMLInputElement> passFields;
-  PRUint32 i, firstPasswordIndex = numControls;
-  for (i = 0; i < numControls; ++i) {
-    nsCOMPtr<nsIFormControl> control;
-    formElement->GetElementAt(i, getter_AddRefs(control));
-    PRInt32 ctype = control->GetType();
-    if (ctype == NS_FORM_INPUT_PASSWORD) {
-      nsCOMPtr<nsIDOMHTMLInputElement> elem = do_QueryInterface(control);
-      passFields.AppendObject(elem);
-      if (firstPasswordIndex == numControls)
-        firstPasswordIndex = i;
-    }
-  }
-  nsCOMPtr<nsIPrompt> prompt;
-  aWindow->GetPrompter(getter_AddRefs(prompt));
-  switch (passFields.Count()) {
-  case 1:  // normal login
-    {
-      // Search backwards from the password field to find a username field.
-      for (PRInt32 j = (PRInt32) firstPasswordIndex - 1; j >= 0; --j) {
-        nsCOMPtr<nsIFormControl> control;
-        formElement->GetElementAt(j, getter_AddRefs(control));
-        if (control->GetType() == NS_FORM_INPUT_TEXT) {
-          userField = do_QueryInterface(control);
-          break;
-        }
-      }
-      // If the username field or the form has autocomplete=off,
-      // we don't store the login
-      if (!sForceAutocompletion) {
-        nsString autocomplete;
-        if (userField) {
-          nsCOMPtr<nsIDOMElement> userFieldElement = do_QueryInterface(userField);
-          userFieldElement->GetAttribute(NS_LITERAL_STRING("autocomplete"),
-                                         autocomplete);
-          if (autocomplete.LowerCaseEqualsLiteral("off"))
-            return NS_OK;
-        }
-        aDOMForm->GetAttribute(NS_LITERAL_STRING("autocomplete"), autocomplete);
-        if (autocomplete.LowerCaseEqualsLiteral("off"))
-            return NS_OK;
-        nsCOMPtr<nsIDOMElement> passFieldElement = do_QueryInterface(passFields.ObjectAt(0));
-        passFieldElement->GetAttribute(NS_LITERAL_STRING("autocomplete"), autocomplete);
-        if (autocomplete.LowerCaseEqualsLiteral("off"))
-          return NS_OK;
-      }
-      // Check whether this signon is already stored.
-      // Note that we don't prompt the user if only the password doesn't match;
-      // we instead just silently change the stored password.
-      nsAutoString userValue, passValue, userFieldName, passFieldName;
-      if (userField) {
-        userField->GetValue(userValue);
-        userField->GetName(userFieldName);
-      }
-      passFields.ObjectAt(0)->GetValue(passValue);
-      passFields.ObjectAt(0)->GetName(passFieldName);
-      // If the password is empty, there is no reason to store this login.
-      if (passValue.IsEmpty())
-        return NS_OK;
-      SignonHashEntry* hashEnt;
-      if (mSignonTable.Get(realm, &hashEnt)) {
-        SignonDataEntry* entry;
-        nsAutoString buffer;
-        for (entry = hashEnt->head; entry; entry = entry->next) {
-          if (entry->userField.Equals(userFieldName) &&
-              entry->passField.Equals(passFieldName)) {
-            if (NS_FAILED(DecryptData(entry->userValue, buffer)))
-              return NS_OK;
-            if (buffer.Equals(userValue)) {
-              if (NS_FAILED(DecryptData(entry->passValue, buffer)))
-                return NS_OK;
-              if (!buffer.Equals(passValue)) {
-                if (NS_FAILED(EncryptDataUCS2(passValue, entry->passValue)))
-                  return NS_OK;
-                WritePasswords(mSignonFile);
-              }
-              return NS_OK;
-            }
-          }
-        }
-      }
-      nsresult rv;
-      nsCOMPtr<nsIStringBundleService> bundleService =
-        do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
-      nsCOMPtr<nsIStringBundle> brandBundle;
-      rv = bundleService->CreateBundle("chrome://branding/locale/brand.properties",
-                                       getter_AddRefs(brandBundle));
-      NS_ENSURE_SUCCESS(rv, rv);
-      nsString brandShortName;
-      rv = brandBundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
-                                          getter_Copies(brandShortName));
-      NS_ENSURE_SUCCESS(rv, rv);
-      const PRUnichar* formatArgs[1] = {
-          brandShortName.get()
-      };
-      nsAutoString dialogText;
-      GetLocalizedString(NS_LITERAL_STRING("savePasswordText"),
-                         dialogText,
-                         PR_TRUE,
-                         formatArgs,
-                         1);
-      nsAutoString dialogTitle, neverButtonText, rememberButtonText,
-                   notNowButtonText;
-      GetLocalizedString(NS_LITERAL_STRING("savePasswordTitle"), dialogTitle);
-      GetLocalizedString(NS_LITERAL_STRING("neverForSiteButtonText"),
-                         neverButtonText);
-      GetLocalizedString(NS_LITERAL_STRING("rememberButtonText"),
-                         rememberButtonText);
-      GetLocalizedString(NS_LITERAL_STRING("notNowButtonText"),
-                         notNowButtonText);
-      PRInt32 selection;
-      nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aWindow));
-      GtkWidget *parentWidget = GetGtkWidgetForDOMWindow(domWindow);
-      if (parentWidget)
-        gtk_signal_emit(GTK_OBJECT(GTK_MOZ_EMBED(parentWidget)->common),
-                        moz_embed_common_signals[COMMON_REMEMBER_LOGIN], &selection);
-      // FIXME These values (0,1,2,3,4) need constant variable.
-      if (selection == GTK_MOZ_EMBED_LOGIN_REMEMBER_FOR_THIS_SITE ) {
-        SignonDataEntry* entry = new SignonDataEntry();
-        entry->userField.Assign(userFieldName);
-        entry->passField.Assign(passFieldName);
-        if (NS_FAILED(EncryptDataUCS2(userValue, entry->userValue)) ||
-            NS_FAILED(EncryptDataUCS2(passValue, entry->passValue))) {
-          delete entry;
-          return NS_OK;
-        }
-        AddSignonData(realm, entry);
-        WritePasswords(mSignonFile);
-      } else if (selection == GTK_MOZ_EMBED_LOGIN_REMEMBER_FOR_THIS_SERVER ) {
-        SignonDataEntry* entry = new SignonDataEntry();
-
-        entry->userField.Assign(userFieldName);
-        entry->passField.Assign(passFieldName);
-        if (NS_FAILED(EncryptDataUCS2(userValue, entry->userValue)) ||
-            NS_FAILED(EncryptDataUCS2(passValue, entry->passValue))) {
-          delete entry;
-          return NS_OK;
-        }
-        AddSignonData(realm, entry);
-        WritePasswords(mSignonFile);
-      } else if (selection == GTK_MOZ_EMBED_LOGIN_NOT_NOW) {
-        // cancel button was pressed.
-      } else if (selection == GTK_MOZ_EMBED_LOGIN_NEVER_FOR_SITE || selection == GTK_MOZ_EMBED_LOGIN_NEVER_FOR_SERVER) {
-        AddReject(realm);
-      }
-    }
-    break;
-  case 2:
-  case 3: {
-            // If the following conditions are true, we guess that this is a
-            // password change page:
-            //   - there are 2 or 3 password fields on the page
-            //   - the fields do not all have the same value
-            //   - there is already a stored login for this realm
-            //
-            // In this situation, prompt the user to confirm that this is a password
-            // change.
-            SignonDataEntry* changeEntry = nsnull;
-            nsAutoString value0, valueN;
-            passFields.ObjectAt(0)->GetValue(value0);
-            for (PRInt32 k = 1; k < passFields.Count(); ++k) {
-              passFields.ObjectAt(k)->GetValue(valueN);
-              if (!value0.Equals(valueN)) {
-                SignonHashEntry* hashEnt;
-                if (mSignonTable.Get(realm, &hashEnt)) {
-                  SignonDataEntry* entry = hashEnt->head;
-                  if (entry->next) {
-                    // Multiple stored logons, prompt for which username is
-                    // being changed.
-                    PRUint32 entryCount = 2;
-                    SignonDataEntry* temp = entry->next;
-                    while (temp->next) {
-                      ++entryCount;
-                      temp = temp->next;
-                    }
-                    nsAutoString* ptUsernames = new nsAutoString[entryCount];
-                    const PRUnichar** formatArgs = new const PRUnichar*[entryCount];
-                    temp = entry;
-                    for (PRUint32 arg = 0; arg < entryCount; ++arg) {
-                      if (NS_FAILED(DecryptData(temp->userValue, ptUsernames[arg]))) {
-                        delete [] formatArgs;
-                        delete [] ptUsernames;
-                        return NS_OK;
-                      }
-                      formatArgs[arg] = ptUsernames[arg].get();
-                      temp = temp->next;
-                    }
-                    nsAutoString dialogTitle, dialogText;
-                    GetLocalizedString(NS_LITERAL_STRING("passwordChangeTitle"),
-                                       dialogTitle);
-                    GetLocalizedString(NS_LITERAL_STRING("userSelectText"),
-                                       dialogText);
-                    PRInt32 selection;
-                    PRBool confirm;
-                    prompt->Select(dialogTitle.get(),
-                                   dialogText.get(),
-                                   entryCount,
-                                   formatArgs,
-                                   &selection,
-                                   &confirm);
-                    delete[] formatArgs;
-                    delete[] ptUsernames;
-                    if (confirm && selection >= 0) {
-                      changeEntry = entry;
-                      for (PRInt32 m = 0; m < selection; ++m)
-                        changeEntry = changeEntry->next;
-                    }
-                  } else {
-                    nsAutoString dialogTitle, dialogText, ptUser;
-                    if (NS_FAILED(DecryptData(entry->userValue, ptUser)))
-                      return NS_OK;
-
-                    const PRUnichar* formatArgs[1] = {
-                      ptUser.get()
-                    };
-                    GetLocalizedString(NS_LITERAL_STRING("passwordChangeTitle"),
-                                       dialogTitle);
-                    GetLocalizedString(NS_LITERAL_STRING("passwordChangeText"),
-                                       dialogText,
-                                       PR_TRUE,
-                                       formatArgs,
-                                       1);
-                    PRInt32 selection;
-                    prompt->ConfirmEx(dialogTitle.get(), dialogText.get(),
-                                      nsIPrompt::STD_YES_NO_BUTTONS,
-                                      nsnull, nsnull, nsnull, nsnull, nsnull,
-                                      &selection);
-                    if (selection == 0)
-                      changeEntry = entry;
-                  }
-                }
-                break;
-              }
-            }
-            if (changeEntry) {
-              nsAutoString newValue;
-              passFields.ObjectAt(1)->GetValue(newValue);
-              if (NS_FAILED(EncryptDataUCS2(newValue, changeEntry->passValue)))
-                return NS_OK;
-              WritePasswords(mSignonFile);
-            }
-          }
-          break;
-  default:  // no passwords or something odd; be safe and just don't store anything
-          break;
-  }
-#endif // FIXED_BUG347731 || MOZ_ENABLE_LIBXUL
-  return NS_OK;
-}
-
-// nsIDOMFocusListener implementation
-NS_IMETHODIMP
-EmbedPasswordMgr::Focus(nsIDOMEvent* aEvent)
-{
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::Blur(nsIDOMEvent* aEvent)
-{
-  return FillPassword(aEvent);
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::HandleEvent(nsIDOMEvent* aEvent)
-{
-  return FillPassword(aEvent);
-}
-
-// nsIPromptFactory implementation
-
-NS_IMETHODIMP
-EmbedPasswordMgr::GetPrompt(nsIDOMWindow* aParent,
-                            const nsIID& aIID,
-                            void** _retval)
-{
-  if (!aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
-    NS_WARNING("asked for unknown IID");
-    return NS_NOINTERFACE;
-  }
-
-  // NOTE: It is important to return the specific return value here. The
-  // caller cares.
-  nsresult rv;
-  nsCOMPtr<nsIPromptService2> service =
-    do_GetService(NS_PROMPTSERVICE_CONTRACTID, &rv);
-  if (NS_FAILED(rv))
-    return rv;
-
-  EmbedSignonPrompt2* wrapper = new EmbedSignonPrompt2(service, aParent);
-  if (!wrapper)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  NS_ADDREF(wrapper);
-  *_retval = static_cast<nsIAuthPrompt2*>(wrapper);
-  return NS_OK;
-}
-
-
-// nsIDOMLoadListener implementation
-NS_IMETHODIMP
-EmbedPasswordMgr::Load(nsIDOMEvent* aEvent)
-{
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::BeforeUnload(nsIDOMEvent* aEvent)
-{
-  return NS_OK;
-}
-
-/* static */ PLDHashOperator PR_CALLBACK
-EmbedPasswordMgr::RemoveForDOMDocumentEnumerator(nsISupports* aKey,
-                                                 PRInt32& aEntry,
-                                                 void* aUserData)
-{
-  nsIDOMDocument* domDoc = static_cast<nsIDOMDocument*>(aUserData);
-  nsCOMPtr<nsIDOMHTMLInputElement> element = do_QueryInterface(aKey);
-  nsCOMPtr<nsIDOMDocument> elementDoc;
-  element->GetOwnerDocument(getter_AddRefs(elementDoc));
-  if (elementDoc == domDoc)
-    return PL_DHASH_REMOVE;
-  return PL_DHASH_NEXT;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::Unload(nsIDOMEvent* aEvent)
-{
-  nsCOMPtr<nsIDOMEventTarget> target;
-  aEvent->GetTarget(getter_AddRefs(target));
-  nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(target);
-  if (domDoc)
-    mAutoCompleteInputs.Enumerate(RemoveForDOMDocumentEnumerator, domDoc);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::Abort(nsIDOMEvent* aEvent)
-{
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedPasswordMgr::Error(nsIDOMEvent* aEvent)
-{
-  return NS_OK;
-}
-
-/* static */ PLDHashOperator PR_CALLBACK
-EmbedPasswordMgr::WriteRejectEntryEnumerator(const nsACString& aKey,
-                                             PRInt32 aEntry,
-                                             void* aUserData)
-{
-  nsIOutputStream* stream = static_cast<nsIOutputStream*>(aUserData);
-  PRUint32 bytesWritten;
-  nsCAutoString buffer(aKey);
-  buffer.Append(NS_LINEBREAK);
-  stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-  return PL_DHASH_NEXT;
-}
-
-/* static */ PLDHashOperator PR_CALLBACK
-EmbedPasswordMgr::WriteSignonEntryEnumerator(const nsACString& aKey,
-                                             SignonHashEntry* aEntry,
-                                             void* aUserData)
-{
-  nsIOutputStream* stream = static_cast<nsIOutputStream*>(aUserData);
-  PRUint32 bytesWritten;
-  nsCAutoString buffer(aKey);
-  buffer.Append(NS_LINEBREAK);
-  stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-  for (SignonDataEntry* e = aEntry->head; e; e = e->next) {
-    NS_ConvertUTF16toUTF8 userField(e->userField);
-    userField.Append(NS_LINEBREAK);
-    stream->Write(userField.get(), userField.Length(), &bytesWritten);
-    buffer.Assign(NS_ConvertUTF16toUTF8(e->userValue));
-    buffer.Append(NS_LINEBREAK);
-    stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-    buffer.Assign("*");
-    buffer.Append(NS_ConvertUTF16toUTF8(e->passField));
-    buffer.Append(NS_LINEBREAK);
-    stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-    buffer.Assign(NS_ConvertUTF16toUTF8(e->passValue));
-    buffer.Append(NS_LINEBREAK);
-    stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-  }
-  buffer.Assign("." NS_LINEBREAK);
-  stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-  return PL_DHASH_NEXT;
-}
-
-void
-EmbedPasswordMgr::WritePasswords(nsIFile* aPasswordFile)
-{
-  nsCOMPtr<nsIOutputStream> fileStream;
-  NS_NewLocalFileOutputStream(
-      getter_AddRefs(fileStream),
-      aPasswordFile,
-      -1,
-      0600,
-      0);
-  if (!fileStream)
-    return;
-  PRUint32 bytesWritten;
-  // File header
-  nsCAutoString buffer("#2c" NS_LINEBREAK);
-  fileStream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-  // Write out the reject list.
-  mRejectTable.EnumerateRead(WriteRejectEntryEnumerator, fileStream);
-  buffer.Assign("." NS_LINEBREAK);
-  fileStream->Write(buffer.get(), buffer.Length(), &bytesWritten);
-  // Write out the signon data.
-  mSignonTable.EnumerateRead(WriteSignonEntryEnumerator, fileStream);
-}
-
-void
-EmbedPasswordMgr::AddSignonData(const nsACString& aRealm,
-                                SignonDataEntry* aEntry)
-{
-  // See if there is already an entry for this URL
-  SignonHashEntry* hashEnt;
-  if (mSignonTable.Get(aRealm, &hashEnt)) {
-    // Add this one at the front of the linked list
-    aEntry->next = hashEnt->head;
-    hashEnt->head = aEntry;
-  } else {
-    /* XXX this is bad, you shouldn't stick nulls -OOM- into hashtables */
-    mSignonTable.Put(aRealm, new SignonHashEntry(aEntry));
-  }
-}
-
-/* static */ nsresult
-EmbedPasswordMgr::DecryptData(const nsAString& aData,
-                              nsAString& aPlaintext)
-{
-  NS_ConvertUTF16toUTF8 flatData(aData);
-  char* buffer = nsnull;
-  if (flatData.CharAt(0) == '~') {
-    // This is a base64-encoded string. Strip off the ~ prefix.
-    PRUint32 srcLength = flatData.Length() - 1;
-    if (!(buffer = PL_Base64Decode(&(flatData.get())[1], srcLength, NULL)))
-      return NS_ERROR_FAILURE;
-  } else {
-    // This is encrypted using nsISecretDecoderRing.
-    EnsureDecoderRing();
-    if (!sDecoderRing) {
-      NS_WARNING("Unable to get decoder ring service");
-      return NS_ERROR_FAILURE;
-    }
-    if (NS_FAILED(sDecoderRing->DecryptString(flatData.get(), &buffer)))
-      return NS_ERROR_FAILURE;
-  }
-  aPlaintext.Assign(NS_ConvertUTF8toUTF16(buffer));
-  /* sdr::descryptstring is a proper xpcom creature, it uses nsmemory */
-  NS_Free(buffer);
-  return NS_OK;
-}
-
-// Note that nsISecretDecoderRing encryption uses a pseudo-random salt value,
-// so it's not possible to test equality of two strings by comparing their
-// ciphertexts.  We need to decrypt both strings and compare the plaintext.
-/* static */ nsresult
-EmbedPasswordMgr::EncryptData(const nsAString& aPlaintext,
-                              nsACString& aEncrypted)
-{
-  EnsureDecoderRing();
-  NS_ENSURE_TRUE(sDecoderRing, NS_ERROR_FAILURE);
-  char* buffer;
-  if (NS_FAILED(sDecoderRing->EncryptString(NS_ConvertUTF16toUTF8(aPlaintext).get(), &buffer)))
-    return NS_ERROR_FAILURE;
-  aEncrypted.Assign(buffer);
-  /* XXX [not our fault] we intentionally leak here because SDR is so buggy that we could
-   * only corrupt the heap if we tried to do something about it. Bug 359209
-   */
-  NS_Free(buffer);
-  return NS_OK;
-}
-
-/* static */ nsresult
-EmbedPasswordMgr::EncryptDataUCS2(const nsAString& aPlaintext,
-                                  nsAString& aEncrypted)
-{
-  nsCAutoString buffer;
-  nsresult rv = EncryptData(aPlaintext, buffer);
-  NS_ENSURE_SUCCESS(rv, rv);
-  aEncrypted.Assign(NS_ConvertUTF8toUTF16(buffer));
-  return NS_OK;
-}
-
-/* static */ void
-EmbedPasswordMgr::EnsureDecoderRing()
-{
-  if (!sDecoderRing) {
-    CallGetService("@mozilla.org/security/sdr;1", &sDecoderRing);
-    // Ensure that the master password (internal key) has been initialized.
-    // If not, set a default empty master password.
-    nsCOMPtr<nsIPK11TokenDB> tokenDB = do_GetService(NS_PK11TOKENDB_CONTRACTID);
-    if (!tokenDB)
-      return;
-    nsCOMPtr<nsIPK11Token> token;
-    tokenDB->GetInternalKeyToken(getter_AddRefs(token));
-    PRBool needUserInit = PR_FALSE;
-    token->GetNeedsUserInit(&needUserInit);
-    if (needUserInit)
-      token->InitPassword(EmptyString().get());
-  }
-}
-
-nsresult
-EmbedPasswordMgr::FindPasswordEntryInternal(const SignonDataEntry* aEntry,
-                                            const nsAString&  aUser,
-                                            const nsAString&  aPassword,
-                                            const nsAString&  aUserField,
-                                            SignonDataEntry** aResult)
-{
-  // host has already been checked, so just look for user/password match.
-  const SignonDataEntry* entry = aEntry;
-  nsAutoString buffer;
-  for (; entry; entry = entry->next) {
-    PRBool matched;
-    if (aUser.IsEmpty()) {
-      matched = PR_TRUE;
-    } else {
-      if (NS_FAILED(DecryptData(entry->userValue, buffer))) {
-        *aResult = nsnull;
-        return NS_ERROR_FAILURE;
-      }
-      matched = aUser.Equals(buffer);
-    }
-    if (!matched)
-      continue;
-    if (aPassword.IsEmpty()) {
-      matched = PR_TRUE;
-    } else {
-      if (NS_FAILED(DecryptData(entry->passValue, buffer))) {
-        *aResult = nsnull;
-        return NS_ERROR_FAILURE;
-      }
-      matched = aPassword.Equals(buffer);
-    }
-    if (!matched)
-      continue;
-    if (aUserField.IsEmpty())
-      matched = PR_TRUE;
-    else
-      matched = entry->userField.Equals(aUserField);
-    if (matched)
-      break;
-  }
-  if (entry) {
-    *aResult = const_cast<SignonDataEntry*>(entry);
-    return NS_OK;
-  }
-  *aResult = nsnull;
-  return NS_ERROR_FAILURE;
-}
-
-nsresult
-EmbedPasswordMgr::FillPassword(nsIDOMEvent* aEvent)
-{
-  // Try to prefill the password for the just-changed username.
-  nsCOMPtr<nsIDOMHTMLInputElement> userField;
-  if (aEvent) {
-    nsCOMPtr<nsIDOMEventTarget> target;
-    aEvent->GetTarget(getter_AddRefs(target));
-    userField = do_QueryInterface(target);
-  } else {
-    userField = mGlobalUserField;
-  }
-  if (!userField || userField == mAutoCompletingField)
-    return NS_OK;
-  nsCOMPtr<nsIContent> fieldContent = do_QueryInterface(userField);
-  // The document may be null during teardown, for example as Windows
-  // sends a blur event as a native widget is destroyed.
-  nsIDocument *doc = fieldContent->GetDocument();
-  if (!doc)
-    return NS_OK;
-  nsCAutoString realm;
-  if (!GetPasswordRealm(doc->GetDocumentURI(), realm))
-    return NS_OK;
-  nsAutoString userValue;
-  userField->GetValue(userValue);
-  if (userValue.IsEmpty())
-    return NS_OK;
-  nsAutoString fieldName;
-  userField->GetName(fieldName);
-  SignonHashEntry* hashEnt;
-  if (!mSignonTable.Get(realm, &hashEnt))
-    return NS_OK;
-  SignonDataEntry* foundEntry;
-  FindPasswordEntryInternal(hashEnt->head, userValue, EmptyString(),
-                            fieldName, &foundEntry);
-  if (!foundEntry)
-    return NS_OK;
-  nsCOMPtr<nsIDOMHTMLFormElement> formEl;
-  userField->GetForm(getter_AddRefs(formEl));
-  if (!formEl)
-    return NS_OK;
-#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
-  nsCOMPtr<nsIForm> form = do_QueryInterface(formEl);
-  nsCOMPtr<nsISupports> foundNode;
-  form->ResolveName(foundEntry->passField, getter_AddRefs(foundNode));
-  nsCOMPtr<nsIDOMHTMLInputElement> passField = do_QueryInterface(foundNode);
-  if (!passField)
-    return NS_OK;
-  nsAutoString passValue;
-  if (NS_SUCCEEDED(DecryptData(foundEntry->passValue, passValue)))
-    passField->SetValue(passValue);
-#endif
-  return NS_OK;
-}
-
-void
-EmbedPasswordMgr::AttachToInput(nsIDOMHTMLInputElement* aElement)
-{
-  nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(aElement);
-  nsIDOMEventListener* listener = static_cast<nsIDOMFocusListener*>(this);
-  targ->AddEventListener(NS_LITERAL_STRING("blur"), listener, PR_FALSE);
-  targ->AddEventListener(NS_LITERAL_STRING("DOMAutoComplete"), listener, PR_FALSE);
-  mAutoCompleteInputs.Put(aElement, 1);
-}
-
-PRBool
-EmbedPasswordMgr::GetPasswordRealm(nsIURI* aURI, nsACString& aRealm)
-{
-  // Note: this _is_ different from getting the uri's prePath!
-  // We don't want to include a username or password that's part of the
-  // URL in the host key... it will cause lookups to work incorrectly, and will
-  // also cause usernames and passwords to be stored in cleartext.
-  nsCAutoString buffer;
-  aURI->GetScheme(buffer);
-  aRealm.Append(buffer);
-  aRealm.Append(NS_LITERAL_CSTRING("://"));
-  aURI->GetHostPort(buffer);
-  if (buffer.IsEmpty()) {
-    // The scheme does not support hostnames, so don't attempt to save/restore
-    // any signon data. (see bug 159484)
-    return PR_FALSE;
-  }
-  aRealm.Append(buffer);
-  return PR_TRUE;
-}
-
-/* static */ void
-EmbedPasswordMgr::GetLocalizedString(const nsAString& key,
-                                     nsAString& aResult,
-                                     PRBool aIsFormatted,
-                                     const PRUnichar** aFormatArgs,
-                                     PRUint32 aFormatArgsLength)
-{
-  if (!sPMBundle) {
-    nsCOMPtr<nsIStringBundleService> bundleService = do_GetService(NS_STRINGBUNDLE_CONTRACTID);
-    bundleService->CreateBundle(kPMPropertiesURL,
-                                &sPMBundle);
-    if (!sPMBundle) {
-      NS_ERROR("string bundle not present");
-      return;
-    }
-  }
-  nsString str;
-  if (aIsFormatted)
-    sPMBundle->FormatStringFromName(PromiseFlatString(key).get(),
-                                    aFormatArgs, aFormatArgsLength,
-                                    getter_Copies(str));
-  else
-    sPMBundle->GetStringFromName(PromiseFlatString(key).get(),
-                                 getter_Copies(str));
-  aResult.Assign(str);
-}
-
-NS_IMPL_ISUPPORTS2(EmbedSignonPrompt,
-                   nsIAuthPromptWrapper,
-                   nsIAuthPrompt)
-
-// nsIAuthPrompt
-NS_IMETHODIMP
-EmbedSignonPrompt::Prompt(const PRUnichar* aDialogTitle,
-                          const PRUnichar* aText,
-                          const PRUnichar* aPasswordRealm,
-                          PRUint32 aSavePassword,
-                          const PRUnichar* aDefaultText,
-                          PRUnichar** aResult,
-                          PRBool* aConfirm)
-{
-  nsAutoString checkMsg;
-  nsString emptyString;
-  PRBool checkValue = PR_FALSE;
-  PRBool *checkPtr = nsnull;
-  PRUnichar* value = nsnull;
-  nsCOMPtr<nsIPasswordManagerInternal> mgrInternal;
-  if (EmbedPasswordMgr::SingleSignonEnabled() && aPasswordRealm) {
-    if (aSavePassword == SAVE_PASSWORD_PERMANENTLY) {
-      EmbedPasswordMgr::GetLocalizedString(NS_LITERAL_STRING("rememberValue"),
-                                           checkMsg);
-      checkPtr = &checkValue;
-    }
-    mgrInternal = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
-    nsCAutoString outHost;
-    nsAutoString outUser, outPassword;
-    mgrInternal->FindPasswordEntry(NS_ConvertUTF16toUTF8(aPasswordRealm),
-                                   emptyString,
-                                   emptyString,
-                                   outHost,
-                                   outUser,
-                                   outPassword);
-    if (!outUser.IsEmpty()) {
-      value = ToNewUnicode(outUser);
-      checkValue = PR_TRUE;
-    }
-  }
-  if (!value && aDefaultText)
-    value = ToNewUnicode(nsDependentString(aDefaultText));
-    mPrompt->Prompt(aDialogTitle,
-                  aText,
-                  &value,
-                  checkMsg.get(),
-                  checkPtr,
-                  aConfirm);
-  if (*aConfirm) {
-    if (checkValue && value && value[0] != '\0') {
-      // The user requested that we save the value
-      // TODO: support SAVE_PASSWORD_FOR_SESSION
-      nsCOMPtr<nsIPasswordManager> manager = do_QueryInterface(mgrInternal);
-      manager->AddUser(NS_ConvertUTF16toUTF8(aPasswordRealm),
-                       nsDependentString(value),
-                       emptyString);
-    }
-    *aResult = value;
-  } else {
-    if (value)
-      nsMemory::Free(value);
-    *aResult = nsnull;
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedSignonPrompt::PromptUsernameAndPassword(const PRUnichar* aDialogTitle,
-                                             const PRUnichar* aText,
-                                             const PRUnichar* aPasswordRealm,
-                                             PRUint32 aSavePassword,
-                                             PRUnichar** aUser,
-                                             PRUnichar** aPassword,
-                                             PRBool* aConfirm)
-{
-  nsAutoString checkMsg;
-  nsString emptyString;
-  PRBool checkValue = PR_FALSE;
-  PRBool *checkPtr = nsnull;
-  PRUnichar *user = nsnull, *password = nsnull;
-  nsCOMPtr<nsIPasswordManagerInternal> mgrInternal;
-  if (EmbedPasswordMgr::SingleSignonEnabled() && aPasswordRealm) {
-    if (aSavePassword == SAVE_PASSWORD_PERMANENTLY) {
-      EmbedPasswordMgr::GetLocalizedString(NS_LITERAL_STRING("rememberPassword"),
-                                           checkMsg);
-      checkPtr = &checkValue;
-    }
-    mgrInternal = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
-    nsCAutoString outHost;
-    nsAutoString outUser, outPassword;
-    mgrInternal->FindPasswordEntry(NS_ConvertUTF16toUTF8(aPasswordRealm),
-                                   emptyString,
-                                   emptyString,
-                                   outHost,
-                                   outUser,
-                                   outPassword);
-    user = ToNewUnicode(outUser);
-    password = ToNewUnicode(outPassword);
-    if (!outUser.IsEmpty() || !outPassword.IsEmpty())
-      checkValue = PR_TRUE;
-  }
-  mPrompt->PromptUsernameAndPassword(aPasswordRealm,
-                                     aText,
-                                     &user,
-                                     &password,
-                                     checkMsg.get(),
-                                     checkPtr,
-                                     aConfirm);
-  if (*aConfirm) {
-    if (checkValue && user && password && (user[0] != '\0' || password[0] != '\0')) {
-      // The user requested that we save the values
-      // TODO: support SAVE_PASSWORD_FOR_SESSION
-      nsCOMPtr<nsIPasswordManager> manager = do_QueryInterface(mgrInternal);
-      manager->AddUser(NS_ConvertUTF16toUTF8(aPasswordRealm),
-                       nsDependentString(user),
-                       nsDependentString(password));
-    }
-    *aUser = user;
-    *aPassword = password;
-  } else {
-    if (user)
-      nsMemory::Free(user);
-    if (password)
-      nsMemory::Free(password);
-    *aUser = *aPassword = nsnull;
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedSignonPrompt::PromptPassword(const PRUnichar* aDialogTitle,
-                                  const PRUnichar* aText,
-                                  const PRUnichar* aPasswordRealm,
-                                  PRUint32 aSavePassword,
-                                  PRUnichar** aPassword,
-                                  PRBool* aConfirm)
-{
-  nsAutoString checkMsg;
-  nsString emptyString;
-  PRBool checkValue = PR_FALSE;
-  PRBool *checkPtr = nsnull;
-  PRUnichar* password = nsnull;
-  nsCOMPtr<nsIPasswordManagerInternal> mgrInternal;
-  if (EmbedPasswordMgr::SingleSignonEnabled() && aPasswordRealm) {
-    if (aSavePassword == SAVE_PASSWORD_PERMANENTLY) {
-      EmbedPasswordMgr::GetLocalizedString(NS_LITERAL_STRING("rememberPassword"),
-                                           checkMsg);
-      checkPtr = &checkValue;
-    }
-    mgrInternal = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
-    nsCAutoString outHost;
-    nsAutoString outUser, outPassword;
-    mgrInternal->FindPasswordEntry(NS_ConvertUTF16toUTF8(aPasswordRealm),
-                                   emptyString,
-                                   emptyString,
-                                   outHost,
-                                   outUser,
-                                   outPassword);
-    password = ToNewUnicode(outPassword);
-    if (!outPassword.IsEmpty())
-      checkValue = PR_TRUE;
-  }
-  mPrompt->PromptPassword(aDialogTitle,
-                          aText,
-                          &password,
-                          checkMsg.get(),
-                          checkPtr,
-                          aConfirm);
-  if (*aConfirm) {
-    if (checkValue && password && password[0] != '\0') {
-      // The user requested that we save the password
-      // TODO: support SAVE_PASSWORD_FOR_SESSION
-      nsCOMPtr<nsIPasswordManager> manager = do_QueryInterface(mgrInternal);
-      manager->AddUser(NS_ConvertUTF16toUTF8(aPasswordRealm),
-                       emptyString,
-                       nsDependentString(password));
-    }
-    *aPassword = password;
-  } else {
-    if (password)
-      nsMemory::Free(password);
-    *aPassword = nsnull;
-  }
-  return NS_OK;
-}
-
-// nsIAuthPromptWrapper
-NS_IMETHODIMP
-EmbedSignonPrompt::SetPromptDialogs(nsIPrompt* aDialogs)
-{
-  mPrompt = aDialogs;
-  return NS_OK;
-}
-
-// ---------------------------------------------------------------------
-// EmbedSignonPrompt2
-
-EmbedSignonPrompt2::EmbedSignonPrompt2(nsIPromptService2* aService,
-                                       nsIDOMWindow* aParent)
-: mService(aService), mParent(aParent)
-{
-}
-
-EmbedSignonPrompt2::~EmbedSignonPrompt2()
-{
-}
-
-NS_IMPL_ISUPPORTS1(EmbedSignonPrompt2, nsIAuthPrompt2)
-
-// nsIAuthPrompt2
-
-NS_IMETHODIMP
-EmbedSignonPrompt2::PromptAuth(nsIChannel* aChannel,
-                               PRUint32 aLevel,
-                               nsIAuthInformation* aAuthInfo,
-                               PRBool* aConfirm)
-{
-  nsCAutoString key;
-#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
-  NS_GetAuthKey(aChannel, aAuthInfo, key);
-#endif
-
-  nsAutoString checkMsg;
-  PRBool checkValue = PR_FALSE;
-  PRBool *checkPtr = nsnull;
-  nsCOMPtr<nsIPasswordManagerInternal> mgrInternal;
-
-  if (EmbedPasswordMgr::SingleSignonEnabled()) {
-    EmbedPasswordMgr::GetLocalizedString(NS_LITERAL_STRING("rememberPassword"),
-                                         checkMsg);
-    checkPtr = &checkValue;
-
-    mgrInternal = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
-    nsCAutoString outHost;
-    nsAutoString outUser, outPassword;
-
-    const nsString& emptyString = EmptyString();
-    mgrInternal->FindPasswordEntry(key,
-                                   emptyString,
-                                   emptyString,
-                                   outHost,
-                                   outUser,
-                                   outPassword);
-
-#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
-    NS_SetAuthInfo(aAuthInfo, outUser, outPassword);
-#endif
-
-    if (!outUser.IsEmpty() || !outPassword.IsEmpty())
-      checkValue = PR_TRUE;
-  }
-
-  mService->PromptAuth(mParent, aChannel, aLevel, aAuthInfo,
-                       checkMsg.get(), checkPtr, aConfirm);
-
-  if (*aConfirm) {
-    // XXX domain
-    nsAutoString user, password;
-    aAuthInfo->GetUsername(user);
-    aAuthInfo->GetPassword(password);
-    if (checkValue && (!user.IsEmpty() || !password.IsEmpty())) {
-      // The user requested that we save the password
-
-      nsCOMPtr<nsIPasswordManager> manager = do_QueryInterface(mgrInternal);
-
-      manager->AddUser(key, user, password);
-    }
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-EmbedSignonPrompt2::AsyncPromptAuth(nsIChannel*,
-                                    nsIAuthPromptCallback*,
-                                    nsISupports*,
-                                    PRUint32,
-                                    nsIAuthInformation*,
-                                    nsICancelable**)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-
Index: mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPasswordMgr.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 tw=80 et cindent: */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is Mozilla Password Manager.
- *
- * The Initial Developer of the Original Code is
- * Brian Ryner.
- * Portions created by the Initial Developer are Copyright (C) 2003
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *  Brian Ryner <bryner@brianryner.com>
- *  Changes: romaxa@gmail.com (from original:  mozilla/toolkit/components/passwordmgr/base/nsPasswordManager.h)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "nsCPasswordManager.h"
-#include "nsClassHashtable.h"
-#include "nsDataHashtable.h"
-#include "nsCOMPtr.h"
-#include "nsIObserver.h"
-#include "nsWeakReference.h"
-#include "nsIFormSubmitObserver.h"
-#include "nsIWebProgressListener.h"
-#include "nsIDOMFocusListener.h"
-#include "nsIDOMLoadListener.h"
-#include "nsIStringBundle.h"
-#include "nsIPrefBranch.h"
-#include "nsIPromptFactory.h"
-#include "nsIAuthPromptWrapper.h"
-#include "nsCOMPtr.h"
-#include "nsIPrompt.h"
-#include "nsIAuthPrompt2.h"
-#include "EmbedPrivate.h"
-
-#define EMBED_PASSWORDMANAGER_DESCRIPTION "MicroB PSM Dialog Impl"
-/* 360565c4-2ef3-4f6a-bab9-94cca891b2a7 */
-#define EMBED_PASSWORDMANAGER_CID \
-{0x360565c4, 0x2ef3, 0x4f6a, {0xba, 0xb9, 0x94, 0xcc, 0xa8, 0x91, 0xb2, 0xa7}}
-
-class nsIFile;
-class nsIStringBundle;
-class nsIComponentManager;
-class nsIContent;
-class nsIDOMWindowInternal;
-class nsIURI;
-class nsIDOMHTMLInputElement;
-class nsIDOMWindow;
-class nsIPromptService2;
-
-struct nsModuleComponentInfo;
-
-class EmbedPasswordMgr : public nsIPasswordManager,
-                         public nsIPasswordManagerInternal,
-                         public nsIObserver,
-                         public nsIFormSubmitObserver,
-                         public nsIWebProgressListener,
-                         public nsIDOMFocusListener,
-                         public nsIPromptFactory,
-                         public nsIDOMLoadListener,
-                         public nsSupportsWeakReference
-{
-public:
-  class SignonDataEntry;
-  class SignonHashEntry;
-  class PasswordEntry;
-  EmbedPasswordMgr();
-  virtual ~EmbedPasswordMgr();
-  static EmbedPasswordMgr* GetInstance();
-  static EmbedPasswordMgr* GetInstance(EmbedPrivate *aOwner);
-  nsresult Init();
-  static PRBool SingleSignonEnabled();
-  static NS_METHOD Register(nsIComponentManager* aCompMgr,
-                            nsIFile* aPath,
-                            const char* aRegistryLocation,
-                            const char* aComponentType,
-                            const nsModuleComponentInfo* aInfo);
-  static NS_METHOD Unregister(nsIComponentManager* aCompMgr,
-                              nsIFile* aPath,
-                              const char* aRegistryLocation,
-                              const nsModuleComponentInfo* aInfo);
-  static void Shutdown();
-  static void GetLocalizedString(const nsAString& key,
-                                 nsAString& aResult,
-                                 PRBool aFormatted = PR_FALSE,
-                                 const PRUnichar** aFormatArgs = nsnull,
-                                 PRUint32 aFormatArgsLength = 0);
-  static nsresult DecryptData(const nsAString& aData, nsAString& aPlaintext);
-  static nsresult EncryptData(const nsAString& aPlaintext,
-                              nsACString& aEncrypted);
-  static nsresult EncryptDataUCS2(const nsAString& aPlaintext,
-                                  nsAString& aEncrypted);
-  nsresult InsertLogin(const char* username, const char* password = nsnull);
-  nsresult RemovePasswords(const char *aHostName, const char *aUserName);
-  nsresult RemovePasswordsByIndex(PRUint32 aIndex);
-  nsresult IsEqualToLastHostQuery(nsCString& aHost);
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIPASSWORDMANAGER
-  NS_DECL_NSIPASSWORDMANAGERINTERNAL
-  NS_DECL_NSIOBSERVER
-  NS_DECL_NSIWEBPROGRESSLISTENER
-  NS_DECL_NSIPROMPTFACTORY
-  // nsIFormSubmitObserver
-  NS_IMETHOD Notify(nsIDOMHTMLFormElement* aDOMForm,
-                    nsIDOMWindowInternal* aWindow,
-                    nsIURI* aActionURL,
-                    PRBool* aCancelSubmit);
-  // nsIDOMFocusListener
-  NS_IMETHOD Focus(nsIDOMEvent* aEvent);
-  NS_IMETHOD Blur(nsIDOMEvent* aEvent);
-  // nsIDOMEventListener
-  NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
-  // nsIDOMLoadListener
-  NS_IMETHOD Load(nsIDOMEvent* aEvent);
-  NS_IMETHOD Unload(nsIDOMEvent* aEvent);
-  NS_IMETHOD BeforeUnload(nsIDOMEvent* aEvent);
-  NS_IMETHOD Abort(nsIDOMEvent* aEvent);
-  NS_IMETHOD Error(nsIDOMEvent* aEvent);
-protected:
-  void WritePasswords(nsIFile* aPasswordFile);
-  void AddSignonData(const nsACString& aRealm, SignonDataEntry* aEntry);
-  nsresult FindPasswordEntryInternal(const SignonDataEntry* aEntry,
-                                     const nsAString&  aUser,
-                                     const nsAString&  aPassword,
-                                     const nsAString&  aUserField,
-                                     SignonDataEntry** aResult);
-  nsresult FillPassword(nsIDOMEvent* aEvent = nsnull);
-  void AttachToInput(nsIDOMHTMLInputElement* aElement);
-  PRBool GetPasswordRealm(nsIURI* aURI, nsACString& aRealm);
-  static PLDHashOperator PR_CALLBACK FindEntryEnumerator(const nsACString& aKey,
-                                                         SignonHashEntry* aEntry,
-                                                         void* aUserData);
-  static PLDHashOperator PR_CALLBACK WriteRejectEntryEnumerator(const nsACString& aKey,
-                                                                PRInt32 aEntry,
-                                                                void* aUserData);
-  static PLDHashOperator PR_CALLBACK WriteSignonEntryEnumerator(const nsACString& aKey,
-                                                                SignonHashEntry* aEntry,
-                                                                void* aUserData);
-  static PLDHashOperator PR_CALLBACK BuildArrayEnumerator(const nsACString& aKey,
-                                                          SignonHashEntry* aEntry,
-                                                          void* aUserData);
-  static PLDHashOperator PR_CALLBACK BuildRejectArrayEnumerator(const nsACString& aKey,
-                                                                PRInt32 aEntry,
-                                                                void* aUserData);
-  static PLDHashOperator PR_CALLBACK RemoveForDOMDocumentEnumerator(nsISupports* aKey,
-                                                                    PRInt32& aEntry,
-                                                                    void* aUserData);
-  static void EnsureDecoderRing();
-  nsClassHashtable<nsCStringHashKey,SignonHashEntry> mSignonTable;
-  nsDataHashtable<nsCStringHashKey,PRInt32> mRejectTable;
-  nsDataHashtable<nsISupportsHashKey,PRInt32> mAutoCompleteInputs;
-  nsCOMPtr<nsIFile> mSignonFile;
-  nsCOMPtr<nsIPrefBranch> mPrefBranch;
-  nsIDOMHTMLInputElement* mAutoCompletingField;
-  nsIDOMHTMLInputElement* mGlobalUserField;
-  nsIDOMHTMLInputElement* mGlobalPassField;
-  SignonHashEntry * mLastSignonHashEntry;
-  int lastIndex;
-  nsCAutoString mLastHostQuery;
-  EmbedCommon* mCommonObject;
-public:
-  PRBool mFormAttachCount;
-  //  nsAString mLastHostQuery;
-};
-
-/* 1baf3398-f759-4a72-a21f-0abdc9cc9960 */
-#define NS_SINGLE_SIGNON_PROMPT_CID \
-{0x1baf3398, 0xf759, 0x4a72, {0xa2, 0x1f, 0x0a, 0xbd, 0xc9, 0xcc, 0x99, 0x60}}
-
-// Our wrapper for username/password prompts - this allows us to prefill
-// the password dialog and add a "remember this password" checkbox.
-class EmbedSignonPrompt : public nsIAuthPromptWrapper
-{
-public:
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIAUTHPROMPT
-  NS_DECL_NSIAUTHPROMPTWRAPPER
-  EmbedSignonPrompt() {}
-  virtual ~EmbedSignonPrompt() {}
-protected:
-  void GetLocalizedString(const nsAString& aKey, nsAString& aResult);
-  nsCOMPtr<nsIPrompt> mPrompt;
-};
-
-// A wrapper for the newer nsIAuthPrompt2 interface
-// Its purpose is the same as nsSingleSignonPrompt, but wraps an nsIDOMWindow
-// instead of an nsIPrompt.
-
-class EmbedSignonPrompt2 : public nsIAuthPrompt2
-{
-public:
-  EmbedSignonPrompt2(nsIPromptService2* aService, nsIDOMWindow* aParent);
-
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIAUTHPROMPT2
-
-private:
-  ~EmbedSignonPrompt2();
-
-  nsCOMPtr<nsIPromptService2> mService;
-  nsCOMPtr<nsIDOMWindow> mParent;
-};
-
Index: mozilla/embedding/browser/gtk/src/EmbedPrivate.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPrivate.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -35,16 +35,17 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIDocShell.h"
 #include "nsIWebProgress.h"
 #include "nsIWidget.h"
+#include "nsIHTMLDocument.h"
 #include "nsCRT.h"
 #include "nsNetUtil.h"
 #include "nsIWebBrowserStream.h"
 #include "nsIHistoryEntry.h"
 #include "nsIWebBrowserFocus.h"
 #include "nsIDirectoryService.h"
 #include "nsAppDirectoryServiceDefs.h"
 
@@ -85,22 +86,18 @@
 // all of our local includes
 #include "EmbedPrivate.h"
 #include "EmbedWindow.h"
 #include "EmbedProgress.h"
 #include "EmbedContentListener.h"
 #include "EmbedEventListener.h"
 #include "EmbedWindowCreator.h"
 #include "GtkPromptService.h"
-#include "nsICookiePromptService.h"
 #include "EmbedCertificates.h"
 #include "EmbedDownloadMgr.h"
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-#include "EmbedPasswordMgr.h"
-#endif
 #include "EmbedGlobalHistory.h"
 #include "EmbedFilePicker.h"
 
 #ifdef MOZ_ACCESSIBILITY_ATK
 #include "nsIAccessibilityService.h"
 #include "nsIAccessible.h"
 #include "nsIDOMDocument.h"
 #endif
@@ -109,26 +106,44 @@
 #include "nsIDOMNSHTMLInputElement.h"
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMNSHTMLTextAreaElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMNSEditableElement.h"
 #include "nsIDOMNSDocument.h"
 #include "nsIEditingSession.h"
 #include "nsIEditor.h"
-#include "nsIHTMLEditor.h"
+#include "nsIPlaintextEditor.h"
 #include "nsEditorCID.h"
+#include "nsIDOMScreen.h"
 
 #include "nsEmbedCID.h"
+#include "nsWidgetsCID.h"
 
-//#include "nsICache.h"
 #include "nsICacheService.h"
 #include "nsICacheSession.h"
-//#include "nsICacheListener.h"
+
+#include "nsIDOMHTMLFrameElement.h"
+
+//Plugins
+#include "nsplugindefs.h"
+#include "nsIPluginInstance.h"
+#include "nsIDOMNodeList.h"
+#include "nsIPresShell.h"
+#include "nsIContent.h"
+#include "nsIObjectFrame.h"
+#include "nsIDOMHTMLIFrameElement.h"
+
+#include "nsIExtensionManager.h"
+#include "nsICommandLineRunner.h"
+#include "nsICommandManager.h"
+#include "nsIBadCertListener2.h"
+
 static NS_DEFINE_CID(kCacheServiceCID,           NS_CACHESERVICE_CID);
+static NS_DEFINE_CID(kAppShellCID,               NS_APPSHELL_CID);
 static nsICacheService* sCacheService;
 
 static EmbedCommon* sEmbedCommon = nsnull;
 
 /* static */
 EmbedCommon*
 EmbedCommon::GetInstance()
 {
@@ -169,16 +184,17 @@
 PRUint32     EmbedPrivate::sWidgetCount = 0;
 char        *EmbedPrivate::sPath        = nsnull;
 char        *EmbedPrivate::sCompPath    = nsnull;
 nsVoidArray *EmbedPrivate::sWindowList  = nsnull;
 nsILocalFile *EmbedPrivate::sProfileDir  = nsnull;
 nsISupports  *EmbedPrivate::sProfileLock = nsnull;
 GtkWidget   *EmbedPrivate::sOffscreenWindow = 0;
 GtkWidget   *EmbedPrivate::sOffscreenFixed  = 0;
+PRBool       EmbedPrivate::sTermEmbedding = PR_TRUE;
 
 nsIDirectoryServiceProvider *EmbedPrivate::sAppFileLocProvider = nsnull;
 
 GtkMozEmbed*
 EmbedCommon::GetAnyLiveWidget()
 {
   if (!EmbedPrivate::sWidgetCount || !EmbedPrivate::sWindowList)
     return nsnull;
@@ -187,22 +203,33 @@
   PRInt32 count = EmbedPrivate::sWindowList->Count();
   // This function doesn't get called very often at all (only when
   // creating a new window) so it's OK to walk the list of open
   // windows.
   //FIXME need to choose right window
   GtkMozEmbed *ret = nsnull;
   for (int i = 0; i < count; i++) {
     EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>
-                                          (EmbedPrivate::sWindowList->ElementAt(i));
+                                              (EmbedPrivate::sWindowList->ElementAt(i));
     ret = tmpPrivate->mOwningWidget;
   }
   return ret;
 }
 
+nsresult
+EmbedCommon::SuspendNative(PRBool aOn) {
+static PRBool suspended = PR_FALSE;
+   if (suspended == aOn)
+     return NS_OK;
+   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
+   NS_ENSURE_TRUE(appShell, NS_ERROR_FAILURE);
+   suspended = aOn;
+   return aOn?appShell->SuspendNative():appShell->ResumeNative();
+}
+
 class GTKEmbedDirectoryProvider : public nsIDirectoryServiceProvider2
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIDIRECTORYSERVICEPROVIDER
   NS_DECL_NSIDIRECTORYSERVICEPROVIDER2
 };
 
@@ -258,67 +285,48 @@
     return NS_ERROR_FAILURE;
 
   return dp2->GetFiles(aKey, aResult);
 }
 
 NS_GENERIC_FACTORY_CONSTRUCTOR(GtkPromptService)
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(EmbedCertificates, Init)
 NS_GENERIC_FACTORY_CONSTRUCTOR(EmbedDownloadMgr)
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(EmbedPasswordMgr, EmbedPasswordMgr::GetInstance)
-NS_GENERIC_FACTORY_CONSTRUCTOR(EmbedSignonPrompt)
-#endif
 NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(EmbedGlobalHistory, EmbedGlobalHistory::GetInstance)
 NS_GENERIC_FACTORY_CONSTRUCTOR(EmbedFilePicker)
 
 static const nsModuleComponentInfo defaultAppComps[] = {
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-  {
-    EMBED_PASSWORDMANAGER_DESCRIPTION,
-    EMBED_PASSWORDMANAGER_CID,
-    NS_PASSWORDMANAGER_CONTRACTID,
-    EmbedPasswordMgrConstructor,
-    EmbedPasswordMgr::Register,
-    EmbedPasswordMgr::Unregister
-  },
-  { EMBED_PASSWORDMANAGER_DESCRIPTION,
-    EMBED_PASSWORDMANAGER_CID,
-    NS_PWMGR_AUTHPROMPTFACTORY,
-    EmbedPasswordMgrConstructor,
-    EmbedPasswordMgr::Register,
-    EmbedPasswordMgr::Unregister},
-
-  {
-    EMBED_PASSWORDMANAGER_DESCRIPTION,
-    NS_SINGLE_SIGNON_PROMPT_CID,
-    "@mozilla.org/wallet/single-sign-on-prompt;1",
-    EmbedSignonPromptConstructor
-  },
-#endif
+#ifdef NECKO_COOKIES
   { "Prompt Service",
     NS_PROMPTSERVICE_CID,
     NS_COOKIEPROMPTSERVICE_CONTRACTID,
     GtkPromptServiceConstructor
   },
+#endif
   {
     "Prompt Service",
     NS_PROMPTSERVICE_CID,
     "@mozilla.org/embedcomp/prompt-service;1",
     GtkPromptServiceConstructor
   },
   {
     EMBED_CERTIFICATES_DESCRIPTION,
     EMBED_CERTIFICATES_CID,
     NS_TOKENPASSWORDSDIALOG_CONTRACTID,
     EmbedCertificatesConstructor
   },
   {
     EMBED_CERTIFICATES_DESCRIPTION,
     EMBED_CERTIFICATES_CID,
+    "@mozilla.org/nsBadCertListener2;1",
+    EmbedCertificatesConstructor
+  },
+  {
+    EMBED_CERTIFICATES_DESCRIPTION,
+    EMBED_CERTIFICATES_CID,
     NS_CERTIFICATEDIALOGS_CONTRACTID,
     EmbedCertificatesConstructor
   },
   {
     EMBED_CERTIFICATES_DESCRIPTION,
     EMBED_CERTIFICATES_CID,
     NS_CLIENTAUTHDIALOGS_CONTRACTID,
     EmbedCertificatesConstructor
@@ -383,20 +391,31 @@
   mChromeMask       = nsIWebBrowserChrome::CHROME_ALL;
   mIsChrome         = PR_FALSE;
   mChromeLoaded     = PR_FALSE;
   mLoadFinished     = PR_TRUE;
   mListenersAttached = PR_FALSE;
   mMozWindowWidget  = 0;
   mIsDestroyed      = PR_FALSE;
   mDoResizeEmbed    = PR_TRUE;
+  mCurVisibleHeight = 1000; // to disable this condition for first time
   mOpenBlock        = PR_FALSE;
   mNeedFav          = PR_TRUE;
+  mPluginSuspended  = PR_TRUE;
+  mIsUploading      = PR_FALSE;
+  mResizeControl    = PR_FALSE;
+
+  gboolean bval = TRUE;
+  // Probably VKB Resize control not required anymore, and we can drop it...
+  if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.resize_control", &bval) && bval)
+    mResizeControl  = PR_TRUE;
 
-  PushStartup();
+  sWidgetCount++;
+  if (sWidgetCount == 1)
+    PushStartup();
   if (!sWindowList) {
     sWindowList = new nsVoidArray();
   }
   sWindowList->AppendElement(this);
 }
 
 EmbedPrivate::~EmbedPrivate()
 {
@@ -421,17 +440,17 @@
   mWindowGuard = static_cast<nsIWebBrowserChrome *>(mWindow);
   mWindow->Init(this);
 
   // Create our progress listener object, make an owning reference,
   // and initialize it.  It is assumed that this progress listener
   // will be destroyed when we go out of scope.
   mProgress = new EmbedProgress();
   mProgressGuard = static_cast<nsIWebProgressListener *>
-                              (mProgress);
+               (mProgress);
   mProgress->Init(this);
 
   // Create our content listener object, initialize it and attach it.
   // It is assumed that this will be destroyed when we go out of
   // scope.
   mContentListener = new EmbedContentListener();
   mContentListenerGuard = NS_ISUPPORTS_CAST(nsIURIContentListener*, mContentListener);
   mContentListener->Init(this);
@@ -513,17 +532,17 @@
   webBrowser->SetParentURIContentListener(uriListener);
 
   // save the window id of the newly created window
   nsCOMPtr<nsIWidget> mozWidget;
   mWindow->mBaseWindow->GetMainWidget(getter_AddRefs(mozWidget));
   // get the native drawing area
   GdkWindow *tmp_window =
     static_cast<GdkWindow *>
-               (mozWidget->GetNativeData(NS_NATIVE_WINDOW));
+      (mozWidget->GetNativeData(NS_NATIVE_WINDOW));
   // and, thanks to superwin we actually need the parent of that.
   tmp_window = gdk_window_get_parent(tmp_window);
   // save the widget ID - it should be the mozarea of the window.
   gpointer data = nsnull;
   gdk_window_get_user_data(tmp_window, &data);
   mMozWindowWidget = static_cast<GtkWidget *>(data);
 
   // Apply the current chrome mask
@@ -548,69 +567,99 @@
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // and set the visibility on the thing
   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(webBrowser);
 
   // XXX hack around problem. probably widget/gtk2 window initialization.
   baseWindow->SetVisibility(PR_FALSE);
-
+  mWindow->mHidden = 0;
   baseWindow->SetVisibility(PR_TRUE);
 }
 
 void
 EmbedPrivate::Hide(void)
 {
   // Get the nsIWebBrowser object for our embedded window.
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // and set the visibility on the thing
   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(webBrowser);
   baseWindow->SetVisibility(PR_FALSE);
 }
 
-#include "nsIDOMScreen.h"
+#define VKB_HEIGHT 150
 void
 EmbedPrivate::Resize(PRUint32 aWidth, PRUint32 aHeight)
 {
-  PRInt32 sub   = 0;
-  PRInt32 diff  = 0;
+// TODO Should be moved in other place or extension
+  PRInt32 X, Y, W, H;
+  mWindow->GetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION | nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER, &X, &Y, &W, &H);
+  PRInt32 height_diff = ABS(H - aHeight);
 
-  if (mDoResizeEmbed){
+  //printf("EmbedPrivate::Resize: mResizeControl:%s\n", mResizeControl?"TRUE":"FALSE");
+  if (aWidth - W != 0 || !mResizeControl)
+  {
+    mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+                           nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+                           0, 0, aWidth, aHeight);
+  }
+  else if ((mDoResizeEmbed && height_diff != VKB_HEIGHT) || aHeight > H || aHeight > mCurVisibleHeight)
+  {
+     mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+                            nsIEmbeddingSiteWindow::DIM_FLAGS_VERTICAL |
+                            nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+                           0, 0, aWidth, aHeight);
+  }
+  else {
+    if (Y < 0) {
+      mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION, 0, 0, nsnull, nsnull);
+      return;
+    }
     EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-    gint x, y, width, height, depth;
-    gdk_window_get_geometry(gtk_widget_get_parent_window(GTK_WIDGET(mOwningWidget)),&x,&y,&width,&height,&depth);
-
-    if (ctx_menu) {
-      if (height < ctx_menu->mFormRect.y + ctx_menu->mFormRect.height) {
-        sub = ctx_menu->mFormRect.y - height + ctx_menu->mFormRect.height;
-        diff = height - aHeight;
+    if (!ctx_menu)
+      return;
+    gint y, height;
+    gdk_window_get_geometry(gtk_widget_get_parent_window(GTK_WIDGET(mOwningWidget)), NULL, &y, NULL, &height, NULL);
+    PRInt32 sub = height - aHeight;
+    gint screen_height = gdk_screen_height();
+    PRInt32 visible_form_height = ctx_menu->mFormRect.height;
+    if (screen_height - ctx_menu->mFormRect.y < ctx_menu->mFormRect.height)
+      visible_form_height = screen_height - ctx_menu->mFormRect.y;
+    if (ctx_menu && visible_form_height <= screen_height - y - height_diff - sub
+        && !(ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_RICHEDIT)
+        ) {
+      PRInt32 diff = height_diff + sub;
+      if (screen_height - diff <= ctx_menu->mFormRect.y + ctx_menu->mFormRect.height) {
+        if (ctx_menu->mFormRect.y - height_diff + y > 0)
+          mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION, 0, -height_diff, nsnull, nsnull);
       }
+    } else {
+      mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+                             nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+                             0, 0, aWidth, aHeight);
     }
   }
-
-  mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
-                          nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
-                          0, 0, aWidth, aHeight);
-
-  if (sub > 0 && diff >= 0){
-    SetScrollTop(sub + diff);
-  }
+  mCurVisibleHeight = aHeight;
+//  mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+//                         nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+//                         0, 0, aWidth, aHeight);
 }
 
 void
 EmbedPrivate::Destroy(void)
 {
   // This flag might have been set from
   // EmbedWindow::DestroyBrowserWindow() as well if someone used a
   // window.close() or something or some other script action to close
   // the window.  No harm setting it again.
-  mIsDestroyed = PR_TRUE;
+  // if (mIsDestroyed) // NB#65157 Browser crash on http://moto.allegro.pl/4056_volvo.html?order=t&view=gtext web page
+  //  return;
 
   // Get the nsIWebBrowser object for our embedded window.
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // Release our progress listener
   nsCOMPtr<nsISupportsWeakReference> supportsWeak;
   supportsWeak = do_QueryInterface(mProgressGuard);
@@ -631,29 +680,34 @@
   mProgressGuard = nsnull;
   mProgress = nsnull;
 
   // detach our event listeners and release the event receiver
   DetachListeners();
   if (mEventTarget)
     mEventTarget = nsnull;
 
+  mEventListenerGuard = nsnull;
+  mEventListener = nsnull;
+
   // destroy our child window
   mWindow->ReleaseChildren();
 
   // release navigation
   mNavigation = nsnull;
 
   // release session history
   mSessionHistory = nsnull;
 
   mOwningWidget = nsnull;
 
   mMozWindowWidget = 0;
   mNeedFav = PR_TRUE;
+  mIsDestroyed = PR_TRUE;
+  mPluginSuspended = PR_TRUE;
 }
 
 void
 EmbedPrivate::SetURI(const char *aURI)
 {
   mURI.Assign(NS_ConvertUTF8toUTF16(aURI));
 }
 
@@ -661,18 +715,20 @@
 EmbedPrivate::LoadCurrentURI(void)
 {
   if (!mURI.IsEmpty()) {
     nsCOMPtr<nsPIDOMWindow> piWin;
     GetPIDOMWindow(getter_AddRefs(piWin));
 
     nsAutoPopupStatePusher popupStatePusher(piWin, openAllowed);
 
+    mWindow->mHidden = 1;
     mNavigation->LoadURI(mURI.get(),                        // URI string
-                         nsIWebNavigation::LOAD_FLAGS_NONE, // Load flags
+                         nsIWebNavigation::LOAD_FLAGS_NONE | // Load flags
+                         nsIWebNavigation::LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP,  // Allow keyword.URL.. functionality
                          nsnull,                            // Referring URI
                          nsnull,                            // Post data
                          nsnull);                           // extra headers
   }
 }
 
 void
 EmbedPrivate::Reload(PRUint32 reloadFlags)
@@ -727,72 +783,134 @@
     return;
   }
   mChromeMask = aChromeMask;
 
   ApplyChromeMask();
 }
 
 
+// Embedding is only initialized (and should only be terminated) if this returns
+// NS_OK *AND* !aNeedsRestart. In all other cases, it is not initialized.
+// Only call XRE_TermEmbedding if Embedding is initialized :)
+nsresult EmbedPrivate::LocalInitEmbedding(nsILocalFile *aGREDir, nsILocalFile
+                                          *aBinDir, nsILocalFile
+                                          *aProfileDir,
+                                          PRBool *aNeedsRestart)
+{
+  nsresult rv;
+  *aNeedsRestart = PR_FALSE;
+  if (EmbedPrivate::sProfileDir) {
+    rv = XRE_LockProfileDirectory(EmbedPrivate::sProfileDir,
+                                  &EmbedPrivate::sProfileLock);
+    if (NS_FAILED(rv))
+      return rv;
+  }
+
+  if (sWidgetCount > 1)
+    XRE_NotifyProfile();
+
+  rv = XRE_InitEmbedding(aGREDir,
+                         aBinDir,
+                         const_cast<GTKEmbedDirectoryProvider*>
+                                       (&kDirectoryProvider),
+                         nsnull,
+                         nsnull);
+  if (NS_FAILED(rv))
+    return rv;
+
+  if (aProfileDir) {
+    XRE_NotifyProfile();
+  }
+
+  nsCOMPtr<nsICommandLineRunner>
+    cmdline(do_CreateInstance("@mozilla.org/toolkit/command-line;1", &rv));
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  nsCOMPtr<nsIExtensionManager>
+    extensionManager(do_GetService("@mozilla.org/extensions/manager;1", &rv));
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Fail to initialize extension manager\n");
+    cmdline = nsnull;
+    return rv;
+  }
+
+  extensionManager->Start(cmdline, aNeedsRestart);
+  if (*aNeedsRestart) {
+    extensionManager = nsnull;
+    cmdline = nsnull;
+  }
+  return NS_OK;
+}
+
 /* static */
 void
 EmbedPrivate::PushStartup(void)
 {
-  // increment the number of widgets
-  sWidgetCount++;
+  if (!EmbedPrivate::sTermEmbedding) {
+    NS_WARNING("Multiple PushStartup call\n");
+    return;
+  }
 
-  // if this is the first widget, fire up xpcom
-  if (sWidgetCount == 1) {
-    nsresult rv;
-    nsCOMPtr<nsILocalFile> binDir;
-    nsCOMPtr<nsILocalFile> compDir;
-    if (EmbedPrivate::sCompPath) {
-      rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(binDir));
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsILocalFile> binDir;
+  nsCOMPtr<nsILocalFile> compDir;
+  if (EmbedPrivate::sCompPath) {
+    rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(binDir));
+    if (NS_SUCCEEDED(rv))
       rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(compDir));
-      if (NS_FAILED(rv))
-        return;
+    if (NS_FAILED(rv))
+      return;
+    rv = compDir->AppendNative(nsDependentCString("components"));
+#if 0
       PRBool exists;
-      rv = compDir->AppendNative(nsDependentCString("components"));
       compDir->Exists(&exists);
       if (!exists)
         rv = compDir->Create(nsIFile::DIRECTORY_TYPE, 0700);
       if (NS_FAILED(rv))
         return;
-    } else
-      NS_ASSERTION(EmbedPrivate::sCompPath, "Warning: Failed to init Component Path.\n");
+#endif
+  }
+  NS_ASSERTION(EmbedPrivate::sCompPath, "Warning: Component Path wasn't set.");
+  NS_ASSERTION(NS_SUCCEEDED(rv), "Can't set Component Path.");
 
-    const char *grePath = sPath;
-    NS_ASSERTION(grePath, "Warning: Failed to init grePath.\n");
+  const char *grePath = sPath;
+  if (!grePath) {
+    NS_WARNING("grePath wasn't set, will use fallback.");
+    grePath = getenv("MOZILLA_FIVE_HOME");
+  }
 
-    if (!grePath)
-      grePath = getenv("MOZILLA_FIVE_HOME");
+  if (!grePath)
+    return;
 
-    if (!grePath)
-      return;
+  nsCOMPtr<nsILocalFile> greDir;
+  rv = NS_NewNativeLocalFile(nsDependentCString(grePath), PR_TRUE,
+                             getter_AddRefs(greDir));
+  if (NS_FAILED(rv))
+    return;
 
-    nsCOMPtr<nsILocalFile> greDir;
-    rv = NS_NewNativeLocalFile(nsDependentCString(grePath), PR_TRUE,
-                               getter_AddRefs(greDir));
-    if (NS_FAILED(rv))
-      return;
+  PRBool needsRestart = PR_TRUE;
 
-    rv = XRE_InitEmbedding(greDir, binDir,
-                           const_cast<GTKEmbedDirectoryProvider*>
-                                     (&kDirectoryProvider),
-                           nsnull, nsnull);
-    if (NS_FAILED(rv))
+  PRInt32 initCount;
+  for (initCount = 0; initCount < 4 && needsRestart; ++initCount) {
+    rv = LocalInitEmbedding(greDir.get(), binDir.get(), EmbedPrivate::sProfileDir,
+                            &needsRestart);
+    if (NS_FAILED(rv)) {
+      // Embedding isn't initialized!!!
       return;
-
-    if (EmbedPrivate::sProfileDir) {
-      XRE_NotifyProfile();
     }
-
-    rv = RegisterAppComponents();
-    NS_ASSERTION(NS_SUCCEEDED(rv), "Warning: Failed to register app components.\n");
   }
+
+  rv = RegisterComponents(initCount > 1);
+  NS_ASSERTION(NS_SUCCEEDED(rv), "Warning: Failed to register app components.\n");
+  // If this fails, you're probably dead and you should probably term
+  // embedding and mark yourself as dead, but perhaps it isn't critical.
+  EmbedPrivate::sTermEmbedding = PR_FALSE;
 }
 
 /* static */
 void
 EmbedPrivate::PopStartup(void)
 {
   sWidgetCount--;
   if (sWidgetCount == 0) {
@@ -803,16 +921,17 @@
 
     // we no longer need a reference to the DirectoryServiceProvider
     if (EmbedPrivate::sAppFileLocProvider) {
       NS_RELEASE(EmbedPrivate::sAppFileLocProvider);
       EmbedPrivate::sAppFileLocProvider = nsnull;
     }
 
     // shut down XPCOM/Embedding
+    EmbedPrivate::sTermEmbedding = PR_TRUE;
     XRE_TermEmbedding();
 
     EmbedGlobalHistory::DeleteInstance();
   }
 }
 
 /* static */
 void EmbedPrivate::SetPath(const char *aPath)
@@ -978,22 +1097,16 @@
     return;
 
   GetListener();
 
   if (!mEventTarget)
     return;
 
   AttachListeners();
-
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-  EmbedPasswordMgr *passwordManager = EmbedPasswordMgr::GetInstance();
-  if (passwordManager)
-    passwordManager->mFormAttachCount = PR_FALSE;
-#endif
 }
 
 void
 EmbedPrivate::ContentFinishedLoading(void)
 {
   if (mIsChrome) {
     // We're done loading.
     mChromeLoaded = PR_TRUE;
@@ -1015,55 +1128,16 @@
 
     // and since we're done loading show the window, assuming that the
     // visibility flag has been set.
     PRBool visibility;
     mWindow->GetVisibility(&visibility);
     if (visibility)
       mWindow->SetVisibility(PR_TRUE);
   }
-
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-  EmbedPasswordMgr *passwordManager = EmbedPasswordMgr::GetInstance();
-  if (passwordManager && passwordManager->mFormAttachCount) {
-
-    GList *list_full = NULL, *users_list = NULL;
-    gint retval = -1;
-
-    if (gtk_moz_embed_common_get_logins(NS_ConvertUTF16toUTF8(mURI).get(), &list_full)) {
-
-      GList *ptr = list_full;
-      while(ptr) {
-        GtkMozLogin * login = static_cast<GtkMozLogin*>(ptr->data);
-        if (login && login->user) {
-          users_list = g_list_append(users_list, NS_strdup(login->user));
-          NS_Free((void*)login->user);
-          if (login->pass)
-            NS_Free((void*)login->pass);
-          if (login->host)
-            NS_Free((void*)login->host);
-        }
-        else
-          break;
-        ptr = ptr->next;
-      }
-      g_list_free(list_full);
-      if (users_list)
-        gtk_signal_emit(GTK_OBJECT(mOwningWidget->common),
-                        moz_embed_common_signals[COMMON_SELECT_LOGIN],
-                        users_list,
-                        &retval);
-      if (retval != -1) {
-        passwordManager->InsertLogin((const gchar*)g_list_nth_data(users_list, retval));
-      }
-      g_list_free(users_list);
-    }
-    passwordManager->mFormAttachCount = PR_FALSE;
-  }
-#endif
 }
 
 void
 EmbedPrivate::ChildFocusIn(void)
 {
   if (mIsDestroyed)
     return;
 
@@ -1072,17 +1146,19 @@
   rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
   if (NS_FAILED(rv))
     return;
 
   nsCOMPtr<nsIWebBrowserFocus> webBrowserFocus(do_QueryInterface(webBrowser));
   if (!webBrowserFocus)
     return;
 
+  mWindow->EnableFocusEmit(PR_FALSE);
   webBrowserFocus->Activate();
+  mWindow->EnableFocusEmit(PR_TRUE);
 }
 
 void
 EmbedPrivate::ChildFocusOut(void)
 {
   if (mIsDestroyed)
     return;
 
@@ -1121,17 +1197,17 @@
 void
 EmbedPrivate::AttachListeners(void)
 {
   if (!mEventTarget || mListenersAttached)
     return;
 
   nsIDOMEventListener *eventListener =
     static_cast<nsIDOMEventListener *>
-               (static_cast<nsIDOMKeyListener *>(mEventListener));
+       (static_cast<nsIDOMKeyListener *>(mEventListener));
 
   // add the key listener
   nsresult rv;
   rv = mEventTarget->AddEventListenerByIID(
          eventListener,
          NS_GET_IID(nsIDOMKeyListener));
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to add key listener\n");
@@ -1165,34 +1241,36 @@
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mEventTarget));
   if (!target) {
     return;
   }
   
   rv = target->AddEventListener(NS_LITERAL_STRING("focus"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("blur"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("DOMLinkAdded"), eventListener, PR_TRUE);
+  rv = target->AddEventListener(NS_LITERAL_STRING("DOMPopupBlocked"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("load"), eventListener, PR_TRUE);
+  rv = target->AddEventListener(NS_LITERAL_STRING("DOMLinkXSLParsed"), eventListener, PR_TRUE);
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to add Mouse Motion listener\n");
     return;
   }
   // ok, all set.
   mListenersAttached = PR_TRUE;
 }
 
 void
 EmbedPrivate::DetachListeners(void)
 {
   if (!mListenersAttached || !mEventTarget)
     return;
 
   nsIDOMEventListener *eventListener =
     static_cast<nsIDOMEventListener *>
-               (static_cast<nsIDOMKeyListener *>(mEventListener));
+       (static_cast<nsIDOMKeyListener *>(mEventListener));
 
   nsresult rv;
   rv = mEventTarget->RemoveEventListenerByIID(
          eventListener,
          NS_GET_IID(nsIDOMKeyListener));
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to remove key listener\n");
     return;
@@ -1226,16 +1304,18 @@
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mEventTarget));
   if (!target) {
     return;
   }
 
   rv = target->RemoveEventListener(NS_LITERAL_STRING("focus"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("blur"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMLinkAdded"), eventListener, PR_TRUE);
+  rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMPopupBlocked"), eventListener, PR_TRUE);
+  rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMLinkXSLParsed"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("load"), eventListener, PR_TRUE);
   mListenersAttached = PR_FALSE;
 }
 
 nsresult
 EmbedPrivate::GetFocusController(nsIFocusController * *controller)
 {
   nsresult rv;
@@ -1316,17 +1396,17 @@
       return atkObj;
   }
   return nsnull;
 }
 #endif /* MOZ_ACCESSIBILITY_ATK */
 
 /* static */
 nsresult
-EmbedPrivate::RegisterAppComponents(void)
+EmbedPrivate::RegisterComponents(PRBool aAutoRegister)
 {
   nsCOMPtr<nsIComponentRegistrar> cr;
   nsresult rv = NS_GetComponentRegistrar(getter_AddRefs(cr));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIComponentManager> cm;
   rv = NS_GetComponentManager(getter_AddRefs(cm));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1347,16 +1427,19 @@
     // Call the registration hook of the component, if any
     if (sAppComps[i].mRegisterSelfProc) {
       rv = sAppComps[i].mRegisterSelfProc(cm, nsnull, nsnull, nsnull,
                                           &(sAppComps[i]));
       NS_ASSERTION(NS_SUCCEEDED(rv), "Unable to self-register component");
     }
   }
 
+  if (aAutoRegister)
+    cr->AutoRegister(nsnull);
+
   return rv;
 }
 
 /* static */
 void
 EmbedPrivate::EnsureOffscreenWindow(void)
 {
   if (sOffscreenWindow)
@@ -1394,18 +1477,17 @@
   switch (type) {
     case GTK_MOZ_EMBED_SELECT_ALL:
     {
       rv = clipboard->SelectAll();
       break;
     }
     case GTK_MOZ_EMBED_CAN_SELECT:
     {
-      //FIXME
-      break;
+      return CanSelect();
     }
     case GTK_MOZ_EMBED_CUT:
     {
       rv = clipboard->CutSelection();
       break;
     }
     case GTK_MOZ_EMBED_COPY:
     {
@@ -1486,64 +1568,101 @@
   rv = finder->FindNext(&match);
   NS_Free(text);
   if (NS_FAILED(rv))
     return FALSE;
 
   return match;
 }
 
-void
-EmbedPrivate::SetScrollTop(PRUint32 aTop)
-{
-  EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-  if (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_IFRAME){
-    if (ctx_menu) {
-      nsIDOMWindow *ctxDomWindows = ctx_menu->mCtxDomWindow;
-      if (ctxDomWindows)
-      {
-        nsCOMPtr<nsIDOMDocument> domDoc;
-        ctxDomWindows->GetDocument(getter_AddRefs(domDoc));
-        if (domDoc) {
-          ctx_menu->GetElementForScroll(domDoc);
-          if (ctx_menu->mNSHHTMLElementSc)
-            ctx_menu->mNSHHTMLElementSc->SetScrollTop(aTop);
-        }
-      }
-    }
-  } else {
-    nsCOMPtr<nsIDOMWindow> window;
-    nsCOMPtr<nsIWebBrowser> webBrowser;
-    mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
-    webBrowser->GetContentDOMWindow(getter_AddRefs(window));
-    window->ScrollBy(0, aTop);
-  }
-} 
-
 nsresult
 EmbedPrivate::ScrollToSelectedNode(nsIDOMNode *aDOMNode)
 {
   nsresult rv = NS_ERROR_FAILURE;
   if (aDOMNode) {
     nsCOMPtr<nsIDOMNSHTMLElement> nodeElement = do_QueryInterface(aDOMNode, &rv);
     if (NS_SUCCEEDED(rv) && nodeElement) {
       nodeElement->ScrollIntoView(PR_FALSE);
     }
   }
   return rv;
 }
 
 nsresult
-EmbedPrivate::InsertTextToNode(nsIDOMNode *aDOMNode, const char *string)
+EmbedPrivate::GetTextAndCursorPosition(gchar **aString, PRInt32 *aCursorPos)
+{
+  NS_ENSURE_ARG_POINTER(aString);
+  NS_ENSURE_ARG_POINTER(aCursorPos);
+
+  nsresult rv;
+  nsString cString;
+
+  nsCOMPtr<nsIWebBrowser> webBrowser;
+  rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+  if (NS_FAILED(rv))
+    return PR_FALSE;
+
+  nsCOMPtr<nsIWebBrowserFocus> focus(do_GetInterface(webBrowser));
+  if (!focus)
+    return PR_FALSE;
+
+  EmbedContextMenuInfo *ctxInfo;
+  ctxInfo = mEventListener->GetContextInfo();
+
+  nsIDOMElement *domElement;
+  rv = focus->GetFocusedElement(&domElement);
+  if (NS_SUCCEEDED(rv)) {
+    /* if domElement is either an input or text area, get their content and
+       cursor position */
+    if (ctxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
+      if (ctxInfo->mCtxFormType == NS_FORM_TEXTAREA) {
+	nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea = do_QueryInterface(domElement, &rv);
+	if (textArea) {
+          rv = textArea->GetValue(cString);
+          if (NS_FAILED(rv))
+            return PR_FALSE;
+
+          nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaNS = do_QueryInterface(domElement);
+	  if(textAreaNS)
+	    textAreaNS->GetSelectionStart(aCursorPos);
+
+	  *aString = strdup((gchar *)NS_ConvertUTF16toUTF8(cString).get());
+	  //printf("1STRING=%s curpos=%d\n", *aString, (int)*aCursorPos);
+        }
+      } else {
+	nsCOMPtr<nsIDOMHTMLInputElement> inputElement = do_QueryInterface(domElement, &rv);
+        if (inputElement) {
+          rv = inputElement->GetValue(cString);
+          if (NS_FAILED(rv))
+            return PR_FALSE;
+
+          nsCOMPtr<nsIDOMNSHTMLInputElement> inputElementNS = do_QueryInterface(domElement);
+          if(inputElementNS)
+	    inputElementNS->GetSelectionStart(aCursorPos);
+
+	  *aString = strdup((gchar *)NS_ConvertUTF16toUTF8(cString).get());
+	  //printf(">>>>>> 2STRING=%s curpos=%d\n", *aString, (int)*aCursorPos);
+        }
+      }
+    }
+  }
+
+  return PR_TRUE;
+
+}
+
+nsresult
+EmbedPrivate::InsertTextToNode(nsIDOMNode *aDOMNode, const char *string, gint surr1, gint surr2)
 {
   nsIDOMNode *targetNode = nsnull;
   nsresult rv;
 
   EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-  if (ctx_menu && ctx_menu->mEventNode && (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT)) {
+  if (ctx_menu && ctx_menu->mEventNode &&
+     (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT | GTK_MOZ_EMBED_CTX_XUL)) {
     targetNode = ctx_menu->mEventNode;
   }
 
   if (!targetNode)
     return NS_ERROR_FAILURE;
 
   nsString nodeName;
   targetNode->GetNodeName(nodeName);
@@ -1558,64 +1677,101 @@
     input->GetReadOnly(&rdonly);
     if (rdonly)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNSHTMLTextAreaElement> nsinput;
     nsinput = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsinput->GetTextLength(&textLength);
+    nsString utfstring = NS_ConvertUTF8toUTF16(string);
     if (textLength > 0) {
       NS_ENSURE_SUCCESS(rv, rv);
       rv = input->GetValue(buffer);
       nsinput->GetSelectionStart(&selectionStart);
       nsinput->GetSelectionEnd(&selectionEnd);
 
       if (selectionStart != selectionEnd)
         buffer.Cut(selectionStart, selectionEnd - selectionStart);
-      buffer.Insert(NS_ConvertUTF8toUTF16(string), selectionStart);
-    } else {
-      buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    }
+      if (surr1 != 0 || surr2 != 0) {
+        /* next 2 strings: use cursor position (selectionStart) instead of textLength */
+        buffer.Cut(selectionStart + surr1, surr2);
+        buffer.Insert(utfstring, selectionStart + surr1);
+      } else
+        buffer.Insert(utfstring, selectionStart);
+    } else
+        buffer.Assign(utfstring);
 
     input->SetValue(buffer);
-    int len = strlen(string);
+    int len = utfstring.Length();
     nsinput->SetSelectionRange(selectionStart + len, selectionStart + len);
+
+    nsCOMPtr<nsIDOMNSEditableElement> nseditable;
+    nseditable = do_QueryInterface(targetNode, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIEditor> theEditor;
+    nseditable->GetEditor(getter_AddRefs(theEditor));
+    NS_ENSURE_TRUE(theEditor, NS_OK);
+
+    nsCOMPtr<nsISelectionController> selectionController;
+    theEditor->GetSelectionController(getter_AddRefs(selectionController));
+    PRBool sync = PR_TRUE;
+    short selectionType = nsISelectionController::SELECTION_NORMAL;
+    selectionController->ScrollSelectionIntoView(selectionType, selectionType, sync);
   }
   else if (ctx_menu->mCtxFormType) {
     nsCOMPtr<nsIDOMHTMLInputElement> input;
     input = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     PRBool rdonly = PR_FALSE;
     input->GetReadOnly(&rdonly);
     if (rdonly)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNSHTMLInputElement> nsinput;
     nsinput = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsinput->GetTextLength(&textLength);
-
+    nsString utfstring = NS_ConvertUTF8toUTF16(string);
     if (textLength > 0) {
       NS_ENSURE_SUCCESS(rv, rv);
       rv = input->GetValue(buffer);
       nsinput->GetSelectionStart(&selectionStart);
       nsinput->GetSelectionEnd(&selectionEnd);
 
       if (selectionStart != selectionEnd) {
         buffer.Cut(selectionStart, selectionEnd - selectionStart);
       }
-      buffer.Insert(NS_ConvertUTF8toUTF16(string), selectionStart);
-    } else {
-      buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    }
+      if (surr1 != 0 || surr2 != 0) {
+        /* next 2 strings: use cursor position (selectionStart) instead of textLength */
+        buffer.Cut(selectionStart + surr1, surr2);
+        buffer.Insert(utfstring, selectionStart + surr1);
+      } else
+        buffer.Insert(utfstring, selectionStart);
+    } else
+        buffer.Assign(utfstring);
 
     input->SetValue(buffer);
-    int len = strlen(string);
+    int len = utfstring.Length();
     nsinput->SetSelectionRange(selectionStart + len, selectionStart + len);
+
+    nsCOMPtr<nsIDOMNSEditableElement> nseditable;
+    nseditable = do_QueryInterface(targetNode, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIEditor> theEditor;
+    nseditable->GetEditor(getter_AddRefs(theEditor));
+    NS_ENSURE_TRUE(theEditor, NS_OK);
+
+    nsCOMPtr<nsISelectionController> selectionController;
+    theEditor->GetSelectionController(getter_AddRefs(selectionController));
+    PRBool sync = PR_TRUE;
+    short selectionType = nsISelectionController::SELECTION_NORMAL;
+    selectionController->ScrollSelectionIntoView(selectionType, selectionType, sync);
   }
   else {
     nsIWebBrowser *retval = nsnull;
     mWindow->GetWebBrowser(&retval);
     nsCOMPtr<nsIEditingSession> editingSession = do_GetInterface(retval);
     if (!editingSession)
       return NS_ERROR_FAILURE;
 
@@ -1625,27 +1781,63 @@
     if (!doc)
       return NS_OK;
     piWin = doc->GetWindow();
     editingSession->GetEditorForWindow(piWin, getter_AddRefs(theEditor));
     if (!theEditor) {
       return NS_ERROR_FAILURE;
     }
 
-    nsCOMPtr<nsIHTMLEditor> htmlEditor;
-    htmlEditor = do_QueryInterface(theEditor, &rv);
-    if (!htmlEditor)
+    nsCOMPtr<nsIPlaintextEditor> textEditor;
+    textEditor = do_QueryInterface(theEditor, &rv);
+    if (NS_FAILED(rv) || !textEditor)
       return NS_ERROR_FAILURE;
     buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    htmlEditor->InsertHTML(buffer);
+    if (surr1 != 0 || surr2 != 0) {
+      DoCommand("cmd_delete", surr2, aDOMNode);
+    }
+    textEditor->InsertText(buffer);
   }
   return NS_OK;
 }
 
 nsresult
+EmbedPrivate::DoCommand(const char *aCommand, PRInt32 aCount, nsIDOMNode *aDOMNode)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+  nsCOMPtr<nsIDOMWindow> DOMWindow;
+  if (aDOMNode) {
+    rv = GetDOMWindowByNode(aDOMNode, getter_AddRefs(DOMWindow));
+  } else {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
+
+  }
+  nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(DOMWindow));
+  NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
+
+  nsCOMPtr<nsICommandManager> cmdMgr(do_GetInterface(window->GetDocShell()));
+  NS_ENSURE_TRUE(cmdMgr, NS_ERROR_FAILURE);
+
+  if (!aCount) {
+      PRBool enabled = PR_FALSE;
+      rv = cmdMgr->IsCommandEnabled(aCommand, DOMWindow, &enabled);
+      if (enabled)
+        return NS_OK;
+      return NS_ERROR_FAILURE;
+  }
+  for (int i = 0; i < aCount && NS_SUCCEEDED(rv); i++) {
+    rv = cmdMgr->DoCommand(aCommand, nsnull, DOMWindow);
+  }
+  return rv;
+}
+
+nsresult
 EmbedPrivate::GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow)
 {
   nsresult rv;
   nsCOMPtr<nsIDOMDocument> nodeDoc;
   rv = aNode->GetOwnerDocument(getter_AddRefs(nodeDoc));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMDocumentView> docView = do_QueryInterface(nodeDoc, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1655,16 +1847,38 @@
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(absView, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   *aDOMWindow = window;
   NS_IF_ADDREF(*aDOMWindow);
   return rv;
 }
 
+static nsresult
+GetMarkupViewerByWindow(nsIDOMWindow *aDOMWindow,
+                        nsIMarkupDocumentViewer * *aMarkupDocViewver)
+{
+  nsresult rv;
+  NS_ENSURE_ARG_POINTER(aMarkupDocViewver);
+  nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aDOMWindow, &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsIDocShell *docShell = nsnull;
+  if (window)
+    docShell = window->GetDocShell();
+  NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
+  nsCOMPtr<nsIContentViewer> contentViewer;
+  rv = docShell->GetContentViewer(getter_AddRefs(contentViewer));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer, &rv));
+  NS_ENSURE_TRUE(markupViewer, NS_ERROR_FAILURE);
+  *aMarkupDocViewver = markupViewer;
+  NS_IF_ADDREF(*aMarkupDocViewver);
+  return rv;
+}
+
 nsresult
 EmbedPrivate::GetZoom(PRInt32 *aZoomLevel, nsISupports *aContext)
 {
 
   NS_ENSURE_ARG_POINTER(aZoomLevel);
 
   nsresult rv;
   *aZoomLevel = 100;
@@ -1679,19 +1893,27 @@
     nsCOMPtr<nsIWebBrowser> webBrowser;
     rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  float zoomLevelFloat;
-  if (DOMWindow)
-    rv = DOMWindow->GetTextZoom(&zoomLevelFloat);
+  float zoomLevelFloat = 100;
+  if (DOMWindow) {
+    nsCOMPtr<nsIMarkupDocumentViewer> markupViewer;
+    rv = GetMarkupViewerByWindow(DOMWindow, getter_AddRefs(markupViewer));
+    NS_ENSURE_SUCCESS(rv, rv);
+    gboolean bval = FALSE;
+    if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.textzoom", &bval) && bval)
+      rv = markupViewer->GetTextZoom(&zoomLevelFloat);
+    else
+      rv = markupViewer->GetFullZoom(&zoomLevelFloat);
+  }
   NS_ENSURE_SUCCESS(rv, rv);
 
   *aZoomLevel = (int)round(zoomLevelFloat * 100.);
   return rv;
 }
 nsresult
 EmbedPrivate::SetZoom(PRInt32 aZoomLevel, nsISupports *aContext)
 {
@@ -1710,19 +1932,29 @@
 
     rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   float zoomLevelFloat;
   zoomLevelFloat = (float) aZoomLevel / 100.;
 
-  if (DOMWindow)
-    rv = DOMWindow->SetTextZoom(zoomLevelFloat);
-
+  if (DOMWindow) {
+    nsCOMPtr<nsIMarkupDocumentViewer> markupViewer;
+    rv = GetMarkupViewerByWindow(DOMWindow, getter_AddRefs(markupViewer));
+    NS_ENSURE_SUCCESS(rv, rv);
+    gboolean bval = FALSE;
+    if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.textzoom", &bval) && bval)
+      rv = markupViewer->SetTextZoom(zoomLevelFloat);
+    else
+      rv = markupViewer->SetFullZoom(zoomLevelFloat);
+    gtk_widget_queue_draw(GTK_WIDGET(mOwningWidget));
+  }
+  //update
+  mWindow->mBaseWindow->SetPosition(0, 0);
   return rv;
 }
 
 nsresult
 EmbedPrivate::HasFrames  (PRUint32 *numberOfFrames)
 {
   // setting default value.
   *numberOfFrames = 0;
@@ -1875,8 +2107,214 @@
      if (type == GTK_MOZ_EMBED_BACK_SHISTORY)
        navIndex--;
      else if (type == GTK_MOZ_EMBED_FORWARD_SHISTORY)
        navIndex++;
    }
    *count = maxItems;
    return NS_OK;
 }
+
+PRBool
+EmbedPrivate::CanSelect()
+{
+  nsCOMPtr<nsIWebBrowser> webBrowser;
+  nsresult rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  nsCOMPtr<nsIWebBrowserFocus> focus = do_QueryInterface(webBrowser, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  EmbedContextMenuInfo *ctxInfo;
+  ctxInfo = mEventListener->GetContextInfo();
+  if (!ctxInfo)
+    return PR_TRUE;
+
+  nsCOMPtr<nsIDOMElement> domElement;
+  rv = focus->GetFocusedElement(getter_AddRefs(domElement));
+  if (NS_SUCCEEDED(rv)) {
+    /* if domElement is either an input or text area, get their length to
+       check if there is anything to select */
+    if (ctxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
+      PRInt32 textLength;
+      if (ctxInfo->mCtxFormType == NS_FORM_TEXTAREA) {
+        nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(domElement, &rv);
+        NS_ENSURE_SUCCESS(rv, PR_TRUE);
+        textArea->GetTextLength(&textLength);
+        if (textLength == 0)
+          return PR_FALSE;
+      } else {
+        nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(domElement, &rv);
+        NS_ENSURE_SUCCESS(rv, PR_TRUE);
+        input->GetTextLength(&textLength);
+        if (textLength == 0)
+          return PR_FALSE;
+      }
+    }
+    return PR_TRUE;
+  }
+
+  nsCOMPtr<nsIDOMWindow> domWindow;
+  rv = focus->GetFocusedWindow(getter_AddRefs(domWindow));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  nsCOMPtr<nsIDOMDocument> domDoc;
+  rv = domWindow->GetDocument(getter_AddRefs(domDoc));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  /* checks if focused document is a frameset */
+  nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(domDoc, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+  if (htmlDoc->GetIsFrameset())
+    return PR_FALSE;
+
+  return PR_TRUE;
+}
+
+nsresult
+EmbedPrivate::NotifyPlugins(PRUint16 aEvent, nsIDOMWindow* aDomWindow)
+{
+  nsCOMPtr<nsIDOMDocument> domDoc;
+
+  if (!aDomWindow) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    if (!webBrowser) return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIDOMWindow> domWin;
+    webBrowser->GetContentDOMWindow(getter_AddRefs(domWin));
+    if (!domWin) return NS_ERROR_FAILURE;
+
+    domWin->GetDocument(getter_AddRefs(domDoc));
+    if (!domDoc)
+      return NS_ERROR_FAILURE;
+  }
+  else {
+    aDomWindow->GetDocument(getter_AddRefs(domDoc));
+    if (!domDoc)
+      return NS_ERROR_FAILURE;
+  }
+
+  EnumeratePlugins(domDoc, NS_LITERAL_STRING("object"),  aEvent);
+  EnumeratePlugins(domDoc, NS_LITERAL_STRING("embed"),  aEvent);
+  EnumerateFrames(domDoc, aEvent);
+}
+
+nsresult
+EmbedPrivate::EnumerateFrames(nsIDOMDocument* aDomDoc, PRUint16 aEvent)
+{
+  nsresult rv;
+
+  PRUint32 iframeLength;
+  PRUint32 frameLength;
+
+  nsCOMPtr<nsIDOMNodeList> iframeList;
+  nsCOMPtr<nsIDOMDocument> iframeDoc;
+  nsCOMPtr<nsIDOMNodeList> frameList;
+  nsCOMPtr<nsIDOMDocument> frameDoc;
+
+  rv = aDomDoc->GetElementsByTagName (NS_LITERAL_STRING("iframe"),
+                                     getter_AddRefs(iframeList));
+  if (iframeList) {
+    rv = iframeList->GetLength(&iframeLength);
+    nsCOMPtr<nsIDOMNode> node;
+    for (PRUint32 i = 0; i < iframeLength; i++) {
+      rv = iframeList->Item(i, getter_AddRefs(node));
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      nsCOMPtr<nsIDOMHTMLIFrameElement> element = do_QueryInterface(node, &rv);
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      element->GetContentDocument(getter_AddRefs(iframeDoc));
+      if (!iframeDoc)
+        return NS_ERROR_FAILURE;
+
+      EnumeratePlugins(iframeDoc, NS_LITERAL_STRING("object"), aEvent);
+      EnumeratePlugins(iframeDoc, NS_LITERAL_STRING("embed"), aEvent);
+      EnumerateFrames(iframeDoc, aEvent);
+    }
+  }
+
+  // Now try to get the plugin instance in frame
+  rv = aDomDoc->GetElementsByTagName (NS_LITERAL_STRING("frame"),
+                                    getter_AddRefs(frameList));
+  if (frameList) {
+    rv = frameList->GetLength(&frameLength);
+    nsCOMPtr<nsIDOMNode> node;
+    for (PRUint32 i = 0; i < frameLength; i++) {
+      rv = frameList->Item(i, getter_AddRefs(node));
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      nsCOMPtr<nsIDOMHTMLFrameElement> element = do_QueryInterface(node, &rv);
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      element->GetContentDocument(getter_AddRefs(frameDoc));
+      if (!frameDoc)
+        return NS_ERROR_FAILURE;
+
+      EnumeratePlugins(frameDoc, NS_LITERAL_STRING("object"), aEvent);
+      EnumeratePlugins(frameDoc, NS_LITERAL_STRING("embed"), aEvent);
+      EnumerateFrames(frameDoc, aEvent);
+    }
+  }
+}
+
+nsresult
+EmbedPrivate::EnumeratePlugins(nsIDOMDocument* aDomDoc, const nsAString& aPluginTag, PRUint16 aEvent)
+{
+  nsresult rv;
+
+  PRUint32 length;
+  nsCOMPtr<nsIDocument> iDoc = do_QueryInterface(aDomDoc);
+  if (!iDoc)
+    return NS_ERROR_FAILURE;
+  nsIPresShell* presShell = iDoc->GetPrimaryShell();
+  if (!presShell)
+    return NS_ERROR_FAILURE;
+
+  PRBool handled;
+  nsPluginEvent pluginEvent;
+  pluginEvent.event.type = aEvent;
+
+  nsCOMPtr<nsIDOMNodeList> list;
+  rv = aDomDoc->GetElementsByTagName(aPluginTag, getter_AddRefs(list));
+  if (!list)
+    return NS_ERROR_FAILURE;
+
+  rv = list->GetLength(&length);
+  nsCOMPtr<nsIDOMNode> node;
+  for (PRUint32 i = 0; i < length; i++) {
+    rv = list->Item(i,getter_AddRefs(node));
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIDOMHTMLElement> element = do_QueryInterface(node, &rv);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIContent> iContent = do_QueryInterface(element, &rv);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsIFrame* frame = nsnull;
+    frame = presShell->GetPrimaryFrameFor(iContent);
+
+    nsIObjectFrame* objectFrame = nsnull;
+    if (frame)
+      CallQueryInterface(frame,&objectFrame);
+    if (!objectFrame)
+      continue;
+
+    nsCOMPtr<nsIPluginInstance> instance;
+    objectFrame->GetPluginInstance(*getter_AddRefs(instance));
+
+    if (!instance)
+      continue;
+    instance->HandleEvent(&pluginEvent,&handled);
+    if (!handled)
+      return NS_ERROR_FAILURE;
+  }
+}
+
Index: mozilla/embedding/browser/gtk/src/EmbedPrivate.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPrivate.h
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -86,16 +86,17 @@
  public:
   EmbedCommon() {
   }
   ~EmbedCommon() { }
   static EmbedCommon* GetInstance();
   static void DeleteInstance();
   nsresult    Init(void);
   GtkObject   *mCommon;
+  static nsresult SuspendNative(PRBool aOn);
   static GtkMozEmbed* GetAnyLiveWidget();
 };
 class EmbedPrivate {
 
  public:
 
   EmbedPrivate();
   ~EmbedPrivate();
@@ -111,16 +112,20 @@
   void        LoadCurrentURI  (void);
   void        Reload          (PRUint32 reloadFlags);
 
   void        SetChromeMask   (PRUint32 chromeMask);
   void        ApplyChromeMask ();
 
   static void PushStartup     (void);
   static void PopStartup      (void);
+  static nsresult LocalInitEmbedding(nsILocalFile *aGREDir,
+                                     nsILocalFile *aBinDir,
+                                     nsILocalFile *aProfileDir,
+                                     PRBool *aNeedsRestart);
   static void SetPath         (const char *aPath);
   static void SetCompPath     (const char *aPath);
 
   static void SetAppComponents (const nsModuleComponentInfo* aComps,
                                 int aNumComponents);
   static void SetProfilePath  (const char *aDir, const char *aName);
   static void SetDirectoryServiceProvider (nsIDirectoryServiceProvider * appFileLocProvider);
 
@@ -148,33 +153,35 @@
   void        ChildFocusIn (void);
   void        ChildFocusOut(void);
   PRBool      ClipBoardAction(GtkMozEmbedClipboard type);
   char*       GetEncoding ();
   nsresult    SetEncoding (const char *encoding);
   PRBool      FindText(const char *exp, PRBool  reverse,
                        PRBool  whole_word, PRBool  case_sensitive,
                        PRBool  restart);
-  void        SetScrollTop(PRUint32 aTop);
-  nsresult    ScrollToSelectedNode(nsIDOMNode *aDOMNode);
-  nsresult    InsertTextToNode(nsIDOMNode *aDOMNode, const char *string);
+  nsresult    InsertTextToNode(nsIDOMNode *aDOMNode, const char *string, gint surr1 = 0, gint surr2 = 0);
   nsresult    GetFocusController(nsIFocusController **controller);
-  nsresult    GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow);
+  nsresult    DoCommand(const char *aCommand, PRInt32 aCount = 1, nsIDOMNode *aDOMNode = nsnull);
   nsresult    GetZoom(PRInt32 *aZoomLevel, nsISupports *aContext = nsnull);
   nsresult    SetZoom(PRInt32 aZoomLevel, nsISupports *aContext = nsnull);
   nsresult    HasFrames(PRUint32 *numberOfFrames);
   nsresult    GetMIMEInfo(const char **aMime, nsIDOMNode *aDOMNode = nsnull);
   nsresult    GetCacheEntry(const char *aStorage,
                             const char *aKeyName,
                             PRUint32 aAccess,
                             PRBool aIsBlocking,
                             nsICacheEntryDescriptor **aDescriptor);
   nsresult    GetSHistoryList(GtkMozHistoryItem **GtkHI,
                                GtkMozEmbedSessionHistory type, gint *count);
+  nsresult    GetTextAndCursorPosition(gchar **aString, PRInt32 *aCursorPos);
+  nsresult    NotifyPlugins(PRUint16 aEvent, nsIDOMWindow* aDomWin = nsnull);
 
+  static nsresult    ScrollToSelectedNode(nsIDOMNode *aDOMNode);
+  static nsresult    GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow);
 
 #ifdef MOZ_ACCESSIBILITY_ATK
   void *GetAtkObjectForCurrentDocument();
 #endif
 
   GtkMozEmbed                   *mOwningWidget;
 
   // all of the objects that we own
@@ -193,16 +200,17 @@
   nsCOMPtr<nsPIDOMEventTarget>   mEventTarget;
 
   // the currently loaded uri
   nsString                       mURI;
   nsCString                      mPrePath;
 
   // the number of widgets that have been created
   static PRUint32                sWidgetCount;
+  static PRBool                  sTermEmbedding;
   // the path to the GRE
   static char                   *sPath;
   // the path to components
   static char                   *sCompPath;
   // the list of application-specific components to register
   static const nsModuleComponentInfo  *sAppComps;
   static int                     sNumAppComps;
   // the appshell we have created
@@ -220,41 +228,50 @@
   // is this a chrome window?
   PRBool                         mIsChrome;
   // has the chrome finished loading?
   PRBool                         mChromeLoaded;
 
   // has the network finished loading?
   PRBool                         mLoadFinished;
 
+  // is it uploadind a file ?
+  PRBool                         mIsUploading;
+
   // saved window ID for reparenting later
   GtkWidget                     *mMozWindowWidget;
   // has someone called Destroy() on us?
   PRBool                         mIsDestroyed;
 
   //Open Blocker for Create Window class //Fixme...
   //I just tried to block it on earlier moment
   PRBool                         mOpenBlock;
   PRBool                         mNeedFav;
+  PRBool                         mPluginSuspended;
  private:
 
   // is the chrome listener attached yet?
   PRBool                         mListenersAttached;
   PRBool                         mDoResizeEmbed;
+  PRInt32                        mCurVisibleHeight;
+  PRBool                         mResizeControl;
 
   void GetListener    (void);
   void AttachListeners(void);
   void DetachListeners(void);
 
   // this will get the PIDOMWindow for this widget
   nsresult        GetPIDOMWindow   (nsPIDOMWindow **aPIWin);
 
-  static nsresult RegisterAppComponents();
+  static nsresult RegisterComponents(PRBool aAutoRegister);
 
   // offscreen window methods and the offscreen widget
   static void       EnsureOffscreenWindow(void);
   static void       DestroyOffscreenWindow(void);
   static GtkWidget *sOffscreenWindow;
   static GtkWidget *sOffscreenFixed;
 
+  PRBool          CanSelect();
+  nsresult        EnumerateFrames(nsIDOMDocument* aDomDoc, PRUint16 aEvent);
+  nsresult        EnumeratePlugins(nsIDOMDocument* aDomDoc, const nsAString& aPluginTag, PRUint16 aEvent);
 };
 
 #endif /* __EmbedPrivate_h */
Index: mozilla/embedding/browser/gtk/src/EmbedProgress.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedProgress.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Antonio Gomes <tonikitoo@gmail.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *
@@ -43,148 +43,229 @@
 
 #ifdef MOZILLA_INTERNAL_API
 #include "nsXPIDLString.h"
 #endif
 #include "nsIChannel.h"
 #include "nsIHttpChannel.h"
 #include "nsIWebProgress.h"
 #include "nsIDOMWindow.h"
-#include "EmbedPasswordMgr.h"
+#include "nsPresContext.h"
+#include "nsIFrame.h"
+#include "EmbedWindow.h"
 
 #include "nsIURI.h"
 #include "nsCRT.h"
 
+//#define MOZ_PLUGINS_SHOW = 1,
+//#define MOZ_PLUGINS_HIDE = 2,
+//#define MOZ_PLUGINS_RESUME = 3,
+//#define MOZ_PLUGINS_SUSPEND = 4,
+//#define MOZ_PLUGINS_LOW_MEMORY = 5,
+//#define MOZ_PLUGINS_NORMAL_MEMORY = 6,
+//#define MOZ_PLUGINS_LAST = 7
+
 static PRInt32 sStopSignalTimer = 0;
+static PRBool sNastyProgress = PR_TRUE;
+
 static gboolean
 progress_emit_stop(void * data)
 {
+    if (EmbedPrivate::sTermEmbedding) {
+      fprintf(stderr,"%s:Warning: Emit signal after destroy\n", __FUNCTION__);
+      return FALSE;
+    }
     g_return_val_if_fail(data, FALSE);
     EmbedPrivate *owner = (EmbedPrivate*)data;
+
+    if (owner->mIsUploading) {
+
+        gtk_signal_emit(GTK_OBJECT(owner->mOwningWidget),
+                        moz_embed_signals[FILE_UPLOAD_FINISHED]);
+
+        owner->mIsUploading = PR_FALSE;
+        return FALSE;
+    }
+
     if (!owner->mLoadFinished) {
       owner->mLoadFinished = PR_TRUE;
       gtk_signal_emit(GTK_OBJECT(owner->mOwningWidget),
                       moz_embed_signals[NET_STOP]);
     }
+
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+
+    if (success && enabled) {
+      owner->NotifyPlugins(3);
+      owner->mPluginSuspended = PR_FALSE;
+    }
+    // when finished loading, disable flash suspending function
+    // with the help of pref
+    gboolean btval = FALSE;
+    gtk_moz_embed_common_set_pref (G_TYPE_BOOLEAN,"plugins.flashhack",&btval);
     return FALSE;
 }
 
 EmbedProgress::EmbedProgress(void)
 {
   mOwner = nsnull;
+  mConnectingState = PR_TRUE;
+  mPageDownloaded = PR_FALSE;
+  mPagePainted = PR_FALSE;
+  mShowProgressStopped = PR_TRUE;
 }
 
 EmbedProgress::~EmbedProgress()
 {
 }
 
 NS_IMPL_ISUPPORTS2(EmbedProgress,
                    nsIWebProgressListener,
                    nsISupportsWeakReference)
 
 nsresult
 EmbedProgress::Init(EmbedPrivate *aOwner)
 {
   mOwner = aOwner;
   mStopLevel = 0;
+  gboolean enabled = PR_TRUE;
+  if (gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"gtkmozembed.nasty_progress", &enabled)
+      && !enabled)
+    sNastyProgress = PR_FALSE;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnStateChange(nsIWebProgress *aWebProgress,
            nsIRequest     *aRequest,
            PRUint32        aStateFlags,
            nsresult        aStatus)
 {
+  PRBool mIsLoadingDocument = PR_TRUE;
+  aWebProgress->GetIsLoadingDocument(&mIsLoadingDocument);
+  if (mOwner->mWindow->mHidden == 2) {
+    mOwner->Show();
+    gtk_widget_grab_focus(GTK_WIDGET(mOwner->mOwningWidget));
+    mOwner->mWindow->mHidden = 0;
+  }
+  if (sNastyProgress &&
+      aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING &&
+      aStateFlags & GTK_MOZ_EMBED_FLAG_IS_DOCUMENT) {
+    if (aStatus == NS_FRAME_HAS_VIEW) {
+      mPagePainted = PR_FALSE;
+      mConnectingState = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
+    }
+    if (aStatus == NS_FRAME_IMPL_RESERVED)
+      mPagePainted = PR_TRUE;
+  }
+
   // give the widget a chance to attach any listeners
   mOwner->ContentStateChange();
 
   if (sStopSignalTimer &&
       (
        (aStateFlags & GTK_MOZ_EMBED_FLAG_TRANSFERRING)
        || (aStateFlags & GTK_MOZ_EMBED_FLAG_REDIRECTING)
        || (aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING)
       )
      ) {
-      g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
       mStopLevel = 0;
       gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                       moz_embed_signals[NET_START]);
       mOwner->mLoadFinished = PR_FALSE;
+      mPageDownloaded = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
   }
 
   // if we've got the start flag, emit the signal
-  if ((aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) &&
+  if ((aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK || aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING) &&
       (aStateFlags & GTK_MOZ_EMBED_FLAG_START)) {
     // FIXME: workaround for broken progress values.
     mOwner->mOwningWidget->current_number_of_requests = 0;
     mOwner->mOwningWidget->total_number_of_requests = 0;
 
     if (mOwner->mLoadFinished) {
       mOwner->mLoadFinished = PR_FALSE;
       mStopLevel = 0;
+      mConnectingState = PR_TRUE;
+      mPageDownloaded = PR_FALSE;
+      mPagePainted = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
       gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                       moz_embed_signals[NET_START]);
     }
   }
-  // get the uri for this request
-  nsCString tmpString;
-  RequestToURIString(aRequest, tmpString);
+
+  if (sNastyProgress && mPagePainted && mPageDownloaded && !mShowProgressStopped) {
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[PROGRESS_ALL],
+                    (const gchar *) nsnull,
+                    100, 100);
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[NET_STOP]);
+    mShowProgressStopped = PR_TRUE;
+  }
 
   // FIXME: workaround for broken progress values.
   if (mOwner->mOwningWidget) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_REQUEST) {
       if (aStateFlags & GTK_MOZ_EMBED_FLAG_START)
         mOwner->mOwningWidget->total_number_of_requests ++;
       else if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP)
         mOwner->mOwningWidget->current_number_of_requests++;
     }
 
-    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                    moz_embed_signals[PROGRESS_ALL],
-                    (const gchar *) tmpString.get(),
-                    mOwner->mOwningWidget->current_number_of_requests,
-                    mOwner->mOwningWidget->total_number_of_requests);
-  }
-  // is it the same as the current URI?
-  if (mOwner->mURI.Equals(NS_ConvertUTF8toUTF16(tmpString))) {
-    // for people who know what they are doing
-    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                    moz_embed_signals[NET_STATE],
-                    aStateFlags, aStatus);
+    if (!sNastyProgress || (!mConnectingState && !mShowProgressStopped))
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[PROGRESS_ALL],
+                      (const gchar *) NULL,
+                      mOwner->mOwningWidget->current_number_of_requests,
+                      mOwner->mOwningWidget->total_number_of_requests);
   }
 
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[NET_STATE_ALL],
-                  (const gchar *)tmpString.get(),
+                    NULL,
                   (gint)aStateFlags, (gint)aStatus);
 
   // and for stop, too
   if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_REQUEST)
       mStopLevel = 1;
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_DOCUMENT)
        mStopLevel = mStopLevel == 1 ? 2 : 0;
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_WINDOW) {
       mStopLevel = mStopLevel == 2 ? 3 : 0;
     }
   }
 
   if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) {
-      if (sStopSignalTimer)
-        g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
+      mShowProgressStopped = PR_TRUE;
       progress_emit_stop(mOwner);
       // let our owner know that the load finished
       mOwner->ContentFinishedLoading();
 
+      // resume plugins
+      PRBool enabled = PR_TRUE;
+      gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+      if (success && enabled) {
+        nsCOMPtr<nsIDOMWindow> domWindow;
+        aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
+        mOwner->NotifyPlugins(3, domWindow);
+        mOwner->mPluginSuspended = PR_FALSE;
+      }
     } else if (mStopLevel == 3) {
-      if (sStopSignalTimer)
-        g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
       mStopLevel = 0;
+      mShowProgressStopped = PR_TRUE;
       sStopSignalTimer = g_timeout_add(1000, progress_emit_stop, mOwner);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnProgressChange(nsIWebProgress *aWebProgress,
@@ -193,17 +274,28 @@
                                 PRInt32         aMaxSelfProgress,
                                 PRInt32         aCurTotalProgress,
                                 PRInt32         aMaxTotalProgress)
 {
   nsCString tmpString;
   RequestToURIString(aRequest, tmpString);
 
   // is it the same as the current uri?
+  if (aMaxTotalProgress != -1 && aCurTotalProgress == aMaxTotalProgress
+      && aMaxSelfProgress != -1 && aCurSelfProgress == aMaxSelfProgress) {
+    mPageDownloaded = PR_TRUE;
+  }
+
   if (mOwner->mURI.Equals(NS_ConvertUTF8toUTF16(tmpString))) {
+    if (!mPagePainted && mOwner->mLoadFinished && !sStopSignalTimer) {
+      mOwner->mLoadFinished = PR_FALSE;
+      sStopSignalTimer = g_timeout_add(1000, progress_emit_stop, mOwner);
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[NET_START]);
+    }
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[PROGRESS],
                     aCurTotalProgress, aMaxTotalProgress);
   }
 
   return NS_OK;
 }
 
@@ -236,37 +328,36 @@
   }
 
   if (!isSubFrameLoad) {
     mOwner->SetURI(newURI.get());
     mOwner->mPrePath.Assign(prePath.get());
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[LOCATION]);
   }
-  mOwner->mNeedFav = PR_TRUE;
 
+  // suspend plugins
+  // this->NotifyPlugins(4);
+  mOwner->mNeedFav = PR_TRUE;
+  gboolean bval = TRUE;
+  gtk_moz_embed_common_set_pref (G_TYPE_BOOLEAN,"plugins.flashhack",&bval);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnStatusChange(nsIWebProgress  *aWebProgress,
                               nsIRequest      *aRequest,
                               nsresult         aStatus,
                               const PRUnichar *aMessage)
 {
-  // need to make a copy so we can safely cast to a void *
-  PRUnichar *tmpString = NS_strdup(aMessage);
-
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[STATUS_CHANGE],
                   static_cast<void *>(aRequest),
                   static_cast<gint>(aStatus),
-                  static_cast<void *>(tmpString));
-
-  NS_Free(tmpString);
+                  static_cast<const void *>(aMessage));
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnSecurityChange(nsIWebProgress *aWebProgress,
                                 nsIRequest     *aRequest,
                                 PRUint32         aState)
@@ -316,9 +407,8 @@
   rv = httpChannel->GetResponseStatus(&responseCode);
   // it has to handle more http errors code ??? 401 ? responseCode >= 500 && responseCode <= 505
   rv = httpChannel->GetResponseStatusText(responseText);
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[NETWORK_ERROR],
                   responseCode, responseText.get(), (const gchar*)aUri);
   return rv;
 }
-
Index: mozilla/embedding/browser/gtk/src/EmbedProgress.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedProgress.h
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -59,11 +59,15 @@
 
  private:
 
   static void RequestToURIString(nsIRequest *aRequest, nsCString& aString);
   nsresult HandleHTTPStatus(nsIRequest *aRequest, const char *aUri, PRBool &aSucceeded);
 
   EmbedPrivate *mOwner;
   PRBool mStopLevel;
+  PRBool mConnectingState;
+  PRBool mPageDownloaded;
+  PRBool mPagePainted;
+  PRBool mShowProgressStopped;
 };
 
 #endif /* __EmbedProgress_h */
Index: mozilla/embedding/browser/gtk/src/EmbedPrompter.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPrompter.h
+++ mozilla/embedding/browser/gtk/src/EmbedPrompter.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Brian Ryner <bryner@brianryner.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
Index: mozilla/embedding/browser/gtk/src/EmbedWindow.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindow.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedWindow.cpp
@@ -12,17 +12,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -37,32 +37,36 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCWebBrowser.h"
 #include "nsIComponentManager.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIWidget.h"
+#include "nsPresContext.h"
+#include "nsIPresShell.h"
 #ifdef MOZILLA_INTERNAL_API
 #include "nsReadableUtils.h"
 #else
 #include "nsComponentManagerUtils.h"
 #endif
 #include "EmbedWindow.h"
 #include "EmbedPrivate.h"
 #include "EmbedPrompter.h"
 
 GtkWidget *EmbedWindow::sTipWindow = nsnull;
 
 EmbedWindow::EmbedWindow(void)
 {
   mOwner       = nsnull;
   mVisibility  = PR_FALSE;
   mIsModal     = PR_FALSE;
+  mJSFocusEmit = PR_TRUE;
+  mHidden      = 0;
 }
 
 EmbedWindow::~EmbedWindow(void)
 {
   ExitModalEventLoop(PR_FALSE);
 }
 
 nsresult
@@ -123,16 +127,17 @@
 NS_IMPL_ADDREF(EmbedWindow)
 NS_IMPL_RELEASE(EmbedWindow)
 
 NS_INTERFACE_MAP_BEGIN(EmbedWindow)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebBrowserChrome)
   NS_INTERFACE_MAP_ENTRY(nsIWebBrowserChrome)
   NS_INTERFACE_MAP_ENTRY(nsIWebBrowserChromeFocus)
   NS_INTERFACE_MAP_ENTRY(nsIEmbeddingSiteWindow)
+  NS_INTERFACE_MAP_ENTRY(nsIEmbeddingSiteWindow2)
 //  NS_INTERFACE_MAP_ENTRY(nsITooltipListener)
   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
 NS_INTERFACE_MAP_END
 
 // nsIWebBrowserChrome
 
 NS_IMETHODIMP
 EmbedWindow::SetStatus(PRUint32 aStatusType, const PRUnichar *aStatus)
@@ -271,68 +276,111 @@
 // nsIEmbeddingSiteWindow
 
 NS_IMETHODIMP
 EmbedWindow::SetDimensions(PRUint32 aFlags, PRInt32 aX, PRInt32 aY,
          PRInt32 aCX, PRInt32 aCY)
 {
   if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION &&
       (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
-     nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER))) {
-    return mBaseWindow->SetPositionAndSize(aX, aY, aCX, aCY, PR_TRUE);
+    nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER))) {
+    mBaseWindow->SetPositionAndSize(aX, aY, aCX, aCY, PR_TRUE);
   }
   else if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION) {
-    return mBaseWindow->SetPosition(aX, aY);
+    mBaseWindow->SetPosition(aX, aY);
   }
   else if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
-         nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER)) {
-    return mBaseWindow->SetSize(aCX, aCY, PR_TRUE);
+    nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER)) {
+    mBaseWindow->SetSize(aCX, aCY, PR_TRUE);
+  }
+
+  if(aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_VERTICAL)
+  {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    NS_ENSURE_TRUE(webBrowser, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIDocShell> docShell(do_GetInterface((nsISupports*)webBrowser));
+    NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsPresContext> context;
+    docShell->GetPresContext(getter_AddRefs(context));
+    NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIPresShell> presShell = context->GetPresShell();
+    NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
+    presShell->StyleChangeReflow();
   }
-  return NS_ERROR_INVALID_ARG;
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetDimensions(PRUint32 aFlags, PRInt32 *aX,
          PRInt32 *aY, PRInt32 *aCX, PRInt32 *aCY)
 {
-  if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION &&
-      (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
-     nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER))) {
-    return mBaseWindow->GetPositionAndSize(aX, aY, aCX, aCY);
-  }
-  else if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION) {
-    return mBaseWindow->GetPosition(aX, aY);
-  }
-  else if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
+  nsresult rv = NS_ERROR_INVALID_ARG;
+  if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION && aX && aY) {
+    GdkWindow *window = gtk_widget_get_parent_window(GTK_WIDGET(mOwner->mOwningWidget));
+    if (window) {
+      gdk_window_get_position(window, aX, aY);
+      rv = NS_OK;
+    }
+  } else
+    rv = NS_OK;
+  if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
          nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER)) {
-    return mBaseWindow->GetSize(aCX, aCY);
+    rv |= mBaseWindow->GetSize(aCX, aCY);
   }
-  return NS_ERROR_INVALID_ARG;
+  return rv;
 }
 
 NS_IMETHODIMP
 EmbedWindow::SetFocus(void)
 {
   // XXX might have to do more here.
-  return mBaseWindow->SetFocus();
+  gboolean return_val = FALSE;
+  nsresult rv = NS_OK;
+  rv = mBaseWindow->SetFocus();
+  if (mJSFocusEmit && mOwner->mOwningWidget)
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_WINDOW_FOCUS],
+                    &return_val);
+  return rv;
+}
+
+NS_IMETHODIMP
+EmbedWindow::Blur(void)
+{
+  // XXX might have to do more here.
+  gboolean handled = FALSE;
+  if (mOwner->mOwningWidget)
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_WINDOW_BLUR],
+                    &handled);
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetTitle(PRUnichar **aTitle)
 {
   *aTitle = ToNewUnicode(mTitle);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::SetTitle(const PRUnichar *aTitle)
 {
   mTitle = aTitle;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
       moz_embed_signals[TITLE]);
+  if (mHidden == 1) {
+    mOwner->Hide();
+    mHidden = 2;
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetSiteWindow(void **aSiteWindow)
 {
   GtkWidget *ownerAsWidget(GTK_WIDGET(mOwner->mOwningWidget));
   *aSiteWindow = static_cast<void *>(ownerAsWidget);
@@ -394,17 +442,17 @@
   if (sTipWindow)
     gtk_widget_destroy(sTipWindow);
 
   // get the root origin for this content window
   nsCOMPtr<nsIWidget> mainWidget;
   mBaseWindow->GetMainWidget(getter_AddRefs(mainWidget));
   GdkWindow *window;
   window = static_cast<GdkWindow *>
-                      (mainWidget->GetNativeData(NS_NATIVE_WINDOW));
+        (mainWidget->GetNativeData(NS_NATIVE_WINDOW));
   gint root_x, root_y;
   gdk_window_get_origin(window, &root_x, &root_y);
 
   // XXX work around until I can get pink to figure out why
   // tooltips vanish if they show up right at the origin of the
   // cursor.
   root_y += 10;
 
Index: mozilla/embedding/browser/gtk/src/EmbedWindow.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindow.h
+++ mozilla/embedding/browser/gtk/src/EmbedWindow.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -43,65 +43,70 @@
 #ifdef MOZILLA_INTERNAL_API
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #endif
 #include "nsIWebBrowserChrome.h"
 #include "nsIWebBrowserChromeFocus.h"
 #include "nsIEmbeddingSiteWindow.h"
+#include "nsIEmbeddingSiteWindow2.h"
 //#include "nsITooltipListener.h"
 #include "nsISupports.h"
 #include "nsIWebBrowser.h"
 #include "nsIBaseWindow.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsCOMPtr.h"
 
 #include <gtk/gtk.h>
 
 class EmbedPrivate;
 
 class EmbedWindow : public nsIWebBrowserChrome,
         public nsIWebBrowserChromeFocus,
-                    public nsIEmbeddingSiteWindow,
+        public nsIEmbeddingSiteWindow2,
 //                    public nsITooltipListener,
         public nsIInterfaceRequestor
 {
 
  public:
 
   EmbedWindow();
   virtual ~EmbedWindow();
 
   nsresult Init            (EmbedPrivate *aOwner);
   nsresult CreateWindow    (void);
   void     ReleaseChildren (void);
+  void     EnableFocusEmit (PRBool aEnable = PR_TRUE) { mJSFocusEmit = aEnable; };
 
   NS_DECL_ISUPPORTS
 
   NS_DECL_NSIWEBBROWSERCHROME
 
   NS_DECL_NSIWEBBROWSERCHROMEFOCUS
 
   NS_DECL_NSIEMBEDDINGSITEWINDOW
 
+  NS_DECL_NSIEMBEDDINGSITEWINDOW2
+
 //  NS_DECL_NSITOOLTIPLISTENER
 
   NS_DECL_NSIINTERFACEREQUESTOR
 
   nsString                 mTitle;
   nsString                 mJSStatus;
   nsString                 mLinkMessage;
 
   nsCOMPtr<nsIBaseWindow>  mBaseWindow; // [OWNER]
+  PRInt32                  mHidden;
 
 private:
 
   EmbedPrivate            *mOwner;
   nsCOMPtr<nsIWebBrowser>  mWebBrowser; // [OWNER]
   static GtkWidget        *sTipWindow;
   PRBool                   mVisibility;
   PRBool                   mIsModal;
-
+  PRBool                   mJSFocusEmit;
 };
 
 
 #endif /* __EmbedWindow_h */
Index: mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindowCreator.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp
@@ -12,17 +12,17 @@
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard.
- *
+ * Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -94,24 +94,24 @@
 
   // The window _must_ be realized before we pass it back to the
   // function that created it. Functions that create new windows
   // will do things like GetDocShell() and the widget has to be
   // realized before that can happen.
   gtk_widget_realize(GTK_WIDGET(newEmbed));
 
   EmbedPrivate *newEmbedPrivate = static_cast<EmbedPrivate *>
-                                             (newEmbed->data);
+             (newEmbed->data);
 
   // set the chrome flag on the new window if it's a chrome open
   if (aChromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME)
     newEmbedPrivate->mIsChrome = PR_TRUE;
 
   *_retval = static_cast<nsIWebBrowserChrome *>
-                        ((newEmbedPrivate->mWindow));
+            (newEmbedPrivate->mWindow);
 
   if (*_retval) {
     NS_ADDREF(*_retval);
     return NS_OK;
   }
 
   return NS_ERROR_FAILURE;
 }
Index: mozilla/embedding/browser/gtk/src/EmbedWindowCreator.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindowCreator.h
+++ mozilla/embedding/browser/gtk/src/EmbedWindowCreator.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
Index: mozilla/embedding/browser/gtk/src/GtkPromptService.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/GtkPromptService.cpp
+++ mozilla/embedding/browser/gtk/src/GtkPromptService.cpp
@@ -49,16 +49,17 @@
 #else
 #include "nsStringAPI.h"
 #endif
 #include "nsIWindowWatcher.h"
 #include "nsIWebBrowserChrome.h"
 #include "nsIEmbeddingSiteWindow.h"
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
+#include "EmbedEventListener.h"
 
 #define UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(newed) PR_BEGIN_MACRO \
   /* OOPS this code is using a glib allocation function which     \
    * will cause the application to crash when it runs out of      \
    * memory. This is not cool. either g_try methods should be     \
    * used or malloc, or new (note that gecko /will/ be replacing  \
    * its operator new such that new will not throw exceptions).   \
    * XXX please fix me.                                           \
@@ -70,26 +71,31 @@
 GtkPromptService::GtkPromptService()
 {
 }
 
 GtkPromptService::~GtkPromptService()
 {
 }
 
+#ifdef NECKO_COOKIES
 NS_IMPL_ISUPPORTS2(GtkPromptService, nsIPromptService, nsICookiePromptService)
+#else
+NS_IMPL_ISUPPORTS1(GtkPromptService, nsIPromptService)
+#endif
 
 NS_IMETHODIMP
 GtkPromptService::Alert(
   nsIDOMWindow* aParent,
   const PRUnichar* aDialogTitle,
   const PRUnichar* aDialogText)
 {
   GtkWidget* parentWidget = GetGtkWidgetForDOMWindow(aParent);
   if (parentWidget && gtk_signal_handler_pending(parentWidget, moz_embed_signals[ALERT], TRUE)) {
+    EmbedEventListener::DisableLongPressTimer(parentWidget);
     gtk_signal_emit(GTK_OBJECT(parentWidget),
       moz_embed_signals[ALERT],
       (const gchar *) NS_ConvertUTF16toUTF8(aDialogTitle).get(),
       (const gchar *) NS_ConvertUTF16toUTF8(aDialogText).get());
     return NS_OK;
   }
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
   EmbedPrompter prompter;
@@ -469,17 +475,17 @@
     for (PRUint32 i = 0; i < aCount; ++i) {
       itemList[i] = ToNewCString(NS_ConvertUTF16toUTF8(aSelectList[i]));
       list = g_list_append(list, (gpointer)itemList[i].get());
     }
     gtk_signal_emit(GTK_OBJECT(parentWidget),
                     moz_embed_signals[SELECT],
                     NS_ConvertUTF16toUTF8(aDialogTitle).get(),
                     NS_ConvertUTF16toUTF8(aDialogText).get(),
-                    (const GList**)&list,
+                    list,
                     outSelection,
                     aConfirm);
     delete[] itemList;
     g_list_free(list);
     return NS_OK;
   }
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
   EmbedPrompter prompter;
@@ -489,16 +495,18 @@
   prompter.Create(EmbedPrompter::TYPE_SELECT,
                   GetGtkWindowForDOMWindow(aParent));
   prompter.Run();
   prompter.GetSelectedItem(outSelection);
   prompter.GetConfirmValue(aConfirm);
 #endif
   return NS_OK;
 }
+
+#ifdef NECKO_COOKIES
 /* nsCookiePromptService */
 NS_IMETHODIMP
 GtkPromptService::CookieDialog(
   nsIDOMWindow *aParent,
   nsICookie *aCookie,
   const nsACString &aHostname,
   PRInt32 aCookiesFromHost,
   PRBool aChangingCookie,
@@ -519,17 +527,19 @@
   /* We have to investigate a value to use here */
   gboolean illegal_path = FALSE;
   PRUint64 aExpires;
   aCookie->GetExpires(&aExpires);
   nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aParent));
   GtkMozEmbed *parentWidget = GTK_MOZ_EMBED(GetGtkWidgetForDOMWindow(domWindow));
   GtkMozEmbedCookie *cookie_struct = g_new0(GtkMozEmbedCookie, 1);
   UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(cookie_struct);
-  if (parentWidget && cookie_struct) {
+  if (!cookie_struct) return NS_ERROR_OUT_OF_MEMORY;
+
+  if (parentWidget) {
     g_signal_emit_by_name(
       GTK_OBJECT(parentWidget->common),
       "ask-cookie",
       cookie_struct,
       actions,
       (const gchar *) hostName.get(),
       (const gchar *) aName.get(),
       (const gchar *) aValue.get(),
@@ -538,16 +548,17 @@
       illegal_path,
       aExpires,
       NULL);
   }
   *aRememberDecision = !!(cookie_struct->remember_decision);
   *aAccept = cookie_struct->accept;
   return NS_OK;
 }
+#endif
 
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 void
 GtkPromptService::GetButtonLabel(
   PRUint32 aFlags,
   PRUint32 aPos,
   const PRUnichar* aStringValue,
   nsAString& aLabel)
Index: mozilla/embedding/browser/gtk/src/GtkPromptService.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/GtkPromptService.h
+++ mozilla/embedding/browser/gtk/src/GtkPromptService.h
@@ -34,39 +34,45 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIPromptService.h"
+#ifdef NECKO_COOKIES
 #include "nsICookiePromptService.h"
 #include "nsICookie.h"
+#endif
 #include "nsNetCID.h"
 #include <gtk/gtk.h>
 #ifdef MOZILLA_INTERNAL_API
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #endif
 #define NS_PROMPTSERVICE_CID \
  {0x95611356, 0xf583, 0x46f5, {0x81, 0xff, 0x4b, 0x3e, 0x01, 0x62, 0xc6, 0x19}}
 
 class nsIDOMWindow;
 
-class GtkPromptService : public nsIPromptService,
-                         public nsICookiePromptService
+class GtkPromptService : public nsIPromptService
+#ifdef NECKO_COOKIES
+                         , public nsICookiePromptService
+#endif
 {
 public:
     GtkPromptService();
     virtual ~GtkPromptService();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIPROMPTSERVICE
+#ifdef NECKO_COOKIES
     NS_DECL_NSICOOKIEPROMPTSERVICE
+#endif
 
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 private:
     void GetButtonLabel(PRUint32 aFlags, PRUint32 aPos,
                         const PRUnichar* aStringValue, nsAString &aLabel);
 #endif
 };
Index: mozilla/embedding/browser/gtk/src/Makefile.in
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/Makefile.in
+++ mozilla/embedding/browser/gtk/src/Makefile.in
@@ -64,24 +64,20 @@
 endif
 endif
 
 DEFINES += -DIMPL_XREAPI
 
 # New Stuff in GtkMozEmbed
 ifdef MOZ_MICROBEMBED
 DEFINES += -DBAD_CERT_LISTENER2
-#Probably scrolling can be fixed without this hack
-DEFINES += -DMOZ_SCROLL_TOP_LEFT_HACK
 
-MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT = 1
-DEFINES += -DMOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
+#MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT = 1
+#DEFINES += -DMOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 
-MOZ_GTKPASSWORD_INTERFACE = 1
-DEFINES += -DMOZ_GTKPASSWORD_INTERFACE
 endif
 
 REQUIRES	= xpcom \
 		  string \
 		  content \
 		  docshell \
 		  necko \
 		  widget \
@@ -109,16 +105,22 @@
 		  exthandler \
 		  mimetype \
 		  chardet \
 		  find \
 		  webbrowserpersist \
 		  cookie \
 		  nkcache \
 		  pipboot \
+		  view \
+		  plugin \
+		  commandhandler \
+		  extensions \
+		  rdf \
+		  toolkitcomps \
 		  $(NULL)
 
 ifdef ACCESSIBILITY
 REQUIRES        += accessibility
 endif
 
 CPPSRCS		= \
 		gtkmozembed2.cpp \
@@ -137,27 +139,16 @@
 		gtkmozembed_download.cpp \
 		EmbedContextMenuInfo.cpp \
 		EmbedCertificates.cpp \
 		EmbedDownloadMgr.cpp \
 		EmbedGlobalHistory.cpp \
 		EmbedFilePicker.cpp \
 		$(NULL)
 
-ifdef MOZ_GTKPASSWORD_INTERFACE
-CPPSRCS		+= \
-		EmbedPasswordMgr.cpp \
-		$(NULL)
-
-XPIDLSRCS       += \
-		nsIPassword.idl \
-		nsIPasswordInternal.idl \
-		$(NULL)
-endif
-
 CSRCS           = \
 		gtkmozembedmarshal.c
 
 CPPSRCS         += \
 		GtkPromptService.cpp \
 		$(NULL)
 
 ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
Index: mozilla/embedding/browser/gtk/src/gtkmozembed.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *   Antonio Gomes <tonikitoo@gmail.com>
@@ -175,23 +175,29 @@
   gint     (* confirm_ex)      (GtkMozEmbed *embed, const char *title, const char *text, guint bt_flags,
                                 const char *button1, const char *button2, const char *button3,
                                 const char *check_msg, gboolean *check_val);
   gboolean (* prompt)          (GtkMozEmbed *embed, const char *title, const char *text,
                                 char **value, const char *check_msg, gboolean *check_val);
   gboolean (* prompt_auth)     (GtkMozEmbed *embed, const char *title, const char *text,
                                 char **user, char **pass, const char *check_msg, gboolean *check_val);
   gboolean (* select)          (GtkMozEmbed *embed, const char *title, const char *text,
-                                GList *list, gint *selected_item);
-  void     (* download_request)(GtkMozEmbed *, const char *, const char *, const char *, long, int, gpointer);
-  gboolean (* upload_dialog)   (GtkMozEmbed *, const char *, const char *, char **);
-  void     (* icon_changed)    (GtkMozEmbed *, gpointer*);
-  void     (* mailto)          (GtkMozEmbed *, gchar *);
-  void     (* network_error)   (GtkMozEmbed *, gchar *, const gint, const gchar **);
-  void     (* rss_request)     (GtkMozEmbed *, gchar *, gchar *);
+                                gpointer list, gpointer selected_item);
+  void     (* download_request)(GtkMozEmbed *embed, const char *, const char *, const char *, long, int, gpointer);
+  gboolean (* upload_dialog)   (GtkMozEmbed *embed);
+  void     (* file_upload_started)(GtkMozEmbed *embed);
+  void     (* file_upload_finished)(GtkMozEmbed *embed);
+  void     (* icon_changed)    (GtkMozEmbed *embed, gpointer*);
+  void     (* mailto)          (GtkMozEmbed *embed, gchar *);
+  void     (* network_error)   (GtkMozEmbed *embed, gchar *, const gint, const gchar **);
+  void     (* rss_request)     (GtkMozEmbed *embed, gchar *, gchar *);
+  gint     (* dom_window_focus)(GtkMozEmbed *embed);
+  gint     (* dom_window_blur) (GtkMozEmbed *embed);
+  void     (* dom_content_blocked)(GtkMozEmbed *embed, const char *aURI,const char * url);
+
 };
 
 GTKMOZEMBED_API(GtkType,       gtk_moz_embed_get_type,            (void))
 GTKMOZEMBED_API(GtkWidget*,    gtk_moz_embed_new,                 (void))
 GTKMOZEMBED_API(void,          gtk_moz_embed_push_startup,        (void))
 GTKMOZEMBED_API(void,          gtk_moz_embed_pop_startup,         (void))
 
 /* Tell gtkmozembed where the gtkmozembed libs live. If this is not specified,
@@ -229,22 +235,25 @@
 GTKMOZEMBED_API(void,          gtk_moz_embed_set_encoding,        (GtkMozEmbed *embed, const gchar *, gint))
 GTKMOZEMBED_API(guint,         gtk_moz_embed_get_context_info,    (GtkMozEmbed *embed, gpointer event, gpointer *node,
                                                                    gint *x, gint *y, gint *docindex,
                                                                    const gchar **url, const gchar **objurl, const gchar **docurl))
 GTKMOZEMBED_API(const gchar*,  gtk_moz_embed_get_selection,       (GtkMozEmbed *embed))
 GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_doc_info,        (GtkMozEmbed *embed, gpointer node, gint docindex, const gchar**title,
                                                                    const gchar**location, const gchar **file_type, guint *file_size,
                                                                    gint *width, gint *height))
-GTKMOZEMBED_API(gboolean,      gtk_moz_embed_insert_text,         (GtkMozEmbed *embed, const gchar*, gpointer node))
-GTKMOZEMBED_API(gboolean,      gtk_moz_embed_save_target,         (GtkMozEmbed *embed, gchar*, gchar*, gint))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_insert_text,         (GtkMozEmbed *embed, const gchar*, gpointer node, gint surr1, gint surr2))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_save_target,         (GtkMozEmbed *embed, const gchar*, const gchar*, gint, gpointer))
 GTKMOZEMBED_API(gint,          gtk_moz_embed_get_shistory_list,   (GtkMozEmbed *embed, GtkMozHistoryItem **GtkHI, guint type))
 GTKMOZEMBED_API(gint,          gtk_moz_embed_get_shistory_index,  (GtkMozEmbed *embed))
 GTKMOZEMBED_API(void,          gtk_moz_embed_shistory_goto_index, (GtkMozEmbed *embed, gint index))
 GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_server_cert,     (GtkMozEmbed *embed, gpointer *aCert, gpointer))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_text,            (GtkMozEmbed *embed, gchar**, gint *curpos))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_load_image,          (GtkMozEmbed *embed, const gchar*))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_do_command,          (GtkMozEmbed *embed, const gchar*, gint, gpointer))
 
 typedef enum
 {
   GTK_MOZ_EMBED_BACK_SHISTORY,
   GTK_MOZ_EMBED_FORWARD_SHISTORY
 } GtkMozEmbedSessionHistory;
 
 typedef enum
@@ -262,21 +271,23 @@
 {
   GTK_MOZ_EMBED_CTX_NONE       = 0,
   GTK_MOZ_EMBED_CTX_XUL        = 1 << 1,
   GTK_MOZ_EMBED_CTX_SIDEBAR    = 1 << 2,
   GTK_MOZ_EMBED_CTX_DOCUMENT   = 1 << 3,
   GTK_MOZ_EMBED_CTX_LINK       = 1 << 4,
   GTK_MOZ_EMBED_CTX_IMAGE      = 1 << 5,
   GTK_MOZ_EMBED_CTX_IFRAME     = 1 << 6,
-  GTK_MOZ_EMBED_CTX_INPUT      = 1 << 7,
+  GTK_MOZ_EMBED_CTX_INPUT_TEXT = 1 << 7,
   GTK_MOZ_EMBED_CTX_IPASSWORD  = 1 << 8,
   GTK_MOZ_EMBED_CTX_EMAIL      = 1 << 9,
   GTK_MOZ_EMBED_CTX_RICHEDIT   = 1 << 10,
-  GTK_MOZ_EMBED_CTX_ROINPUT    = 1 << 11
+  GTK_MOZ_EMBED_CTX_ROINPUT    = 1 << 11,
+  GTK_MOZ_EMBED_CTX_MULTILINE  = 1 << 12,
+  GTK_MOZ_EMBED_CTX_SELECT     = 1 << 13
 } GtkMozEmbedContext;
 typedef enum
 {
   GTK_MOZ_EMBED_DIALOG_BUTTON_OK,
   GTK_MOZ_EMBED_DIALOG_BUTTON_CANCEL,
   GTK_MOZ_EMBED_DIALOG_BUTTON_YES,
   GTK_MOZ_EMBED_DIALOG_BUTTON_NO,
   GTK_MOZ_EMBED_DIALOG_BUTTON_SAVE,
Index: mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed2.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp
@@ -12,17 +12,17 @@
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard.
- *
+ * Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *   Antonio Gomes <tonikitoo@gmail.com>
@@ -75,16 +75,19 @@
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
 #else
 #include "nsStringAPI.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #endif
 
+#include "nsIImageLoadingContent.h"
+#include "nsIDOMNodeList.h"
+
 #include "gtkmozembedmarshal.h"
 
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
 class nsIDirectoryServiceProvider;
 
 // class and instance initialization
@@ -513,22 +516,22 @@
                    GTK_TYPE_POINTER,
                    GTK_TYPE_STRING,
                    GTK_TYPE_POINTER);
   moz_embed_signals[SELECT] =
     gtk_signal_new("select",
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, select),
-                   gtkmozembed_BOOL__STRING_STRING_POINTER_INT,
+                   gtkmozembed_BOOL__STRING_STRING_POINTER_POINTER,
                    GTK_TYPE_BOOL, 4,
                    GTK_TYPE_STRING,
                    GTK_TYPE_STRING,
                    GTK_TYPE_POINTER,
-                   GTK_TYPE_INT);
+                   GTK_TYPE_POINTER);
   moz_embed_signals[DOWNLOAD_REQUEST] =
     gtk_signal_new("download_request",
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, download_request),
                    gtkmozembed_VOID__STRING_STRING_STRING_ULONG_INT,
                    GTK_TYPE_NONE,
                    5,
@@ -544,16 +547,32 @@
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, upload_dialog),
                    gtkmozembed_BOOL__STRING_STRING_POINTER,
                    GTK_TYPE_BOOL,
                    3,
                    GTK_TYPE_STRING,
                    GTK_TYPE_STRING,
                    GTK_TYPE_POINTER);
+  moz_embed_signals[FILE_UPLOAD_STARTED] =
+    gtk_signal_new("file_upload_started",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, file_upload_started),
+                   gtk_marshal_VOID__VOID,
+                   GTK_TYPE_NONE,
+                   0);
+  moz_embed_signals[FILE_UPLOAD_FINISHED] =
+    gtk_signal_new("file_upload_finished",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, file_upload_finished),
+                   gtk_marshal_VOID__VOID,
+                   GTK_TYPE_NONE,
+                   0);
   moz_embed_signals[ICON_CHANGED] =
     gtk_signal_new("icon_changed",
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, icon_changed),
                    gtkmozembed_VOID__POINTER,
                    GTK_TYPE_NONE,
                    1,
@@ -585,16 +604,40 @@
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, rss_request),
                    gtkmozembed_VOID__STRING_STRING,
                    GTK_TYPE_NONE,
                    2,
                    GTK_TYPE_STRING, GTK_TYPE_STRING);
 
+  moz_embed_signals[DOM_WINDOW_BLUR] =
+    gtk_signal_new("dom_window_blur",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_window_blur),
+                   gtk_marshal_BOOL__NONE,
+                   GTK_TYPE_BOOL, 0);
+
+  moz_embed_signals[DOM_WINDOW_FOCUS] =
+    gtk_signal_new("dom_window_focus",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_window_focus),
+                   gtk_marshal_BOOL__NONE,
+                   GTK_TYPE_BOOL, 0);
+
+  moz_embed_signals[DOM_CONTENT_BLOCKED] =
+    gtk_signal_new("dom_content_blocked",
+                   GTK_RUN_FIRST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_content_blocked),
+                   gtk_marshal_NONE__POINTER_POINTER,
+                   GTK_TYPE_NONE, 2,
+                   GTK_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE,GTK_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE);
 }
 
 static void
 gtk_moz_embed_init(GtkMozEmbed *embed)
 {
   EmbedPrivate *priv = new EmbedPrivate();
   embed->data = priv;
   embed->common = NULL;
@@ -788,18 +831,17 @@
 static AtkObject*
 gtk_moz_embed_get_accessible (GtkWidget *widget)
 {
   g_return_val_if_fail(widget != NULL, NULL);
   g_return_val_if_fail(GTK_IS_MOZ_EMBED(widget), NULL);
 
   GtkMozEmbed  *embed = GTK_MOZ_EMBED(widget);;
   EmbedPrivate *embedPrivate = (EmbedPrivate *)embed->data;
-  return static_cast<AtkObject *>
-                    (embedPrivate->GetAtkObjectForCurrentDocument());
+  return static_cast<AtkObject *>(embedPrivate->GetAtkObjectForCurrentDocument());
 }
 #endif /* MOZ_ACCESSIBILITY_ATK */
 
 static gint
 handle_child_focus_in(GtkWidget     *aWidget,
                       GdkEventFocus *aGdkFocusEvent,
                       GtkMozEmbed   *aEmbed)
 {
@@ -1378,19 +1420,26 @@
   g_return_val_if_fail (embed != NULL, FALSE);
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), FALSE);
   g_return_val_if_fail (GTK_WIDGET_REALIZED(GTK_WIDGET(embed)), FALSE);
   embedPrivate = (EmbedPrivate *)embed->data;
   return embedPrivate->ClipBoardAction((GtkMozEmbedClipboard)action) ? TRUE : FALSE;
 }
 
 void
-gtk_moz_embed_notify_plugins(GtkMozEmbed *embed, guint)
+gtk_moz_embed_notify_plugins(GtkMozEmbed *embed, guint event)
 {
-  return;
+    EmbedPrivate *embedPrivate;
+    g_return_if_fail ((embed != NULL));
+    g_return_if_fail (GTK_IS_MOZ_EMBED(embed));
+
+    embedPrivate = (EmbedPrivate *)embed->data;
+    embedPrivate->NotifyPlugins(event);
+
+    return;
 }
 
 gchar *
 gtk_moz_embed_get_encoding(GtkMozEmbed *embed, gint frame_number)
 {
   gchar *retval = nsnull;
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail ((embed != NULL), (gchar *)NULL);
@@ -1475,103 +1524,157 @@
     if (!ctx_menu)
       return NULL;
     return ctx_menu->GetSelectedText();
   }
 
   return NULL;
 }
 gboolean
-gtk_moz_embed_insert_text(GtkMozEmbed *embed, const gchar *string, gpointer node)
+gtk_moz_embed_insert_text(GtkMozEmbed *embed, const gchar *string, gpointer node, gint surr1, gint surr2)
 {
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail(embed != NULL, FALSE);
   g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
   embedPrivate = (EmbedPrivate *)embed->data;
   if (!embedPrivate || !embedPrivate->mEventListener)
     return FALSE;
   if (!string && node) {
     embedPrivate->ScrollToSelectedNode((nsIDOMNode*)node);
     return TRUE;
   }
   if (string) {
-    embedPrivate->InsertTextToNode((nsIDOMNode*)node, string);
+    embedPrivate->InsertTextToNode((nsIDOMNode*)node, string, surr1, surr2);
     return TRUE;
   }
   return FALSE;
 }
 
+gboolean
+gtk_moz_embed_get_text(GtkMozEmbed *embed, gchar** string, gint *curpos)
+{
+  EmbedPrivate *embedPrivate;
+  g_return_val_if_fail(embed != NULL, FALSE);
+  g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
+  embedPrivate = (EmbedPrivate *)embed->data;
+  if (!embedPrivate || !embedPrivate->mEventListener)
+    return FALSE;
+
+  if(embedPrivate->GetTextAndCursorPosition((gchar**)string, curpos))
+    return TRUE;
+
+  return FALSE;
+}
+
+gboolean
+gtk_moz_embed_do_command(GtkMozEmbed *embed,
+                        const gchar* command_name,
+                        gint count, gpointer object)
+{
+  EmbedPrivate *embedPrivate;
+  g_return_val_if_fail(command_name, FALSE);
+  g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
+  embedPrivate = (EmbedPrivate *)embed->data;
+  if (!embedPrivate)
+    return FALSE;
+  return NS_SUCCEEDED(embedPrivate->DoCommand(command_name, count, (nsIDOMNode*)object))?TRUE:FALSE;
+}
 
 gboolean
-gtk_moz_embed_save_target(GtkMozEmbed *aEmbed, gchar* aUrl,
-                          gchar* aDestination, gint aSetting)
+gtk_moz_embed_save_target(GtkMozEmbed *aEmbed, const gchar* aUrl,
+                          const gchar* aDestination, gint aSetting, gpointer aCtx)
 {
   //FIXME
   nsresult rv;
+  nsCOMPtr<nsIDOMWindow> DOMWindow;
 
-  g_return_val_if_fail (aEmbed != NULL, FALSE);
-  nsIWebBrowser *webBrowser = nsnull;
-  gtk_moz_embed_get_nsIWebBrowser(GTK_MOZ_EMBED(aEmbed), &webBrowser);
-  g_return_val_if_fail (webBrowser != NULL, FALSE);
+  if (aCtx) {
+    nsCOMPtr<nsIDOMNode> node = do_QueryInterface((nsISupports*)aCtx, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    EmbedPrivate *embedPrivate;
+    embedPrivate = (EmbedPrivate *) aEmbed->data;
+    rv = embedPrivate->GetDOMWindowByNode(node, getter_AddRefs(DOMWindow));
+  } else {
+    g_return_val_if_fail (aEmbed != NULL, FALSE);
+    nsIWebBrowser *webBrowser = nsnull;
+    gtk_moz_embed_get_nsIWebBrowser(GTK_MOZ_EMBED(aEmbed), &webBrowser);
+    g_return_val_if_fail (webBrowser != NULL, FALSE);
 
-  nsCOMPtr<nsIDOMWindow> DOMWindow;
-  webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
-  g_return_val_if_fail (DOMWindow != NULL, FALSE);
+    webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
+    g_return_val_if_fail (DOMWindow != NULL, FALSE);
+  }
 
   nsCOMPtr<nsIDOMDocument> doc;
   DOMWindow->GetDocument(getter_AddRefs(doc));
   g_return_val_if_fail (doc != NULL, FALSE);
 
+
   nsCOMPtr<nsIWebBrowserPersist> persist =
     do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
   if (!persist)
     return FALSE;
 
   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios)
     return FALSE;
 
   nsCOMPtr<nsIURI> uri;
   rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
   if (!uri)
     return FALSE;
 
-  if (aSetting == 0)
-  {
+  if (aSetting == 0) {
     nsCOMPtr<nsIURI> uri_s;
     rv = ios->NewURI(nsDependentCString(aUrl), "", nsnull, getter_AddRefs(uri_s));
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
 
     if (!uri_s)
       return FALSE;
-    rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);  
+    //rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);
+    rv = persist->SaveDocument(doc, uri, nsnull, nsnull, 0, 0);
 
     if (NS_SUCCEEDED(rv))
       return TRUE;
 
-  } else if (aSetting == 1)
-  {
+  }
+  else if (aSetting == 1) {
     nsCOMPtr<nsIURI> contentFolder;
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(contentFolder));
 
     nsCString contentFolderPath;
     contentFolder->GetSpec(contentFolderPath);
     contentFolderPath.Append("_content");
     printf("GetNativePath=%s ", contentFolderPath.get());
     rv = ios->NewURI(contentFolderPath, "", nsnull, getter_AddRefs(contentFolder));
 
     if (NS_FAILED(rv))
       return FALSE;
     
     rv = persist->SaveDocument(doc, uri, contentFolder, nsnull, 0, 0);
     if (NS_SUCCEEDED(rv))
       return TRUE;
-  } else if (aSetting == 2)
-  {
+  }
+  else if (aSetting == 2) {
+    nsCOMPtr<nsIURI> uri_s;
+    rv = ios->NewURI(nsDependentCString(aUrl), "", nsnull, getter_AddRefs(uri_s));
+    rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
+
+    PRInt32 persist_flags = nsIWebBrowserPersist::PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION;
+    persist->SetPersistFlags(persist_flags);
+
+    if (!uri_s)
+      return FALSE;
+    rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);
+
+    if (NS_SUCCEEDED(rv))
+      return TRUE;
+    return FALSE;
+  }
+  else if (aSetting == 3) {
     // FIXME: How should I handle this option G_WEBENGINE_SAVE_FRAMES ?
     return FALSE;
   }
   return FALSE;
 }
 
 gboolean
 gtk_moz_embed_get_doc_info(GtkMozEmbed *embed, gpointer node, gint docindex,
@@ -1589,26 +1692,26 @@
   if (file_type) {
     embedPrivate->GetMIMEInfo(file_type, (nsIDOMNode*)node);
   }
 
   if (width && height) {
     nsString imgSrc;
     EmbedContextMenuInfo * ctx_menu = embedPrivate->mEventListener->GetContextInfo();
     if (ctx_menu)
-      ctx_menu->CheckDomImageElement((nsIDOMNode*)node, imgSrc, width, height);
+      ctx_menu->CheckDomImageElement((nsIDOMNode*)node, imgSrc, width, height, file_size);
   }
 
   if (title) {
     EmbedContextMenuInfo * ctx_menu = embedPrivate->mEventListener->GetContextInfo();
     if (ctx_menu)
       *title = NEW_TOOLKIT_STRING(ctx_menu->GetCtxDocTitle());
   }
 
-  if (file_size && location && *location != nsnull) {
+  if (file_size && *file_size == 0 && location && *location != nsnull) {
     nsCOMPtr<nsICacheEntryDescriptor> descriptor;
     nsresult rv;
     rv = embedPrivate->GetCacheEntry("HTTP", *location, nsICache::ACCESS_READ, PR_FALSE, getter_AddRefs(descriptor));
     if (descriptor) {
       rv = descriptor->GetDataSize(file_size);
     }
   }
 
@@ -1631,17 +1734,17 @@
 }
 
 gint
 gtk_moz_embed_get_shistory_index(GtkMozEmbed *embed)
 {
   g_return_val_if_fail ((embed != NULL), -1);
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), -1);
 
-  PRInt32 curIndex;
+  PRInt32 curIndex = -1;
   EmbedPrivate *embedPrivate;
   
   embedPrivate = (EmbedPrivate *)embed->data;
   if (embedPrivate->mSessionHistory)
     embedPrivate->mSessionHistory->GetIndex(&curIndex);
 
   return (gint)curIndex;
 }
@@ -1685,8 +1788,69 @@
 
   nsCOMPtr<nsIX509Cert> serverCert;
   SSLStatus->GetServerCert(getter_AddRefs(serverCert));
   if (!serverCert) return FALSE;
 
   *aCert = serverCert;
   return TRUE;
 }
+
+gboolean
+gtk_moz_embed_load_image(GtkMozEmbed *embed, const gchar *url)
+{
+  g_return_val_if_fail(embed != NULL, FALSE);
+  g_return_val_if_fail(url != NULL, FALSE);
+
+  EmbedPrivate *embedPrivate;
+  embedPrivate = (EmbedPrivate *)embed->data;
+
+  if (!embedPrivate || !embedPrivate->mEventListener)
+    return FALSE;
+
+  EmbedContextMenuInfo *ctx_menu = embedPrivate->mEventListener->GetContextInfo();
+  if (!ctx_menu->mCtxDocument)
+    return FALSE;
+
+  nsCOMPtr<nsIDOMNodeList> imgList;
+  nsresult rv = ctx_menu->mCtxDocument->GetElementsByTagName(NS_LITERAL_STRING("img"),
+                                                             getter_AddRefs(imgList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 imgCount;
+  rv = imgList->GetLength(&imgCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  for (guint32 i = 0; i < imgCount; i++) {
+    nsCOMPtr<nsIDOMNode> imgNode;
+    rv = imgList->Item(i, getter_AddRefs(imgNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(imgNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIURI> imgUri;
+    rv = imgContent->GetCurrentURI(getter_AddRefs(imgUri));
+    if (NS_FAILED(rv) || !imgUri)
+      continue;
+
+    nsCAutoString spec;
+    rv = imgUri->GetSpec(spec);
+    if (NS_FAILED(rv))
+      continue;
+
+    if (spec.Equals(url)) {
+      gint tmp_value = 1, cur_value;
+      gtk_moz_embed_common_get_pref(G_TYPE_INT, "permissions.default.image", &cur_value);
+      if (cur_value != 1) {
+        gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &tmp_value);
+        imgContent->ForceReload();
+        gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &cur_value);
+      }
+      else
+        imgContent->ForceReload();
+    }
+  }
+
+  return TRUE;
+}
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_common.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_common.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_common.cpp
@@ -12,17 +12,17 @@
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard.
- *
+ * Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -42,21 +42,16 @@
 #include <stdio.h>
 #include "gtkmozembed.h"
 #include "gtkmozembed_common.h"
 #include "gtkmozembedprivate.h"
 #include "gtkmozembed_internal.h"
 #include "EmbedPrivate.h"
 #include "EmbedWindow.h"
 
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-#include "EmbedPasswordMgr.h"
-#include "nsIPassword.h"
-#endif
-
 #include "EmbedGlobalHistory.h"
 //#include "EmbedDownloadMgr.h"
 // so we can do our get_nsIWebBrowser later...
 #include "nsIWebBrowser.h"
 #include "nsIComponentManager.h"
 #include "nsIServiceManager.h"
 #include "nsIPref.h"
 #include "nsICookieManager.h"
@@ -73,27 +68,48 @@
 #include "nsStringAPI.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #endif
 // for plugins
 #include "nsIDOMNavigator.h"
 #include "nsIDOMPluginArray.h"
 #include "nsIDOMPlugin.h"
-#include <plugin/nsIPluginHost.h>
+#include "nsIPluginHost.h"
 #include "nsIDOMMimeType.h"
 #include "nsIObserverService.h"
 
+#ifdef MOZ_RDF
+#include "nsIRDFDataSource.h"
+#include "nsIRDFService.h"
+#endif
+#include "nsIExtensionManager.h"
+#include "nsICommandLineRunner.h"
+
 //for security
 #include "nsIWebProgressListener.h"
 
 //for cache
 #include "nsICacheService.h"
 #include "nsICache.h"
 
+// for image loading
+#include "nsIDOMDocument.h"
+#include "nsIDOMNodeList.h"
+#include "nsIImageLoadingContent.h"
+#include "nsIDOMHTMLIFrameElement.h"
+#include "nsIDOMHTMLFrameElement.h"
+#include "nsIDOMHTMLDocument.h"
+#include "nsIDOMHTMLCollection.h"
+
+#define EM_RDF_EXT_DES "http://www.mozilla.org/2004/em-rdf#description"
+#define EM_RDF_EXT_CREATOR "http://www.mozilla.org/2004/em-rdf#creator"
+#define EM_RDF_EXT_STATE "http://www.mozilla.org/2004/em-rdf#userDisabled"
+#define EM_RDF_EXT_APP_DISABLED "http://www.mozilla.org/2004/em-rdf#appDisabled"
+
 #include "gtkmozembedmarshal.h"
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_TOOLKIT_STRING(x) NS_ConvertUTF16toUTF8(x).get()
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
 #define UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(newed) PR_BEGIN_MACRO \
   /* OOPS this code is using a glib allocation function which     \
    * will cause the application to crash when it runs out of      \
@@ -387,77 +403,24 @@
     return FALSE;
   nsresult rv = prefService->SavePrefFile (nsnull);
   return NS_SUCCEEDED(rv);
 }
 
 gint
 gtk_moz_embed_common_get_logins(const char* uri, GList **list)
 {
-  gint ret = 0;
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-  EmbedPasswordMgr *passwordManager = EmbedPasswordMgr::GetInstance();
-  nsCOMPtr<nsISimpleEnumerator> passwordEnumerator;
-  nsresult result = passwordManager->GetEnumerator(getter_AddRefs(passwordEnumerator));
-  PRBool enumResult;
-  for (passwordEnumerator->HasMoreElements(&enumResult) ;
-       enumResult == PR_TRUE ;
-       passwordEnumerator->HasMoreElements(&enumResult))
-  {
-    nsCOMPtr<nsIPassword> nsPassword;
-    result = passwordEnumerator->GetNext(getter_AddRefs(nsPassword));
-    if (NS_FAILED(result)) {
-      /* this almost certainly leaks logins */
-      return ret;
-    }
-    nsCString host;
-    nsPassword->GetHost(host);
-    nsCString nsCURI(uri);
-    if (uri) {
-      if (!StringBeginsWith(nsCURI, host)
-          // && !StringBeginsWith(host, nsCURI)
-          )
-        continue;
-    } else if (!passwordManager->IsEqualToLastHostQuery(host))
-      continue;
-
-    if (list) {
-      nsString unicodeName;
-      nsString unicodePassword;
-      nsPassword->GetUser(unicodeName);
-      nsPassword->GetPassword(unicodePassword);
-      GtkMozLogin * login = g_new0(GtkMozLogin, 1);
-      UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(login);
-      login->user = ToNewUTF8String(unicodeName);
-      ALLOC_NOT_CHECKED(login->user);
-      login->pass = ToNewUTF8String(unicodePassword);
-      ALLOC_NOT_CHECKED(login->pass);
-      login->host = NS_strdup(host.get());
-      ALLOC_NOT_CHECKED(login->host);
-      login->index = ret;
-      *list = g_list_append(*list, login);
-    }
-    ret++;
-  }
-#endif
+  gint ret = -1;
   return ret;
 }
 
 gboolean
 gtk_moz_embed_common_remove_passwords(const gchar *host, const gchar *user, gint index)
 {
-#ifdef MOZ_GTKPASSWORD_INTERFACE
-  EmbedPasswordMgr *passwordManager = EmbedPasswordMgr::GetInstance();
-  if (index >= 0) {
-    passwordManager->RemovePasswordsByIndex(index);
-  } else {
-    passwordManager->RemovePasswords(host, user);
-  }
-#endif
-  return TRUE;
+  return FALSE;
 }
 
 gint
 gtk_moz_embed_common_get_history_list(GtkMozHistoryItem **GtkHI)
 {
   gint count = 0;
   EmbedGlobalHistory *history = EmbedGlobalHistory::GetInstance();
   history->GetContentList(GtkHI, &count);
@@ -469,17 +432,17 @@
   nsresult rv;
   // The global history service
   nsCOMPtr<nsIGlobalHistory2> globalHistory(do_GetService("@mozilla.org/browser/global-history;2"));
   if (!globalHistory) return NS_ERROR_NULL_POINTER;
   // The browser history interface
   nsCOMPtr<nsIObserver> myHistory = do_QueryInterface(globalHistory, &rv);
   if (!myHistory) return NS_ERROR_NULL_POINTER ;
   if (!url)
-    myHistory->Observe(nsnull, "RemoveEntries", nsnull);
+    myHistory->Observe(nsnull, "history-item-removed", nsnull);
   else {
     EmbedGlobalHistory *history = EmbedGlobalHistory::GetInstance();
     PRUnichar *uniurl = ToNewUnicode(NS_ConvertUTF8toUTF16(url));
     rv = history->RemoveEntries(uniurl, time);
     NS_Free(uniurl);
   }
   return 1;
 }
@@ -556,88 +519,232 @@
     return NULL;
   unsigned char *data;
   ((nsIX509Cert*)nsIX509Ptr)->GetRawDER(len, (PRUint8 **)&data);
   if (!data)
     return NULL;
   return data;
 }
 
-gint
-gtk_moz_embed_common_get_plugins_list(GList **pluginArray)
+#ifdef MOZ_RDF
+static PRBool
+gtk_moz_embed_common_get_node_value(nsIRDFDataSource *eDataSource,
+                                    nsIRDFResource *itemResource,
+                                    nsIRDFService *rdfService,
+                                    gchar* nodeType, PRUnichar **retval)
+{
+  nsCOMPtr<nsIRDFResource> nodeRDFResource;
+  rdfService->GetResource(NS_LITERAL_CSTRING(nodeType), getter_AddRefs(nodeRDFResource));
+  if (!nodeRDFResource)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFNode> itemNode;
+  eDataSource->GetTarget(itemResource, nodeRDFResource, PR_TRUE, getter_AddRefs(itemNode));
+  if (!itemNode)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFLiteral> itemNodeLiteral = do_QueryInterface(itemNode);
+  if (!itemNodeLiteral)
+    return PR_FALSE;
+
+  PRUnichar *itemType = nsnull;
+  itemNodeLiteral->GetValue(&itemType);
+  *retval= itemType;
+
+  return PR_TRUE;
+}
+#endif
+
+gboolean
+gtk_moz_embed_common_set_extension_status(gchar *extensionID, gboolean status)
+{
+  g_return_val_if_fail (extensionID != NULL, FALSE);
+  nsCOMPtr<nsIExtensionManager> eManager(do_GetService("@mozilla.org/extensions/manager;1"));
+  if (!eManager)
+    return FALSE;
+
+  nsAutoString id;
+  id.AppendLiteral(extensionID);
+
+  if (status)
+    eManager->EnableItem(id);
+  else
+    eManager->DisableItem(id);
+
+  return TRUE;
+}
+
+static PRBool
+gtk_moz_embed_common_get_component_list(PRUint32 *length, GList **pluginArray)
+{
+  PRUint32 count = 0;
+  nsIUpdateItem **extensions = nsnull;
+
+#ifdef MOZ_RDF
+  nsCOMPtr<nsIExtensionManager> eManager(do_GetService("@mozilla.org/extensions/manager;1"));
+  if (!eManager)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFService> rdfService;
+  rdfService = do_GetService("@mozilla.org/rdf/rdf-service;1");
+  if (!rdfService)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFDataSource> eDataSource;
+  eManager->GetDatasource(getter_AddRefs(eDataSource));
+  if (!eDataSource)
+    return PR_FALSE;
+
+  eManager->GetItemList(nsIUpdateItem::TYPE_EXTENSION, &count,
+                                &extensions);
+
+  for (PRUint32 i = 0; i < count; i++) {
+    nsIUpdateItem *extension = extensions[i];
+    if (extension) {
+      GtkMozPlugin *list_item = g_new0(GtkMozPlugin, 1);
+      nsAutoString itemName;
+      extension->GetName(itemName);
+      if (itemName.IsEmpty())
+        return PR_FALSE;
+
+      nsAutoString itemId;
+      extension->GetId(itemId);
+      if (itemId.IsEmpty())
+        return PR_FALSE;
+
+      nsCString resourceID("urn:mozilla:item:");
+      resourceID.Append(NS_ConvertUTF16toUTF8(itemId));
+      nsCOMPtr<nsIRDFResource> itemResource;
+      rdfService->GetResource(resourceID, getter_AddRefs(itemResource));
+      if (!itemResource)
+        return PR_FALSE;
+
+      PRUnichar *extAppDisabled = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_APP_DISABLED, &extAppDisabled);
+      if ((extAppDisabled) && (nsDependentString(extAppDisabled).Equals(NS_LITERAL_STRING("true"))))
+        return PR_FALSE;
+
+      list_item->title = g_strdup((gchar *)NS_ConvertUTF16toUTF8(itemName).get());
+      list_item->path =  g_strdup((gchar *)NS_ConvertUTF16toUTF8(itemId).get());
+
+      PRUnichar *itemCreator = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_CREATOR, &itemCreator);
+      if (itemCreator)
+        list_item->creator = g_strdup(NS_ConvertUTF16toUTF8(itemCreator).get());
+
+      PRUnichar *itemDescrption = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_DES, &itemDescrption);
+      if(itemDescrption)
+        list_item->type = g_strdup(NS_ConvertUTF16toUTF8(itemDescrption).get());
+
+      PRUnichar *itemState = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_STATE, &itemState);
+      if ((itemState) && (nsDependentString(itemState).Equals(NS_LITERAL_STRING("true"))))
+        list_item->isDisabled = TRUE;
+      else
+        list_item->isDisabled = FALSE;
+
+      list_item->isPlugin = FALSE;
+      *pluginArray = g_list_append(*pluginArray, list_item);
+      *length = *length + 1;
+    }
+  }
+  return PR_TRUE;
+#else
+  return PR_FALSE;
+#endif
+}
+
+static PRBool
+gtk_moz_embed_common_get_npplugin_list(PRUint32 *aLength, GList **pluginArray)
 {
   nsresult rv;
   nsCOMPtr<nsIPluginManager> pluginMan =
     do_GetService(kPluginManagerCID, &rv);
   if (NS_FAILED(rv)) {
-    g_print("Could not get the plugin manager\n");
-    return -1;
+    NS_WARNING("Could not get the plugin manager\n");
+    return FALSE;
   }
-  pluginMan->ReloadPlugins(PR_TRUE);  //FIXME XXX MEMLEAK
+  pluginMan->ReloadPlugins(PR_FALSE);  //FIXME XXX MEMLEAK
 
   nsCOMPtr<nsIPluginHost> pluginHost =
     do_GetService(kPluginManagerCID, &rv);
-  if (NS_FAILED(rv))
-    return -1;
+  NS_ENSURE_SUCCESS(rv, FALSE);
 
-  PRUint32 aLength;
-  pluginHost->GetPluginCount(&aLength);
+  pluginHost->GetPluginCount(aLength);
 
   if (!pluginArray)
-    return (gint)aLength;
+    return FALSE;
 
-  nsIDOMPlugin **aItems = nsnull;
-  aItems = new nsIDOMPlugin*[aLength];
-  if (!aItems)
-    return -1; //NO MEMORY
+  nsIDOMPlugin **aItems = new nsIDOMPlugin*[*aLength];
+  NS_ENSURE_TRUE(aItems, FALSE); // OUT OF Memory
 
-  rv = pluginHost->GetPlugins(aLength, aItems);
+  rv = pluginHost->GetPlugins(*aLength, aItems);
   if (NS_FAILED(rv)) {
+    for (PRUint32 i = 0; i < *aLength; i++)
+      NS_IF_RELEASE(aItems[i]);
     delete [] aItems;
-    return -1;
+    return FALSE;
   }
 
   nsString string;
-  for (int plugin_index = 0; plugin_index < (gint) aLength; plugin_index++)
-  {
+  for (int plugin_index = 0; plugin_index < (gint) *aLength; plugin_index++) {
     GtkMozPlugin *list_item = g_new0(GtkMozPlugin, 1);
     UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(list_item);
 
     rv = aItems[plugin_index]->GetName(string);
     if (!NS_FAILED(rv))
       list_item->title = g_strdup(NS_ConvertUTF16toUTF8(string).get());
 
     aItems[plugin_index]->GetFilename(string);
     if (!NS_FAILED(rv))
       list_item->path = g_strdup(NS_ConvertUTF16toUTF8(string).get());
 
     nsCOMPtr<nsIDOMMimeType> mimeType;
     PRUint32 mime_count = 0;
     rv = aItems[plugin_index]->GetLength(&mime_count);
     if (NS_FAILED(rv))
       continue;
-    
+
     nsString single_mime;
     string.SetLength(0);
     for (int mime_index = 0; mime_index < mime_count; ++mime_index) {
       rv = aItems[plugin_index]->Item(mime_index, getter_AddRefs(mimeType));
       if (NS_FAILED(rv))
         continue;
       rv = mimeType->GetDescription(single_mime);
       if (!NS_FAILED(rv)) {
+        if(mime_index > 0)
+          string.AppendLiteral(";");
         string.Append(single_mime);
-        string.AppendLiteral(";");
       }
     }
-    
+
     list_item->type = g_strdup(NS_ConvertUTF16toUTF8(string).get());
+    list_item->isPlugin = TRUE;
+
     if (!NS_FAILED(rv))
       *pluginArray = g_list_append(*pluginArray, list_item);
   }
+  for (PRUint32 i = 0; i < *aLength; i++)
+    NS_IF_RELEASE(aItems[i]);
   delete [] aItems;
+  return TRUE;
+}
+
+gint
+gtk_moz_embed_common_get_plugins_list(GList **pluginArray)
+{
+  PRUint32 aLength = 0;
+  gtk_moz_embed_common_get_npplugin_list(&aLength, pluginArray);
+  gtk_moz_embed_common_get_component_list(&aLength, pluginArray);
   return (gint)aLength;
 }
 
 void
 gtk_moz_embed_common_reload_plugins()
 {
   nsresult rv;
   nsCOMPtr<nsIPluginManager> pluginMan =
@@ -645,27 +752,17 @@
   pluginMan->ReloadPlugins(PR_TRUE); //FIXME XXX MEMLEAK
 }
 
 guint
 gtk_moz_embed_common_get_security_mode(guint sec_state)
 {
   GtkMozEmbedSecurityMode sec_mode;
 
-  const guint wpl_security_bits = nsIWebProgressListener::STATE_IS_SECURE |
-                                  nsIWebProgressListener::STATE_IS_BROKEN |
-                                  nsIWebProgressListener::STATE_IS_INSECURE |
-                                  nsIWebProgressListener::STATE_SECURE_HIGH |
-                                  nsIWebProgressListener::STATE_SECURE_MED |
-                                  nsIWebProgressListener::STATE_SECURE_LOW;
-
-  /* sec_state is defined as a bitmask that may be extended in the future.
-   * We filter out any unknown bits before testing for known values.
-   */
-  switch (sec_state & wpl_security_bits) {
+  switch (sec_state) {
     case nsIWebProgressListener::STATE_IS_INSECURE:
       sec_mode = GTK_MOZ_EMBED_NO_SECURITY;
       //g_print("GTK_MOZ_EMBED_NO_SECURITY\n");
       break;
     case nsIWebProgressListener::STATE_IS_BROKEN:
       sec_mode = GTK_MOZ_EMBED_NO_SECURITY;
       //g_print("GTK_MOZ_EMBED_NO_SECURITY\n");
       break;
@@ -726,8 +823,140 @@
     //This is the correct?
     nsCOMPtr<nsIObserverService> obsService =
       do_GetService("@mozilla.org/observer-service;1", &rv);
     if (obsService)
       rv = obsService->NotifyObservers((nsISupports*)object, topic, (PRUnichar*)data);
   }
   return NS_FAILED(rv) ? FALSE : TRUE;
 }
+
+/* Loads all images from all documents (frames and iframes) inside aDoc, recursively */
+static gboolean
+gtk_moz_embed_common_load_images(nsIDOMDocument *aDoc)
+{
+  /* look for img tags */
+  nsresult rv;
+  nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(aDoc, &rv);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  nsCOMPtr<nsIDOMHTMLCollection> imgList;
+  rv = htmlDoc->GetImages(getter_AddRefs(imgList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 imgCount;
+  rv = imgList->GetLength(&imgCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  guint32 i;
+  for (i = 0; i < imgCount; i++) {
+    nsCOMPtr<nsIDOMNode> imgNode;
+    rv = imgList->Item(i, getter_AddRefs(imgNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(imgNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    imgContent->ForceReload();
+  }
+
+  /* Look for iframes */
+  nsCOMPtr<nsIDOMNodeList> iframeList;
+  rv = aDoc->GetElementsByTagName(NS_LITERAL_STRING("iframe"),
+                                  getter_AddRefs(iframeList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 iframeCount;
+  rv = iframeList->GetLength(&iframeCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  /* look for frames */
+  nsCOMPtr<nsIDOMNodeList> frameList;
+  rv = aDoc->GetElementsByTagName(NS_LITERAL_STRING("frame"),
+                                  getter_AddRefs(frameList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 frameCount;
+  rv = frameList->GetLength(&frameCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  if (iframeCount == 0 && frameCount == 0)
+    return TRUE;
+
+  for (i = 0; i < iframeCount; i++) {
+    nsCOMPtr<nsIDOMNode> iframeNode;
+    rv = iframeList->Item(i, getter_AddRefs(iframeNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMHTMLIFrameElement> iframeElement = do_QueryInterface(iframeNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMDocument> iframeDoc;
+    rv = iframeElement->GetContentDocument(getter_AddRefs(iframeDoc));
+    if (NS_FAILED(rv))
+      continue;
+
+    gtk_moz_embed_common_load_images(iframeDoc);
+  }
+
+  for (i = 0; i < frameCount; i++) {
+    nsCOMPtr<nsIDOMNode> frameNode;
+    rv = frameList->Item(i, getter_AddRefs(frameNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMHTMLFrameElement> frameElement = do_QueryInterface(frameNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMDocument> frameDoc;
+    rv = frameElement->GetContentDocument(getter_AddRefs(frameDoc));
+    if (NS_FAILED(rv))
+      continue;
+
+    gtk_moz_embed_common_load_images(frameDoc);
+  }
+
+  return TRUE;
+}
+
+gboolean
+gtk_moz_embed_common_set_image_policy(gint policy)
+{
+  if (gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &policy))
+     gtk_moz_embed_common_save_prefs();
+
+  PRInt32 winCount = 0;
+  if (EmbedPrivate::sWindowList)
+    winCount = EmbedPrivate::sWindowList->Count();
+
+  for (gint i = 0; i < winCount; i++) {
+    EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>
+                                              (EmbedPrivate::sWindowList->ElementAt(i));
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    nsresult rv = tmpPrivate->mNavigation->GetDocument(getter_AddRefs(domDoc));
+    if (NS_FAILED(rv))
+      continue;
+
+    switch (policy) {
+    case GTK_MOZ_EMBED_IMAGE_POLICY_ALWAYS:
+      if (!gtk_moz_embed_common_load_images(domDoc));
+        continue;
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_NEVER:
+      tmpPrivate->Reload(nsIWebNavigation::LOAD_FLAGS_NONE);
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_NO_EXTERNAL:
+      /* Hide images from external servers */
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_ONLY_LOADED:
+      if (!gtk_moz_embed_common_load_images(domDoc));
+        continue;
+      break;
+    }
+  }
+
+  return TRUE;
+}
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_common.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_common.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_common.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -136,16 +136,27 @@
 {
   GTK_MOZ_EMBED_NO_SECURITY = 0,
   GTK_MOZ_EMBED_LOW_SECURITY,
   GTK_MOZ_EMBED_MEDIUM_SECURITY,
   GTK_MOZ_EMBED_HIGH_SECURITY,
   GTK_MOZ_EMBED_UNKNOWN_SECURITY
 } GtkMozEmbedSecurityMode;
 
+/** GtkMozEmbedImagePolicy
+  * Enumerates image policy
+  */
+typedef enum
+{
+  GTK_MOZ_EMBED_IMAGE_POLICY_ALWAYS = 1,
+  GTK_MOZ_EMBED_IMAGE_POLICY_NEVER,
+  GTK_MOZ_EMBED_IMAGE_POLICY_NO_EXTERNAL,
+  GTK_MOZ_EMBED_IMAGE_POLICY_ONLY_LOADED
+} GtkMozEmbedImagePolicy;
+
 typedef struct _GtkMozCookieList GtkMozCookieList;
 struct _GtkMozCookieList
 {
     gchar *domain; /** < The domain's name */
     gchar *name;   /** < The cookie's name */
     gchar *value;  /** < The cookie's value */
     gchar *path;   /** < The cookie's path */
 };
@@ -157,27 +168,29 @@
 };
 /** @struct GtkMozPlugin.
  * Defines a Mozilla Plugin.
  */
 typedef struct _GtkMozPlugin GtkMozPlugin;
 struct _GtkMozPlugin
 {
     gchar *title;  /** < Plugin title */
+    gchar *creator;  /** < Plugin creator */
     gchar *path;   /** < Plugin path */
     gchar *type;   /** < Plugin type */
     gboolean isDisabled; /** < is plugin enabled */
+    gboolean isPlugin; /** <is plugin or extension*/
 };
 
 typedef struct _GtkMozLogin GtkMozLogin;
 struct _GtkMozLogin
 {
-    const gchar *user; /** < Plugin title */
-    const gchar *pass; /** < Plugin path */
-    const gchar *host; /** < Plugin type */
+    gchar *user; /** < Plugin title */
+    gchar *pass; /** < Plugin path */
+    gchar *host; /** < Plugin type */
     guint index;
 };
 
 GTKMOZEMBED_API(GtkType,    gtk_moz_embed_common_get_type,          (void))
 GTKMOZEMBED_API(GtkWidget*, gtk_moz_embed_common_new,               (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_pref,          (GtkType type, gchar*, gpointer))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_get_pref,          (GtkType type, gchar*, gpointer))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_save_prefs,        (void))
@@ -185,21 +198,22 @@
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_remove_passwords,  (const gchar *host, const gchar *user, gint index))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_logins,        (const char* uri, GList **list))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_history_list,  (GtkMozHistoryItem **GtkHI))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_remove_history,    (gchar *url, gint time))
 GTKMOZEMBED_API(GSList*,    gtk_moz_embed_common_get_cookie_list,   (void))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_delete_all_cookies,(GSList *deletedCookies))
 GTKMOZEMBED_API(unsigned char*, gtk_moz_embed_common_nsx509_to_raw, (void *nsIX509Ptr, guint *len))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_plugins_list,  (GList **pluginArray))
+GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_extension_status,  (gchar *extensionID, gboolean status))
 GTKMOZEMBED_API(void,       gtk_moz_embed_common_reload_plugins,    (void))
 GTKMOZEMBED_API(guint,      gtk_moz_embed_common_get_security_mode, (guint sec_state))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_clear_cache,       (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_observe,           (const gchar*, gpointer, const gchar*, gunichar*))
-
+GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_image_policy,  (gint policy))
 
 /*typedef struct _GtkMozEmbedCertContext GtkMozEmbedCertContext;
 struct _GtkMozEmbedCertContext
 {
     GObject * cert;
     guint message;
     GtkWidget *parent;
 };*/
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_download.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_download.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_download.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -57,25 +57,28 @@
 #include "nsStringAPI.h"
 #endif
 
 #include "gtkmozembedmarshal.h"
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_TOOLKIT_STRING(x) NS_ConvertUTF16toUTF8(x).get()
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
-static void gtk_moz_embed_download_set_latest_object(GtkObject *o);
+// static stuff
+static void gtk_moz_embed_download_set_latest_object (GtkObject *o);
 static GtkObject *latest_download_object = nsnull;
+static gboolean  is_restart = FALSE;
 
 // class and instance initialization
 guint moz_embed_download_signals[DOWNLOAD_LAST_SIGNAL] = { 0 };
 static void gtk_moz_embed_download_class_init(GtkMozEmbedDownloadClass *klass);
 static void gtk_moz_embed_download_init(GtkMozEmbedDownload *embed);
 static void gtk_moz_embed_download_destroy(GtkObject *object);
 GtkObject * gtk_moz_embed_download_new(void);
+GtkObject * gtk_moz_embed_download_new_with_url_filename (const gchar *url, const gchar *filename);
 
 // GtkObject + class-related functions
 GtkType
 gtk_moz_embed_download_get_type(void)
 {
   static GtkType moz_embed_download_type = 0;
   if (!moz_embed_download_type)
   {
@@ -177,108 +180,160 @@
     embed->data = NULL;
   }
 }
 
 GtkObject *
 gtk_moz_embed_download_new(void)
 {
   GtkObject *instance = (GtkObject *) gtk_type_new(gtk_moz_embed_download_get_type());
+  g_return_val_if_fail(instance, NULL);
   gtk_moz_embed_download_set_latest_object(instance);
+  gtk_moz_embed_download_set_restart_flag (FALSE);
 
   return instance;
 }
 
 GtkObject *
+gtk_moz_embed_download_new_with_url_filename (const gchar *url, const gchar *filename)
+{
+  g_return_val_if_fail((url && filename), nsnull);
+  GtkObject *instance = (GtkObject *) gtk_type_new(gtk_moz_embed_download_get_type());
+  g_return_val_if_fail(instance, NULL);
+
+  GtkMozEmbedDownload *download = GTK_MOZ_EMBED_DOWNLOAD(instance);
+  gtk_moz_embed_download_set_latest_object(instance);
+  gtk_moz_embed_download_set_restart_flag (TRUE);
+
+  EmbedDownloadMgr::CreateIncrementalDownload(url, filename);
+  //gtk_moz_embed_load_url (EmbedCommon::GetAnyLiveWidget(), url);
+
+  return instance;
+}
+
+
+GtkObject *
 gtk_moz_embed_download_get_latest_object(void)
 {
   return latest_download_object;
 }
 
 static void
 gtk_moz_embed_download_set_latest_object(GtkObject *obj)
 {
   latest_download_object = obj;
   return ;
 }
 
+gboolean
+gtk_moz_embed_download_get_restart_flag (void)
+{
+  return is_restart;
+}
+
+void
+gtk_moz_embed_download_set_restart_flag (gboolean restart)
+{
+  is_restart = restart;
+  return ;
+}
+
 void
 gtk_moz_embed_download_do_command(GtkMozEmbedDownload *item, guint command)
 {
+  g_return_if_fail(item);
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return;
 
   if (command == GTK_MOZ_EMBED_DOWNLOAD_CANCEL) {
-    download_priv->launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
-    download_priv->launcher->SetWebProgressListener(nsnull);
+    if (download_priv->launcher) {
+      download_priv->isCanceled = PR_TRUE;
+      download_priv->launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+      download_priv->launcher->SetWebProgressListener(nsnull);
+    } else if (download_priv->incr_launcher) {
+      download_priv->isCanceled = PR_TRUE;
+      item->is_paused = FALSE;
+      download_priv->incr_launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+    }
 
     return;
   }
 
-  if (command == GTK_MOZ_EMBED_DOWNLOAD_RESUME) {
-    download_priv->request->Resume();
-    download_priv->is_paused = FALSE;
+  if (command == GTK_MOZ_EMBED_DOWNLOAD_RESUME && item->is_paused) {
+    if (download_priv->incr_launcher) {
+      EmbedDownloadMgr::CreateIncrementalDownload(download_priv);
 
+    } else
+    if (download_priv->request) {
+        download_priv->request->Resume();
+    }
+    item->is_paused = FALSE;
     return;
   }
 
-  if (command == GTK_MOZ_EMBED_DOWNLOAD_PAUSE) {
-    if (download_priv->request) {
-      download_priv->request->Suspend();
-      download_priv->is_paused = TRUE;
+  if (command == GTK_MOZ_EMBED_DOWNLOAD_PAUSE && !item->is_paused) {
+    if (download_priv->incr_launcher) {
+      download_priv->incr_launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+    } else {
+      if (download_priv->request) {
+        download_priv->request->Suspend();
+      }
     }
-
+    item->is_paused = TRUE;
     return;
   }
 
   if (command == GTK_MOZ_EMBED_DOWNLOAD_RELOAD) {
     if (download_priv->gtkMozEmbedParentWidget) {}
   }
   // FIXME: missing GTK_MOZ_EMBED_DOWNLOAD_STORE and GTK_MOZ_EMBED_DOWNLOAD_RESTORE implementation.
 }
 
 gchar*
 gtk_moz_embed_download_get_file_name(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, nsnull); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return nsnull;
 
-  return (gchar *) download_priv->file_name;
+  return (gchar *) item->file_name;
 }
 
 gchar*
 gtk_moz_embed_download_get_url(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, nsnull); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return nsnull;
 
   // FIXME : 'server' is storing the wrong value. See EmbedDownloadMgr.cpp l. 189.
-  return (gchar *) download_priv->server;
+  return (gchar *) item->server;
 }
 
 glong
 gtk_moz_embed_download_get_progress(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, -1); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return -1;
 
-  return (glong) download_priv->downloaded_size;
+  return (glong) item->downloaded_size;
 }
 
 glong
 gtk_moz_embed_download_get_file_size(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, -1); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return -1;
 
-  return (glong) download_priv->file_size;
+  return (glong) item->file_size;
 }
-
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_download.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_download.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_download.h
@@ -9,17 +9,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -77,18 +77,28 @@
 #define GTK_IS_MOZ_EMBED_DOWNLOAD(obj)          GTK_CHECK_TYPE((obj), GTK_TYPE_MOZ_EMBED_DOWNLOAD)
 #define GTK_IS_MOZ_EMBED_DOWNLOAD_CLASS(klass)  GTK_CHECK_CLASS_TYPE((klass), GTK_TYPE_MOZ_EMBED_DOWNLOAD)
 
 typedef struct _GtkMozEmbedDownload      GtkMozEmbedDownload;
 typedef struct _GtkMozEmbedDownloadClass GtkMozEmbedDownloadClass;
 
 struct _GtkMozEmbedDownload
 {
-  GtkObject  object;
-  void *data;
+  GtkObject   object;
+  void        *data;
+
+  char*       file_name;             /** < The file's name */
+  char*       file_name_with_path;   /** < The file's name */
+  const char* server;                /** < The server's name */
+  const char* file_type;             /** < The file's type */
+  const char* handler_app;           /** < The application's name */
+  gulong      file_size;             /** < The file's size */
+  glong       downloaded_size;       /** < The download's size */
+  gboolean    is_paused;             /** < If download is paused or not */
+  gboolean    open_with;             /** < If the file can be opened by other application */
 };
 
 struct _GtkMozEmbedDownloadClass
 {
   GtkObjectClass parent_class;
   void (*started) (GtkMozEmbedDownload* item, gchar **file_name_with_path);
   void (*completed) (GtkMozEmbedDownload* item);
   void (*error) (GtkMozEmbedDownload* item);
@@ -101,23 +111,23 @@
   GTK_MOZ_EMBED_DOWNLOAD_RESUME,
   GTK_MOZ_EMBED_DOWNLOAD_CANCEL,
   GTK_MOZ_EMBED_DOWNLOAD_PAUSE,
   GTK_MOZ_EMBED_DOWNLOAD_RELOAD,
   GTK_MOZ_EMBED_DOWNLOAD_STORE,
   GTK_MOZ_EMBED_DOWNLOAD_RESTORE
 } GtkMozEmbedDownloadActions;
 
-GTKMOZEMBED_API(GtkType,      gtk_moz_embed_download_get_type,           (void))
-GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new,                (void))
-GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_get_latest_object,  (void))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_file_name,      (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_url,            (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_progress,       (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_file_size,      (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(GtkType,      gtk_moz_embed_download_get_type,             (void))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new,                  (void))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new_with_url_filename,(const gchar *url, const gchar *filename))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_get_latest_object,    (void))
+GTKMOZEMBED_API(gboolean,     gtk_moz_embed_download_get_restart_flag,     (void))
+GTKMOZEMBED_API(void,         gtk_moz_embed_download_set_restart_flag,     (gboolean))
+GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_file_name,        (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_url,              (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_progress,         (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_file_size,        (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,           (GtkMozEmbedDownload *item, guint command))
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
 #endif /* gtkmozembed_download_h */
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_glue.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_glue.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_glue.cpp
@@ -49,16 +49,17 @@
 
 #ifndef XPCOM_GLUE
 #error This file only makes sense when XPCOM_GLUE is defined.
 #endif
 
 #define GTKMOZEMBED2_FUNCTIONS \
   GTKF(gtk_moz_embed_download_get_type) \
   GTKF(gtk_moz_embed_download_new) \
+  GTKF(gtk_moz_embed_download_new_with_url_filename) \
   GTKF(gtk_moz_embed_common_get_type) \
   GTKF(gtk_moz_embed_common_new) \
   GTKF(gtk_moz_embed_common_set_pref) \
   GTKF(gtk_moz_embed_common_get_pref) \
   GTKF(gtk_moz_embed_common_save_prefs) \
   GTKF(gtk_moz_embed_common_remove_passwords) \
   GTKF(gtk_moz_embed_common_get_history_list) \
   GTKF(gtk_moz_embed_get_zoom_level) \
@@ -71,17 +72,19 @@
   GTKF(gtk_moz_embed_get_doc_info) \
   GTKF(gtk_moz_embed_insert_text) \
   GTKF(gtk_moz_embed_common_nsx509_to_raw) \
   GTKF(gtk_moz_embed_common_observe) \
   GTKF(gtk_moz_embed_get_shistory_list) \
   GTKF(gtk_moz_embed_get_shistory_index) \
   GTKF(gtk_moz_embed_shistory_goto_index) \
   GTKF(gtk_moz_embed_get_server_cert) \
-  GTKF(gtk_moz_embed_get_nsIWebBrowser)
+  GTKF(gtk_moz_embed_get_nsIWebBrowser) \
+  GTKF(gtk_moz_embed_get_text) \
+  GTKF(gtk_moz_embed_do_command)
 
 #define GTKMOZEMBED_FUNCTIONS \
   GTKF(gtk_moz_embed_get_type) \
   GTKF(gtk_moz_embed_new) \
   GTKF(gtk_moz_embed_push_startup) \
   GTKF(gtk_moz_embed_pop_startup) \
   GTKF(gtk_moz_embed_set_path) \
   GTKF(gtk_moz_embed_set_comp_path) \
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_internal.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_internal.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_internal.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
Index: mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.list
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembedmarshal.list
+++ mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.list
@@ -24,8 +24,9 @@
 VOID:STRING,STRING,POINTER
 VOID:STRING,STRING,STRING,ULONG,INT
 VOID:STRING,STRING,STRING,POINTER
 VOID:UINT,INT,INT,STRING,STRING,STRING,STRING
 VOID:ULONG,ULONG,ULONG
 BOOL:POINTER,UINT
 VOID:POINTER
 BOOL:STRING,STRING,POINTER
+BOOL:STRING,STRING,POINTER,POINTER
Index: mozilla/embedding/browser/gtk/src/gtkmozembedprivate.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembedprivate.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembedprivate.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard.
+ * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -87,20 +87,25 @@
   PROMPT_AUTH,
   SELECT,
   DOWNLOAD_REQUEST,
   DOM_MOUSE_SCROLL,
   DOM_MOUSE_LONG_PRESS,
   DOM_FOCUS,
   DOM_BLUR,
   UPLOAD_DIALOG,
+  FILE_UPLOAD_STARTED,
+  FILE_UPLOAD_FINISHED,
   ICON_CHANGED,
   MAILTO,
   NETWORK_ERROR,
   RSS_REQUEST,
+  DOM_WINDOW_FOCUS,
+  DOM_WINDOW_BLUR,
+  DOM_CONTENT_BLOCKED,
   EMBED_LAST_SIGNAL
 };
 
 //  DOM_MOUSE_MOVE,
 extern guint moz_embed_signals[EMBED_LAST_SIGNAL];
 
 #if 0
 enum {
Index: mozilla/embedding/browser/gtk/src/nsIPassword.idl
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/nsIPassword.idl
+++ /dev/null
@@ -1,79 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- * Netscape Communications, Inc.
- * Portions created by the Initial Developer are Copyright (C) 2001
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "nsISupports.idl"
-
-[scriptable, uuid(CF39C2B0-1E4B-11d5-A549-0010A401EB10)]
-
-/**
- * An optional interface for clients wishing to access a
- * password object
- *
- * @status FROZEN
- */
-
-interface nsIPassword : nsISupports {
-
-    /**
-     * the name of the host corresponding to the login being saved
-     *
-     * The form of the host depends on how the nsIPassword object was created
-     *
-     * - if it was created as a result of submitting a form to a site, then the
-     *   host is the url of the site, as obtained from a call to GetSpec
-     *
-     * - if it was created as a result of another app (e.g., mailnews) calling a
-     *   prompt routine such at PromptUsernameAndPassword, then the host is whatever
-     *   arbitrary string the app decided to pass in.
-     *
-     * Whatever form it is in, it will be used by the password manager to uniquely
-     * identify the login realm, so that "newsserver:119" is not the same thing as
-     * "newsserver".
-     */
-    readonly attribute AUTF8String host;
-
-    /**
-     * the user name portion of the login
-     */
-    readonly attribute AString user;
-
-    /**
-     * the password portion of the login
-     */
-    readonly attribute AString password;
-};
Index: mozilla/embedding/browser/gtk/src/nsIPasswordInternal.idl
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/nsIPasswordInternal.idl
+++ /dev/null
@@ -1,57 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim:set ts=2 sw=2 sts=2 et cindent: */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is Google Inc.
- * Portions created by the Initial Developer are Copyright (C) 2005
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *  Darin Fisher <darin@meer.net>
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "nsIPassword.idl"
-
-/**
- * This interface is supported by password manager entries to expose the
- * fieldnames passed to nsIPasswordManagerInternal's addUserFull method.
- */
-[scriptable, uuid(2cc35c67-978f-42a9-a958-16e97ad2f4c8)]
-interface nsIPasswordInternal : nsIPassword
-{
-  /**
-   * The name of the field that contained the username.
-   */
-  readonly attribute AString userFieldName;
-
-  /**
-   * The name of the field that contained the password.
-   */
-  readonly attribute AString passwordFieldName;
-};
