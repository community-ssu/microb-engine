# make widgets focusable if it's in visible area
# fixed problem with scrolling to focused widget by js
# contact: Anton Rogaynis ext-anton(dot)rogaynis(at)nokia.com
Index: mozilla/content/html/content/src/nsHTMLInputElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsHTMLInputElement.cpp
+++ mozilla/content/html/content/src/nsHTMLInputElement.cpp
@@ -105,16 +105,17 @@
 #include "nsILocalFile.h"
 #include "nsIFileStreams.h"
 #include "nsNetUtil.h"
 #include "nsDOMFile.h"
 
 // input type=image
 #include "nsImageLoadingContent.h"
 #include "nsIDOMWindowInternal.h"
+#include "nsIViewManager.h"
 
 // XXX align=left, hspace, vspace, border? other nav4 attrs
 
 static NS_DEFINE_CID(kXULControllersCID,  NS_XULCONTROLLERS_CID);
 //
 // Accessors for mBitField
 //
 #define BF_DISABLED_CHANGED 0
@@ -356,16 +357,18 @@
    * possible to avoid accidental errors where the wrong filename is used.
    * Therefor the filename is always owned by this member, never by the frame.
    * Whenever the frame wants to change the filename it has to call
    * SetFileName to update this member.
    */
   nsAutoPtr<nsString>      mFileName;
 
   nsRefPtr<nsDOMFileList>  mFileList;
+private:
+  PRBool                   mJSFocus;
 };
 
 #ifdef ACCESSIBILITY
 //Helper method
 static nsresult FireEventForAccessibility(nsIDOMHTMLInputElement* aTarget,
                                           nsPresContext* aPresContext,
                                           const nsAString& aEventType);
 #endif
@@ -376,17 +379,17 @@
 
 NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Input)
 
 nsHTMLInputElement::nsHTMLInputElement(nsINodeInfo *aNodeInfo,
                                        PRBool aFromParser)
   : nsGenericHTMLFormElement(aNodeInfo),
     mType(NS_FORM_INPUT_TEXT), // default value
     mBitField(0),
-    mValue(nsnull)
+    mValue(nsnull), mJSFocus(PR_FALSE)
 {
   SET_BOOLBIT(mBitField, BF_PARSER_CREATING, aFromParser);
 }
 
 nsHTMLInputElement::~nsHTMLInputElement()
 {
   DestroyImageLoadingContent();
   if (mValue) {
@@ -1240,23 +1243,83 @@
 {
   if (ShouldFocus(this)) {
     SetElementFocus(PR_FALSE);
   }
 
   return NS_OK;
 }
 
+static NS_IMETHODIMP
+SetSpecialFocus(nsIContent *aContent)
+{
+  nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
+  PRBool enabled = PR_FALSE;
+  NS_ENSURE_TRUE(prefBranch, NS_OK);
+
+  nsresult rv = prefBranch->GetBoolPref("browser.display.jsfocus_for_visible_area", &enabled);
+  NS_ENSURE_SUCCESS(rv, NS_OK);
+
+  nsIDocument *doc = aContent->GetDocument();
+  NS_ENSURE_TRUE(doc, NS_OK);
+
+  nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
+  NS_ENSURE_TRUE(presShell, NS_OK);
+
+  nsPresContext *presContext = presShell->GetPresContext();
+  NS_ENSURE_TRUE(presContext, NS_OK);
+
+  nsRect varea = presContext->GetVisibleArea();
+  varea.y = presContext->AppUnitsToDevPixels(varea.y);
+  varea.height = presContext->AppUnitsToDevPixels(varea.height);
+
+
+  nsIFrame* frame = nsnull;
+  frame = presShell->GetPrimaryFrameFor(aContent);
+  NS_ENSURE_TRUE(frame, NS_OK);
+
+  nsRect frameRect;
+  frameRect.SetRect(0,0,0,0);
+  nsPoint offset;
+  frameRect = frame->GetRect();
+  PRInt32 frame_height = presContext->AppUnitsToDevPixels(frameRect.height);
+  nsIView* view = nsnull;
+  frame->GetOffsetFromView(offset, &view);
+  NS_ENSURE_TRUE(view, NS_OK);
+  nsIView* rootView = nsnull;
+  nsIViewManager* viewManager = view->GetViewManager();
+  NS_ASSERTION(viewManager, "View must have a viewmanager");
+  viewManager->GetRootView(rootView);
+
+  while (view) {
+    offset  += view->GetPosition();
+    if (view == rootView) {
+      break;
+    }
+    view = view->GetParent();
+  }
+
+  frameRect.MoveTo(offset);
+  frameRect.y = presContext->AppUnitsToDevPixels(frameRect.y);
+  frameRect.height = presContext->AppUnitsToDevPixels(frameRect.height);
+  if (frameRect.y>=0 && (frameRect.y+frameRect.height)<=(varea.y+varea.height))
+    return NS_OK;
+
+  return NS_ERROR_FAILURE;
+}
+
 NS_IMETHODIMP
 nsHTMLInputElement::Focus()
 {
-  if (ShouldFocus(this)) {
+  mJSFocus = PR_TRUE;
+  nsresult rv = SetSpecialFocus(this);
+  if (NS_SUCCEEDED(rv) && ShouldFocus(this)) {
     SetElementFocus(PR_TRUE);
   }
-
+  mJSFocus = PR_FALSE;
   return NS_OK;
 }
 
 void
 nsHTMLInputElement::SetFocus(nsPresContext* aPresContext)
 {
   if (!aPresContext)
     return;
@@ -1279,17 +1342,18 @@
     nsIFocusController *focusController = win->GetRootFocusController();
     if (focusController) {
       PRBool isActive = PR_FALSE;
       focusController->GetActive(&isActive);
       if (!isActive) {
         focusController->SetFocusedWindow(win);
         focusController->SetFocusedElement(this);
 
-        return;
+        if (!mJSFocus) return;
+        focusController->SetActive(PR_TRUE);
       }
     }
   }
 
   SetFocusAndScrollIntoView(aPresContext);
 }
 
 NS_IMETHODIMP
