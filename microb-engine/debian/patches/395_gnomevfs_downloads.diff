# Additional fixes for Downloads implementation with gnomevfs protocol
#
Index: mozilla/uriloader/exthandler/nsExternalHelperAppService.h
===================================================================
--- mozilla.orig/uriloader/exthandler/nsExternalHelperAppService.h
+++ mozilla/uriloader/exthandler/nsExternalHelperAppService.h
@@ -426,16 +426,18 @@
 
   /**
    * When we are told to save the temp file to disk (in a more permament
    * location) before we are done writing the content to a temp file, then
    * we need to remember the final destination until we are ready to use it.
    */
   nsCOMPtr<nsIFile> mFinalFileDestination;
 
+  nsCOMPtr<nsIURI> mFinalUriDestination;
+
   char mDataBuffer[DATA_BUFFER_SIZE];
 
   /**
    * Creates the temporary file for the download and an output stream for it.
    * Upon successful return, both mTempFile and mOutStream will be valid.
    */
   nsresult SetUpTempFile(nsIChannel * aChannel);
   /**
@@ -451,16 +453,20 @@
    * then create a progress listener of some kind so they know
    * what's going on...
    */
   nsresult CreateProgressListener();
   nsresult PromptForSaveToFile(nsILocalFile ** aNewFile,
                                const nsAFlatString &aDefaultFile,
                                const nsAFlatString &aDefaultFileExt);
 
+  nsresult PromptForSaveToUri(nsIURI ** aNewFile,
+                               const nsAFlatString &aDefaultFile,
+                               const nsAFlatString &aDefaultFileExt);
+
   /**
    * After we're done prompting the user for any information, if the original
    * channel had a refresh url associated with it (which might point to a
    * "thank you for downloading" kind of page, then process that....It is safe
    * to invoke this method multiple times. We'll clear mOriginalChannel after
    * it's called and this ensures we won't call it again....
    */
   void ProcessAnyRefreshTags();
Index: mozilla/uriloader/exthandler/nsIHelperAppLauncherDialog.idl
===================================================================
--- mozilla.orig/uriloader/exthandler/nsIHelperAppLauncherDialog.idl
+++ mozilla/uriloader/exthandler/nsIHelperAppLauncherDialog.idl
@@ -34,16 +34,17 @@
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsISupports.idl"
 
 interface nsIHelperAppLauncher;
 interface nsILocalFile;
+interface nsIURI;
 
 /**
  * This interface is used to display a confirmatino dialog before
  * launching a "helper app" to handle content not handled by
  * Mozilla.
  *
  * Usage:  Clients (of which there is one: the nsIExternalHelperAppService
  * implementation in mozilla/uriloader/exthandler) create an instance of
@@ -84,15 +85,21 @@
 	// invoke a save to file dialog instead of the full fledged helper app dialog.
 	// aDefaultFileName --> default file name to provide (can be null)
 	// aSuggestedFileExtension --> sugested file extension
 	// aFileLocation --> return value for the file location
   nsILocalFile promptForSaveToFile(in nsIHelperAppLauncher aLauncher, 
                                    in nsISupports aWindowContext, 
                                    in wstring aDefaultFile, 
                                    in wstring aSuggestedFileExtension);
+
+  nsIURI promptForSaveToUri(in nsIHelperAppLauncher aLauncher,
+                                   in nsISupports aWindowContext,
+                                   in wstring aDefaultFile,
+                                   in wstring aSuggestedFileExtension);
+
 };
 
 
 %{C++
 #define NS_IHELPERAPPLAUNCHERDLG_CONTRACTID    "@mozilla.org/helperapplauncherdialog;1"
 #define NS_IHELPERAPPLAUNCHERDLG_CLASSNAME "Mozilla Helper App Launcher Confirmation Dialog"
 %}
Index: mozilla/uriloader/exthandler/nsExternalHelperAppService.cpp
===================================================================
--- mozilla.orig/uriloader/exthandler/nsExternalHelperAppService.cpp
+++ mozilla/uriloader/exthandler/nsExternalHelperAppService.cpp
@@ -2162,42 +2162,45 @@
   return NS_OK;
 }
 
 nsresult nsExternalAppHandler::ExecuteDesiredAction()
 {
   nsresult rv = NS_OK;
   if (mProgressListenerInitialized && !mCanceled)
   {
-    nsMIMEInfoHandleAction action = nsIMIMEInfo::saveToDisk;
-    mMimeInfo->GetPreferredAction(&action);
-    if (action == nsIMIMEInfo::useHelperApp ||
-        action == nsIMIMEInfo::useSystemDefault)
+    if(mFinalFileDestination)
     {
-      // Make sure the suggested name is unique since in this case we don't
-      // have a file name that was guaranteed to be unique by going through
-      // the File Save dialog
-      rv = mFinalFileDestination->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
-      if (NS_SUCCEEDED(rv))
+      nsMIMEInfoHandleAction action = nsIMIMEInfo::saveToDisk;
+      mMimeInfo->GetPreferredAction(&action);
+      if (action == nsIMIMEInfo::useHelperApp ||
+          action == nsIMIMEInfo::useSystemDefault)
       {
-        // Source and dest dirs should be == so this should just do a rename
-        rv = MoveFile(mFinalFileDestination);
+        // Make sure the suggested name is unique since in this case we don't
+        // have a file name that was guaranteed to be unique by going through
+        // the File Save dialog
+        rv = mFinalFileDestination->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
         if (NS_SUCCEEDED(rv))
-          rv = OpenWithApplication();
+        {
+          // Source and dest dirs should be == so this should just do a rename
+          rv = MoveFile(mFinalFileDestination);
+          if (NS_SUCCEEDED(rv))
+            rv = OpenWithApplication();
+        }
       }
-    }
-    else // Various unknown actions go here too
-    {
-      // XXX Put progress dialog in barber-pole mode
-      //     and change text to say "Copying from:".
-      rv = MoveFile(mFinalFileDestination);
-      if (NS_SUCCEEDED(rv) && action == nsIMIMEInfo::saveToDisk)
+      else // Various unknown actions go here too
       {
-        nsCOMPtr<nsILocalFile> destfile(do_QueryInterface(mFinalFileDestination));
-        gExtProtSvc->FixFilePermissions(destfile);
+        // XXX Put progress dialog in barber-pole mode
+        //     and change text to say "Copying from:".
+        rv = MoveFile(mFinalFileDestination);
+        if (NS_SUCCEEDED(rv) && action == nsIMIMEInfo::saveToDisk)
+        {
+          nsCOMPtr<nsILocalFile> destfile(do_QueryInterface(mFinalFileDestination));
+          gExtProtSvc->FixFilePermissions(destfile);
+        }
       }
     }
     
     // Notify dialog that download is complete.
     // By waiting till this point, it ensures that the progress dialog doesn't indicate
     // success until we're really done.
     if(mWebProgressListener)
     {
@@ -2308,16 +2311,47 @@
   rv = mDialog->PromptForSaveToFile(this, 
                                     mWindowContext,
                                     aDefaultFile.get(),
                                     aFileExtension.get(),
                                     aNewFile);
   return rv;
 }
 
+nsresult nsExternalAppHandler::PromptForSaveToUri(nsIURI ** aNewFile, const nsAFlatString &aDefaultFile, const nsAFlatString &aFileExtension)
+{
+  // invoke the dialog!!!!! use mWindowContext as the window context parameter for the dialog request
+  // Convert to use file picker? No, then embeddors could not do any sort of
+  // "AutoDownload" w/o showing a prompt
+  nsresult rv = NS_OK;
+  if (!mDialog)
+  {
+    // Get helper app launcher dialog.
+    mDialog = do_CreateInstance( NS_IHELPERAPPLAUNCHERDLG_CONTRACTID, &rv );
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  // we want to explicitly unescape aDefaultFile b4 passing into the dialog. we can't unescape
+  // it because the dialog is implemented by a JS component which doesn't have a window so no unescape routine is defined...
+
+  // Now, be sure to keep |this| alive, and the dialog
+  // If we don't do this, users that close the helper app dialog while the file
+  // picker is up would cause Cancel() to be called, and the dialog would be
+  // released, which would release this object too, which would crash.
+  // See Bug 249143
+  nsRefPtr<nsExternalAppHandler> kungFuDeathGrip(this);
+  nsCOMPtr<nsIHelperAppLauncherDialog> dlg(mDialog);
+  rv = mDialog->PromptForSaveToUri(this,
+                                    mWindowContext,
+                                    aDefaultFile.get(),
+                                    aFileExtension.get(),
+                                    aNewFile);
+  return rv;
+}
+
 nsresult nsExternalAppHandler::MoveFile(nsIFile * aNewFileLocation)
 {
   nsresult rv = NS_OK;
   NS_ASSERTION(mStopRequestIssued, "uhoh, how did we get here if we aren't done getting data?");
  
   nsCOMPtr<nsILocalFile> fileToUse = do_QueryInterface(aNewFileLocation);
 
   // if the on stop request was actually issued then it's now time to actually perform the file move....
@@ -2383,39 +2417,58 @@
   if (mCanceled)
     return NS_OK;
 
   mMimeInfo->SetPreferredAction(nsIMIMEInfo::saveToDisk);
 
   // The helper app dialog has told us what to do.
   mReceivedDispositionInfo = PR_TRUE;
 
+  nsCOMPtr<nsIURI> uriToUse;
   nsCOMPtr<nsILocalFile> fileToUse = do_QueryInterface(aNewFileLocation);
   if (!fileToUse)
   {
     nsAutoString leafName;
     mTempFile->GetLeafName(leafName);
     if (mSuggestedFileName.IsEmpty())
       rv = PromptForSaveToFile(getter_AddRefs(fileToUse), leafName, mTempFileExtension);
+    if(NS_FAILED(rv))
+      rv = PromptForSaveToUri(getter_AddRefs(uriToUse), leafName, mTempFileExtension);
     else
     {
       nsAutoString fileExt;
       PRInt32 pos = mSuggestedFileName.RFindChar('.');
       if (pos >= 0)
         mSuggestedFileName.Right(fileExt, mSuggestedFileName.Length() - pos);
       if (fileExt.IsEmpty())
         fileExt = mTempFileExtension;
 
       rv = PromptForSaveToFile(getter_AddRefs(fileToUse), mSuggestedFileName, fileExt);
+      if(NS_FAILED(rv))
+        rv = PromptForSaveToUri(getter_AddRefs(uriToUse), mSuggestedFileName, fileExt);
     }
+  }
 
-    if (NS_FAILED(rv) || !fileToUse) {
-      Cancel(NS_BINDING_ABORTED);
-      return NS_ERROR_FAILURE;
-    }
+  if (uriToUse) {
+    mFinalFileDestination = nsnull;
+    mFinalUriDestination = do_QueryInterface(uriToUse);
+    mOutStream->Close();
+    rv = NS_NewOutputStream(getter_AddRefs(mOutStream), uriToUse, nsnull);
+
+    if (!mProgressListenerInitialized)
+      CreateProgressListener();
+
+    ProcessAnyRefreshTags();
+
+    return NS_OK;
+  }
+
+  if (NS_FAILED(rv) || !fileToUse) {
+    Cancel(NS_BINDING_ABORTED);
+    return NS_ERROR_FAILURE;
   }
   
   mFinalFileDestination = do_QueryInterface(fileToUse);
 
   // Move what we have in the final directory, but append .part
   // to it, to indicate that it's unfinished.
   // do not do that if we're already done
   if (mFinalFileDestination && !mStopRequestIssued)
