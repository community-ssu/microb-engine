#https://projects.maemo.org/bugzilla/show_bug.cgi?id=124409
###microb-engine
Index: mozilla/widget/src/gtk2/mozdrawingarea.c
===================================================================
--- mozilla.orig/widget/src/gtk2/mozdrawingarea.c
+++ mozilla/widget/src/gtk2/mozdrawingarea.c
@@ -204,32 +204,35 @@ moz_drawingarea_move (MozDrawingarea *dr
 {
     gdk_window_move(drawingarea->clip_window, x, y);
 }
 
 void
 moz_drawingarea_resize (MozDrawingarea *drawingarea,
                         gint width, gint height)
 {
+    if (!drawingarea) return;
     gdk_window_resize(drawingarea->clip_window, width, height);
     gdk_window_resize(drawingarea->inner_window, width, height);
 }
 
 void
 moz_drawingarea_move_resize (MozDrawingarea *drawingarea,
                              gint x, gint y, gint width, gint height)
 {
+    if (!drawingarea) return;
     gdk_window_resize(drawingarea->inner_window, width, height);
     gdk_window_move_resize(drawingarea->clip_window, x, y, width, height);
 }
 
 void
 moz_drawingarea_set_visibility (MozDrawingarea *drawingarea,
                                 gboolean visibility)
 {
+    if (!drawingarea) return;
     if (visibility) {
         gdk_window_show_unraised(drawingarea->inner_window);
         gdk_window_show_unraised(drawingarea->clip_window);
     }
     else    {
         gdk_window_hide(drawingarea->clip_window);
         gdk_window_hide(drawingarea->inner_window);
     }
Index: mozilla/widget/src/gtk2/nsWindow.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsWindow.cpp
+++ mozilla/widget/src/gtk2/nsWindow.cpp
@@ -352,16 +352,17 @@ static GdkCursor *gCursorCache[eCursorCo
 
 // Global update pixmap
 static PRBool gUseBufferPixmap = PR_FALSE;
 static GdkPixmap *gBufferPixmap = nsnull;
 static gfxIntSize gBufferPixmapSize(0,0);
 static gfxIntSize gBufferPixmapMaxSize(0,0);
 static int gBufferPixmapUsageCount = 0;
 static PRBool gBlockWidgetActivity = PR_FALSE;
+static PRBool gBlockWidgetActivity_full = PR_FALSE;
 
 // imported in nsWidgetFactory.cpp
 PRBool gDisableNativeTheme = PR_FALSE;
 
 // If this is 1, then a 24bpp buffer surface is always
 // created for exposes, even if the display has a different depth
 static PRBool gForce24bpp = PR_FALSE;
 
@@ -3937,31 +3938,34 @@ nsWindow::NativeCreate(nsIWidget        
         mContainer = MOZ_CONTAINER(moz_container_new());
         gtk_container_add(GTK_CONTAINER(mShell), GTK_WIDGET(mContainer));
         gtk_widget_realize(GTK_WIDGET(mContainer));
 
         // make sure this is the focus widget in the container
         gtk_window_set_focus(GTK_WINDOW(mShell), GTK_WIDGET(mContainer));
 
         // and the drawing area
-        mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
+        if (!gBlockWidgetActivity_full)
+            mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
 
         if (mWindowType == eWindowType_popup) {
             // gdk does not automatically set the cursor for "temporary"
             // windows, which are what gtk uses for popups.
 
             mCursor = eCursor_wait; // force SetCursor to actually set the
                                     // cursor, even though our internal state
                                     // indicates that we already have the
                                     // standard cursor.
             SetCursor(eCursor_standard);
         }
     }
         break;
     case eWindowType_child: {
+        if (gBlockWidgetActivity_full)
+          break;
         if (parentMozContainer) {
             mDrawingarea = moz_drawingarea_new(parentArea, parentMozContainer, visual);
         }
         else if (parentGtkContainer) {
             mContainer = MOZ_CONTAINER(moz_container_new());
             gtk_container_add(parentGtkContainer, GTK_WIDGET(mContainer));
             gtk_widget_realize(GTK_WIDGET(mContainer));
 
@@ -3983,25 +3987,27 @@ nsWindow::NativeCreate(nsIWidget        
     // double-buffering everywhere
 #ifdef MOZ_X11
     if (mContainer)
         gtk_widget_set_double_buffered (GTK_WIDGET(mContainer),FALSE);
 #endif
 
     // label the drawing area with this object so we can find our way
     // home
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "nsWindow",
-                      this);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "nsWindow",
-                      this);
+    if (mDrawingarea) {
+        g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "nsWindow",
+                          this);
+        g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "nsWindow",
+                          this);
 
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "mozdrawingarea",
-                      mDrawingarea);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "mozdrawingarea",
-                      mDrawingarea);
+        g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "mozdrawingarea",
+                          mDrawingarea);
+        g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "mozdrawingarea",
+                          mDrawingarea);
+    }
 
     if (mContainer)
         g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
 
     if (mShell)
         g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
 
     // attach listeners for events
@@ -4282,17 +4288,18 @@ nsWindow::NativeResize(PRInt32 aX, PRInt
         // We only move the toplevel window if someone has
         // actually placed the window somewhere.  If no placement
         // has taken place, we just let the window manager Do The
         // Right Thing.
         if (mPlaced)
             gtk_window_move(GTK_WINDOW(mShell), aX, aY);
 
         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
-        moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
+        if (mDrawingarea)
+            moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
     }
     else if (mContainer) {
         GtkAllocation allocation;
         allocation.x = 0;
         allocation.y = 0;
         allocation.width = aWidth;
         allocation.height = aHeight;
         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
@@ -5965,16 +5972,21 @@ initialize_prefs(void)
     rv = prefs->GetBoolPref("mozilla.widget.disable-native-theme", &val);
     if (NS_SUCCEEDED(rv))
         gDisableNativeTheme = val;
 
     rv = prefs->GetBoolPref("mozilla.widget.not-active", &val);
     if (NS_SUCCEEDED(rv))
         gBlockWidgetActivity = val;
 
+    rv = prefs->GetBoolPref("mozilla.widget.not-realized", &val);
+    if (NS_SUCCEEDED(rv))
+        gBlockWidgetActivity_full = val;
+
+
     return NS_OK;
 }
 
 void
 nsWindow::ResetDragMotionTimer(GtkWidget *aWidget,
                                GdkDragContext *aDragContext,
                                gint aX, gint aY, guint aTime)
 {
@@ -7210,17 +7222,24 @@ nsWindow::GetSurfaceForGdkDrawable(GdkDr
     return result;
 }
 #endif
 
 // return the gfxASurface for rendering to this widget
 gfxASurface*
 nsWindow::GetThebesSurface()
 {
-    if (!mDrawingarea) return NULL;
+    if (!mDrawingarea) {
+        if (!mThebesSurface)
+            mThebesSurface = new gfxImageSurface(gfxIntSize(1,1),
+                                                 gdk_rgb_get_visual()->depth == 16 ?
+                                                     gfxImageSurface::ImageFormatRGB16 :
+                                                     gfxImageSurface::ImageFormatRGB24);
+        return mThebesSurface;
+    }
     GdkDrawable* d;
     gint x_offset, y_offset;
     gdk_window_get_internal_paint_info(mDrawingarea->inner_window,
                                        &d, &x_offset, &y_offset);
 
 #ifdef MOZ_X11
     gint width, height;
     gdk_drawable_get_size(d, &width, &height);
