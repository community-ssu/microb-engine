diff -r ed28977f2452 configure.in
--- a/configure.in	Thu Jul 17 10:22:45 2008 +0200
+++ b/configure.in	Fri Jul 18 17:03:02 2008 +0300
@@ -4295,18 +4295,6 @@ MOZ_ARG_WITH_STRING(java-bin-path,
 MOZ_ARG_WITH_STRING(java-bin-path,
 [  --with-java-bin-path=dir   Location of Java binaries (java, javac, jar)],
     JAVA_BIN_PATH=$withval)
-
-dnl ========================================================
-dnl Use ARM userspace kernel helpers; tell NSPR to enable
-dnl their usage and use them in spidermonkey.
-dnl ========================================================
-MOZ_ARG_WITH_BOOL(arm-kuser,
-[  --with-arm-kuser         Use kuser helpers (Linux/ARM only -- requires kernel 2.6.13 or later)],
-    USE_ARM_KUSER=1,
-    USE_ARM_KUSER=)
-if test -n "$USE_ARM_KUSER"; then
-   AC_DEFINE(USE_ARM_KUSER)
-fi
 
 dnl ========================================================
 dnl =
@@ -8332,9 +8320,6 @@ if test -z "$MOZ_NATIVE_NSPR" || test "$
     if test -n "$HAVE_64BIT_OS"; then
         ac_configure_args="$ac_configure_args --enable-64bit"
     fi
-    if test -n "$USE_ARM_KUSER"; then
-        ac_configure_args="$ac_configure_args --with-arm-kuser"
-    fi
     AC_OUTPUT_SUBDIRS(nsprpub)
     ac_configure_args="$_SUBDIR_CONFIG_ARGS"
 fi
diff -r ed28977f2452 js/src/jsatom.cpp
--- a/js/src/jsatom.cpp	Thu Jul 17 10:22:45 2008 +0200
+++ b/js/src/jsatom.cpp	Fri Jul 18 17:03:02 2008 +0300
@@ -578,19 +578,19 @@ js_AtomizeDouble(JSContext *cx, jsdouble
     state = &cx->runtime->atomState;
     table = &state->doubleAtoms;
 
-    JS_LOCK(cx, &state->lock);
+    JS_LOCK(&state->lock, cx);
     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, &d, JS_DHASH_ADD));
     if (!entry)
         goto failed_hash_add;
     if (entry->keyAndFlags == 0) {
         gen = ++table->generation;
-        JS_UNLOCK(cx, &state->lock);
+        JS_UNLOCK(&state->lock, cx);
 
         key = js_NewWeaklyRootedDouble(cx, d);
         if (!key)
             return NULL;
 
-        JS_LOCK(cx, &state->lock);
+        JS_LOCK(&state->lock, cx);
         if (table->generation == gen) {
             JS_ASSERT(entry->keyAndFlags == 0);
         } else {
@@ -608,12 +608,12 @@ js_AtomizeDouble(JSContext *cx, jsdouble
   finish:
     v = DOUBLE_TO_JSVAL((jsdouble *)ATOM_ENTRY_KEY(entry));
     cx->weakRoots.lastAtom = v;
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock,cx);
 
     return (JSAtom *)v;
 
   failed_hash_add:
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock,cx);
     JS_ReportOutOfMemory(cx);
     return NULL;
 }
@@ -634,7 +634,7 @@ js_AtomizeString(JSContext *cx, JSString
     state = &cx->runtime->atomState;
     table = &state->stringAtoms;
 
-    JS_LOCK(cx, &state->lock);
+    JS_LOCK(&state->lock, cx);
     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, str, JS_DHASH_ADD));
     if (!entry)
         goto failed_hash_add;
@@ -653,7 +653,7 @@ js_AtomizeString(JSContext *cx, JSString
             key = str;
         } else {
             gen = table->generation;
-            JS_UNLOCK(cx, &state->lock);
+            JS_UNLOCK(&state->lock, cx);
 
             if (flags & ATOM_TMPSTR) {
                 if (flags & ATOM_NOCOPY) {
@@ -677,7 +677,7 @@ js_AtomizeString(JSContext *cx, JSString
                 key = str;
             }
 
-            JS_LOCK(cx, &state->lock);
+            JS_LOCK(&state->lock, cx);
             if (table->generation == gen) {
                 JS_ASSERT(entry->keyAndFlags == 0);
             } else {
@@ -701,11 +701,11 @@ js_AtomizeString(JSContext *cx, JSString
     JS_ASSERT(JSSTRING_IS_ATOMIZED(key));
     v = STRING_TO_JSVAL(key);
     cx->weakRoots.lastAtom = v;
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock, cx);
     return (JSAtom *)v;
 
   failed_hash_add:
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock,cx);
     JS_ReportOutOfMemory(cx);
     return NULL;
 }
@@ -766,12 +766,12 @@ js_GetExistingStringAtom(JSContext *cx, 
     JSFLATSTR_INIT(&str, (jschar *)chars, length);
     state = &cx->runtime->atomState;
 
-    JS_LOCK(cx, &state->lock);
+    JS_LOCK(&state->lock, cx);
     hdr = JS_DHashTableOperate(&state->stringAtoms, &str, JS_DHASH_LOOKUP);
     str2 = JS_DHASH_ENTRY_IS_BUSY(hdr)
            ? (JSString *)ATOM_ENTRY_KEY(TO_ATOM_ENTRY(hdr))
            : NULL;
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock, cx);
 
     return str2 ? (JSAtom *)STRING_TO_JSVAL(str2) : NULL;
 }
diff -r ed28977f2452 js/src/jslock.cpp
--- a/js/src/jslock.cpp	Thu Jul 17 10:22:45 2008 +0200
+++ b/js/src/jslock.cpp	Fri Jul 18 17:03:02 2008 +0300
@@ -61,8 +61,30 @@
 
 #ifndef NSPR_LOCK
 
-/* Implement NativeCompareAndSwap. */
+#include <memory.h>
 
+static PRLock **global_locks;
+static uint32 global_lock_count = 1;
+static uint32 global_locks_log2 = 0;
+static uint32 global_locks_mask = 0;
+
+#define GLOBAL_LOCK_INDEX(id)   (((uint32)(id) >> 2) & global_locks_mask)
+
+static void
+js_LockGlobal(void *id)
+{
+    uint32 i = GLOBAL_LOCK_INDEX(id);
+    PR_Lock(global_locks[i]);
+}
+
+static void
+js_UnlockGlobal(void *id)
+{
+    uint32 i = GLOBAL_LOCK_INDEX(id);
+    PR_Unlock(global_locks[i]);
+}
+
+/* Exclude Alpha NT. */
 #if defined(_WIN32) && defined(_M_IX86)
 #pragma warning( disable : 4035 )
 JS_BEGIN_EXTERN_C
@@ -72,7 +94,7 @@ JS_END_EXTERN_C
 #pragma intrinsic(_InterlockedCompareExchange)
 
 static JS_INLINE int
-NativeCompareAndSwapHelper(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwapHelper(jsword *w, jsword ov, jsword nv)
 {
     _InterlockedCompareExchange(w, nv, ov);
     __asm {
@@ -81,9 +103,9 @@ NativeCompareAndSwapHelper(jsword *w, js
 }
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
-    return (NativeCompareAndSwapHelper(w, ov, nv) & 1);
+    return (js_CompareAndSwapHelper(w, ov, nv) & 1);
 }
 
 #elif defined(XP_MACOSX) || defined(DARWIN)
@@ -91,7 +113,7 @@ NativeCompareAndSwap(jsword *w, jsword o
 #include <libkern/OSAtomic.h>
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     /* Details on these functions available in the manpage for atomic */
 #if JS_BYTES_PER_WORD == 8 && JS_BYTES_PER_LONG != 8
@@ -105,7 +127,7 @@ NativeCompareAndSwap(jsword *w, jsword o
 
 /* Note: This fails on 386 cpus, cmpxchgl is a >= 486 instruction */
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     unsigned int res;
 
@@ -123,7 +145,7 @@ NativeCompareAndSwap(jsword *w, jsword o
 #elif defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
 #if defined(__GNUC__)
     unsigned int res;
@@ -151,80 +173,16 @@ 1:"
 #include <sys/atomic_op.h>
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     return !_check_lock((atomic_p)w, ov, nv);
 }
 
-#elif defined(USE_ARM_KUSER)
-
-/* See https://bugzilla.mozilla.org/show_bug.cgi?id=429387 for a
- * description of this ABI; this is a function provided at a fixed
- * location by the kernel in the memory space of each process.
- */
-typedef int (__kernel_cmpxchg_t)(int oldval, int newval, volatile int *ptr);
-#define __kernel_cmpxchg (*(__kernel_cmpxchg_t *)0xffff0fc0)
-
-JS_STATIC_ASSERT(sizeof(jsword) == sizeof(int));
-
-static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
-{
-    volatile int *vp = (volatile int*)w;
-    return !__kernel_cmpxchg(ov, nv, vp);
-}
-
-#elif defined(__GNUC__) &&                                                    \
-    (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
-
-static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
-{
-    return __sync_bool_compare_and_swap(w, ov, nv);
-}
-
 #else
 
-#error "JS_HAS_NATIVE_COMPARE_AND_SWAP should be 0 if your platform lacks a compare-and-swap instruction."
+#error "Define NSPR_LOCK if your platform lacks a compare-and-swap instruction."
 
 #endif /* arch-tests */
-
-struct JSFatLock {
-    int         susp;
-    PRLock      *slock;
-    PRCondVar   *svar;
-    JSFatLock   *next;
-    JSFatLock   **prevp;
-};
-
-typedef struct JSFatLockTable {
-    JSFatLock   *free;
-    JSFatLock   *taken;
-} JSFatLockTable;
-
-#define GLOBAL_LOCK_INDEX(id)   (((uint32)(jsuword)(id)>>2) & global_locks_mask)
-
-static void
-js_Dequeue(JSThinLock *);
-
-static PRLock **global_locks;
-static uint32 global_lock_count = 1;
-static uint32 global_locks_log2 = 0;
-static uint32 global_locks_mask = 0;
-
-static void
-js_LockGlobal(void *id)
-{
-    uint32 i = GLOBAL_LOCK_INDEX(id);
-    PR_Lock(global_locks[i]);
-}
-
-static void
-js_UnlockGlobal(void *id)
-{
-    uint32 i = GLOBAL_LOCK_INDEX(id);
-    PR_Unlock(global_locks[i]);
-}
 
 #endif /* !NSPR_LOCK */
 
@@ -251,6 +209,10 @@ js_FinishLock(JSThinLock *tl)
     JS_ASSERT(tl->fat == NULL);
 #endif
 }
+
+#ifndef NSPR_LOCK
+static void js_Dequeue(JSThinLock *);
+#endif
 
 #ifdef DEBUG_SCOPE_COUNT
 
@@ -605,7 +567,7 @@ js_GetSlotThreadSafe(JSContext *cx, JSOb
     tl = &title->lock;
     me = CX_THINLOCK_ID(cx);
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (NativeCompareAndSwap(&tl->owner, 0, me)) {
+    if (js_CompareAndSwap(&tl->owner, 0, me)) {
         /*
          * Got the lock with one compare-and-swap.  Even so, someone else may
          * have mutated obj so it now has its own scope and lock, which would
@@ -614,7 +576,7 @@ js_GetSlotThreadSafe(JSContext *cx, JSOb
          */
         if (scope == OBJ_SCOPE(obj)) {
             v = STOBJ_GET_SLOT(obj, slot);
-            if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
+            if (!js_CompareAndSwap(&tl->owner, me, 0)) {
                 /* Assert that scope locks never revert to flyweight. */
                 JS_ASSERT(title->ownercx != cx);
                 LOGIT(scope, '1');
@@ -623,7 +585,7 @@ js_GetSlotThreadSafe(JSContext *cx, JSOb
             }
             return v;
         }
-        if (!NativeCompareAndSwap(&tl->owner, me, 0))
+        if (!js_CompareAndSwap(&tl->owner, me, 0))
             js_Dequeue(tl);
     }
     else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
@@ -701,10 +663,10 @@ js_SetSlotThreadSafe(JSContext *cx, JSOb
     tl = &title->lock;
     me = CX_THINLOCK_ID(cx);
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (NativeCompareAndSwap(&tl->owner, 0, me)) {
+    if (js_CompareAndSwap(&tl->owner, 0, me)) {
         if (scope == OBJ_SCOPE(obj)) {
             LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, v);
-            if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
+            if (!js_CompareAndSwap(&tl->owner, me, 0)) {
                 /* Assert that scope locks never revert to flyweight. */
                 JS_ASSERT(title->ownercx != cx);
                 LOGIT(scope, '1');
@@ -713,7 +675,7 @@ js_SetSlotThreadSafe(JSContext *cx, JSOb
             }
             return;
         }
-        if (!NativeCompareAndSwap(&tl->owner, me, 0))
+        if (!js_CompareAndSwap(&tl->owner, me, 0))
             js_Dequeue(tl);
     }
     else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
@@ -900,23 +862,7 @@ js_CleanupLocks()
 #endif /* !NSPR_LOCK */
 }
 
-#ifdef NSPR_LOCK
-
-static JS_INLINE void
-ThinLock(JSThinLock *tl, jsword me)
-{
-    JS_ACQUIRE_LOCK((JSLock *) tl->fat);
-    tl->owner = me;
-}
-
-static JS_INLINE void
-ThinUnlock(JSThinLock *tl, jsword /*me*/)
-{
-    tl->owner = 0;
-    JS_RELEASE_LOCK((JSLock *) tl->fat);
-}
-
-#else
+#ifndef NSPR_LOCK
 
 /*
  * Fast locking and unlocking is implemented by delaying the allocation of a
@@ -1006,13 +952,13 @@ js_Enqueue(JSThinLock *tl, jsword me)
     for (;;) {
         o = ReadWord(tl->owner);
         n = Thin_SetWait(o);
-        if (o != 0 && NativeCompareAndSwap(&tl->owner, o, n)) {
+        if (o != 0 && js_CompareAndSwap(&tl->owner, o, n)) {
             if (js_SuspendThread(tl))
                 me = Thin_RemoveWait(me);
             else
                 me = Thin_SetWait(me);
         }
-        else if (NativeCompareAndSwap(&tl->owner, 0, me)) {
+        else if (js_CompareAndSwap(&tl->owner, 0, me)) {
             js_UnlockGlobal(tl);
             return;
         }
@@ -1028,16 +974,16 @@ js_Dequeue(JSThinLock *tl)
     o = ReadWord(tl->owner);
     JS_ASSERT(Thin_GetWait(o) != 0);
     JS_ASSERT(tl->fat != NULL);
-    if (!NativeCompareAndSwap(&tl->owner, o, 0)) /* release it */
+    if (!js_CompareAndSwap(&tl->owner, o, 0)) /* release it */
         JS_ASSERT(0);
     js_ResumeThread(tl);
 }
 
-static JS_INLINE void
-ThinLock(JSThinLock *tl, jsword me)
+JS_INLINE void
+js_Lock(JSThinLock *tl, jsword me)
 {
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (NativeCompareAndSwap(&tl->owner, 0, me))
+    if (js_CompareAndSwap(&tl->owner, 0, me))
         return;
     if (Thin_RemoveWait(ReadWord(tl->owner)) != me)
         js_Enqueue(tl, me);
@@ -1047,16 +993,16 @@ ThinLock(JSThinLock *tl, jsword me)
 #endif
 }
 
-static JS_INLINE void
-ThinUnlock(JSThinLock *tl, jsword me)
+JS_INLINE void
+js_Unlock(JSThinLock *tl, jsword me)
 {
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
 
     /*
-     * Since we can race with the NativeCompareAndSwap in js_Enqueue, we need
+     * Since we can race with the CompareAndSwap in js_Enqueue, we need
      * to use a C_A_S here as well -- Arjan van de Ven 30/1/08
      */
-    if (NativeCompareAndSwap(&tl->owner, me, 0))
+    if (js_CompareAndSwap(&tl->owner, me, 0))
         return;
 
     JS_ASSERT(Thin_GetWait(tl->owner));
@@ -1069,18 +1015,6 @@ ThinUnlock(JSThinLock *tl, jsword me)
 }
 
 #endif /* !NSPR_LOCK */
-
-void
-js_Lock(JSContext *cx, JSThinLock *tl)
-{
-    ThinLock(tl, CX_THINLOCK_ID(cx));
-}
-
-void
-js_Unlock(JSContext *cx, JSThinLock *tl)
-{
-    ThinUnlock(tl, CX_THINLOCK_ID(cx));
-}
 
 void
 js_LockRuntime(JSRuntime *rt)
@@ -1117,7 +1051,8 @@ js_LockTitle(JSContext *cx, JSTitle *tit
         LOGIT(scope, '+');
         title->u.count++;
     } else {
-        ThinLock(&title->lock, me);
+        JSThinLock *tl = &title->lock;
+        JS_LOCK0(tl, me);
         JS_ASSERT(title->u.count == 0);
         LOGIT(scope, '1');
         title->u.count = 1;
@@ -1164,8 +1099,10 @@ js_UnlockTitle(JSContext *cx, JSTitle *t
         return;
     }
     LOGIT(scope, '-');
-    if (--title->u.count == 0)
-        ThinUnlock(&title->lock, me);
+    if (--title->u.count == 0) {
+        JSThinLock *tl = &title->lock;
+        JS_UNLOCK0(tl, me);
+    }
 }
 
 /*
@@ -1175,6 +1112,9 @@ void
 void
 js_TransferTitle(JSContext *cx, JSTitle *oldtitle, JSTitle *newtitle)
 {
+    jsword me;
+    JSThinLock *tl;
+
     JS_ASSERT(JS_IS_TITLE_LOCKED(cx, newtitle));
 
     /*
@@ -1233,7 +1173,9 @@ js_TransferTitle(JSContext *cx, JSTitle 
      */
     LOGIT(oldscope, '0');
     oldtitle->u.count = 0;
-    ThinUnlock(&oldtitle->lock, CX_THINLOCK_ID(cx));
+    tl = &oldtitle->lock;
+    me = CX_THINLOCK_ID(cx);
+    JS_UNLOCK0(tl, me);
 }
 
 void
diff -r ed28977f2452 js/src/jslock.h
--- a/js/src/jslock.h	Thu Jul 17 10:22:45 2008 +0200
+++ b/js/src/jslock.h	Fri Jul 18 17:03:02 2008 +0300
@@ -39,44 +39,32 @@
 #ifndef jslock_h__
 #define jslock_h__
 
+#ifdef JS_THREADSAFE
+
 #include "jstypes.h"
+#include "pratom.h"
+#include "prlock.h"
+#include "prcvar.h"
+#include "prthread.h"
+
 #include "jsprvtd.h"    /* for JSScope, etc. */
 #include "jspubtd.h"    /* for JSRuntime, etc. */
 
-#ifdef JS_THREADSAFE
-# include "pratom.h"
-# include "prlock.h"
-# include "prcvar.h"
-# include "prthread.h"
-#endif
-
 JS_BEGIN_EXTERN_C
-
-#ifdef JS_THREADSAFE
-
-#if (defined(_WIN32) && defined(_M_IX86)) ||                                  \
-    (defined(__GNUC__) && defined(__i386__)) ||                               \
-    (defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)) ||           \
-    defined(AIX) ||                                                           \
-    defined(USE_ARM_KUSER) ||                                                 \
-    (defined(__GNUC__) &&                                                     \
-     (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)))
-# define JS_HAS_NATIVE_COMPARE_AND_SWAP 1
-#else
-# define JS_HAS_NATIVE_COMPARE_AND_SWAP 0
-#endif
-
-#if defined(JS_USE_ONLY_NSPR_LOCKS) || !JS_HAS_NATIVE_COMPARE_AND_SWAP
-# define NSPR_LOCK 1
-#else
-# undef NSPR_LOCK
-#endif
 
 #define Thin_GetWait(W) ((jsword)(W) & 0x1)
 #define Thin_SetWait(W) ((jsword)(W) | 0x1)
 #define Thin_RemoveWait(W) ((jsword)(W) & ~0x1)
 
 typedef struct JSFatLock JSFatLock;
+
+struct JSFatLock {
+    int         susp;
+    PRLock      *slock;
+    PRCondVar   *svar;
+    JSFatLock   *next;
+    JSFatLock   **prevp;
+};
 
 typedef struct JSThinLock {
     jsword      owner;
@@ -87,6 +75,11 @@ typedef struct JSThinLock {
 #define CURRENT_THREAD_IS_ME(me) (((JSThread *)me)->id == js_CurrentThreadId())
 
 typedef PRLock JSLock;
+
+typedef struct JSFatLockTable {
+    JSFatLock   *free;
+    JSFatLock   *taken;
+} JSFatLockTable;
 
 typedef struct JSTitle JSTitle;
 
@@ -101,7 +94,7 @@ struct JSTitle {
     const char      *file[4];           /* file where lock was (re-)taken */
     unsigned int    line[4];            /* line where lock was (re-)taken */
 #endif
-};
+};    
 
 /*
  * Title structures must be immediately preceded by JSObjectMap structures for
@@ -126,6 +119,8 @@ struct JSTitle {
 #define JS_DESTROY_LOCK(l)          PR_DestroyLock(l)
 #define JS_ACQUIRE_LOCK(l)          PR_Lock(l)
 #define JS_RELEASE_LOCK(l)          PR_Unlock(l)
+#define JS_LOCK0(P,M)               js_Lock(P,M)
+#define JS_UNLOCK0(P,M)             js_Unlock(P,M)
 
 #define JS_NEW_CONDVAR(l)           PR_NewCondVar(l)
 #define JS_DESTROY_CONDVAR(cv)      PR_DestroyCondVar(cv)
@@ -143,9 +138,6 @@ struct JSTitle {
     js_SetScopeInfo(scope_, file_, line_)
 
 #endif
-
-#define JS_LOCK(cx, tl)             js_Lock(cx, tl)
-#define JS_UNLOCK(cx, tl)           js_Unlock(cx, tl)
 
 #define JS_LOCK_RUNTIME(rt)         js_LockRuntime(rt)
 #define JS_UNLOCK_RUNTIME(rt)       js_UnlockRuntime(rt)
@@ -178,9 +170,6 @@ struct JSTitle {
 #define JS_TRANSFER_SCOPE_LOCK(cx, scope, newscope)                            \
     js_TransferTitle(cx, &scope->title, &newscope->title)
 
-
-extern void js_Lock(JSContext *cx, JSThinLock *tl);
-extern void js_Unlock(JSContext *cx, JSThinLock *tl);
 extern void js_LockRuntime(JSRuntime *rt);
 extern void js_UnlockRuntime(JSRuntime *rt);
 extern void js_LockObj(JSContext *cx, JSObject *obj);
@@ -233,7 +222,31 @@ extern void js_SetScopeInfo(JSScope *sco
         JS_LOCK_RUNTIME_VOID(_rt, e);                                         \
     JS_END_MACRO
 
+#if defined(JS_USE_ONLY_NSPR_LOCKS) ||                                        \
+    !( (defined(_WIN32) && defined(_M_IX86)) ||                               \
+       (defined(__GNUC__) && defined(__i386__)) ||                            \
+       (defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)) ||        \
+       defined(AIX) )
+
+#define NSPR_LOCK 1
+
+#undef JS_LOCK0
+#undef JS_UNLOCK0
+#define JS_LOCK0(P,M)   (JS_ACQUIRE_LOCK(((JSLock*)(P)->fat)), (P)->owner = (M))
+#define JS_UNLOCK0(P,M) ((P)->owner = 0, JS_RELEASE_LOCK(((JSLock*)(P)->fat)))
+
+#else  /* arch-tests */
+
+#undef NSPR_LOCK
+
+extern void js_Lock(JSThinLock *tl, jsword me);
+extern void js_Unlock(JSThinLock *tl, jsword me);
+
+#endif /* arch-tests */
+
 #else  /* !JS_THREADSAFE */
+
+JS_BEGIN_EXTERN_C
 
 #define JS_ATOMIC_INCREMENT(p)      (++*(p))
 #define JS_ATOMIC_DECREMENT(p)      (--*(p))
@@ -244,8 +257,8 @@ extern void js_SetScopeInfo(JSScope *sco
 #define JS_DESTROY_LOCK(l)          ((void)0)
 #define JS_ACQUIRE_LOCK(l)          ((void)0)
 #define JS_RELEASE_LOCK(l)          ((void)0)
-#define JS_LOCK(cx, tl)             ((void)0)
-#define JS_UNLOCK(cx, tl)           ((void)0)
+#define JS_LOCK0(P,M)               ((void)0)
+#define JS_UNLOCK0(P,M)             ((void)0)
 
 #define JS_NEW_CONDVAR(l)           NULL
 #define JS_DESTROY_CONDVAR(cv)      ((void)0)
@@ -285,6 +298,9 @@ extern void js_SetScopeInfo(JSScope *sco
                                                     JS_NO_TIMEOUT)
 #define JS_NOTIFY_REQUEST_DONE(rt)  JS_NOTIFY_CONDVAR((rt)->requestDone)
 
+#define JS_LOCK(P,CX)               JS_LOCK0(P, CX_THINLOCK_ID(CX))
+#define JS_UNLOCK(P,CX)             JS_UNLOCK0(P, CX_THINLOCK_ID(CX))
+ 
 #ifndef SET_OBJ_INFO
 #define SET_OBJ_INFO(obj,f,l)       ((void)0)
 #endif
