diff -ruN -p -U5 mozilla/js.orig/src/jsatom.cpp mozilla/js/src/jsatom.cpp
--- mozilla/js.orig/src/jsatom.cpp	2008-07-20 17:32:25.000000000 +0300
+++ mozilla/js/src/jsatom.cpp	2008-07-20 17:33:00.000000000 +0300
@@ -576,23 +576,23 @@ js_AtomizeDouble(JSContext *cx, jsdouble
     jsval v;
 
     state = &cx->runtime->atomState;
     table = &state->doubleAtoms;
 
-    JS_LOCK(cx, &state->lock);
+    JS_LOCK(&state->lock, cx);
     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, &d, JS_DHASH_ADD));
     if (!entry)
         goto failed_hash_add;
     if (entry->keyAndFlags == 0) {
         gen = ++table->generation;
-        JS_UNLOCK(cx, &state->lock);
+        JS_UNLOCK(&state->lock, cx);
 
         key = js_NewWeaklyRootedDouble(cx, d);
         if (!key)
             return NULL;
 
-        JS_LOCK(cx, &state->lock);
+        JS_LOCK(&state->lock, cx);
         if (table->generation == gen) {
             JS_ASSERT(entry->keyAndFlags == 0);
         } else {
             entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, key,
                                                        JS_DHASH_ADD));
@@ -606,16 +606,16 @@ js_AtomizeDouble(JSContext *cx, jsdouble
     }
 
   finish:
     v = DOUBLE_TO_JSVAL((jsdouble *)ATOM_ENTRY_KEY(entry));
     cx->weakRoots.lastAtom = v;
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock,cx);
 
     return (JSAtom *)v;
 
   failed_hash_add:
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock,cx);
     JS_ReportOutOfMemory(cx);
     return NULL;
 }
 
 JSAtom *
@@ -632,11 +632,11 @@ js_AtomizeString(JSContext *cx, JSString
     JS_ASSERT_IF(flags & ATOM_NOCOPY, flags & ATOM_TMPSTR);
 
     state = &cx->runtime->atomState;
     table = &state->stringAtoms;
 
-    JS_LOCK(cx, &state->lock);
+    JS_LOCK(&state->lock, cx);
     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, str, JS_DHASH_ADD));
     if (!entry)
         goto failed_hash_add;
     if (entry->keyAndFlags != 0) {
         key = (JSString *)ATOM_ENTRY_KEY(entry);
@@ -651,11 +651,11 @@ js_AtomizeString(JSContext *cx, JSString
         if (!(flags & ATOM_TMPSTR) && JSSTRING_IS_FLAT(str)) {
             JSFLATSTR_CLEAR_MUTABLE(str);
             key = str;
         } else {
             gen = table->generation;
-            JS_UNLOCK(cx, &state->lock);
+            JS_UNLOCK(&state->lock, cx);
 
             if (flags & ATOM_TMPSTR) {
                 if (flags & ATOM_NOCOPY) {
                     key = js_NewString(cx, JSFLATSTR_CHARS(str),
                                        JSFLATSTR_LENGTH(str));
@@ -675,11 +675,11 @@ js_AtomizeString(JSContext *cx, JSString
                 if (!js_UndependString(cx, str))
                     return NULL;
                 key = str;
             }
 
-            JS_LOCK(cx, &state->lock);
+            JS_LOCK(&state->lock, cx);
             if (table->generation == gen) {
                 JS_ASSERT(entry->keyAndFlags == 0);
             } else {
                 entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, key,
                                                            JS_DHASH_ADD));
@@ -699,15 +699,15 @@ js_AtomizeString(JSContext *cx, JSString
   finish:
     ADD_ATOM_ENTRY_FLAGS(entry, flags & (ATOM_PINNED | ATOM_INTERNED));
     JS_ASSERT(JSSTRING_IS_ATOMIZED(key));
     v = STRING_TO_JSVAL(key);
     cx->weakRoots.lastAtom = v;
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock, cx);
     return (JSAtom *)v;
 
   failed_hash_add:
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock,cx);
     JS_ReportOutOfMemory(cx);
     return NULL;
 }
 
 JSAtom *
@@ -764,16 +764,16 @@ js_GetExistingStringAtom(JSContext *cx, 
     JSDHashEntryHdr *hdr;
 
     JSFLATSTR_INIT(&str, (jschar *)chars, length);
     state = &cx->runtime->atomState;
 
-    JS_LOCK(cx, &state->lock);
+    JS_LOCK(&state->lock, cx);
     hdr = JS_DHashTableOperate(&state->stringAtoms, &str, JS_DHASH_LOOKUP);
     str2 = JS_DHASH_ENTRY_IS_BUSY(hdr)
            ? (JSString *)ATOM_ENTRY_KEY(TO_ATOM_ENTRY(hdr))
            : NULL;
-    JS_UNLOCK(cx, &state->lock);
+    JS_UNLOCK(&state->lock, cx);
 
     return str2 ? (JSAtom *)STRING_TO_JSVAL(str2) : NULL;
 }
 
 JSBool
diff -ruN -p -U5 mozilla/js.orig/src/jslock.cpp mozilla/js/src/jslock.cpp
--- mozilla/js.orig/src/jslock.cpp	2008-07-20 17:32:25.000000000 +0300
+++ mozilla/js/src/jslock.cpp	2008-07-20 17:33:54.000000000 +0300
@@ -59,41 +59,63 @@
 
 #define ReadWord(W) (W)
 
 #ifndef NSPR_LOCK
 
-/* Implement NativeCompareAndSwap. */
+#include <memory.h>
 
+static PRLock **global_locks;
+static uint32 global_lock_count = 1;
+static uint32 global_locks_log2 = 0;
+static uint32 global_locks_mask = 0;
+
+#define GLOBAL_LOCK_INDEX(id)   (((uint32)(id) >> 2) & global_locks_mask)
+
+static void
+js_LockGlobal(void *id)
+{
+    uint32 i = GLOBAL_LOCK_INDEX(id);
+    PR_Lock(global_locks[i]);
+}
+
+static void
+js_UnlockGlobal(void *id)
+{
+    uint32 i = GLOBAL_LOCK_INDEX(id);
+    PR_Unlock(global_locks[i]);
+}
+
+/* Exclude Alpha NT. */
 #if defined(_WIN32) && defined(_M_IX86)
 #pragma warning( disable : 4035 )
 JS_BEGIN_EXTERN_C
 extern long __cdecl
 _InterlockedCompareExchange(long *volatile dest, long exchange, long comp);
 JS_END_EXTERN_C
 #pragma intrinsic(_InterlockedCompareExchange)
 
 static JS_INLINE int
-NativeCompareAndSwapHelper(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwapHelper(jsword *w, jsword ov, jsword nv)
 {
     _InterlockedCompareExchange(w, nv, ov);
     __asm {
         sete al
     }
 }
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
-    return (NativeCompareAndSwapHelper(w, ov, nv) & 1);
+    return (js_CompareAndSwapHelper(w, ov, nv) & 1);
 }
 
 #elif defined(XP_MACOSX) || defined(DARWIN)
 
 #include <libkern/OSAtomic.h>
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     /* Details on these functions available in the manpage for atomic */
 #if JS_BYTES_PER_WORD == 8 && JS_BYTES_PER_LONG != 8
     return OSAtomicCompareAndSwap64Barrier(ov, nv, (int64_t*) w);
 #else
@@ -103,11 +125,11 @@ NativeCompareAndSwap(jsword *w, jsword o
 
 #elif defined(__GNUC__) && defined(__i386__)
 
 /* Note: This fails on 386 cpus, cmpxchgl is a >= 486 instruction */
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     unsigned int res;
 
     __asm__ __volatile__ (
                           "lock\n"
@@ -121,11 +143,11 @@ NativeCompareAndSwap(jsword *w, jsword o
 }
 
 #elif defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
 #if defined(__GNUC__)
     unsigned int res;
     JS_ASSERT(ov != nv);
     asm volatile ("\
@@ -149,11 +171,11 @@ mov 0,%0\n\
 #elif defined(AIX)
 
 #include <sys/atomic_op.h>
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     return !_check_lock((atomic_p)w, ov, nv);
 }
 
 #elif defined(USE_ARM_KUSER)
@@ -166,68 +188,22 @@ typedef int (__kernel_cmpxchg_t)(int old
 #define __kernel_cmpxchg (*(__kernel_cmpxchg_t *)0xffff0fc0)
 
 JS_STATIC_ASSERT(sizeof(jsword) == sizeof(int));
 
 static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
+js_CompareAndSwap(jsword *w, jsword ov, jsword nv)
 {
     volatile int *vp = (volatile int*)w;
     return !__kernel_cmpxchg(ov, nv, vp);
 }
 
-#elif defined(__GNUC__) &&                                                    \
-    (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
-
-static JS_INLINE int
-NativeCompareAndSwap(jsword *w, jsword ov, jsword nv)
-{
-    return __sync_bool_compare_and_swap(w, ov, nv);
-}
-
 #else
 
-#error "JS_HAS_NATIVE_COMPARE_AND_SWAP should be 0 if your platform lacks a compare-and-swap instruction."
+#error "Define NSPR_LOCK if your platform lacks a compare-and-swap instruction."
 
 #endif /* arch-tests */
 
-struct JSFatLock {
-    int         susp;
-    PRLock      *slock;
-    PRCondVar   *svar;
-    JSFatLock   *next;
-    JSFatLock   **prevp;
-};
-
-typedef struct JSFatLockTable {
-    JSFatLock   *free;
-    JSFatLock   *taken;
-} JSFatLockTable;
-
-#define GLOBAL_LOCK_INDEX(id)   (((uint32)(jsuword)(id)>>2) & global_locks_mask)
-
-static void
-js_Dequeue(JSThinLock *);
-
-static PRLock **global_locks;
-static uint32 global_lock_count = 1;
-static uint32 global_locks_log2 = 0;
-static uint32 global_locks_mask = 0;
-
-static void
-js_LockGlobal(void *id)
-{
-    uint32 i = GLOBAL_LOCK_INDEX(id);
-    PR_Lock(global_locks[i]);
-}
-
-static void
-js_UnlockGlobal(void *id)
-{
-    uint32 i = GLOBAL_LOCK_INDEX(id);
-    PR_Unlock(global_locks[i]);
-}
-
 #endif /* !NSPR_LOCK */
 
 void
 js_InitLock(JSThinLock *tl)
 {
@@ -250,10 +226,14 @@ js_FinishLock(JSThinLock *tl)
     JS_ASSERT(tl->owner == 0);
     JS_ASSERT(tl->fat == NULL);
 #endif
 }
 
+#ifndef NSPR_LOCK
+static void js_Dequeue(JSThinLock *);
+#endif
+
 #ifdef DEBUG_SCOPE_COUNT
 
 #include <stdio.h>
 #include "jsdhash.h"
 
@@ -603,29 +583,29 @@ js_GetSlotThreadSafe(JSContext *cx, JSOb
 
 #ifndef NSPR_LOCK
     tl = &title->lock;
     me = CX_THINLOCK_ID(cx);
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (NativeCompareAndSwap(&tl->owner, 0, me)) {
+    if (js_CompareAndSwap(&tl->owner, 0, me)) {
         /*
          * Got the lock with one compare-and-swap.  Even so, someone else may
          * have mutated obj so it now has its own scope and lock, which would
          * require either a restart from the top of this routine, or a thin
          * lock release followed by fat lock acquisition.
          */
         if (scope == OBJ_SCOPE(obj)) {
             v = STOBJ_GET_SLOT(obj, slot);
-            if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
+            if (!js_CompareAndSwap(&tl->owner, me, 0)) {
                 /* Assert that scope locks never revert to flyweight. */
                 JS_ASSERT(title->ownercx != cx);
                 LOGIT(scope, '1');
                 title->u.count = 1;
                 js_UnlockObj(cx, obj);
             }
             return v;
         }
-        if (!NativeCompareAndSwap(&tl->owner, me, 0))
+        if (!js_CompareAndSwap(&tl->owner, me, 0))
             js_Dequeue(tl);
     }
     else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
         return STOBJ_GET_SLOT(obj, slot);
     }
@@ -699,23 +679,23 @@ js_SetSlotThreadSafe(JSContext *cx, JSOb
 
 #ifndef NSPR_LOCK
     tl = &title->lock;
     me = CX_THINLOCK_ID(cx);
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (NativeCompareAndSwap(&tl->owner, 0, me)) {
+    if (js_CompareAndSwap(&tl->owner, 0, me)) {
         if (scope == OBJ_SCOPE(obj)) {
             LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, v);
-            if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
+            if (!js_CompareAndSwap(&tl->owner, me, 0)) {
                 /* Assert that scope locks never revert to flyweight. */
                 JS_ASSERT(title->ownercx != cx);
                 LOGIT(scope, '1');
                 title->u.count = 1;
                 js_UnlockObj(cx, obj);
             }
             return;
         }
-        if (!NativeCompareAndSwap(&tl->owner, me, 0))
+        if (!js_CompareAndSwap(&tl->owner, me, 0))
             js_Dequeue(tl);
     }
     else if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
         LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, v);
         return;
@@ -898,27 +878,11 @@ js_CleanupLocks()
         fl_list_table_len = 0;
     }
 #endif /* !NSPR_LOCK */
 }
 
-#ifdef NSPR_LOCK
-
-static JS_INLINE void
-ThinLock(JSThinLock *tl, jsword me)
-{
-    JS_ACQUIRE_LOCK((JSLock *) tl->fat);
-    tl->owner = me;
-}
-
-static JS_INLINE void
-ThinUnlock(JSThinLock *tl, jsword /*me*/)
-{
-    tl->owner = 0;
-    JS_RELEASE_LOCK((JSLock *) tl->fat);
-}
-
-#else
+#ifndef NSPR_LOCK
 
 /*
  * Fast locking and unlocking is implemented by delaying the allocation of a
  * system lock (fat lock) until contention.  As long as a locking thread A
  * runs uncontended, the lock is represented solely by storing A's identity in
@@ -1004,17 +968,17 @@ js_Enqueue(JSThinLock *tl, jsword me)
 
     js_LockGlobal(tl);
     for (;;) {
         o = ReadWord(tl->owner);
         n = Thin_SetWait(o);
-        if (o != 0 && NativeCompareAndSwap(&tl->owner, o, n)) {
+        if (o != 0 && js_CompareAndSwap(&tl->owner, o, n)) {
             if (js_SuspendThread(tl))
                 me = Thin_RemoveWait(me);
             else
                 me = Thin_SetWait(me);
         }
-        else if (NativeCompareAndSwap(&tl->owner, 0, me)) {
+        else if (js_CompareAndSwap(&tl->owner, 0, me)) {
             js_UnlockGlobal(tl);
             return;
         }
     }
 }
@@ -1026,39 +990,39 @@ js_Dequeue(JSThinLock *tl)
 
     js_LockGlobal(tl);
     o = ReadWord(tl->owner);
     JS_ASSERT(Thin_GetWait(o) != 0);
     JS_ASSERT(tl->fat != NULL);
-    if (!NativeCompareAndSwap(&tl->owner, o, 0)) /* release it */
+    if (!js_CompareAndSwap(&tl->owner, o, 0)) /* release it */
         JS_ASSERT(0);
     js_ResumeThread(tl);
 }
 
-static JS_INLINE void
-ThinLock(JSThinLock *tl, jsword me)
+JS_INLINE void
+js_Lock(JSThinLock *tl, jsword me)
 {
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
-    if (NativeCompareAndSwap(&tl->owner, 0, me))
+    if (js_CompareAndSwap(&tl->owner, 0, me))
         return;
     if (Thin_RemoveWait(ReadWord(tl->owner)) != me)
         js_Enqueue(tl, me);
 #ifdef DEBUG
     else
         JS_ASSERT(0);
 #endif
 }
 
-static JS_INLINE void
-ThinUnlock(JSThinLock *tl, jsword me)
+JS_INLINE void
+js_Unlock(JSThinLock *tl, jsword me)
 {
     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
 
     /*
-     * Since we can race with the NativeCompareAndSwap in js_Enqueue, we need
+     * Since we can race with the CompareAndSwap in js_Enqueue, we need
      * to use a C_A_S here as well -- Arjan van de Ven 30/1/08
      */
-    if (NativeCompareAndSwap(&tl->owner, me, 0))
+    if (js_CompareAndSwap(&tl->owner, me, 0))
         return;
 
     JS_ASSERT(Thin_GetWait(tl->owner));
     if (Thin_RemoveWait(ReadWord(tl->owner)) == me)
         js_Dequeue(tl);
@@ -1069,22 +1033,10 @@ ThinUnlock(JSThinLock *tl, jsword me)
 }
 
 #endif /* !NSPR_LOCK */
 
 void
-js_Lock(JSContext *cx, JSThinLock *tl)
-{
-    ThinLock(tl, CX_THINLOCK_ID(cx));
-}
-
-void
-js_Unlock(JSContext *cx, JSThinLock *tl)
-{
-    ThinUnlock(tl, CX_THINLOCK_ID(cx));
-}
-
-void
 js_LockRuntime(JSRuntime *rt)
 {
     PR_Lock(rt->rtLock);
 #ifdef DEBUG
     rt->rtLockOwner = js_CurrentThreadId();
@@ -1115,11 +1067,12 @@ js_LockTitle(JSContext *cx, JSTitle *tit
     if (Thin_RemoveWait(ReadWord(title->lock.owner)) == me) {
         JS_ASSERT(title->u.count > 0);
         LOGIT(scope, '+');
         title->u.count++;
     } else {
-        ThinLock(&title->lock, me);
+        JSThinLock *tl = &title->lock;
+        JS_LOCK0(tl, me);
         JS_ASSERT(title->u.count == 0);
         LOGIT(scope, '1');
         title->u.count = 1;
     }
 }
@@ -1162,21 +1115,26 @@ js_UnlockTitle(JSContext *cx, JSTitle *t
     if (Thin_RemoveWait(ReadWord(title->lock.owner)) != me) {
         JS_ASSERT(0);   /* unbalanced unlock */
         return;
     }
     LOGIT(scope, '-');
-    if (--title->u.count == 0)
-        ThinUnlock(&title->lock, me);
+    if (--title->u.count == 0) {
+        JSThinLock *tl = &title->lock;
+        JS_UNLOCK0(tl, me);
+    }
 }
 
 /*
  * NB: oldtitle may be null if our caller is js_GetMutableScope and it just
  * dropped the last reference to oldtitle.
  */
 void
 js_TransferTitle(JSContext *cx, JSTitle *oldtitle, JSTitle *newtitle)
 {
+    jsword me;
+    JSThinLock *tl;
+
     JS_ASSERT(JS_IS_TITLE_LOCKED(cx, newtitle));
 
     /*
      * If the last reference to oldtitle went away, newtitle needs no lock
      * state update.
@@ -1231,11 +1189,13 @@ js_TransferTitle(JSContext *cx, JSTitle 
     /*
      * Reset oldtitle's lock state so that it is completely unlocked.
      */
     LOGIT(oldscope, '0');
     oldtitle->u.count = 0;
-    ThinUnlock(&oldtitle->lock, CX_THINLOCK_ID(cx));
+    tl = &oldtitle->lock;
+    me = CX_THINLOCK_ID(cx);
+    JS_UNLOCK0(tl, me);
 }
 
 void
 js_LockObj(JSContext *cx, JSObject *obj)
 {
diff -ruN -p -U5 mozilla/js.orig/src/jslock.h mozilla/js/src/jslock.h
--- mozilla/js.orig/src/jslock.h	2008-07-20 17:32:25.000000000 +0300
+++ mozilla/js/src/jslock.h	2008-07-20 17:33:54.000000000 +0300
@@ -37,59 +37,52 @@
  *
  * ***** END LICENSE BLOCK ***** */
 #ifndef jslock_h__
 #define jslock_h__
 
+#ifdef JS_THREADSAFE
+
 #include "jstypes.h"
+#include "pratom.h"
+#include "prlock.h"
+#include "prcvar.h"
+#include "prthread.h"
+
 #include "jsprvtd.h"    /* for JSScope, etc. */
 #include "jspubtd.h"    /* for JSRuntime, etc. */
 
-#ifdef JS_THREADSAFE
-# include "pratom.h"
-# include "prlock.h"
-# include "prcvar.h"
-# include "prthread.h"
-#endif
-
 JS_BEGIN_EXTERN_C
 
-#ifdef JS_THREADSAFE
-
-#if (defined(_WIN32) && defined(_M_IX86)) ||                                  \
-    (defined(__GNUC__) && defined(__i386__)) ||                               \
-    (defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)) ||           \
-    defined(AIX) ||                                                           \
-    defined(USE_ARM_KUSER) ||                                                 \
-    (defined(__GNUC__) &&                                                     \
-     (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)))
-# define JS_HAS_NATIVE_COMPARE_AND_SWAP 1
-#else
-# define JS_HAS_NATIVE_COMPARE_AND_SWAP 0
-#endif
-
-#if defined(JS_USE_ONLY_NSPR_LOCKS) || !JS_HAS_NATIVE_COMPARE_AND_SWAP
-# define NSPR_LOCK 1
-#else
-# undef NSPR_LOCK
-#endif
-
 #define Thin_GetWait(W) ((jsword)(W) & 0x1)
 #define Thin_SetWait(W) ((jsword)(W) | 0x1)
 #define Thin_RemoveWait(W) ((jsword)(W) & ~0x1)
 
 typedef struct JSFatLock JSFatLock;
 
+struct JSFatLock {
+    int         susp;
+    PRLock      *slock;
+    PRCondVar   *svar;
+    JSFatLock   *next;
+    JSFatLock   **prevp;
+};
+
 typedef struct JSThinLock {
     jsword      owner;
     JSFatLock   *fat;
 } JSThinLock;
 
 #define CX_THINLOCK_ID(cx)       ((jsword)(cx)->thread)
 #define CURRENT_THREAD_IS_ME(me) (((JSThread *)me)->id == js_CurrentThreadId())
 
 typedef PRLock JSLock;
 
+typedef struct JSFatLockTable {
+    JSFatLock   *free;
+    JSFatLock   *taken;
+} JSFatLockTable;
+
 typedef struct JSTitle JSTitle;
 
 struct JSTitle {
     JSContext       *ownercx;           /* creating context, NULL if shared */
     JSThinLock      lock;               /* binary semaphore protecting title */
@@ -99,11 +92,11 @@ struct JSTitle {
     } u;
 #ifdef JS_DEBUG_TITLE_LOCKS
     const char      *file[4];           /* file where lock was (re-)taken */
     unsigned int    line[4];            /* line where lock was (re-)taken */
 #endif
-};
+};    
 
 /*
  * Title structures must be immediately preceded by JSObjectMap structures for
  * maps that use titles for threadsafety.  This is enforced by assertion in
  * jsscope.h; see bug 408416 for future remedies to this somewhat fragile
@@ -124,10 +117,12 @@ struct JSTitle {
 #define js_CurrentThreadId()        (jsword)PR_GetCurrentThread()
 #define JS_NEW_LOCK()               PR_NewLock()
 #define JS_DESTROY_LOCK(l)          PR_DestroyLock(l)
 #define JS_ACQUIRE_LOCK(l)          PR_Lock(l)
 #define JS_RELEASE_LOCK(l)          PR_Unlock(l)
+#define JS_LOCK0(P,M)               js_Lock(P,M)
+#define JS_UNLOCK0(P,M)             js_Unlock(P,M)
 
 #define JS_NEW_CONDVAR(l)           PR_NewCondVar(l)
 #define JS_DESTROY_CONDVAR(cv)      PR_DestroyCondVar(cv)
 #define JS_WAIT_CONDVAR(cv,to)      PR_WaitCondVar(cv,to)
 #define JS_NO_TIMEOUT               PR_INTERVAL_NO_TIMEOUT
@@ -142,13 +137,10 @@ struct JSTitle {
 #define SET_SCOPE_INFO(scope_, file_, line_)                                   \
     js_SetScopeInfo(scope_, file_, line_)
 
 #endif
 
-#define JS_LOCK(cx, tl)             js_Lock(cx, tl)
-#define JS_UNLOCK(cx, tl)           js_Unlock(cx, tl)
-
 #define JS_LOCK_RUNTIME(rt)         js_LockRuntime(rt)
 #define JS_UNLOCK_RUNTIME(rt)       js_UnlockRuntime(rt)
 
 /*
  * NB: The JS_LOCK_OBJ and JS_UNLOCK_OBJ macros work *only* on native objects
@@ -176,13 +168,10 @@ struct JSTitle {
 #define JS_UNLOCK_SCOPE(cx,scope) JS_UNLOCK_TITLE(cx,&(scope)->title)
 
 #define JS_TRANSFER_SCOPE_LOCK(cx, scope, newscope)                            \
     js_TransferTitle(cx, &scope->title, &newscope->title)
 
-
-extern void js_Lock(JSContext *cx, JSThinLock *tl);
-extern void js_Unlock(JSContext *cx, JSThinLock *tl);
 extern void js_LockRuntime(JSRuntime *rt);
 extern void js_UnlockRuntime(JSRuntime *rt);
 extern void js_LockObj(JSContext *cx, JSObject *obj);
 extern void js_UnlockObj(JSContext *cx, JSObject *obj);
 extern void js_InitTitle(JSContext *cx, JSTitle *title);
@@ -231,23 +220,47 @@ extern void js_SetScopeInfo(JSScope *sco
     JS_BEGIN_MACRO                                                            \
         JSRuntime *_rt = (cx)->runtime;                                       \
         JS_LOCK_RUNTIME_VOID(_rt, e);                                         \
     JS_END_MACRO
 
+#if defined(JS_USE_ONLY_NSPR_LOCKS) ||                                        \
+    !( (defined(_WIN32) && defined(_M_IX86)) ||                               \
+       (defined(__GNUC__) && defined(__i386__)) ||                            \
+       (defined(SOLARIS) && defined(sparc) && defined(ULTRA_SPARC)) ||        \
+       defined(AIX) || defined(USE_ARM_KUSER))
+
+#define NSPR_LOCK 1
+
+#undef JS_LOCK0
+#undef JS_UNLOCK0
+#define JS_LOCK0(P,M)   (JS_ACQUIRE_LOCK(((JSLock*)(P)->fat)), (P)->owner = (M))
+#define JS_UNLOCK0(P,M) ((P)->owner = 0, JS_RELEASE_LOCK(((JSLock*)(P)->fat)))
+
+#else  /* arch-tests */
+
+#undef NSPR_LOCK
+
+extern void js_Lock(JSThinLock *tl, jsword me);
+extern void js_Unlock(JSThinLock *tl, jsword me);
+
+#endif /* arch-tests */
+
 #else  /* !JS_THREADSAFE */
 
+JS_BEGIN_EXTERN_C
+
 #define JS_ATOMIC_INCREMENT(p)      (++*(p))
 #define JS_ATOMIC_DECREMENT(p)      (--*(p))
 #define JS_ATOMIC_ADD(p,v)          (*(p) += (v))
 
 #define JS_CurrentThreadId() 0
 #define JS_NEW_LOCK()               NULL
 #define JS_DESTROY_LOCK(l)          ((void)0)
 #define JS_ACQUIRE_LOCK(l)          ((void)0)
 #define JS_RELEASE_LOCK(l)          ((void)0)
-#define JS_LOCK(cx, tl)             ((void)0)
-#define JS_UNLOCK(cx, tl)           ((void)0)
+#define JS_LOCK0(P,M)               ((void)0)
+#define JS_UNLOCK0(P,M)             ((void)0)
 
 #define JS_NEW_CONDVAR(l)           NULL
 #define JS_DESTROY_CONDVAR(cv)      ((void)0)
 #define JS_WAIT_CONDVAR(cv,to)      ((void)0)
 #define JS_NOTIFY_CONDVAR(cv)       ((void)0)
@@ -283,10 +296,13 @@ extern void js_SetScopeInfo(JSScope *sco
 #define JS_NOTIFY_GC_DONE(rt)       JS_NOTIFY_ALL_CONDVAR((rt)->gcDone)
 #define JS_AWAIT_REQUEST_DONE(rt)   JS_WAIT_CONDVAR((rt)->requestDone,        \
                                                     JS_NO_TIMEOUT)
 #define JS_NOTIFY_REQUEST_DONE(rt)  JS_NOTIFY_CONDVAR((rt)->requestDone)
 
+#define JS_LOCK(P,CX)               JS_LOCK0(P, CX_THINLOCK_ID(CX))
+#define JS_UNLOCK(P,CX)             JS_UNLOCK0(P, CX_THINLOCK_ID(CX))
+ 
 #ifndef SET_OBJ_INFO
 #define SET_OBJ_INFO(obj,f,l)       ((void)0)
 #endif
 #ifndef SET_TITLE_INFO
 #define SET_TITLE_INFO(title,f,l)   ((void)0)
