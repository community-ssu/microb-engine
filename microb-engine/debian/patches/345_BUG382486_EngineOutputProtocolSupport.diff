# Implemnentation of OutputHandler Interface, 
# for supporting third party protocols in write mode
# see 350_GnomeVfsWriteSupport.diff
# 
Index: mozilla/netwerk/base/public/Makefile.in
===================================================================
--- mozilla.orig/netwerk/base/public/Makefile.in
+++ mozilla/netwerk/base/public/Makefile.in
@@ -44,16 +44,17 @@
 
 MODULE		= necko
 GRE_MODULE	= 1
 
 SDK_XPIDLSRCS   = \
 		nsIChannel.idl \
 		nsILoadGroup.idl \
 		nsIProtocolHandler.idl \
+		nsIOutputProtocolHandler.idl \
 		nsIRequest.idl \
 		nsIRequestObserver.idl \
 		nsIStreamListener.idl \
 		nsIIOService.idl \
 		nsIURI.idl \
 		nsIURL.idl \
 		nsIFileURL.idl \
 		nsIUploadChannel.idl \
Index: mozilla/netwerk/base/public/nsIOutputProtocolHandler.idl
===================================================================
--- /dev/null
+++ mozilla/netwerk/base/public/nsIOutputProtocolHandler.idl
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *       Oleg Romashin <romaxa@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIOutputStream;
+interface nsIURI;
+
+/**
+ * nsIOutputProtocolHandler
+ *
+ */
+[scriptable, uuid(f6669109-a0b2-43fa-a8a5-e9e98eaba1b0)]
+interface nsIOutputProtocolHandler : nsISupports
+{
+    /**
+     * Constructs a new OutputStream from the given URI for this protocol handler.
+     */
+    nsIOutputStream newOutputStreamFromURI(in nsIURI aURI);
+};
+
Index: mozilla/netwerk/base/public/nsNetUtil.h
===================================================================
--- mozilla.orig/netwerk/base/public/nsNetUtil.h
+++ mozilla/netwerk/base/public/nsNetUtil.h
@@ -65,16 +65,17 @@
 #include "nsITransport.h"
 #include "nsIStreamTransportService.h"
 #include "nsIHttpChannel.h"
 #include "nsIDownloader.h"
 #include "nsIStreamLoader.h"
 #include "nsIUnicharStreamLoader.h"
 #include "nsIPipe.h"
 #include "nsIProtocolHandler.h"
+#include "nsIOutputProtocolHandler.h"
 #include "nsIFileProtocolHandler.h"
 #include "nsIStringStream.h"
 #include "nsILocalFile.h"
 #include "nsIFileStreams.h"
 #include "nsIProtocolProxyService.h"
 #include "nsIProxyInfo.h"
 #include "nsIFileStreams.h"
 #include "nsIBufferedStreams.h"
@@ -334,16 +335,44 @@
         return -1;
 
     NS_ASSERTION(handler, "IO Service lied");
     rv = handler->GetDefaultPort(&port);
     return NS_SUCCEEDED(rv) ? port : -1;
 }
 
 inline nsresult
+NS_NewOutputStream(nsIOutputStream   **aResult,
+                   nsIURI            *aURI,
+                   nsIIOService      *ioService = nsnull)     // pass in nsIIOService to optimize callers
+{
+    nsresult rv;
+
+    nsCAutoString scheme;
+    rv = aURI->GetScheme(scheme);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIIOService> grip;
+    rv = net_EnsureIOService(&ioService, grip);
+    NS_ENSURE_TRUE(ioService, rv);
+
+    nsCOMPtr<nsIProtocolHandler> handler;
+    rv = ioService->GetProtocolHandler(scheme.get(), getter_AddRefs(handler));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIOutputProtocolHandler> output_handler = do_QueryInterface(handler, &rv);
+    if (!output_handler) {
+        NS_WARNING("Output Handler interface not defined");
+        return NS_ERROR_FAILURE;
+    }
+    rv = output_handler->NewOutputStreamFromURI(aURI, aResult);
+    return rv;
+}
+
+inline nsresult
 NS_NewInputStreamChannel(nsIChannel      **result,
                          nsIURI           *uri,
                          nsIInputStream   *stream,
                          const nsACString &contentType,
                          const nsACString *contentCharset)
 {
     nsresult rv;
     nsCOMPtr<nsIInputStreamChannel> isc =
Index: mozilla/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
===================================================================
--- mozilla.orig/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
+++ mozilla/embedding/components/webbrowserpersist/src/nsWebBrowserPersist.cpp
@@ -60,16 +60,17 @@
 #include "nsEscape.h"
 #include "nsUnicharUtils.h"
 #include "nsIStringEnumerator.h"
 #include "nsCRT.h"
 #include "nsSupportsArray.h"
 #include "nsInt64.h"
 #include "nsContentCID.h"
 #include "nsStreamUtils.h"
+#include "nsNetUtil.h"
 
 #include "nsCExternalHandlerService.h"
 
 #include "nsIURL.h"
 #include "nsIFileURL.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMXMLDocument.h"
@@ -865,17 +866,23 @@
                 // all written.  We loop because for some errors (e.g., disk
                 // full), we get NS_OK with some bytes written, then an error.
                 // So, we want to write again in that case to get the actual
                 // error code.
                 const char *bufPtr = buffer; // Where to write from.
                 while (NS_SUCCEEDED(rv) && bytesRead)
                 {
                     PRUint32 bytesWritten = 0;
-                    rv = data->mStream->Write(bufPtr, bytesRead, &bytesWritten);
+                    // FIXME  Hack to fix a crash
+                    PRUint32 bytesPut;
+                    if(bytesRead > 10)
+                        bytesPut = 10;
+                    else bytesPut = bytesRead;
+
+                    rv = data->mStream->Write(bufPtr, bytesPut, &bytesWritten);
                     if (NS_SUCCEEDED(rv))
                     {
                         bytesRead -= bytesWritten;
                         bufPtr += bytesWritten;
                         bytesRemaining -= bytesWritten;
                         // Force an error if (for some reason) we get NS_OK but
                         // no bytes written.
                         if (!bytesWritten)
@@ -2307,18 +2314,23 @@
 }
 
 nsresult
 nsWebBrowserPersist::MakeOutputStreamFromURI(
     nsIURI *aURI, nsIOutputStream  **aOutputStream)
 {
     PRUint32 segsize = 8192;
     PRUint32 maxsize = PRUint32(-1);
+    nsresult rv;
+    rv = NS_NewOutputStream(aOutputStream, aURI);
+    if (NS_SUCCEEDED(rv))
+        return rv;
+
     nsCOMPtr<nsIStorageStream> storStream;
-    nsresult rv = NS_NewStorageStream(segsize, maxsize, getter_AddRefs(storStream));
+    rv = NS_NewStorageStream(segsize, maxsize, getter_AddRefs(storStream));
     NS_ENSURE_SUCCESS(rv, rv);
     
     NS_ENSURE_SUCCESS(CallQueryInterface(storStream, aOutputStream), NS_ERROR_FAILURE);
     return NS_OK;
 }
 
 void
 nsWebBrowserPersist::EndDownload(nsresult aResult)
@@ -3390,33 +3402,38 @@
         nsCOMPtr<nsIURL> url(do_QueryInterface(fileAsURI));
         if (!url)
           return NS_ERROR_FAILURE;
           
         nsCAutoString filename;
         url->GetFileName(filename);
 
         nsCAutoString rawPathURL(data->mRelativePathToData);
+        PRInt32 len = rawPathURL.Length();
+        if (len > 0 && rawPathURL.CharAt(len - 1) != '/')
+        {
+            rawPathURL.Append('/');
+        }
+
         rawPathURL.Append(filename);
 
         nsCAutoString buf;
         AppendUTF8toUTF16(NS_EscapeURL(rawPathURL, esc_FilePath, buf),
                           newValue);
     }
     else
     {
         nsCAutoString fileurl;
         fileAsURI->GetSpec(fileurl);
         AppendUTF8toUTF16(fileurl, newValue);
     }
     if (data->mIsSubFrame)
     {
         newValue.Append(data->mSubFrameExt);
     }
-
     aURI = newValue;
     return NS_OK;
 }
 
 nsresult
 nsWebBrowserPersist::FixupNodeAttributeNS(nsIDOMNode *aNode,
                                         const char *aNamespaceURI,
                                         const char *aAttribute)
@@ -3649,16 +3666,20 @@
     {
         nsCOMPtr<nsIStorageStream> storStream(do_QueryInterface(outputStream));
         if (storStream)
         {
             outputStream->Close();
             rv = StartUpload(storStream, aFile, aFormatType);
             NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
         }
+        else
+        {
+            outputStream->Close();
+        }
     }
 #if defined(XP_OS2)
     else
     {
         // close the stream, then tag the file it created with its source URI
         outputStream->Close();
         nsCOMPtr<nsILocalFileOS2> localFileOS2 = do_QueryInterface(localFile);
         if (localFileOS2)
