# It adds support to restart a download if disk gets full (out of space) while downloading.
# NOTE: It does not recover download across browser sessions. Once browser is closed, 
# downloads are gone.
--- mozilla/uriloader/exthandler/nsExternalHelperAppService.h.orig	2007-04-03 18:31:08.000000000 -0400
+++ mozilla/uriloader/exthandler/nsExternalHelperAppService.h	2007-04-03 18:33:57.000000000 -0400
@@ -419,16 +419,25 @@ protected:
    * we need to remember the final destination until we are ready to use it.
    */
   nsCOMPtr<nsIFile> mFinalFileDestination;
 
   nsCOMPtr<nsIURI> mFinalUriDestination;
 
   char mDataBuffer[DATA_BUFFER_SIZE];
 
+  /** 
+   * XXX: Download recover stuff
+   */
+  PRBool mWriteError;
+  PRUint32 mReadButNotWrittenBytes;
+  PRUint32 mNotWrittenCount;
+  PRUint32 mOutputOffsetTemp;
+  const char *bufPtr;
+
   /**
    * Creates the temporary file for the download and an output stream for it.
    * Upon successful return, both mTempFile and mOutStream will be valid.
    */
   nsresult SetUpTempFile(nsIChannel * aChannel);
   /**
    * When we download a helper app, we are going to retarget all load
    * notifications into our own docloader and load group instead of
--- mozilla/uriloader/exthandler/nsExternalHelperAppService.cpp.old	2007-04-13 12:07:10.000000000 -0400
+++ mozilla/uriloader/exthandler/nsExternalHelperAppService.cpp	2007-04-13 12:07:24.000000000 -0400
@@ -113,16 +113,18 @@
 
 #include "nsIGlobalHistory.h" // to mark downloads as visited
 #include "nsIGlobalHistory2.h" // to mark downloads as visited
 
 #include "nsIDOMWindow.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIDocShell.h"
 
+#include "nsISeekableStream.h"
+
 #include "nsCRT.h"
 
 #ifdef PR_LOGGING
 PRLogModuleInfo* nsExternalHelperAppService::mLog = nsnull;
 #endif
 
 // Using level 3 here because the OSHelperAppServices use a log level
 // of PR_LOG_DEBUG (4), and we want less detailed output here
@@ -1412,16 +1414,18 @@ nsExternalAppHandler::nsExternalAppHandl
 , mShouldCloseWindow(PR_FALSE)
 , mReceivedDispositionInfo(PR_FALSE)
 , mStopRequestIssued(PR_FALSE)
 , mProgressListenerInitialized(PR_FALSE)
 , mReason(aReason)
 , mContentLength(-1)
 , mProgress(0)
 , mRequest(nsnull)
+, mWriteError(PR_FALSE)
+, mOutputOffsetTemp(0)
 {
 
   // make sure the extention includes the '.'
   if (!aTempFileExtension.IsEmpty() && aTempFileExtension.First() != '.')
     mTempFileExtension = PRUnichar('.');
   AppendUTF8toUTF16(aTempFileExtension, mTempFileExtension);
 
   // replace platform specific path separator and illegal characters to avoid any confusion
@@ -2003,59 +2007,134 @@ void nsExternalAppHandler::SendStatusCha
         }
     }
 }
 
 NS_IMETHODIMP nsExternalAppHandler::OnDataAvailable(nsIRequest *request, nsISupports * aCtxt,
                                                   nsIInputStream * inStr, PRUint32 sourceOffset, PRUint32 count)
 {
   nsresult rv = NS_OK;
+  PRBool readError = PR_FALSE;
   // first, check to see if we've been canceled....
   if (mCanceled) // then go cancel our underlying channel too
     return request->Cancel(NS_BINDING_ABORTED);
 
   // read the data out of the stream and write it to the temp file.
   if (mOutStream && count > 0)
   {
-    PRUint32 numBytesRead = 0; 
+    PRUint32 numBytesRead = 0;
     PRUint32 numBytesWritten = 0;
+
+    // XXX check if we had not written data in previous interaction,
+    // if so, write them before next interaction.
+    if (mWriteError) {
+
+      // seek to mOutputOffsetTemp
+      nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mOutStream);
+      if (seekable)
+        seekable->Seek(nsISeekableStream::NS_SEEK_SET, mOutputOffsetTemp);
+
+      rv = NS_ERROR_FAILURE;
+      do {
+        if(NS_SUCCEEDED (rv)) {
+          rv = inStr->Read(mDataBuffer, PR_MIN(mNotWrittenCount, DATA_BUFFER_SIZE - 1), &numBytesRead);
+          bufPtr = mDataBuffer;
+        } else {
+             rv = NS_OK;
+             numBytesRead = mReadButNotWrittenBytes;
+        }
+
+        while (NS_SUCCEEDED(rv) && numBytesRead) {
+
+          rv = mOutStream->Write(bufPtr, numBytesRead, &numBytesWritten);
+          if (!numBytesWritten || NS_FAILED (rv))
+            mWriteError = PR_TRUE;
+          else {
+            numBytesRead -= numBytesWritten;
+            mNotWrittenCount -= numBytesWritten;
+            mOutputOffsetTemp += numBytesWritten;
+            mProgress += numBytesWritten;
+            bufPtr += numBytesWritten;
+          }
+        }
+      } while(NS_SUCCEEDED(rv) && mNotWrittenCount > 0);
+    }
+
+    if (mWriteError) {
+      if (!mNotWrittenCount) {
+        mWriteError = PR_FALSE;
+        rv = NS_OK;
+      }
+    }
+
     mProgress += count;
-    PRBool readError = PR_TRUE;
+    readError = PR_FALSE;
     while (NS_SUCCEEDED(rv) && count > 0) // while we still have bytes to copy...
     {
+      PRUint32 numBytesRead = 0; 
+
       readError = PR_TRUE;
       rv = inStr->Read(mDataBuffer, PR_MIN(count, DATA_BUFFER_SIZE - 1), &numBytesRead);
+
+      // XXX: now setting proper value to nNotWrittenCount
+      mNotWrittenCount = count;
+
       if (NS_SUCCEEDED(rv))
       {
         if (count >= numBytesRead)
           count -= numBytesRead; // subtract off the number of bytes we just read
         else
           count = 0;
+
         readError = PR_FALSE;
         // Write out the data until something goes wrong, or, it is
         // all written.  We loop because for some errors (e.g., disk
         // full), we get NS_OK with some bytes written, then an error.
         // So, we want to write again in that case to get the actual
         // error code.
-        const char *bufPtr = mDataBuffer; // Where to write from.
+        bufPtr = mDataBuffer; // Where to write from.
         while (NS_SUCCEEDED(rv) && numBytesRead)
         {
           numBytesWritten = 0;
+          // XXX: there is no such error yet
+          mWriteError = PR_FALSE; 
           rv = mOutStream->Write(bufPtr, numBytesRead, &numBytesWritten);
           if (NS_SUCCEEDED(rv))
           {
             numBytesRead -= numBytesWritten;
             bufPtr += numBytesWritten;
+            // XXX
+            mOutputOffsetTemp += numBytesWritten;
+            mNotWrittenCount = count;
+
             // Force an error if (for some reason) we get NS_OK but
             // no bytes written.
             if (!numBytesWritten)
             {
               rv = NS_ERROR_FAILURE;
             }
           }
+          else
+          {
+             // XXX: how many bytes got written still ?
+            mWriteError = PR_TRUE;
+
+            nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mOutStream);
+            if (seekable) { 
+              PRInt64 offsetAfter;
+              seekable->Tell(&offsetAfter);
+
+              PRUint32 diff = (offsetAfter - mOutputOffsetTemp);
+
+              mReadButNotWrittenBytes = numBytesRead - diff;
+              bufPtr += diff;
+              mOutputOffsetTemp += diff;
+              mNotWrittenCount -= diff;
+            }
+          }
         }
       }
     }
     if (NS_SUCCEEDED(rv))
     {
       // Send progress notification.
       if (mWebProgressListener)
       {
@@ -2065,35 +2144,40 @@ NS_IMETHODIMP nsExternalAppHandler::OnDa
     else
     {
       // An error occurred, notify listener.
       nsAutoString tempFilePath;
       if (mTempFile)
         mTempFile->GetPath(tempFilePath);
       SendStatusChange(readError ? kReadError : kWriteError, rv, request, tempFilePath);
 
-      // Cancel the download.
-      Cancel(rv);
+      // Cancel the download if error is different from write error.
+      // Cancel(rv);
+
     }
   }
+
+  if ((mWriteError || readError) && NS_FAILED (rv))
+    return NS_OK;
+
   return rv;
 }
 
 NS_IMETHODIMP nsExternalAppHandler::OnStopRequest(nsIRequest *request, nsISupports *aCtxt, 
                                                   nsresult aStatus)
 {
   mStopRequestIssued = PR_TRUE;
   mRequest = nsnull;
   // Cancel if the request did not complete successfully.
   if (!mCanceled && NS_FAILED(aStatus))
   {
     // Send error notification.
     nsAutoString tempFilePath;
     if (mTempFile)
-      mTempFile->GetPath(tempFilePath);
+      mTempFile->GetPath(tempFilePath); 
     SendStatusChange( kReadError, aStatus, request, tempFilePath );
 
     Cancel(aStatus);
   }
 
   // first, check to see if we've been canceled....
   if (mCanceled)
     return NS_OK;
