diff -r c531aa117519 toolkit/components/places/src/nsNavHistory.cpp
--- a/toolkit/components/places/src/nsNavHistory.cpp	Wed Aug 05 19:02:22 2009 +0300
+++ b/toolkit/components/places/src/nsNavHistory.cpp	Wed Aug 05 19:16:20 2009 +0300
@@ -197,16 +198,17 @@
 // the maximum number of times we'll postpone a lazy timer before committing
 // See StartLazyTimer()
 #define MAX_LAZY_TIMER_DEFERMENTS 2
 
 #endif // LAZY_ADD
 
 // Perform expiration after 5 minutes of idle time, repeating.
 #define EXPIRE_IDLE_TIME_IN_MSECS (5 * 60 * PR_MSEC_PER_SEC)
+#define EXPIRE_IDLE_INACTIVE_TIME_IN_MSECS (3600 * 60 * PR_MSEC_PER_SEC)
 
 // Amount of items to expire at idle time.
 #define MAX_EXPIRE_RECORDS_ON_IDLE 200
 
 // Limit the number of items in the history for performance reasons
 #define EXPIRATION_CAP_SITES 40000
 
 // character-set annotation
@@ -380,16 +382,18 @@ const PRInt32 nsNavHistory::kAutoComplet
 const PRInt32 nsNavHistory::kAutoCompleteBehaviorTitle = 1 << 3;
 const PRInt32 nsNavHistory::kAutoCompleteBehaviorUrl = 1 << 4;
 const PRInt32 nsNavHistory::kAutoCompleteBehaviorTyped = 1 << 5;
 
 static const char* gQuitApplicationGrantedMessage = "quit-application-granted";
 static const char* gXpcomShutdown = "xpcom-shutdown";
 static const char* gAutoCompleteFeedback = "autocomplete-will-enter-text";
 static const char* gIdleDaily = "idle-daily";
+static const char* gSystemIdle = "system-idle";
+static const char* gSystemActive = "system-active";
 
 // annotation names
 const char nsNavHistory::kAnnotationPreviousEncoding[] = "history/encoding";
 
 // code borrowed from mozilla/xpfe/components/history/src/nsGlobalHistory.cpp
 // pass in a pre-normalized now and a date, and we'll find
 // the difference since midnight on each of the days.
 //
@@ -536,16 +540,17 @@ nsNavHistory::Init()
     PRBool hasSession;
     if (NS_SUCCEEDED(selectSession->ExecuteStep(&hasSession)) && hasSession)
       mLastSessionID = selectSession->AsInt64(0);
     else
       mLastSessionID = 1;
   }
 
   // initialize idle timer
+  mExpireIdleTimeInMSecs = EXPIRE_IDLE_TIME_IN_MSECS;
   InitializeIdleTimer();
 
   // recent events hash tables
   NS_ENSURE_TRUE(mRecentTyped.Init(128), NS_ERROR_OUT_OF_MEMORY);
   NS_ENSURE_TRUE(mRecentBookmark.Init(128), NS_ERROR_OUT_OF_MEMORY);
   NS_ENSURE_TRUE(mRecentRedirects.Init(128), NS_ERROR_OUT_OF_MEMORY);
 
   /*****************************************************************************
@@ -580,16 +585,18 @@ nsNavHistory::Init()
     pbi->AddObserver(PREF_BROWSER_HISTORY_EXPIRE_SITES, this, PR_FALSE);
   }
 
   observerService->AddObserver(this, gQuitApplicationGrantedMessage, PR_FALSE);
   observerService->AddObserver(this, gXpcomShutdown, PR_FALSE);
   observerService->AddObserver(this, gAutoCompleteFeedback, PR_FALSE);
   observerService->AddObserver(this, gIdleDaily, PR_FALSE);
   observerService->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, PR_FALSE);
+  observerService->AddObserver(this, gSystemIdle, PR_FALSE);
+  observerService->AddObserver(this, gSystemActive, PR_FALSE);
   // In case we've either imported or done a migration from a pre-frecency
   // build, we will calculate the first cutoff period's frecencies once the rest
   // of the places infrastructure has been initialized.
   if (mDatabaseStatus == DATABASE_STATUS_CREATE ||
       mDatabaseStatus == DATABASE_STATUS_UPGRADED) {
     (void)observerService->AddObserver(this, PLACES_INIT_COMPLETE_EVENT_TOPIC,
                                        PR_FALSE);
   }
@@ -991,19 +998,18 @@ nsNavHistory::InitializeIdleTimer()
   if (mIdleTimer) {
     mIdleTimer->Cancel();
     mIdleTimer = nsnull;
   }
   nsresult rv;
   mIdleTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  PRInt32 idleTimerTimeout = EXPIRE_IDLE_TIME_IN_MSECS;
   rv = mIdleTimer->InitWithFuncCallback(IdleTimerCallback, this,
-                                        idleTimerTimeout,
+                                        mExpireIdleTimeInMSecs,
                                         nsITimer::TYPE_REPEATING_SLACK);
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsNavHistory::GetDatabaseStatus(PRUint16 *aDatabaseStatus)
 {
@@ -5489,17 +5495,17 @@ nsNavHistory::OnIdle()
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRUint32 idleTime;
   rv = idleService->GetIdleTime(&idleTime);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If we've been idle for more than EXPIRE_IDLE_TIME_IN_MSECS
   // keep the expiration engine chugging along.
-  if (idleTime > EXPIRE_IDLE_TIME_IN_MSECS) {
+  if (idleTime > mExpireIdleTimeInMSecs) {
     mozStorageTransaction transaction(mDBConn, PR_TRUE);
 
     PRBool keepGoing; // We don't care about this value.
     (void)mExpire.ExpireItems(MAX_EXPIRE_RECORDS_ON_IDLE / 2, &keepGoing);
 
     (void)mExpire.ExpireOrphans(MAX_EXPIRE_RECORDS_ON_IDLE / 2);
   }
 
@@ -5654,22 +5660,32 @@ nsNavHistory::Observe(nsISupports *aSubj
     NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
     (void)bookmarks->OnQuit();
   }
   else if (strcmp(aTopic, gXpcomShutdown) == 0) {
     nsresult rv;
     nsCOMPtr<nsIObserverService> observerService =
       do_GetService("@mozilla.org/observer-service;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
+    observerService->RemoveObserver(this, gSystemIdle);
+    observerService->RemoveObserver(this, gSystemActive);
     observerService->RemoveObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC);
     observerService->RemoveObserver(this, gIdleDaily);
     observerService->RemoveObserver(this, gAutoCompleteFeedback);
     observerService->RemoveObserver(this, gXpcomShutdown);
     observerService->RemoveObserver(this, gQuitApplicationGrantedMessage);
   }
+  else if (strcmp(aTopic, gSystemIdle) == 0) {
+    mExpireIdleTimeInMSecs = EXPIRE_IDLE_INACTIVE_TIME_IN_MSECS;
+    InitializeIdleTimer();
+  }
+  else if (strcmp(aTopic, gSystemActive) == 0) {
+    mExpireIdleTimeInMSecs = EXPIRE_IDLE_TIME_IN_MSECS;
+    InitializeIdleTimer();
+  }
 #ifdef MOZ_XUL
   else if (strcmp(aTopic, gAutoCompleteFeedback) == 0) {
     nsCOMPtr<nsIAutoCompleteInput> input = do_QueryInterface(aSubject);
     if (!input)
       return NS_OK;
 
     nsCOMPtr<nsIAutoCompletePopup> popup;
     input->GetPopup(getter_AddRefs(popup));
diff -r c531aa117519 toolkit/components/places/src/nsNavHistory.h
--- a/toolkit/components/places/src/nsNavHistory.h	Wed Aug 05 19:02:22 2009 +0300
+++ b/toolkit/components/places/src/nsNavHistory.h	Wed Aug 05 19:16:20 2009 +0300
@@ -812,16 +812,17 @@ protected:
   static void IdleTimerCallback(nsITimer* aTimer, void* aClosure);
   nsresult OnIdle();
 
   PRInt64 mTagsFolder;
 
   PRBool mInPrivateBrowsing;
 
   PRUint16 mDatabaseStatus;
+  PRInt32 mExpireIdleTimeInMSecs;
 };
 
 /**
  * Shared between the places components, this function binds the given URI as
  * UTF8 to the given parameter for the statement.
  */
 nsresult BindStatementURI(mozIStorageStatement* statement, PRInt32 index,
                           nsIURI* aURI);
