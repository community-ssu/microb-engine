Index: src/EmbedContentListener.cpp
===================================================================
--- mozilla/embedding/browser/gtk/src.orig/EmbedContentListener.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedContentListener.cpp
@@ -33,13 +33,10 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-#include <strings.h>
-#include "nsXPIDLString.h"
-
 #include "nsIURI.h"
 
 #include "EmbedContentListener.h"
 #include "EmbedPrivate.h"
 
Index: src/EmbedProgress.cpp
===================================================================
--- mozilla/embedding/browser/gtk/src.orig/EmbedProgress.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.cpp
@@ -35,17 +35,16 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "EmbedProgress.h"
 
-#include "nsXPIDLString.h"
 #include "nsIChannel.h"
 #include "nsIWebProgress.h"
 #include "nsIDOMWindow.h"
 
 #include "nsIURI.h"
-#include "nsCRT.h"
+#include "nsCRTGlue.h"
 
 EmbedProgress::EmbedProgress(void)
 {
   mOwner = nsnull;
 }
@@ -80,26 +79,25 @@ EmbedProgress::OnStateChange(nsIWebProgr
     g_signal_emit(G_OBJECT(mOwner->mOwningWidget),
 		    moz_embed_signals[NET_START], 0);
   }
 
   // get the uri for this request
-  nsXPIDLCString uriString;
-  RequestToURIString(aRequest, getter_Copies(uriString));
-  nsString tmpString;
-  CopyUTF8toUTF16(uriString, tmpString);
+  nsCAutoString uriString;
+  RequestToURIString(aRequest, uriString);
 
   // is it the same as the current URI?
-  if (mOwner->mURI.Equals(tmpString))
+  if (mOwner->mURI.Equals(uriString))
   {
     // for people who know what they are doing
     g_signal_emit(G_OBJECT(mOwner->mOwningWidget),
 		    moz_embed_signals[NET_STATE], 0,
 		    aStateFlags, aStatus);
   }
   g_signal_emit(G_OBJECT(mOwner->mOwningWidget),
 		  moz_embed_signals[NET_STATE_ALL], 0,
-		  (const char *)uriString,
+ 		  uriString.get(),
+		  (const char *)uriString.get(),
 		  (gint)aStateFlags, (gint)aStatus);
   // and for stop, too
   if ((aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) && 
       (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP))
   {
@@ -119,26 +117,23 @@ EmbedProgress::OnProgressChange(nsIWebPr
 				PRInt32         aMaxSelfProgress,
 				PRInt32         aCurTotalProgress,
 				PRInt32         aMaxTotalProgress)
 {
 
-  nsXPIDLCString uriString;
-  RequestToURIString(aRequest, getter_Copies(uriString));
+  nsCAutoString uriString;
+  RequestToURIString(aRequest, uriString);
   
-  nsString tmpString;
-  CopyUTF8toUTF16(uriString, tmpString);
-
   // is it the same as the current uri?
-  if (mOwner->mURI.Equals(tmpString)) {
+  if (mOwner->mURI.Equals(uriString)) {
     g_signal_emit(G_OBJECT(mOwner->mOwningWidget),
 		    moz_embed_signals[PROGRESS], 0,
 		    aCurTotalProgress, aMaxTotalProgress);
   }
 
   g_signal_emit(G_OBJECT(mOwner->mOwningWidget),
 		  moz_embed_signals[PROGRESS_ALL], 0,
-		  (const char *)uriString,
+		  uriString.get(),
 		  aCurTotalProgress, aMaxTotalProgress);
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -181,19 +176,19 @@ EmbedProgress::OnStatusChange(nsIWebProg
 			      nsIRequest      *aRequest,
 			      nsresult         aStatus,
 			      const PRUnichar *aMessage)
 {
   // need to make a copy so we can safely cast to a void *
-  PRUnichar *tmpString = nsCRT::strdup(aMessage);
+  PRUnichar *tmpString = NS_strdup(aMessage);
 
   g_signal_emit(G_OBJECT(mOwner->mOwningWidget),
 		  moz_embed_signals[STATUS_CHANGE], 0,
 		  static_cast<void *>(aRequest),
 		  static_cast<int>(aStatus),
 		  static_cast<void *>(tmpString));
 
-  nsMemory::Free(tmpString);
+  NS_Free(tmpString);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -208,11 +203,11 @@ EmbedProgress::OnSecurityChange(nsIWebPr
   return NS_OK;
 }
 
 /* static */
 void
-EmbedProgress::RequestToURIString(nsIRequest *aRequest, char **aString)
+EmbedProgress::RequestToURIString(nsIRequest *aRequest, nsACString &aString)
 {
   // is it a channel
   nsCOMPtr<nsIChannel> channel;
   channel = do_QueryInterface(aRequest);
   if (!channel)
@@ -221,10 +216,7 @@ EmbedProgress::RequestToURIString(nsIReq
   nsCOMPtr<nsIURI> uri;
   channel->GetURI(getter_AddRefs(uri));
   if (!uri)
     return;
   
-  nsCAutoString uriString;
-  uri->GetSpec(uriString);
-
-  *aString = strdup(uriString.get());
+  uri->GetSpec(aString);
 }
Index: src/EmbedProgress.h
===================================================================
--- mozilla/embedding/browser/gtk/src.orig/EmbedProgress.h
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.h
@@ -55,11 +55,11 @@ class EmbedProgress : public nsIWebProgr
 
   NS_DECL_NSIWEBPROGRESSLISTENER
 
  private:
 
-  static void RequestToURIString (nsIRequest *aRequest, char **aString);
+  static void RequestToURIString (nsIRequest *aRequest, nsACString &aString);
 
   EmbedPrivate *mOwner;
 
 };
 
Index: src/EmbedWindow.cpp
===================================================================
--- mozilla/embedding/browser/gtk/src.orig/EmbedWindow.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedWindow.cpp
@@ -40,11 +40,10 @@
 
 #include "nsCWebBrowser.h"
 #include "nsIComponentManager.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIWidget.h"
-#include "nsReadableUtils.h"
 
 #include "EmbedWindow.h"
 #include "EmbedPrivate.h"
 #include "EmbedPrompter.h"
 
Index: src/gtkmozembed2.cpp
===================================================================
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed2.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp
@@ -47,12 +47,10 @@
 
 // so we can do our get_nsIWebBrowser later...
 #include "nsIWebBrowser.h"
 
 // for strings
-#include "nsXPIDLString.h"
-#include "nsReadableUtils.h"
 
 #include "gtkmozembedmarshal.h"
 
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
@@ -894,11 +892,11 @@ gtk_moz_embed_get_location(GtkMozEmbed *
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), (char *)NULL);
 
   embedPrivate = (EmbedPrivate *)embed->data;
   
   if (!embedPrivate->mURI.IsEmpty())
-    retval = NEW_TOOLKIT_STRING(embedPrivate->mURI);
+    retval = g_strdup(embedPrivate->mURI.get());
 
   return retval;
 }
 
 void
Index: src/EmbedPrivate.cpp
===================================================================
--- mozilla/embedding/browser/gtk/src.orig/EmbedPrivate.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.cpp
@@ -420,11 +420,11 @@ EmbedPrivate::Destroy(void)
 }
 
 void
 EmbedPrivate::SetURI(const char *aURI)
 {
-  CopyUTF8toUTF16(aURI, mURI);
+  mURI.Assign(aURI);
 }
 
 void
 EmbedPrivate::LoadCurrentURI(void)
 {
@@ -432,11 +432,11 @@ EmbedPrivate::LoadCurrentURI(void)
     nsCOMPtr<nsPIDOMWindow> piWin;
     GetPIDOMWindow(getter_AddRefs(piWin));
 
     nsAutoPopupStatePusher popupStatePusher(piWin, openAllowed);
 
-    mNavigation->LoadURI(mURI.get(),                        // URI string
+    mNavigation->LoadURI(NS_ConvertUTF8toUTF16(mURI).get(), // URI string
                          nsIWebNavigation::LOAD_FLAGS_NONE, // Load flags
                          nsnull,                            // Referring URI
                          nsnull,                            // Post data
                          nsnull);                           // extra headers
   }
Index: src/EmbedPrivate.h
===================================================================
--- mozilla/embedding/browser/gtk/src.orig/EmbedPrivate.h
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.h
@@ -137,11 +137,11 @@ class EmbedPrivate {
 
   // our event receiver
   nsCOMPtr<nsPIDOMEventTarget>   mEventTarget;
 
   // the currently loaded uri
-  nsString                       mURI;
+  nsCString                      mURI;
 
   // the number of widgets that have been created
   static PRUint32                sWidgetCount;
   // the path to the GRE
   static char                   *sPath;
