diff -ruN -p -U10 mozilla/embedding/browser/gtk/src.orig/Makefile.in mozilla/embedding/browser/gtk/src/Makefile.in
--- mozilla/embedding/browser/gtk/src.orig/Makefile.in	2007-09-14 00:42:43.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/Makefile.in	2007-09-14 09:11:39.000000000 +0300
@@ -60,31 +60,31 @@ ifdef MOZ_GTKEMBED_DYN
 DEFINES += -DFIXED_BUG347731
 FORCE_SHARED_LIB = 1
 ifdef MOZ_ENABLE_LIBXUL
 LIBXUL_LIBRARY  = 
 endif
 endif
 
 DEFINES += -DIMPL_XREAPI
 
 # New Stuff in GtkMozEmbed
-ifdef MOZ_MICROBEMBED
+#ifdef MOZ_MICROBEMBED
 DEFINES += -DBAD_CERT_LISTENER2
 #Probably scrolling can be fixed without this hack
-DEFINES += -DMOZ_SCROLL_TOP_LEFT_HACK
+#DEFINES += -DMOZ_SCROLL_TOP_LEFT_HACK
 
-MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT = 1
-DEFINES += -DMOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
+#MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT = 1
+#DEFINES += -DMOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 
 MOZ_GTKPASSWORD_INTERFACE = 1
 DEFINES += -DMOZ_GTKPASSWORD_INTERFACE
-endif
+#endif
 
 REQUIRES	= xpcom \
 		  string \
 		  content \
 		  docshell \
 		  necko \
 		  widget \
 		  dom \
 		  gfx \
 		  intl \
@@ -106,20 +106,26 @@ REQUIRES	= xpcom \
 		  nspr \
 		  xulapp \
 		  exthandler \
 		  mimetype \
 		  chardet \
 		  find \
 		  webbrowserpersist \
 		  cookie \
 		  nkcache \
 		  pipboot \
+		  plugin \
+		  extensions \
+		  rdf \
+		  toolkitcomps \
+		  view \
+		  commandhandler \
 		  $(NULL)
 
 ifdef ACCESSIBILITY
 REQUIRES        += accessibility
 endif
 
 CPPSRCS		= \
 		gtkmozembed2.cpp \
 		EmbedPrivate.cpp \
 		EmbedWindow.cpp \
@@ -180,20 +185,21 @@ EXPORTS		+= \
 		gtkmozembed_download.h \
 		$(NULL)
 endif
 
 ifdef MOZ_GTKEMBED_DYN
 ifneq (,$(filter gtk2 qt,$(MOZ_WIDGET_TOOLKIT)))
 EXTRA_DSO_LDOPTS += \
 		$(DIST)/lib/libxpcomglue_s.$(LIB_SUFFIX) \
 		$(MOZ_COMPONENT_LIBS) \
 		$(MOZ_GTK2_LIBS) \
+		$(XLIBS) \
 		$(NULL)
 
 #Any Idea what can be used instead -lxul in FF configuration?
 ifndef MOZ_ENABLE_LIBXUL
 EXTRA_DSO_LDOPTS += \
 		-lxul \
 		$(NULL)
 endif
 endif
 endif
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedCertificates.cpp mozilla/embedding/browser/gtk/src/EmbedCertificates.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedCertificates.cpp	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedCertificates.cpp	2007-10-03 12:03:14.000000000 +0300
@@ -289,21 +289,21 @@ EmbedCertificates::ConfirmBadCertificate
   PRBool *_retval)
 {
   nsresult rv;
   gpointer pCert = NULL;
   guint messint = 0;
   nsCOMPtr<nsIDOMWindow> parent(do_GetInterface(ctx));
 
   GtkMozEmbedCommon * common = nsnull;
   GtkMozEmbed *parentWidget = GTK_MOZ_EMBED(GetGtkWidgetForDOMWindow(parent));
 
-  if (!parentWidget) {
+  if (parentWidget) {
     EmbedCommon * embedcommon = EmbedCommon::GetInstance();
     if (embedcommon)
       common = GTK_MOZ_EMBED_COMMON(embedcommon->mCommon);
   }
 
   if (!(aError & nsIX509Cert::VERIFIED_OK)) {
     pCert = (gpointer)cert;
     messint = GTK_MOZ_EMBED_CERT_VERIFIED_OK;
     if (aError & nsIX509Cert::NOT_VERIFIED_UNKNOWN) {
       messint |= GTK_MOZ_EMBED_CERT_NOT_VERIFIED_UNKNOWN;
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedContextMenuInfo.cpp mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedContextMenuInfo.cpp	2007-05-02 01:24:25.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -30,20 +30,21 @@
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
+
 #include "EmbedContextMenuInfo.h"
 #include "nsIImageLoadingContent.h"
 #include "imgILoader.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMHTMLElement.h"
 #include "nsIDOMHTMLHtmlElement.h"
 #include "nsIDOMHTMLAnchorElement.h"
 #include "nsIDOMHTMLImageElement.h"
 #include "nsIDOMHTMLAreaElement.h"
@@ -66,52 +67,62 @@
 #include "nsIPresShell.h"
 #include "nsIFormControl.h"
 #include "nsIDOMNSHTMLInputElement.h"
 #include "nsIDOMNSHTMLTextAreaElement.h"
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMNSHTMLDocument.h"
 #include "nsIDOMNodeList.h"
 #include "nsISelection.h"
 #include "nsIDocument.h"
+#include "nsIWidget.h"
+#include "nsIScrollableView.h"
+#include "nsIScrollableViewProvider.h"
+#include "nsIView.h"
+#include "nsIScrollableFrame.h"
+#include "nsIDOMWindowInternal.h"
 #include "EmbedPrivate.h"
+#include "nsGUIEvent.h"
 #include <stdio.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <glib.h>
 #if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
 #include "nsIFrame.h"
 #endif
+#include "gfxIImageFrame.h"
 
 //*****************************************************************************
 // class EmbedContextMenuInfo
 //*****************************************************************************
 EmbedContextMenuInfo::EmbedContextMenuInfo(EmbedPrivate *aOwner) : mCtxFrameNum(-1), mEmbedCtxType(0)
 {
   mOwner = aOwner;
   mEventNode = nsnull;
   mCtxDocument = nsnull;
   mNSHHTMLElement = nsnull;
-  mNSHHTMLElementSc = nsnull;
   mCtxEvent = nsnull;
   mEventNode = nsnull;
   mFormRect = nsRect(0,0,0,0);
+  mIsScrollableElement = PR_TRUE;
+  mCtxScrollable = nsnull;
+  mIsJSHandledElement = 0;
 }
 
 EmbedContextMenuInfo::~EmbedContextMenuInfo(void)
 {
   mEventNode = nsnull;
   mCtxDocument = nsnull;
   mNSHHTMLElement = nsnull;
-  mNSHHTMLElementSc = nsnull;
   mCtxEvent = nsnull;
   mEventNode = nsnull;
+  mCtxScrollable = nsnull;
 }
 
 NS_IMPL_ADDREF(EmbedContextMenuInfo)
 NS_IMPL_RELEASE(EmbedContextMenuInfo)
 NS_INTERFACE_MAP_BEGIN(EmbedContextMenuInfo)
 NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
 nsresult
 EmbedContextMenuInfo::SetFrameIndex()
@@ -131,20 +142,41 @@ EmbedContextMenuInfo::SetFrameIndex()
       nsCOMPtr<nsIDocument> doc = do_QueryInterface(currentDoc);
       if (doc)
         mCtxDocTitle = doc->GetDocumentTitle();
       return NS_OK;
     }
   }
   return NS_ERROR_FAILURE;
 }
 
 nsresult
+EmbedContextMenuInfo::GetJSHandledInfo(nsIDOMEvent *aEvent, PRInt32 *aIsJSHandled)
+{
+  if (!aEvent && !aIsJSHandled)
+    return NS_ERROR_FAILURE;
+  nsresult rv = NS_ERROR_FAILURE;
+  if (aEvent) {
+    PRUint32 flags;
+    rv = aEvent->GetPrivateFlags(&flags);
+    if (NS_SUCCEEDED(rv) && (flags & NS_PRIV_EVENT_FLAG_SCRIPT)) {
+      mIsJSHandledElement = aIsJSHandled?*aIsJSHandled:1;
+    } else {
+      mIsJSHandledElement = 0;
+      rv = NS_ERROR_FAILURE;
+    }
+  }
+  if (aIsJSHandled)
+    *aIsJSHandled = mIsJSHandledElement;
+  return rv;
+}
+
+nsresult
 EmbedContextMenuInfo::GetFormControlType(nsIDOMEvent* aEvent)
 {
   if (!aEvent)
     return NS_OK;
   nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
   nsCOMPtr<nsIDOMEventTarget> target;
   nsevent->GetOriginalTarget(getter_AddRefs(target));
   //    mOrigTarget  = target;
   if (SetFormControlType(target)) {
     nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(target);
@@ -178,98 +210,106 @@ EmbedContextMenuInfo::GetFormControlType
     return NS_OK;
   }
   return NS_ERROR_FAILURE;
 }
 
 nsresult
 EmbedContextMenuInfo::SetFormControlType(nsIDOMEventTarget *originalTarget)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsCOMPtr<nsIContent> targetContent = do_QueryInterface(originalTarget);
+  if(!targetContent)
+    return rv;
+  
   mCtxFormType = 0;
 #ifdef MOZILLA_1_8_BRANCH
-  if (targetContent && targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
+  if (targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
 #else
-  if (targetContent && targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
+  if (targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
 #endif
     nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(targetContent));
     if (formControl) {
       mCtxFormType = formControl->GetType();
       rv = NS_OK;
       //#ifdef MOZ_LOGGING
       switch (mCtxFormType) {
       case NS_FORM_BUTTON_BUTTON:
         break;
       case NS_FORM_BUTTON_RESET:
         break;
       case NS_FORM_BUTTON_SUBMIT:
         break;
       case NS_FORM_INPUT_BUTTON:
+        //  mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
         break;
       case NS_FORM_INPUT_CHECKBOX:
         break;
+      case NS_FORM_INPUT_RADIO:
+        break;
       case NS_FORM_INPUT_FILE:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
         break;
       case NS_FORM_INPUT_HIDDEN:
         break;
       case NS_FORM_INPUT_RESET:
         break;
       case NS_FORM_INPUT_IMAGE:
         break;
       case NS_FORM_INPUT_PASSWORD:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
         mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IPASSWORD;
         break;
-      case NS_FORM_INPUT_RADIO:
-        break;
       case NS_FORM_INPUT_SUBMIT:
         break;
       case NS_FORM_INPUT_TEXT:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
         break;
       case NS_FORM_LABEL:
         break;
       case NS_FORM_OPTION:
         break;
       case NS_FORM_OPTGROUP:
         break;
       case NS_FORM_LEGEND:
         break;
       case NS_FORM_SELECT:
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_SELECT;
+        mIsScrollableElement = PR_FALSE;
         break;
       case NS_FORM_TEXTAREA:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_MULTILINE;
         break;
       case NS_FORM_OBJECT:
         break;
       default:
         break;
       }
-      if (mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      if (mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
         PRBool rdonly = PR_FALSE;
         if (mCtxFormType == NS_FORM_TEXTAREA) {
           nsCOMPtr<nsIDOMHTMLTextAreaElement> input;
           input = do_QueryInterface(mEventNode, &rv);
           if (!NS_FAILED(rv) && input)
             rv = input->GetReadOnly(&rdonly);
-          if (!NS_FAILED(rv) && rdonly) {
+          if (!NS_FAILED(rv) && rdonly)
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_ROINPUT;
-          }
+          else
+            mIsScrollableElement = PR_FALSE;
         } else {
           nsCOMPtr<nsIDOMHTMLInputElement> input;
           input = do_QueryInterface(mEventNode, &rv);
           if (!NS_FAILED(rv) && input)
             rv = input->GetReadOnly(&rdonly);
-          if (!NS_FAILED(rv) && rdonly) {
+          if (!NS_FAILED(rv) && rdonly)
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_ROINPUT;
-          }
+          else
+            mIsScrollableElement = PR_FALSE;
         }
       }
       //#endif
     }
   }
   return rv;
 }
 
 const char*
 EmbedContextMenuInfo::GetSelectedText()
@@ -320,34 +360,42 @@ EmbedContextMenuInfo::GetSelectedText()
     rv = NS_OK;
   }
   if (rv == NS_OK) {
     return NS_ConvertUTF16toUTF8(cString).get();
   }
   return nsnull;
 }
 
 nsresult
 EmbedContextMenuInfo::CheckDomImageElement(nsIDOMNode *node, nsString& aHref,
-                                           PRInt32 *aWidth, PRInt32 *aHeight)
+                                           PRInt32 *aWidth, PRInt32 *aHeight, PRUint32 *aSize)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsCOMPtr<nsIDOMHTMLImageElement> image =
     do_QueryInterface(node, &rv);
-  if (image) {
-    rv = image->GetSrc(aHref);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    rv = image->GetWidth(aWidth);
-    rv = image->GetHeight(aHeight);
-    rv = NS_OK;
-  }
+  NS_ENSURE_TRUE(image, rv);
+  rv = image->GetSrc(aHref);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = NS_OK;
+  image->GetWidth(aWidth);
+  image->GetHeight(aHeight);
+  if (!aSize) return rv;
+  nsCOMPtr<imgIRequest> request;
+  GetImageRequest(getter_AddRefs(request), node);
+  NS_ENSURE_TRUE(request, rv);
+  nsCOMPtr<imgIContainer> imgCont;
+  request->GetImage(getter_AddRefs(imgCont));
+  NS_ENSURE_TRUE(imgCont, rv);
+  nsCOMPtr<gfxIImageFrame> currentFrame;
+  imgCont->GetCurrentFrame(getter_AddRefs(currentFrame));
+  NS_ENSURE_TRUE(currentFrame, rv);
+  currentFrame->GetImageDataLength(aSize);
   return rv;
 }
 
 nsresult
 EmbedContextMenuInfo::GetImageRequest(imgIRequest **aRequest, nsIDOMNode *aDOMNode)
 {
   NS_ENSURE_ARG(aDOMNode);
   NS_ENSURE_ARG_POINTER(aRequest);
 
   // Get content
@@ -358,47 +406,38 @@ EmbedContextMenuInfo::GetImageRequest(im
                              aRequest);
 }
 
 nsresult
 EmbedContextMenuInfo::CheckDomHtmlNode(nsIDOMNode *aNode)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsString uTag;
   PRUint16 dnode_type;
 
-  nsCOMPtr<nsIDOMNode> node;
-  if (!aNode && mEventNode)
-    node = mEventNode;
-  nsCOMPtr<nsIDOMHTMLElement> element  = do_QueryInterface(node, &rv);
-  if (!element) {
-    element = do_QueryInterface(mOrigNode, &rv);
-    if (element) {
-      node = mOrigNode;
-      element  = do_QueryInterface(node, &rv);
-    }
-  }
+  nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode, &rv);
+  NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
 
   rv = node->GetNodeType(&dnode_type);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  if (!((nsIDOMNode::ELEMENT_NODE == dnode_type) && element)) {
+  if (!((nsIDOMNode::ELEMENT_NODE == dnode_type))) {
     return rv;
   }
   nsCOMPtr<nsIDOMNSHTMLElement> nodeElement = do_QueryInterface(node, &rv);
   if (NS_SUCCEEDED(rv) && nodeElement) {
     mNSHHTMLElement = nodeElement;
   } else {
     mNSHHTMLElement = nsnull;
   }
-  rv = element->GetLocalName(uTag);
+  rv = node->GetLocalName(uTag);
   if (NS_FAILED(rv)) {
     return rv;
   }
   if (uTag.LowerCaseEqualsLiteral("object")) {
   }
   else if (uTag.LowerCaseEqualsLiteral("html")) {
   }
   else if (uTag.LowerCaseEqualsLiteral("a")) {
     nsCOMPtr<nsIDOMHTMLAnchorElement> anchor = do_QueryInterface(node);
     anchor->GetHref(mCtxHref);
@@ -408,20 +447,27 @@ EmbedContextMenuInfo::CheckDomHtmlNode(n
         nsCOMPtr<nsIDOMNode> childNode;
         node->GetFirstChild(getter_AddRefs(childNode));
         if (childNode) {
           PRInt32 width, height;
           rv = CheckDomImageElement(node, mCtxImgHref, &width, &height);
           if (NS_SUCCEEDED(rv))
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IMAGE;
         }
       } else if (StringBeginsWith(mCtxHref, NS_LITERAL_STRING("mailto:"))) {
         mEmbedCtxType |= GTK_MOZ_EMBED_CTX_EMAIL;
+      } else {
+        nsCOMPtr<nsIDOMNode> childNode;
+        node->GetFirstChild(getter_AddRefs(childNode));
+        if (childNode) {
+          childNode->GetLocalName(uTag);
+          mIsScrollableElement = !uTag.LowerCaseEqualsLiteral("div");
+        }
       }
     }
   }
   else if (uTag.LowerCaseEqualsLiteral("area")) {
     nsCOMPtr<nsIDOMHTMLAreaElement> area = do_QueryInterface(node, &rv);
     if (NS_SUCCEEDED(rv) && area) {
       PRBool aNoHref = PR_FALSE;
       rv = area->GetNoHref(&aNoHref);
       if (aNoHref == PR_FALSE)
         rv = area->GetHref(mCtxHref);
@@ -435,66 +481,196 @@ EmbedContextMenuInfo::CheckDomHtmlNode(n
     PRInt32 width, height;
     rv = CheckDomImageElement(node, mCtxImgHref, &width, &height);
     if (NS_SUCCEEDED(rv))
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IMAGE;
   } else {
     rv = NS_ERROR_FAILURE;
   }
   return rv;
 }
 
-nsresult
-EmbedContextMenuInfo::UpdateContextData(void *aEvent)
+static nsIFrame*
+GetParentFrameToScroll(nsPresContext* aPresContext, nsIFrame* aFrame)
 {
-  NS_ENSURE_ARG_POINTER(aEvent);
+  if (!aPresContext || !aFrame)
+    return nsnull;
+
+  if (aFrame->GetStyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED)
+    return aPresContext->GetPresShell()->GetRootScrollFrame();
+
+  return aFrame->GetParent();
+}
+
+static PRBool
+ViewIsScrollable(nsIScrollableView* aScrollView)
+{
+  // Can it crash?
+  nsIFrame *frame = static_cast<nsIFrame*>(aScrollView->View()->GetParent()->GetClientData());
+  NS_ENSURE_TRUE(frame, PR_FALSE);
+  nsIScrollableFrame *sf = nsnull;
+  CallQueryInterface(frame, &sf);
+  NS_ENSURE_TRUE(sf, PR_FALSE);
+  nsPresContext::ScrollbarStyles ss = sf->GetScrollbarStyles();
+  if (NS_STYLE_OVERFLOW_HIDDEN != ss.mHorizontal
+      || NS_STYLE_OVERFLOW_HIDDEN != ss.mVertical)
+    return PR_TRUE;
+  return PR_FALSE;
+}
+
+static nsresult
+FindScrollableView(nsPresContext* aPresContext,
+                   nsIFrame* aTargetFrame,
+                   nsIScrollableViewProvider* *aSvp)
+{
+  nsIScrollableView* scrollView = nsnull;
+  nsIFrame* scrollFrame = aTargetFrame;
+  PRBool passToParent = PR_TRUE;
+  for (; scrollFrame && passToParent;
+       scrollFrame = GetParentFrameToScroll(aPresContext, scrollFrame)) {
+    scrollView = nsnull;
+    nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(scrollFrame);
+    if (svp)
+      scrollView = svp->GetScrollableView();
+
+    if (!scrollView)
+      continue;
+    else
+      if (aSvp)
+        NS_ADDREF(*aSvp = svp);
+
+    if (!ViewIsScrollable(scrollView))
+      continue;
+
+    // Check if the scrollable view can be scrolled any further.
+    nscoord lineHeight;
+    scrollView->GetLineHeight(&lineHeight);
+    if (lineHeight != 0) {
+      PRBool canScroll;
+      if ((NS_SUCCEEDED(scrollView->CanScroll(PR_FALSE, PR_TRUE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_TRUE, PR_TRUE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_TRUE, PR_FALSE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_FALSE, PR_FALSE, canScroll)) && canScroll)
+         ) {
+        passToParent = PR_FALSE;
+        return NS_OK;
+      }
+    }
+  }
+  return NS_ERROR_FAILURE;
+}
+
+static PRBool
+IsScrollableWindow(nsIDOMWindow *win)
+{
+  if (!win) return PR_FALSE;
+  nsCOMPtr<nsIDOMWindowInternal> winint = do_QueryInterface(win);
+  if (!winint) return PR_FALSE;
+  PRInt32 maxScrollX = 0, maxScrollY = 0;
+  winint->GetScrollMaxX(&maxScrollX);
+  winint->GetScrollMaxY(&maxScrollY);
+  return maxScrollX || maxScrollY;
+}
+
+inline PRBool
+EmbedContextMenuInfo::GetScrollableViewByNode(void)
+{
+  if (!mEventNode) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
+    NS_ENSURE_TRUE(mCtxDomWindow, PR_FALSE);
+    nsCOMPtr<nsIDOMDocument> document;
+    mCtxDomWindow->GetDocument(getter_AddRefs(document));
+    NS_ENSURE_TRUE(document, PR_FALSE);
+    nsCOMPtr<nsIDOMElement> el;
+    document->GetDocumentElement(getter_AddRefs(el));
+    mEventNode = do_QueryInterface(el);
+    NS_ENSURE_TRUE(mEventNode, PR_FALSE);
+  }
   nsresult rv;
-  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface((nsISupports*)aEvent, &rv);
-  if (NS_FAILED(rv) || !event)
-    return NS_ERROR_FAILURE;
-  return UpdateContextData(event);
+  nsIFrame* frame = nsnull;
+  mCtxScrollable = nsnull;
+  nsCOMPtr<nsIContent> iContent = do_QueryInterface(mEventNode, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  nsCOMPtr<nsIPresShell> presShell;
+  nsCOMPtr<nsIDOMDocument> doc;
+  mEventNode->GetOwnerDocument(getter_AddRefs(doc));
+  nsCOMPtr<nsIDocument> iDoc = do_QueryInterface(doc);
+  NS_ENSURE_TRUE(iDoc, PR_FALSE);
+  presShell = iDoc->GetPrimaryShell();
+  NS_ENSURE_TRUE(presShell, PR_FALSE);
+  frame = presShell->GetPrimaryFrameFor(iContent);
+  NS_ENSURE_TRUE(frame, PR_FALSE);
+  nsPresContext *context = presShell->GetPresContext();
+  NS_ENSURE_TRUE(context, PR_FALSE);
+  nsCOMPtr<nsIScrollableViewProvider> svp;
+  if (NS_SUCCEEDED(FindScrollableView(context, frame, getter_AddRefs(svp)))
+      && svp && (mCtxScrollable = svp))
+    return PR_TRUE;
+  return PR_FALSE;
+}
+
+PRBool
+EmbedContextMenuInfo::GetScrollableView(void)
+{
+  if (GetScrollableViewByNode())
+    return PR_TRUE;
+  if (!mCtxDomWindow) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
+  }
+  NS_ENSURE_TRUE(mCtxDomWindow, PR_FALSE);
+  nsCOMPtr<nsIDOMWindow> cur = mCtxDomWindow;
+  nsCOMPtr<nsIDOMWindow> parent = nsnull;
+  if (IsScrollableWindow(cur)) {
+    mCtxScrollable = cur;
+    return PR_TRUE;
+  }
+  while (cur && cur != parent) {
+    cur->GetParent(getter_AddRefs(parent));
+    cur = parent;
+    if (IsScrollableWindow(cur)) {
+      mCtxScrollable = cur;
+      return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
 }
 
 nsresult
-EmbedContextMenuInfo::GetElementForScroll(nsIDOMEvent *aEvent)
+EmbedContextMenuInfo::ScrollScrollableView(PRInt32 subX, PRInt32 subY)
 {
-  if (!aEvent) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
-  nsCOMPtr<nsIDOMEventTarget> target;
-  nsevent->GetOriginalTarget(getter_AddRefs(target));
-  if (!target) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMNode> targetDOMNode(do_QueryInterface(target));
-  if (!targetDOMNode) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMDocument> targetDOMDocument;
-  targetDOMNode->GetOwnerDocument(getter_AddRefs(targetDOMDocument));
-  if (!targetDOMDocument) return NS_ERROR_UNEXPECTED;
-  return GetElementForScroll(targetDOMDocument);
+  nsresult rv;
+  nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(mCtxScrollable, &rv);
+  if (svp && !NS_FAILED(rv)) {
+    nsIScrollableView* scrollView = svp->GetScrollableView();
+    NS_ENSURE_TRUE(scrollView, NS_ERROR_FAILURE);
+    return scrollView->ScrollByPixels(subX, subY);
+  }
+
+  nsCOMPtr<nsIDOMWindow> win = do_QueryInterface(mCtxScrollable, &rv);
+  if (!win || NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  return win->ScrollBy(subX, subY);
 }
 
 nsresult
-EmbedContextMenuInfo::GetElementForScroll(nsIDOMDocument *targetDOMDocument)
+EmbedContextMenuInfo::UpdateContextData(void *aEvent)
 {
-  nsCOMPtr<nsIDOMElement> targetDOMElement;
-  targetDOMDocument->GetDocumentElement(getter_AddRefs(targetDOMElement));
-  if (!targetDOMElement) return NS_ERROR_UNEXPECTED;
-  nsString bodyName(NS_LITERAL_STRING("body"));
-  nsCOMPtr<nsIDOMNodeList> bodyList;
-  targetDOMElement->GetElementsByTagName(bodyName, getter_AddRefs(bodyList));
-  PRUint32 i = 0;
-  bodyList->GetLength(&i);
-  if (i) {
-    nsCOMPtr<nsIDOMNode> domBodyNode;
-    bodyList->Item(0, getter_AddRefs(domBodyNode));
-    if (!domBodyNode) return NS_ERROR_UNEXPECTED;
-    mNSHHTMLElementSc = do_QueryInterface(domBodyNode);
-    if (!mNSHHTMLElementSc) return NS_ERROR_UNEXPECTED;
-  }
-  return NS_OK;
+  NS_ENSURE_ARG_POINTER(aEvent);
+  nsresult rv;
+  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface((nsISupports*)aEvent, &rv);
+  if (NS_FAILED(rv) || !event)
+    return NS_ERROR_FAILURE;
+  return UpdateContextData(event);
 }
 
 nsresult
 EmbedContextMenuInfo::UpdateContextData(nsIDOMEvent *aDOMEvent)
 {
   if (mCtxEvent == aDOMEvent)
     return NS_OK;
 
   nsresult rv = nsnull;
   mCtxEvent = aDOMEvent;
@@ -531,72 +707,84 @@ EmbedContextMenuInfo::UpdateContextData(
     return NS_OK;
 
   mEmbedCtxType = GTK_MOZ_EMBED_CTX_NONE;
   mOrigNode = originalNode;
   if (mOrigNode) {
     nsString SOrigNode;
     mOrigNode->GetNodeName(SOrigNode);
     if (SOrigNode.EqualsLiteral("#document"))
       return NS_OK;
     if (SOrigNode.EqualsLiteral("xul:thumb")
-        || SOrigNode.EqualsLiteral("xul:slider")
-        || SOrigNode.EqualsLiteral("xul:scrollbarbutton")
         || SOrigNode.EqualsLiteral("xul:vbox")
         || SOrigNode.EqualsLiteral("xul:spacer")) {
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = PR_FALSE;
+      return NS_OK;
+    } else
+    if (SOrigNode.EqualsLiteral("xul:slider")) {
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = 2;
+      return NS_OK;
+    } else
+    if (SOrigNode.EqualsLiteral("xul:scrollbarbutton")) {
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = 3;
       return NS_OK;
     }
   }
+  mIsScrollableElement = PR_TRUE;
   if (mCtxEvent)
     rv = mCtxEvent->GetTarget(getter_AddRefs(mEventTarget));
   if (NS_FAILED(rv) || !mEventTarget) {
     return NS_OK;
   }
   nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(mEventTarget, &rv);
   mEventNode = eventNode;
   //Frame Stuff
   nsCOMPtr<nsIDOMDocument> domDoc;
   if (mEventNode)
     rv = mEventNode->GetOwnerDocument(getter_AddRefs(domDoc));
   if (!NS_SUCCEEDED(rv) || !domDoc) {
     //  return NS_OK;
   }
   if (NS_SUCCEEDED(rv) && domDoc && mCtxDocument != domDoc) {
     mCtxDocument = domDoc;
-    mNSHHTMLElementSc = nsnull;
     nsCOMPtr<nsIDOM3Document> docuri = do_QueryInterface(mCtxDocument);
     docuri->GetDocumentURI(mCtxURI);
     NS_ENSURE_ARG_POINTER(mOwner);
     nsCOMPtr<nsIWebBrowser> webBrowser;
     mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
     webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
     nsCOMPtr<nsIDOMDocument> mainDocument;
     mCtxDomWindow->GetDocument(getter_AddRefs(mainDocument));
+
     if (!mainDocument) {
       return NS_OK;
     }
     mCtxFrameNum = -1;
     if (mainDocument != domDoc) {
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IFRAME;
       SetFrameIndex();
     }
   }
   nsCOMPtr<nsIDOMElement> targetDOMElement;
   mCtxDocument->GetDocumentElement(getter_AddRefs(targetDOMElement));
   if (!targetDOMElement) return NS_ERROR_UNEXPECTED;
   nsCOMPtr<nsIDOMNSHTMLDocument> htmlDoc = do_QueryInterface(mCtxDocument);
   if (htmlDoc) {
     nsString DMode;
     htmlDoc->GetDesignMode(DMode);
     if (DMode.EqualsLiteral("on")) {
-      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_RICHEDIT;
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_MULTILINE;
+      mIsScrollableElement = PR_FALSE;
     }
   }
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(mCtxDocument);
   if (!doc)
     return NS_OK;
   nsIPresShell *presShell = doc->GetPrimaryShell();
   if (!presShell)
     return NS_OK;
   nsCOMPtr<nsIContent> tgContent = do_QueryInterface(mEventTarget);
   nsIFrame* frame = nsnull;
@@ -611,24 +799,33 @@ EmbedContextMenuInfo::UpdateContextData(
     frame = presShell->GetPrimaryFrameFor(tgContent);
 #endif
   }
   if (frame) {
     mFormRect = frame->GetScreenRectExternal();
   }
 #endif
   if (NS_SUCCEEDED(SetFormControlType(mEventTarget))) {
     return NS_OK;
   }
-  CheckDomHtmlNode();
-  nsCOMPtr<nsIDOMNode> node = mEventNode;
+
+  nsCOMPtr<nsIDOMNode> node;
   nsCOMPtr<nsIDOMNode> parentNode;
+  
+  nsCOMPtr<nsIDOMHTMLElement> element = do_QueryInterface(mEventNode, &rv);
+  if (element)
+    node = do_QueryInterface(mEventNode, &rv);
+  else /* Fallback to XML/XSLT content */
+    node = do_QueryInterface(mOrigNode, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  CheckDomHtmlNode(node);
   node->GetParentNode(getter_AddRefs(parentNode));
   node = parentNode;
   while (node) {
-    if (NS_FAILED(CheckDomHtmlNode()))
+    if (NS_FAILED(CheckDomHtmlNode(node)))
       break;
     node->GetParentNode(getter_AddRefs(parentNode));
     node = parentNode;
   }
   mEmbedCtxType |= GTK_MOZ_EMBED_CTX_DOCUMENT;
   return NS_OK;
 }
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedContextMenuInfo.h mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedContextMenuInfo.h	2007-04-23 17:21:56.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.h	2007-10-03 12:03:15.000000000 +0300
@@ -62,40 +62,44 @@
 class EmbedContextMenuInfo : public nsISupports
 {
 public:
   EmbedContextMenuInfo(EmbedPrivate *aOwner);
   virtual ~EmbedContextMenuInfo(void);
   NS_DECL_ISUPPORTS
   nsresult          GetFormControlType(nsIDOMEvent *aDOMEvent);
   nsresult          UpdateContextData(nsIDOMEvent *aDOMEvent);
   nsresult          UpdateContextData(void *aEvent);
   const char*       GetSelectedText();
-  nsresult          GetElementForScroll(nsIDOMDocument *targetDOMDocument);
-  nsresult          GetElementForScroll(nsIDOMEvent *aEvent);
   nsresult          CheckDomImageElement(nsIDOMNode *node, nsString& aHref,
-                                       PRInt32 *aWidth, PRInt32 *aHeight);
+                                       PRInt32 *aWidth, PRInt32 *aHeight, PRUint32 *aSize = nsnull);
   nsresult          GetImageRequest(imgIRequest **aRequest, nsIDOMNode *aDOMNode);
   nsString          GetCtxDocTitle(void) { return mCtxDocTitle; }
+  PRBool            GetScrollableView(void);
+  PRBool            GetScrollableViewByNode(void);
+  nsresult          ScrollScrollableView(PRInt32 subX, PRInt32 subY);
+  nsresult          GetJSHandledInfo(nsIDOMEvent *aEvent, PRInt32 *aIsJSHandled = nsnull);
 
 
   PRInt32                 mX, mY, mObjWidth, mObjHeight, mCtxFrameNum;
   nsString                mCtxURI, mCtxHref, mCtxImgHref;
   PRUint32                mEmbedCtxType;
   PRInt32 mCtxFormType;
   nsCOMPtr<nsIDOMNode>    mEventNode;
   nsCOMPtr<nsIDOMEventTarget> mEventTarget;
   nsCOMPtr<nsIDOMDocument>mCtxDocument;
   nsRect               mFormRect;
   nsCOMPtr<nsIDOMWindow>  mCtxDomWindow;
   nsCOMPtr<nsIDOMEvent>   mCtxEvent;
   nsCOMPtr<nsIDOMNSHTMLElement> mNSHHTMLElement;
-  nsCOMPtr<nsIDOMNSHTMLElement> mNSHHTMLElementSc;
+  nsISupports            *mCtxScrollable;
+  PRInt32                 mIsScrollableElement;
+  PRInt32                 mIsJSHandledElement;
 private:
   nsresult          SetFrameIndex();
   nsresult          SetFormControlType(nsIDOMEventTarget *originalTarget);
   nsresult          CheckDomHtmlNode(nsIDOMNode *aNode = nsnull);
 
   EmbedPrivate           *mOwner;
   nsCOMPtr<nsIDOMNode>    mOrigNode;
   nsString                mCtxDocTitle;
 }; // class EmbedContextMenuInfo
 #endif // EmbedContextMenuInfo_h__
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedDownloadMgr.cpp mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedDownloadMgr.cpp	2007-10-03 11:58:45.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -15,20 +15,22 @@
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
+ *   Oleg Romashin <romaxa@gmail.com>
+ *   Antonio Gomes <tonikitoo@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
@@ -63,20 +65,22 @@
 #include "nsCExternalHandlerService.h"
 #include "nsMemory.h"
 #include "nsNetError.h"
 #include "nsIStreamListener.h"
 #include "nsIFile.h"
 #include "nsILocalFile.h"
 #include "nsNetCID.h"
 #include <unistd.h>
 #include "gtkmozembed_download.h"
 #include "nsIIOService.h"
+#include "nsIProgressEventSink.h"
+#include "nsNetUtil.h"
 
 #define UNKNOWN_FILE_SIZE -1
 
 class EmbedDownloadMgr;
 class ProgressListener : public nsIWebProgressListener2
 {
 public:
     ProgressListener(EmbedDownload *aDownload):mDownload(aDownload)
     {
     }
@@ -85,84 +89,126 @@ public:
     {
     }
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIWEBPROGRESSLISTENER
     NS_DECL_NSIWEBPROGRESSLISTENER2
 
     EmbedDownload *mDownload;
 };
 
+class FetchObserver : public nsIRequestObserver
+                      ,public nsIProgressEventSink
+{
+public:
+    FetchObserver(EmbedDownload *aDownload):mDownload(aDownload)
+    {
+    }
+
+    ~FetchObserver(void)
+    {
+    }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIREQUESTOBSERVER
+    NS_DECL_NSIPROGRESSEVENTSINK
+    EmbedDownload *mDownload;
+};
+
+NS_IMPL_ISUPPORTS2(FetchObserver, nsIRequestObserver, nsIProgressEventSink)
+
 NS_IMPL_ISUPPORTS2(ProgressListener, nsIWebProgressListener2, nsIWebProgressListener)
 NS_IMPL_ISUPPORTS1(EmbedDownloadMgr, nsIHelperAppLauncherDialog)
 
+EmbedDownload::EmbedDownload(void)
+  : parent(nsnull), gtkMozEmbedParentWidget(nsnull), launcher(nsnull), request(nsnull), isCanceled(PR_FALSE)
+{
+}
+
+EmbedDownload::~EmbedDownload(void)
+{
+  isCanceled = PR_TRUE;
+  request = nsnull;
+}
+
 EmbedDownloadMgr::EmbedDownloadMgr(void)
 {
 }
 
 EmbedDownloadMgr::~EmbedDownloadMgr(void)
 {
+  if (!mDownload || !mDownload->parent)
+    return;
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  temp->is_paused = TRUE;
+  temp->data = NULL;
 }
 
-static gchar *
-RemoveSchemeFromFilePath(gchar *path)
+static char *
+RemoveSchemeFromFilePath(const char *path)
 {
-  gchar *new_path = path;
-
-  if (!strncmp(path, "file://", 7)) {
-    /* XXX this should really look for the first non / after file:/ instead of
-     * assuming file://tmp v. file:///tmp
-     */
-    new_path = g_strdup(path+sizeof("file:/"));
-    g_free(path);
-  }
-    
-  return new_path;
+  return g_strdup(g_str_has_prefix(path, "file://")?&path[7]:path);
 }
 
 NS_IMETHODIMP
 EmbedDownloadMgr::Show(nsIHelperAppLauncher *aLauncher,
                        nsISupports *aContext,
                        PRUint32 aForced)
 {
   nsresult rv;
+  GtkObject* instance;
 
   /* create a Download object */
-  GtkObject* instance = gtk_moz_embed_download_new();
+  instance = gtk_moz_embed_download_get_restart_flag () ?
+                gtk_moz_embed_download_get_latest_object () : gtk_moz_embed_download_new();
+
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
   mDownload = (EmbedDownload *) GTK_MOZ_EMBED_DOWNLOAD(instance)->data;
+  if (!mDownload)
+    return NS_ERROR_FAILURE;
   mDownload->parent = instance;
 
   rv = GetDownloadInfo(aLauncher, aContext);
 
   /* Retrieve GtkMozEmbed object from DOM Window */
   nsCOMPtr<nsIDOMWindow> parentDOMWindow = do_GetInterface(aContext);
   mDownload->gtkMozEmbedParentWidget = GetGtkWidgetForDOMWindow(parentDOMWindow);
 
+  // avoiding some casts.
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+
   gtk_signal_emit(GTK_OBJECT(mDownload->gtkMozEmbedParentWidget),
                   moz_embed_signals[DOWNLOAD_REQUEST],
-                  mDownload->server,
-                  mDownload->file_name,
-                  mDownload->file_type,
-                  (gulong) mDownload->file_size,
+                  temp->server,
+                  temp->file_name,
+                  temp->file_type,
+                  (gulong) temp->file_size,
                    1);
 
   gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                   moz_embed_download_signals[DOWNLOAD_STARTED_SIGNAL],
-                  &mDownload->file_name_with_path);
+                  & temp->file_name_with_path);
 
-  if (!mDownload->file_name_with_path) {
+  if (!temp->file_name_with_path) {
     gtk_moz_embed_download_do_command(GTK_MOZ_EMBED_DOWNLOAD(mDownload->parent),
                                       GTK_MOZ_EMBED_DOWNLOAD_CANCEL);
     return NS_OK;
   }
 
-  mDownload->file_name_with_path = RemoveSchemeFromFilePath(mDownload->file_name_with_path);
+  char * path = RemoveSchemeFromFilePath(temp->file_name_with_path);
+  NS_Free(temp->file_name_with_path);
+  temp->file_name_with_path = path;
 
   return aLauncher->SaveToDisk(nsnull, PR_FALSE);
 }
 
 NS_METHOD
 EmbedDownloadMgr::GetDownloadInfo(nsIHelperAppLauncher *aLauncher,
                                   nsISupports *aContext)
 {
   /* File type */
   nsCOMPtr<nsIMIMEInfo> mimeInfo;
@@ -189,41 +235,66 @@ EmbedDownloadMgr::GetDownloadInfo(nsIHel
   nsCOMPtr<nsIURI> uri;
   rv = aLauncher->GetSource(getter_AddRefs(uri));
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
   nsCAutoString spec;
   rv = uri->Resolve(NS_LITERAL_CSTRING("."), spec);
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
+  PRInt64 mContentLength;
+  rv = aLauncher->GetContentLength(&mContentLength);
+  if (NS_FAILED(rv))
+    return rv;
+
+  /* avoiding some casts */
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+
   /* Sets download object to keep control of each download. */
   mDownload->launcher = aLauncher;
-  mDownload->downloaded_size = -1;
-  mDownload->file_name = g_strdup((gchar *) tempFileName.get());
-  mDownload->server = g_strconcat(spec.get(), (gchar *) mDownload->file_name, NULL);
-  mDownload->file_type = g_strdup(mimeType.get());
-  mDownload->file_size = UNKNOWN_FILE_SIZE;
+  mDownload->incr_launcher = nsnull;
+  temp->downloaded_size = -1;
+  temp->file_name = g_strdup((gchar *) tempFileName.get());
+  temp->server = g_strconcat(spec.get(), (gchar *) temp->file_name, NULL);
+  temp->file_type = g_strdup(mimeType.get());
+  temp->file_size = (mContentLength > 0)? mContentLength : UNKNOWN_FILE_SIZE;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP EmbedDownloadMgr::PromptForSaveToFile(nsIHelperAppLauncher *aLauncher,
                                                     nsISupports *aWindowContext,
                                                     const PRUnichar *aDefaultFile,
                                                     const PRUnichar *aSuggestedFileExtension,
                                                     nsILocalFile **_retval)
 {
   *_retval = nsnull;
 
   nsCAutoString filePath;
-  filePath.Assign(mDownload->file_name_with_path);
+  filePath.Assign(((GtkMozEmbedDownload *) mDownload->parent)->file_name_with_path);
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  if (temp) {
+    if (temp->file_name && !strlen(temp->file_name)) {
+      NS_Free(temp->file_name);
+      if (!NS_ConvertUTF16toUTF8(aDefaultFile).IsEmpty())
+        temp->file_name = NS_strdup(NS_ConvertUTF16toUTF8(aDefaultFile).get());
+      else
+        temp->file_name = g_strdup_printf("_temp_file%s", NS_ConvertUTF16toUTF8(aSuggestedFileExtension).get());
+      if (temp->file_name_with_path) {
+        filePath.Append(temp->file_name);
+        NS_Free(temp->file_name_with_path);
+        temp->file_name_with_path = NS_strdup(filePath.get());
+      }
+    }
+  }
 
   nsCOMPtr<nsILocalFile> destFile;
   NS_NewNativeLocalFile(filePath,
                         PR_TRUE,
                         getter_AddRefs(destFile));
   if (!destFile)
     return NS_ERROR_OUT_OF_MEMORY;
 
   /* Progress listener to follow the download and connecting it to
      the launcher which controls the download. */
@@ -242,21 +313,21 @@ NS_IMETHODIMP EmbedDownloadMgr::PromptFo
 #ifdef OUTPUT_HANDLER_IMPL
 NS_IMETHODIMP EmbedDownloadMgr::PromptForSaveToUri(nsIHelperAppLauncher *aLauncher,
                                                    nsISupports *aWindowContext,
                                                    const PRUnichar *aDefaultFile,
                                                    const PRUnichar *aSuggestedFileExtension,
                                                    nsIURI **_retval)
 {
   nsresult rv;
 
   nsCAutoString file_path;
-  file_path.Assign (mDownload->file_name_with_path);
+  file_path.Assign (((GtkMozEmbedDownload *) mDownload->parent)->file_name_with_path);
   nsCOMPtr<nsIIOService> ios (do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios)
     return FALSE;
 
   nsCOMPtr<nsIURI> uri;
   rv = ios->NewURI(file_path, "", nsnull, getter_AddRefs(uri));
   if (!uri)
     return FALSE;
 
   NS_ADDREF (*_retval = uri);
@@ -272,22 +343,37 @@ NS_IMETHODIMP EmbedDownloadMgr::PromptFo
 }
 #endif
 
 /* nsIWebProgressListener Functions
    all these methods must be here due to nsIWebProgressListener/2 inheritance */
 NS_IMETHODIMP ProgressListener::OnStatusChange(nsIWebProgress *aWebProgress,
                                                nsIRequest *aRequest,
                                                nsresult aStatus,
                                                const PRUnichar *aMessage)
 {
+  switch (aStatus) 
+  {
+    case NS_ERROR_OUT_OF_MEMORY:     // No memory
+    case NS_ERROR_FILE_DISK_FULL:    // Out of space on target volume.
+    case NS_ERROR_FILE_NO_DEVICE_SPACE:
+    case NS_ERROR_FILE_READ_ONLY:     // Attempt to write to read/only file.
+    case NS_ERROR_FILE_ACCESS_DENIED: // Attempt to write without sufficient permissions.
+    case NS_ERROR_FILE_NOT_FOUND:     // Helper app not found, let's verify this happened on launch
+    case NS_ERROR_FILE_TARGET_DOES_NOT_EXIST:
+    case NS_ERROR_FILE_UNRECOGNIZED_PATH:
+    default:
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent), moz_embed_download_signals[DOWNLOAD_DESTROYED_SIGNAL]);
+      break;
+  }
+
   if (NS_SUCCEEDED(aStatus))
-    return NS_OK;
+      return NS_OK;
 
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP ProgressListener::OnStateChange(nsIWebProgress *aWebProgress,
                                               nsIRequest *aRequest, PRUint32 aStateFlags,
                                               nsresult aStatus)
 {
   if (NS_FAILED(aStatus))
     return NS_ERROR_FAILURE;
@@ -336,24 +422,175 @@ NS_IMETHODIMP ProgressListener::OnProgre
     gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                     moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
                     (gulong) aCurSelfProgress, (gulong) aMaxSelfProgress, 1);
   }
   else {
     gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                     moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
                     (gulong) aCurSelfProgress, 0, 1);
   }
 
+
   /* storing current downloaded size. */
-  mDownload->downloaded_size = (gulong) aCurSelfProgress;
+  ((GtkMozEmbedDownload *) mDownload->parent)->downloaded_size = (gulong) aCurSelfProgress;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP ProgressListener::OnRefreshAttempted(nsIWebProgress *aWebProgress,
                                                    nsIURI *aUri, PRInt32 aDelay,
                                                    PRBool aSameUri,
                                                    PRBool *allowRefresh)
 {
   *allowRefresh = PR_TRUE;
   return NS_OK;
 }
+
+NS_IMETHODIMP
+EmbedDownloadMgr::CreateIncrementalDownload(const char *aUrl,
+                                            const char *aDestination,
+                                            PRBool aHidden)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+
+  GtkObject* instance;
+  /* create a Download object */
+  instance = gtk_moz_embed_download_get_restart_flag () ?
+                gtk_moz_embed_download_get_latest_object () : gtk_moz_embed_download_new();
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
+  EmbedDownload *Download = (EmbedDownload *) GTK_MOZ_EMBED_DOWNLOAD(instance)->data;
+  if (!Download)
+    return NS_ERROR_FAILURE;
+  Download->parent = instance;
+  /* Sets download object to keep control of each download. */
+  Download->launcher = nsnull;
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) Download->parent;
+  temp->downloaded_size = -1;
+  temp->file_size = UNKNOWN_FILE_SIZE;
+  temp->server = NS_strdup(aUrl);
+  temp->file_name_with_path = NS_strdup(aDestination);
+  temp->file_name = RemoveSchemeFromFilePath(aDestination);
+
+  return EmbedDownloadMgr::CreateIncrementalDownload(Download);
+}
+
+NS_IMETHODIMP
+EmbedDownloadMgr::CreateIncrementalDownload(EmbedDownload *Download)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+
+  GtkObject* instance = Download->parent;
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
+  /* Sets download object to keep control of each download. */
+  Download->launcher = nsnull;
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) Download->parent;
+
+  nsCOMPtr<nsILocalFile> resultFile;
+  char *new_path = RemoveSchemeFromFilePath(temp->file_name_with_path);
+  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(new_path),
+                                      PR_FALSE, getter_AddRefs(resultFile));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewURI(getter_AddRefs(uri), temp->server);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr <nsIRequestObserver> observer = new FetchObserver(Download);
+  NS_ENSURE_TRUE(observer, rv);
+
+  nsCOMPtr<nsIIncrementalDownload> download =
+      do_CreateInstance(NS_INCREMENTALDOWNLOAD_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  Download->incr_launcher = download;
+
+  rv = download->Init(uri, resultFile, -1, 0);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = download->Start(observer, nsnull);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+FetchObserver::OnStartRequest(nsIRequest *request, nsISupports *context)
+{
+  //printf("FetchObserver::OnStartRequest\n");
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                  moz_embed_download_signals[DOWNLOAD_STARTED_SIGNAL], temp->file_name);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnProgress(nsIRequest *request, nsISupports *context,
+                          PRUint64 progress, PRUint64 progressMax)
+{
+  //printf("FetchObserver::OnProgress [%lu/%lu]\n",PRUint32(progress), PRUint32(progressMax));
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  if (mDownload->isCanceled)
+    return NS_OK;
+  if (progressMax != UNKNOWN_FILE_SIZE)
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                    moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
+                    (gulong) progress, (gulong) progressMax, 1);
+  else
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                    moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
+                    (gulong) progress, 0, 1);
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  temp->downloaded_size = progress;
+  temp->file_size = progressMax;
+
+  /* storing current downloaded size. */
+  ((GtkMozEmbedDownload *) mDownload->parent)->downloaded_size = (gulong) progress;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnStatus(nsIRequest *request, nsISupports *context,
+                        nsresult status, const PRUnichar *statusText)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnStopRequest(nsIRequest *request, nsISupports *context,
+                             nsresult status)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s, [status=%x]\n",  __LINE__, __FUNCTION__, status);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = nsnull;
+  GtkMozEmbedDownload *parent = (GtkMozEmbedDownload *) mDownload->parent;
+  if (mDownload->isCanceled)
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent), moz_embed_download_signals[DOWNLOAD_DESTROYED_SIGNAL]);
+  else if (!parent->is_paused) {
+    if (NS_FAILED(status)) {
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                      moz_embed_download_signals[DOWNLOAD_FAILED_SIGNAL]);    //error
+      // DOWNLOAD_FAILED_SIGNAL, DOWNLOAD_DESTROYED_SIGNAL, DOWNLOAD_COMPLETED_SIGNAL, DOWNLOAD_STOPPED_SIGNAL,
+      gtk_moz_embed_load_url (EmbedCommon::GetAnyLiveWidget(), parent->server);
+    }
+    else
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                      moz_embed_download_signals[DOWNLOAD_COMPLETED_SIGNAL]);
+  }
+
+  return NS_OK;
+}
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedDownloadMgr.h mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedDownloadMgr.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.h	2007-10-03 12:03:15.000000000 +0300
@@ -40,59 +40,56 @@
 #ifndef __EmbedDownloadMgr_h
 #define __EmbedDownloadMgr_h
 
 #include "EmbedPrivate.h"
 #include "nsIHelperAppLauncherDialog.h"
 #include "nsIMIMEInfo.h"
 #include "nsCOMPtr.h"
 #include "nsIExternalHelperAppService.h"
 #include "nsIRequest.h"
 #include "nsILocalFile.h"
+#include "nsIIncrementalDownload.h"
+#include "nsIRequestObserver.h"
 
 #include "nsWeakReference.h"
 #define EMBED_DOWNLOADMGR_DESCRIPTION "MicroB Download Manager"
 #define EMBED_DOWNLOADMGR_CID {0x53df12a2, 0x1f4a, 0x4382, {0x99, 0x4e, 0xed, 0x62, 0xcf, 0x0d, 0x6b, 0x3a}}
 
 class nsIURI;
 class nsIFile;
 class nsIFactory;
 class nsExternalAppHandler;
 
-typedef struct _EmbedDownload EmbedDownload;
-
-struct _EmbedDownload
+class EmbedDownload
 {
+public:
+  EmbedDownload();
+  ~EmbedDownload();
   GtkObject*  parent;
   GtkWidget*  gtkMozEmbedParentWidget;/** Associated gtkmozembed widget */
 
-  char*       file_name;             /** < The file's name */
-  char*       file_name_with_path;   /** < The file's name */
-  const char* server;                /** < The server's name */
-  const char* file_type;             /** < The file's type */
-  const char* handler_app;           /** < The application's name */
-  PRInt64     file_size;             /** < The file's size */
-  PRInt64     downloaded_size;       /** < The download's size */
-  gboolean    is_paused;             /** < If download is paused or not */
-  gboolean    open_with;             /** < If the file can be opened by other application */
-
   /* Pointer to mozilla interfaces */
   nsIHelperAppLauncher* launcher;    /** < The mozilla's download dialog */
+  nsCOMPtr <nsIIncrementalDownload> incr_launcher;
   nsIRequest* request;               /** < The download request */
+  PRBool isCanceled;
 };
 
 class EmbedDownloadMgr : public nsIHelperAppLauncherDialog
 {
   public:
     EmbedDownloadMgr();
     virtual ~EmbedDownloadMgr();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIHELPERAPPLAUNCHERDIALOG
+    static nsresult CreateIncrementalDownload(const char *aUrl, const char *aDestination, PRBool aHidden = PR_FALSE);
+    static nsresult CreateIncrementalDownload(EmbedDownload *download);
 
   private:
     /** Gets all informations about a file which is being downloaded.
     */
     NS_METHOD GetDownloadInfo(nsIHelperAppLauncher *aLauncher, nsISupports *aContext);
 
     EmbedDownload *mDownload;
 };
 #endif /* __EmbedDownloadMgr_h */
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedEventListener.cpp mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedEventListener.cpp	2007-05-02 01:24:25.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -16,20 +16,21 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Oleg Romashin <romaxa@gmail.com>
+ *   Anton Rogaynis <rogainis@gmail.com>
  *   Tomaz Noleto <tnoleto@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
@@ -43,61 +44,103 @@
 #include "nsIDOMMouseEvent.h"
 
 #include "nsIDOMNSEvent.h"
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMUIEvent.h"
 #include "nsIDOMDocument.h"
 #include "nsIDocument.h"
 #include "nsIContent.h"
 #include "nsIPresShell.h"
 #include "nsIDOMNodeList.h"
+#include "nsIPrefService.h"
 
 #include "EmbedEventListener.h"
 #include "EmbedPrivate.h"
 #include "gtkmozembed_internal.h"
+#include "nsIDOMPopupBlockedEvent.h"
 
 static PRInt32 sLongPressTimer = 0, mLongMPressDelay = 1000;
-static PRInt32 sX = 0, sY = 0;
-static PRBool  sMPressed = PR_FALSE, sIsScrolling = PR_FALSE;
+static PRInt32 spX = 0, spY = 0, sScrollStep = 2;
+static PRInt32 sgX = 0, sgY = 0;
+static PRBool  sMPressed = PR_FALSE, sForcePan = PR_FALSE;
+static PRBool sDirectPan = PR_TRUE;
+static PRInt16 sIsScrolling = 0, sXulType = 0;
 static char* gFavLocation = NULL;
+#define START_PANNING_STEP 8
+
+static gboolean
+motion_notify_event_cb (GtkWidget *widget, GdkEventMotion *event, EmbedEventListener *self);
+static gboolean
+button_release_event_cb(GtkWidget *widget, GdkEvent *event, EmbedPrivate *self);
+static gboolean
+button_press_event_cb(GtkWidget *widget, GdkEvent *event, EmbedPrivate *self);
+static gboolean
+enter_notify_event_cb  (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self);
+static gboolean
+leave_notify_event_cb  (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self);
 
 EmbedEventListener::EmbedEventListener(void)
 {
   mOwner = nsnull;
+  mAddonSignals = PR_FALSE;
+  mXSLTransformed = PR_FALSE;
 }
 
 EmbedEventListener::~EmbedEventListener()
 {
   delete mCtxInfo;
+  mOwner = nsnull;
+  mCtxInfo = nsnull;
+  mAddonSignals = PR_FALSE;
 }
 
 NS_IMPL_ADDREF(EmbedEventListener)
 NS_IMPL_RELEASE(EmbedEventListener)
 NS_INTERFACE_MAP_BEGIN(EmbedEventListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMKeyListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMKeyListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMUIListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseMotionListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMFocusListener)
   NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
 NS_INTERFACE_MAP_END
 
 nsresult
 EmbedEventListener::Init(EmbedPrivate *aOwner)
 {
+  nsresult rv;
   mOwner = aOwner;
   mCtxInfo = nsnull;
   mClickCount = 1;
   mCtxInfo = new EmbedContextMenuInfo(aOwner);
   mOwner->mNeedFav = PR_TRUE;
+  nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+  if (!prefs)
+    return NS_OK;
+
+  PRInt32 scrollStep = 0;
+  PRBool forcePan = PR_FALSE;
+  PRBool directPan = PR_TRUE;
+  rv = prefs->GetIntPref("gtkmozembed.mscroll.step", &scrollStep);
+  if (scrollStep && NS_SUCCEEDED(rv))
+    sScrollStep = scrollStep;
+
+  rv = prefs->GetBoolPref("gtkmozembed.mscroll.force", &forcePan);
+  if (scrollStep && NS_SUCCEEDED(rv))
+    sForcePan = forcePan;
+
+  rv = prefs->GetBoolPref("gtkmozembed.mscroll.direct", &directPan);
+  if (NS_SUCCEEDED(prefs->GetBoolPref("gtkmozembed.mscroll.direct", &directPan)) && !directPan)
+    sDirectPan = directPan;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleLink(nsIDOMNode* node)
 {
   nsresult rv;
 
   nsCOMPtr<nsIDOMElement> linkElement;
   linkElement = do_QueryInterface(node);
@@ -145,44 +188,94 @@ EmbedEventListener::HandleLink(nsIDOMNod
   }
   else if (name.LowerCaseEqualsLiteral("alternate") &&
            type.LowerCaseEqualsLiteral("application/rss+xml")) {
 
     NS_ConvertUTF16toUTF8 narrowTitle(title);
 
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[RSS_REQUEST],
                     (gchar *)url.get(),
                     narrowTitle.get());
+    mXSLTransformed = PR_FALSE;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleEvent(nsIDOMEvent* aDOMEvent)
 {
   nsString eventType;
   aDOMEvent->GetType(eventType);
 
+  if (mOwner->mWindow && eventType.EqualsLiteral("DOMLinkXSLParsed")) {
+    mXSLTransformed = PR_TRUE;
+    return NS_OK;
+  }
+
   if (eventType.EqualsLiteral("focus"))
     if (mCtxInfo->GetFormControlType(aDOMEvent)) {
-      if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
         gint return_val = FALSE;
         gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                         moz_embed_signals[DOM_FOCUS],
                         (void *)aDOMEvent, &return_val);
         if (return_val) {
           aDOMEvent->StopPropagation();
           aDOMEvent->PreventDefault();
         }
       }
     }
 
+  if (eventType.EqualsLiteral("DOMPopupBlocked")) {
+    nsCOMPtr<nsIDOMPopupBlockedEvent> popupEvent =
+      do_QueryInterface (aDOMEvent);
+    NS_ENSURE_TRUE (popupEvent, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIURI> popupWindowURI;
+    popupEvent->GetPopupWindowURI (getter_AddRefs (popupWindowURI));
+
+    nsCString popupWindowURIString;
+    nsCString Host;
+    nsresult rv;
+
+    if (popupWindowURI) {
+      rv = popupWindowURI->GetSpec (popupWindowURIString);
+      NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+      rv = popupWindowURI->GetHost (Host);
+      NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+    }
+
+    nsString popupWindowFeatures;
+    rv = popupEvent->GetPopupWindowFeatures (popupWindowFeatures);
+    NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+
+    nsCString popupWindowFeaturesString;
+    NS_UTF16ToCString (popupWindowFeatures,
+                       NS_CSTRING_ENCODING_UTF8,
+                       popupWindowFeaturesString);
+
+    nsCString popupWindowNameString;
+#ifdef HAVE_GECKO_1_9
+    nsString popupWindowName;
+    rv = popupEvent->GetPopupWindowName (popupWindowName);
+    NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+
+    NS_UTF16ToCString (popupWindowName,
+                       NS_CSTRING_ENCODING_UTF8,
+                       popupWindowNameString);
+#endif
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_CONTENT_BLOCKED],
+                    (void *)popupWindowURIString.get(),(void*)Host.get());
+    return NS_OK;
+  }
+
   if (eventType.EqualsLiteral("DOMLinkAdded")) {
 
     nsresult rv;
     nsCOMPtr<nsIDOMEventTarget> eventTarget;
 
     aDOMEvent->GetTarget(getter_AddRefs(eventTarget));
     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(eventTarget, &rv);
     if (NS_FAILED(rv) || !node)
       return NS_ERROR_FAILURE;
     HandleLink(node);
@@ -194,42 +287,53 @@ EmbedEventListener::HandleEvent(nsIDOMEv
 
     nsCOMPtr<nsIDOMWindow> DOMWindow;
     webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     if (!DOMWindow) return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMDocument> doc;
     DOMWindow->GetDocument(getter_AddRefs(doc));
     if (!doc) return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNodeList> nodelist = nsnull;
+    
+    PRUint32 length = 0;
     doc->GetElementsByTagName( NS_LITERAL_STRING( "rss" ), getter_AddRefs( nodelist ));
-    if (nodelist) {
-      PRUint32 length = 0;
+    if (nodelist)
       nodelist->GetLength(&length);
-      if (length >= 1) {
+    if (!nodelist || length == 0) {
+      doc->GetElementsByTagName( NS_LITERAL_STRING( "feed" ), getter_AddRefs( nodelist ));
+      if (nodelist)
+        nodelist->GetLength(&length);
+    }
+    if (!nodelist || length == 0) {
+      doc->GetElementsByTagName( NS_LITERAL_STRING( "rdf:RDF" ), getter_AddRefs( nodelist ));
+      if (nodelist)
+        nodelist->GetLength(&length);
+    }
+    if (nodelist && length >= 1 || mXSLTransformed) {
         char *url = gtk_moz_embed_get_location(mOwner->mOwningWidget);
         char *title = gtk_moz_embed_get_title(mOwner->mOwningWidget);
         gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                         moz_embed_signals[RSS_REQUEST],
                         (gchar*)url,
                         (gchar*)title);
         if (url)
           NS_Free(url);
         if (title)
           NS_Free(title);
-      }
+        mXSLTransformed = PR_FALSE;
     }
   }
   else if (mOwner->mNeedFav) {
     mOwner->mNeedFav = PR_FALSE;
     nsCString favicon_url = mOwner->mPrePath;
-	favicon_url.AppendLiteral("/favicon.ico");
+    favicon_url.AppendLiteral("/favicon.ico");
     this->GetFaviconFromURI(favicon_url.get());
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::KeyDown(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMKeyEvent> keyEvent;
   keyEvent = do_QueryInterface(aDOMEvent);
@@ -286,115 +390,213 @@ EmbedEventListener::KeyPress(nsIDOMEvent
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
   return NS_OK;
 }
 
 static gboolean
 sLongMPress(void *aOwningWidget)
 {
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (!sMPressed || sIsScrolling)
+  if (EmbedPrivate::sTermEmbedding) {
+      fprintf(stderr,"%s:Warning: Emit signal after destroy\n", __FUNCTION__);
+      return FALSE;
+  }
+
+  if (!sMPressed || sIsScrolling
+    || (ABS(spX-sgX) > START_PANNING_STEP + 3 || ABS(spY-sgY) > START_PANNING_STEP + 3)
+    )
     return FALSE;
+
   sMPressed = PR_FALSE;
+  spX = 0;
+  spY = 0;
+  sgX = 0;
+  sgY = 0;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(aOwningWidget),
                   moz_embed_signals[DOM_MOUSE_LONG_PRESS],
                   (void *)0, &return_val);
   if (return_val) {
     sMPressed = PR_FALSE;
   }
   return FALSE;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseDown(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
-
-  // Return TRUE from your signal handler to mark the event as consumed.
-  sMPressed = PR_TRUE;
+    
+  if(!(mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_SELECT))
+    sMPressed = PR_TRUE;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_DOWN],
                   (void *)mouseEvent, &return_val);
-  if (return_val) {
+  if (!return_val && !sForcePan) {
     mClickCount = 2;
     sMPressed = PR_FALSE;
 #if 1
-    if (sLongPressTimer)
-      g_source_remove(sLongPressTimer);
+    GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
 #else
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
 #endif
   } else {
     mClickCount = 1;
     sLongPressTimer = g_timeout_add(mLongMPressDelay, sLongMPress, mOwner->mOwningWidget);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&sX);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&sY);
+    
+    // Return TRUE from your signal handler to mark the event as consumed.
+    PRInt32 JSHandledInfo = DOM_MOUSE_DOWN;
+    if (mCtxInfo->mIsJSHandledElement == DOM_MOUSE_OVER
+        || mCtxInfo->mIsJSHandledElement == DOM_MOUSE_SCROLL) {
+      return NS_OK;
+    }
+    if (mCtxInfo && NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+        && JSHandledInfo == DOM_MOUSE_DOWN) {
+      return NS_OK;
+    }
+    
+    if (!sDirectPan) {
+    //((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&spX);
+    //((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&spY);
+    } else {
+      if (!mAddonSignals) {
+        GtkWidget * child = gtk_bin_get_child((GtkBin *)mOwner->mOwningWidget);
+        if (child) {
+          g_signal_connect(G_OBJECT(child), "motion_notify_event",
+                           G_CALLBACK(motion_notify_event_cb), this);
+          g_signal_connect(G_OBJECT(child), "button_release_event",
+                           G_CALLBACK(button_release_event_cb), mOwner);
+          g_signal_connect(G_OBJECT(child), "button_press_event",
+                           G_CALLBACK(button_press_event_cb), mOwner);
+          g_signal_connect(G_OBJECT(child), "enter_notify_event",
+                           G_CALLBACK(enter_notify_event_cb), this);
+          g_signal_connect(G_OBJECT(child), "leave_notify_event",
+                           G_CALLBACK(leave_notify_event_cb), this);
+          mAddonSignals = PR_TRUE;
+        }
+      }
+    }
+  }
+  if (sDirectPan) {
+    spX = sgX;
+    spY = sgY;
   }
 
   // handling event internally.
   HandleSelection(mouseEvent);
 
+  if (mCtxInfo)
+    sXulType = mCtxInfo->mIsScrollableElement;
+
   return NS_OK;
 }
 
+static void
+PanStatesReset(EmbedPrivate *self, PRBool aFull = PR_TRUE)
+{
+  GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+  sMPressed = PR_FALSE;
+  if (self)
+    self->mOpenBlock = sIsScrolling > 2;
+  sIsScrolling = sMPressed;
+  spX = sgX;
+  spY = sgY;
+  sXulType = 0;
+
+  EmbedCommon::SuspendNative(PR_FALSE);
+
+  if (!aFull) return;
+  gint return_val = FALSE;
+  if (self)
+    gtk_signal_emit(GTK_OBJECT(self->mOwningWidget),
+                    moz_embed_signals[DOM_MOUSE_UP],
+                    (void *)nsnull, &return_val);
+}
+
 NS_IMETHODIMP
 EmbedEventListener::MouseUp(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
 
+#if 1
+    GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+#else
+    aDOMEvent->StopPropagation();
+    aDOMEvent->PreventDefault();
+#endif
+
   // handling event internally, first.
   HandleSelection(mouseEvent);
 
+  if (!sDirectPan)
+  PanStatesReset(mOwner, PR_FALSE);
+
+  mCtxInfo->mIsJSHandledElement = 0;
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (sLongPressTimer)
-    g_source_remove(sLongPressTimer);
-  sMPressed = PR_FALSE;
-  mOwner->mOpenBlock = sIsScrolling;
-  sIsScrolling = sMPressed;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_UP],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
+
+  if (mOwner->mLoadFinished && mOwner->mPluginSuspended) {
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+    if (enabled && success) {
+      mOwner->NotifyPlugins(3);
+      mOwner->mPluginSuspended = PR_FALSE;
+    }
+  }
+
+  gtk_widget_queue_draw(GTK_WIDGET(mOwner->mOwningWidget));
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseClick(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
   // Return TRUE from your signal handler to mark the event as consumed.
   sMPressed = PR_FALSE;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_CLICK],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
+
+  if (mOwner->mLoadFinished && mOwner->mPluginSuspended) {
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+    if (enabled && success) {
+      mOwner->NotifyPlugins(3);
+      mOwner->mPluginSuspended = PR_FALSE;
+    }
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseDblClick(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
@@ -413,20 +615,25 @@ EmbedEventListener::MouseDblClick(nsIDOM
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseOver(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
+  PRInt32 JSHandledInfo = DOM_MOUSE_OVER;
+  if (mCtxInfo && NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+      && JSHandledInfo == DOM_MOUSE_OVER)
+    return NS_OK;
+
   // Return TRUE from your signal handler to mark the event as consumed.
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_OVER],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   } else {
     //mCtxInfo->UpdateContextData(aDOMEvent);
@@ -503,178 +710,168 @@ EmbedEventListener::FocusOut(nsIDOMEvent
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseMove(nsIDOMEvent* aDOMEvent)
 {
+  PRInt32 JSHandledInfo = DOM_MOUSE_SCROLL;
+  if (mCtxInfo && mCtxInfo->mIsJSHandledElement != DOM_MOUSE_OVER &&
+      NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+      && JSHandledInfo == DOM_MOUSE_SCROLL) {
+    return NS_OK;
+  }
+
+  if (sMPressed && mCtxInfo && (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL) && sXulType < 2)
+     EmbedCommon::SuspendNative(PR_TRUE);
+
   if (mCurSelCon)
     mCurSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
 
-  if (sMPressed &&
-      gtk_signal_handler_pending(GTK_OBJECT(mOwner->mOwningWidget),
-                                 moz_embed_signals[DOM_MOUSE_SCROLL], TRUE)) {
+  if (mCtxInfo &&
+      (sMPressed &&
+       (gtk_signal_handler_pending(GTK_OBJECT(mOwner->mOwningWidget),
+                                   moz_embed_signals[DOM_MOUSE_SCROLL], TRUE)
+        || sForcePan)
+       && (!(mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL && sXulType != 2))
+      )
+     ) {
     // Return TRUE from your signal handler to mark the event as consumed.
     nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aDOMEvent);
-    if (!mouseEvent)
-      return NS_OK;
     PRInt32  newX, newY, subX, subY;
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&newX);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&newY);
-    subX = newX - sX;
-    subY = newY - sY;
-    nsresult rv = NS_OK;
-    if (ABS(subX) > 10 || ABS(subY) > 10 || (sIsScrolling && sMPressed)) {
-      if (!sIsScrolling) {
-        gint return_val = FALSE;
-        gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                        moz_embed_signals[DOM_MOUSE_SCROLL],
-                        (void *)mouseEvent, &return_val);
-        if (!return_val) {
-          sIsScrolling = PR_TRUE;
-          if (mCtxInfo)
-            rv = mCtxInfo->GetElementForScroll(aDOMEvent);
-        } else {
-          sMPressed = PR_FALSE;
-          sIsScrolling = PR_FALSE;
+    if (sDirectPan) {
+      newX = sgX;
+      newY = sgY;
+    } else {
+      if (!mouseEvent)
+        return NS_OK;
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&newX);
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&newY);
+    }
+    subX = newX - spX;
+    subY = newY - spY;
+    if (!sIsScrolling
+        && (ABS(subX) > START_PANNING_STEP || ABS(subY) > START_PANNING_STEP)) {
+      gint return_val = FALSE;
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[DOM_MOUSE_SCROLL],
+                      (void *)mouseEvent, &return_val);
+      if ((!return_val || sXulType == 2) && mCtxInfo->GetScrollableView()) {
+        sIsScrolling = PR_TRUE;
+        if (sXulType < 2)
+          EmbedCommon::SuspendNative(PR_TRUE);
+
+        // suspend plugins when panning
+        // Only need to suspend when page is already loaded and at the FIRST movement
+        if ( mOwner->mLoadFinished && !mOwner->mPluginSuspended ) {
+          PRBool enabled = PR_TRUE;
+          gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+          if (success && enabled) {
+            // do suspend
+            mOwner->NotifyPlugins(4);
+            mOwner->mPluginSuspended = PR_TRUE;
+          }
         }
+      } else {
+        sMPressed = PR_FALSE;
+        sIsScrolling = PR_FALSE;
       }
-      if (sIsScrolling)
-      {
-        if (sLongPressTimer)
-          g_source_remove(sLongPressTimer);
-        if (mCtxInfo->mNSHHTMLElementSc) {
-          PRInt32 x, y;
-          mCtxInfo->mNSHHTMLElementSc->GetScrollTop(&y);
-          mCtxInfo->mNSHHTMLElementSc->GetScrollLeft(&x);
-#ifdef MOZ_SCROLL_TOP_LEFT_HACK
-          rv = mCtxInfo->mNSHHTMLElementSc->ScrollTopLeft(y - subY, x - subX);
-#endif
-        } else {
-          rv = NS_ERROR_UNEXPECTED;
-        }
-        if (rv == NS_ERROR_UNEXPECTED) {
-          nsCOMPtr<nsIDOMWindow> DOMWindow;
-          nsIWebBrowser *webBrowser = nsnull;
-          gtk_moz_embed_get_nsIWebBrowser(mOwner->mOwningWidget, &webBrowser);
-          webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
-          DOMWindow->ScrollBy(-subX, -subY);
-        }
+    }
+
+    if (sIsScrolling && (ABS(subX) >= sScrollStep || ABS(subY) >= sScrollStep)) {
+      spX = newX;
+      spY = newY;
+      if (!mCtxInfo->mIsScrollableElement)
+        return NS_OK;
+      GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+      if (mCtxInfo->mCtxScrollable && !(sDirectPan && aDOMEvent)) {
+        sIsScrolling++;
+        mCtxInfo->ScrollScrollableView(-subX, -subY);
       }
-      sX = newX;
-      sY = newY;
-      sIsScrolling = sMPressed;
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::DragMove(nsIDOMEvent* aMouseEvent)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::Focus(nsIDOMEvent* aEvent)
 {
   nsString eventType;
   aEvent->GetType(eventType);
 
   if (eventType.EqualsLiteral("focus") &&
       mCtxInfo->GetFormControlType(aEvent) &&
-      mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
     gint return_val = FALSE;
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[DOM_FOCUS],
                     (void *)aEvent, &return_val);
     if (return_val) {
       aEvent->StopPropagation();
       aEvent->PreventDefault();
     }
   }
 
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 EmbedEventListener::Blur(nsIDOMEvent* aEvent)
 {
-  gint return_val = FALSE;
   mFocusInternalFrame = PR_FALSE;
 
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
-  nsCOMPtr<nsIDOMEventTarget> target;
-  nsevent->GetOriginalTarget(getter_AddRefs(target));
-
-  if (!target)
-    return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(target);
-
-  if (targetContent) {
-#ifdef MOZILLA_1_8_BRANCH
-    if (targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
-#else
-    if (targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
-#endif
-      if (sLongPressTimer)
-        g_source_remove(sLongPressTimer);
-
-      sMPressed = sIsScrolling ? PR_FALSE : sMPressed;
-      sIsScrolling = PR_FALSE;
-    }
-  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleSelection(nsIDOMMouseEvent* aDOMMouseEvent)
 {
   nsresult rv;
 
   /* This function gets called everytime that a mousedown or a mouseup
    * event occurs.
    */
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aDOMMouseEvent));
+  nsCOMPtr<nsIDOMNSEvent> nsevent = do_QueryInterface(aDOMMouseEvent, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDOMEventTarget> target;
   rv = nsevent->GetOriginalTarget(getter_AddRefs(target));
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
-  nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(target);
+  nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(target, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMDocument> domDoc;
   rv = eventNode->GetOwnerDocument(getter_AddRefs(domDoc));
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc, &rv);
-  if (NS_FAILED(rv) || !doc)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsIPresShell *presShell = doc->GetPrimaryShell();
-
   /* Gets nsISelectionController interface for the current context */
-  mCurSelCon = do_QueryInterface(presShell);
-  if (!mCurSelCon)
-    return NS_ERROR_FAILURE;
+  mCurSelCon = do_QueryInterface(presShell, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   /* Gets event type */
   nsString eventType;
   rv = aDOMMouseEvent->GetType(eventType);
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   /* Updates context to check which context is being clicked on */
   mCtxInfo->UpdateContextData(aDOMMouseEvent);
 
   /* If a mousedown after 1 click is done (and if clicked context is not a XUL
    * one (e.g. scrollbar), the selection is disabled for that context.
    */
   if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL || mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_RICHEDIT)
     return rv;
 
@@ -689,32 +886,34 @@ EmbedEventListener::HandleSelection(nsID
    * number of clicks). If this event occurs after 1 click, the selection of
    * both last and current contexts are cleaned up.
    */
   if (eventType.EqualsLiteral("mouseup")) {
 
     /* Selection controller of current event context */
     if (mCurSelCon) {
       rv = mCurSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
       if (mClickCount == 1) {
         nsCOMPtr<nsISelection> domSel;
-        mCurSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
-                                 getter_AddRefs(domSel));
+        rv = mCurSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
+                                      getter_AddRefs(domSel));
+        NS_ENSURE_SUCCESS(rv, rv);                              
         rv = domSel->RemoveAllRanges();
       }
     }
     /* Selection controller of previous event context */
     if (mLastSelCon) {
       rv = mLastSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
       if (mClickCount == 1) {
         nsCOMPtr<nsISelection> domSel;
-        mLastSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
-                                  getter_AddRefs(domSel));
+        rv = mLastSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
+                                       getter_AddRefs(domSel));
+        NS_ENSURE_SUCCESS(rv, rv);                               
         rv = domSel->RemoveAllRanges();
       }
     }
 
     /* If 1 click was done (despite the event type), sets the last context's
      * selection controller with current one
      */
     if (mClickCount == 1)
       mLastSelCon = mCurSelCon;
   } // mouseup
@@ -748,157 +947,155 @@ EmbedEventListener::GetIOService(nsIIOSe
 
   rv = mgr->GetServiceByContractID("@mozilla.org/network/io-service;1",
                                    NS_GET_IID(nsIIOService),
                                    (void **)ioService);
   return rv;
 }
 
 void
 EmbedEventListener::GeneratePixBuf()
 {
+  if (!::gFavLocation)
+    return;
+
   GdkPixbuf *pixbuf = NULL;
   pixbuf = gdk_pixbuf_new_from_file(::gFavLocation, NULL);
-  if (!pixbuf) {
+  if (!pixbuf && mOwner->mOwningWidget) {
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[ICON_CHANGED],
                     NULL );
 
     // remove the wrong favicon
     // FIXME: need better impl...
     nsCOMPtr<nsILocalFile> faviconFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
 
     if (!faviconFile) {
-      NS_Free(::gFavLocation);
-      gFavLocation = nsnull;
+      if (::gFavLocation) {
+        NS_Free(::gFavLocation);
+        gFavLocation = nsnull;
+      }
       return;
     }
 
     nsCString faviconLocation(::gFavLocation);
     faviconFile->InitWithNativePath(faviconLocation);
     faviconFile->Remove(FALSE);
-    NS_Free(::gFavLocation);
-    gFavLocation = nsnull;
+
+    if (::gFavLocation) {
+      NS_Free(::gFavLocation);
+      gFavLocation = nsnull;
+    }
     return;
   }
 
+  if (!(mOwner && mOwner->mOwningWidget))
+    return;
+
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[ICON_CHANGED],
                   pixbuf );
   //mOwner->mNeedFav = PR_FALSE;
-  NS_Free(::gFavLocation);
-  gFavLocation = nsnull;
+  if (::gFavLocation) {
+    NS_Free(::gFavLocation);
+    gFavLocation = nsnull;
+  }
 }
 
 void
 EmbedEventListener::GetFaviconFromURI(const char* aURI)
 {
-  gchar *file_name = NS_strdup(aURI);
-  gchar *favicon_uri = NS_strdup(aURI);
+  nsresult rv = NS_OK;
 
-  gint i = 0;
-  gint rv = 0;
+  if (!aURI)
+    return;
 
-  nsCOMPtr<nsIWebBrowserPersist> persist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
-  if (!persist) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
+  gchar *file_name = NS_strdup(aURI);
+  if (!file_name)
     return;
-  }
-  persist->SetProgressListener(this);
 
+  gint i = 0;
   while (file_name[i] != '\0') {
     if (file_name[i] == '/' || file_name[i] == ':')
       file_name[i] = '_';
     i++;
   }
 
   nsCString fileName(file_name);
+  NS_Free(file_name);
 
-  nsCOMPtr<nsILocalFile> favicon_dir = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
-
-  if (!favicon_dir) {
-    NS_Free(favicon_uri);
-    NS_Free(file_name);
+  nsCOMPtr<nsIWebBrowserPersist> persist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
+  if (!persist)
     return;
-  }
+  persist->SetProgressListener(this);
 
-  nsCString faviconDir("~/.mozilla/favicon");
-  favicon_dir->InitWithNativePath(faviconDir);
+  nsCOMPtr<nsILocalFile> favicon_dir = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
+  if (!favicon_dir)
+    return;
+  favicon_dir->InitWithNativePath(NS_LITERAL_CSTRING("~/.mozilla/favicon"));
 
   PRBool isExist;
   rv = favicon_dir->Exists(&isExist);
   if (NS_SUCCEEDED(rv) && !isExist) {
     rv = favicon_dir->Create(nsIFile::DIRECTORY_TYPE,0775);
-    if (NS_FAILED(rv)) {
-      NS_Free(file_name);
-      NS_Free(favicon_uri);
+    if (NS_FAILED(rv))
       return;
-    }
   }
 
-  nsCAutoString favicon_path("~/.mozilla/favicon");
   nsCOMPtr<nsILocalFile> target_file = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
-  if (!target_file) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
+  if (!target_file)
     return;
-  }
-  target_file->InitWithNativePath(favicon_path);
+  target_file->InitWithNativePath(NS_LITERAL_CSTRING("~/.mozilla/favicon"));
   target_file->Append(NS_ConvertUTF8toUTF16(fileName));
 
   nsString path;
   target_file->GetPath(path);
   ::gFavLocation = NS_strdup(NS_ConvertUTF16toUTF8(path).get());
   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
-    NS_Free(::gFavLocation);
+    if (::gFavLocation)
+      NS_Free(::gFavLocation);
     gFavLocation = nsnull;
     return;
   }
 
   nsCOMPtr<nsIURI> uri;
-
-  rv = ios->NewURI(nsDependentCString(favicon_uri), "", nsnull, getter_AddRefs(uri));
+  rv = ios->NewURI(nsDependentCString(aURI), "", nsnull, getter_AddRefs(uri));
   if (!uri) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
-    NS_Free(::gFavLocation);
+    if (::gFavLocation)
+      NS_Free(::gFavLocation);
     gFavLocation = nsnull;
     return;
   }
-  NS_Free(file_name);
-  NS_Free(favicon_uri);
 
   // save the favicon if the icon does not exist
   rv = target_file->Exists(&isExist);
   if (NS_SUCCEEDED(rv) && !isExist) {
     rv = persist->SaveURI(uri, nsnull, nsnull, nsnull, "", target_file);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv))
       return;
-    }
   }
-  else {
+  else
     GeneratePixBuf();
-  }
-
 }
 
 NS_IMETHODIMP
 EmbedEventListener::OnStateChange(nsIWebProgress *aWebProgress,
                                   nsIRequest *aRequest,
                                   PRUint32 aStateFlags,
                                   nsresult aStatus)
 {
   /* if (!(aStateFlags & (STATE_STOP | STATE_IS_NETWORK | STATE_IS_DOCUMENT))){*/
 
+  if (EmbedPrivate::sTermEmbedding) {
+      fprintf(stderr,"%s:Warning: Emit signal after destroy\n", __FUNCTION__);
+      return NS_ERROR_FAILURE;
+  }
   if (aStateFlags & STATE_STOP)
     /* FINISH DOWNLOADING */
     /* XXX sometimes this==0x0 and it cause crash in GeneratePixBuf, need workaround check for this */
     if (NS_SUCCEEDED(aStatus) && this)
       GeneratePixBuf();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -931,10 +1128,91 @@ EmbedEventListener::OnStatusChange(nsIWe
 }
 
 
 NS_IMETHODIMP
 EmbedEventListener::OnSecurityChange(nsIWebProgress *aWebProgress,
                                      nsIRequest *aRequest,
                                      PRUint32 aState)
 {
   return NS_OK;
 }
+
+void 
+EmbedEventListener::DisableLongPressTimer(GtkWidget *aOwningWidget)
+{
+  gint return_val;
+  
+  GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+          
+  gtk_signal_emit(GTK_OBJECT(aOwningWidget),
+                  moz_embed_signals[DOM_MOUSE_UP],
+                  NULL, &return_val);  
+                              
+  sMPressed = sIsScrolling ? PR_FALSE : sMPressed;
+  sIsScrolling = PR_FALSE;
+}
+
+#include <gdk/gdkx.h>
+/* static */
+gboolean
+motion_notify_event_cb (GtkWidget *widget, GdkEventMotion *event, EmbedEventListener *self)
+{
+  sgX = nscoord(event->x);
+  sgY = nscoord(event->y);
+
+  if (sXulType == 3)
+    return TRUE;
+
+  if ((sIsScrolling || sXulType == 2) && sXulType != 0) {
+    XEvent xevent;
+    PRPackedBool synthEvent = PR_FALSE;
+    while (XCheckWindowEvent(GDK_WINDOW_XDISPLAY(event->window),
+                             GDK_WINDOW_XWINDOW(event->window),
+                             ButtonMotionMask, &xevent)) {
+      synthEvent = PR_TRUE;
+    }
+
+    if (sXulType == 2) {
+      self->MouseMove(nsnull);
+      return FALSE;
+    }
+    self->MouseMove(nsnull);
+    return TRUE;
+  }
+  return FALSE;
+}
+
+/* static */
+gboolean
+button_release_event_cb (GtkWidget *widget, GdkEvent *event, EmbedPrivate *self)
+{
+  PanStatesReset(self);
+  return FALSE;
+}
+
+/* static */
+gboolean
+button_press_event_cb (GtkWidget *widget, GdkEvent *event, EmbedPrivate *self)
+{
+  spX = nscoord(((GdkEventButton*)event)->x);
+  spY = nscoord(((GdkEventButton*)event)->y);
+  return FALSE;
+}
+
+/* static */
+gboolean
+enter_notify_event_cb (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self)
+{
+  if (sXulType == 3)
+    return TRUE;
+  return FALSE;
+}
+
+/* static */
+gboolean
+leave_notify_event_cb (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self)
+{
+  if (sXulType == 3)
+    return TRUE;
+  return FALSE;
+}
+
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedEventListener.h mozilla/embedding/browser/gtk/src/EmbedEventListener.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedEventListener.h	2007-04-23 17:21:56.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedEventListener.h	2007-10-03 12:03:15.000000000 +0300
@@ -127,23 +127,27 @@ class EmbedEventListener : public nsIDOM
   NS_IMETHOD Blur(nsIDOMEvent* aEvent);
   NS_IMETHOD HandleSelection(nsIDOMMouseEvent* aDOMMouseEvent);
 
   nsresult   NewURI            (nsIURI **result,
                                 const char *spec);
   nsresult   GetIOService      (nsIIOService **ioService);
 
   void       GeneratePixBuf    ();
 
   void       GetFaviconFromURI (const char*  aURI);
+ 
+  static void DisableLongPressTimer(GtkWidget *aOwningWidget);
  private:
 
   EmbedPrivate *mOwner;
   EmbedContextMenuInfo *mCtxInfo;
 
   // Selection and some clipboard stuff
   nsCOMPtr<nsISelectionController> mCurSelCon;
   nsCOMPtr<nsISelectionController> mLastSelCon;
   PRBool mFocusInternalFrame;
   PRInt32 mClickCount;
+  PRBool mAddonSignals;
+  PRBool mXSLTransformed;
 };
 
 #endif /* __EmbedEventListener_h */
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedFilePicker.cpp mozilla/embedding/browser/gtk/src/EmbedFilePicker.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedFilePicker.cpp	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedFilePicker.cpp	2007-03-23 17:46:31.000000000 +0200
@@ -9,25 +9,20 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
- * The Initial Developer of the Original Code is
- * timeless <timeless@mozdev.org>.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
  * Contributor(s):
  *   Antonio Gomes <tonikitoo@gmail.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedFilePicker.h mozilla/embedding/browser/gtk/src/EmbedFilePicker.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedFilePicker.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedFilePicker.h	2007-03-23 17:46:31.000000000 +0200
@@ -9,25 +9,20 @@
  * the License. You may obtain a copy of the License at
  * http://www.mozilla.org/MPL/
  *
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
- * The Initial Developer of the Original Code is
- * timeless <timeless@mozdev.org>.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
  * Contributor(s):
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedGlobalHistory.cpp mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedGlobalHistory.cpp	2007-03-23 18:16:24.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -16,20 +16,21 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Conrad Carlen <ccarlen@netscape.com>
  *   Oleg Romashin <romaxa@gmail.com>
+ *   Andre Pedralho <apedralho@gmail.com>
  *   (from original mozilla/embedding/lite/nsEmbedGlobalHistory.cpp)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
@@ -51,21 +52,21 @@
 #include "gtkmozembed_common.h"
 #include "nsISeekableStream.h"
 #ifndef MOZILLA_INTERNAL_API
 #include "nsCRT.h"
 #endif
 #include "nsILineInputStream.h"
 
 // Constants
 #define defaultSeparator 1
 // Number of changes in history before automatic flush
-static const PRInt32 kNewEntriesBetweenFlush = 10;
+static const PRInt32 kNewEntriesBetweenFlush = 20;
 static const PRInt32 kMaxSafeReadEntriesCount = 2000;
 // Default expiration interval: used if can't get preference service value
 static const PRUint32 kDefaultExpirationIntervalDays = 7;
 // Mozilla and EAL standard are different each other
 static const PRInt64 kMSecsPerDay = LL_INIT(0, 60 * 60 * 24 * 1000);
 static const PRInt64 kOneThousand = LL_INIT(0, 1000);
 // The history list and the entries counter
 static GList *mURLList;                 /** < The history list */
 static PRInt64 mExpirationInterval;     /** < Expiration interval time */
 static EmbedGlobalHistory *sEmbedGlobalHistory = nsnull;
@@ -149,33 +150,32 @@ static bool file_handle_seek(OUTPUT_STRE
 
 static bool file_handle_truncate(OUTPUT_STREAM *file_handle)
 {
   g_return_val_if_fail(file_handle, false);
   nsresult rv;
   nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(file_handle, &rv);
   rv = seekable->SetEOF();
   return NS_SUCCEEDED(rv);
 }
 
-static guint64 file_handle_write(OUTPUT_STREAM *file_handle, gpointer line)
+static bool file_handle_write(OUTPUT_STREAM *file_handle, gpointer line)
 {
   g_return_val_if_fail(file_handle, 0);
   PRUint32 amt = 0;
   nsresult rv;
   rv = file_handle->Write((char*)line, strlen((char*)line), &amt);
-  /* XXX booleans are not equivalent to guint64 */
   return NS_SUCCEEDED(rv);
 }
 
 // Static Routine Prototypes
-//GnomeVFSHandle
 static nsresult writeEntry(OUTPUT_STREAM *file_handle, HistoryEntry *entry);
+
 // when an entry is visited
 nsresult OnVisited(HistoryEntry *entry)
 {
   NS_ENSURE_ARG(entry);
   entry->mLastVisitTime = PR_Now();
   LL_DIV(entry->mLastVisitTime, entry->mLastVisitTime, kOneThousand);
   return NS_OK;
 }
 
 // Return the last time an entry was visited
@@ -203,40 +203,53 @@ PRBool GetIsWritten(HistoryEntry *entry)
 
 // Set TRUE when an entry is visited
 nsresult SetIsWritten(HistoryEntry *entry)
 {
   NS_ENSURE_ARG(entry);
   entry->mWritten = PR_TRUE;
   return NS_OK;
 }
 
 // Change the entry title
-#define SET_TITLE(entry, aTitle) (entry->mTitle.Assign(aTitle))
-
-// Return the entry title
-#define GET_TITLE(entry) (entry && !entry->mTitle.IsEmpty() ? entry->mTitle.get() : "")
-
-// Change the entry title
 nsresult SET_URL(HistoryEntry *aEntry, const char *aUrl)
 {
   NS_ENSURE_ARG(aEntry);
   NS_ENSURE_ARG(aUrl);
   aEntry->mUrl.Assign(aUrl);
   return NS_OK;
 }
 
 // Return the entry url
 const char* GET_URL(HistoryEntry *aEntry)
 {
   return (aEntry && !aEntry->mUrl.IsEmpty()) ? aEntry->mUrl.get() : "";
 }
 
+// Return the entry url
+const char* GET_HOST(HistoryEntry *aEntry)
+{
+  nsCOMPtr<nsIURI> aURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(aURI), GET_URL(aEntry));
+  if (NS_FAILED(rv))
+    return GET_URL(aEntry);
+  aURI->GetHost(aEntry->mTitle);
+  if (aEntry->mTitle.IsEmpty())
+    return GET_URL(aEntry);
+  return aEntry->mTitle.get();
+}
+
+// Change the entry title
+#define SET_TITLE(entry, aTitle) (entry->mTitle.Assign(aTitle))
+
+// Return the entry title
+#define GET_TITLE(entry) (entry && !entry->mTitle.IsEmpty() ? entry->mTitle.get() : GET_HOST(entry))
+
 // Traverse the history list trying to find a frame
 int history_entry_find_exist(gconstpointer a, gconstpointer b)
 {
   return g_ascii_strcasecmp((char*)GET_URL((HistoryEntry *)a), (char *) b);
 }
 
 // Traverse the history list looking for the correct place to add a new item
 int find_insertion_place(gconstpointer a, gconstpointer b)
 {
   PRInt64 lastVisitTime = GetLastVisitTime((HistoryEntry *) a);
@@ -290,79 +303,79 @@ EmbedGlobalHistory::GetInstance()
   else
     NS_ADDREF(sEmbedGlobalHistory);   // addref the return result
   return sEmbedGlobalHistory;
 }
 
 /* static */
 void
 EmbedGlobalHistory::DeleteInstance()
 {
   if (sEmbedGlobalHistory)
-  {
     delete sEmbedGlobalHistory;
-  }
 }
 
 // The global history component constructor
 EmbedGlobalHistory::EmbedGlobalHistory()
 : mFileHandle(nsnull)
 {
   if (!mURLList) {
     mDataIsLoaded = PR_FALSE;
     mFlushModeFullWriteNeeded = PR_FALSE;
     mEntriesAddedSinceFlush = 0;
     mHistoryFile = nsnull;
     LL_I2L(mExpirationInterval, kDefaultExpirationIntervalDays);
     LL_MUL(mExpirationInterval, mExpirationInterval, kMSecsPerDay);
   }
 }
 
 // The global history component destructor
 EmbedGlobalHistory::~EmbedGlobalHistory()
 {
   LoadData();
-  FlushData(kFlushModeFullWrite);
+  mFlushModeFullWriteNeeded = PR_TRUE;
+  FlushData();
   if (mURLList) {
     g_list_foreach(mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
     g_list_free(mURLList);
     mURLList = NULL;
   }
   if (mFileHandle) {
     CLOSE_FILE_HANDLE(mFileHandle);
   }
   if (mHistoryFile) {
-    g_free(mHistoryFile);
+    NS_Free(mHistoryFile);
     mHistoryFile = nsnull;
   }
   if (sEmbedGlobalHistory)
     sEmbedGlobalHistory = nsnull;
 }
 
 // Initialize the global history component
 NS_IMETHODIMP EmbedGlobalHistory::Init()
 {
-  if (mURLList) return NS_OK;
+  if (mURLList)
+    return NS_OK;
   // Get Pref and convert to millisecs
 
   PRInt32 expireDays;
   int success = gtk_moz_embed_common_get_pref(G_TYPE_INT, EMBED_HISTORY_PREF_EXPIRE_DAYS, &expireDays);
   if (success) {
     LL_I2L(mExpirationInterval, expireDays);
     LL_MUL(mExpirationInterval, mExpirationInterval, kMSecsPerDay);
   }
   // register to observe profile changes
   nsCOMPtr<nsIObserverService> observerService =
     do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
   NS_ASSERTION(observerService, "failed to get observer service");
   if (observerService) {
     observerService->AddObserver(this, "quit-application", PR_FALSE);
-    observerService->AddObserver(this, "RemoveEntries", PR_FALSE);
+    observerService->AddObserver(this, "history-item-removed", PR_FALSE);
   }
   nsresult rv = InitFile();
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
   rv = LoadData();
   NS_ENSURE_SUCCESS(rv, rv);
   return rv;
 }
 
 #define BROKEN_RV_HANDLING_CODE(rv) PR_BEGIN_MACRO                        \
@@ -422,499 +435,669 @@ NS_IMETHODIMP EmbedGlobalHistory::AddURI
   rv |= aURI->SchemeIs("http", &isHTTP);
   rv |= aURI->SchemeIs("https", &isHTTPS);
   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
   // Only get valid uri schemes
   if (!isHTTP && !isHTTPS)
   {
     /* the following blacklist is silly.
      * if there's some need to whitelist http(s) + ftp,
      * that's what we should do.
      */
-    PRBool isAbout, isImap, isNews, isMailbox, isViewSource, isChrome, isData, isJavascript;
+    PRBool isAbout, isImap, isNews, isMailbox, isViewSource, isChrome, isData, isJavascript, isLocal;
     rv  = aURI->SchemeIs("about", &isAbout);
     rv |= aURI->SchemeIs("imap", &isImap);
     rv |= aURI->SchemeIs("news", &isNews);
+    rv |= aURI->SchemeIs("file", &isLocal);
     rv |= aURI->SchemeIs("mailbox", &isMailbox);
     rv |= aURI->SchemeIs("view-source", &isViewSource);
     rv |= aURI->SchemeIs("chrome", &isChrome);
     rv |= aURI->SchemeIs("data", &isData);
     rv |= aURI->SchemeIs("javascript", &isJavascript);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     if (isAbout ||
         isImap ||
         isNews ||
+        isLocal ||
         isMailbox ||
         isViewSource ||
         isChrome ||
         isData ||
         isJavascript) {
       return NS_OK;
     }
   }
-#ifdef DEBUG
-  //  NS_WARNING("[HISTORY] Visited URL: %s\n", aURL);
-#endif
+
   rv = LoadData();
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_FAILED(rv))
+    return rv;
+
   GList *node = g_list_find_custom(mURLList, aURL, (GCompareFunc) history_entry_find_exist);
   HistoryEntry *entry = NULL;
   if (node && node->data)
     entry = (HistoryEntry *)(node->data);
   nsCAutoString hostname;
   aURI->GetHost(hostname);
 
-  // It is not in the history
+  // It is not in the history: add a new entry
   if (!entry) {
     entry = new HistoryEntry;
-    ALLOC_NOT_CHECKED(entry);
-    rv |= OnVisited(entry);
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    rv = OnVisited(entry);
+    if (NS_FAILED(rv)) {
+      NS_Free(entry);
+      return rv;
+    }
+
     SET_TITLE(entry, hostname);
-    rv |= SET_URL(entry, aURL);
-    BROKEN_RV_HANDLING_CODE(rv);
+    rv = SET_URL(entry, aURL);
+    if (NS_FAILED(rv)) {
+      NS_Free(entry);
+      return rv;
+    }
+
     unsigned int listSize = g_list_length(mURLList);
     if (listSize+1 > kDefaultMaxSize) {
       GList *last = g_list_last(mURLList);
       mURLList = g_list_remove(mURLList, last->data);
     }
     mURLList = g_list_insert_sorted(mURLList, entry,
                                     (GCompareFunc) find_insertion_place);
+
     // Flush after kNewEntriesBetweenFlush changes
-    BROKEN_RV_HANDLING_CODE(rv);
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeAppend);
-    // At this point, something understands there's a new global history item
-  } else {
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return rv;
+    }
+  }
+  // It is already in the history: just update the entry
+  else {
     // update the last visited time
-    rv |= OnVisited(entry);
+    rv = OnVisited(entry);
+    if (NS_FAILED(rv))
+      return rv;
+
     SET_TITLE(entry, hostname);
     // Move the element to the start of the list
-    BROKEN_RV_HANDLING_CODE(rv);
     mURLList = g_list_remove(mURLList, entry);
     mURLList = g_list_insert_sorted(mURLList, entry, (GCompareFunc) find_insertion_place);
+
     // Flush after kNewEntriesBetweenFlush changes
-    BROKEN_RV_HANDLING_CODE(rv);
-    
     mFlushModeFullWriteNeeded = PR_TRUE;
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeFullWrite);
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return rv;
+    }
   }
-  return rv;
+  return NS_OK;
 }
 
 // Return TRUE if the url is already in history
 NS_IMETHODIMP EmbedGlobalHistory::IsVisited(nsIURI *aURI, PRBool *_retval)
 {
   NS_ENSURE_ARG(aURI);
   NS_ENSURE_ARG_POINTER(_retval);
   nsCAutoString URISpec;
   aURI->GetSpec(URISpec);
   const char *aURL = URISpec.get();
   nsresult rv = LoadData();
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  // find the element in the history list
   GList *node = g_list_find_custom(mURLList, aURL,
                                    (GCompareFunc) history_entry_find_exist);
   *_retval = (node && node->data);
-  return rv;
+  return NS_OK;
 }
 
 // It is called when Mozilla get real name of a URL
 NS_IMETHODIMP EmbedGlobalHistory::SetPageTitle(nsIURI *aURI,
                                                const nsAString & aTitle)
 {
   NS_ENSURE_ARG(aURI);
   nsresult rv;
   // skip about: URIs to avoid reading in the db (about:blank, especially)
   PRBool isAbout;
   rv = aURI->SchemeIs("about", &isAbout);
   NS_ENSURE_SUCCESS(rv, rv);
   if (isAbout)
     return NS_OK;
+
+  // load the stored history
+  rv = LoadData();
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsCAutoString URISpec;
   aURI->GetSpec(URISpec);
   const char *aURL = URISpec.get();
-  rv |= LoadData();
-  BROKEN_RV_HANDLING_CODE(rv);
-  NS_ENSURE_SUCCESS(rv, rv);
 
+  // find the entry in the history list
   GList *node = g_list_find_custom(mURLList, aURL,
                                    (GCompareFunc) history_entry_find_exist);
   HistoryEntry *entry = NULL;
-  if (node)
-    entry = (HistoryEntry *)(node->data);
-  if (entry) {
+
+  // entry not found
+  if (!node)
+    return NS_ERROR_FAILURE;
+
+  entry = (HistoryEntry *)(node->data);
+
+  // change the entry content
+  if (!entry) {
+    return NS_ERROR_FAILURE;
+  }
+  else {
     SET_TITLE(entry, NS_ConvertUTF16toUTF8(aTitle).get());
-    BROKEN_RV_HANDLING_CODE(rv);
-    
+
+    // flush after kNewEntriesBetweenFlush entries found
     mFlushModeFullWriteNeeded = PR_TRUE;
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeFullWrite);
-    BROKEN_RV_HANDLING_CODE(rv);
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+    }
   }
-  return rv;
+
+  return NS_OK;
 }
 
 nsresult EmbedGlobalHistory::RemoveEntries(const PRUnichar *url, int time)
 {
-  nsresult rv = NS_ERROR_FAILURE;
+  nsresult rv;
+
+  // there is no history list
   if (!mURLList)
-    return rv;
+    return NS_ERROR_FAILURE;
 
+  // the item to be removed is a URL
   if (url) {
     GList *node = g_list_find_custom(mURLList, NS_ConvertUTF16toUTF8(url).get(), (GCompareFunc) history_entry_find_exist);
-    if (!node) return rv;
-    if (node->data) {
-      HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry *,
-                                           node->data);
+    if (!node)
+      return NS_ERROR_FAILURE;
+    if (!(node->data)) {
+      return NS_ERROR_FAILURE;
+    }
+    else {
+      HistoryEntry *entry = static_cast<HistoryEntry *>
+                                           (node->data);
 
       entry->mLastVisitTime = 0;
+      mURLList = g_list_remove_link(mURLList, node);
       delete entry;
-      mURLList = g_list_remove(mURLList, entry);
     }
-  } else {
+  }
+  // the item to be removed is a folder
+  else {
     g_list_foreach (mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
     g_list_free(mURLList);
     mURLList = NULL;
   }
 
+  // flush after kNewEntriesBetweenFlush changes
   mFlushModeFullWriteNeeded = PR_TRUE;
-  mEntriesAddedSinceFlush++;
-  rv = FlushData(kFlushModeFullWrite);
-
-  return rv;
+  if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+    rv = FlushData();
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
 }
 
 //*****************************************************************************
 // EmbedGlobalHistory::nsIObserver
 //*****************************************************************************
 NS_IMETHODIMP EmbedGlobalHistory::Observe(nsISupports *aSubject,
                                           const char *aTopic,
                                           const PRUnichar *aData)
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+
   // used when the browser is closed and the EmbedGlobalHistory destructor is not called
   if (strcmp(aTopic, "quit-application") == 0) {
+    // load the history data to ensure that all the history items stored in the file were properly loaded
     rv = LoadData();
-    // we have to sort the list before flush it
-    rv |= FlushData(kFlushModeFullWrite);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+    // flush the history data
+    rv = FlushData();
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+    // free the history list
     if (mURLList) {
       g_list_foreach(mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
       g_list_free(mURLList);
       mURLList = NULL;
     }
+    // close the history file
     if (mFileHandle) {
       CLOSE_FILE_HANDLE(mFileHandle);
     }
-  } else if (strcmp(aTopic, "RemoveEntries") == 0) {
-    rv |= RemoveEntries(aData, 0);
   }
-  return rv;
+  // used when the user wants to remove a history item
+  else if (strcmp(aTopic, "history-item-removed") == 0) {
+    rv = RemoveEntries(aData, 0);
+    if(NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
 }
 
 static nsresult
 GetHistoryFileName(char **aHistoryFile)
 {
   NS_ENSURE_ARG_POINTER(aHistoryFile);
   // Get the history file in our profile dir.
   // Notice we are not just getting NS_APP_HISTORY_50_FILE
   // because it is used by the "real" global history component.
+  nsCAutoString tempDirString;
+  // there is a profile set
   if (EmbedPrivate::sProfileDir) {
     nsCString path;
     EmbedPrivate::sProfileDir->GetNativePath(path);
-    *aHistoryFile = g_strdup_printf("%s/history.dat", path.get());
-    BROKEN_STRING_BUILDER(aHistoryFile);
-  } else {
-    *aHistoryFile = g_strdup_printf("%s/history.dat", g_get_tmp_dir());
-    BROKEN_STRING_BUILDER(aHistoryFile);
+
+    tempDirString.Assign(path.get());
+  }
+  // there is no profile set
+  else
+  {
+    // get the temporary directory
+    tempDirString.Assign(g_get_tmp_dir());
   }
+  // the history file name
+  tempDirString.Append(NS_LITERAL_CSTRING("/history.txt"));
+  // return the full history path
+  *aHistoryFile = ToNewCString(tempDirString);
+  if (!(*aHistoryFile))
+    return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
 }
+
 //*****************************************************************************
 // EmbedGlobalHistory
 //*****************************************************************************
-// Open/Create the history.dat file if it does not exist
+// Open/Create the history.txt file if it does not exist
 nsresult EmbedGlobalHistory::InitFile()
 {
-  if (!mHistoryFile) {
+  // the history file is not initialized
+  if (!mHistoryFile)
     if (NS_FAILED(GetHistoryFileName(&mHistoryFile)))
       return NS_ERROR_FAILURE;
-  }
 
   LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
   if (!uri)
     return NS_ERROR_FAILURE;
 
   gboolean rs = FALSE;
+  // there is not a history file
   if (!file_handle_uri_exists(uri)) {
+    // create the history file
     if (!file_handle_create_uri(&mFileHandle, uri)) {
-      NS_WARNING("Could not create a history file\n");
+      NS_WARNING("Could not create a history file");
       file_handle_uri_release(uri);
       return NS_ERROR_FAILURE;
     }
+    // close the history file
     CLOSE_FILE_HANDLE(mFileHandle);
   }
+  // open the history file
   rs = file_handle_open_uri(&mFileHandle, uri);
 
   file_handle_uri_release(uri);
 
   if (!rs) {
-    NS_WARNING("Could not open a history file\n");
+    NS_WARNING("Could not open a history file");
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
-// Get the data from history.dat file
+// Get the data from history.txt file
 nsresult EmbedGlobalHistory::LoadData()
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // the data is not loaded
   if (!mDataIsLoaded) {
-    mDataIsLoaded = PR_TRUE;
+    // create the history file handle
     LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
-    if (uri) {
-      rv |= ReadEntries(uri);
+    // could not create a history file handle
+    if (!uri) {
+      return NS_ERROR_FAILURE;
+    }
+    else {
+      rv = ReadEntries(uri);
+      // could not read the history entries
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
       file_handle_uri_release(uri);
     }
+    mDataIsLoaded = PR_TRUE;
   }
-  return rv;
+  return NS_OK;
 }
 
-// Call a function to write each entry in the history hash table
 nsresult EmbedGlobalHistory::WriteEntryIfWritten(GList *list, OUTPUT_STREAM *file_handle)
 {
-  if (!file_handle)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_ARG_POINTER(file_handle);
 
+  // get the history length;
   unsigned int counter = g_list_length(list);
+
+  // for each history entry
   while (counter > 0) {
-    HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry*, g_list_nth_data(list, counter-1));
+    // get a history entry
+    HistoryEntry *entry = static_cast<HistoryEntry*>(g_list_nth_data(list, counter-1));
     counter--;
-    if (!entry || entryHasExpired(entry)) {
+
+    // could not get a history entry
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    // the entry has expired so does not store it in the history file
+    if (entryHasExpired(entry))
       continue;
-    }
+
+    // write the entry in the history file
     writeEntry(file_handle, entry);
   }
   return NS_OK;
 }
 
-// Call a function to write each unwritten entry in the history hash table
 nsresult EmbedGlobalHistory::WriteEntryIfUnwritten(GList *list, OUTPUT_STREAM *file_handle)
 {
-  if (!file_handle)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_ARG_POINTER(file_handle);
+
+  // get the history length;
   unsigned int counter = g_list_length(list);
+
+  // for each history entry
   while (counter > 0) {
-    HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry*, g_list_nth_data(list, counter-1));
-    if (!entry || entryHasExpired(entry)) {
-      counter--;
+    // get a history entry
+    HistoryEntry *entry = static_cast<HistoryEntry*>(g_list_nth_data(list, counter-1));
+    counter--;
+
+    // could not get a history entry
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    // the entry has expired so don't store it in the history file
+    if(entryHasExpired(entry))
       continue;
-    }
+
+    // the entry has not been written
     if (!GetIsWritten(entry))
       writeEntry(file_handle, entry);
-    counter--;
   }
   return NS_OK;
 }
 
-// Write the history in history.dat file
-nsresult EmbedGlobalHistory::FlushData(PRIntn mode)
+nsresult EmbedGlobalHistory::FlushData()
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // there are no history entries to be added
   if (mEntriesAddedSinceFlush == 0)
     return NS_OK;
+
+  // there is no history file handle
   if (!mHistoryFile)
   {
+    // create the history file
     rv = InitFile();
     NS_ENSURE_SUCCESS(rv, rv);
-    rv = FlushData(kFlushModeFullWrite);
-    return rv;
-  }
-  LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
-  if (!uri) return NS_ERROR_FAILURE;
 
-  gboolean rs = file_handle_uri_exists(uri);
-  file_handle_uri_release(uri);
-
-  if (!rs && NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
+    mFlushModeFullWriteNeeded = PR_TRUE;
+    rv = FlushData();
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
 
-  if (mode == kFlushModeFullWrite || mFlushModeFullWriteNeeded == PR_TRUE)
+  if (mFlushModeFullWriteNeeded)
   {
     if (!file_handle_seek(mFileHandle, FALSE))
       return NS_ERROR_FAILURE;
     if (!file_handle_truncate(mFileHandle))
       return NS_ERROR_FAILURE;
     WriteEntryIfWritten(mURLList, mFileHandle);
     mFlushModeFullWriteNeeded = PR_FALSE;
   }
+  // just need to append some entries
   else
   {
+    // go to the end of the history file
     if (!file_handle_seek(mFileHandle, TRUE))
       return NS_ERROR_FAILURE;
     WriteEntryIfUnwritten(mURLList, mFileHandle);
   }
-
   mEntriesAddedSinceFlush = 0;
   return NS_OK;
 }
 
 // Split an entry in last visit time, title and url.
-// Add a stored entry in the history.dat file in the history hash table
-nsresult EmbedGlobalHistory::GetEntry(const char *entry)
+// Add a stored entry in the history.txt file in the history list
+nsresult EmbedGlobalHistory::GetEntry(nsCString& string)
 {
+  char *entry = string.BeginWriting();
+  PRInt32 str_len = string.Length();
   char separator = (char) defaultSeparator;
   int pos = 0;
   nsInt64 outValue = 0;
+  // get the last visit time from the given entry
   while (PR_TRUE) {
     PRInt32 digit;
+    // it is a separator: get the next digit
     if (entry[pos] == separator) {
       pos++;
       break;
     }
-    if (entry[pos] == '\0' || !isdigit(entry[pos]))
+    // it is the end of a word or is not a number
+    if (str_len <= pos || entry[pos] == '\0' || !isdigit(entry[pos]))
       return NS_ERROR_FAILURE;
     digit = entry[pos] - '0';
+    // add the new digit found to the previous ones
     outValue *= nsInt64(10);
     outValue += nsInt64(digit);
     pos++;
   }
-  char url[1024], title[1024];
+  char *url=&entry[pos];
   int urlLength= 0, titleLength= 0, numStrings=1;
-  // get the url and title
+  // get the url and title from the given entry
   // FIXME
   while(PR_TRUE) {
+    if (str_len <= pos) break;
+    // it is a separator: get the next character
     if (entry[pos] == separator) {
       numStrings++;
       pos++;
       continue;
     }
+    // there are no more strings to be found
     if (numStrings > 2)
       break;
-    if (numStrings==1) {
-      url[urlLength++] = entry[pos];
-    } else {
-      title[titleLength++] = entry[pos];
-  }
-  pos++;
+    // it is the first string found: the url
+    if (numStrings == 1)
+      urlLength++;
+    // it is the second string found: the title
+    else
+      titleLength++;
+    pos++;
   }
+  // terminate the strings properly
+  if (!urlLength || !titleLength)
+    return NS_ERROR_FAILURE;
+
   url[urlLength]='\0';
+  char *title=&url[urlLength + 1];
   title[titleLength]='\0';
+
+  // create a new history entry
   HistoryEntry *newEntry = new HistoryEntry;
   if (!newEntry)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // initialize the title of the new entry
   SET_TITLE(newEntry, title);
-  rv |= SetLastVisitTime(newEntry, outValue);
-  rv |= SetIsWritten(newEntry);
-  rv |= SET_URL(newEntry, url);
-  BROKEN_RV_HANDLING_CODE(rv);
-  // Check wheter the entry has expired
-  if (!entryHasExpired(newEntry)) {
+  // initialize the last visit time of the new entry
+  rv = SetLastVisitTime(newEntry, outValue);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+  // initialize the isWritten flag of the new entry: it is in the history file
+  rv = SetIsWritten(newEntry);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+  // initialize the url of the new entry
+  rv = SET_URL(newEntry, url);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  // Check whether the entry has expired and then add it to the history list
+  if (!entryHasExpired(newEntry))
     mURLList = g_list_prepend(mURLList, newEntry);
-  }
-  return rv;
+  return NS_OK;
 }
 
-
-// Get the history entries from history.dat file
+// Get the history entries from history.txt file
 nsresult EmbedGlobalHistory::ReadEntries(LOCAL_FILE *file_uri)
 {
+  // the history file handle has not been initialized
   if (!file_uri)
     return NS_ERROR_FAILURE;
 
   nsresult rv = NS_OK;
-
+  // create an input stream
   nsCOMPtr<nsIInputStream> fileStream;
   NS_NewLocalFileInputStream(getter_AddRefs(fileStream), file_uri);
   if (!fileStream)
     return NS_ERROR_OUT_OF_MEMORY;
   nsCOMPtr<nsILineInputStream> lineStream = do_QueryInterface(fileStream, &rv);
   NS_ASSERTION(lineStream, "File stream is not an nsILineInputStream");
   // Read the header
   nsCString utf8Buffer;
   PRBool moreData = PR_FALSE;
 
   PRInt32 safe_limit = 0;
+  // get the file content line by line
   do {
     rv = lineStream->ReadLine(utf8Buffer, &moreData);
     safe_limit++;
     if (NS_FAILED(rv))
-      return NS_OK;
+      break;
 
+    // go to the next line: might be a blank line in the file
     if (utf8Buffer.IsEmpty())
       continue;
-    rv = GetEntry(utf8Buffer.get());
+
+    // add the entry to the history
+    rv = GetEntry(utf8Buffer);
+    if (NS_FAILED(rv))
+      break;
   } while (moreData && safe_limit < kMaxSafeReadEntriesCount);
+  // close the file stream
   fileStream->Close();
-
   return rv;
 }
 
 //*****************************************************************************
 // Static Functions
 //*****************************************************************************
-// Get last visit time from a string
+// Transform the last visit time from a PRInt64 to a string
 static nsresult writePRInt64(char time[14], const PRInt64& inValue)
 {
   nsInt64 value(inValue);
+  // the inValue is 0, then return a "0" string
   if (value == nsInt64(0)) {
-    strcpy(time, "0");
+    strncpy(time, "0", 1);
     return NS_OK;
   }
   nsCAutoString tempString;
+  // transform the PRInt64 in a nsCAutoString, digit by digit
   while (value != nsInt64(0)) {
     PRInt32 ones = PRInt32(value % nsInt64(10));
     value /= nsInt64(10);
     tempString.Insert(char('0' + ones), 0);
   }
-  strcpy(time,(char *) tempString.get());
+  // transform the nsCAutoString to a string
+  strncpy(time,(char *) tempString.get(), 14);
   return NS_OK;
 }
 
-// Write an entry in the history.dat file
+// Write an entry in the history.txt file
 nsresult writeEntry(OUTPUT_STREAM *file_handle, HistoryEntry *entry)
 {
-  nsresult rv = NS_OK;
-  char sep = (char) defaultSeparator;
+  nsresult rv;
   char time[14];
+  nsCAutoString tempString;
+
+  // get the string equivalent to a PRInt64 value
   writePRInt64(time, GetLastVisitTime(entry));
-  char *line = g_strdup_printf("%s%c%s%c%s%c\n", time, sep, GET_URL(entry), sep, GET_TITLE(entry), sep);
-  BROKEN_STRING_BUILDER(line);
-  guint64 size = file_handle_write(file_handle, (gpointer)line);
-  if (size != strlen(line))
-    rv = NS_ERROR_FAILURE;
-  rv |= SetIsWritten(entry);
-  g_free(line);
-  return rv;
+
+  // add the time string to the entry line
+  tempString.Assign(time);
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the url string to the entry line
+  tempString.Append(GET_URL(entry));
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the title string to the entry line
+  tempString.Append(GET_TITLE(entry));
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the line separator to the entry line
+  tempString.Append("\n");
+
+  // write the new line to the file
+  guint64 size = file_handle_write(file_handle, (gpointer) tempString.get());
+
+  // could not write all the line to the file
+  if (size != tempString.Length())
+    rv = NS_ERROR_OUT_OF_MEMORY;
+  rv = SetIsWritten(entry);
+  if (NS_FAILED(rv))
+    return rv;
+  return NS_OK;
 }
 
-nsresult EmbedGlobalHistory::GetContentList(GtkMozHistoryItem **GtkHI, int *count)
+nsresult EmbedGlobalHistory::GetContentList(GtkMozHistoryItem **aHistoryVector, int *aCounter)
 {
-  if (!mURLList) return NS_ERROR_FAILURE;
+  // the history list has not been initialized
+  if (!mURLList)
+    return NS_ERROR_FAILURE;
 
-  unsigned int num_items = 0;
-  *GtkHI = g_new0(GtkMozHistoryItem, g_list_length(mURLList));
-  UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(*GtkHI);
-  GtkMozHistoryItem * item = (GtkMozHistoryItem *)*GtkHI;
-  while (num_items < g_list_length(mURLList)) {
-    HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry*,
-                                         g_list_nth_data(mURLList, num_items));
+  // create a new history vector
+  *aHistoryVector = g_try_new0(GtkMozHistoryItem, g_list_length(mURLList));
+  if (!(*aHistoryVector))
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  GtkMozHistoryItem * aItem = (GtkMozHistoryItem *)*aHistoryVector;
+  // get the history items one by one
+  while ((uint)*aCounter < g_list_length(mURLList)) {
+    HistoryEntry *entry = static_cast<HistoryEntry*>
+                                         (g_list_nth_data(mURLList, *aCounter));
     // verify if the entry has expired and discard it
-    if (entryHasExpired(entry)) {
+    if (entryHasExpired(entry))
       break;
-    }
+
     glong accessed;
+    // transform the last visit time to a readable value in microsecs
     PRInt64 temp, outValue;
     LL_MUL(outValue, GetLastVisitTime(entry), kOneThousand);
     LL_DIV(temp, outValue, PR_USEC_PER_SEC);
     LL_L2I(accessed, temp);
-    // Set the External history list
-    item[num_items].title = GET_TITLE(entry);
-    BROKEN_STRING_BUILDER(item[num_items].title);
-    item[num_items].url = GET_URL(entry);
-    item[num_items].accessed = accessed;
-    num_items++;
+    // set history vector title value
+    aItem[*aCounter].title = (const char *) GET_TITLE(entry);
+
+    if (!aItem[*aCounter].title)
+      return NS_ERROR_OUT_OF_MEMORY;
+    // set history vector url value
+    aItem[*aCounter].url = (const char *)GET_URL(entry);
+    if (!aItem[*aCounter].url)
+      return NS_ERROR_OUT_OF_MEMORY;
+    // set history vector accessed flag
+    aItem[*aCounter].accessed = accessed;
+    // count one more history item
+    (*aCounter)++;
   }
-  *count = num_items;
   return NS_OK;
 }
-
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedGlobalHistory.h mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedGlobalHistory.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.h	2007-10-03 12:03:14.000000000 +0300
@@ -14,21 +14,21 @@
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Conrad Carlen <ccarlen@netscape.com>
- *   Changes: andre.pedralho@indt.org.br (from original:  mozilla/embedding/lite/nsEmbedGlobalHistory.h)
+ *   Changes: apedralho@gmail.com (from original:  mozilla/embedding/lite/nsEmbedGlobalHistory.h)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
@@ -66,24 +66,20 @@ class EmbedGlobalHistory: public nsIGlob
     static EmbedGlobalHistory* GetInstance();
     static void DeleteInstance();
     NS_IMETHOD        Init();
     nsresult GetContentList(GtkMozHistoryItem**, int *count);
     NS_DECL_ISUPPORTS
     NS_DECL_NSIGLOBALHISTORY2
     NS_DECL_NSIOBSERVER
     nsresult RemoveEntries(const PRUnichar *url = nsnull, int time = 0);
 
     protected:
-    enum {
-        kFlushModeAppend,      /** < Add a new entry in the history file */
-        kFlushModeFullWrite    /** < Rewrite all history file */
-    };
 /** Initiates the history file
   * @return NS_OK on the success.
   */
     nsresult          InitFile();
 /** Loads the history file
   * @return NS_OK on the success.
   */
     nsresult          LoadData();
 /** Writes entries in the history file
   * @param list The internal history list.
@@ -94,35 +90,35 @@ class EmbedGlobalHistory: public nsIGlob
 /** Writes entries in the history file
  * @param list The internal history list.
  * @param handle A Gnome VFS handle.
  * @return NS_OK on the success.
 */
     nsresult          WriteEntryIfUnwritten(GList *list, OUTPUT_STREAM *file_handle);
 /** Writes entries in the history file
   * @param mode How to write in the history file
   * @return NS_OK on the success.
   */
-    nsresult          FlushData(PRIntn mode = kFlushModeFullWrite);
+    nsresult          FlushData();
  /** Remove entries from the URL table
   * @return NS_OK on the success.
   */
     nsresult          ResetData();
 /** Reads the history entries using GnomeVFS
   * @param vfs_handle A Gnome VFS handle.
   * @return NS_OK on the success.
   */
     nsresult          ReadEntries(LOCAL_FILE *file_uri);
 /** Gets a history entry 
   * @param name The history entry name.
   * @return NS_OK if the history entry name was gotten.
   */
-    nsresult          GetEntry(const char *);
+    nsresult          GetEntry(nsCString &string);
     protected:
     OUTPUT_STREAM    *mFileHandle;              /** < The History File handle */
     PRBool            mDataIsLoaded;            /** < If the data is loaded */
     PRBool            mFlushModeFullWriteNeeded;/** < If needs a full flush */
     PRInt32           mEntriesAddedSinceFlush;  /** < Number of entries added since flush */
     gchar*            mHistoryFile;             /** < The history file path */
 };
 // Default maximum history entries
 static const PRUint32 kDefaultMaxSize = 1000;
 #endif
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedGtkTools.h mozilla/embedding/browser/gtk/src/EmbedGtkTools.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedGtkTools.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedGtkTools.h	2007-10-03 12:03:14.000000000 +0300
@@ -57,11 +57,24 @@
 
 GtkWidget*
 GetGtkWidgetForDOMWindow(nsIDOMWindow* aDOMWindow);
 
 GtkWindow*
 GetGtkWindowForDOMWindow(nsIDOMWindow* aDOMWindow);
 
 nsresult
 GetContentViewer(nsIWebBrowser *webBrowser, nsIContentViewer **aViewer);
 
+/* Helper Macros */
+
+#define GLIB_IF_PTR_FUNC_NULL(_ptr, _func) \
+  PR_BEGIN_MACRO                           \
+    if (_ptr) {                            \
+      _func(_ptr);                         \
+      (_ptr) = 0;                          \
+    }                                      \
+  PR_END_MACRO
+
+#define GLIB_SOURCE_IF_REMOVE(_ptr) GLIB_IF_PTR_FUNC_NULL(_ptr, g_source_remove)
+
 #endif /* __EmbedTools_h */
+
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedPasswordMgr.cpp mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedPasswordMgr.cpp	2007-04-17 07:06:11.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -14,23 +14,24 @@
  * License.
  *
  * The Original Code is Mozilla Password Manager.
  *
  * The Initial Developer of the Original Code is
  * Brian Ryner.
  * Portions created by the Initial Developer are Copyright (C) 2003
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
- *   Brian Ryner <bryner@brianryner.com>
- *   romaxa@gmail.com (Modified from original:  mozilla/toolkit/components/passwordmgr/base/nsPasswordManager.cpp)
- *   Antonio Gomes <tonikitoo@gmail.com>
+ *      Brian Ryner <bryner@brianryner.com>
+ * Modified by:
+ *      romaxa@gmail.com (from original:  mozilla/toolkit/components/passwordmgr/base/nsPasswordManager.cpp)
+ *      Antonio Gomes <tonikitoo@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
@@ -103,48 +104,51 @@
 #endif
 #include "nsIPassword.h"
 #include "nsIPasswordInternal.h"
 #include <string.h>
 
 
 static const char kPMPropertiesURL[] = "chrome://passwordmgr/locale/passwordmgr.properties";
 static PRBool sRememberPasswords = PR_FALSE;
 static PRBool sForceAutocompletion = PR_FALSE;
 static PRBool sPrefsInitialized = PR_FALSE;
-static nsIStringBundle* sPMBundle;
-static nsISecretDecoderRing* sDecoderRing;
-static EmbedPasswordMgr* sPasswordManager;
+static nsIStringBundle* sPMBundle = nsnull;
+static nsISecretDecoderRing* sDecoderRing = nsnull;
+static EmbedPasswordMgr* sPasswordManager = nsnull;
+
 class EmbedPasswordMgr::SignonDataEntry
 {
 public:
   nsString userField;
   nsString userValue;
   nsString passField;
   nsString passValue;
   SignonDataEntry* next;
   SignonDataEntry() : next(nsnull) { }
   ~SignonDataEntry() {
     delete next;
+    next = nsnull;
   }
 };
 
 class EmbedPasswordMgr::SignonHashEntry
 {
   // Wraps a pointer to the linked list of SignonDataEntry objects.
   // This allows us to adjust the head of the linked list without a
   // hashtable operation.
 public:
   SignonDataEntry* head;
   SignonHashEntry(SignonDataEntry* aEntry) : head(aEntry) { }
   ~SignonHashEntry()
   {
     delete head;
+    head = nsnull;
   }
 };
 
 class EmbedPasswordMgr::PasswordEntry : public nsIPasswordInternal
 {
 public:
   PasswordEntry(const nsACString& aKey, SignonDataEntry* aData);
   virtual ~PasswordEntry() { }
   NS_DECL_ISUPPORTS
   NS_DECL_NSIPASSWORD
@@ -234,41 +238,45 @@ NS_INTERFACE_MAP_BEGIN(EmbedPasswordMgr)
   NS_INTERFACE_MAP_ENTRY(nsIDOMLoadListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMFocusListener)
   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIPasswordManager)
   NS_INTERFACE_MAP_ENTRY(nsIPromptFactory)
 NS_INTERFACE_MAP_END
 
 EmbedPasswordMgr::EmbedPasswordMgr()
 : mAutoCompletingField(nsnull), mCommonObject(nsnull)
 {
+  if (!sPasswordManager) {
+    sPasswordManager = this;
+    NS_ADDREF(sPasswordManager);   // addref the global
+  }
 }
 
 EmbedPasswordMgr::~EmbedPasswordMgr()
 {
+  sPasswordManager = nsnull;
 }
 
 /* static */
 EmbedPasswordMgr*
 EmbedPasswordMgr::GetInstance()
 {
   if (!sPasswordManager) {
-    sPasswordManager = new EmbedPasswordMgr();
+    EmbedPasswordMgr* pwd = new EmbedPasswordMgr();
     if (!sPasswordManager)
       return nsnull;
-    NS_ADDREF(sPasswordManager);   // addref the global
     if (NS_FAILED(sPasswordManager->Init())) {
       NS_RELEASE(sPasswordManager);
       return nsnull;
     }
   }
-  NS_ADDREF(sPasswordManager);   // addref the return result
+  NS_ADDREF(sPasswordManager);   // addref the global
   return sPasswordManager;
 }
 
 nsresult
 EmbedPasswordMgr::Init()
 {
   mSignonTable.Init();
   mRejectTable.Init();
   mAutoCompleteInputs.Init();
   sPrefsInitialized = PR_TRUE;
@@ -285,28 +293,26 @@ EmbedPasswordMgr::Init()
   branchInternal->AddObserver("forceAutocompletion", this, PR_TRUE);
   // Be a form submit and web progress observer so that we can save and
   // prefill passwords.
   nsCOMPtr<nsIObserverService> obsService = do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
   NS_ASSERTION(obsService, "No observer service");
   obsService->AddObserver(this, NS_FORMSUBMIT_SUBJECT, PR_TRUE);
   nsCOMPtr<nsIWebProgress> progress = do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
   NS_ASSERTION(progress, "No web progress service");
   progress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_DOCUMENT);
   // Now read in the signon file
-  char* signonFile = nsnull;
-  mPrefBranch->GetCharPref("SignonFileName", &signonFile);
+  nsCString signonFile;
+  mPrefBranch->GetCharPref("SignonFileName", getter_Copies(signonFile));
   NS_ASSERTION(signonFile, "Fallback for signon filename not present");
   NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(mSignonFile));
   NS_ENSURE_TRUE(mSignonFile, NS_ERROR_FAILURE);
-  mSignonFile->AppendNative(nsCString(signonFile));
-  nsCString path;
-  mSignonFile->GetNativePath(path);
+  mSignonFile->AppendNative(signonFile);
   ReadPasswords(mSignonFile);
   return NS_OK;
 }
 
 /* static */ PRBool
 EmbedPasswordMgr::SingleSignonEnabled()
 {
   if (!sPrefsInitialized) {
     // Create the PasswordManager service to initialize the prefs and callback
     nsCOMPtr<nsIPasswordManager> manager = do_GetService(NS_PASSWORDMANAGER_CONTRACTID);
@@ -317,53 +323,61 @@ EmbedPasswordMgr::SingleSignonEnabled()
 /* static */ NS_METHOD
 EmbedPasswordMgr::Register(nsIComponentManager* aCompMgr,
                            nsIFile* aPath,
                            const char* aRegistryLocation,
                            const char* aComponentType,
                            const nsModuleComponentInfo* aInfo)
 {
   // By registering in NS_PASSWORDMANAGER_CATEGORY, an instance of the password
   // manager will be created when a password input is added to a form.  We
   // can then register that singleton instance as a form submission observer.
+
   nsresult rv;
   nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
-  char* prevEntry;
+
   catman->AddCategoryEntry(NS_PASSWORDMANAGER_CATEGORY,
                            "MicroB Password Manager",
                            NS_PASSWORDMANAGER_CONTRACTID,
                            PR_TRUE,
                            PR_TRUE,
-                           &prevEntry);
+                           nsnull);
 
   catman->AddCategoryEntry("app-startup",
                            "MicroB Password Manager",
                            NS_PASSWORDMANAGER_CONTRACTID,
                            PR_TRUE,
                            PR_TRUE,
-                           &prevEntry);
+                           nsnull);
 
   return NS_OK;
 }
 
 /* static */ NS_METHOD
 EmbedPasswordMgr::Unregister(nsIComponentManager* aCompMgr,
                              nsIFile* aPath,
                              const char* aRegistryLocation,
                              const nsModuleComponentInfo* aInfo)
 {
+
   nsresult rv;
   nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
+
   catman->DeleteCategoryEntry(NS_PASSWORDMANAGER_CATEGORY,
                               NS_PASSWORDMANAGER_CONTRACTID,
                               PR_TRUE);
+
+  catman->DeleteCategoryEntry("app-startup",
+                              NS_PASSWORDMANAGER_CONTRACTID,
+                              PR_TRUE);
+
   return NS_OK;
 }
 
 /* static */ void
 EmbedPasswordMgr::Shutdown()
 {
   NS_IF_RELEASE(sDecoderRing);
   NS_IF_RELEASE(sPMBundle);
   NS_IF_RELEASE(sPasswordManager);
 }
@@ -380,21 +394,24 @@ EmbedPasswordMgr::AddUser(const nsACStri
     return NS_OK;
   // Check for an existing entry for this host + user
   if (!aHost.IsEmpty()) {
     SignonHashEntry *hashEnt;
     if (mSignonTable.Get(aHost, &hashEnt)) {
       nsString empty;
       SignonDataEntry *entry = nsnull;
       FindPasswordEntryInternal(hashEnt->head, aUser, empty, empty, &entry);
       if (entry) {
         // Just change the password
-        return EncryptDataUCS2(aPassword, entry->passValue);
+        if (NS_FAILED(EncryptDataUCS2(aPassword, entry->passValue)))
+            return NS_ERROR_FAILURE;
+        WritePasswords(mSignonFile);
+        return NS_OK;
       }
     }
   }
   SignonDataEntry* entry = new SignonDataEntry();
   if (NS_FAILED(EncryptDataUCS2(aUser, entry->userValue)) ||
       NS_FAILED(EncryptDataUCS2(aPassword, entry->passValue))) {
     delete entry;
     return NS_ERROR_FAILURE;
   }
   AddSignonData(aHost, entry);
@@ -544,21 +561,21 @@ NS_IMETHODIMP
 EmbedPasswordMgr::IsEqualToLastHostQuery(nsCString& aHost)
 {
   return StringBeginsWith(aHost, mLastHostQuery);
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::BuildArrayEnumerator(const nsACString& aKey,
                                        SignonHashEntry* aEntry,
                                        void* aUserData)
 {
-  nsIMutableArray* array = NS_STATIC_CAST(nsIMutableArray*, aUserData);
+  nsIMutableArray* array = static_cast<nsIMutableArray*>(aUserData);
   for (SignonDataEntry* e = aEntry->head; e; e = e->next)
     array->AppendElement(new PasswordEntry(aKey, e), PR_FALSE);
   return PL_DHASH_NEXT;
 }
 
 NS_IMETHODIMP
 EmbedPasswordMgr::GetEnumerator(nsISimpleEnumerator** aEnumerator)
 {
   // Build an array out of the hashtable
   nsCOMPtr<nsIMutableArray> signonArray =
@@ -566,21 +583,21 @@ EmbedPasswordMgr::GetEnumerator(nsISimpl
   NS_ENSURE_STATE(signonArray);
   mSignonTable.EnumerateRead(BuildArrayEnumerator, signonArray);
   return signonArray->Enumerate(aEnumerator);
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::BuildRejectArrayEnumerator(const nsACString& aKey,
                                              PRInt32 aEntry,
                                              void* aUserData)
 {
-  nsIMutableArray* array = NS_STATIC_CAST(nsIMutableArray*, aUserData);
+  nsIMutableArray* array = static_cast<nsIMutableArray*>(aUserData);
   nsCOMPtr<nsIPassword> passwordEntry = new PasswordEntry(aKey, nsnull);
   //  if (!passwordEntry) {
   //    // XXX handle oom
   //  }
   array->AppendElement(passwordEntry, PR_FALSE);
   return PL_DHASH_NEXT;
 }
 
 NS_IMETHODIMP
 EmbedPasswordMgr::GetRejectEnumerator(nsISimpleEnumerator** aEnumerator)
@@ -615,21 +632,21 @@ struct findEntryContext {EmbedPasswordMg
     usernameFound(aUsernameFound), passwordFound(aPasswordFound),
     matched(PR_FALSE) {}
 };
 
 /* static */
 PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::FindEntryEnumerator(const nsACString& aKey,
                                       SignonHashEntry* aEntry,
                                       void* aUserData)
 {
-  findEntryContext* context = NS_STATIC_CAST(findEntryContext*, aUserData);
+  findEntryContext* context = static_cast<findEntryContext*>(aUserData);
   EmbedPasswordMgr* manager = context->manager;
   nsresult rv;
   SignonDataEntry* entry = nsnull;
   rv = manager->FindPasswordEntryInternal(aEntry->head,
                                           context->username,
                                           context->password,
                                           EmptyString(),
                                           &entry);
   if (NS_SUCCEEDED(rv) && entry) {
     if (NS_SUCCEEDED(DecryptData(entry->userValue, context->usernameFound)) &&
@@ -717,20 +734,31 @@ EmbedPasswordMgr::AddUserFull(const nsAC
   //  }
   entry->userField.Assign(aUserFieldName);
   entry->passField.Assign(aPassFieldName);
   EncryptDataUCS2(aUser, entry->userValue);
   EncryptDataUCS2(aPassword, entry->passValue);
   AddSignonData(aKey, entry);
   WritePasswords(mSignonFile);
   return NS_OK;
 }
 
+NS_IMETHODIMP                                                                                                                                                                                             
+EmbedPasswordMgr::AddUserFull2(const nsACString& aKey,                                                                                                                                                    
+                               const nsAString& aUser,                                                                                                                                                   
+                               const nsAString& aPassword,                                                                                                                                               
+                               const nsAString& aUserFieldName,                                                                                                                                          
+                               const nsAString& aPassFieldName,                                                                                                                                          
+                               const nsACString& aActionURL)                                                                                                                                             
+{
+  return AddUserFull(aKey, aUser, aPassword, aUserFieldName, aPassFieldName);
+}
+
 NS_IMETHODIMP
 EmbedPasswordMgr::ReadPasswords(nsIFile* aPasswordFile)
 {
   nsCOMPtr<nsIInputStream> fileStream;
   NS_NewLocalFileInputStream(getter_AddRefs(fileStream), aPasswordFile);
   if (!fileStream)
     return NS_ERROR_OUT_OF_MEMORY;
   nsCOMPtr<nsILineInputStream> lineStream = do_QueryInterface(fileStream);
   NS_ASSERTION(lineStream, "File stream is not an nsILineInputStream");
   // Read the header
@@ -769,21 +797,23 @@ EmbedPasswordMgr::ReadPasswords(nsIFile*
       realm.Assign(utf8Buffer);
       state = STATE_USERFIELD;
       break;
     case STATE_USERFIELD:
       // Commit any completed entry
       if (entry) {
         // Weed out empty username+password entries from corrupted signon files
         if (entry->userValue.IsEmpty() && entry->passValue.IsEmpty()) {
           NS_WARNING("Discarding empty password entry");
           writeOnFinish = PR_TRUE; // so we won't get this on the next startup
-          delete entry;
+          if (entry)
+            delete entry;
+          entry = nsnull;
         } else {
           AddSignonData(realm, entry);
         }
       }
       // If the line is a ., we've reached the end of this realm's entries.
       if (utf8Buffer.Equals(NS_LITERAL_CSTRING("."))) {
         entry = nsnull;
         state = STATE_REALM;
       } else {
         entry = new SignonDataEntry();
@@ -807,21 +837,23 @@ EmbedPasswordMgr::ReadPasswords(nsIFile*
       state = STATE_PASSVALUE;
       break;
     case STATE_PASSVALUE:
       NS_ASSERTION(entry, "bad state");
       CopyUTF8toUTF16(utf8Buffer, entry->passValue);
       state = STATE_USERFIELD;
       break;
     }
   } while (moreData);
   // Don't leak if the file ended unexpectedly
-  delete entry;
+  if (entry)
+    delete entry;
+  entry = nsnull;
   if (writeOnFinish) {
     fileStream->Close();
     WritePasswords(mSignonFile);
   }
   return NS_OK;
 }
 
 // nsIObserver implementation
 NS_IMETHODIMP
 EmbedPasswordMgr::Observe(nsISupports* aSubject,
@@ -1031,21 +1063,21 @@ EmbedPasswordMgr::OnStateChange(nsIWebPr
       }
     }
     mGlobalUserField = userField;
     mGlobalPassField = passField;
   }
 #endif
 done:
   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(domDoc);
   targ->AddEventListener(
       NS_LITERAL_STRING("unload"),
-      NS_STATIC_CAST(nsIDOMLoadListener*, this),
+      static_cast<nsIDOMLoadListener*>(this),
       PR_FALSE);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedPasswordMgr::OnProgressChange(nsIWebProgress* aWebProgress,
                                    nsIRequest* aRequest,
                                    PRInt32 aCurSelfProgress,
                                    PRInt32 aMaxSelfProgress,
                                    PRInt32 aCurTotalProgress,
@@ -1110,20 +1142,36 @@ EmbedPasswordMgr::Notify(nsIDOMHTMLFormE
   PRUint32 numControls;
   formElement->GetElementCount(&numControls);
   // Count the number of password fields in the form.
   nsCOMPtr<nsIDOMHTMLInputElement> userField;
   nsCOMArray<nsIDOMHTMLInputElement> passFields;
   PRUint32 i, firstPasswordIndex = numControls;
   for (i = 0; i < numControls; ++i) {
     nsCOMPtr<nsIFormControl> control;
     formElement->GetElementAt(i, getter_AddRefs(control));
     PRInt32 ctype = control->GetType();
+
+    if (ctype == NS_FORM_INPUT_FILE) {
+
+      nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aWindow));
+      GtkWidget *parentWidget = GetGtkWidgetForDOMWindow(domWindow);
+      if (parentWidget) {
+
+        gtk_signal_emit(GTK_OBJECT(GTK_MOZ_EMBED(parentWidget)),
+                        moz_embed_signals[FILE_UPLOAD_STARTED]);
+
+        ((EmbedPrivate *) GTK_MOZ_EMBED(parentWidget)->data)->mIsUploading = PR_TRUE;
+        }
+
+      return NS_OK;
+    }
+
     if (ctype == NS_FORM_INPUT_PASSWORD) {
       nsCOMPtr<nsIDOMHTMLInputElement> elem = do_QueryInterface(control);
       passFields.AppendObject(elem);
       if (firstPasswordIndex == numControls)
         firstPasswordIndex = i;
     }
   }
   nsCOMPtr<nsIPrompt> prompt;
   aWindow->GetPrompter(getter_AddRefs(prompt));
   switch (passFields.Count()) {
@@ -1214,21 +1262,21 @@ EmbedPasswordMgr::Notify(nsIDOMHTMLFormE
                          1);
       nsAutoString dialogTitle, neverButtonText, rememberButtonText,
                    notNowButtonText;
       GetLocalizedString(NS_LITERAL_STRING("savePasswordTitle"), dialogTitle);
       GetLocalizedString(NS_LITERAL_STRING("neverForSiteButtonText"),
                          neverButtonText);
       GetLocalizedString(NS_LITERAL_STRING("rememberButtonText"),
                          rememberButtonText);
       GetLocalizedString(NS_LITERAL_STRING("notNowButtonText"),
                          notNowButtonText);
-      PRInt32 selection;
+      PRInt32 selection = GTK_MOZ_EMBED_LOGIN_REMEMBER_FOR_THIS_SITE;
       nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aWindow));
       GtkWidget *parentWidget = GetGtkWidgetForDOMWindow(domWindow);
       if (parentWidget)
         gtk_signal_emit(GTK_OBJECT(GTK_MOZ_EMBED(parentWidget)->common),
                         moz_embed_common_signals[COMMON_REMEMBER_LOGIN], &selection);
       // FIXME These values (0,1,2,3,4) need constant variable.
       if (selection == GTK_MOZ_EMBED_LOGIN_REMEMBER_FOR_THIS_SITE ) {
         SignonDataEntry* entry = new SignonDataEntry();
         entry->userField.Assign(userFieldName);
         entry->passField.Assign(passFieldName);
@@ -1327,22 +1375,24 @@ EmbedPasswordMgr::Notify(nsIDOMHTMLFormE
                       ptUser.get()
                     };
                     GetLocalizedString(NS_LITERAL_STRING("passwordChangeTitle"),
                                        dialogTitle);
                     GetLocalizedString(NS_LITERAL_STRING("passwordChangeText"),
                                        dialogText,
                                        PR_TRUE,
                                        formatArgs,
                                        1);
                     PRInt32 selection;
-                    prompt->ConfirmEx(dialogTitle.get(), dialogText.get(),
-                                      nsIPrompt::STD_YES_NO_BUTTONS,
+                    prompt->ConfirmEx(dialogTitle.get(),
+                                      dialogText.get(),
+                                      (nsIPrompt::BUTTON_TITLE_YES * nsIPrompt::BUTTON_POS_0) +
+                                      (nsIPrompt::BUTTON_TITLE_NO * nsIPrompt::BUTTON_POS_1),
                                       nsnull, nsnull, nsnull, nsnull, nsnull,
                                       &selection);
                     if (selection == 0)
                       changeEntry = entry;
                   }
                 }
                 break;
               }
             }
             if (changeEntry) {
@@ -1398,21 +1448,21 @@ EmbedPasswordMgr::GetPrompt(nsIDOMWindow
   nsCOMPtr<nsIPromptService2> service =
     do_GetService(NS_PROMPTSERVICE_CONTRACTID, &rv);
   if (NS_FAILED(rv))
     return rv;
 
   EmbedSignonPrompt2* wrapper = new EmbedSignonPrompt2(service, aParent);
   if (!wrapper)
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(wrapper);
-  *_retval = NS_STATIC_CAST(nsIAuthPrompt2*, wrapper);
+  *_retval = static_cast<nsIAuthPrompt2*>(wrapper);
   return NS_OK;
 }
 
 
 // nsIDOMLoadListener implementation
 NS_IMETHODIMP
 EmbedPasswordMgr::Load(nsIDOMEvent* aEvent)
 {
   return NS_OK;
 }
@@ -1421,21 +1471,21 @@ NS_IMETHODIMP
 EmbedPasswordMgr::BeforeUnload(nsIDOMEvent* aEvent)
 {
   return NS_OK;
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::RemoveForDOMDocumentEnumerator(nsISupports* aKey,
                                                  PRInt32& aEntry,
                                                  void* aUserData)
 {
-  nsIDOMDocument* domDoc = NS_STATIC_CAST(nsIDOMDocument*, aUserData);
+  nsIDOMDocument* domDoc = static_cast<nsIDOMDocument*>(aUserData);
   nsCOMPtr<nsIDOMHTMLInputElement> element = do_QueryInterface(aKey);
   nsCOMPtr<nsIDOMDocument> elementDoc;
   element->GetOwnerDocument(getter_AddRefs(elementDoc));
   if (elementDoc == domDoc)
     return PL_DHASH_REMOVE;
   return PL_DHASH_NEXT;
 }
 
 NS_IMETHODIMP
 EmbedPasswordMgr::Unload(nsIDOMEvent* aEvent)
@@ -1458,34 +1508,34 @@ NS_IMETHODIMP
 EmbedPasswordMgr::Error(nsIDOMEvent* aEvent)
 {
   return NS_OK;
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::WriteRejectEntryEnumerator(const nsACString& aKey,
                                              PRInt32 aEntry,
                                              void* aUserData)
 {
-  nsIOutputStream* stream = NS_STATIC_CAST(nsIOutputStream*, aUserData);
+  nsIOutputStream* stream = static_cast<nsIOutputStream*>(aUserData);
   PRUint32 bytesWritten;
   nsCAutoString buffer(aKey);
   buffer.Append(NS_LINEBREAK);
   stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
   return PL_DHASH_NEXT;
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::WriteSignonEntryEnumerator(const nsACString& aKey,
                                              SignonHashEntry* aEntry,
                                              void* aUserData)
 {
-  nsIOutputStream* stream = NS_STATIC_CAST(nsIOutputStream*, aUserData);
+  nsIOutputStream* stream = static_cast<nsIOutputStream*>(aUserData);
   PRUint32 bytesWritten;
   nsCAutoString buffer(aKey);
   buffer.Append(NS_LINEBREAK);
   stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
   for (SignonDataEntry* e = aEntry->head; e; e = e->next) {
     NS_ConvertUTF16toUTF8 userField(e->userField);
     userField.Append(NS_LINEBREAK);
     stream->Write(userField.get(), userField.Length(), &bytesWritten);
     buffer.Assign(NS_ConvertUTF16toUTF8(e->userValue));
     buffer.Append(NS_LINEBREAK);
@@ -1655,21 +1705,21 @@ EmbedPasswordMgr::FindPasswordEntryInter
     if (!matched)
       continue;
     if (aUserField.IsEmpty())
       matched = PR_TRUE;
     else
       matched = entry->userField.Equals(aUserField);
     if (matched)
       break;
   }
   if (entry) {
-    *aResult = NS_CONST_CAST(SignonDataEntry*, entry);
+    *aResult = const_cast<SignonDataEntry*>(entry);
     return NS_OK;
   }
   *aResult = nsnull;
   return NS_ERROR_FAILURE;
 }
 
 nsresult
 EmbedPasswordMgr::FillPassword(nsIDOMEvent* aEvent)
 {
   // Try to prefill the password for the just-changed username.
@@ -1721,29 +1771,30 @@ EmbedPasswordMgr::FillPassword(nsIDOMEve
   if (NS_SUCCEEDED(DecryptData(foundEntry->passValue, passValue)))
     passField->SetValue(passValue);
 #endif
   return NS_OK;
 }
 
 void
 EmbedPasswordMgr::AttachToInput(nsIDOMHTMLInputElement* aElement)
 {
   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(aElement);
-  nsIDOMEventListener* listener = NS_STATIC_CAST(nsIDOMFocusListener*, this);
+  nsIDOMEventListener* listener = static_cast<nsIDOMFocusListener*>(this);
   targ->AddEventListener(NS_LITERAL_STRING("blur"), listener, PR_FALSE);
   targ->AddEventListener(NS_LITERAL_STRING("DOMAutoComplete"), listener, PR_FALSE);
   mAutoCompleteInputs.Put(aElement, 1);
 }
 
 PRBool
 EmbedPasswordMgr::GetPasswordRealm(nsIURI* aURI, nsACString& aRealm)
 {
+  NS_ENSURE_TRUE(aURI, PR_FALSE);
   // Note: this _is_ different from getting the uri's prePath!
   // We don't want to include a username or password that's part of the
   // URL in the host key... it will cause lookups to work incorrectly, and will
   // also cause usernames and passwords to be stored in cleartext.
   nsCAutoString buffer;
   aURI->GetScheme(buffer);
   aRealm.Append(buffer);
   aRealm.Append(NS_LITERAL_CSTRING("://"));
   aURI->GetHostPort(buffer);
   if (buffer.IsEmpty()) {
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedPasswordMgr.h mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedPasswordMgr.h	2007-04-17 07:06:11.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.h	2007-10-03 12:03:14.000000000 +0300
@@ -84,21 +84,20 @@ class EmbedPasswordMgr : public nsIPassw
                          public nsIDOMLoadListener,
                          public nsSupportsWeakReference
 {
 public:
   class SignonDataEntry;
   class SignonHashEntry;
   class PasswordEntry;
   EmbedPasswordMgr();
   virtual ~EmbedPasswordMgr();
   static EmbedPasswordMgr* GetInstance();
-  static EmbedPasswordMgr* GetInstance(EmbedPrivate *aOwner);
   nsresult Init();
   static PRBool SingleSignonEnabled();
   static NS_METHOD Register(nsIComponentManager* aCompMgr,
                             nsIFile* aPath,
                             const char* aRegistryLocation,
                             const char* aComponentType,
                             const nsModuleComponentInfo* aInfo);
   static NS_METHOD Unregister(nsIComponentManager* aCompMgr,
                               nsIFile* aPath,
                               const char* aRegistryLocation,
@@ -171,21 +170,20 @@ protected:
                                                                     void* aUserData);
   static void EnsureDecoderRing();
   nsClassHashtable<nsCStringHashKey,SignonHashEntry> mSignonTable;
   nsDataHashtable<nsCStringHashKey,PRInt32> mRejectTable;
   nsDataHashtable<nsISupportsHashKey,PRInt32> mAutoCompleteInputs;
   nsCOMPtr<nsIFile> mSignonFile;
   nsCOMPtr<nsIPrefBranch> mPrefBranch;
   nsIDOMHTMLInputElement* mAutoCompletingField;
   nsIDOMHTMLInputElement* mGlobalUserField;
   nsIDOMHTMLInputElement* mGlobalPassField;
-  SignonHashEntry * mLastSignonHashEntry;
   int lastIndex;
   nsCAutoString mLastHostQuery;
   EmbedCommon* mCommonObject;
 public:
   PRBool mFormAttachCount;
   //  nsAString mLastHostQuery;
 };
 
 /* 1baf3398-f759-4a72-a21f-0abdc9cc9960 */
 #define NS_SINGLE_SIGNON_PROMPT_CID \
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedPrivate.cpp mozilla/embedding/browser/gtk/src/EmbedPrivate.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedPrivate.cpp	2007-05-14 12:11:49.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -33,20 +33,21 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIDocShell.h"
 #include "nsIWebProgress.h"
 #include "nsIWidget.h"
+#include "nsIHTMLDocument.h"
 #include "nsCRT.h"
 #include "nsNetUtil.h"
 #include "nsIWebBrowserStream.h"
 #include "nsIHistoryEntry.h"
 #include "nsIWebBrowserFocus.h"
 #include "nsIDirectoryService.h"
 #include "nsAppDirectoryServiceDefs.h"
 
 // for do_GetInterface
 #include "nsIInterfaceRequestor.h"
@@ -83,21 +84,20 @@
 #include "nsIComponentRegistrar.h"
 
 // all of our local includes
 #include "EmbedPrivate.h"
 #include "EmbedWindow.h"
 #include "EmbedProgress.h"
 #include "EmbedContentListener.h"
 #include "EmbedEventListener.h"
 #include "EmbedWindowCreator.h"
 #include "GtkPromptService.h"
-#include "nsICookiePromptService.h"
 #include "EmbedCertificates.h"
 #include "EmbedDownloadMgr.h"
 #ifdef MOZ_GTKPASSWORD_INTERFACE
 #include "EmbedPasswordMgr.h"
 #endif
 #include "EmbedGlobalHistory.h"
 #include "EmbedFilePicker.h"
 
 #ifdef MOZ_ACCESSIBILITY_ATK
 #include "nsIAccessibilityService.h"
@@ -107,30 +107,47 @@
 #include "nsIDocument.h"
 #include "nsIDOMNSHTMLElement.h"
 #include "nsIDOMNSHTMLInputElement.h"
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMNSHTMLTextAreaElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMNSEditableElement.h"
 #include "nsIDOMNSDocument.h"
 #include "nsIEditingSession.h"
 #include "nsIEditor.h"
-#include "nsIHTMLEditor.h"
+#include "nsIPlaintextEditor.h"
 #include "nsEditorCID.h"
+#include "nsIDOMScreen.h"
 
 #include "nsEmbedCID.h"
+#include "nsWidgetsCID.h"
 
-//#include "nsICache.h"
 #include "nsICacheService.h"
 #include "nsICacheSession.h"
-//#include "nsICacheListener.h"
+
+#include "nsIDOMHTMLFrameElement.h"
+
+//Plugins
+#include "nsplugindefs.h"
+#include "nsIPluginInstance.h"
+#include "nsIDOMNodeList.h"
+#include "nsIPresShell.h"
+#include "nsIContent.h"
+#include "nsIObjectFrame.h"
+#include "nsIDOMHTMLIFrameElement.h"
+
+#include "nsIExtensionManager.h"
+#include "nsICommandLineRunner.h"
+#include "nsICommandManager.h"
+
 static NS_DEFINE_CID(kCacheServiceCID,           NS_CACHESERVICE_CID);
+static NS_DEFINE_CID(kAppShellCID,               NS_APPSHELL_CID);
 static nsICacheService* sCacheService;
 
 static EmbedCommon* sEmbedCommon = nsnull;
 
 /* static */
 EmbedCommon*
 EmbedCommon::GetInstance()
 {
   if (!sEmbedCommon)
   {
@@ -167,44 +184,56 @@ EmbedCommon::Init(void)
 }
 
 PRUint32     EmbedPrivate::sWidgetCount = 0;
 char        *EmbedPrivate::sPath        = nsnull;
 char        *EmbedPrivate::sCompPath    = nsnull;
 nsVoidArray *EmbedPrivate::sWindowList  = nsnull;
 nsILocalFile *EmbedPrivate::sProfileDir  = nsnull;
 nsISupports  *EmbedPrivate::sProfileLock = nsnull;
 GtkWidget   *EmbedPrivate::sOffscreenWindow = 0;
 GtkWidget   *EmbedPrivate::sOffscreenFixed  = 0;
+PRBool       EmbedPrivate::sTermEmbedding = PR_TRUE;
 
 nsIDirectoryServiceProvider *EmbedPrivate::sAppFileLocProvider = nsnull;
 
 GtkMozEmbed*
 EmbedCommon::GetAnyLiveWidget()
 {
   if (!EmbedPrivate::sWidgetCount || !EmbedPrivate::sWindowList)
     return nsnull;
 
   // Get the number of browser windows.
   PRInt32 count = EmbedPrivate::sWindowList->Count();
   // This function doesn't get called very often at all (only when
   // creating a new window) so it's OK to walk the list of open
   // windows.
   //FIXME need to choose right window
   GtkMozEmbed *ret = nsnull;
   for (int i = 0; i < count; i++) {
-    EmbedPrivate *tmpPrivate = NS_STATIC_CAST(EmbedPrivate *,
-                                              EmbedPrivate::sWindowList->ElementAt(i));
+    EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>
+                                              (EmbedPrivate::sWindowList->ElementAt(i));
     ret = tmpPrivate->mOwningWidget;
   }
   return ret;
 }
 
+nsresult
+EmbedCommon::SuspendNative(PRBool aOn) {
+static PRBool suspended = PR_FALSE;
+   if (suspended == aOn)
+     return NS_OK;
+   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
+   NS_ENSURE_TRUE(appShell, NS_ERROR_FAILURE);
+   suspended = aOn;
+   return aOn?appShell->SuspendNative():appShell->ResumeNative();
+}
+
 class GTKEmbedDirectoryProvider : public nsIDirectoryServiceProvider2
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIDIRECTORYSERVICEPROVIDER
   NS_DECL_NSIDIRECTORYSERVICEPROVIDER2
 };
 
 static const GTKEmbedDirectoryProvider kDirectoryProvider;
 
@@ -287,25 +316,27 @@ static const nsModuleComponentInfo defau
     EmbedPasswordMgr::Register,
     EmbedPasswordMgr::Unregister},
 
   {
     EMBED_PASSWORDMANAGER_DESCRIPTION,
     NS_SINGLE_SIGNON_PROMPT_CID,
     "@mozilla.org/wallet/single-sign-on-prompt;1",
     EmbedSignonPromptConstructor
   },
 #endif
+#ifdef NECKO_COOKIES
   { "Prompt Service",
     NS_PROMPTSERVICE_CID,
     NS_COOKIEPROMPTSERVICE_CONTRACTID,
     GtkPromptServiceConstructor
   },
+#endif
   {
     "Prompt Service",
     NS_PROMPTSERVICE_CID,
     "@mozilla.org/embedcomp/prompt-service;1",
     GtkPromptServiceConstructor
   },
   {
     EMBED_CERTIFICATES_DESCRIPTION,
     EMBED_CERTIFICATES_CID,
     NS_TOKENPASSWORDSDIALOG_CONTRACTID,
@@ -395,24 +426,35 @@ EmbedPrivate::EmbedPrivate(void)
   mContentListener  = nsnull;
   mEventListener    = nsnull;
   mChromeMask       = nsIWebBrowserChrome::CHROME_ALL;
   mIsChrome         = PR_FALSE;
   mChromeLoaded     = PR_FALSE;
   mLoadFinished     = PR_TRUE;
   mListenersAttached = PR_FALSE;
   mMozWindowWidget  = 0;
   mIsDestroyed      = PR_FALSE;
   mDoResizeEmbed    = PR_TRUE;
+  mCurVisibleHeight = 1000; // to disable this condition for first time
   mOpenBlock        = PR_FALSE;
   mNeedFav          = PR_TRUE;
+  mPluginSuspended  = PR_TRUE;
+  mIsUploading      = PR_FALSE;
+  mResizeControl    = PR_FALSE;
+
+  gboolean bval = TRUE;
+  // Probably VKB Resize control not required anymore, and we can drop it...
+  if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.resize_control", &bval) && bval)
+    mResizeControl  = PR_TRUE;
 
-  PushStartup();
+  sWidgetCount++;
+  if (sWidgetCount == 1)
+    PushStartup();
   if (!sWindowList) {
     sWindowList = new nsVoidArray();
   }
   sWindowList->AppendElement(this);
 }
 
 EmbedPrivate::~EmbedPrivate()
 {
   sWindowList->RemoveElement(this);
   PopStartup();
@@ -425,29 +467,29 @@ EmbedPrivate::Init(GtkMozEmbed *aOwningW
   if (mOwningWidget)
     return NS_OK;
 
   // hang on with a reference to the owning widget
   mOwningWidget = aOwningWidget;
 
   // Create our embed window, and create an owning reference to it and
   // initialize it.  It is assumed that this window will be destroyed
   // when we go out of scope.
   mWindow = new EmbedWindow();
-  mWindowGuard = NS_STATIC_CAST(nsIWebBrowserChrome *, mWindow);
+  mWindowGuard = static_cast<nsIWebBrowserChrome *>(mWindow);
   mWindow->Init(this);
 
   // Create our progress listener object, make an owning reference,
   // and initialize it.  It is assumed that this progress listener
   // will be destroyed when we go out of scope.
   mProgress = new EmbedProgress();
-  mProgressGuard = NS_STATIC_CAST(nsIWebProgressListener *,
-               mProgress);
+  mProgressGuard = static_cast<nsIWebProgressListener *>
+               (mProgress);
   mProgress->Init(this);
 
   // Create our content listener object, initialize it and attach it.
   // It is assumed that this will be destroyed when we go out of
   // scope.
   mContentListener = new EmbedContentListener();
   mContentListenerGuard = NS_ISUPPORTS_CAST(nsIURIContentListener*, mContentListener);
   mContentListener->Init(this);
 
   // Create our key listener object and initialize it.  It is assumed
@@ -461,21 +503,21 @@ EmbedPrivate::Init(GtkMozEmbed *aOwningW
   static int initialized = PR_FALSE;
   // Set up our window creator (only once)
   if (!initialized) {
     // We set this flag here instead of on success.  If it failed we
     // don't want to keep trying and leaking window creator objects.
     initialized = PR_TRUE;
 
     // create our local object
     EmbedWindowCreator *creator = new EmbedWindowCreator(&mOpenBlock);
     nsCOMPtr<nsIWindowCreator> windowCreator;
-    windowCreator = NS_STATIC_CAST(nsIWindowCreator *, creator);
+    windowCreator = static_cast<nsIWindowCreator *>(creator);
 
     // Attach it via the watcher service
     nsCOMPtr<nsIWindowWatcher> watcher = do_GetService(NS_WINDOWWATCHER_CONTRACTID);
     if (watcher)
       watcher->SetWindowCreator(windowCreator);
   }
   return NS_OK;
 }
 
 nsresult
@@ -524,28 +566,28 @@ EmbedPrivate::Realize(PRBool *aAlreadyRe
   // set ourselves as the parent uri content listener
   nsCOMPtr<nsIURIContentListener> uriListener;
   uriListener = do_QueryInterface(mContentListenerGuard);
   webBrowser->SetParentURIContentListener(uriListener);
 
   // save the window id of the newly created window
   nsCOMPtr<nsIWidget> mozWidget;
   mWindow->mBaseWindow->GetMainWidget(getter_AddRefs(mozWidget));
   // get the native drawing area
   GdkWindow *tmp_window =
-    NS_STATIC_CAST(GdkWindow *,
-      mozWidget->GetNativeData(NS_NATIVE_WINDOW));
+    static_cast<GdkWindow *>
+      (mozWidget->GetNativeData(NS_NATIVE_WINDOW));
   // and, thanks to superwin we actually need the parent of that.
   tmp_window = gdk_window_get_parent(tmp_window);
   // save the widget ID - it should be the mozarea of the window.
   gpointer data = nsnull;
   gdk_window_get_user_data(tmp_window, &data);
-  mMozWindowWidget = NS_STATIC_CAST(GtkWidget *, data);
+  mMozWindowWidget = static_cast<GtkWidget *>(data);
 
   // Apply the current chrome mask
   ApplyChromeMask();
   // Initialize focus for window, help for WINDOWWATCHER Service
   ChildFocusIn();
 
   return NS_OK;
 }
 
 void
@@ -560,73 +602,103 @@ EmbedPrivate::Show(void)
 {
   // Get the nsIWebBrowser object for our embedded window.
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // and set the visibility on the thing
   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(webBrowser);
 
   // XXX hack around problem. probably widget/gtk2 window initialization.
   baseWindow->SetVisibility(PR_FALSE);
-
+  mWindow->mHidden = 0;
   baseWindow->SetVisibility(PR_TRUE);
 }
 
 void
 EmbedPrivate::Hide(void)
 {
   // Get the nsIWebBrowser object for our embedded window.
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // and set the visibility on the thing
   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(webBrowser);
   baseWindow->SetVisibility(PR_FALSE);
 }
 
-#include "nsIDOMScreen.h"
+#define VKB_HEIGHT 150
 void
 EmbedPrivate::Resize(PRUint32 aWidth, PRUint32 aHeight)
 {
-  PRInt32 sub   = 0;
-  PRInt32 diff  = 0;
+// TODO Should be moved in other place or extension
+  PRInt32 X, Y, W, H;
+  mWindow->GetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION | nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER, &X, &Y, &W, &H);
+  PRInt32 height_diff = ABS(H - aHeight);
 
-  if (mDoResizeEmbed){
+  //printf("EmbedPrivate::Resize: mResizeControl:%s\n", mResizeControl?"TRUE":"FALSE");
+  if (aWidth - W != 0 || !mResizeControl)
+  {
+    mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+                           nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+                           0, 0, aWidth, aHeight);
+  }
+  else if ((mDoResizeEmbed && height_diff != VKB_HEIGHT) || aHeight > H || aHeight > mCurVisibleHeight)
+  {
+     mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+                            nsIEmbeddingSiteWindow::DIM_FLAGS_VERTICAL |
+                            nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+                           0, 0, aWidth, aHeight);
+  }
+  else {
+    if (Y < 0) {
+      mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION, 0, 0, nsnull, nsnull);
+      return;
+    }
     EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-    gint x, y, width, height, depth;
-    gdk_window_get_geometry(gtk_widget_get_parent_window(GTK_WIDGET(mOwningWidget)),&x,&y,&width,&height,&depth);
-
-    if (ctx_menu) {
-      if (height < ctx_menu->mFormRect.y + ctx_menu->mFormRect.height) {
-        sub = ctx_menu->mFormRect.y - height + ctx_menu->mFormRect.height;
-        diff = height - aHeight;
+    if (!ctx_menu)
+      return;
+    gint y, height;
+    gdk_window_get_geometry(gtk_widget_get_parent_window(GTK_WIDGET(mOwningWidget)), NULL, &y, NULL, &height, NULL);
+    PRInt32 sub = height - aHeight;
+    gint screen_height = gdk_screen_height();
+    PRInt32 visible_form_height = ctx_menu->mFormRect.height;
+    if (screen_height - ctx_menu->mFormRect.y < ctx_menu->mFormRect.height)
+      visible_form_height = screen_height - ctx_menu->mFormRect.y;
+    if (ctx_menu && visible_form_height <= screen_height - y - height_diff - sub
+        && !(ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_RICHEDIT)
+        ) {
+      PRInt32 diff = height_diff + sub;
+      if (screen_height - diff <= ctx_menu->mFormRect.y + ctx_menu->mFormRect.height) {
+        if (ctx_menu->mFormRect.y - height_diff + y > 0)
+          mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION, 0, -height_diff, nsnull, nsnull);
       }
+    } else {
+      mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+                             nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+                             0, 0, aWidth, aHeight);
     }
   }
-
-  mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
-                          nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
-                          0, 0, aWidth, aHeight);
-
-  if (sub > 0 && diff >= 0){
-    SetScrollTop(sub + diff);
-  }
+  mCurVisibleHeight = aHeight;
+//  mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
+//                         nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
+//                         0, 0, aWidth, aHeight);
 }
 
 void
 EmbedPrivate::Destroy(void)
 {
   // This flag might have been set from
   // EmbedWindow::DestroyBrowserWindow() as well if someone used a
   // window.close() or something or some other script action to close
   // the window.  No harm setting it again.
-  mIsDestroyed = PR_TRUE;
+  // if (mIsDestroyed) // NB#65157 Browser crash on http://moto.allegro.pl/4056_volvo.html?order=t&view=gtext web page
+  //  return;
 
   // Get the nsIWebBrowser object for our embedded window.
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // Release our progress listener
   nsCOMPtr<nsISupportsWeakReference> supportsWeak;
   supportsWeak = do_QueryInterface(mProgressGuard);
   nsCOMPtr<nsIWeakReference> weakRef;
   supportsWeak->GetWeakReference(getter_AddRefs(weakRef));
@@ -643,52 +715,59 @@ EmbedPrivate::Destroy(void)
   // Now that we have removed the listener, release our progress
   // object
   mProgressGuard = nsnull;
   mProgress = nsnull;
 
   // detach our event listeners and release the event receiver
   DetachListeners();
   if (mEventTarget)
     mEventTarget = nsnull;
 
+  mEventListenerGuard = nsnull;
+  mEventListener = nsnull;
+
   // destroy our child window
   mWindow->ReleaseChildren();
 
   // release navigation
   mNavigation = nsnull;
 
   // release session history
   mSessionHistory = nsnull;
 
   mOwningWidget = nsnull;
 
   mMozWindowWidget = 0;
   mNeedFav = PR_TRUE;
+  mIsDestroyed = PR_TRUE;
+  mPluginSuspended = PR_TRUE;
 }
 
 void
 EmbedPrivate::SetURI(const char *aURI)
 {
   mURI.Assign(NS_ConvertUTF8toUTF16(aURI));
 }
 
 void
 EmbedPrivate::LoadCurrentURI(void)
 {
   if (!mURI.IsEmpty()) {
     nsCOMPtr<nsPIDOMWindow> piWin;
     GetPIDOMWindow(getter_AddRefs(piWin));
 
     nsAutoPopupStatePusher popupStatePusher(piWin, openAllowed);
 
+    mWindow->mHidden = 1;
     mNavigation->LoadURI(mURI.get(),                        // URI string
-                         nsIWebNavigation::LOAD_FLAGS_NONE, // Load flags
+                         nsIWebNavigation::LOAD_FLAGS_NONE | // Load flags
+                         nsIWebNavigation::LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP,  // Allow keyword.URL.. functionality
                          nsnull,                            // Referring URI
                          nsnull,                            // Post data
                          nsnull);                           // extra headers
   }
 }
 
 void
 EmbedPrivate::Reload(PRUint32 reloadFlags)
 {
   /* Use the session history if it is available, this
@@ -739,96 +818,159 @@ EmbedPrivate::SetChromeMask(PRUint32 aCh
   } else {
     mDoResizeEmbed = PR_FALSE;
     return;
   }
   mChromeMask = aChromeMask;
 
   ApplyChromeMask();
 }
 
 
+// Embedding is only initialized (and should only be terminated) if this returns
+// NS_OK *AND* !aNeedsRestart. In all other cases, it is not initialized.
+// Only call XRE_TermEmbedding if Embedding is initialized :)
+nsresult EmbedPrivate::LocalInitEmbedding(nsILocalFile *aGREDir, nsILocalFile
+                                          *aBinDir, nsILocalFile
+                                          *aProfileDir,
+                                          PRBool *aNeedsRestart)
+{
+  nsresult rv;
+  *aNeedsRestart = PR_FALSE;
+  if (EmbedPrivate::sProfileDir) {
+    rv = XRE_LockProfileDirectory(EmbedPrivate::sProfileDir,
+                                  &EmbedPrivate::sProfileLock);
+    if (NS_FAILED(rv))
+      return rv;
+  }
+
+  if (sWidgetCount > 1)
+    XRE_NotifyProfile();
+
+  rv = XRE_InitEmbedding(aGREDir,
+                         aBinDir,
+                         const_cast<GTKEmbedDirectoryProvider*>
+                                       (&kDirectoryProvider),
+                         nsnull,
+                         nsnull);
+  if (NS_FAILED(rv))
+    return rv;
+
+  if (aProfileDir) {
+    XRE_NotifyProfile();
+  }
+
+  nsCOMPtr<nsICommandLineRunner>
+    cmdline(do_CreateInstance("@mozilla.org/toolkit/command-line;1", &rv));
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  nsCOMPtr<nsIExtensionManager>
+    extensionManager(do_GetService("@mozilla.org/extensions/manager;1", &rv));
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Fail to initialize extension manager\n");
+    cmdline = nsnull;
+    return rv;
+  }
+
+  extensionManager->Start(cmdline, aNeedsRestart);
+  if (*aNeedsRestart) {
+    extensionManager = nsnull;
+    cmdline = nsnull;
+  }
+  return NS_OK;
+}
+
 /* static */
 void
 EmbedPrivate::PushStartup(void)
 {
-  // increment the number of widgets
-  sWidgetCount++;
+  if (!EmbedPrivate::sTermEmbedding) {
+    NS_WARNING("Multiple PushStartup call\n");
+    return;
+  }
 
-  // if this is the first widget, fire up xpcom
-  if (sWidgetCount == 1) {
-    nsresult rv;
-    nsCOMPtr<nsILocalFile> binDir;
-    nsCOMPtr<nsILocalFile> compDir;
-    if (EmbedPrivate::sCompPath) {
-      rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(binDir));
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsILocalFile> binDir;
+  nsCOMPtr<nsILocalFile> compDir;
+  if (EmbedPrivate::sCompPath) {
+    rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(binDir));
+    if (NS_SUCCEEDED(rv))
       rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(compDir));
-      if (NS_FAILED(rv))
-        return;
+    if (NS_FAILED(rv))
+      return;
+    rv = compDir->AppendNative(nsDependentCString("components"));
+#if 0
       PRBool exists;
-      rv = compDir->AppendNative(nsDependentCString("components"));
       compDir->Exists(&exists);
       if (!exists)
         rv = compDir->Create(nsIFile::DIRECTORY_TYPE, 0700);
       if (NS_FAILED(rv))
         return;
-    } else
-      NS_ASSERTION(EmbedPrivate::sCompPath, "Warning: Failed to init Component Path.\n");
+#endif
+  }
+  NS_ASSERTION(EmbedPrivate::sCompPath, "Warning: Component Path wasn't set.");
+  NS_ASSERTION(NS_SUCCEEDED(rv), "Can't set Component Path.");
 
-    const char *grePath = sPath;
-    NS_ASSERTION(grePath, "Warning: Failed to init grePath.\n");
+  const char *grePath = sPath;
+  if (!grePath) {
+    NS_WARNING("grePath wasn't set, will use fallback.");
+    grePath = getenv("MOZILLA_FIVE_HOME");
+  }
 
-    if (!grePath)
-      grePath = getenv("MOZILLA_FIVE_HOME");
+  if (!grePath)
+    return;
 
-    if (!grePath)
-      return;
+  nsCOMPtr<nsILocalFile> greDir;
+  rv = NS_NewNativeLocalFile(nsDependentCString(grePath), PR_TRUE,
+                             getter_AddRefs(greDir));
+  if (NS_FAILED(rv))
+    return;
 
-    nsCOMPtr<nsILocalFile> greDir;
-    rv = NS_NewNativeLocalFile(nsDependentCString(grePath), PR_TRUE,
-                               getter_AddRefs(greDir));
-    if (NS_FAILED(rv))
-      return;
+  PRBool needsRestart = PR_TRUE;
 
-    rv = XRE_InitEmbedding(greDir, binDir,
-                           NS_CONST_CAST(GTKEmbedDirectoryProvider*,
-                                         &kDirectoryProvider),
-                           nsnull, nsnull);
-    if (NS_FAILED(rv))
+  PRInt32 initCount;
+  for (initCount = 0; initCount < 4 && needsRestart; ++initCount) {
+    rv = LocalInitEmbedding(greDir.get(), binDir.get(), EmbedPrivate::sProfileDir,
+                            &needsRestart);
+    if (NS_FAILED(rv)) {
+      // Embedding isn't initialized!!!
       return;
-
-    if (EmbedPrivate::sProfileDir) {
-      XRE_NotifyProfile();
     }
-
-    rv = RegisterAppComponents();
-    NS_ASSERTION(NS_SUCCEEDED(rv), "Warning: Failed to register app components.\n");
   }
+
+  rv = RegisterComponents(initCount > 1);
+  NS_ASSERTION(NS_SUCCEEDED(rv), "Warning: Failed to register app components.\n");
+  // If this fails, you're probably dead and you should probably term
+  // embedding and mark yourself as dead, but perhaps it isn't critical.
+  EmbedPrivate::sTermEmbedding = PR_FALSE;
 }
 
 /* static */
 void
 EmbedPrivate::PopStartup(void)
 {
   sWidgetCount--;
   if (sWidgetCount == 0) {
     NS_IF_RELEASE(sCacheService);
 
     // destroy the offscreen window
     DestroyOffscreenWindow();
 
     // we no longer need a reference to the DirectoryServiceProvider
     if (EmbedPrivate::sAppFileLocProvider) {
       NS_RELEASE(EmbedPrivate::sAppFileLocProvider);
       EmbedPrivate::sAppFileLocProvider = nsnull;
     }
 
     // shut down XPCOM/Embedding
+    EmbedPrivate::sTermEmbedding = PR_TRUE;
     XRE_TermEmbedding();
 
     EmbedGlobalHistory::DeleteInstance();
   }
 }
 
 /* static */
 void EmbedPrivate::SetPath(const char *aPath)
 {
   if (sPath)
@@ -965,24 +1107,24 @@ EmbedPrivate::FindPrivateForBrowser(nsIW
 {
   if (!sWindowList)
     return nsnull;
 
   // Get the number of browser windows.
   PRInt32 count = sWindowList->Count();
   // This function doesn't get called very often at all (only when
   // creating a new window) so it's OK to walk the list of open
   // windows.
   for (int i = 0; i < count; i++) {
-    EmbedPrivate *tmpPrivate = NS_STATIC_CAST(EmbedPrivate *, sWindowList->ElementAt(i));
+    EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>(sWindowList->ElementAt(i));
     // get the browser object for that window
     nsIWebBrowserChrome *chrome =
-      NS_STATIC_CAST(nsIWebBrowserChrome *, tmpPrivate->mWindow);
+      static_cast<nsIWebBrowserChrome *>(tmpPrivate->mWindow);
     if (chrome == aBrowser)
       return tmpPrivate;
   }
 
   return nsnull;
 }
 
 void
 EmbedPrivate::ContentStateChange(void)
 {
@@ -1039,21 +1181,21 @@ EmbedPrivate::ContentFinishedLoading(voi
   EmbedPasswordMgr *passwordManager = EmbedPasswordMgr::GetInstance();
   if (passwordManager && passwordManager->mFormAttachCount) {
 
     GList *list_full = NULL, *users_list = NULL;
     gint retval = -1;
 
     if (gtk_moz_embed_common_get_logins(NS_ConvertUTF16toUTF8(mURI).get(), &list_full)) {
 
       GList *ptr = list_full;
       while(ptr) {
-        GtkMozLogin * login = NS_STATIC_CAST(GtkMozLogin*, ptr->data);
+        GtkMozLogin * login = static_cast<GtkMozLogin*>(ptr->data);
         if (login && login->user) {
           users_list = g_list_append(users_list, NS_strdup(login->user));
           NS_Free((void*)login->user);
           if (login->pass)
             NS_Free((void*)login->pass);
           if (login->host)
             NS_Free((void*)login->host);
         }
         else
           break;
@@ -1084,21 +1226,23 @@ EmbedPrivate::ChildFocusIn(void)
   nsresult rv;
   nsCOMPtr<nsIWebBrowser> webBrowser;
   rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
   if (NS_FAILED(rv))
     return;
 
   nsCOMPtr<nsIWebBrowserFocus> webBrowserFocus(do_QueryInterface(webBrowser));
   if (!webBrowserFocus)
     return;
 
+  mWindow->EnableFocusEmit(PR_FALSE);
   webBrowserFocus->Activate();
+  mWindow->EnableFocusEmit(PR_TRUE);
 }
 
 void
 EmbedPrivate::ChildFocusOut(void)
 {
   if (mIsDestroyed)
     return;
 
   nsresult rv;
   nsCOMPtr<nsIWebBrowser> webBrowser;
@@ -1132,22 +1276,22 @@ EmbedPrivate::GetListener(void)
 
 // attach key and mouse event listeners
 
 void
 EmbedPrivate::AttachListeners(void)
 {
   if (!mEventTarget || mListenersAttached)
     return;
 
   nsIDOMEventListener *eventListener =
-    NS_STATIC_CAST(nsIDOMEventListener *,
-       NS_STATIC_CAST(nsIDOMKeyListener *, mEventListener));
+    static_cast<nsIDOMEventListener *>
+       (static_cast<nsIDOMKeyListener *>(mEventListener));
 
   // add the key listener
   nsresult rv;
   rv = mEventTarget->AddEventListenerByIID(
          eventListener,
          NS_GET_IID(nsIDOMKeyListener));
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to add key listener\n");
     return;
   }
@@ -1177,38 +1321,40 @@ EmbedPrivate::AttachListeners(void)
   }
   
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mEventTarget));
   if (!target) {
     return;
   }
   
   rv = target->AddEventListener(NS_LITERAL_STRING("focus"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("blur"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("DOMLinkAdded"), eventListener, PR_TRUE);
+  rv = target->AddEventListener(NS_LITERAL_STRING("DOMPopupBlocked"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("load"), eventListener, PR_TRUE);
+  rv = target->AddEventListener(NS_LITERAL_STRING("DOMLinkXSLParsed"), eventListener, PR_TRUE);
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to add Mouse Motion listener\n");
     return;
   }
   // ok, all set.
   mListenersAttached = PR_TRUE;
 }
 
 void
 EmbedPrivate::DetachListeners(void)
 {
   if (!mListenersAttached || !mEventTarget)
     return;
 
   nsIDOMEventListener *eventListener =
-    NS_STATIC_CAST(nsIDOMEventListener *,
-       NS_STATIC_CAST(nsIDOMKeyListener *, mEventListener));
+    static_cast<nsIDOMEventListener *>
+       (static_cast<nsIDOMKeyListener *>(mEventListener));
 
   nsresult rv;
   rv = mEventTarget->RemoveEventListenerByIID(
          eventListener,
          NS_GET_IID(nsIDOMKeyListener));
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to remove key listener\n");
     return;
   }
 
@@ -1238,20 +1384,22 @@ EmbedPrivate::DetachListeners(void)
   }
   
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mEventTarget));
   if (!target) {
     return;
   }
 
   rv = target->RemoveEventListener(NS_LITERAL_STRING("focus"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("blur"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMLinkAdded"), eventListener, PR_TRUE);
+  rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMPopupBlocked"), eventListener, PR_TRUE);
+  rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMLinkXSLParsed"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("load"), eventListener, PR_TRUE);
   mListenersAttached = PR_FALSE;
 }
 
 nsresult
 EmbedPrivate::GetFocusController(nsIFocusController * *controller)
 {
   nsresult rv;
   if (!controller) {
     return NS_ERROR_FAILURE;
@@ -1328,21 +1476,21 @@ EmbedPrivate::GetAtkObjectForCurrentDocu
     void *atkObj = nsnull;
     if (NS_SUCCEEDED(acc->GetNativeInterface(&atkObj)))
       return atkObj;
   }
   return nsnull;
 }
 #endif /* MOZ_ACCESSIBILITY_ATK */
 
 /* static */
 nsresult
-EmbedPrivate::RegisterAppComponents(void)
+EmbedPrivate::RegisterComponents(PRBool aAutoRegister)
 {
   nsCOMPtr<nsIComponentRegistrar> cr;
   nsresult rv = NS_GetComponentRegistrar(getter_AddRefs(cr));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIComponentManager> cm;
   rv = NS_GetComponentManager(getter_AddRefs(cm));
   NS_ENSURE_SUCCESS(rv, rv);
 
   for (int i = 0; i < sNumAppComps; ++i) {
@@ -1359,20 +1507,23 @@ EmbedPrivate::RegisterAppComponents(void
     NS_ASSERTION(NS_SUCCEEDED(rv), "Unable to register factory for component");
 
     // Call the registration hook of the component, if any
     if (sAppComps[i].mRegisterSelfProc) {
       rv = sAppComps[i].mRegisterSelfProc(cm, nsnull, nsnull, nsnull,
                                           &(sAppComps[i]));
       NS_ASSERTION(NS_SUCCEEDED(rv), "Unable to self-register component");
     }
   }
 
+  if (aAutoRegister)
+    cr->AutoRegister(nsnull);
+
   return rv;
 }
 
 /* static */
 void
 EmbedPrivate::EnsureOffscreenWindow(void)
 {
   if (sOffscreenWindow)
     return;
   sOffscreenWindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);
@@ -1406,22 +1557,21 @@ EmbedPrivate::ClipBoardAction(GtkMozEmbe
   if (!clipboard)
     return PR_FALSE;
   switch (type) {
     case GTK_MOZ_EMBED_SELECT_ALL:
     {
       rv = clipboard->SelectAll();
       break;
     }
     case GTK_MOZ_EMBED_CAN_SELECT:
     {
-      //FIXME
-      break;
+      return CanSelect();
     }
     case GTK_MOZ_EMBED_CUT:
     {
       rv = clipboard->CutSelection();
       break;
     }
     case GTK_MOZ_EMBED_COPY:
     {
       rv = clipboard->CopySelection();
       break;
@@ -1498,68 +1648,105 @@ EmbedPrivate::FindText(const char *exp, 
   finder->SetSearchFrames(TRUE); //SearchInFrames
   finder->SetMatchCase(case_sensitive);
   rv = finder->FindNext(&match);
   NS_Free(text);
   if (NS_FAILED(rv))
     return FALSE;
 
   return match;
 }
 
-void
-EmbedPrivate::SetScrollTop(PRUint32 aTop)
-{
-  EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-  if (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_IFRAME){
-    if (ctx_menu) {
-      nsIDOMWindow *ctxDomWindows = ctx_menu->mCtxDomWindow;
-      if (ctxDomWindows)
-      {
-        nsCOMPtr<nsIDOMDocument> domDoc;
-        ctxDomWindows->GetDocument(getter_AddRefs(domDoc));
-        if (domDoc) {
-          ctx_menu->GetElementForScroll(domDoc);
-          if (ctx_menu->mNSHHTMLElementSc)
-            ctx_menu->mNSHHTMLElementSc->SetScrollTop(aTop);
-        }
-      }
-    }
-  } else {
-    nsCOMPtr<nsIDOMWindow> window;
-    nsCOMPtr<nsIWebBrowser> webBrowser;
-    mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
-    webBrowser->GetContentDOMWindow(getter_AddRefs(window));
-    window->ScrollBy(0, aTop);
-  }
-} 
-
 nsresult
 EmbedPrivate::ScrollToSelectedNode(nsIDOMNode *aDOMNode)
 {
   nsresult rv = NS_ERROR_FAILURE;
   if (aDOMNode) {
     nsCOMPtr<nsIDOMNSHTMLElement> nodeElement = do_QueryInterface(aDOMNode, &rv);
     if (NS_SUCCEEDED(rv) && nodeElement) {
       nodeElement->ScrollIntoView(PR_FALSE);
     }
   }
   return rv;
 }
 
 nsresult
-EmbedPrivate::InsertTextToNode(nsIDOMNode *aDOMNode, const char *string)
+EmbedPrivate::GetTextAndCursorPosition(gchar **aString, PRInt32 *aCursorPos)
+{
+  NS_ENSURE_ARG_POINTER(aString);
+  NS_ENSURE_ARG_POINTER(aCursorPos);
+
+  nsresult rv;
+  nsString cString;
+
+  nsCOMPtr<nsIWebBrowser> webBrowser;
+  rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+  if (NS_FAILED(rv))
+    return PR_FALSE;
+
+  nsCOMPtr<nsIWebBrowserFocus> focus(do_GetInterface(webBrowser));
+  if (!focus)
+    return PR_FALSE;
+
+  EmbedContextMenuInfo *ctxInfo;
+  ctxInfo = mEventListener->GetContextInfo();
+
+  nsIDOMElement *domElement;
+  rv = focus->GetFocusedElement(&domElement);
+  if (NS_SUCCEEDED(rv)) {
+    /* if domElement is either an input or text area, get their content and
+       cursor position */
+    if (ctxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
+      if (ctxInfo->mCtxFormType == NS_FORM_TEXTAREA) {
+	nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea = do_QueryInterface(domElement, &rv);
+	if (textArea) {
+          rv = textArea->GetValue(cString);
+          if (NS_FAILED(rv))
+            return PR_FALSE;
+
+          nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaNS = do_QueryInterface(domElement);
+	  if(textAreaNS)
+	    textAreaNS->GetSelectionStart(aCursorPos);
+
+	  *aString = strdup((gchar *)NS_ConvertUTF16toUTF8(cString).get());
+	  //printf("1STRING=%s curpos=%d\n", *aString, (int)*aCursorPos);
+        }
+      } else {
+	nsCOMPtr<nsIDOMHTMLInputElement> inputElement = do_QueryInterface(domElement, &rv);
+        if (inputElement) {
+          rv = inputElement->GetValue(cString);
+          if (NS_FAILED(rv))
+            return PR_FALSE;
+
+          nsCOMPtr<nsIDOMNSHTMLInputElement> inputElementNS = do_QueryInterface(domElement);
+          if(inputElementNS)
+	    inputElementNS->GetSelectionStart(aCursorPos);
+
+	  *aString = strdup((gchar *)NS_ConvertUTF16toUTF8(cString).get());
+	  //printf(">>>>>> 2STRING=%s curpos=%d\n", *aString, (int)*aCursorPos);
+        }
+      }
+    }
+  }
+
+  return PR_TRUE;
+
+}
+
+nsresult
+EmbedPrivate::InsertTextToNode(nsIDOMNode *aDOMNode, const char *string, gint surr1, gint surr2)
 {
   nsIDOMNode *targetNode = nsnull;
   nsresult rv;
 
   EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-  if (ctx_menu && ctx_menu->mEventNode && (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT)) {
+  if (ctx_menu && ctx_menu->mEventNode &&
+     (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT | GTK_MOZ_EMBED_CTX_XUL)) {
     targetNode = ctx_menu->mEventNode;
   }
 
   if (!targetNode)
     return NS_ERROR_FAILURE;
 
   nsString nodeName;
   targetNode->GetNodeName(nodeName);
   PRInt32 selectionStart = 0, selectionEnd = 0, textLength = 0;
   nsString buffer;
@@ -1570,117 +1757,212 @@ EmbedPrivate::InsertTextToNode(nsIDOMNod
     NS_ENSURE_SUCCESS(rv, rv);
     PRBool rdonly = PR_FALSE;
     input->GetReadOnly(&rdonly);
     if (rdonly)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNSHTMLTextAreaElement> nsinput;
     nsinput = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsinput->GetTextLength(&textLength);
+    nsString utfstring = NS_ConvertUTF8toUTF16(string);
     if (textLength > 0) {
       NS_ENSURE_SUCCESS(rv, rv);
       rv = input->GetValue(buffer);
       nsinput->GetSelectionStart(&selectionStart);
       nsinput->GetSelectionEnd(&selectionEnd);
 
       if (selectionStart != selectionEnd)
         buffer.Cut(selectionStart, selectionEnd - selectionStart);
-      buffer.Insert(NS_ConvertUTF8toUTF16(string), selectionStart);
-    } else {
-      buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    }
+      if (surr1 != 0 || surr2 != 0) {
+        /* next 2 strings: use cursor position (selectionStart) instead of textLength */
+        buffer.Cut(selectionStart + surr1, surr2);
+        buffer.Insert(utfstring, selectionStart + surr1);
+      } else
+        buffer.Insert(utfstring, selectionStart);
+    } else
+        buffer.Assign(utfstring);
 
     input->SetValue(buffer);
-    int len = strlen(string);
+    int len = utfstring.Length();
     nsinput->SetSelectionRange(selectionStart + len, selectionStart + len);
+
+    nsCOMPtr<nsIDOMNSEditableElement> nseditable;
+    nseditable = do_QueryInterface(targetNode, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIEditor> theEditor;
+    nseditable->GetEditor(getter_AddRefs(theEditor));
+    NS_ENSURE_TRUE(theEditor, NS_OK);
+    
+    nsCOMPtr<nsISelectionController> selectionController;
+    theEditor->GetSelectionController(getter_AddRefs(selectionController));
+    PRBool sync = PR_TRUE;
+    short selectionType = nsISelectionController::SELECTION_NORMAL;
+    selectionController->ScrollSelectionIntoView(selectionType, selectionType, sync);
   }
   else if (ctx_menu->mCtxFormType) {
     nsCOMPtr<nsIDOMHTMLInputElement> input;
     input = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     PRBool rdonly = PR_FALSE;
     input->GetReadOnly(&rdonly);
     if (rdonly)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNSHTMLInputElement> nsinput;
     nsinput = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsinput->GetTextLength(&textLength);
-
+    nsString utfstring = NS_ConvertUTF8toUTF16(string);
     if (textLength > 0) {
       NS_ENSURE_SUCCESS(rv, rv);
       rv = input->GetValue(buffer);
       nsinput->GetSelectionStart(&selectionStart);
       nsinput->GetSelectionEnd(&selectionEnd);
 
       if (selectionStart != selectionEnd) {
         buffer.Cut(selectionStart, selectionEnd - selectionStart);
       }
-      buffer.Insert(NS_ConvertUTF8toUTF16(string), selectionStart);
-    } else {
-      buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    }
+      if (surr1 != 0 || surr2 != 0) {
+        /* next 2 strings: use cursor position (selectionStart) instead of textLength */
+        buffer.Cut(selectionStart + surr1, surr2);
+        buffer.Insert(utfstring, selectionStart + surr1);
+      } else
+        buffer.Insert(utfstring, selectionStart);
+    } else
+        buffer.Assign(utfstring);
 
     input->SetValue(buffer);
-    int len = strlen(string);
+    int len = utfstring.Length();
     nsinput->SetSelectionRange(selectionStart + len, selectionStart + len);
+
+    nsCOMPtr<nsIDOMNSEditableElement> nseditable;
+    nseditable = do_QueryInterface(targetNode, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIEditor> theEditor;
+    nseditable->GetEditor(getter_AddRefs(theEditor));
+    NS_ENSURE_TRUE(theEditor, NS_OK);
+    
+    nsCOMPtr<nsISelectionController> selectionController;
+    theEditor->GetSelectionController(getter_AddRefs(selectionController));
+    PRBool sync = PR_TRUE;
+    short selectionType = nsISelectionController::SELECTION_NORMAL;
+    selectionController->ScrollSelectionIntoView(selectionType, selectionType, sync);
   }
   else {
     nsIWebBrowser *retval = nsnull;
     mWindow->GetWebBrowser(&retval);
     nsCOMPtr<nsIEditingSession> editingSession = do_GetInterface(retval);
     if (!editingSession)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIEditor> theEditor;
     nsCOMPtr<nsPIDOMWindow> piWin;
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(ctx_menu->mCtxDocument);
     if (!doc)
       return NS_OK;
     piWin = doc->GetWindow();
     editingSession->GetEditorForWindow(piWin, getter_AddRefs(theEditor));
     if (!theEditor) {
       return NS_ERROR_FAILURE;
     }
 
-    nsCOMPtr<nsIHTMLEditor> htmlEditor;
-    htmlEditor = do_QueryInterface(theEditor, &rv);
-    if (!htmlEditor)
+    nsCOMPtr<nsIPlaintextEditor> textEditor;
+    textEditor = do_QueryInterface(theEditor, &rv);
+    if (NS_FAILED(rv) || !textEditor)
       return NS_ERROR_FAILURE;
     buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    htmlEditor->InsertHTML(buffer);
+    if (surr1 != 0 || surr2 != 0) {
+      DoCommand("cmd_delete", surr2, aDOMNode);
+    }
+    textEditor->InsertText(buffer);
   }
   return NS_OK;
 }
 
 nsresult
+EmbedPrivate::DoCommand(const char *aCommand, PRInt32 aCount, nsIDOMNode *aDOMNode)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+  nsCOMPtr<nsIDOMWindow> DOMWindow;
+  if (aDOMNode) {
+    rv = GetDOMWindowByNode(aDOMNode, getter_AddRefs(DOMWindow));
+  } else {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
+
+  }
+  nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(DOMWindow));
+  NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
+  
+  nsCOMPtr<nsICommandManager> cmdMgr(do_GetInterface(window->GetDocShell()));
+  NS_ENSURE_TRUE(cmdMgr, NS_ERROR_FAILURE);
+
+  if (!aCount) {
+      PRBool enabled = PR_FALSE;
+      rv = cmdMgr->IsCommandEnabled(aCommand, DOMWindow, &enabled);
+      if (enabled)
+        return NS_OK;
+      return NS_ERROR_FAILURE;
+  }
+  for (int i = 0; i < aCount && NS_SUCCEEDED(rv); i++) {
+    rv = cmdMgr->DoCommand(aCommand, nsnull, DOMWindow);
+  }
+  return rv;
+}
+
+nsresult
 EmbedPrivate::GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow)
 {
   nsresult rv;
   nsCOMPtr<nsIDOMDocument> nodeDoc;
   rv = aNode->GetOwnerDocument(getter_AddRefs(nodeDoc));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMDocumentView> docView = do_QueryInterface(nodeDoc, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMAbstractView> absView;
   NS_ENSURE_SUCCESS(rv, rv);
   rv = docView->GetDefaultView(getter_AddRefs(absView));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(absView, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   *aDOMWindow = window;
   NS_IF_ADDREF(*aDOMWindow);
   return rv;
 }
 
+static nsresult
+GetMarkupViewerByWindow(nsIDOMWindow *aDOMWindow,
+                        nsIMarkupDocumentViewer * *aMarkupDocViewver)
+{
+  nsresult rv;
+  NS_ENSURE_ARG_POINTER(aMarkupDocViewver);
+  nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aDOMWindow, &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsIDocShell *docShell = nsnull;
+  if (window)
+    docShell = window->GetDocShell();
+  NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
+  nsCOMPtr<nsIContentViewer> contentViewer;
+  rv = docShell->GetContentViewer(getter_AddRefs(contentViewer));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer, &rv));
+  NS_ENSURE_TRUE(markupViewer, NS_ERROR_FAILURE);
+  *aMarkupDocViewver = markupViewer;
+  NS_IF_ADDREF(*aMarkupDocViewver);
+  return rv;
+}
+
 nsresult
 EmbedPrivate::GetZoom(PRInt32 *aZoomLevel, nsISupports *aContext)
 {
 
   NS_ENSURE_ARG_POINTER(aZoomLevel);
 
   nsresult rv;
   *aZoomLevel = 100;
 
   nsCOMPtr<nsIDOMWindow> DOMWindow;
@@ -1691,23 +1973,31 @@ EmbedPrivate::GetZoom(PRInt32 *aZoomLeve
     rv = GetDOMWindowByNode(node, getter_AddRefs(DOMWindow));
   } else {
     nsCOMPtr<nsIWebBrowser> webBrowser;
     rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  float zoomLevelFloat;
-  if (DOMWindow)
-    rv = DOMWindow->GetTextZoom(&zoomLevelFloat);
+  float zoomLevelFloat = 100;
+  if (DOMWindow) {
+    nsCOMPtr<nsIMarkupDocumentViewer> markupViewer;
+    rv = GetMarkupViewerByWindow(DOMWindow, getter_AddRefs(markupViewer));
+    NS_ENSURE_SUCCESS(rv, rv);
+    gboolean bval = FALSE;
+    if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.textzoom", &bval) && bval)
+      rv = markupViewer->GetTextZoom(&zoomLevelFloat);
+    else
+      rv = markupViewer->GetFullZoom(&zoomLevelFloat);
+  }
   NS_ENSURE_SUCCESS(rv, rv);
 
   *aZoomLevel = (int)round(zoomLevelFloat * 100.);
   return rv;
 }
 nsresult
 EmbedPrivate::SetZoom(PRInt32 aZoomLevel, nsISupports *aContext)
 {
   nsresult rv;
   nsCOMPtr<nsIDOMWindow> DOMWindow;
@@ -1722,23 +2012,33 @@ EmbedPrivate::SetZoom(PRInt32 aZoomLevel
     rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   float zoomLevelFloat;
   zoomLevelFloat = (float) aZoomLevel / 100.;
 
-  if (DOMWindow)
-    rv = DOMWindow->SetTextZoom(zoomLevelFloat);
-
+  if (DOMWindow) {
+    nsCOMPtr<nsIMarkupDocumentViewer> markupViewer;
+    rv = GetMarkupViewerByWindow(DOMWindow, getter_AddRefs(markupViewer));
+    NS_ENSURE_SUCCESS(rv, rv);
+    gboolean bval = FALSE;
+    if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.textzoom", &bval) && bval)
+      rv = markupViewer->SetTextZoom(zoomLevelFloat);
+    else
+      rv = markupViewer->SetFullZoom(zoomLevelFloat);
+    gtk_widget_queue_draw(GTK_WIDGET(mOwningWidget));
+  }
+  //update   
+  mWindow->mBaseWindow->SetPosition(0, 0);
   return rv;
 }
 
 nsresult
 EmbedPrivate::HasFrames  (PRUint32 *numberOfFrames)
 {
   // setting default value.
   *numberOfFrames = 0;
   nsCOMPtr<nsIWebBrowser> webBrowser;
   nsresult rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
@@ -1887,10 +2187,216 @@ EmbedPrivate::GetSHistoryList(GtkMozHist
      item[numItems].accessed = 0;
 
      if (type == GTK_MOZ_EMBED_BACK_SHISTORY)
        navIndex--;
      else if (type == GTK_MOZ_EMBED_FORWARD_SHISTORY)
        navIndex++;
    }
    *count = maxItems;
    return NS_OK;
 }
+
+PRBool
+EmbedPrivate::CanSelect()
+{
+  nsCOMPtr<nsIWebBrowser> webBrowser;
+  nsresult rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  nsCOMPtr<nsIWebBrowserFocus> focus = do_QueryInterface(webBrowser, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  EmbedContextMenuInfo *ctxInfo;
+  ctxInfo = mEventListener->GetContextInfo();
+  if (!ctxInfo)
+    return PR_TRUE;
+
+  nsCOMPtr<nsIDOMElement> domElement;
+  rv = focus->GetFocusedElement(getter_AddRefs(domElement));
+  if (NS_SUCCEEDED(rv)) {
+    /* if domElement is either an input or text area, get their length to
+       check if there is anything to select */
+    if (ctxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
+      PRInt32 textLength;
+      if (ctxInfo->mCtxFormType == NS_FORM_TEXTAREA) {
+        nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(domElement, &rv);
+        NS_ENSURE_SUCCESS(rv, PR_TRUE);
+        textArea->GetTextLength(&textLength);
+        if (textLength == 0)
+          return PR_FALSE;
+      } else {
+        nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(domElement, &rv);
+        NS_ENSURE_SUCCESS(rv, PR_TRUE);
+        input->GetTextLength(&textLength);
+        if (textLength == 0)
+          return PR_FALSE;
+      }
+    }
+    return PR_TRUE;
+  }
+
+  nsCOMPtr<nsIDOMWindow> domWindow;
+  rv = focus->GetFocusedWindow(getter_AddRefs(domWindow));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+  
+  nsCOMPtr<nsIDOMDocument> domDoc;
+  rv = domWindow->GetDocument(getter_AddRefs(domDoc));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+  
+  /* checks if focused document is a frameset */
+  nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(domDoc, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+  if (htmlDoc->GetIsFrameset())
+    return PR_FALSE;
+
+  return PR_TRUE;
+}
+
+nsresult
+EmbedPrivate::NotifyPlugins(PRUint16 aEvent, nsIDOMWindow* aDomWindow)
+{
+  nsCOMPtr<nsIDOMDocument> domDoc;
+
+  if (!aDomWindow) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    if (!webBrowser) return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIDOMWindow> domWin;
+    webBrowser->GetContentDOMWindow(getter_AddRefs(domWin));
+    if (!domWin) return NS_ERROR_FAILURE;
+
+    domWin->GetDocument(getter_AddRefs(domDoc));
+    if (!domDoc)
+      return NS_ERROR_FAILURE;
+  }
+  else {
+    aDomWindow->GetDocument(getter_AddRefs(domDoc));
+    if (!domDoc)
+      return NS_ERROR_FAILURE;
+  }
+
+  EnumeratePlugins(domDoc, NS_LITERAL_STRING("object"),  aEvent);
+  EnumeratePlugins(domDoc, NS_LITERAL_STRING("embed"),  aEvent);
+  EnumerateFrames(domDoc, aEvent);
+}
+
+nsresult
+EmbedPrivate::EnumerateFrames(nsIDOMDocument* aDomDoc, PRUint16 aEvent)
+{
+  nsresult rv;
+
+  PRUint32 iframeLength;
+  PRUint32 frameLength;
+
+  nsCOMPtr<nsIDOMNodeList> iframeList;
+  nsCOMPtr<nsIDOMDocument> iframeDoc;
+  nsCOMPtr<nsIDOMNodeList> frameList;
+  nsCOMPtr<nsIDOMDocument> frameDoc;
+
+  rv = aDomDoc->GetElementsByTagName (NS_LITERAL_STRING("iframe"),
+                                     getter_AddRefs(iframeList));
+  if (iframeList) {
+    rv = iframeList->GetLength(&iframeLength);
+    nsCOMPtr<nsIDOMNode> node;
+    for (PRUint32 i = 0; i < iframeLength; i++) {
+      rv = iframeList->Item(i, getter_AddRefs(node));
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      nsCOMPtr<nsIDOMHTMLIFrameElement> element = do_QueryInterface(node, &rv);
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      element->GetContentDocument(getter_AddRefs(iframeDoc));
+      if (!iframeDoc)
+        return NS_ERROR_FAILURE;
+
+      EnumeratePlugins(iframeDoc, NS_LITERAL_STRING("object"), aEvent);
+      EnumeratePlugins(iframeDoc, NS_LITERAL_STRING("embed"), aEvent);
+      EnumerateFrames(iframeDoc, aEvent);
+    }
+  }
+
+  // Now try to get the plugin instance in frame
+  rv = aDomDoc->GetElementsByTagName (NS_LITERAL_STRING("frame"),
+                                    getter_AddRefs(frameList));
+  if (frameList) {
+    rv = frameList->GetLength(&frameLength);
+    nsCOMPtr<nsIDOMNode> node;
+    for (PRUint32 i = 0; i < frameLength; i++) {
+      rv = frameList->Item(i, getter_AddRefs(node));
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      nsCOMPtr<nsIDOMHTMLFrameElement> element = do_QueryInterface(node, &rv);
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      element->GetContentDocument(getter_AddRefs(frameDoc));
+      if (!frameDoc)
+        return NS_ERROR_FAILURE;
+
+      EnumeratePlugins(frameDoc, NS_LITERAL_STRING("object"), aEvent);
+      EnumeratePlugins(frameDoc, NS_LITERAL_STRING("embed"), aEvent);
+      EnumerateFrames(frameDoc, aEvent);
+    }
+  }
+}
+
+nsresult
+EmbedPrivate::EnumeratePlugins(nsIDOMDocument* aDomDoc, const nsAString& aPluginTag, PRUint16 aEvent)
+{
+  nsresult rv;
+
+  PRUint32 length;
+  nsCOMPtr<nsIDocument> iDoc = do_QueryInterface(aDomDoc);
+  if (!iDoc)
+    return NS_ERROR_FAILURE;
+  nsIPresShell* presShell = iDoc->GetPrimaryShell();
+  if (!presShell)
+    return NS_ERROR_FAILURE;
+
+  PRBool handled;
+  nsPluginEvent pluginEvent;
+  pluginEvent.event.type = aEvent;
+
+  nsCOMPtr<nsIDOMNodeList> list;
+  rv = aDomDoc->GetElementsByTagName(aPluginTag, getter_AddRefs(list));
+  if (!list)
+    return NS_ERROR_FAILURE;
+
+  rv = list->GetLength(&length);
+  nsCOMPtr<nsIDOMNode> node;
+  for (PRUint32 i = 0; i < length; i++) {
+    rv = list->Item(i,getter_AddRefs(node));
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIDOMHTMLElement> element = do_QueryInterface(node, &rv);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIContent> iContent = do_QueryInterface(element, &rv);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsIFrame* frame = nsnull;
+    frame = presShell->GetPrimaryFrameFor(iContent);
+
+    nsIObjectFrame* objectFrame = nsnull;
+    if (frame)
+      CallQueryInterface(frame,&objectFrame);
+    if (!objectFrame)
+      continue;
+
+    nsCOMPtr<nsIPluginInstance> instance;
+    objectFrame->GetPluginInstance(*getter_AddRefs(instance));
+
+    if (!instance)
+      continue;
+    instance->HandleEvent(&pluginEvent,&handled);
+    if (!handled)
+      return NS_ERROR_FAILURE;
+  }
+}
+
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedPrivate.h mozilla/embedding/browser/gtk/src/EmbedPrivate.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedPrivate.h	2007-05-14 12:11:49.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.h	2007-10-03 12:03:15.000000000 +0300
@@ -84,20 +84,21 @@ class nsIDirectoryServiceProvider;
 
 class EmbedCommon {
  public:
   EmbedCommon() {
   }
   ~EmbedCommon() { }
   static EmbedCommon* GetInstance();
   static void DeleteInstance();
   nsresult    Init(void);
   GtkObject   *mCommon;
+  static nsresult SuspendNative(PRBool aOn);
   static GtkMozEmbed* GetAnyLiveWidget();
 };
 class EmbedPrivate {
 
  public:
 
   EmbedPrivate();
   ~EmbedPrivate();
 
   nsresult    Init            (GtkMozEmbed *aOwningWidget);
@@ -109,20 +110,24 @@ class EmbedPrivate {
   void        Destroy         (void);
   void        SetURI          (const char *aURI);
   void        LoadCurrentURI  (void);
   void        Reload          (PRUint32 reloadFlags);
 
   void        SetChromeMask   (PRUint32 chromeMask);
   void        ApplyChromeMask ();
 
   static void PushStartup     (void);
   static void PopStartup      (void);
+  static nsresult LocalInitEmbedding(nsILocalFile *aGREDir,
+                                     nsILocalFile *aBinDir,
+                                     nsILocalFile *aProfileDir,
+                                     PRBool *aNeedsRestart);
   static void SetPath         (const char *aPath);
   static void SetCompPath     (const char *aPath);
 
   static void SetAppComponents (const nsModuleComponentInfo* aComps,
                                 int aNumComponents);
   static void SetProfilePath  (const char *aDir, const char *aName);
   static void SetDirectoryServiceProvider (nsIDirectoryServiceProvider * appFileLocProvider);
 
   nsresult OpenStream         (const char *aBaseURI, const char *aContentType);
   nsresult AppendToStream     (const PRUint8 *aData, PRUint32 aLen);
@@ -146,37 +151,39 @@ class EmbedPrivate {
   // these are when the widget itself gets focus in and focus out
   // events
   void        ChildFocusIn (void);
   void        ChildFocusOut(void);
   PRBool      ClipBoardAction(GtkMozEmbedClipboard type);
   char*       GetEncoding ();
   nsresult    SetEncoding (const char *encoding);
   PRBool      FindText(const char *exp, PRBool  reverse,
                        PRBool  whole_word, PRBool  case_sensitive,
                        PRBool  restart);
-  void        SetScrollTop(PRUint32 aTop);
-  nsresult    ScrollToSelectedNode(nsIDOMNode *aDOMNode);
-  nsresult    InsertTextToNode(nsIDOMNode *aDOMNode, const char *string);
+  nsresult    InsertTextToNode(nsIDOMNode *aDOMNode, const char *string, gint surr1 = 0, gint surr2 = 0);
   nsresult    GetFocusController(nsIFocusController **controller);
-  nsresult    GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow);
+  nsresult    DoCommand(const char *aCommand, PRInt32 aCount = 1, nsIDOMNode *aDOMNode = nsnull);
   nsresult    GetZoom(PRInt32 *aZoomLevel, nsISupports *aContext = nsnull);
   nsresult    SetZoom(PRInt32 aZoomLevel, nsISupports *aContext = nsnull);
   nsresult    HasFrames(PRUint32 *numberOfFrames);
   nsresult    GetMIMEInfo(const char **aMime, nsIDOMNode *aDOMNode = nsnull);
   nsresult    GetCacheEntry(const char *aStorage,
                             const char *aKeyName,
                             PRUint32 aAccess,
                             PRBool aIsBlocking,
                             nsICacheEntryDescriptor **aDescriptor);
   nsresult    GetSHistoryList(GtkMozHistoryItem **GtkHI,
                                GtkMozEmbedSessionHistory type, gint *count);
+  nsresult    GetTextAndCursorPosition(gchar **aString, PRInt32 *aCursorPos);
+  nsresult    NotifyPlugins(PRUint16 aEvent, nsIDOMWindow* aDomWin = nsnull);
 
+  static nsresult    ScrollToSelectedNode(nsIDOMNode *aDOMNode);
+  static nsresult    GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow);
 
 #ifdef MOZ_ACCESSIBILITY_ATK
   void *GetAtkObjectForCurrentDocument();
 #endif
 
   GtkMozEmbed                   *mOwningWidget;
 
   // all of the objects that we own
   EmbedWindow                   *mWindow;
   nsCOMPtr<nsISupports>          mWindowGuard;
@@ -191,20 +198,21 @@ class EmbedPrivate {
   nsCOMPtr<nsISHistory>          mSessionHistory;
 
   nsCOMPtr<nsPIDOMEventTarget>   mEventTarget;
 
   // the currently loaded uri
   nsString                       mURI;
   nsCString                      mPrePath;
 
   // the number of widgets that have been created
   static PRUint32                sWidgetCount;
+  static PRBool                  sTermEmbedding;
   // the path to the GRE
   static char                   *sPath;
   // the path to components
   static char                   *sCompPath;
   // the list of application-specific components to register
   static const nsModuleComponentInfo  *sAppComps;
   static int                     sNumAppComps;
   // the appshell we have created
   static nsIAppShell            *sAppShell;
   // the list of all open windows
@@ -218,43 +226,52 @@ class EmbedPrivate {
   // chrome mask
   PRUint32                       mChromeMask;
   // is this a chrome window?
   PRBool                         mIsChrome;
   // has the chrome finished loading?
   PRBool                         mChromeLoaded;
 
   // has the network finished loading?
   PRBool                         mLoadFinished;
 
+  // is it uploadind a file ?
+  PRBool                         mIsUploading;
+
   // saved window ID for reparenting later
   GtkWidget                     *mMozWindowWidget;
   // has someone called Destroy() on us?
   PRBool                         mIsDestroyed;
 
   //Open Blocker for Create Window class //Fixme...
   //I just tried to block it on earlier moment
   PRBool                         mOpenBlock;
   PRBool                         mNeedFav;
+  PRBool                         mPluginSuspended;
  private:
 
   // is the chrome listener attached yet?
   PRBool                         mListenersAttached;
   PRBool                         mDoResizeEmbed;
+  PRInt32                        mCurVisibleHeight;
+  PRBool                         mResizeControl;
 
   void GetListener    (void);
   void AttachListeners(void);
   void DetachListeners(void);
 
   // this will get the PIDOMWindow for this widget
   nsresult        GetPIDOMWindow   (nsPIDOMWindow **aPIWin);
 
-  static nsresult RegisterAppComponents();
+  static nsresult RegisterComponents(PRBool aAutoRegister);
 
   // offscreen window methods and the offscreen widget
   static void       EnsureOffscreenWindow(void);
   static void       DestroyOffscreenWindow(void);
   static GtkWidget *sOffscreenWindow;
   static GtkWidget *sOffscreenFixed;
 
+  PRBool          CanSelect();
+  nsresult        EnumerateFrames(nsIDOMDocument* aDomDoc, PRUint16 aEvent);
+  nsresult        EnumeratePlugins(nsIDOMDocument* aDomDoc, const nsAString& aPluginTag, PRUint16 aEvent);
 };
 
 #endif /* __EmbedPrivate_h */
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedProgress.cpp mozilla/embedding/browser/gtk/src/EmbedProgress.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedProgress.cpp	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -42,170 +42,263 @@
 #include "EmbedProgress.h"
 
 #ifdef MOZILLA_INTERNAL_API
 #include "nsXPIDLString.h"
 #endif
 #include "nsIChannel.h"
 #include "nsIHttpChannel.h"
 #include "nsIWebProgress.h"
 #include "nsIDOMWindow.h"
 #include "EmbedPasswordMgr.h"
+#include "nsPresContext.h"
+#include "nsIFrame.h"
+#include "EmbedWindow.h"
 
 #include "nsIURI.h"
 #include "nsCRT.h"
 
+//#define MOZ_PLUGINS_SHOW = 1,
+//#define MOZ_PLUGINS_HIDE = 2,
+//#define MOZ_PLUGINS_RESUME = 3,
+//#define MOZ_PLUGINS_SUSPEND = 4,
+//#define MOZ_PLUGINS_LOW_MEMORY = 5,
+//#define MOZ_PLUGINS_NORMAL_MEMORY = 6,
+//#define MOZ_PLUGINS_LAST = 7
+
 static PRInt32 sStopSignalTimer = 0;
+static PRBool sNastyProgress = PR_TRUE;
+
 static gboolean
 progress_emit_stop(void * data)
 {
+    if (EmbedPrivate::sTermEmbedding) {
+      fprintf(stderr,"%s:Warning: Emit signal after destroy\n", __FUNCTION__);
+      return FALSE;
+    }
     g_return_val_if_fail(data, FALSE);
     EmbedPrivate *owner = (EmbedPrivate*)data;
+
+    if (owner->mIsUploading) {
+
+        gtk_signal_emit(GTK_OBJECT(owner->mOwningWidget),
+                        moz_embed_signals[FILE_UPLOAD_FINISHED]);
+
+        owner->mIsUploading = PR_FALSE;
+        return FALSE;
+    }
+
     if (!owner->mLoadFinished) {
       owner->mLoadFinished = PR_TRUE;
       gtk_signal_emit(GTK_OBJECT(owner->mOwningWidget),
                       moz_embed_signals[NET_STOP]);
     }
+
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+
+    if (success && enabled) {
+      owner->NotifyPlugins(3);
+      owner->mPluginSuspended = PR_FALSE;
+    }
+    // when finished loading, disable flash suspending function
+    // with the help of pref
+    gboolean btval = FALSE;
+    gtk_moz_embed_common_set_pref (G_TYPE_BOOLEAN,"plugins.flashhack",&btval);
     return FALSE;
 }
 
 EmbedProgress::EmbedProgress(void)
 {
   mOwner = nsnull;
+  mConnectingState = PR_TRUE;
+  mPageDownloaded = PR_FALSE;
+  mPagePainted = PR_FALSE;
+  mShowProgressStopped = PR_TRUE;
 }
 
 EmbedProgress::~EmbedProgress()
 {
 }
 
 NS_IMPL_ISUPPORTS2(EmbedProgress,
                    nsIWebProgressListener,
                    nsISupportsWeakReference)
 
 nsresult
 EmbedProgress::Init(EmbedPrivate *aOwner)
 {
   mOwner = aOwner;
   mStopLevel = 0;
+  gboolean enabled = PR_TRUE;
+  if (gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"gtkmozembed.nasty_progress", &enabled)
+      && !enabled)
+    sNastyProgress = PR_FALSE;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnStateChange(nsIWebProgress *aWebProgress,
            nsIRequest     *aRequest,
            PRUint32        aStateFlags,
            nsresult        aStatus)
 {
+  PRBool mIsLoadingDocument = PR_TRUE;
+  aWebProgress->GetIsLoadingDocument(&mIsLoadingDocument);
+  if (mOwner->mWindow->mHidden == 2) {
+    mOwner->Show();
+    gtk_widget_grab_focus(GTK_WIDGET(mOwner->mOwningWidget));
+    mOwner->mWindow->mHidden = 0;
+  }
+  if (sNastyProgress &&
+      aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING &&
+      aStateFlags & GTK_MOZ_EMBED_FLAG_IS_DOCUMENT) {
+    if (aStatus == NS_FRAME_HAS_VIEW) {
+      mPagePainted = PR_FALSE;
+      mConnectingState = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
+    }
+    if (aStatus == NS_FRAME_IMPL_RESERVED)
+      mPagePainted = PR_TRUE;
+  }
+
   // give the widget a chance to attach any listeners
   mOwner->ContentStateChange();
 
   if (sStopSignalTimer &&
       (
        (aStateFlags & GTK_MOZ_EMBED_FLAG_TRANSFERRING)
        || (aStateFlags & GTK_MOZ_EMBED_FLAG_REDIRECTING)
        || (aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING)
       )
      ) {
-      g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
       mStopLevel = 0;
       gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                       moz_embed_signals[NET_START]);
       mOwner->mLoadFinished = PR_FALSE;
+      mPageDownloaded = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
   }
 
   // if we've got the start flag, emit the signal
-  if ((aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) &&
+  if ((aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK || aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING) &&
       (aStateFlags & GTK_MOZ_EMBED_FLAG_START)) {
     // FIXME: workaround for broken progress values.
     mOwner->mOwningWidget->current_number_of_requests = 0;
     mOwner->mOwningWidget->total_number_of_requests = 0;
 
     if (mOwner->mLoadFinished) {
       mOwner->mLoadFinished = PR_FALSE;
       mStopLevel = 0;
+      mConnectingState = PR_TRUE;
+      mPageDownloaded = PR_FALSE;
+      mPagePainted = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
       gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                       moz_embed_signals[NET_START]);
     }
   }
-  // get the uri for this request
-  nsCString tmpString;
-  RequestToURIString(aRequest, tmpString);
+
+  if (sNastyProgress && mPagePainted && mPageDownloaded && !mShowProgressStopped) {
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[PROGRESS_ALL],
+                    (const gchar *) nsnull,
+                    100, 100);
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[NET_STOP]);
+    mShowProgressStopped = PR_TRUE;
+  }
 
   // FIXME: workaround for broken progress values.
   if (mOwner->mOwningWidget) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_REQUEST) {
       if (aStateFlags & GTK_MOZ_EMBED_FLAG_START)
         mOwner->mOwningWidget->total_number_of_requests ++;
       else if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP)
         mOwner->mOwningWidget->current_number_of_requests++;
     }
 
-    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                    moz_embed_signals[PROGRESS_ALL],
-                    (const gchar *) tmpString.get(),
-                    mOwner->mOwningWidget->current_number_of_requests,
-                    mOwner->mOwningWidget->total_number_of_requests);
-  }
-  // is it the same as the current URI?
-  if (mOwner->mURI.Equals(NS_ConvertUTF8toUTF16(tmpString))) {
-    // for people who know what they are doing
-    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                    moz_embed_signals[NET_STATE],
-                    aStateFlags, aStatus);
+    if (!sNastyProgress || (!mConnectingState && !mShowProgressStopped))
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[PROGRESS_ALL],
+                      (const gchar *) NULL,
+                      mOwner->mOwningWidget->current_number_of_requests,
+                      mOwner->mOwningWidget->total_number_of_requests);
   }
 
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[NET_STATE_ALL],
-                  (const gchar *)tmpString.get(),
+                    NULL,
                   (gint)aStateFlags, (gint)aStatus);
 
   // and for stop, too
   if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_REQUEST)
       mStopLevel = 1;
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_DOCUMENT)
        mStopLevel = mStopLevel == 1 ? 2 : 0;
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_WINDOW) {
       mStopLevel = mStopLevel == 2 ? 3 : 0;
     }
   }
 
   if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) {
-      if (sStopSignalTimer)
-        g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
+      mShowProgressStopped = PR_TRUE;
       progress_emit_stop(mOwner);
       // let our owner know that the load finished
       mOwner->ContentFinishedLoading();
 
+      // resume plugins
+      PRBool enabled = PR_TRUE;
+      gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+      if (success && enabled) {
+        nsCOMPtr<nsIDOMWindow> domWindow;
+        aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
+        mOwner->NotifyPlugins(3, domWindow);
+        mOwner->mPluginSuspended = PR_FALSE;
+      }
     } else if (mStopLevel == 3) {
-      if (sStopSignalTimer)
-        g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
       mStopLevel = 0;
+      mShowProgressStopped = PR_TRUE;
       sStopSignalTimer = g_timeout_add(1000, progress_emit_stop, mOwner);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnProgressChange(nsIWebProgress *aWebProgress,
                                 nsIRequest     *aRequest,
                                 PRInt32         aCurSelfProgress,
                                 PRInt32         aMaxSelfProgress,
                                 PRInt32         aCurTotalProgress,
                                 PRInt32         aMaxTotalProgress)
 {
   nsCString tmpString;
   RequestToURIString(aRequest, tmpString);
 
   // is it the same as the current uri?
+  if (aMaxTotalProgress != -1 && aCurTotalProgress == aMaxTotalProgress
+      && aMaxSelfProgress != -1 && aCurSelfProgress == aMaxSelfProgress) {
+    mPageDownloaded = PR_TRUE;
+  }
+
   if (mOwner->mURI.Equals(NS_ConvertUTF8toUTF16(tmpString))) {
+    if (!mPagePainted && mOwner->mLoadFinished && !sStopSignalTimer) {
+      mOwner->mLoadFinished = PR_FALSE;
+      sStopSignalTimer = g_timeout_add(1000, progress_emit_stop, mOwner);
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[NET_START]);
+    }
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[PROGRESS],
                     aCurTotalProgress, aMaxTotalProgress);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnLocationChange(nsIWebProgress *aWebProgress,
@@ -234,53 +327,52 @@ EmbedProgress::OnLocationChange(nsIWebPr
     if (domWindow != topDomWindow)
       isSubFrameLoad = PR_TRUE;
   }
 
   if (!isSubFrameLoad) {
     mOwner->SetURI(newURI.get());
     mOwner->mPrePath.Assign(prePath.get());
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[LOCATION]);
   }
-  mOwner->mNeedFav = PR_TRUE;
 
+  // suspend plugins
+  // this->NotifyPlugins(4);
+  mOwner->mNeedFav = PR_TRUE;
+  gboolean bval = TRUE;
+  gtk_moz_embed_common_set_pref (G_TYPE_BOOLEAN,"plugins.flashhack",&bval);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnStatusChange(nsIWebProgress  *aWebProgress,
                               nsIRequest      *aRequest,
                               nsresult         aStatus,
                               const PRUnichar *aMessage)
 {
-  // need to make a copy so we can safely cast to a void *
-  PRUnichar *tmpString = NS_strdup(aMessage);
-
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[STATUS_CHANGE],
-                  NS_STATIC_CAST(void *, aRequest),
-                  NS_STATIC_CAST(gint, aStatus),
-                  NS_STATIC_CAST(void *, tmpString));
-
-  NS_Free(tmpString);
+                  static_cast<void *>(aRequest),
+                  static_cast<gint>(aStatus),
+                  static_cast<const void *>(aMessage));
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnSecurityChange(nsIWebProgress *aWebProgress,
                                 nsIRequest     *aRequest,
                                 PRUint32         aState)
 {
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[SECURITY_CHANGE],
-                  NS_STATIC_CAST(void *, aRequest),
+                  static_cast<void *>(aRequest),
                   aState);
   return NS_OK;
 }
 
 /* static */
 void
 EmbedProgress::RequestToURIString(nsIRequest *aRequest, nsCString& aString)
 {
   // is it a channel
   nsCOMPtr<nsIChannel> channel;
@@ -314,11 +406,10 @@ EmbedProgress::HandleHTTPStatus(nsIReque
   PRUint32 responseCode = 0;
   nsCString responseText;
   rv = httpChannel->GetResponseStatus(&responseCode);
   // it has to handle more http errors code ??? 401 ? responseCode >= 500 && responseCode <= 505
   rv = httpChannel->GetResponseStatusText(responseText);
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[NETWORK_ERROR],
                   responseCode, responseText.get(), (const gchar*)aUri);
   return rv;
 }
-
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedProgress.h mozilla/embedding/browser/gtk/src/EmbedProgress.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedProgress.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.h	2007-10-03 12:03:14.000000000 +0300
@@ -57,13 +57,17 @@ class EmbedProgress : public nsIWebProgr
 
   NS_DECL_NSIWEBPROGRESSLISTENER
 
  private:
 
   static void RequestToURIString(nsIRequest *aRequest, nsCString& aString);
   nsresult HandleHTTPStatus(nsIRequest *aRequest, const char *aUri, PRBool &aSucceeded);
 
   EmbedPrivate *mOwner;
   PRBool mStopLevel;
+  PRBool mConnectingState;
+  PRBool mPageDownloaded;
+  PRBool mPagePainted;
+  PRBool mShowProgressStopped;
 };
 
 #endif /* __EmbedProgress_h */
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedWindow.cpp mozilla/embedding/browser/gtk/src/EmbedWindow.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedWindow.cpp	2007-05-01 02:52:37.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/EmbedWindow.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -35,55 +35,59 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCWebBrowser.h"
 #include "nsIComponentManager.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIWidget.h"
+#include "nsPresContext.h"
+#include "nsIPresShell.h"
 #ifdef MOZILLA_INTERNAL_API
 #include "nsReadableUtils.h"
 #else
 #include "nsComponentManagerUtils.h"
 #endif
 #include "EmbedWindow.h"
 #include "EmbedPrivate.h"
 #include "EmbedPrompter.h"
 
 GtkWidget *EmbedWindow::sTipWindow = nsnull;
 
 EmbedWindow::EmbedWindow(void)
 {
   mOwner       = nsnull;
   mVisibility  = PR_FALSE;
   mIsModal     = PR_FALSE;
+  mJSFocusEmit = PR_TRUE;
+  mHidden      = 0;
 }
 
 EmbedWindow::~EmbedWindow(void)
 {
   ExitModalEventLoop(PR_FALSE);
 }
 
 nsresult
 EmbedWindow::Init(EmbedPrivate *aOwner)
 {
   // save our owner for later
   mOwner = aOwner;
 
   // create our nsIWebBrowser object and set up some basic defaults.
   mWebBrowser = do_CreateInstance(NS_WEBBROWSER_CONTRACTID);
   if (!mWebBrowser)
     return NS_ERROR_FAILURE;
 
-  mWebBrowser->SetContainerWindow(NS_STATIC_CAST(nsIWebBrowserChrome *, this));
+  mWebBrowser->SetContainerWindow(static_cast<nsIWebBrowserChrome *>(this));
 
   nsCOMPtr<nsIDocShellTreeItem> item = do_QueryInterface(mWebBrowser);
   item->SetItemType(nsIDocShellTreeItem::typeContentWrapper);
 
   return NS_OK;
 }
 
 nsresult
 EmbedWindow::CreateWindow(void)
 {
@@ -121,20 +125,21 @@ EmbedWindow::ReleaseChildren(void)
 // nsISupports
 
 NS_IMPL_ADDREF(EmbedWindow)
 NS_IMPL_RELEASE(EmbedWindow)
 
 NS_INTERFACE_MAP_BEGIN(EmbedWindow)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebBrowserChrome)
   NS_INTERFACE_MAP_ENTRY(nsIWebBrowserChrome)
   NS_INTERFACE_MAP_ENTRY(nsIWebBrowserChromeFocus)
   NS_INTERFACE_MAP_ENTRY(nsIEmbeddingSiteWindow)
+  NS_INTERFACE_MAP_ENTRY(nsIEmbeddingSiteWindow2)
 //  NS_INTERFACE_MAP_ENTRY(nsITooltipListener)
   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
 NS_INTERFACE_MAP_END
 
 // nsIWebBrowserChrome
 
 NS_IMETHODIMP
 EmbedWindow::SetStatus(PRUint32 aStatusType, const PRUnichar *aStatus)
 {
   switch (aStatusType) {
@@ -269,80 +274,123 @@ EmbedWindow::FocusPrevElement()
 }
 
 // nsIEmbeddingSiteWindow
 
 NS_IMETHODIMP
 EmbedWindow::SetDimensions(PRUint32 aFlags, PRInt32 aX, PRInt32 aY,
          PRInt32 aCX, PRInt32 aCY)
 {
   if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION &&
       (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
-     nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER))) {
-    return mBaseWindow->SetPositionAndSize(aX, aY, aCX, aCY, PR_TRUE);
+    nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER))) {
+    mBaseWindow->SetPositionAndSize(aX, aY, aCX, aCY, PR_TRUE);
   }
   else if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION) {
-    return mBaseWindow->SetPosition(aX, aY);
+    mBaseWindow->SetPosition(aX, aY);
   }
   else if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
-         nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER)) {
-    return mBaseWindow->SetSize(aCX, aCY, PR_TRUE);
+    nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER)) {
+    mBaseWindow->SetSize(aCX, aCY, PR_TRUE);
+  }
+
+  if(aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_VERTICAL)
+  {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    NS_ENSURE_TRUE(webBrowser, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIDocShell> docShell(do_GetInterface((nsISupports*)webBrowser));
+    NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsPresContext> context;
+    docShell->GetPresContext(getter_AddRefs(context));
+    NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIPresShell> presShell = context->GetPresShell();
+    NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
+    presShell->StyleChangeReflow();
   }
-  return NS_ERROR_INVALID_ARG;
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetDimensions(PRUint32 aFlags, PRInt32 *aX,
          PRInt32 *aY, PRInt32 *aCX, PRInt32 *aCY)
 {
-  if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION &&
-      (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
-     nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER))) {
-    return mBaseWindow->GetPositionAndSize(aX, aY, aCX, aCY);
-  }
-  else if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION) {
-    return mBaseWindow->GetPosition(aX, aY);
-  }
-  else if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
+  nsresult rv = NS_ERROR_INVALID_ARG;
+  if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION && aX && aY) {
+    GdkWindow *window = gtk_widget_get_parent_window(GTK_WIDGET(mOwner->mOwningWidget));
+    if (window) {
+      gdk_window_get_position(window, aX, aY);
+      rv = NS_OK;
+    }
+  } else
+    rv = NS_OK;
+  if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
          nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER)) {
-    return mBaseWindow->GetSize(aCX, aCY);
+    rv |= mBaseWindow->GetSize(aCX, aCY);
   }
-  return NS_ERROR_INVALID_ARG;
+  return rv;
 }
 
 NS_IMETHODIMP
 EmbedWindow::SetFocus(void)
 {
   // XXX might have to do more here.
-  return mBaseWindow->SetFocus();
+  gboolean return_val = FALSE;
+  nsresult rv = NS_OK;
+  rv = mBaseWindow->SetFocus();
+  if (mJSFocusEmit && mOwner->mOwningWidget)
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_WINDOW_FOCUS],
+                    &return_val);
+  return rv;
+}
+
+NS_IMETHODIMP
+EmbedWindow::Blur(void)
+{
+  // XXX might have to do more here.
+  gboolean handled = FALSE;
+  if (mOwner->mOwningWidget)
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_WINDOW_BLUR],
+                    &handled);
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetTitle(PRUnichar **aTitle)
 {
   *aTitle = ToNewUnicode(mTitle);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::SetTitle(const PRUnichar *aTitle)
 {
   mTitle = aTitle;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
       moz_embed_signals[TITLE]);
+  if (mHidden == 1) {
+    mOwner->Hide();
+    mHidden = 2;
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetSiteWindow(void **aSiteWindow)
 {
   GtkWidget *ownerAsWidget(GTK_WIDGET(mOwner->mOwningWidget));
-  *aSiteWindow = NS_STATIC_CAST(void *, ownerAsWidget);
+  *aSiteWindow = static_cast<void *>(ownerAsWidget);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetVisibility(PRBool *aVisibility)
 {
   *aVisibility = mVisibility ||
                  !mOwner->mIsChrome &&
                  mOwner->mOwningWidget &&
                  GTK_WIDGET_MAPPED(mOwner->mOwningWidget);
@@ -391,22 +439,22 @@ EmbedWindow::OnShowTooltip(PRInt32 aXCoo
 
   const char* tipString = ToNewUTF8String(tipText);
 
   if (sTipWindow)
     gtk_widget_destroy(sTipWindow);
 
   // get the root origin for this content window
   nsCOMPtr<nsIWidget> mainWidget;
   mBaseWindow->GetMainWidget(getter_AddRefs(mainWidget));
   GdkWindow *window;
-  window = NS_STATIC_CAST(GdkWindow *,
-        mainWidget->GetNativeData(NS_NATIVE_WINDOW));
+  window = static_cast<GdkWindow *>
+        (mainWidget->GetNativeData(NS_NATIVE_WINDOW));
   gint root_x, root_y;
   gdk_window_get_origin(window, &root_x, &root_y);
 
   // XXX work around until I can get pink to figure out why
   // tooltips vanish if they show up right at the origin of the
   // cursor.
   root_y += 10;
 
   sTipWindow = gtk_window_new(GTK_WINDOW_POPUP);
   gtk_widget_set_app_paintable(sTipWindow, TRUE);
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedWindow.h mozilla/embedding/browser/gtk/src/EmbedWindow.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedWindow.h	2007-01-03 00:23:53.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedWindow.h	2007-10-03 12:03:14.000000000 +0300
@@ -41,67 +41,72 @@
 #define __EmbedWindow_h
 
 #ifdef MOZILLA_INTERNAL_API
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #endif
 #include "nsIWebBrowserChrome.h"
 #include "nsIWebBrowserChromeFocus.h"
 #include "nsIEmbeddingSiteWindow.h"
+#include "nsIEmbeddingSiteWindow2.h"
 //#include "nsITooltipListener.h"
 #include "nsISupports.h"
 #include "nsIWebBrowser.h"
 #include "nsIBaseWindow.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsCOMPtr.h"
 
 #include <gtk/gtk.h>
 
 class EmbedPrivate;
 
 class EmbedWindow : public nsIWebBrowserChrome,
         public nsIWebBrowserChromeFocus,
-                    public nsIEmbeddingSiteWindow,
+        public nsIEmbeddingSiteWindow2,
 //                    public nsITooltipListener,
         public nsIInterfaceRequestor
 {
 
  public:
 
   EmbedWindow();
   virtual ~EmbedWindow();
 
   nsresult Init            (EmbedPrivate *aOwner);
   nsresult CreateWindow    (void);
   void     ReleaseChildren (void);
+  void     EnableFocusEmit (PRBool aEnable = PR_TRUE) { mJSFocusEmit = aEnable; };
 
   NS_DECL_ISUPPORTS
 
   NS_DECL_NSIWEBBROWSERCHROME
 
   NS_DECL_NSIWEBBROWSERCHROMEFOCUS
 
   NS_DECL_NSIEMBEDDINGSITEWINDOW
 
+  NS_DECL_NSIEMBEDDINGSITEWINDOW2
+
 //  NS_DECL_NSITOOLTIPLISTENER
 
   NS_DECL_NSIINTERFACEREQUESTOR
 
   nsString                 mTitle;
   nsString                 mJSStatus;
   nsString                 mLinkMessage;
 
   nsCOMPtr<nsIBaseWindow>  mBaseWindow; // [OWNER]
+  PRInt32                  mHidden;
 
 private:
 
   EmbedPrivate            *mOwner;
   nsCOMPtr<nsIWebBrowser>  mWebBrowser; // [OWNER]
   static GtkWidget        *sTipWindow;
   PRBool                   mVisibility;
   PRBool                   mIsModal;
-
+  PRBool                   mJSFocusEmit;
 };
 
 
 #endif /* __EmbedWindow_h */
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/EmbedWindowCreator.cpp mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedWindowCreator.cpp	2007-01-03 00:23:53.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -91,27 +91,27 @@ EmbedWindowCreator::CreateChromeWindow(n
   // check to make sure that we made a new window
   if (!newEmbed)
     return NS_ERROR_FAILURE;
 
   // The window _must_ be realized before we pass it back to the
   // function that created it. Functions that create new windows
   // will do things like GetDocShell() and the widget has to be
   // realized before that can happen.
   gtk_widget_realize(GTK_WIDGET(newEmbed));
 
-  EmbedPrivate *newEmbedPrivate = NS_STATIC_CAST(EmbedPrivate *,
-             newEmbed->data);
+  EmbedPrivate *newEmbedPrivate = static_cast<EmbedPrivate *>
+             (newEmbed->data);
 
   // set the chrome flag on the new window if it's a chrome open
   if (aChromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME)
     newEmbedPrivate->mIsChrome = PR_TRUE;
 
-  *_retval = NS_STATIC_CAST(nsIWebBrowserChrome *,
-            (newEmbedPrivate->mWindow));
+  *_retval = static_cast<nsIWebBrowserChrome *>
+            (newEmbedPrivate->mWindow);
 
   if (*_retval) {
     NS_ADDREF(*_retval);
     return NS_OK;
   }
 
   return NS_ERROR_FAILURE;
 }
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/GtkPromptService.cpp mozilla/embedding/browser/gtk/src/GtkPromptService.cpp
--- mozilla/embedding/browser/gtk/src.orig/GtkPromptService.cpp	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/GtkPromptService.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -47,20 +47,21 @@
 #ifdef MOZILLA_INTERNAL_API
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #endif
 #include "nsIWindowWatcher.h"
 #include "nsIWebBrowserChrome.h"
 #include "nsIEmbeddingSiteWindow.h"
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
+#include "EmbedEventListener.h"
 
 #define UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(newed) PR_BEGIN_MACRO \
   /* OOPS this code is using a glib allocation function which     \
    * will cause the application to crash when it runs out of      \
    * memory. This is not cool. either g_try methods should be     \
    * used or malloc, or new (note that gecko /will/ be replacing  \
    * its operator new such that new will not throw exceptions).   \
    * XXX please fix me.                                           \
    */                                                             \
   if (!newed) {                                                   \
@@ -68,30 +69,35 @@
   PR_END_MACRO
 
 GtkPromptService::GtkPromptService()
 {
 }
 
 GtkPromptService::~GtkPromptService()
 {
 }
 
+#ifdef NECKO_COOKIES
 NS_IMPL_ISUPPORTS2(GtkPromptService, nsIPromptService, nsICookiePromptService)
+#else
+NS_IMPL_ISUPPORTS1(GtkPromptService, nsIPromptService)
+#endif
 
 NS_IMETHODIMP
 GtkPromptService::Alert(
   nsIDOMWindow* aParent,
   const PRUnichar* aDialogTitle,
   const PRUnichar* aDialogText)
 {
   GtkWidget* parentWidget = GetGtkWidgetForDOMWindow(aParent);
   if (parentWidget && gtk_signal_handler_pending(parentWidget, moz_embed_signals[ALERT], TRUE)) {
+    EmbedEventListener::DisableLongPressTimer(parentWidget);
     gtk_signal_emit(GTK_OBJECT(parentWidget),
       moz_embed_signals[ALERT],
       (const gchar *) NS_ConvertUTF16toUTF8(aDialogTitle).get(),
       (const gchar *) NS_ConvertUTF16toUTF8(aDialogText).get());
     return NS_OK;
   }
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
   EmbedPrompter prompter;
   prompter.SetTitle(aDialogTitle ? aDialogTitle : NS_LITERAL_STRING("Alert").get());
   prompter.SetMessageText(aDialogText);
@@ -487,20 +493,22 @@ GtkPromptService::Select(
   prompter.SetMessageText(aDialogText);
   prompter.SetItems(aSelectList, aCount);
   prompter.Create(EmbedPrompter::TYPE_SELECT,
                   GetGtkWindowForDOMWindow(aParent));
   prompter.Run();
   prompter.GetSelectedItem(outSelection);
   prompter.GetConfirmValue(aConfirm);
 #endif
   return NS_OK;
 }
+
+#ifdef NECKO_COOKIES
 /* nsCookiePromptService */
 NS_IMETHODIMP
 GtkPromptService::CookieDialog(
   nsIDOMWindow *aParent,
   nsICookie *aCookie,
   const nsACString &aHostname,
   PRInt32 aCookiesFromHost,
   PRBool aChangingCookie,
   PRBool *aRememberDecision,
   PRInt32 *aAccept)
@@ -517,39 +525,42 @@ GtkPromptService::CookieDialog(
   nsCString aPath;
   aCookie->GetPath(aPath);
   /* We have to investigate a value to use here */
   gboolean illegal_path = FALSE;
   PRUint64 aExpires;
   aCookie->GetExpires(&aExpires);
   nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aParent));
   GtkMozEmbed *parentWidget = GTK_MOZ_EMBED(GetGtkWidgetForDOMWindow(domWindow));
   GtkMozEmbedCookie *cookie_struct = g_new0(GtkMozEmbedCookie, 1);
   UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(cookie_struct);
-  if (parentWidget && cookie_struct) {
+  if (!cookie_struct) return NS_ERROR_OUT_OF_MEMORY;
+  
+  if (parentWidget) {
     g_signal_emit_by_name(
       GTK_OBJECT(parentWidget->common),
       "ask-cookie",
       cookie_struct,
       actions,
       (const gchar *) hostName.get(),
       (const gchar *) aName.get(),
       (const gchar *) aValue.get(),
       (const gchar *) aDomain.get(),
       (const gchar *) aPath.get(),
       illegal_path,
       aExpires,
       NULL);
   }
   *aRememberDecision = cookie_struct->remember_decision;
   *aAccept = cookie_struct->accept;
   return NS_OK;
 }
+#endif
 
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 void
 GtkPromptService::GetButtonLabel(
   PRUint32 aFlags,
   PRUint32 aPos,
   const PRUnichar* aStringValue,
   nsAString& aLabel)
 {
   PRUint32 posFlag = (aFlags & (255 * aPos)) / aPos;
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/GtkPromptService.h mozilla/embedding/browser/gtk/src/GtkPromptService.h
--- mozilla/embedding/browser/gtk/src.orig/GtkPromptService.h	2007-01-03 00:23:53.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/GtkPromptService.h	2007-10-03 12:03:15.000000000 +0300
@@ -32,41 +32,47 @@
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIPromptService.h"
+#ifdef NECKO_COOKIES
 #include "nsICookiePromptService.h"
 #include "nsICookie.h"
+#endif
 #include "nsNetCID.h"
 #include <gtk/gtk.h>
 #ifdef MOZILLA_INTERNAL_API
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #endif
 #define NS_PROMPTSERVICE_CID \
  {0x95611356, 0xf583, 0x46f5, {0x81, 0xff, 0x4b, 0x3e, 0x01, 0x62, 0xc6, 0x19}}
 
 class nsIDOMWindow;
 
-class GtkPromptService : public nsIPromptService,
-                         public nsICookiePromptService
+class GtkPromptService : public nsIPromptService
+#ifdef NECKO_COOKIES
+                         , public nsICookiePromptService
+#endif
 {
 public:
     GtkPromptService();
     virtual ~GtkPromptService();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIPROMPTSERVICE
+#ifdef NECKO_COOKIES
     NS_DECL_NSICOOKIEPROMPTSERVICE
+#endif
 
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 private:
     void GetButtonLabel(PRUint32 aFlags, PRUint32 aPos,
                         const PRUnichar* aStringValue, nsAString &aLabel);
 #endif
 };
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembed.h mozilla/embedding/browser/gtk/src/gtkmozembed.h
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed.h	2007-05-01 02:52:37.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/gtkmozembed.h	2007-10-03 12:03:15.000000000 +0300
@@ -174,26 +174,32 @@ struct _GtkMozEmbedClass
                                 const char *check_msg, gboolean *check_val);
   gint     (* confirm_ex)      (GtkMozEmbed *embed, const char *title, const char *text, guint bt_flags,
                                 const char *button1, const char *button2, const char *button3,
                                 const char *check_msg, gboolean *check_val);
   gboolean (* prompt)          (GtkMozEmbed *embed, const char *title, const char *text,
                                 char **value, const char *check_msg, gboolean *check_val);
   gboolean (* prompt_auth)     (GtkMozEmbed *embed, const char *title, const char *text,
                                 char **user, char **pass, const char *check_msg, gboolean *check_val);
   gboolean (* select)          (GtkMozEmbed *embed, const char *title, const char *text,
                                 GList *list, gint *selected_item);
-  void     (* download_request)(GtkMozEmbed *, const char *, const char *, const char *, long, int, gpointer);
-  gboolean (* upload_dialog)   (GtkMozEmbed *, const char *, const char *, char **);
-  void     (* icon_changed)    (GtkMozEmbed *, gpointer*);
-  void     (* mailto)          (GtkMozEmbed *, gchar *);
-  void     (* network_error)   (GtkMozEmbed *, gchar *, const gint, const gchar **);
-  void     (* rss_request)     (GtkMozEmbed *, gchar *, gchar *);
+  void     (* download_request)(GtkMozEmbed *embed, const char *, const char *, const char *, long, int, gpointer);
+  gboolean (* upload_dialog)   (GtkMozEmbed *embed);
+  void     (* file_upload_started)(GtkMozEmbed *embed);
+  void     (* file_upload_finished)(GtkMozEmbed *embed);
+  void     (* icon_changed)    (GtkMozEmbed *embed, gpointer*);
+  void     (* mailto)          (GtkMozEmbed *embed, gchar *);
+  void     (* network_error)   (GtkMozEmbed *embed, gchar *, const gint, const gchar **);
+  void     (* rss_request)     (GtkMozEmbed *embed, gchar *, gchar *);
+  gint     (* dom_window_focus)(GtkMozEmbed *embed);
+  gint     (* dom_window_blur) (GtkMozEmbed *embed);
+  void     (* dom_content_blocked)(GtkMozEmbed *embed, const char *aURI,const char * url);
+
 };
 
 GTKMOZEMBED_API(GtkType,       gtk_moz_embed_get_type,            (void))
 GTKMOZEMBED_API(GtkWidget*,    gtk_moz_embed_new,                 (void))
 GTKMOZEMBED_API(void,          gtk_moz_embed_push_startup,        (void))
 GTKMOZEMBED_API(void,          gtk_moz_embed_pop_startup,         (void))
 
 /* Tell gtkmozembed where the gtkmozembed libs live. If this is not specified,
    The MOZILLA_FIVE_HOME environment variable is checked. */
 GTKMOZEMBED_API(void,          gtk_moz_embed_set_path,            (const char *aPath))
@@ -227,26 +233,29 @@ GTKMOZEMBED_API(void,          gtk_moz_e
 GTKMOZEMBED_API(void,          gtk_moz_embed_check_logins,        (GtkMozEmbed *embed))
 GTKMOZEMBED_API(char*,         gtk_moz_embed_get_encoding,        (GtkMozEmbed *embed, gint))
 GTKMOZEMBED_API(void,          gtk_moz_embed_set_encoding,        (GtkMozEmbed *embed, const gchar *, gint))
 GTKMOZEMBED_API(guint,         gtk_moz_embed_get_context_info,    (GtkMozEmbed *embed, gpointer event, gpointer *node,
                                                                    gint *x, gint *y, gint *docindex,
                                                                    const gchar **url, const gchar **objurl, const gchar **docurl))
 GTKMOZEMBED_API(const gchar*,  gtk_moz_embed_get_selection,       (GtkMozEmbed *embed))
 GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_doc_info,        (GtkMozEmbed *embed, gpointer node, gint docindex, const gchar**title,
                                                                    const gchar**location, const gchar **file_type, guint *file_size,
                                                                    gint *width, gint *height))
-GTKMOZEMBED_API(gboolean,      gtk_moz_embed_insert_text,         (GtkMozEmbed *embed, const gchar*, gpointer node))
-GTKMOZEMBED_API(gboolean,      gtk_moz_embed_save_target,         (GtkMozEmbed *embed, gchar*, gchar*, gint))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_insert_text,         (GtkMozEmbed *embed, const gchar*, gpointer node, gint surr1, gint surr2))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_save_target,         (GtkMozEmbed *embed, const gchar*, const gchar*, gint, gpointer))
 GTKMOZEMBED_API(gint,          gtk_moz_embed_get_shistory_list,   (GtkMozEmbed *embed, GtkMozHistoryItem **GtkHI, guint type))
 GTKMOZEMBED_API(gint,          gtk_moz_embed_get_shistory_index,  (GtkMozEmbed *embed))
 GTKMOZEMBED_API(void,          gtk_moz_embed_shistory_goto_index, (GtkMozEmbed *embed, gint index))
 GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_server_cert,     (GtkMozEmbed *embed, gpointer *aCert, gpointer))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_text,            (GtkMozEmbed *embed, gchar**, gint *curpos))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_load_image,          (GtkMozEmbed *embed, const gchar*))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_do_command,          (GtkMozEmbed *embed, const gchar*, gint, gpointer))
 
 typedef enum
 {
   GTK_MOZ_EMBED_BACK_SHISTORY,
   GTK_MOZ_EMBED_FORWARD_SHISTORY
 } GtkMozEmbedSessionHistory;
 
 typedef enum
 {
   GTK_MOZ_EMBED_SELECT_ALL,
@@ -260,25 +269,27 @@ typedef enum
 } GtkMozEmbedClipboard;
 typedef enum
 {
   GTK_MOZ_EMBED_CTX_NONE       = 0,
   GTK_MOZ_EMBED_CTX_XUL        = 1 << 1,
   GTK_MOZ_EMBED_CTX_SIDEBAR    = 1 << 2,
   GTK_MOZ_EMBED_CTX_DOCUMENT   = 1 << 3,
   GTK_MOZ_EMBED_CTX_LINK       = 1 << 4,
   GTK_MOZ_EMBED_CTX_IMAGE      = 1 << 5,
   GTK_MOZ_EMBED_CTX_IFRAME     = 1 << 6,
-  GTK_MOZ_EMBED_CTX_INPUT      = 1 << 7,
+  GTK_MOZ_EMBED_CTX_INPUT_TEXT = 1 << 7,
   GTK_MOZ_EMBED_CTX_IPASSWORD  = 1 << 8,
   GTK_MOZ_EMBED_CTX_EMAIL      = 1 << 9,
   GTK_MOZ_EMBED_CTX_RICHEDIT   = 1 << 10,
-  GTK_MOZ_EMBED_CTX_ROINPUT    = 1 << 11
+  GTK_MOZ_EMBED_CTX_ROINPUT    = 1 << 11,
+  GTK_MOZ_EMBED_CTX_MULTILINE  = 1 << 12,
+  GTK_MOZ_EMBED_CTX_SELECT     = 1 << 13
 } GtkMozEmbedContext;
 typedef enum
 {
   GTK_MOZ_EMBED_DIALOG_BUTTON_OK,
   GTK_MOZ_EMBED_DIALOG_BUTTON_CANCEL,
   GTK_MOZ_EMBED_DIALOG_BUTTON_YES,
   GTK_MOZ_EMBED_DIALOG_BUTTON_NO,
   GTK_MOZ_EMBED_DIALOG_BUTTON_SAVE,
   GTK_MOZ_EMBED_DIALOG_BUTTON_DONT_SAVE,
   GTK_MOZ_EMBED_DIALOG_BUTTON_REVERT,
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembed2.cpp mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed2.cpp	2007-05-01 02:52:37.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -73,20 +73,23 @@
 // for strings
 #ifdef MOZILLA_INTERNAL_API
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
 #else
 #include "nsStringAPI.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #endif
 
+#include "nsIImageLoadingContent.h"
+#include "nsIDOMNodeList.h"
+
 #include "gtkmozembedmarshal.h"
 
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
 class nsIDirectoryServiceProvider;
 
 // class and instance initialization
 
 static void
@@ -542,20 +545,36 @@ gtk_moz_embed_class_init(GtkMozEmbedClas
     gtk_signal_new("upload_dialog",
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, upload_dialog),
                    gtkmozembed_BOOL__STRING_STRING_POINTER,
                    GTK_TYPE_BOOL,
                    3,
                    GTK_TYPE_STRING,
                    GTK_TYPE_STRING,
                    GTK_TYPE_POINTER);
+  moz_embed_signals[FILE_UPLOAD_STARTED] =
+    gtk_signal_new("file_upload_started",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, file_upload_started),
+                   gtk_marshal_VOID__VOID,
+                   GTK_TYPE_NONE,
+                   0);
+  moz_embed_signals[FILE_UPLOAD_FINISHED] =
+    gtk_signal_new("file_upload_finished",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, file_upload_finished),
+                   gtk_marshal_VOID__VOID,
+                   GTK_TYPE_NONE,
+                   0);
   moz_embed_signals[ICON_CHANGED] =
     gtk_signal_new("icon_changed",
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, icon_changed),
                    gtkmozembed_VOID__POINTER,
                    GTK_TYPE_NONE,
                    1,
                    GTK_TYPE_POINTER);
   moz_embed_signals[MAILTO] =
@@ -583,20 +602,44 @@ gtk_moz_embed_class_init(GtkMozEmbedClas
   moz_embed_signals[RSS_REQUEST] =
     gtk_signal_new("rss_request",
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, rss_request),
                    gtkmozembed_VOID__STRING_STRING,
                    GTK_TYPE_NONE,
                    2,
                    GTK_TYPE_STRING, GTK_TYPE_STRING);
 
+  moz_embed_signals[DOM_WINDOW_BLUR] =
+    gtk_signal_new("dom_window_blur",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_window_blur),
+                   gtk_marshal_BOOL__NONE,
+                   GTK_TYPE_BOOL, 0);
+
+  moz_embed_signals[DOM_WINDOW_FOCUS] =
+    gtk_signal_new("dom_window_focus",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_window_focus),
+                   gtk_marshal_BOOL__NONE,
+                   GTK_TYPE_BOOL, 0);
+
+  moz_embed_signals[DOM_CONTENT_BLOCKED] =
+    gtk_signal_new("dom_content_blocked",
+                   GTK_RUN_FIRST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_content_blocked),
+                   gtk_marshal_NONE__POINTER_POINTER,
+                   GTK_TYPE_NONE, 2,
+                   GTK_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE,GTK_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE);
 }
 
 static void
 gtk_moz_embed_init(GtkMozEmbed *embed)
 {
   EmbedPrivate *priv = new EmbedPrivate();
   embed->data = priv;
   embed->common = NULL;
   gtk_widget_set_name(GTK_WIDGET(embed), "gtkmozembed");
 
@@ -786,22 +829,21 @@ gtk_moz_embed_unmap(GtkWidget *widget)
 
 #ifdef MOZ_ACCESSIBILITY_ATK
 static AtkObject*
 gtk_moz_embed_get_accessible (GtkWidget *widget)
 {
   g_return_val_if_fail(widget != NULL, NULL);
   g_return_val_if_fail(GTK_IS_MOZ_EMBED(widget), NULL);
 
   GtkMozEmbed  *embed = GTK_MOZ_EMBED(widget);;
   EmbedPrivate *embedPrivate = (EmbedPrivate *)embed->data;
-  return NS_STATIC_CAST(AtkObject *,
-                        embedPrivate->GetAtkObjectForCurrentDocument());
+  return static_cast<AtkObject *>(embedPrivate->GetAtkObjectForCurrentDocument());
 }
 #endif /* MOZ_ACCESSIBILITY_ATK */
 
 static gint
 handle_child_focus_in(GtkWidget     *aWidget,
                       GdkEventFocus *aGdkFocusEvent,
                       GtkMozEmbed   *aEmbed)
 {
   EmbedPrivate *embedPrivate;
 
@@ -1376,23 +1418,30 @@ gtk_moz_embed_clipboard(GtkMozEmbed *emb
 {
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail (embed != NULL, FALSE);
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), FALSE);
   g_return_val_if_fail (GTK_WIDGET_REALIZED(GTK_WIDGET(embed)), FALSE);
   embedPrivate = (EmbedPrivate *)embed->data;
   return embedPrivate->ClipBoardAction((GtkMozEmbedClipboard)action) ? TRUE : FALSE;
 }
 
 void
-gtk_moz_embed_notify_plugins(GtkMozEmbed *embed, guint)
+gtk_moz_embed_notify_plugins(GtkMozEmbed *embed, guint event)
 {
-  return;
+    EmbedPrivate *embedPrivate;
+    g_return_if_fail ((embed != NULL));
+    g_return_if_fail (GTK_IS_MOZ_EMBED(embed));
+
+    embedPrivate = (EmbedPrivate *)embed->data;
+    embedPrivate->NotifyPlugins(event);
+
+    return;
 }
 
 gchar *
 gtk_moz_embed_get_encoding(GtkMozEmbed *embed, gint frame_number)
 {
   gchar *retval = nsnull;
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail ((embed != NULL), (gchar *)NULL);
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), (gchar *)NULL);
   embedPrivate = (EmbedPrivate *)embed->data;
@@ -1473,107 +1522,161 @@ gtk_moz_embed_get_selection(GtkMozEmbed 
   if (embedPrivate->mEventListener) {
     EmbedContextMenuInfo * ctx_menu = embedPrivate->mEventListener->GetContextInfo();
     if (!ctx_menu)
       return NULL;
     return ctx_menu->GetSelectedText();
   }
 
   return NULL;
 }
 gboolean
-gtk_moz_embed_insert_text(GtkMozEmbed *embed, const gchar *string, gpointer node)
+gtk_moz_embed_insert_text(GtkMozEmbed *embed, const gchar *string, gpointer node, gint surr1, gint surr2)
 {
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail(embed != NULL, FALSE);
   g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
   embedPrivate = (EmbedPrivate *)embed->data;
   if (!embedPrivate || !embedPrivate->mEventListener)
     return FALSE;
   if (!string && node) {
     embedPrivate->ScrollToSelectedNode((nsIDOMNode*)node);
     return TRUE;
   }
   if (string) {
-    embedPrivate->InsertTextToNode((nsIDOMNode*)node, string);
+    embedPrivate->InsertTextToNode((nsIDOMNode*)node, string, surr1, surr2);
     return TRUE;
   }
   return FALSE;
 }
 
+gboolean
+gtk_moz_embed_get_text(GtkMozEmbed *embed, gchar** string, gint *curpos)
+{
+  EmbedPrivate *embedPrivate;
+  g_return_val_if_fail(embed != NULL, FALSE);
+  g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
+  embedPrivate = (EmbedPrivate *)embed->data;
+  if (!embedPrivate || !embedPrivate->mEventListener)
+    return FALSE;
+
+  if(embedPrivate->GetTextAndCursorPosition((gchar**)string, curpos))
+    return TRUE;
+
+  return FALSE;
+}
+
+gboolean
+gtk_moz_embed_do_command(GtkMozEmbed *embed,
+                        const gchar* command_name,
+                        gint count, gpointer object)
+{
+  EmbedPrivate *embedPrivate;
+  g_return_val_if_fail(command_name, FALSE);
+  g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
+  embedPrivate = (EmbedPrivate *)embed->data;
+  if (!embedPrivate)
+    return FALSE;
+  return NS_SUCCEEDED(embedPrivate->DoCommand(command_name, count, (nsIDOMNode*)object))?TRUE:FALSE;
+}
 
 gboolean
-gtk_moz_embed_save_target(GtkMozEmbed *aEmbed, gchar* aUrl,
-                          gchar* aDestination, gint aSetting)
+gtk_moz_embed_save_target(GtkMozEmbed *aEmbed, const gchar* aUrl,
+                          const gchar* aDestination, gint aSetting, gpointer aCtx)
 {
   //FIXME
   nsresult rv;
-
-  g_return_val_if_fail (aEmbed != NULL, FALSE);
-  nsIWebBrowser *webBrowser = nsnull;
-  gtk_moz_embed_get_nsIWebBrowser(GTK_MOZ_EMBED(aEmbed), &webBrowser);
-  g_return_val_if_fail (webBrowser != NULL, FALSE);
-
   nsCOMPtr<nsIDOMWindow> DOMWindow;
-  webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
-  g_return_val_if_fail (DOMWindow != NULL, FALSE);
+ 
+  if (aCtx) {
+    nsCOMPtr<nsIDOMNode> node = do_QueryInterface((nsISupports*)aCtx, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    EmbedPrivate *embedPrivate;
+    embedPrivate = (EmbedPrivate *) aEmbed->data;
+    rv = embedPrivate->GetDOMWindowByNode(node, getter_AddRefs(DOMWindow));
+  } else {
+    g_return_val_if_fail (aEmbed != NULL, FALSE);
+    nsIWebBrowser *webBrowser = nsnull;
+    gtk_moz_embed_get_nsIWebBrowser(GTK_MOZ_EMBED(aEmbed), &webBrowser);
+    g_return_val_if_fail (webBrowser != NULL, FALSE);
 
+    webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
+    g_return_val_if_fail (DOMWindow != NULL, FALSE);
+  }
+   
   nsCOMPtr<nsIDOMDocument> doc;
   DOMWindow->GetDocument(getter_AddRefs(doc));
-  g_return_val_if_fail (doc != NULL, FALSE);
+  g_return_val_if_fail (doc != NULL, FALSE); 
 
+  
   nsCOMPtr<nsIWebBrowserPersist> persist =
     do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
   if (!persist)
     return FALSE;
 
   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios)
     return FALSE;
 
   nsCOMPtr<nsIURI> uri;
   rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
   if (!uri)
     return FALSE;
 
-  if (aSetting == 0)
-  {
+  if (aSetting == 0) {
     nsCOMPtr<nsIURI> uri_s;
     rv = ios->NewURI(nsDependentCString(aUrl), "", nsnull, getter_AddRefs(uri_s));
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
 
     if (!uri_s)
       return FALSE;
-    rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);  
+    //rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);
+    rv = persist->SaveDocument(doc, uri, nsnull, nsnull, 0, 0);
 
     if (NS_SUCCEEDED(rv))
       return TRUE;
 
-  } else if (aSetting == 1)
-  {
+  }
+  else if (aSetting == 1) {
     nsCOMPtr<nsIURI> contentFolder;
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(contentFolder));
 
     nsCString contentFolderPath;
     contentFolder->GetSpec(contentFolderPath);
     contentFolderPath.Append("_content");
     printf("GetNativePath=%s ", contentFolderPath.get());
     rv = ios->NewURI(contentFolderPath, "", nsnull, getter_AddRefs(contentFolder));
 
     if (NS_FAILED(rv))
       return FALSE;
     
     rv = persist->SaveDocument(doc, uri, contentFolder, nsnull, 0, 0);
     if (NS_SUCCEEDED(rv))
       return TRUE;
-  } else if (aSetting == 2)
-  {
+  }
+  else if (aSetting == 2) {
+    nsCOMPtr<nsIURI> uri_s;
+    rv = ios->NewURI(nsDependentCString(aUrl), "", nsnull, getter_AddRefs(uri_s));
+    rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
+    
+    PRInt32 persist_flags = nsIWebBrowserPersist::PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION;
+    persist->SetPersistFlags(persist_flags);
+
+    if (!uri_s)
+      return FALSE;
+    rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);
+
+    if (NS_SUCCEEDED(rv))
+      return TRUE;
+    return FALSE;
+  }
+  else if (aSetting == 3) {
     // FIXME: How should I handle this option G_WEBENGINE_SAVE_FRAMES ?
     return FALSE;
   }
   return FALSE;
 }
 
 gboolean
 gtk_moz_embed_get_doc_info(GtkMozEmbed *embed, gpointer node, gint docindex,
                            const gchar**title, const gchar**location,
                            const gchar **file_type, guint *file_size, gint *width, gint *height)
@@ -1587,30 +1690,30 @@ gtk_moz_embed_get_doc_info(GtkMozEmbed *
     return FALSE;
 
   if (file_type) {
     embedPrivate->GetMIMEInfo(file_type, (nsIDOMNode*)node);
   }
 
   if (width && height) {
     nsString imgSrc;
     EmbedContextMenuInfo * ctx_menu = embedPrivate->mEventListener->GetContextInfo();
     if (ctx_menu)
-      ctx_menu->CheckDomImageElement((nsIDOMNode*)node, imgSrc, width, height);
+      ctx_menu->CheckDomImageElement((nsIDOMNode*)node, imgSrc, width, height, file_size);
   }
 
   if (title) {
     EmbedContextMenuInfo * ctx_menu = embedPrivate->mEventListener->GetContextInfo();
     if (ctx_menu)
       *title = NEW_TOOLKIT_STRING(ctx_menu->GetCtxDocTitle());
   }
 
-  if (file_size && location && *location != nsnull) {
+  if (file_size && *file_size == 0 && location && *location != nsnull) {
     nsCOMPtr<nsICacheEntryDescriptor> descriptor;
     nsresult rv;
     rv = embedPrivate->GetCacheEntry("HTTP", *location, nsICache::ACCESS_READ, PR_FALSE, getter_AddRefs(descriptor));
     if (descriptor) {
       rv = descriptor->GetDataSize(file_size);
     }
   }
 
   return TRUE;
 }
@@ -1629,21 +1732,21 @@ gtk_moz_embed_get_shistory_list(GtkMozEm
     embedPrivate->GetSHistoryList(GtkHI, (GtkMozEmbedSessionHistory)type, &count);
   return count;
 }
 
 gint
 gtk_moz_embed_get_shistory_index(GtkMozEmbed *embed)
 {
   g_return_val_if_fail ((embed != NULL), -1);
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), -1);
 
-  PRInt32 curIndex;
+  PRInt32 curIndex = -1;
   EmbedPrivate *embedPrivate;
   
   embedPrivate = (EmbedPrivate *)embed->data;
   if (embedPrivate->mSessionHistory)
     embedPrivate->mSessionHistory->GetIndex(&curIndex);
 
   return (gint)curIndex;
 }
 
 void
@@ -1683,10 +1786,71 @@ gtk_moz_embed_get_server_cert(GtkMozEmbe
   mSecureProvider->GetSSLStatus(getter_AddRefs(SSLStatus));
   if (!SSLStatus) return FALSE;
 
   nsCOMPtr<nsIX509Cert> serverCert;
   SSLStatus->GetServerCert(getter_AddRefs(serverCert));
   if (!serverCert) return FALSE;
 
   *aCert = serverCert;
   return TRUE;
 }
+
+gboolean
+gtk_moz_embed_load_image(GtkMozEmbed *embed, const gchar *url)
+{
+  g_return_val_if_fail(embed != NULL, FALSE);
+  g_return_val_if_fail(url != NULL, FALSE);
+  
+  EmbedPrivate *embedPrivate;
+  embedPrivate = (EmbedPrivate *)embed->data;
+
+  if (!embedPrivate || !embedPrivate->mEventListener)
+    return FALSE;
+
+  EmbedContextMenuInfo *ctx_menu = embedPrivate->mEventListener->GetContextInfo();
+  if (!ctx_menu->mCtxDocument)
+    return FALSE;  
+    
+  nsCOMPtr<nsIDOMNodeList> imgList;
+  nsresult rv = ctx_menu->mCtxDocument->GetElementsByTagName(NS_LITERAL_STRING("img"),
+                                                             getter_AddRefs(imgList));
+  NS_ENSURE_SUCCESS(rv, FALSE);                                  
+  
+  PRUint32 imgCount;
+  rv = imgList->GetLength(&imgCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  for (guint32 i = 0; i < imgCount; i++) {
+    nsCOMPtr<nsIDOMNode> imgNode;
+    rv = imgList->Item(i, getter_AddRefs(imgNode));
+    if (NS_FAILED(rv))
+      continue;
+        
+    nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(imgNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+    
+    nsCOMPtr<nsIURI> imgUri;
+    rv = imgContent->GetCurrentURI(getter_AddRefs(imgUri));
+    if (NS_FAILED(rv) || !imgUri)
+      continue;
+        
+    nsCAutoString spec;
+    rv = imgUri->GetSpec(spec);
+    if (NS_FAILED(rv))
+      continue;
+    
+    if (spec.Equals(url)) {
+      gint tmp_value = 1, cur_value;
+      gtk_moz_embed_common_get_pref(G_TYPE_INT, "permissions.default.image", &cur_value);
+      if (cur_value != 1) {
+        gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &tmp_value);
+        imgContent->ForceReload();
+        gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &cur_value);      
+      }
+      else 
+        imgContent->ForceReload();
+    }
+  }
+  
+  return TRUE;
+}
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembed_common.cpp mozilla/embedding/browser/gtk/src/gtkmozembed_common.cpp
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed_common.cpp	2007-05-01 02:52:37.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_common.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -71,31 +71,52 @@
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #endif
 // for plugins
 #include "nsIDOMNavigator.h"
 #include "nsIDOMPluginArray.h"
 #include "nsIDOMPlugin.h"
-#include <plugin/nsIPluginHost.h>
+#include "nsIPluginHost.h"
 #include "nsIDOMMimeType.h"
 #include "nsIObserverService.h"
 
+#ifdef MOZ_RDF
+#include "nsIRDFDataSource.h"
+#include "nsIRDFService.h"
+#endif
+#include "nsIExtensionManager.h"
+#include "nsICommandLineRunner.h"
+
 //for security
 #include "nsIWebProgressListener.h"
 
 //for cache
 #include "nsICacheService.h"
 #include "nsICache.h"
 
+// for image loading
+#include "nsIDOMDocument.h"
+#include "nsIDOMNodeList.h"
+#include "nsIImageLoadingContent.h"
+#include "nsIDOMHTMLIFrameElement.h"
+#include "nsIDOMHTMLFrameElement.h"
+#include "nsIDOMHTMLDocument.h"
+#include "nsIDOMHTMLCollection.h"
+
+#define EM_RDF_EXT_DES "http://www.mozilla.org/2004/em-rdf#description"
+#define EM_RDF_EXT_CREATOR "http://www.mozilla.org/2004/em-rdf#creator"
+#define EM_RDF_EXT_STATE "http://www.mozilla.org/2004/em-rdf#userDisabled"
+#define EM_RDF_EXT_APP_DISABLED "http://www.mozilla.org/2004/em-rdf#appDisabled"
+
 #include "gtkmozembedmarshal.h"
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_TOOLKIT_STRING(x) NS_ConvertUTF16toUTF8(x).get()
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
 #define UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(newed) PR_BEGIN_MACRO \
   /* OOPS this code is using a glib allocation function which     \
    * will cause the application to crash when it runs out of      \
    * memory. This is not cool. either g_try methods should be     \
    * used or malloc, or new (note that gecko /will/ be replacing  \
@@ -292,20 +313,21 @@ gtk_moz_embed_common_destroy(GtkObject *
   g_return_if_fail(object != NULL);
   g_return_if_fail(GTK_IS_MOZ_EMBED_COMMON(object));
   GtkMozEmbedCommon  *embed = nsnull;
   EmbedCommon *commonPrivate = nsnull;
   embed = GTK_MOZ_EMBED_COMMON(object);
   commonPrivate = (EmbedCommon *)embed->data;
   if (commonPrivate) {
     delete commonPrivate;
     embed->data = NULL;
   }
+  EmbedPasswordMgr::Shutdown();
 }
 
 GtkWidget *
 gtk_moz_embed_common_new(void)
 {
   GtkWidget *widget = (GtkWidget*) gtk_type_new(gtk_moz_embed_common_get_type());
   gtk_widget_set_name(widget, "gtkmozembedcommon");
   return (GtkWidget *) widget;
 }
 
@@ -467,21 +489,21 @@ gtk_moz_embed_common_get_history_list(Gt
 gint
 gtk_moz_embed_common_remove_history(gchar *url, gint time) {
   nsresult rv;
   // The global history service
   nsCOMPtr<nsIGlobalHistory2> globalHistory(do_GetService("@mozilla.org/browser/global-history;2"));
   if (!globalHistory) return NS_ERROR_NULL_POINTER;
   // The browser history interface
   nsCOMPtr<nsIObserver> myHistory = do_QueryInterface(globalHistory, &rv);
   if (!myHistory) return NS_ERROR_NULL_POINTER ;
   if (!url)
-    myHistory->Observe(nsnull, "RemoveEntries", nsnull);
+    myHistory->Observe(nsnull, "history-item-removed", nsnull);
   else {
     EmbedGlobalHistory *history = EmbedGlobalHistory::GetInstance();
     PRUnichar *uniurl = ToNewUnicode(NS_ConvertUTF8toUTF16(url));
     rv = history->RemoveEntries(uniurl, time);
     NS_Free(uniurl);
   }
   return 1;
 }
 
 GSList*
@@ -554,92 +576,236 @@ gtk_moz_embed_common_nsx509_to_raw(void 
 {
   if (!nsIX509Ptr)
     return NULL;
   unsigned char *data;
   ((nsIX509Cert*)nsIX509Ptr)->GetRawDER(len, (PRUint8 **)&data);
   if (!data)
     return NULL;
   return data;
 }
 
-gint
-gtk_moz_embed_common_get_plugins_list(GList **pluginArray)
+#ifdef MOZ_RDF
+static PRBool
+gtk_moz_embed_common_get_node_value(nsIRDFDataSource *eDataSource,
+                                    nsIRDFResource *itemResource,
+                                    nsIRDFService *rdfService,
+                                    gchar* nodeType, PRUnichar **retval)
+{
+  nsCOMPtr<nsIRDFResource> nodeRDFResource;
+  rdfService->GetResource(NS_LITERAL_CSTRING(nodeType), getter_AddRefs(nodeRDFResource));
+  if (!nodeRDFResource)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFNode> itemNode;
+  eDataSource->GetTarget(itemResource, nodeRDFResource, PR_TRUE, getter_AddRefs(itemNode));
+  if (!itemNode)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFLiteral> itemNodeLiteral = do_QueryInterface(itemNode);
+  if (!itemNodeLiteral)
+    return PR_FALSE;
+
+  PRUnichar *itemType = nsnull;
+  itemNodeLiteral->GetValue(&itemType);
+  *retval= itemType;
+
+  return PR_TRUE;
+}
+#endif
+
+gboolean
+gtk_moz_embed_common_set_extension_status(gchar *extensionID, gboolean status)
+{
+  g_return_val_if_fail (extensionID != NULL, FALSE);
+  nsCOMPtr<nsIExtensionManager> eManager(do_GetService("@mozilla.org/extensions/manager;1"));
+  if (!eManager)
+    return FALSE;
+
+  nsAutoString id;
+  id.Append(NS_ConvertUTF8toUTF16(extensionID));
+
+  if (status)
+    eManager->EnableItem(id);
+  else
+    eManager->DisableItem(id);
+
+  return TRUE;
+}
+
+static PRBool
+gtk_moz_embed_common_get_component_list(PRUint32 *length, GList **pluginArray)
+{
+  PRUint32 count = 0;
+  nsIUpdateItem **extensions = nsnull;
+
+#ifdef MOZ_RDF
+  nsCOMPtr<nsIExtensionManager> eManager(do_GetService("@mozilla.org/extensions/manager;1"));
+  if (!eManager)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFService> rdfService;
+  rdfService = do_GetService("@mozilla.org/rdf/rdf-service;1");
+  if (!rdfService)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFDataSource> eDataSource;
+  eManager->GetDatasource(getter_AddRefs(eDataSource));
+  if (!eDataSource)
+    return PR_FALSE;
+
+  eManager->GetItemList(nsIUpdateItem::TYPE_EXTENSION, &count,
+                                &extensions);
+
+  for (PRUint32 i = 0; i < count; i++) {
+    nsIUpdateItem *extension = extensions[i];
+    if (extension) {
+      GtkMozPlugin *list_item = g_new0(GtkMozPlugin, 1);
+      nsAutoString itemName;
+      extension->GetName(itemName);
+      if (itemName.IsEmpty())
+        return PR_FALSE;
+
+      nsAutoString itemId;
+      extension->GetId(itemId);
+      if (itemId.IsEmpty())
+        return PR_FALSE;
+
+      nsCString resourceID("urn:mozilla:item:");
+      resourceID.Append(NS_ConvertUTF16toUTF8(itemId));
+      nsCOMPtr<nsIRDFResource> itemResource;
+      rdfService->GetResource(resourceID, getter_AddRefs(itemResource));
+      if (!itemResource)
+        return PR_FALSE;
+
+      PRUnichar *extAppDisabled = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_APP_DISABLED, &extAppDisabled);
+      if ((extAppDisabled) && (nsDependentString(extAppDisabled).Equals(NS_LITERAL_STRING("true"))))
+        return PR_FALSE;
+
+      list_item->title = g_strdup((gchar *)NS_ConvertUTF16toUTF8(itemName).get());
+      list_item->path =  g_strdup((gchar *)NS_ConvertUTF16toUTF8(itemId).get());
+
+      PRUnichar *itemCreator = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_CREATOR, &itemCreator);
+      if (itemCreator)
+        list_item->creator = g_strdup(NS_ConvertUTF16toUTF8(itemCreator).get());
+
+      PRUnichar *itemDescrption = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_DES, &itemDescrption);
+      if(itemDescrption)
+        list_item->type = g_strdup(NS_ConvertUTF16toUTF8(itemDescrption).get());
+
+      PRUnichar *itemState = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_STATE, &itemState);
+      if ((itemState) && (nsDependentString(itemState).Equals(NS_LITERAL_STRING("true"))))
+        list_item->isDisabled = TRUE;
+      else
+        list_item->isDisabled = FALSE;
+
+      list_item->isPlugin = FALSE;
+      *pluginArray = g_list_append(*pluginArray, list_item);
+      *length = *length + 1;
+    }
+  }
+  return PR_TRUE;
+#else
+  return PR_FALSE;
+#endif
+}
+
+static PRBool
+gtk_moz_embed_common_get_npplugin_list(PRUint32 *aLength, GList **pluginArray)
 {
   nsresult rv;
   nsCOMPtr<nsIPluginManager> pluginMan =
     do_GetService(kPluginManagerCID, &rv);
   if (NS_FAILED(rv)) {
-    g_print("Could not get the plugin manager\n");
-    return -1;
+    NS_WARNING("Could not get the plugin manager\n");
+    return FALSE;
   }
-  pluginMan->ReloadPlugins(PR_TRUE);  //FIXME XXX MEMLEAK
+  pluginMan->ReloadPlugins(PR_FALSE);  //FIXME XXX MEMLEAK
 
   nsCOMPtr<nsIPluginHost> pluginHost =
     do_GetService(kPluginManagerCID, &rv);
-  if (NS_FAILED(rv))
-    return -1;
+  NS_ENSURE_SUCCESS(rv, FALSE);
 
-  PRUint32 aLength;
-  pluginHost->GetPluginCount(&aLength);
+  pluginHost->GetPluginCount(aLength);
 
   if (!pluginArray)
-    return (gint)aLength;
+    return FALSE;
 
-  nsIDOMPlugin **aItems = nsnull;
-  aItems = new nsIDOMPlugin*[aLength];
-  if (!aItems)
-    return -1; //NO MEMORY
+  nsIDOMPlugin **aItems = new nsIDOMPlugin*[*aLength];
+  NS_ENSURE_TRUE(aItems, FALSE); // OUT OF Memory
 
-  rv = pluginHost->GetPlugins(aLength, aItems);
+  rv = pluginHost->GetPlugins(*aLength, aItems);
   if (NS_FAILED(rv)) {
+    for (PRUint32 i = 0; i < *aLength; i++)
+      NS_IF_RELEASE(aItems[i]);
     delete [] aItems;
-    return -1;
+    return FALSE;
   }
 
   nsString string;
-  for (int plugin_index = 0; plugin_index < (gint) aLength; plugin_index++)
-  {
+  for (int plugin_index = 0; plugin_index < (gint) *aLength; plugin_index++) {
     GtkMozPlugin *list_item = g_new0(GtkMozPlugin, 1);
     UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(list_item);
 
     rv = aItems[plugin_index]->GetName(string);
     if (!NS_FAILED(rv))
       list_item->title = g_strdup(NS_ConvertUTF16toUTF8(string).get());
 
     aItems[plugin_index]->GetFilename(string);
     if (!NS_FAILED(rv))
       list_item->path = g_strdup(NS_ConvertUTF16toUTF8(string).get());
 
     nsCOMPtr<nsIDOMMimeType> mimeType;
     PRUint32 mime_count = 0;
     rv = aItems[plugin_index]->GetLength(&mime_count);
     if (NS_FAILED(rv))
       continue;
-    
+
     nsString single_mime;
     string.SetLength(0);
     for (int mime_index = 0; mime_index < mime_count; ++mime_index) {
       rv = aItems[plugin_index]->Item(mime_index, getter_AddRefs(mimeType));
       if (NS_FAILED(rv))
         continue;
       rv = mimeType->GetDescription(single_mime);
       if (!NS_FAILED(rv)) {
+        if(mime_index > 0)
+          string.AppendLiteral(";");
         string.Append(single_mime);
-        string.AppendLiteral(";");
       }
     }
-    
+
     list_item->type = g_strdup(NS_ConvertUTF16toUTF8(string).get());
+    list_item->isPlugin = TRUE;
+
     if (!NS_FAILED(rv))
       *pluginArray = g_list_append(*pluginArray, list_item);
   }
+  for (PRUint32 i = 0; i < *aLength; i++)
+    NS_IF_RELEASE(aItems[i]);
   delete [] aItems;
+  return TRUE;
+}
+
+gint
+gtk_moz_embed_common_get_plugins_list(GList **pluginArray)
+{
+  PRUint32 aLength = 0;
+  gtk_moz_embed_common_get_npplugin_list(&aLength, pluginArray);
+  gtk_moz_embed_common_get_component_list(&aLength, pluginArray);
   return (gint)aLength;
 }
 
 void
 gtk_moz_embed_common_reload_plugins()
 {
   nsresult rv;
   nsCOMPtr<nsIPluginManager> pluginMan =
     do_GetService(kPluginManagerCID, &rv);
   pluginMan->ReloadPlugins(PR_TRUE); //FIXME XXX MEMLEAK
@@ -714,10 +880,142 @@ gtk_moz_embed_common_observe(const gchar
     rv = Observer->Observe((nsISupports*)object, topic, (PRUnichar*)data);
   } else {
     //This is the correct?
     nsCOMPtr<nsIObserverService> obsService =
       do_GetService("@mozilla.org/observer-service;1", &rv);
     if (obsService)
       rv = obsService->NotifyObservers((nsISupports*)object, topic, (PRUnichar*)data);
   }
   return NS_FAILED(rv) ? FALSE : TRUE;
 }
+
+/* Loads all images from all documents (frames and iframes) inside aDoc, recursively */
+static gboolean
+gtk_moz_embed_common_load_images(nsIDOMDocument *aDoc)
+{
+  /* look for img tags */
+  nsresult rv;
+  nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(aDoc, &rv);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  nsCOMPtr<nsIDOMHTMLCollection> imgList;
+  rv = htmlDoc->GetImages(getter_AddRefs(imgList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+  
+  PRUint32 imgCount;
+  rv = imgList->GetLength(&imgCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  guint32 i;
+  for (i = 0; i < imgCount; i++) {
+    nsCOMPtr<nsIDOMNode> imgNode;
+    rv = imgList->Item(i, getter_AddRefs(imgNode));
+    if (NS_FAILED(rv))
+      continue;   
+          
+    nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(imgNode, &rv);
+    if (NS_FAILED(rv))
+      continue;  
+
+    imgContent->ForceReload();
+  }
+  
+  /* Look for iframes */
+  nsCOMPtr<nsIDOMNodeList> iframeList;
+  rv = aDoc->GetElementsByTagName(NS_LITERAL_STRING("iframe"),
+                                  getter_AddRefs(iframeList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+                                  
+  PRUint32 iframeCount;
+  rv = iframeList->GetLength(&iframeCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+  
+  /* look for frames */
+  nsCOMPtr<nsIDOMNodeList> frameList;
+  rv = aDoc->GetElementsByTagName(NS_LITERAL_STRING("frame"),
+                                  getter_AddRefs(frameList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+                                  
+  PRUint32 frameCount;
+  rv = frameList->GetLength(&frameCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  if (iframeCount == 0 && frameCount == 0)
+    return TRUE;
+  
+  for (i = 0; i < iframeCount; i++) {
+    nsCOMPtr<nsIDOMNode> iframeNode;
+    rv = iframeList->Item(i, getter_AddRefs(iframeNode));
+    if (NS_FAILED(rv))
+      continue;
+ 
+    nsCOMPtr<nsIDOMHTMLIFrameElement> iframeElement = do_QueryInterface(iframeNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMDocument> iframeDoc;
+    rv = iframeElement->GetContentDocument(getter_AddRefs(iframeDoc));
+    if (NS_FAILED(rv))
+      continue;
+
+    gtk_moz_embed_common_load_images(iframeDoc);      
+  }
+  
+  for (i = 0; i < frameCount; i++) {
+    nsCOMPtr<nsIDOMNode> frameNode;
+    rv = frameList->Item(i, getter_AddRefs(frameNode));
+    if (NS_FAILED(rv))
+      continue;
+    
+    nsCOMPtr<nsIDOMHTMLFrameElement> frameElement = do_QueryInterface(frameNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMDocument> frameDoc;
+    rv = frameElement->GetContentDocument(getter_AddRefs(frameDoc));
+    if (NS_FAILED(rv))
+      continue;
+          
+    gtk_moz_embed_common_load_images(frameDoc);      
+  }
+ 
+  return TRUE;
+}
+
+gboolean
+gtk_moz_embed_common_set_image_policy(gint policy)
+{
+  if (gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &policy))
+     gtk_moz_embed_common_save_prefs();
+  
+  PRInt32 winCount = 0;    
+  if (EmbedPrivate::sWindowList)
+    winCount = EmbedPrivate::sWindowList->Count();
+
+  for (gint i = 0; i < winCount; i++) {
+    EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>
+                                              (EmbedPrivate::sWindowList->ElementAt(i));
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    nsresult rv = tmpPrivate->mNavigation->GetDocument(getter_AddRefs(domDoc));
+    if (NS_FAILED(rv))
+      continue;  
+
+    switch (policy) {
+    case GTK_MOZ_EMBED_IMAGE_POLICY_ALWAYS:
+      if (!gtk_moz_embed_common_load_images(domDoc));        
+        continue;
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_NEVER:
+      tmpPrivate->Reload(nsIWebNavigation::LOAD_FLAGS_NONE);  
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_NO_EXTERNAL:
+      /* Hide images from external servers */
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_ONLY_LOADED:
+      if (!gtk_moz_embed_common_load_images(domDoc));        
+        continue; 
+      break;
+    }
+  }
+  
+  return TRUE;
+}
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembed_common.h mozilla/embedding/browser/gtk/src/gtkmozembed_common.h
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed_common.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_common.h	2007-10-03 12:03:14.000000000 +0300
@@ -134,20 +134,31 @@ typedef enum
   */
 typedef enum
 {
   GTK_MOZ_EMBED_NO_SECURITY = 0,
   GTK_MOZ_EMBED_LOW_SECURITY,
   GTK_MOZ_EMBED_MEDIUM_SECURITY,
   GTK_MOZ_EMBED_HIGH_SECURITY,
   GTK_MOZ_EMBED_UNKNOWN_SECURITY
 } GtkMozEmbedSecurityMode;
 
+/** GtkMozEmbedImagePolicy
+  * Enumerates image policy
+  */
+typedef enum
+{
+  GTK_MOZ_EMBED_IMAGE_POLICY_ALWAYS = 1,
+  GTK_MOZ_EMBED_IMAGE_POLICY_NEVER,
+  GTK_MOZ_EMBED_IMAGE_POLICY_NO_EXTERNAL,
+  GTK_MOZ_EMBED_IMAGE_POLICY_ONLY_LOADED
+} GtkMozEmbedImagePolicy;
+
 typedef struct _GtkMozCookieList GtkMozCookieList;
 struct _GtkMozCookieList
 {
     gchar *domain; /** < The domain's name */
     gchar *name;   /** < The cookie's name */
     gchar *value;  /** < The cookie's value */
     gchar *path;   /** < The cookie's path */
 };
 typedef struct _GtkMozEmbedCookie GtkMozEmbedCookie;
 struct _GtkMozEmbedCookie
@@ -155,53 +166,56 @@ struct _GtkMozEmbedCookie
     gboolean remember_decision;
     gboolean accept;
 };
 /** @struct GtkMozPlugin.
  * Defines a Mozilla Plugin.
  */
 typedef struct _GtkMozPlugin GtkMozPlugin;
 struct _GtkMozPlugin
 {
     gchar *title;  /** < Plugin title */
+    gchar *creator;  /** < Plugin creator */
     gchar *path;   /** < Plugin path */
     gchar *type;   /** < Plugin type */
     gboolean isDisabled; /** < is plugin enabled */
+    gboolean isPlugin; /** <is plugin or extension*/
 };
 
 typedef struct _GtkMozLogin GtkMozLogin;
 struct _GtkMozLogin
 {
-    const gchar *user; /** < Plugin title */
-    const gchar *pass; /** < Plugin path */
-    const gchar *host; /** < Plugin type */
+    gchar *user; /** < Plugin title */
+    gchar *pass; /** < Plugin path */
+    gchar *host; /** < Plugin type */
     guint index;
 };
 
 GTKMOZEMBED_API(GtkType,    gtk_moz_embed_common_get_type,          (void))
 GTKMOZEMBED_API(GtkWidget*, gtk_moz_embed_common_new,               (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_pref,          (GtkType type, gchar*, gpointer))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_get_pref,          (GtkType type, gchar*, gpointer))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_save_prefs,        (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_login,             (GtkWidget *embed, const gchar* username))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_remove_passwords,  (const gchar *host, const gchar *user, gint index))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_logins,        (const char* uri, GList **list))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_history_list,  (GtkMozHistoryItem **GtkHI))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_remove_history,    (gchar *url, gint time))
 GTKMOZEMBED_API(GSList*,    gtk_moz_embed_common_get_cookie_list,   (void))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_delete_all_cookies,(GSList *deletedCookies))
 GTKMOZEMBED_API(unsigned char*, gtk_moz_embed_common_nsx509_to_raw, (void *nsIX509Ptr, guint *len))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_plugins_list,  (GList **pluginArray))
+GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_extension_status,  (gchar *extensionID, gboolean status))
 GTKMOZEMBED_API(void,       gtk_moz_embed_common_reload_plugins,    (void))
 GTKMOZEMBED_API(guint,      gtk_moz_embed_common_get_security_mode, (guint sec_state))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_clear_cache,       (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_observe,           (const gchar*, gpointer, const gchar*, gunichar*))
-
+GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_image_policy,  (gint policy))
 
 /*typedef struct _GtkMozEmbedCertContext GtkMozEmbedCertContext;
 struct _GtkMozEmbedCertContext
 {
     GObject * cert;
     guint message;
     GtkWidget *parent;
 };*/
 #ifdef __cplusplus
 }
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembed_download.cpp mozilla/embedding/browser/gtk/src/gtkmozembed_download.cpp
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed_download.cpp	2007-05-01 02:52:37.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_download.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -55,29 +55,32 @@
 #include "nsReadableUtils.h"
 #else
 #include "nsStringAPI.h"
 #endif
 
 #include "gtkmozembedmarshal.h"
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_TOOLKIT_STRING(x) NS_ConvertUTF16toUTF8(x).get()
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
-static void gtk_moz_embed_download_set_latest_object(GtkObject *o);
+// static stuff
+static void gtk_moz_embed_download_set_latest_object (GtkObject *o);
 static GtkObject *latest_download_object = nsnull;
+static gboolean  is_restart = FALSE;
 
 // class and instance initialization
 guint moz_embed_download_signals[DOWNLOAD_LAST_SIGNAL] = { 0 };
 static void gtk_moz_embed_download_class_init(GtkMozEmbedDownloadClass *klass);
 static void gtk_moz_embed_download_init(GtkMozEmbedDownload *embed);
 static void gtk_moz_embed_download_destroy(GtkObject *object);
 GtkObject * gtk_moz_embed_download_new(void);
+GtkObject * gtk_moz_embed_download_new_with_url_filename (const gchar *url, const gchar *filename);
 
 // GtkObject + class-related functions
 GtkType
 gtk_moz_embed_download_get_type(void)
 {
   static GtkType moz_embed_download_type = 0;
   if (!moz_embed_download_type)
   {
     static const GtkTypeInfo moz_embed_download_info =
     {
@@ -175,110 +178,162 @@ gtk_moz_embed_download_destroy(GtkObject
   if (downloadPrivate) {
     delete downloadPrivate;
     embed->data = NULL;
   }
 }
 
 GtkObject *
 gtk_moz_embed_download_new(void)
 {
   GtkObject *instance = (GtkObject *) gtk_type_new(gtk_moz_embed_download_get_type());
+  g_return_val_if_fail(instance, NULL);
   gtk_moz_embed_download_set_latest_object(instance);
+  gtk_moz_embed_download_set_restart_flag (FALSE);
 
   return instance;
 }
 
 GtkObject *
+gtk_moz_embed_download_new_with_url_filename (const gchar *url, const gchar *filename)
+{
+  g_return_val_if_fail((url && filename), nsnull);
+  GtkObject *instance = (GtkObject *) gtk_type_new(gtk_moz_embed_download_get_type());
+  g_return_val_if_fail(instance, NULL);
+
+  GtkMozEmbedDownload *download = GTK_MOZ_EMBED_DOWNLOAD(instance);
+  gtk_moz_embed_download_set_latest_object(instance);
+  gtk_moz_embed_download_set_restart_flag (TRUE);
+
+  EmbedDownloadMgr::CreateIncrementalDownload(url, filename);
+  //gtk_moz_embed_load_url (EmbedCommon::GetAnyLiveWidget(), url);
+
+  return instance;
+}
+
+
+GtkObject *
 gtk_moz_embed_download_get_latest_object(void)
 {
   return latest_download_object;
 }
 
 static void
 gtk_moz_embed_download_set_latest_object(GtkObject *obj)
 {
   latest_download_object = obj;
   return ;
 }
 
+gboolean
+gtk_moz_embed_download_get_restart_flag (void)
+{
+  return is_restart;
+}
+
+void
+gtk_moz_embed_download_set_restart_flag (gboolean restart)
+{
+  is_restart = restart;
+  return ;
+}
+
 void
 gtk_moz_embed_download_do_command(GtkMozEmbedDownload *item, guint command)
 {
+  g_return_if_fail(item);
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return;
 
   if (command == GTK_MOZ_EMBED_DOWNLOAD_CANCEL) {
-    download_priv->launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
-    download_priv->launcher->SetWebProgressListener(nsnull);
+    if (download_priv->launcher) {
+      download_priv->isCanceled = PR_TRUE;
+      download_priv->launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+      download_priv->launcher->SetWebProgressListener(nsnull);
+    } else if (download_priv->incr_launcher) {
+      download_priv->isCanceled = PR_TRUE;
+      item->is_paused = FALSE;
+      download_priv->incr_launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+    }
 
     return;
   }
 
-  if (command == GTK_MOZ_EMBED_DOWNLOAD_RESUME) {
-    download_priv->request->Resume();
-    download_priv->is_paused = FALSE;
-
+  if (command == GTK_MOZ_EMBED_DOWNLOAD_RESUME && item->is_paused) {
+    if (download_priv->incr_launcher) {
+      EmbedDownloadMgr::CreateIncrementalDownload(download_priv);
+
+    } else
+    if (download_priv->request) { 
+        download_priv->request->Resume();
+    }
+    item->is_paused = FALSE;
     return;
   }
 
-  if (command == GTK_MOZ_EMBED_DOWNLOAD_PAUSE) {
-    if (download_priv->request) {
-      download_priv->request->Suspend();
-      download_priv->is_paused = TRUE;
+  if (command == GTK_MOZ_EMBED_DOWNLOAD_PAUSE && !item->is_paused) {
+    if (download_priv->incr_launcher) {
+      download_priv->incr_launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+    } else {
+      if (download_priv->request) {
+        download_priv->request->Suspend();
+      }
     }
-
+    item->is_paused = TRUE;
     return;
   }
 
   if (command == GTK_MOZ_EMBED_DOWNLOAD_RELOAD) {
     if (download_priv->gtkMozEmbedParentWidget) {}
   }
   // FIXME: missing GTK_MOZ_EMBED_DOWNLOAD_STORE and GTK_MOZ_EMBED_DOWNLOAD_RESTORE implementation.
 }
 
 gchar*
 gtk_moz_embed_download_get_file_name(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, nsnull); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return nsnull;
 
-  return (gchar *) download_priv->file_name;
+  return (gchar *) item->file_name;
 }
 
 gchar*
 gtk_moz_embed_download_get_url(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, nsnull); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return nsnull;
 
   // FIXME : 'server' is storing the wrong value. See EmbedDownloadMgr.cpp l. 189.
-  return (gchar *) download_priv->server;
+  return (gchar *) item->server;
 }
 
 glong
 gtk_moz_embed_download_get_progress(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, -1); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return -1;
 
-  return (glong) download_priv->downloaded_size;
+  return (glong) item->downloaded_size;
 }
 
 glong
 gtk_moz_embed_download_get_file_size(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, -1); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return -1;
 
-  return (glong) download_priv->file_size;
+  return (glong) item->file_size;
 }
-
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembed_download.h mozilla/embedding/browser/gtk/src/gtkmozembed_download.h
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed_download.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_download.h	2007-10-03 12:03:15.000000000 +0300
@@ -75,22 +75,32 @@ extern "C" {
 #define GTK_MOZ_EMBED_DOWNLOAD(obj)             GTK_CHECK_CAST((obj), GTK_TYPE_MOZ_EMBED_DOWNLOAD, GtkMozEmbedDownload)
 #define GTK_MOZ_EMBED_DOWNLOAD_CLASS(klass)     GTK_CHECK_CLASS_CAST((klass), GTK_TYPE_MOZ_EMBED_DOWNLOAD, GtkMozEmbedDownloadClass)
 #define GTK_IS_MOZ_EMBED_DOWNLOAD(obj)          GTK_CHECK_TYPE((obj), GTK_TYPE_MOZ_EMBED_DOWNLOAD)
 #define GTK_IS_MOZ_EMBED_DOWNLOAD_CLASS(klass)  GTK_CHECK_CLASS_TYPE((klass), GTK_TYPE_MOZ_EMBED_DOWNLOAD)
 
 typedef struct _GtkMozEmbedDownload      GtkMozEmbedDownload;
 typedef struct _GtkMozEmbedDownloadClass GtkMozEmbedDownloadClass;
 
 struct _GtkMozEmbedDownload
 {
-  GtkObject  object;
-  void *data;
+  GtkObject   object;
+  void        *data;
+
+  char*       file_name;             /** < The file's name */
+  char*       file_name_with_path;   /** < The file's name */
+  const char* server;                /** < The server's name */
+  const char* file_type;             /** < The file's type */
+  const char* handler_app;           /** < The application's name */
+  gulong      file_size;             /** < The file's size */
+  glong       downloaded_size;       /** < The download's size */
+  gboolean    is_paused;             /** < If download is paused or not */
+  gboolean    open_with;             /** < If the file can be opened by other application */
 };
 
 struct _GtkMozEmbedDownloadClass
 {
   GtkObjectClass parent_class;
   void (*started) (GtkMozEmbedDownload* item, gchar **file_name_with_path);
   void (*completed) (GtkMozEmbedDownload* item);
   void (*error) (GtkMozEmbedDownload* item);
   void (*aborted) (GtkMozEmbedDownload* item);
   void (*progress) (GtkMozEmbedDownload* item, gulong downloaded_bytes, gulong total_bytes, gdouble kbps);
@@ -99,25 +109,25 @@ struct _GtkMozEmbedDownloadClass
 typedef enum
 {
   GTK_MOZ_EMBED_DOWNLOAD_RESUME,
   GTK_MOZ_EMBED_DOWNLOAD_CANCEL,
   GTK_MOZ_EMBED_DOWNLOAD_PAUSE,
   GTK_MOZ_EMBED_DOWNLOAD_RELOAD,
   GTK_MOZ_EMBED_DOWNLOAD_STORE,
   GTK_MOZ_EMBED_DOWNLOAD_RESTORE
 } GtkMozEmbedDownloadActions;
 
-GTKMOZEMBED_API(GtkType,      gtk_moz_embed_download_get_type,           (void))
-GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new,                (void))
-GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_get_latest_object,  (void))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_file_name,      (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_url,            (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_progress,       (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_file_size,      (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(GtkType,      gtk_moz_embed_download_get_type,             (void))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new,                  (void))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new_with_url_filename,(const gchar *url, const gchar *filename))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_get_latest_object,    (void))
+GTKMOZEMBED_API(gboolean,     gtk_moz_embed_download_get_restart_flag,     (void))
+GTKMOZEMBED_API(void,         gtk_moz_embed_download_set_restart_flag,     (gboolean))
+GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_file_name,        (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_url,              (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_progress,         (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_file_size,        (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,           (GtkMozEmbedDownload *item, guint command))
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
 #endif /* gtkmozembed_download_h */
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembed_glue.cpp mozilla/embedding/browser/gtk/src/gtkmozembed_glue.cpp
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembed_glue.cpp	2007-05-13 17:52:52.000000000 +0300
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_glue.cpp	2007-10-03 12:03:15.000000000 +0300
@@ -47,20 +47,21 @@
 #include "gtkmozembed_download.h"
 #include "nsXPCOMGlue.h"
 
 #ifndef XPCOM_GLUE
 #error This file only makes sense when XPCOM_GLUE is defined.
 #endif
 
 #define GTKMOZEMBED2_FUNCTIONS \
   GTKF(gtk_moz_embed_download_get_type) \
   GTKF(gtk_moz_embed_download_new) \
+  GTKF(gtk_moz_embed_download_new_with_url_filename) \
   GTKF(gtk_moz_embed_common_get_type) \
   GTKF(gtk_moz_embed_common_new) \
   GTKF(gtk_moz_embed_common_set_pref) \
   GTKF(gtk_moz_embed_common_get_pref) \
   GTKF(gtk_moz_embed_common_save_prefs) \
   GTKF(gtk_moz_embed_common_remove_passwords) \
   GTKF(gtk_moz_embed_common_get_history_list) \
   GTKF(gtk_moz_embed_get_zoom_level) \
   GTKF(gtk_moz_embed_set_zoom_level) \
   GTKF(gtk_moz_embed_find_text) \
@@ -69,21 +70,23 @@
   GTKF(gtk_moz_embed_get_context_info) \
   GTKF(gtk_moz_embed_get_selection) \
   GTKF(gtk_moz_embed_get_doc_info) \
   GTKF(gtk_moz_embed_insert_text) \
   GTKF(gtk_moz_embed_common_nsx509_to_raw) \
   GTKF(gtk_moz_embed_common_observe) \
   GTKF(gtk_moz_embed_get_shistory_list) \
   GTKF(gtk_moz_embed_get_shistory_index) \
   GTKF(gtk_moz_embed_shistory_goto_index) \
   GTKF(gtk_moz_embed_get_server_cert) \
-  GTKF(gtk_moz_embed_get_nsIWebBrowser)
+  GTKF(gtk_moz_embed_get_nsIWebBrowser) \
+  GTKF(gtk_moz_embed_get_text) \
+  GTKF(gtk_moz_embed_do_command)
 
 #define GTKMOZEMBED_FUNCTIONS \
   GTKF(gtk_moz_embed_get_type) \
   GTKF(gtk_moz_embed_new) \
   GTKF(gtk_moz_embed_push_startup) \
   GTKF(gtk_moz_embed_pop_startup) \
   GTKF(gtk_moz_embed_set_path) \
   GTKF(gtk_moz_embed_set_comp_path) \
   GTKF(gtk_moz_embed_set_profile_path) \
   GTKF(gtk_moz_embed_load_url) \
diff -ruN -p -u10 mozilla/embedding/browser/gtk/src.orig/gtkmozembedprivate.h mozilla/embedding/browser/gtk/src/gtkmozembedprivate.h
--- mozilla/embedding/browser/gtk/src.orig/gtkmozembedprivate.h	2007-03-23 17:56:57.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/gtkmozembedprivate.h	2007-10-03 12:03:15.000000000 +0300
@@ -85,24 +85,29 @@ enum {
   CONFIRM_EX,
   PROMPT,
   PROMPT_AUTH,
   SELECT,
   DOWNLOAD_REQUEST,
   DOM_MOUSE_SCROLL,
   DOM_MOUSE_LONG_PRESS,
   DOM_FOCUS,
   DOM_BLUR,
   UPLOAD_DIALOG,
+  FILE_UPLOAD_STARTED,
+  FILE_UPLOAD_FINISHED,
   ICON_CHANGED,
   MAILTO,
   NETWORK_ERROR,
   RSS_REQUEST,
+  DOM_WINDOW_FOCUS,
+  DOM_WINDOW_BLUR,
+  DOM_CONTENT_BLOCKED,
   EMBED_LAST_SIGNAL
 };
 
 //  DOM_MOUSE_MOVE,
 extern guint moz_embed_signals[EMBED_LAST_SIGNAL];
 
 #if 0
 enum {
   COMMON_CERT_DIALOG,
   COMMON_CERT_PASSWD_DIALOG,
diff -ruN -p -U8 mozilla/embedding/browser/gtk/src.orig/EmbedWindowCreator.cpp mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp
--- mozilla/embedding/browser/gtk/src.orig/EmbedWindowCreator.cpp	2007-11-21 23:42:25.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp	2007-11-22 03:34:14.000000000 +0200
@@ -36,43 +36,47 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "EmbedWindowCreator.h"
 #include "EmbedPrivate.h"
 #include "EmbedWindow.h"
+#include "nsWidgetsCID.h"
+#include "nsAppShellCID.h"
+#include "nsIAppShellService.h"
+#include "nsIXULWindow.h"
+static NS_DEFINE_CID(kAppShellCID,               NS_APPSHELL_CID);
 
 // in order to create orphaned windows
 #include "gtkmozembedprivate.h"
 
 EmbedWindowCreator::EmbedWindowCreator(PRBool *aOpenBlockPtr)
 {
   mOpenBlock = aOpenBlockPtr;
+  mAppShell = do_GetService(kAppShellCID);
 }
 
 EmbedWindowCreator::~EmbedWindowCreator()
 {
 }
 
-NS_IMPL_ISUPPORTS1(EmbedWindowCreator, nsIWindowCreator)
+NS_IMPL_ISUPPORTS2(EmbedWindowCreator, nsIWindowCreator, nsIWindowCreator2)
 
 NS_IMETHODIMP
 EmbedWindowCreator::CreateChromeWindow(nsIWebBrowserChrome *aParent,
                PRUint32 aChromeFlags,
                nsIWebBrowserChrome **_retval)
 {
   NS_ENSURE_ARG_POINTER(_retval);
 
-  if (mOpenBlock) {
-    if (*mOpenBlock == PR_TRUE) {
+  if (mOpenBlock && *mOpenBlock) {
       *mOpenBlock = PR_FALSE;
       return NS_ERROR_FAILURE;
-    }
   }
   GtkMozEmbed *newEmbed = nsnull;
 
   // No parent?  Ask via the singleton object instead.
   if (!aParent) {
     gtk_moz_embed_single_create_window(&newEmbed,
                (guint)aChromeFlags);
   } else {
@@ -103,15 +107,76 @@ EmbedWindowCreator::CreateChromeWindow(n
 
   // set the chrome flag on the new window if it's a chrome open
   if (aChromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME)
     newEmbedPrivate->mIsChrome = PR_TRUE;
 
   *_retval = static_cast<nsIWebBrowserChrome *>
             (newEmbedPrivate->mWindow);
 
-  if (*_retval) {
+  if (*_retval)
     NS_ADDREF(*_retval);
-    return NS_OK;
+
+  return *_retval ? NS_OK : NS_ERROR_FAILURE;
+
+//  PRBool cancel;
+//  return CreateChromeWindow2(aParent, aChromeFlags, 0, 0, &cancel, _retval);
+}
+
+NS_IMETHODIMP
+EmbedWindowCreator::CreateChromeWindow2(nsIWebBrowserChrome *aParent,
+                                        PRUint32 aChromeFlags,
+                                        PRUint32 aContextFlags,
+                                        nsIURI *aURI,
+                                        PRBool *aCancel,
+                                        nsIWebBrowserChrome **_retval)
+{
+  NS_ENSURE_ARG_POINTER(aCancel);
+  NS_ENSURE_ARG_POINTER(_retval);
+  *aCancel = PR_FALSE;
+  *_retval = 0;
+
+  if (mOpenBlock && *mOpenBlock) {
+      *mOpenBlock = PR_FALSE;
+      *aCancel = PR_TRUE;
+      return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIXULWindow> newWindow;
+  nsCOMPtr<nsIXULWindow> xulParent;
+
+  if (aParent) {
+    xulParent = do_GetInterface(aParent);
+    NS_ASSERTION(xulParent, "window created using non-XUL parent. that's unexpected, but may work.");
+
+    if (xulParent)
+      xulParent->CreateNewWindow(aChromeFlags, mAppShell, getter_AddRefs(newWindow));
+    // And if it fails, don't try again without a parent. It could fail
+    // intentionally (bug 115969).
+  }
+
+  if (!newWindow) { // try using basic methods:
+    /* You really shouldn't be making dependent windows without a parent.
+      But unparented modal (and therefore dependent) windows happen
+      in our codebase, so we allow it after some bellyaching: */
+    if (aChromeFlags & nsIWebBrowserChrome::CHROME_DEPENDENT)
+      NS_WARNING("dependent window created without a parent");
+
+    nsCOMPtr<nsIAppShellService> appShell(do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
+    if (!appShell)
+        return NS_ERROR_FAILURE;
+
+    appShell->CreateTopLevelWindow(xulParent, 0, aChromeFlags,
+                                   nsIAppShellService::SIZE_TO_CONTENT,
+                                   nsIAppShellService::SIZE_TO_CONTENT,
+                                   mAppShell, getter_AddRefs(newWindow));
+  }
+
+  // if anybody gave us anything to work with, use it
+  if (newWindow) {
+    newWindow->SetContextFlags(aContextFlags);
+    nsCOMPtr<nsIInterfaceRequestor> thing(do_QueryInterface(newWindow));
+    if (thing)
+        CallGetInterface(thing.get(), _retval);
   }
 
-  return NS_ERROR_FAILURE;
+  return *_retval ? NS_OK : NS_ERROR_FAILURE;
 }
diff -ruN -p -U8 mozilla/embedding/browser/gtk/src.orig/EmbedWindowCreator.h mozilla/embedding/browser/gtk/src/EmbedWindowCreator.h
--- mozilla/embedding/browser/gtk/src.orig/EmbedWindowCreator.h	2007-01-03 00:23:53.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedWindowCreator.h	2007-11-22 03:34:14.000000000 +0200
@@ -35,24 +35,28 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __EmbedWindowCreator_h
 #define __EmbedWindowCreator_h
 
-#include "nsIWindowCreator.h"
+#include "nsIWindowCreator2.h"
+#include "nsIAppShell.h"
+#include "nsCOMPtr.h"
 
-class EmbedWindowCreator : public nsIWindowCreator
+class EmbedWindowCreator : public nsIWindowCreator2
 {
  public:
   EmbedWindowCreator(PRBool *aOpenBlockPtr);
   virtual ~EmbedWindowCreator();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIWINDOWCREATOR
+  NS_DECL_NSIWINDOWCREATOR2
 
  private:
   PRBool *mOpenBlock;
+  nsCOMPtr<nsIAppShell> mAppShell;
 };
 
 #endif /* __EmbedWindowCreator_h */
diff -ruN -p -U8 mozilla/embedding/browser/gtk/src.orig/Makefile.in mozilla/embedding/browser/gtk/src/Makefile.in
--- mozilla/embedding/browser/gtk/src.orig/Makefile.in	2007-11-21 23:42:24.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/Makefile.in	2007-11-22 03:34:44.000000000 +0200
@@ -114,16 +114,17 @@ REQUIRES	= xpcom \
 		  nkcache \
 		  pipboot \
 		  plugin \
 		  extensions \
 		  rdf \
 		  toolkitcomps \
 		  view \
 		  commandhandler \
+		  appshell \
 		  $(NULL)
 
 ifdef ACCESSIBILITY
 REQUIRES        += accessibility
 endif
 
 CPPSRCS		= \
 		gtkmozembed2.cpp \
--- mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.cpp.orig	2007-11-23 11:21:38.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.cpp	2007-11-23 11:21:17.000000000 +0200
@@ -297,17 +297,17 @@ EmbedPasswordMgr::Init()
   NS_ASSERTION(obsService, "No observer service");
   obsService->AddObserver(this, NS_FORMSUBMIT_SUBJECT, PR_TRUE);
   nsCOMPtr<nsIWebProgress> progress = do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
   NS_ASSERTION(progress, "No web progress service");
   progress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_DOCUMENT);
   // Now read in the signon file
   nsCString signonFile;
   mPrefBranch->GetCharPref("SignonFileName", getter_Copies(signonFile));
-  NS_ASSERTION(signonFile, "Fallback for signon filename not present");
+  NS_ASSERTION(!signonFile.IsEmpty(), "Fallback for signon filename not present");
   NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(mSignonFile));
   NS_ENSURE_TRUE(mSignonFile, NS_ERROR_FAILURE);
   mSignonFile->AppendNative(signonFile);
   ReadPasswords(mSignonFile);
   return NS_OK;
 }
 
 /* static */ PRBool
--- mozilla/embedding/browser/gtk/src/EmbedGtkTools.cpp.orig	2007-03-23 17:46:31.000000000 +0200
+++ mozilla/embedding/browser/gtk/src/EmbedGtkTools.cpp	2007-11-24 15:39:48.000000000 +0200
@@ -41,36 +41,34 @@
 #ifndef MOZILLA_INTERNAL_API
 #include "nsServiceManagerUtils.h"
 #endif
 #include "EmbedPrivate.h"
 
 GtkWidget * GetGtkWidgetForDOMWindow(nsIDOMWindow* aDOMWindow)
 {
   nsCOMPtr<nsIWindowWatcher> wwatch = do_GetService("@mozilla.org/embedcomp/window-watcher;1");
-  if (!aDOMWindow)
-    return NULL;
+  if (!aDOMWindow || !wwatch)
+    return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
   nsCOMPtr<nsIWebBrowserChrome> chrome;
   wwatch->GetChromeForWindow(aDOMWindow, getter_AddRefs(chrome));
-  if (!chrome) {
+  if (!chrome)
     return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
-  }
 
   nsCOMPtr<nsIEmbeddingSiteWindow> siteWindow = nsnull;
   siteWindow = do_QueryInterface(chrome);
 
-  if (!siteWindow) {
+  if (!siteWindow)
     return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
-  }
 
   GtkWidget* parentWidget;
   siteWindow->GetSiteWindow((void**)&parentWidget);
   if (GTK_IS_WIDGET(parentWidget))
     return parentWidget;
-  return NULL;
+  return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
 }
 
 GtkWindow * GetGtkWindowForDOMWindow(nsIDOMWindow* aDOMWindow)
 {
   GtkWidget* parentWidget = GetGtkWidgetForDOMWindow(aDOMWindow);
   if (!parentWidget)
     return NULL;
   GtkWidget* gtkWin = gtk_widget_get_toplevel(parentWidget);
