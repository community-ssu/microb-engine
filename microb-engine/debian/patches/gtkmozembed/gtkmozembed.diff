Index: mozilla/embedding/browser/gtk/src/EmbedCertificates.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedCertificates.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedCertificates.cpp
@@ -84,18 +84,18 @@
 EmbedCertificates::~EmbedCertificates()
 {
 }
 
 NS_IMPL_THREADSAFE_ADDREF(EmbedCertificates)
 NS_IMPL_THREADSAFE_RELEASE(EmbedCertificates)
 NS_INTERFACE_MAP_BEGIN(EmbedCertificates)
 NS_INTERFACE_MAP_ENTRY(nsITokenPasswordDialogs)
-NS_INTERFACE_MAP_ENTRY(nsIBadCertListener)
 #ifdef BAD_CERT_LISTENER2
+NS_INTERFACE_MAP_ENTRY(nsIBadCertListener)
 NS_INTERFACE_MAP_ENTRY(nsIBadCertListener2)
 #endif
 NS_INTERFACE_MAP_ENTRY(nsICertificateDialogs)
 NS_INTERFACE_MAP_ENTRY(nsIClientAuthDialogs)
 NS_INTERFACE_MAP_ENTRY(nsICertPickDialogs)
 NS_INTERFACE_MAP_ENTRY(nsITokenDialogs)
 NS_INTERFACE_MAP_ENTRY(nsIGeneratingKeypairInfoDialogs)
 NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMCryptoDialogs)
@@ -125,16 +125,17 @@
                           const PRUnichar *tokenName,
                           PRUnichar **_password,
                           PRBool* _canceled)
 {
   *_canceled = PR_FALSE;
   return NS_OK;
 }
 
+#ifdef BAD_CERT_LISTENER2
 NS_IMETHODIMP
 EmbedCertificates::ConfirmUnknownIssuer(nsIInterfaceRequestor *socketInfo,
                                    nsIX509Cert *cert, PRInt16 *outAddType,
                                    PRBool *_retval)
 {
   *outAddType = ADD_TRUSTED_FOR_SESSION;
   *_retval    = PR_TRUE;
   return NS_OK;
@@ -158,33 +159,32 @@
 }
 
 NS_IMETHODIMP
 EmbedCertificates::NotifyCrlNextupdate(nsIInterfaceRequestor *socketInfo,
                                   const nsACString &targetURL, nsIX509Cert *cert)
 {
   return NS_OK;
 }
+#endif
 
 NS_IMETHODIMP
 EmbedCertificates::CrlImportStatusDialog(nsIInterfaceRequestor *ctx, nsICRLInfo *crl)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedCertificates::ConfirmDownloadCACert(nsIInterfaceRequestor *ctx,
                                     nsIX509Cert *cert,
                                     PRUint32 *_trust,
                                     PRBool *_retval)
 {
-  *_retval = PR_TRUE;
-  *_trust |= nsIX509CertDB::TRUSTED_SSL;
-  *_trust |= nsIX509CertDB::TRUSTED_EMAIL;
-  *_trust |= nsIX509CertDB::TRUSTED_OBJSIGN;
+  *_retval = PR_FALSE;
+  *_trust = nsIX509CertDB::UNTRUSTED;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedCertificates::NotifyCACertExists(nsIInterfaceRequestor *ctx)
 {
   return NS_OK;
 }
@@ -266,21 +266,30 @@
   PRUint32 aCount,
   PRUnichar **aTokenChosen,
   PRBool *aCanceled)
 {
   *aCanceled = PR_FALSE;
   return NS_OK;
 }
 
+#ifndef BAD_CERT_LISTENER2
+NS_IMETHODIMP
+EmbedCertificates::DisplayProtectedAuth(nsIInterfaceRequestor *aCtx,
+                                        nsIProtectedAuthThread *runnable)
+{
+    return NS_OK;
+}
+#endif
+
 /* boolean ConfirmKeyEscrow (in nsIX509Cert escrowAuthority); */
 NS_IMETHODIMP
 EmbedCertificates::ConfirmKeyEscrow(nsIX509Cert *escrowAuthority, PRBool *_retval)
 {
-  *_retval = PR_TRUE;
+  *_retval = PR_FALSE;
   return NS_OK;
 }
 
 #ifdef BAD_CERT_LISTENER2
 NS_IMETHODIMP
 EmbedCertificates::ConfirmBadCertificate(
   nsIInterfaceRequestor *ctx,
   nsIX509Cert *cert,
@@ -291,17 +300,17 @@
   nsresult rv;
   gpointer pCert = NULL;
   guint messint = 0;
   nsCOMPtr<nsIDOMWindow> parent(do_GetInterface(ctx));
 
   GtkMozEmbedCommon * common = nsnull;
   GtkMozEmbed *parentWidget = GTK_MOZ_EMBED(GetGtkWidgetForDOMWindow(parent));
 
-  if (!parentWidget) {
+  if (parentWidget) {
     EmbedCommon * embedcommon = EmbedCommon::GetInstance();
     if (embedcommon)
       common = GTK_MOZ_EMBED_COMMON(embedcommon->mCommon);
   }
 
   if (!(aError & nsIX509Cert::VERIFIED_OK)) {
     pCert = (gpointer)cert;
     messint = GTK_MOZ_EMBED_CERT_VERIFIED_OK;
Index: mozilla/embedding/browser/gtk/src/EmbedCertificates.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedCertificates.h
+++ mozilla/embedding/browser/gtk/src/EmbedCertificates.h
@@ -39,18 +39,18 @@
  *
  * ***** END LICENSE BLOCK ***** */
 /**
  * Derived from nsNSSDialogs http://landfill.mozilla.org/mxr-test/seamonkey/source/security/manager/pki/src/nsNSSDialogs.h
  */
 #ifndef __EmbedCertificates_h
 #define __EmbedCertificates_h
 #include "nsITokenPasswordDialogs.h"
-#include "nsIBadCertListener.h"
 #ifdef BAD_CERT_LISTENER2
+#include "nsIBadCertListener.h"
 #include "nsIBadCertListener2.h"
 #endif
 #include "nsICertificateDialogs.h"
 #include "nsIClientAuthDialogs.h"
 #include "nsICertPickDialogs.h"
 #include "nsITokenDialogs.h"
 #include "nsIDOMCryptoDialogs.h"
 #include "nsIGenKeypairInfoDlg.h"
@@ -58,32 +58,32 @@
 #include "nsIStringBundle.h"
 #define EMBED_CERTIFICATES_CID \
   { 0x518e071f, 0x1dd2, 0x11b2, \
   { 0x93, 0x7e, 0xc4, 0x5f, 0x14, 0xde, 0xf7, 0x78 }}
 #define EMBED_CERTIFICATES_DESCRIPTION "Certificates Listener Impl"
 class EmbedPrivate;
 class EmbedCertificates
 : public nsITokenPasswordDialogs,
-  public nsIBadCertListener,
 #ifdef BAD_CERT_LISTENER2
+  public nsIBadCertListener,
   public nsIBadCertListener2,
 #endif
   public nsICertificateDialogs,
   public nsIClientAuthDialogs,
   public nsICertPickDialogs,
   public nsITokenDialogs,
   public nsIDOMCryptoDialogs,
   public nsIGeneratingKeypairInfoDialogs
 {
   public:
     NS_DECL_ISUPPORTS
     NS_DECL_NSITOKENPASSWORDDIALOGS
-    NS_DECL_NSIBADCERTLISTENER
 #ifdef BAD_CERT_LISTENER2
+    NS_DECL_NSIBADCERTLISTENER
     NS_DECL_NSIBADCERTLISTENER2
 #endif
     NS_DECL_NSICERTIFICATEDIALOGS
     NS_DECL_NSICLIENTAUTHDIALOGS
     NS_DECL_NSICERTPICKDIALOGS
     NS_DECL_NSITOKENDIALOGS
     NS_DECL_NSIDOMCRYPTODIALOGS
     NS_DECL_NSIGENERATINGKEYPAIRINFODIALOGS
Index: mozilla/embedding/browser/gtk/src/EmbedContentListener.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContentListener.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedContentListener.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -102,17 +102,17 @@
 
   // otherwise  ...
   return_val = FALSE;
 
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[OPEN_URI],
                   specString.get(), &return_val);
 
-  *aAbortOpen = return_val;
+  *aAbortOpen = !!return_val;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedContentListener::DoContent(const char         *aContentType,
                                 PRBool             aIsContentPreferred,
                                 nsIRequest         *aRequest,
Index: mozilla/embedding/browser/gtk/src/EmbedContentListener.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContentListener.h
+++ mozilla/embedding/browser/gtk/src/EmbedContentListener.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
Index: mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.cpp
@@ -12,17 +12,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
+ * Oleg Romashin.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -32,16 +32,17 @@
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
+
 #include "EmbedContextMenuInfo.h"
 #include "nsIImageLoadingContent.h"
 #include "imgILoader.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMHTMLElement.h"
 #include "nsIDOMHTMLHtmlElement.h"
 #include "nsIDOMHTMLAnchorElement.h"
@@ -68,48 +69,58 @@
 #include "nsIDOMNSHTMLInputElement.h"
 #include "nsIDOMNSHTMLTextAreaElement.h"
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMNSHTMLDocument.h"
 #include "nsIDOMNodeList.h"
 #include "nsISelection.h"
 #include "nsIDocument.h"
+#include "nsIWidget.h"
+#include "nsIScrollableView.h"
+#include "nsIScrollableViewProvider.h"
+#include "nsIView.h"
+#include "nsIDOMWindowInternal.h"
 #include "EmbedPrivate.h"
+#include "nsGUIEvent.h"
 #include <stdio.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <glib.h>
 #if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
 #include "nsIFrame.h"
+#include "nsIScrollableFrame.h"
 #endif
+#include "gfxIImageFrame.h"
 
 //*****************************************************************************
 // class EmbedContextMenuInfo
 //*****************************************************************************
 EmbedContextMenuInfo::EmbedContextMenuInfo(EmbedPrivate *aOwner) : mCtxFrameNum(-1), mEmbedCtxType(0)
 {
   mOwner = aOwner;
   mEventNode = nsnull;
   mCtxDocument = nsnull;
   mNSHHTMLElement = nsnull;
-  mNSHHTMLElementSc = nsnull;
   mCtxEvent = nsnull;
   mEventNode = nsnull;
   mFormRect = nsRect(0,0,0,0);
+  mIsScrollableElement = PR_TRUE;
+  mCtxScrollable = nsnull;
+  mIsJSHandledElement = 0;
 }
 
 EmbedContextMenuInfo::~EmbedContextMenuInfo(void)
 {
   mEventNode = nsnull;
   mCtxDocument = nsnull;
   mNSHHTMLElement = nsnull;
-  mNSHHTMLElementSc = nsnull;
   mCtxEvent = nsnull;
   mEventNode = nsnull;
+  mCtxScrollable = nsnull;
 }
 
 NS_IMPL_ADDREF(EmbedContextMenuInfo)
 NS_IMPL_RELEASE(EmbedContextMenuInfo)
 NS_INTERFACE_MAP_BEGIN(EmbedContextMenuInfo)
 NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
@@ -133,16 +144,39 @@
         mCtxDocTitle = doc->GetDocumentTitle();
       return NS_OK;
     }
   }
   return NS_ERROR_FAILURE;
 }
 
 nsresult
+EmbedContextMenuInfo::GetJSHandledInfo(nsIDOMEvent *aEvent, PRInt32 *aIsJSHandled)
+{
+  if (!aEvent && !aIsJSHandled)
+    return NS_ERROR_FAILURE;
+  nsresult rv = NS_ERROR_FAILURE;
+#ifdef JS_EVENT_INFO
+  if (aEvent) {
+    PRUint32 flags;
+    rv = aEvent->GetPrivateFlags(&flags);
+    if (NS_SUCCEEDED(rv) && (flags & NS_PRIV_EVENT_FLAG_SCRIPT)) {
+      mIsJSHandledElement = aIsJSHandled?*aIsJSHandled:1;
+    } else {
+      mIsJSHandledElement = 0;
+      rv = NS_ERROR_FAILURE;
+    }
+  }
+  if (aIsJSHandled)
+    *aIsJSHandled = mIsJSHandledElement;
+#endif
+  return rv;
+}
+
+nsresult
 EmbedContextMenuInfo::GetFormControlType(nsIDOMEvent* aEvent)
 {
   if (!aEvent)
     return NS_OK;
   nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
   nsCOMPtr<nsIDOMEventTarget> target;
   nsevent->GetOriginalTarget(getter_AddRefs(target));
   //    mOrigTarget  = target;
@@ -180,21 +214,24 @@
   return NS_ERROR_FAILURE;
 }
 
 nsresult
 EmbedContextMenuInfo::SetFormControlType(nsIDOMEventTarget *originalTarget)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsCOMPtr<nsIContent> targetContent = do_QueryInterface(originalTarget);
+  if(!targetContent)
+    return rv;
+
   mCtxFormType = 0;
 #ifdef MOZILLA_1_8_BRANCH
-  if (targetContent && targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
+  if (targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
 #else
-  if (targetContent && targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
+  if (targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
 #endif
     nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(targetContent));
     if (formControl) {
       mCtxFormType = formControl->GetType();
       rv = NS_OK;
       //#ifdef MOZ_LOGGING
       switch (mCtxFormType) {
       case NS_FORM_BUTTON_BUTTON:
@@ -203,71 +240,73 @@
         break;
       case NS_FORM_BUTTON_SUBMIT:
         break;
       case NS_FORM_INPUT_BUTTON:
         break;
       case NS_FORM_INPUT_CHECKBOX:
         break;
       case NS_FORM_INPUT_FILE:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
         break;
       case NS_FORM_INPUT_HIDDEN:
         break;
       case NS_FORM_INPUT_RESET:
         break;
       case NS_FORM_INPUT_IMAGE:
         break;
       case NS_FORM_INPUT_PASSWORD:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
         mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IPASSWORD;
         break;
       case NS_FORM_INPUT_RADIO:
         break;
       case NS_FORM_INPUT_SUBMIT:
         break;
       case NS_FORM_INPUT_TEXT:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
         break;
       case NS_FORM_LABEL:
         break;
       case NS_FORM_OPTION:
         break;
       case NS_FORM_OPTGROUP:
         break;
       case NS_FORM_LEGEND:
         break;
       case NS_FORM_SELECT:
+        mIsScrollableElement = PR_FALSE;
         break;
       case NS_FORM_TEXTAREA:
-        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+        mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
         break;
       case NS_FORM_OBJECT:
         break;
       default:
         break;
       }
-      if (mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      if (mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
         PRBool rdonly = PR_FALSE;
         if (mCtxFormType == NS_FORM_TEXTAREA) {
           nsCOMPtr<nsIDOMHTMLTextAreaElement> input;
           input = do_QueryInterface(mEventNode, &rv);
           if (!NS_FAILED(rv) && input)
             rv = input->GetReadOnly(&rdonly);
-          if (!NS_FAILED(rv) && rdonly) {
+          if (!NS_FAILED(rv) && rdonly)
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_ROINPUT;
-          }
+          else
+            mIsScrollableElement = PR_FALSE;
         } else {
           nsCOMPtr<nsIDOMHTMLInputElement> input;
           input = do_QueryInterface(mEventNode, &rv);
           if (!NS_FAILED(rv) && input)
             rv = input->GetReadOnly(&rdonly);
-          if (!NS_FAILED(rv) && rdonly) {
+          if (!NS_FAILED(rv) && rdonly)
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_ROINPUT;
-          }
+          else
+            mIsScrollableElement = PR_FALSE;
         }
       }
       //#endif
     }
   }
   return rv;
 }
 
@@ -322,30 +361,38 @@
   if (rv == NS_OK) {
     return NS_ConvertUTF16toUTF8(cString).get();
   }
   return nsnull;
 }
 
 nsresult
 EmbedContextMenuInfo::CheckDomImageElement(nsIDOMNode *node, nsString& aHref,
-                                           PRInt32 *aWidth, PRInt32 *aHeight)
+                                           PRInt32 *aWidth, PRInt32 *aHeight, PRUint32 *aSize)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsCOMPtr<nsIDOMHTMLImageElement> image =
     do_QueryInterface(node, &rv);
-  if (image) {
-    rv = image->GetSrc(aHref);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    rv = image->GetWidth(aWidth);
-    rv = image->GetHeight(aHeight);
-    rv = NS_OK;
-  }
+  NS_ENSURE_TRUE(image, rv);
+  rv = image->GetSrc(aHref);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = NS_OK;
+  image->GetWidth(aWidth);
+  image->GetHeight(aHeight);
+  if (!aSize) return rv;
+  nsCOMPtr<imgIRequest> request;
+  GetImageRequest(getter_AddRefs(request), node);
+  NS_ENSURE_TRUE(request, rv);
+  nsCOMPtr<imgIContainer> imgCont;
+  request->GetImage(getter_AddRefs(imgCont));
+  NS_ENSURE_TRUE(imgCont, rv);
+  nsCOMPtr<gfxIImageFrame> currentFrame;
+  imgCont->GetCurrentFrame(getter_AddRefs(currentFrame));
+  NS_ENSURE_TRUE(currentFrame, rv);
+  currentFrame->GetImageDataLength(aSize);
   return rv;
 }
 
 nsresult
 EmbedContextMenuInfo::GetImageRequest(imgIRequest **aRequest, nsIDOMNode *aDOMNode)
 {
   NS_ENSURE_ARG(aDOMNode);
   NS_ENSURE_ARG_POINTER(aRequest);
@@ -360,43 +407,34 @@
 
 nsresult
 EmbedContextMenuInfo::CheckDomHtmlNode(nsIDOMNode *aNode)
 {
   nsresult rv = NS_ERROR_FAILURE;
   nsString uTag;
   PRUint16 dnode_type;
 
-  nsCOMPtr<nsIDOMNode> node;
-  if (!aNode && mEventNode)
-    node = mEventNode;
-  nsCOMPtr<nsIDOMHTMLElement> element  = do_QueryInterface(node, &rv);
-  if (!element) {
-    element = do_QueryInterface(mOrigNode, &rv);
-    if (element) {
-      node = mOrigNode;
-      element  = do_QueryInterface(node, &rv);
-    }
-  }
+  nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode, &rv);
+  NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
 
   rv = node->GetNodeType(&dnode_type);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  if (!((nsIDOMNode::ELEMENT_NODE == dnode_type) && element)) {
+  if (!((nsIDOMNode::ELEMENT_NODE == dnode_type))) {
     return rv;
   }
   nsCOMPtr<nsIDOMNSHTMLElement> nodeElement = do_QueryInterface(node, &rv);
   if (NS_SUCCEEDED(rv) && nodeElement) {
     mNSHHTMLElement = nodeElement;
   } else {
     mNSHHTMLElement = nsnull;
   }
-  rv = element->GetLocalName(uTag);
+  rv = node->GetLocalName(uTag);
   if (NS_FAILED(rv)) {
     return rv;
   }
   if (uTag.LowerCaseEqualsLiteral("object")) {
   }
   else if (uTag.LowerCaseEqualsLiteral("html")) {
   }
   else if (uTag.LowerCaseEqualsLiteral("a")) {
@@ -410,16 +448,23 @@
         if (childNode) {
           PRInt32 width, height;
           rv = CheckDomImageElement(node, mCtxImgHref, &width, &height);
           if (NS_SUCCEEDED(rv))
             mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IMAGE;
         }
       } else if (StringBeginsWith(mCtxHref, NS_LITERAL_STRING("mailto:"))) {
         mEmbedCtxType |= GTK_MOZ_EMBED_CTX_EMAIL;
+      } else {
+        nsCOMPtr<nsIDOMNode> childNode;
+        node->GetFirstChild(getter_AddRefs(childNode));
+        if (childNode) {
+          childNode->GetLocalName(uTag);
+          mIsScrollableElement = !uTag.LowerCaseEqualsLiteral("div");
+        }
       }
     }
   }
   else if (uTag.LowerCaseEqualsLiteral("area")) {
     nsCOMPtr<nsIDOMHTMLAreaElement> area = do_QueryInterface(node, &rv);
     if (NS_SUCCEEDED(rv) && area) {
       PRBool aNoHref = PR_FALSE;
       rv = area->GetNoHref(&aNoHref);
@@ -437,62 +482,198 @@
     if (NS_SUCCEEDED(rv))
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IMAGE;
   } else {
     rv = NS_ERROR_FAILURE;
   }
   return rv;
 }
 
-nsresult
-EmbedContextMenuInfo::UpdateContextData(void *aEvent)
+#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
+static nsIFrame*
+GetParentFrameToScroll(nsPresContext* aPresContext, nsIFrame* aFrame)
 {
-  NS_ENSURE_ARG_POINTER(aEvent);
+  if (!aPresContext || !aFrame)
+    return nsnull;
+
+#ifdef ROOT_SCROLL_FRAME
+  if (aFrame->GetStyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED)
+    return aPresContext->GetPresShell()->GetRootScrollFrame();
+#endif
+
+  return aFrame->GetParent();
+}
+
+static PRBool
+ViewIsScrollable(nsIScrollableView* aScrollView)
+{
+  // Can it crash?
+  nsIFrame *frame = static_cast<nsIFrame*>(aScrollView->View()->GetParent()->GetClientData());
+  NS_ENSURE_TRUE(frame, PR_FALSE);
+  nsIScrollableFrame *sf = nsnull;
+  CallQueryInterface(frame, &sf);
+  NS_ENSURE_TRUE(sf, PR_FALSE);
+  nsPresContext::ScrollbarStyles ss = sf->GetScrollbarStyles();
+  if (NS_STYLE_OVERFLOW_HIDDEN != ss.mHorizontal
+      || NS_STYLE_OVERFLOW_HIDDEN != ss.mVertical)
+    return PR_TRUE;
+  return PR_FALSE;
+}
+
+static nsresult
+FindScrollableView(nsPresContext* aPresContext,
+                   nsIFrame* aTargetFrame,
+                   nsIScrollableViewProvider* *aSvp)
+{
+  nsIScrollableView* scrollView = nsnull;
+  nsIFrame* scrollFrame = aTargetFrame;
+  PRBool passToParent = PR_TRUE;
+  for (; scrollFrame && passToParent;
+       scrollFrame = GetParentFrameToScroll(aPresContext, scrollFrame)) {
+    scrollView = nsnull;
+    nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(scrollFrame);
+    if (svp)
+      scrollView = svp->GetScrollableView();
+
+    if (!scrollView)
+      continue;
+    else
+      if (aSvp)
+        NS_ADDREF(*aSvp = svp);
+
+    if (!ViewIsScrollable(scrollView))
+      continue;
+
+    // Check if the scrollable view can be scrolled any further.
+    nscoord lineHeight;
+    scrollView->GetLineHeight(&lineHeight);
+    if (lineHeight != 0) {
+      PRBool canScroll;
+      if ((NS_SUCCEEDED(scrollView->CanScroll(PR_FALSE, PR_TRUE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_TRUE, PR_TRUE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_TRUE, PR_FALSE, canScroll)) && canScroll)
+          || (NS_SUCCEEDED(scrollView->CanScroll(PR_FALSE, PR_FALSE, canScroll)) && canScroll)
+         ) {
+        passToParent = PR_FALSE;
+        return NS_OK;
+      }
+    }
+  }
+  return NS_ERROR_FAILURE;
+}
+#endif  /* FIXED_BUG347731 */
+
+static PRBool
+IsScrollableWindow(nsIDOMWindow *win)
+{
+  if (!win) return PR_FALSE;
+  nsCOMPtr<nsIDOMWindowInternal> winint = do_QueryInterface(win);
+  if (!winint) return PR_FALSE;
+  PRInt32 maxScrollX = 0, maxScrollY = 0;
+  winint->GetScrollMaxX(&maxScrollX);
+  winint->GetScrollMaxY(&maxScrollY);
+  return maxScrollX || maxScrollY;
+}
+
+inline PRBool
+EmbedContextMenuInfo::GetScrollableViewByNode(void)
+{
+  if (!mEventNode) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
+    NS_ENSURE_TRUE(mCtxDomWindow, PR_FALSE);
+    nsCOMPtr<nsIDOMDocument> document;
+    mCtxDomWindow->GetDocument(getter_AddRefs(document));
+    NS_ENSURE_TRUE(document, PR_FALSE);
+    nsCOMPtr<nsIDOMElement> el;
+    document->GetDocumentElement(getter_AddRefs(el));
+    mEventNode = do_QueryInterface(el);
+    NS_ENSURE_TRUE(mEventNode, PR_FALSE);
+  }
   nsresult rv;
-  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface((nsISupports*)aEvent, &rv);
-  if (NS_FAILED(rv) || !event)
-    return NS_ERROR_FAILURE;
-  return UpdateContextData(event);
+  nsIFrame* frame = nsnull;
+  mCtxScrollable = nsnull;
+  nsCOMPtr<nsIContent> iContent = do_QueryInterface(mEventNode, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_FALSE);
+  nsCOMPtr<nsIPresShell> presShell;
+  nsCOMPtr<nsIDOMDocument> doc;
+  mEventNode->GetOwnerDocument(getter_AddRefs(doc));
+  nsCOMPtr<nsIDocument> iDoc = do_QueryInterface(doc);
+  NS_ENSURE_TRUE(iDoc, PR_FALSE);
+  presShell = iDoc->GetPrimaryShell();
+  NS_ENSURE_TRUE(presShell, PR_FALSE);
+  frame = presShell->GetPrimaryFrameFor(iContent);
+  NS_ENSURE_TRUE(frame, PR_FALSE);
+  nsPresContext *context = presShell->GetPresContext();
+  NS_ENSURE_TRUE(context, PR_FALSE);
+  nsCOMPtr<nsIScrollableViewProvider> svp;
+#if defined(FIXED_BUG347731) || !defined(MOZ_ENABLE_LIBXUL)
+  if (NS_SUCCEEDED(FindScrollableView(context, frame, getter_AddRefs(svp)))
+      && svp && (mCtxScrollable = svp))
+    return PR_TRUE;
+#endif
+  return PR_FALSE;
 }
 
-nsresult
-EmbedContextMenuInfo::GetElementForScroll(nsIDOMEvent *aEvent)
+PRBool
+EmbedContextMenuInfo::GetScrollableView(void)
 {
-  if (!aEvent) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
-  nsCOMPtr<nsIDOMEventTarget> target;
-  nsevent->GetOriginalTarget(getter_AddRefs(target));
-  if (!target) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMNode> targetDOMNode(do_QueryInterface(target));
-  if (!targetDOMNode) return NS_ERROR_UNEXPECTED;
-  nsCOMPtr<nsIDOMDocument> targetDOMDocument;
-  targetDOMNode->GetOwnerDocument(getter_AddRefs(targetDOMDocument));
-  if (!targetDOMDocument) return NS_ERROR_UNEXPECTED;
-  return GetElementForScroll(targetDOMDocument);
+  if (GetScrollableViewByNode())
+    return PR_TRUE;
+  if (!mCtxDomWindow) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
+  }
+  NS_ENSURE_TRUE(mCtxDomWindow, PR_FALSE);
+  nsCOMPtr<nsIDOMWindow> cur = mCtxDomWindow;
+  nsCOMPtr<nsIDOMWindow> parent = nsnull;
+  if (IsScrollableWindow(cur)) {
+    mCtxScrollable = cur;
+    return PR_TRUE;
+  }
+  while (cur && cur != parent) {
+    cur->GetParent(getter_AddRefs(parent));
+    cur = parent;
+    if (IsScrollableWindow(cur)) {
+      mCtxScrollable = cur;
+      return PR_TRUE;
+    }
+  }
+  return PR_FALSE;
 }
 
 nsresult
-EmbedContextMenuInfo::GetElementForScroll(nsIDOMDocument *targetDOMDocument)
+EmbedContextMenuInfo::ScrollScrollableView(PRInt32 subX, PRInt32 subY)
 {
-  nsCOMPtr<nsIDOMElement> targetDOMElement;
-  targetDOMDocument->GetDocumentElement(getter_AddRefs(targetDOMElement));
-  if (!targetDOMElement) return NS_ERROR_UNEXPECTED;
-  nsString bodyName(NS_LITERAL_STRING("body"));
-  nsCOMPtr<nsIDOMNodeList> bodyList;
-  targetDOMElement->GetElementsByTagName(bodyName, getter_AddRefs(bodyList));
-  PRUint32 i = 0;
-  bodyList->GetLength(&i);
-  if (i) {
-    nsCOMPtr<nsIDOMNode> domBodyNode;
-    bodyList->Item(0, getter_AddRefs(domBodyNode));
-    if (!domBodyNode) return NS_ERROR_UNEXPECTED;
-    mNSHHTMLElementSc = do_QueryInterface(domBodyNode);
-    if (!mNSHHTMLElementSc) return NS_ERROR_UNEXPECTED;
+  nsresult rv;
+  nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(mCtxScrollable, &rv);
+  if (svp && !NS_FAILED(rv)) {
+    nsIScrollableView* scrollView = svp->GetScrollableView();
+    NS_ENSURE_TRUE(scrollView, NS_ERROR_FAILURE);
+    return scrollView->ScrollByPixels(subX, subY);
   }
-  return NS_OK;
+
+  nsCOMPtr<nsIDOMWindow> win = do_QueryInterface(mCtxScrollable, &rv);
+  if (!win || NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  return win->ScrollBy(subX, subY);
+}
+
+nsresult
+EmbedContextMenuInfo::UpdateContextData(void *aEvent)
+{
+  NS_ENSURE_ARG_POINTER(aEvent);
+  nsresult rv;
+  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface((nsISupports*)aEvent, &rv);
+  if (NS_FAILED(rv) || !event)
+    return NS_ERROR_FAILURE;
+  return UpdateContextData(event);
 }
 
 nsresult
 EmbedContextMenuInfo::UpdateContextData(nsIDOMEvent *aDOMEvent)
 {
   if (mCtxEvent == aDOMEvent)
     return NS_OK;
 
@@ -533,47 +714,54 @@
   mEmbedCtxType = GTK_MOZ_EMBED_CTX_NONE;
   mOrigNode = originalNode;
   if (mOrigNode) {
     nsString SOrigNode;
     mOrigNode->GetNodeName(SOrigNode);
     if (SOrigNode.EqualsLiteral("#document"))
       return NS_OK;
     if (SOrigNode.EqualsLiteral("xul:thumb")
-        || SOrigNode.EqualsLiteral("xul:slider")
-        || SOrigNode.EqualsLiteral("xul:scrollbarbutton")
         || SOrigNode.EqualsLiteral("xul:vbox")
         || SOrigNode.EqualsLiteral("xul:spacer")) {
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = PR_FALSE;
+      return NS_OK;
+    } else
+    if (SOrigNode.EqualsLiteral("xul:slider")) {
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = 2;
+      return NS_OK;
+    } else
+    if (SOrigNode.EqualsLiteral("xul:scrollbarbutton")) {
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_XUL;
+      mIsScrollableElement = 3;
       return NS_OK;
     }
   }
+  mIsScrollableElement = PR_TRUE;
   if (mCtxEvent)
     rv = mCtxEvent->GetTarget(getter_AddRefs(mEventTarget));
   if (NS_FAILED(rv) || !mEventTarget) {
     return NS_OK;
   }
   nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(mEventTarget, &rv);
   mEventNode = eventNode;
   //Frame Stuff
   nsCOMPtr<nsIDOMDocument> domDoc;
   if (mEventNode)
     rv = mEventNode->GetOwnerDocument(getter_AddRefs(domDoc));
   if (!NS_SUCCEEDED(rv) || !domDoc) {
     //  return NS_OK;
   }
   if (NS_SUCCEEDED(rv) && domDoc && mCtxDocument != domDoc) {
     mCtxDocument = domDoc;
-    mNSHHTMLElementSc = nsnull;
     nsCOMPtr<nsIDOM3Document> docuri = do_QueryInterface(mCtxDocument);
     docuri->GetDocumentURI(mCtxURI);
     NS_ENSURE_ARG_POINTER(mOwner);
-    nsCOMPtr<nsIWebBrowser> webBrowser;
-    mOwner->mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
-    webBrowser->GetContentDOMWindow(getter_AddRefs(mCtxDomWindow));
+    mOwner->GetDOMWindowByNode(mEventNode, getter_AddRefs(mCtxDomWindow));
     nsCOMPtr<nsIDOMDocument> mainDocument;
     mCtxDomWindow->GetDocument(getter_AddRefs(mainDocument));
     if (!mainDocument) {
       return NS_OK;
     }
     mCtxFrameNum = -1;
     if (mainDocument != domDoc) {
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_IFRAME;
@@ -583,18 +771,20 @@
   nsCOMPtr<nsIDOMElement> targetDOMElement;
   mCtxDocument->GetDocumentElement(getter_AddRefs(targetDOMElement));
   if (!targetDOMElement) return NS_ERROR_UNEXPECTED;
   nsCOMPtr<nsIDOMNSHTMLDocument> htmlDoc = do_QueryInterface(mCtxDocument);
   if (htmlDoc) {
     nsString DMode;
     htmlDoc->GetDesignMode(DMode);
     if (DMode.EqualsLiteral("on")) {
-      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT;
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_INPUT_TEXT;
       mEmbedCtxType |= GTK_MOZ_EMBED_CTX_RICHEDIT;
+      mEmbedCtxType |= GTK_MOZ_EMBED_CTX_MULTILINE;
+      mIsScrollableElement = PR_FALSE;
     }
   }
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(mCtxDocument);
   if (!doc)
     return NS_OK;
   nsIPresShell *presShell = doc->GetPrimaryShell();
   if (!presShell)
     return NS_OK;
@@ -613,22 +803,31 @@
   }
   if (frame) {
     mFormRect = frame->GetScreenRectExternal();
   }
 #endif
   if (NS_SUCCEEDED(SetFormControlType(mEventTarget))) {
     return NS_OK;
   }
-  CheckDomHtmlNode();
-  nsCOMPtr<nsIDOMNode> node = mEventNode;
+
+  nsCOMPtr<nsIDOMNode> node;
   nsCOMPtr<nsIDOMNode> parentNode;
+
+  nsCOMPtr<nsIDOMHTMLElement> element = do_QueryInterface(mEventNode, &rv);
+  if (element)
+    node = do_QueryInterface(mEventNode, &rv);
+  else /* Fallback to XML/XSLT content */
+    node = do_QueryInterface(mOrigNode, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  CheckDomHtmlNode(node);
   node->GetParentNode(getter_AddRefs(parentNode));
   node = parentNode;
   while (node) {
-    if (NS_FAILED(CheckDomHtmlNode()))
+    if (NS_FAILED(CheckDomHtmlNode(node)))
       break;
     node->GetParentNode(getter_AddRefs(parentNode));
     node = parentNode;
   }
   mEmbedCtxType |= GTK_MOZ_EMBED_CTX_DOCUMENT;
   return NS_OK;
 }
Index: mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedContextMenuInfo.h
+++ mozilla/embedding/browser/gtk/src/EmbedContextMenuInfo.h
@@ -14,17 +14,17 @@
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is the Mozilla browser.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
+ * Oleg Romashin.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -64,36 +64,40 @@
 public:
   EmbedContextMenuInfo(EmbedPrivate *aOwner);
   virtual ~EmbedContextMenuInfo(void);
   NS_DECL_ISUPPORTS
   nsresult          GetFormControlType(nsIDOMEvent *aDOMEvent);
   nsresult          UpdateContextData(nsIDOMEvent *aDOMEvent);
   nsresult          UpdateContextData(void *aEvent);
   const char*       GetSelectedText();
-  nsresult          GetElementForScroll(nsIDOMDocument *targetDOMDocument);
-  nsresult          GetElementForScroll(nsIDOMEvent *aEvent);
   nsresult          CheckDomImageElement(nsIDOMNode *node, nsString& aHref,
-                                       PRInt32 *aWidth, PRInt32 *aHeight);
+                                         PRInt32 *aWidth, PRInt32 *aHeight, PRUint32 *aSize = nsnull);
   nsresult          GetImageRequest(imgIRequest **aRequest, nsIDOMNode *aDOMNode);
   nsString          GetCtxDocTitle(void) { return mCtxDocTitle; }
+  PRBool            GetScrollableView(void);
+  PRBool            GetScrollableViewByNode(void);
+  nsresult          ScrollScrollableView(PRInt32 subX, PRInt32 subY);
+  nsresult          GetJSHandledInfo(nsIDOMEvent *aEvent, PRInt32 *aIsJSHandled = nsnull);
 
 
   PRInt32                 mX, mY, mObjWidth, mObjHeight, mCtxFrameNum;
   nsString                mCtxURI, mCtxHref, mCtxImgHref;
   PRUint32                mEmbedCtxType;
   PRInt32 mCtxFormType;
   nsCOMPtr<nsIDOMNode>    mEventNode;
   nsCOMPtr<nsIDOMEventTarget> mEventTarget;
   nsCOMPtr<nsIDOMDocument>mCtxDocument;
   nsRect               mFormRect;
   nsCOMPtr<nsIDOMWindow>  mCtxDomWindow;
   nsCOMPtr<nsIDOMEvent>   mCtxEvent;
   nsCOMPtr<nsIDOMNSHTMLElement> mNSHHTMLElement;
-  nsCOMPtr<nsIDOMNSHTMLElement> mNSHHTMLElementSc;
+  nsISupports            *mCtxScrollable;
+  PRInt32                 mIsScrollableElement;
+  PRInt32                 mIsJSHandledElement;
 private:
   nsresult          SetFrameIndex();
   nsresult          SetFormControlType(nsIDOMEventTarget *originalTarget);
   nsresult          CheckDomHtmlNode(nsIDOMNode *aNode = nsnull);
 
   EmbedPrivate           *mOwner;
   nsCOMPtr<nsIDOMNode>    mOrigNode;
   nsString                mCtxDocTitle;
Index: mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedDownloadMgr.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.cpp
@@ -11,22 +11,24 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
+ *   Oleg Romashin <romaxa@gmail.com>
+ *   Antonio Gomes <tonikitoo@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -65,102 +67,193 @@
 #include "nsNetError.h"
 #include "nsIStreamListener.h"
 #include "nsIFile.h"
 #include "nsILocalFile.h"
 #include "nsNetCID.h"
 #include <unistd.h>
 #include "gtkmozembed_download.h"
 #include "nsIIOService.h"
+#include "nsIProgressEventSink.h"
+#include "nsNetUtil.h"
+#include "nsIDOMWindowInternal.h"
+#include "nsIPrompt.h"
+#ifdef MOZ_RDF
+#include "nsIExtensionManager.h"
+#endif
+#ifdef MOZ_XPINSTALL
+#include "nsIXPIProgressDialog.h"
+#endif
+#include "nsIPrefBranch2.h"
+#include "nsIPrefService.h"
 
 #define UNKNOWN_FILE_SIZE -1
 
 class EmbedDownloadMgr;
+
 class ProgressListener : public nsIWebProgressListener2
+#ifdef MOZ_RDF
+                       , public nsIAddonUpdateListener
+#endif
 {
 public:
-    ProgressListener(EmbedDownload *aDownload):mDownload(aDownload)
+    ProgressListener(EmbedDownload *aDownload):mDownload(aDownload),mObserveIndex(-1),mProgressState(-1)
     {
+      mObserverService = do_GetService("@mozilla.org/observer-service;1");
     }
 
     ~ProgressListener(void)
     {
     }
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIWEBPROGRESSLISTENER
     NS_DECL_NSIWEBPROGRESSLISTENER2
+#ifdef MOZ_RDF
+    NS_DECL_NSIADDONUPDATELISTENER
+#endif
 
     EmbedDownload *mDownload;
+    PRInt32 mObserveIndex;
+    PRInt32 mProgressState;
+    nsCOMPtr<nsIObserverService> mObserverService;
 };
 
-NS_IMPL_ISUPPORTS2(ProgressListener, nsIWebProgressListener2, nsIWebProgressListener)
-NS_IMPL_ISUPPORTS1(EmbedDownloadMgr, nsIHelperAppLauncherDialog)
+class FetchObserver : public nsIRequestObserver
+                      ,public nsIProgressEventSink
+{
+public:
+    FetchObserver(EmbedDownload *aDownload):mDownload(aDownload)
+    {
+    }
+
+    ~FetchObserver(void)
+    {
+    }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIREQUESTOBSERVER
+    NS_DECL_NSIPROGRESSEVENTSINK
+    EmbedDownload *mDownload;
+};
+
+NS_IMPL_ISUPPORTS2(FetchObserver, nsIRequestObserver, nsIProgressEventSink)
+
+NS_IMPL_ADDREF(ProgressListener)
+NS_IMPL_RELEASE(ProgressListener)
+NS_INTERFACE_MAP_BEGIN(ProgressListener)
+NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener2)
+NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
+#ifdef MOZ_RDF
+NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAddonUpdateListener)
+NS_INTERFACE_MAP_ENTRY(nsIAddonUpdateListener)
+#endif
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(EmbedDownloadMgr)
+NS_IMPL_RELEASE(EmbedDownloadMgr)
+NS_INTERFACE_MAP_BEGIN(EmbedDownloadMgr)
+NS_INTERFACE_MAP_ENTRY(nsIHelperAppLauncherDialog)
+#ifdef MOZ_XPINSTALL
+NS_INTERFACE_MAP_ENTRY(nsIXPIDialogService)
+#endif
+NS_INTERFACE_MAP_END
+
+EmbedDownload::EmbedDownload(void)
+  : parent(nsnull), gtkMozEmbedParentWidget(nsnull), launcher(nsnull), request(nsnull), isCanceled(PR_FALSE)
+{
+}
+
+EmbedDownload::~EmbedDownload(void)
+{
+  isCanceled = PR_TRUE;
+  request = nsnull;
+}
 
 EmbedDownloadMgr::EmbedDownloadMgr(void)
 {
+  mDownload = nsnull;
+  mObserverService = do_GetService("@mozilla.org/observer-service;1");
 }
 
 EmbedDownloadMgr::~EmbedDownloadMgr(void)
 {
+  // if (!mDownload || !mDownload->parent)
+  //   return;
+  // GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  // temp->is_paused = TRUE;
+  // temp->data = NULL;
 }
 
-static gchar *
-RemoveSchemeFromFilePath(gchar *path)
+static char *
+RemoveSchemeFromFilePath(const char *path)
 {
-  gchar *new_path = path;
-
-  if (!strncmp(path, "file://", 7)) {
-    /* XXX this should really look for the first non / after file:/ instead of
-     * assuming file://tmp v. file:///tmp
-     */
-    new_path = g_strdup(path+sizeof("file:/"));
-    g_free(path);
-  }
-    
-  return new_path;
+  return g_strdup(g_str_has_prefix(path, "file://")?&path[7]:path);
 }
 
 NS_IMETHODIMP
 EmbedDownloadMgr::Show(nsIHelperAppLauncher *aLauncher,
                        nsISupports *aContext,
                        PRUint32 aForced)
 {
   nsresult rv;
+  GtkObject* instance;
 
   /* create a Download object */
-  GtkObject* instance = gtk_moz_embed_download_new();
+  instance = gtk_moz_embed_download_get_restart_flag () ?
+                gtk_moz_embed_download_get_latest_object () : gtk_moz_embed_download_new();
+
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
   mDownload = (EmbedDownload *) GTK_MOZ_EMBED_DOWNLOAD(instance)->data;
+  if (!mDownload)
+    return NS_ERROR_FAILURE;
   mDownload->parent = instance;
 
   rv = GetDownloadInfo(aLauncher, aContext);
 
   /* Retrieve GtkMozEmbed object from DOM Window */
   nsCOMPtr<nsIDOMWindow> parentDOMWindow = do_GetInterface(aContext);
   mDownload->gtkMozEmbedParentWidget = GetGtkWidgetForDOMWindow(parentDOMWindow);
 
+  // avoiding some casts.
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+
+  mObserverService->NotifyObservers(nsnull, "dl-ask", NS_ConvertUTF8toUTF16(temp->server).get());
+
+  PRBool useDownloadDir = PR_FALSE;
+  nsCOMPtr<nsIPrefBranch2> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
+  rv = prefs->GetBoolPref("browser.download.useDownloadDir", &useDownloadDir);
+
   gtk_signal_emit(GTK_OBJECT(mDownload->gtkMozEmbedParentWidget),
                   moz_embed_signals[DOWNLOAD_REQUEST],
-                  mDownload->server,
-                  mDownload->file_name,
-                  mDownload->file_type,
-                  (gulong) mDownload->file_size,
-                   1);
+                  temp->server,
+                  temp->file_name,
+                  temp->file_type,
+                  (gulong) temp->file_size,
+                   useDownloadDir?2:1);
 
   gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                   moz_embed_download_signals[DOWNLOAD_STARTED_SIGNAL],
-                  &mDownload->file_name_with_path);
+                  & temp->file_name_with_path);
 
-  if (!mDownload->file_name_with_path) {
+  if (!temp->file_name_with_path) {
     gtk_moz_embed_download_do_command(GTK_MOZ_EMBED_DOWNLOAD(mDownload->parent),
                                       GTK_MOZ_EMBED_DOWNLOAD_CANCEL);
     return NS_OK;
   }
+  mObserverService->NotifyObservers(nsnull, "dl-start", nsnull);
 
-  mDownload->file_name_with_path = RemoveSchemeFromFilePath(mDownload->file_name_with_path);
+  char * path = RemoveSchemeFromFilePath(temp->file_name_with_path);
+  NS_Free(temp->file_name_with_path);
+  temp->file_name_with_path = path;
 
   return aLauncher->SaveToDisk(nsnull, PR_FALSE);
 }
 
 NS_METHOD
 EmbedDownloadMgr::GetDownloadInfo(nsIHelperAppLauncher *aLauncher,
                                   nsISupports *aContext)
 {
@@ -191,37 +284,64 @@
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
   nsCAutoString spec;
   rv = uri->Resolve(NS_LITERAL_CSTRING("."), spec);
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
 
+  PRInt64 mContentLength;
+#ifdef GET_CONTENT_LENGTH
+  rv = aLauncher->GetContentLength(&mContentLength);
+  if (NS_FAILED(rv))
+    return rv;
+#endif
+
+  /* avoiding some casts */
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+
   /* Sets download object to keep control of each download. */
   mDownload->launcher = aLauncher;
-  mDownload->downloaded_size = -1;
-  mDownload->file_name = g_strdup((gchar *) tempFileName.get());
-  mDownload->server = g_strconcat(spec.get(), (gchar *) mDownload->file_name, NULL);
-  mDownload->file_type = g_strdup(mimeType.get());
-  mDownload->file_size = UNKNOWN_FILE_SIZE;
+  mDownload->incr_launcher = nsnull;
+  temp->downloaded_size = -1;
+  temp->file_name = g_strdup((gchar *) tempFileName.get());
+  temp->server = g_strconcat(spec.get(), (gchar *) temp->file_name, NULL);
+  temp->file_type = g_strdup(mimeType.get());
+  temp->file_size = (mContentLength > 0)? mContentLength : UNKNOWN_FILE_SIZE;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP EmbedDownloadMgr::PromptForSaveToFile(nsIHelperAppLauncher *aLauncher,
                                                     nsISupports *aWindowContext,
                                                     const PRUnichar *aDefaultFile,
                                                     const PRUnichar *aSuggestedFileExtension,
                                                     nsILocalFile **_retval)
 {
   *_retval = nsnull;
 
   nsCAutoString filePath;
-  filePath.Assign(mDownload->file_name_with_path);
+  filePath.Assign(((GtkMozEmbedDownload *) mDownload->parent)->file_name_with_path);
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  if (temp) {
+    if (temp->file_name && !strlen(temp->file_name)) {
+      NS_Free(temp->file_name);
+      if (!NS_ConvertUTF16toUTF8(aDefaultFile).IsEmpty())
+        temp->file_name = NS_strdup(NS_ConvertUTF16toUTF8(aDefaultFile).get());
+      else
+        temp->file_name = g_strdup_printf("_temp_file%s", NS_ConvertUTF16toUTF8(aSuggestedFileExtension).get());
+      if (temp->file_name_with_path) {
+        filePath.Append(temp->file_name);
+        NS_Free(temp->file_name_with_path);
+        temp->file_name_with_path = NS_strdup(filePath.get());
+      }
+    }
+  }
 
   nsCOMPtr<nsILocalFile> destFile;
   NS_NewNativeLocalFile(filePath,
                         PR_TRUE,
                         getter_AddRefs(destFile));
   if (!destFile)
     return NS_ERROR_OUT_OF_MEMORY;
 
@@ -244,17 +364,17 @@
                                                    nsISupports *aWindowContext,
                                                    const PRUnichar *aDefaultFile,
                                                    const PRUnichar *aSuggestedFileExtension,
                                                    nsIURI **_retval)
 {
   nsresult rv;
 
   nsCAutoString file_path;
-  file_path.Assign (mDownload->file_name_with_path);
+  file_path.Assign (((GtkMozEmbedDownload *) mDownload->parent)->file_name_with_path);
   nsCOMPtr<nsIIOService> ios (do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios)
     return FALSE;
 
   nsCOMPtr<nsIURI> uri;
   rv = ios->NewURI(file_path, "", nsnull, getter_AddRefs(uri));
   if (!uri)
     return FALSE;
@@ -274,32 +394,53 @@
 
 /* nsIWebProgressListener Functions
    all these methods must be here due to nsIWebProgressListener/2 inheritance */
 NS_IMETHODIMP ProgressListener::OnStatusChange(nsIWebProgress *aWebProgress,
                                                nsIRequest *aRequest,
                                                nsresult aStatus,
                                                const PRUnichar *aMessage)
 {
+  switch (aStatus)
+  {
+    case NS_ERROR_OUT_OF_MEMORY:     // No memory
+    case NS_ERROR_FILE_DISK_FULL:    // Out of space on target volume.
+    case NS_ERROR_FILE_NO_DEVICE_SPACE:
+    case NS_ERROR_FILE_READ_ONLY:     // Attempt to write to read/only file.
+    case NS_ERROR_FILE_ACCESS_DENIED: // Attempt to write without sufficient permissions.
+    case NS_ERROR_FILE_NOT_FOUND:     // Helper app not found, let's verify this happened on launch
+    case NS_ERROR_FILE_TARGET_DOES_NOT_EXIST:
+    case NS_ERROR_FILE_UNRECOGNIZED_PATH:
+    default:
+    {
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent), moz_embed_download_signals[DOWNLOAD_DESTROYED_SIGNAL]);
+      mObserverService->NotifyObservers(nsnull, "dl-failed", nsnull);
+    }
+      break;
+  }
+
   if (NS_SUCCEEDED(aStatus))
-    return NS_OK;
+      return NS_OK;
 
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP ProgressListener::OnStateChange(nsIWebProgress *aWebProgress,
                                               nsIRequest *aRequest, PRUint32 aStateFlags,
                                               nsresult aStatus)
 {
   if (NS_FAILED(aStatus))
     return NS_ERROR_FAILURE;
 
-  if (aStateFlags & STATE_STOP)
+  if (aStateFlags & STATE_STOP) {
+    // We can crash here if parent or mDownload is null
+    mObserverService->NotifyObservers(nsnull, "dl-done", NS_ConvertUTF8toUTF16(((GtkMozEmbedDownload *) mDownload->parent)->file_name_with_path).get());
     gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                     moz_embed_download_signals[DOWNLOAD_COMPLETED_SIGNAL]);
+  }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP ProgressListener::OnProgressChange(nsIWebProgress *aWebProgress,
                                                  nsIRequest *aRequest, PRInt32 aCurSelfProgress,
                                                  PRInt32 aMaxSelfProgress, PRInt32 aCurTotalProgress,
                                                  PRInt32 aMaxTotalProgress)
@@ -338,22 +479,387 @@
                     (gulong) aCurSelfProgress, (gulong) aMaxSelfProgress, 1);
   }
   else {
     gtk_signal_emit(GTK_OBJECT(mDownload->parent),
                     moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
                     (gulong) aCurSelfProgress, 0, 1);
   }
 
+
   /* storing current downloaded size. */
-  mDownload->downloaded_size = (gulong) aCurSelfProgress;
+  ((GtkMozEmbedDownload *) mDownload->parent)->downloaded_size = (gulong) aCurSelfProgress;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP ProgressListener::OnRefreshAttempted(nsIWebProgress *aWebProgress,
                                                    nsIURI *aUri, PRInt32 aDelay,
                                                    PRBool aSameUri,
                                                    PRBool *allowRefresh)
 {
   *allowRefresh = PR_TRUE;
   return NS_OK;
 }
+
+NS_IMETHODIMP
+EmbedDownloadMgr::CreateIncrementalDownload(const char *aUrl,
+                                            const char *aDestination,
+                                            PRBool aHidden)
+{
+  //printf("EmbedDownloadMgr.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+
+  GtkObject* instance;
+  /* create a Download object */
+  instance = gtk_moz_embed_download_get_restart_flag () ?
+                gtk_moz_embed_download_get_latest_object () : gtk_moz_embed_download_new();
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
+  EmbedDownload *Download = (EmbedDownload *) GTK_MOZ_EMBED_DOWNLOAD(instance)->data;
+  if (!Download)
+    return NS_ERROR_FAILURE;
+  Download->parent = instance;
+  /* Sets download object to keep control of each download. */
+  Download->launcher = nsnull;
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) Download->parent;
+  temp->downloaded_size = -1;
+  temp->file_size = UNKNOWN_FILE_SIZE;
+  temp->server = NS_strdup(aUrl);
+  temp->file_name_with_path = NS_strdup(aDestination);
+  temp->file_name = RemoveSchemeFromFilePath(aDestination);
+
+  return EmbedDownloadMgr::CreateIncrementalDownload(Download);
+}
+
+NS_IMETHODIMP
+EmbedDownloadMgr::CreateIncrementalDownload(EmbedDownload *Download)
+{
+  //printf("EmbedDownloadMgr.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+
+  GtkObject* instance = Download->parent;
+  // XXX reseting download restart flag ...
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+  if (!instance)
+    return NS_ERROR_FAILURE;
+
+  /* Sets download object to keep control of each download. */
+  Download->launcher = nsnull;
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) Download->parent;
+
+  nsCOMPtr<nsILocalFile> resultFile;
+  char *new_path = RemoveSchemeFromFilePath(temp->file_name_with_path);
+  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(new_path),
+                                      PR_FALSE, getter_AddRefs(resultFile));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewURI(getter_AddRefs(uri), temp->server);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr <nsIRequestObserver> observer = new FetchObserver(Download);
+  NS_ENSURE_TRUE(observer, rv);
+
+  nsCOMPtr<nsIIncrementalDownload> download =
+      do_CreateInstance(NS_INCREMENTALDOWNLOAD_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  Download->incr_launcher = download;
+
+  rv = download->Init(uri, resultFile, -1, 0);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = download->Start(observer, nsnull);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+FetchObserver::OnStartRequest(nsIRequest *request, nsISupports *context)
+{
+  //printf("FetchObserver::OnStartRequest\n");
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                  moz_embed_download_signals[DOWNLOAD_STARTED_SIGNAL], temp->file_name);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnProgress(nsIRequest *request, nsISupports *context,
+                          PRUint64 progress, PRUint64 progressMax)
+{
+  //printf("FetchObserver::OnProgress [%lu/%lu]\n",PRUint32(progress), PRUint32(progressMax));
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  if (mDownload->isCanceled)
+    return NS_OK;
+  if (progressMax != UNKNOWN_FILE_SIZE)
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                    moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
+                    (gulong) progress, (gulong) progressMax, 1);
+  else
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                    moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
+                    (gulong) progress, 0, 1);
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  temp->downloaded_size = progress;
+  temp->file_size = progressMax;
+
+  /* storing current downloaded size. */
+  ((GtkMozEmbedDownload *) mDownload->parent)->downloaded_size = (gulong) progress;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnStatus(nsIRequest *request, nsISupports *context,
+                        nsresult status, const PRUnichar *statusText)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s\n",  __LINE__, __FUNCTION__);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = request;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchObserver::OnStopRequest(nsIRequest *request, nsISupports *context,
+                             nsresult status)
+{
+  //printf("gtkmozembed_download.cpp, Line:%d, Func:%s, [status=%x]\n",  __LINE__, __FUNCTION__, status);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = nsnull;
+  GtkMozEmbedDownload *parent = (GtkMozEmbedDownload *) mDownload->parent;
+  if (mDownload->isCanceled)
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent), moz_embed_download_signals[DOWNLOAD_DESTROYED_SIGNAL]);
+  else if (!parent->is_paused) {
+    if (NS_FAILED(status)) {
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                      moz_embed_download_signals[DOWNLOAD_FAILED_SIGNAL]);    //error
+      // DOWNLOAD_FAILED_SIGNAL, DOWNLOAD_DESTROYED_SIGNAL, DOWNLOAD_COMPLETED_SIGNAL, DOWNLOAD_STOPPED_SIGNAL,
+      gtk_moz_embed_load_url (EmbedCommon::GetAnyLiveWidget(), parent->server);
+    }
+    else
+      gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                      moz_embed_download_signals[DOWNLOAD_COMPLETED_SIGNAL]);
+  }
+
+  return NS_OK;
+}
+
+#ifdef MOZ_XPINSTALL
+// nsIXPIDialogService.idl
+NS_IMETHODIMP
+EmbedDownloadMgr::ConfirmInstall(nsIDOMWindow *aParent, const PRUnichar **aPackageList, PRUint32 aCount, PRBool *aRetval)
+{
+  *aRetval = PR_FALSE;
+  nsresult rv = NS_ERROR_FAILURE;
+  nsCOMPtr<nsIDOMWindowInternal> mParentWindow( do_QueryInterface(aParent) );
+  if (NS_FAILED(rv) && mParentWindow)
+  {
+    PRInt32 selection;
+    nsCOMPtr<nsIPrompt> prompt;
+    rv = mParentWindow->GetPrompter(getter_AddRefs(prompt));
+    if (NS_SUCCEEDED(rv)) {
+      nsString str;
+      str.Append(NS_LITERAL_STRING("Do you want to install:\n"));
+      for (PRUint32 i = 0; i < aCount; i++)
+      {
+        if (!aPackageList[i][0]) continue;
+        str.Append(aPackageList[i]);
+        str.Append(NS_LITERAL_STRING("\n"));
+      }
+      rv = prompt->ConfirmEx(NS_LITERAL_STRING("Installation confirm").get(), str.get(),
+                             (nsIPrompt::BUTTON_DELAY_ENABLE) + (nsIPrompt::BUTTON_POS_0_DEFAULT)
+                             + (nsIPrompt::BUTTON_TITLE_OK * nsIPrompt::BUTTON_POS_0)
+                             + (nsIPrompt::BUTTON_TITLE_CANCEL * nsIPrompt::BUTTON_POS_1),
+                             nsnull, nsnull, nsnull, nsnull, nsnull, &selection);
+
+      if (NS_SUCCEEDED(rv))
+      {
+        //Now get which button was pressed from the ParamBlock
+        *aRetval = selection ? PR_FALSE : PR_TRUE;
+      }
+    }
+  }
+  return rv;
+}
+
+NS_IMETHODIMP
+EmbedDownloadMgr::OpenProgressDialog(const PRUnichar **aPackageList, PRUint32 aCount, nsIObserver *aObserver)
+{
+  nsresult rv;
+  nsCOMPtr<nsIExtensionManager>
+    extensionManager(do_GetService("@mozilla.org/extensions/manager;1", &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
+
+  PRUint32 itemscount = aCount/4;
+  nsIUpdateItem **items = new nsIUpdateItem*[itemscount];
+  memset(items, 0, sizeof(nsIUpdateItem *) * itemscount);
+  PRUint32 j = 0;
+  for (PRUint32 i = 0; i < aCount; i++) {
+    nsString displayName(aPackageList[i++]);
+    nsString url(aPackageList[i++]);
+    nsString iconURL(aPackageList[i++]);
+    PRBool isTheme = PR_FALSE;
+
+    if (ios) {
+      nsCOMPtr<nsIURI> uri;
+      ios->NewURI(NS_ConvertUTF16toUTF8(url), "", nsnull, getter_AddRefs(uri));
+      nsCOMPtr<nsIURL> nsURL(do_QueryInterface(uri));
+      if (nsURL) {
+        nsCString extension;
+        nsURL->GetFileExtension(extension);
+        isTheme = extension.Equals("jar");
+      }
+    }
+    if (iconURL.IsEmpty())
+      iconURL = isTheme ? NS_LITERAL_STRING("chrome://mozapps/skin/extensions/themeGeneric.png") :
+        NS_LITERAL_STRING("chrome://mozapps/skin/xpinstall/xpinstallItemGeneric.png");
+
+    nsCOMPtr<nsIUpdateItem> item = do_CreateInstance("@mozilla.org/updates/item;1", &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = item->Init(url, NS_LITERAL_STRING(" "), NS_LITERAL_STRING("app-profile"), NS_LITERAL_STRING(""), NS_LITERAL_STRING(""),
+                    displayName, url, NS_LITERAL_STRING(""), iconURL, NS_LITERAL_STRING(""),
+#ifdef MOZ_TRUNK_BUILD
+                    NS_LITERAL_STRING(""), isTheme?nsIUpdateItem::TYPE_THEME:nsIUpdateItem::TYPE_EXTENSION, NS_LITERAL_STRING(""));
+#else
+                                           isTheme?nsIUpdateItem::TYPE_THEME:nsIUpdateItem::TYPE_EXTENSION);
+#endif
+
+    if (NS_SUCCEEDED(rv))
+      NS_ADDREF(items[j++] = item);
+
+    GtkObject* instance = gtk_moz_embed_download_get_restart_flag () ?
+      gtk_moz_embed_download_get_latest_object () : gtk_moz_embed_download_new();
+    gtk_moz_embed_download_set_restart_flag (FALSE);
+    if (!instance) return NS_OK;
+    mDownload = (EmbedDownload *) GTK_MOZ_EMBED_DOWNLOAD(instance)->data;
+    if (!mDownload) return NS_OK;
+    mDownload->parent = instance;
+    mDownload->gtkMozEmbedParentWidget = GetGtkWidgetForDOMWindow(nsnull);
+    GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+    gtk_signal_emit(GTK_OBJECT(mDownload->gtkMozEmbedParentWidget),
+                    moz_embed_signals[DOWNLOAD_REQUEST],
+                    NS_ConvertUTF16toUTF8(url).get(),
+                    NS_ConvertUTF16toUTF8(displayName).get(),
+                    "application/x-xpinstall",
+                    (gulong) 1,
+                    2);
+    gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                    moz_embed_download_signals[DOWNLOAD_STARTED_SIGNAL],
+                    &temp->file_name_with_path);
+
+  }
+  rv = extensionManager->AddDownloads(items, j, PR_FALSE);
+
+  nsIAddonUpdateListener *listener = new ProgressListener(mDownload);
+  if (listener)
+    extensionManager->AddUpdateListener(static_cast<nsIAddonUpdateListener*>(listener),
+                                        &static_cast<ProgressListener*>(listener)->mObserveIndex);
+
+  return rv;
+}
+#endif
+
+#ifdef MOZ_RDF
+// nsIAddonUpdateListener
+NS_IMETHODIMP
+ProgressListener::OnStateChange(nsIUpdateItem *addon, PRInt16 state, PRInt32 value)
+{
+  //printf("nsIAddonUpdateListener:OnStateChange idx:%p, state:%x, val:%i\n", addon, state, value);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  mDownload->request = nsnull;
+  GtkMozEmbedDownload *parent = (GtkMozEmbedDownload *) mDownload->parent;
+  switch (state) {
+    case nsIXPIProgressDialog::DOWNLOAD_START:
+        break;
+    case nsIXPIProgressDialog::DOWNLOAD_DONE:
+    {
+        gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                        moz_embed_download_signals[DOWNLOAD_COMPLETED_SIGNAL]);
+        break;
+    }
+    case nsIXPIProgressDialog::INSTALL_START:
+        break;
+    case nsIXPIProgressDialog::INSTALL_DONE:
+    {
+        // From nsInstall.h
+        // SUCCESS        = 0
+        // REBOOT_NEEDED  = 999
+        // USER_CANCELLED = -210
+        if (value == 30) {
+          mProgressState = 30;
+          return NS_OK;
+        }
+
+        if ((value == 0 || value == 999 || value == -210) && mProgressState != 30) {
+          mProgressState = value;
+        } else if (mProgressState == 30)
+          mProgressState = -2;
+        else
+          mProgressState = -1;
+        break;
+    }
+    case nsIXPIProgressDialog::DIALOG_CLOSE:
+    {
+        nsCOMPtr<nsIExtensionManager>
+          extensionManager(do_GetService("@mozilla.org/extensions/manager;1"));
+        if (extensionManager)
+          extensionManager->RemoveUpdateListenerAt(mObserveIndex);
+
+        mDownload = nsnull;
+        mObserveIndex = -1;
+        PRBool aNeedsRestart = PR_FALSE;
+        nsresult rv = extensionManager->Start(nsnull, &aNeedsRestart);
+        nsCOMPtr<nsIComponentRegistrar> cr;
+        rv = NS_GetComponentRegistrar(getter_AddRefs(cr));
+        NS_ENSURE_SUCCESS(rv, rv);
+        cr->AutoRegister(nsnull);
+        nsCOMPtr<nsIPromptService>
+          ps(do_GetService("@mozilla.org/embedcomp/prompt-service;1"));
+        if (!ps) return NS_OK;
+        if (mProgressState == -1)
+          ps->Alert(nsnull, NS_LITERAL_STRING("errorInstallTitle").get(), NS_LITERAL_STRING("Install Error").get());
+        else
+          if (aNeedsRestart)
+            //ps->Confirm(nsnull, NS_LITERAL_STRING("SuccessInstallTitle").get(), NS_LITERAL_STRING("Do you want to restart now?").get(), &aNeedsRestart);
+            ps->Alert(nsnull, NS_LITERAL_STRING("SuccessInstallTitle").get(), NS_LITERAL_STRING("Success Installation\nPlease restart browser").get());
+          else
+            ps->Alert(nsnull, NS_LITERAL_STRING("SuccessInstallTitle").get(), NS_LITERAL_STRING("Success Installation").get());
+        break;
+    }
+    default:
+        break;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ProgressListener::OnProgress(nsIUpdateItem *addon, PRUint32 value, PRUint32 maxValue)
+{
+  //printf("nsIAddonUpdateListener:OnProgress idx:%p, val:%i, maxval:%i\n", addon, value, maxValue);
+  NS_ENSURE_TRUE(mDownload, NS_OK);
+  if (mDownload->isCanceled)
+    return NS_OK;
+  gtk_signal_emit(GTK_OBJECT(mDownload->parent),
+                  moz_embed_download_signals[DOWNLOAD_PROGRESS_SIGNAL],
+                  (gulong) value, (gulong) maxValue, 1);
+
+  GtkMozEmbedDownload *temp = (GtkMozEmbedDownload *) mDownload->parent;
+  temp->downloaded_size = value;
+  temp->file_size = maxValue;
+
+  /* storing current downloaded size. */
+  ((GtkMozEmbedDownload *) mDownload->parent)->downloaded_size = (gulong) value;
+
+  return NS_OK;
+}
+#endif
+
Index: mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedDownloadMgr.h
+++ mozilla/embedding/browser/gtk/src/EmbedDownloadMgr.h
@@ -9,17 +9,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -42,57 +42,68 @@
 
 #include "EmbedPrivate.h"
 #include "nsIHelperAppLauncherDialog.h"
 #include "nsIMIMEInfo.h"
 #include "nsCOMPtr.h"
 #include "nsIExternalHelperAppService.h"
 #include "nsIRequest.h"
 #include "nsILocalFile.h"
+#include "nsIIncrementalDownload.h"
+#include "nsIRequestObserver.h"
+
+#ifdef MOZ_XPINSTALL
+#include "nsIXPIDialogService.h"
+#endif
+#include "nsIObserverService.h"
 
 #include "nsWeakReference.h"
 #define EMBED_DOWNLOADMGR_DESCRIPTION "MicroB Download Manager"
 #define EMBED_DOWNLOADMGR_CID {0x53df12a2, 0x1f4a, 0x4382, {0x99, 0x4e, 0xed, 0x62, 0xcf, 0x0d, 0x6b, 0x3a}}
 
 class nsIURI;
 class nsIFile;
 class nsIFactory;
 class nsExternalAppHandler;
 
-typedef struct _EmbedDownload EmbedDownload;
-
-struct _EmbedDownload
+class EmbedDownload
 {
+public:
+  EmbedDownload();
+  ~EmbedDownload();
   GtkObject*  parent;
   GtkWidget*  gtkMozEmbedParentWidget;/** Associated gtkmozembed widget */
 
-  char*       file_name;             /** < The file's name */
-  char*       file_name_with_path;   /** < The file's name */
-  const char* server;                /** < The server's name */
-  const char* file_type;             /** < The file's type */
-  const char* handler_app;           /** < The application's name */
-  PRInt64     file_size;             /** < The file's size */
-  PRInt64     downloaded_size;       /** < The download's size */
-  gboolean    is_paused;             /** < If download is paused or not */
-  gboolean    open_with;             /** < If the file can be opened by other application */
-
   /* Pointer to mozilla interfaces */
   nsIHelperAppLauncher* launcher;    /** < The mozilla's download dialog */
+  nsCOMPtr <nsIIncrementalDownload> incr_launcher;
   nsIRequest* request;               /** < The download request */
+  PRBool isCanceled;
 };
 
-class EmbedDownloadMgr : public nsIHelperAppLauncherDialog
+class EmbedDownloadMgr :
+#ifdef MOZ_XPINSTALL
+                         public nsIXPIDialogService,
+#endif
+                         public nsIHelperAppLauncherDialog
 {
   public:
     EmbedDownloadMgr();
     virtual ~EmbedDownloadMgr();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIHELPERAPPLAUNCHERDIALOG
+#ifdef MOZ_XPINSTALL
+    NS_DECL_NSIXPIDIALOGSERVICE
+#endif
+    static nsresult CreateIncrementalDownload(const char *aUrl, const char *aDestination, PRBool aHidden = PR_FALSE);
+    static nsresult CreateIncrementalDownload(EmbedDownload *download);
 
   private:
     /** Gets all informations about a file which is being downloaded.
     */
     NS_METHOD GetDownloadInfo(nsIHelperAppLauncher *aLauncher, nsISupports *aContext);
 
     EmbedDownload *mDownload;
+    nsCOMPtr < nsIDOMWindow > mParentWindow;
+    nsCOMPtr<nsIObserverService> mObserverService;
 };
 #endif /* __EmbedDownloadMgr_h */
Index: mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedEventListener.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedEventListener.cpp
@@ -11,23 +11,24 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Oleg Romashin <romaxa@gmail.com>
+ *   Anton Rogaynis <rogainis@gmail.com>
  *   Tomaz Noleto <tnoleto@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
@@ -40,39 +41,63 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsCOMPtr.h"
 #include "nsIDOMMouseEvent.h"
 
 #include "nsIDOMNSEvent.h"
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMUIEvent.h"
+#include "nsIDOMPopupBlockedEvent.h"
 #include "nsIDOMDocument.h"
 #include "nsIDocument.h"
 #include "nsIContent.h"
 #include "nsIPresShell.h"
 #include "nsIDOMNodeList.h"
+#include "nsIPrefService.h"
 
 #include "EmbedEventListener.h"
 #include "EmbedPrivate.h"
 #include "gtkmozembed_internal.h"
 
 static PRInt32 sLongPressTimer = 0, mLongMPressDelay = 1000;
-static PRInt32 sX = 0, sY = 0;
-static PRBool  sMPressed = PR_FALSE, sIsScrolling = PR_FALSE;
+static PRInt32 spX = 0, spY = 0, sScrollStep = 2;
+static PRBool  sMPressed = PR_FALSE, sForcePan = PR_FALSE, sMBPressed = PR_FALSE;
+static PRInt16 sIsScrolling = 0, sXulType = 0;
 static char* gFavLocation = NULL;
+#define START_PANNING_STEP 8
+
+static PRInt32 sgX = 0, sgY = 0;
+static PRBool sDirectPan = PR_TRUE, sDoubleClick = PR_FALSE;
+
+static gboolean
+motion_notify_event_cb (GtkWidget *widget, GdkEventMotion *event, EmbedEventListener *self);
+static gboolean
+button_release_event_cb(GtkWidget *widget, GdkEvent *event, EmbedPrivate *self);
+static gboolean
+button_press_event_cb(GtkWidget *widget, GdkEvent *event, EmbedPrivate *self);
+static gboolean
+enter_notify_event_cb  (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self);
+static gboolean
+leave_notify_event_cb  (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self);
 
 EmbedEventListener::EmbedEventListener(void)
 {
   mOwner = nsnull;
+  mXSLTransformed = PR_FALSE;
+  mAddonSignals = PR_FALSE;
 }
 
 EmbedEventListener::~EmbedEventListener()
 {
   delete mCtxInfo;
+  mOwner = nsnull;
+  mCtxInfo = nsnull;
+  mXSLTransformed = PR_FALSE;
+  mAddonSignals = PR_FALSE;
 }
 
 NS_IMPL_ADDREF(EmbedEventListener)
 NS_IMPL_RELEASE(EmbedEventListener)
 NS_INTERFACE_MAP_BEGIN(EmbedEventListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMKeyListener)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMKeyListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
@@ -81,21 +106,41 @@
   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseMotionListener)
   NS_INTERFACE_MAP_ENTRY(nsIDOMFocusListener)
   NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
 NS_INTERFACE_MAP_END
 
 nsresult
 EmbedEventListener::Init(EmbedPrivate *aOwner)
 {
+  nsresult rv;
   mOwner = aOwner;
   mCtxInfo = nsnull;
   mClickCount = 1;
   mCtxInfo = new EmbedContextMenuInfo(aOwner);
   mOwner->mNeedFav = PR_TRUE;
+  nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+  if (!prefs)
+    return NS_OK;
+
+  PRInt32 scrollStep = 0;
+  PRBool forcePan = PR_FALSE;
+  PRBool directPan = PR_TRUE;
+  rv = prefs->GetIntPref("gtkmozembed.mscroll.step", &scrollStep);
+  if (scrollStep && NS_SUCCEEDED(rv))
+    sScrollStep = scrollStep;
+
+  rv = prefs->GetBoolPref("gtkmozembed.mscroll.force", &forcePan);
+  if (scrollStep && NS_SUCCEEDED(rv))
+    sForcePan = forcePan;
+
+  rv = prefs->GetBoolPref("gtkmozembed.mscroll.direct", &directPan);
+  if (NS_SUCCEEDED(prefs->GetBoolPref("gtkmozembed.mscroll.direct", &directPan)) && !directPan)
+    sDirectPan = directPan;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleLink(nsIDOMNode* node)
 {
   nsresult rv;
 
@@ -147,40 +192,90 @@
            type.LowerCaseEqualsLiteral("application/rss+xml")) {
 
     NS_ConvertUTF16toUTF8 narrowTitle(title);
 
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[RSS_REQUEST],
                     (gchar *)url.get(),
                     narrowTitle.get());
+    mXSLTransformed = PR_FALSE;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleEvent(nsIDOMEvent* aDOMEvent)
 {
   nsString eventType;
   aDOMEvent->GetType(eventType);
 
+  if (mOwner->mWindow && eventType.EqualsLiteral("DOMLinkXSLParsed")) {
+    mXSLTransformed = PR_TRUE;
+    return NS_OK;
+  }
+
   if (eventType.EqualsLiteral("focus"))
     if (mCtxInfo->GetFormControlType(aDOMEvent)) {
-      if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
         gint return_val = FALSE;
         gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                         moz_embed_signals[DOM_FOCUS],
                         (void *)aDOMEvent, &return_val);
         if (return_val) {
           aDOMEvent->StopPropagation();
           aDOMEvent->PreventDefault();
         }
       }
     }
 
+  if (eventType.EqualsLiteral("DOMPopupBlocked")) {
+    nsCOMPtr<nsIDOMPopupBlockedEvent> popupEvent =
+      do_QueryInterface (aDOMEvent);
+    NS_ENSURE_TRUE (popupEvent, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIURI> popupWindowURI;
+    popupEvent->GetPopupWindowURI (getter_AddRefs (popupWindowURI));
+
+    nsCString popupWindowURIString;
+    nsCString Host;
+    nsresult rv;
+
+    if (popupWindowURI) {
+      rv = popupWindowURI->GetSpec (popupWindowURIString);
+      NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+      rv = popupWindowURI->GetHost (Host);
+      NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+    }
+
+    nsString popupWindowFeatures;
+    rv = popupEvent->GetPopupWindowFeatures (popupWindowFeatures);
+    NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+
+    nsCString popupWindowFeaturesString;
+    NS_UTF16ToCString (popupWindowFeatures,
+                       NS_CSTRING_ENCODING_UTF8,
+                       popupWindowFeaturesString);
+
+    nsCString popupWindowNameString;
+#ifdef HAVE_GECKO_1_9
+    nsString popupWindowName;
+    rv = popupEvent->GetPopupWindowName (popupWindowName);
+    NS_ENSURE_SUCCESS (rv, NS_ERROR_FAILURE);
+
+    NS_UTF16ToCString (popupWindowName,
+                       NS_CSTRING_ENCODING_UTF8,
+                       popupWindowNameString);
+#endif
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_CONTENT_BLOCKED],
+                    (void *)popupWindowURIString.get(),(void*)Host.get());
+    return NS_OK;
+  }
+
   if (eventType.EqualsLiteral("DOMLinkAdded")) {
 
     nsresult rv;
     nsCOMPtr<nsIDOMEventTarget> eventTarget;
 
     aDOMEvent->GetTarget(getter_AddRefs(eventTarget));
     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(eventTarget, &rv);
     if (NS_FAILED(rv) || !node)
@@ -196,38 +291,49 @@
     webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     if (!DOMWindow) return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMDocument> doc;
     DOMWindow->GetDocument(getter_AddRefs(doc));
     if (!doc) return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNodeList> nodelist = nsnull;
+
+    PRUint32 length = 0;
     doc->GetElementsByTagName( NS_LITERAL_STRING( "rss" ), getter_AddRefs( nodelist ));
-    if (nodelist) {
-      PRUint32 length = 0;
+    if (nodelist)
       nodelist->GetLength(&length);
-      if (length >= 1) {
+    if (!nodelist || length == 0) {
+      doc->GetElementsByTagName( NS_LITERAL_STRING( "feed" ), getter_AddRefs( nodelist ));
+      if (nodelist)
+        nodelist->GetLength(&length);
+    }
+    if (!nodelist || length == 0) {
+      doc->GetElementsByTagName( NS_LITERAL_STRING( "rdf:RDF" ), getter_AddRefs( nodelist ));
+      if (nodelist)
+        nodelist->GetLength(&length);
+    }
+    if (nodelist && length >= 1 || mXSLTransformed) {
         char *url = gtk_moz_embed_get_location(mOwner->mOwningWidget);
         char *title = gtk_moz_embed_get_title(mOwner->mOwningWidget);
         gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                         moz_embed_signals[RSS_REQUEST],
                         (gchar*)url,
                         (gchar*)title);
         if (url)
           NS_Free(url);
         if (title)
           NS_Free(title);
-      }
+        mXSLTransformed = PR_FALSE;
     }
   }
   else if (mOwner->mNeedFav) {
     mOwner->mNeedFav = PR_FALSE;
     nsCString favicon_url = mOwner->mPrePath;
-	favicon_url.AppendLiteral("/favicon.ico");
+    favicon_url.AppendLiteral("/favicon.ico");
     this->GetFaviconFromURI(favicon_url.get());
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::KeyDown(nsIDOMEvent* aDOMEvent)
 {
@@ -291,88 +397,175 @@
 
 static gboolean
 sLongMPress(void *aOwningWidget)
 {
   // Return TRUE from your signal handler to mark the event as consumed.
   if (!sMPressed || sIsScrolling)
     return FALSE;
   sMPressed = PR_FALSE;
+  spX = 0;
+  spY = 0;
+  sgX = 0;
+  sgY = 0;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(aOwningWidget),
                   moz_embed_signals[DOM_MOUSE_LONG_PRESS],
                   (void *)0, &return_val);
   if (return_val) {
     sMPressed = PR_FALSE;
   }
   return FALSE;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseDown(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
-  if (!mouseEvent)
+  if ((!mouseEvent) || (mAddonSignals && !sMBPressed))
     return NS_OK;
 
-  // Return TRUE from your signal handler to mark the event as consumed.
-  sMPressed = PR_TRUE;
+  if(!(mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_SELECT))
+    sMPressed = PR_TRUE;
+  if(!mAddonSignals)
+    sMBPressed = PR_TRUE;
+
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_DOWN],
                   (void *)mouseEvent, &return_val);
-  if (return_val) {
+  if (sDoubleClick && !sForcePan) {
     mClickCount = 2;
     sMPressed = PR_FALSE;
 #if 1
-    if (sLongPressTimer)
-      g_source_remove(sLongPressTimer);
+    GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
 #else
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
 #endif
+    if (sDirectPan) {
+      spX = sgX;
+      spY = sgY;
+    }
   } else {
     mClickCount = 1;
-    sLongPressTimer = g_timeout_add(mLongMPressDelay, sLongMPress, mOwner->mOwningWidget);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&sX);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&sY);
+
+    if(sMBPressed) {
+      sLongPressTimer = g_timeout_add(mLongMPressDelay, sLongMPress, mOwner->mOwningWidget);
+      sMBPressed = PR_FALSE;
+    }
+
+    // Return TRUE from your signal handler to mark the event as consumed.
+    PRInt32 JSHandledInfo = DOM_MOUSE_DOWN;
+    if (mCtxInfo->mIsJSHandledElement == DOM_MOUSE_OVER
+        || mCtxInfo->mIsJSHandledElement == DOM_MOUSE_SCROLL) {
+      return NS_OK;
+    }
+    if (mCtxInfo && NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+        && JSHandledInfo == DOM_MOUSE_DOWN) {
+      return NS_OK;
+    }
+
+    if(!mAddonSignals || spX == 0 || spY == 0)
+    {
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&spX);
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&spY);
+    }
+    if (sDirectPan) {
+      if (!mAddonSignals) {
+        GtkWidget * child = gtk_bin_get_child((GtkBin *)mOwner->mOwningWidget);
+        if (child) {
+          g_signal_connect(G_OBJECT(child), "motion_notify_event",
+                           G_CALLBACK(motion_notify_event_cb), this);
+          g_signal_connect(G_OBJECT(child), "button_release_event",
+                           G_CALLBACK(button_release_event_cb), mOwner);
+          g_signal_connect(G_OBJECT(child), "button_press_event",
+                           G_CALLBACK(button_press_event_cb), mOwner);
+          g_signal_connect(G_OBJECT(child), "enter_notify_event",
+                           G_CALLBACK(enter_notify_event_cb), this);
+          g_signal_connect(G_OBJECT(child), "leave_notify_event",
+                           G_CALLBACK(leave_notify_event_cb), this);
+          mAddonSignals = PR_TRUE;
+        }
+      }
+    }
   }
 
   // handling event internally.
   HandleSelection(mouseEvent);
 
+  if (mCtxInfo)
+    sXulType = mCtxInfo->mIsScrollableElement;
+
   return NS_OK;
 }
 
+static void
+PanStatesReset(EmbedPrivate *self, PRBool aFull = PR_TRUE)
+{
+  GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+  sMPressed = PR_FALSE;
+  if (self)
+    self->mOpenBlock = sIsScrolling > 2;
+  sIsScrolling = sMPressed;
+  spX = sgX;
+  spY = sgY;
+  sXulType = 0;
+
+  EmbedCommon::SuspendNative(PR_FALSE);
+
+  if (!self || !aFull) return;
+  gint return_val = FALSE;
+  gtk_signal_emit(GTK_OBJECT(self->mOwningWidget),
+                  moz_embed_signals[DOM_MOUSE_UP],
+                  (void *)nsnull, &return_val);
+}
+
 NS_IMETHODIMP
 EmbedEventListener::MouseUp(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
 
+#if 1
+    GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+#else
+    aDOMEvent->StopPropagation();
+    aDOMEvent->PreventDefault();
+#endif
+
   // handling event internally, first.
   HandleSelection(mouseEvent);
 
+  if (!sDirectPan)
+  PanStatesReset(mOwner, PR_FALSE);
+
+  mCtxInfo->mIsJSHandledElement = 0;
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (sLongPressTimer)
-    g_source_remove(sLongPressTimer);
-  sMPressed = PR_FALSE;
-  mOwner->mOpenBlock = sIsScrolling;
-  sIsScrolling = sMPressed;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_UP],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
+
+  if (mOwner->mLoadFinished && mOwner->mPluginSuspended) {
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+    if (enabled && success) {
+      mOwner->NotifyPlugins(3);
+      mOwner->mPluginSuspended = PR_FALSE;
+    }
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseClick(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
@@ -383,29 +576,38 @@
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_CLICK],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
   }
+
+  if (mOwner->mLoadFinished && mOwner->mPluginSuspended) {
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+    if (enabled && success) {
+      mOwner->NotifyPlugins(3);
+      mOwner->mPluginSuspended = PR_FALSE;
+    }
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseDblClick(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
   // Return TRUE from your signal handler to mark the event as consumed.
-  if (sLongPressTimer)
-    g_source_remove(sLongPressTimer);
+  GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
   sMPressed = PR_FALSE;
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_DBL_CLICK],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
@@ -415,16 +617,21 @@
 
 NS_IMETHODIMP
 EmbedEventListener::MouseOver(nsIDOMEvent* aDOMEvent)
 {
   nsCOMPtr<nsIDOMMouseEvent> mouseEvent;
   mouseEvent = do_QueryInterface(aDOMEvent);
   if (!mouseEvent)
     return NS_OK;
+  PRInt32 JSHandledInfo = DOM_MOUSE_OVER;
+  if (mCtxInfo && NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+      && JSHandledInfo == DOM_MOUSE_OVER)
+    return NS_OK;
+
   // Return TRUE from your signal handler to mark the event as consumed.
   gint return_val = FALSE;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[DOM_MOUSE_OVER],
                   (void *)mouseEvent, &return_val);
   if (return_val) {
     aDOMEvent->StopPropagation();
     aDOMEvent->PreventDefault();
@@ -505,72 +712,90 @@
     aDOMEvent->PreventDefault();
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::MouseMove(nsIDOMEvent* aDOMEvent)
 {
+  PRInt32 JSHandledInfo = DOM_MOUSE_SCROLL;
+  sMBPressed = PR_FALSE;
+  if (mCtxInfo && mCtxInfo->mIsJSHandledElement != DOM_MOUSE_OVER &&
+      NS_SUCCEEDED(mCtxInfo->GetJSHandledInfo(aDOMEvent, &JSHandledInfo))
+      && JSHandledInfo == DOM_MOUSE_SCROLL) {
+    return NS_OK;
+  }
+  if (sMPressed && mCtxInfo && (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL) && sXulType < 2)
+     EmbedCommon::SuspendNative(PR_TRUE);
+
   if (mCurSelCon)
     mCurSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
 
-  if (sMPressed &&
-      gtk_signal_handler_pending(GTK_OBJECT(mOwner->mOwningWidget),
-                                 moz_embed_signals[DOM_MOUSE_SCROLL], TRUE)) {
+  if (mCtxInfo &&
+      (sMPressed &&
+       (gtk_signal_handler_pending(GTK_OBJECT(mOwner->mOwningWidget),
+                                   moz_embed_signals[DOM_MOUSE_SCROLL], TRUE)
+        || sForcePan)
+       && (!(mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL && sXulType != 2)
+       )
+      )
+     ) {
     // Return TRUE from your signal handler to mark the event as consumed.
     nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aDOMEvent);
-    if (!mouseEvent)
-      return NS_OK;
     PRInt32  newX, newY, subX, subY;
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&newX);
-    ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&newY);
-    subX = newX - sX;
-    subY = newY - sY;
-    nsresult rv = NS_OK;
-    if (ABS(subX) > 10 || ABS(subY) > 10 || (sIsScrolling && sMPressed)) {
-      if (!sIsScrolling) {
-        gint return_val = FALSE;
-        gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                        moz_embed_signals[DOM_MOUSE_SCROLL],
-                        (void *)mouseEvent, &return_val);
-        if (!return_val) {
-          sIsScrolling = PR_TRUE;
-          if (mCtxInfo)
-            rv = mCtxInfo->GetElementForScroll(aDOMEvent);
-        } else {
-          sMPressed = PR_FALSE;
-          sIsScrolling = PR_FALSE;
+    if (sDirectPan) {
+      newX = sgX;
+      newY = sgY;
+    } else {
+      if (!mouseEvent)
+        return NS_OK;
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenX(&newX);
+      ((nsIDOMMouseEvent*)mouseEvent)->GetScreenY(&newY);
+    }
+    subX = newX - spX;
+    subY = newY - spY;
+    if (!sIsScrolling
+        && (ABS(subX) > START_PANNING_STEP || ABS(subY) > START_PANNING_STEP)) {
+      gint return_val = FALSE;
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[DOM_MOUSE_SCROLL],
+                      (void *)mouseEvent, &return_val);
+      if ((!return_val || sXulType == 2) && mCtxInfo->GetScrollableView()) {
+        sIsScrolling = PR_TRUE;
+        if (sXulType < 2)
+          EmbedCommon::SuspendNative(PR_TRUE);
+
+        // suspend plugins when panning
+        // Only need to suspend when page is already loaded and at the FIRST movement
+        if ( mOwner->mLoadFinished && !mOwner->mPluginSuspended ) {
+          PRBool enabled = PR_TRUE;
+          gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+          if (success && enabled) {
+            // do suspend
+            mOwner->NotifyPlugins(4);
+            mOwner->mPluginSuspended = PR_TRUE;
+          }
         }
+      } else {
+        sMPressed = PR_FALSE;
+        sIsScrolling = PR_FALSE;
       }
-      if (sIsScrolling)
-      {
-        if (sLongPressTimer)
-          g_source_remove(sLongPressTimer);
-        if (mCtxInfo->mNSHHTMLElementSc) {
-          PRInt32 x, y;
-          mCtxInfo->mNSHHTMLElementSc->GetScrollTop(&y);
-          mCtxInfo->mNSHHTMLElementSc->GetScrollLeft(&x);
-#ifdef MOZ_SCROLL_TOP_LEFT_HACK
-          rv = mCtxInfo->mNSHHTMLElementSc->ScrollTopLeft(y - subY, x - subX);
-#endif
-        } else {
-          rv = NS_ERROR_UNEXPECTED;
-        }
-        if (rv == NS_ERROR_UNEXPECTED) {
-          nsCOMPtr<nsIDOMWindow> DOMWindow;
-          nsIWebBrowser *webBrowser = nsnull;
-          gtk_moz_embed_get_nsIWebBrowser(mOwner->mOwningWidget, &webBrowser);
-          webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
-          DOMWindow->ScrollBy(-subX, -subY);
-        }
+    }
+
+    if (sIsScrolling && (ABS(subX) >= sScrollStep || ABS(subY) >= sScrollStep)) {
+      spX = newX;
+      spY = newY;
+      if (!mCtxInfo->mIsScrollableElement)
+        return NS_OK;
+      GLIB_SOURCE_IF_REMOVE(sLongPressTimer);
+      if (mCtxInfo->mCtxScrollable && !(sDirectPan && aDOMEvent)) {
+        sIsScrolling++;
+        mCtxInfo->ScrollScrollableView(-subX, -subY);
       }
-      sX = newX;
-      sY = newY;
-      sIsScrolling = sMPressed;
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::DragMove(nsIDOMEvent* aMouseEvent)
 {
@@ -580,17 +805,17 @@
 NS_IMETHODIMP
 EmbedEventListener::Focus(nsIDOMEvent* aEvent)
 {
   nsString eventType;
   aEvent->GetType(eventType);
 
   if (eventType.EqualsLiteral("focus") &&
       mCtxInfo->GetFormControlType(aEvent) &&
-      mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT) {
+      mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
     gint return_val = FALSE;
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[DOM_FOCUS],
                     (void *)aEvent, &return_val);
     if (return_val) {
       aEvent->StopPropagation();
       aEvent->PreventDefault();
     }
@@ -598,121 +823,95 @@
 
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 EmbedEventListener::Blur(nsIDOMEvent* aEvent)
 {
-  gint return_val = FALSE;
   mFocusInternalFrame = PR_FALSE;
 
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
-  nsCOMPtr<nsIDOMEventTarget> target;
-  nsevent->GetOriginalTarget(getter_AddRefs(target));
-
-  if (!target)
-    return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(target);
-
-  if (targetContent) {
-#ifdef MOZILLA_1_8_BRANCH
-    if (targetContent->IsContentOfType(nsIContent::eHTML_FORM_CONTROL)) {
-#else
-    if (targetContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL)) {
-#endif
-      if (sLongPressTimer)
-        g_source_remove(sLongPressTimer);
-
-      sMPressed = sIsScrolling ? PR_FALSE : sMPressed;
-      sIsScrolling = PR_FALSE;
-    }
-  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::HandleSelection(nsIDOMMouseEvent* aDOMMouseEvent)
 {
   nsresult rv;
 
   /* This function gets called everytime that a mousedown or a mouseup
    * event occurs.
    */
-  nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aDOMMouseEvent));
+  nsCOMPtr<nsIDOMNSEvent> nsevent = do_QueryInterface(aDOMMouseEvent, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDOMEventTarget> target;
   rv = nsevent->GetOriginalTarget(getter_AddRefs(target));
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
-  nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(target);
+  nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(target, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMDocument> domDoc;
   rv = eventNode->GetOwnerDocument(getter_AddRefs(domDoc));
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc, &rv);
-  if (NS_FAILED(rv) || !doc)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   nsIPresShell *presShell = doc->GetPrimaryShell();
-
   /* Gets nsISelectionController interface for the current context */
-  mCurSelCon = do_QueryInterface(presShell);
-  if (!mCurSelCon)
-    return NS_ERROR_FAILURE;
+  mCurSelCon = do_QueryInterface(presShell, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   /* Gets event type */
   nsString eventType;
   rv = aDOMMouseEvent->GetType(eventType);
-  if (NS_FAILED(rv))
-    return rv;
+  NS_ENSURE_SUCCESS(rv, rv);
 
   /* Updates context to check which context is being clicked on */
   mCtxInfo->UpdateContextData(aDOMMouseEvent);
 
   /* If a mousedown after 1 click is done (and if clicked context is not a XUL
    * one (e.g. scrollbar), the selection is disabled for that context.
    */
   if (mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_XUL || mCtxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_RICHEDIT)
     return rv;
 
   if (eventType.EqualsLiteral("mousedown")) {
 
     if (mClickCount == 1)
       rv = mCurSelCon->SetDisplaySelection(nsISelectionController::SELECTION_OFF);
-
   } // mousedown
 
   /* If a mouseup occurs, the selection for context is enabled again (despite of
    * number of clicks). If this event occurs after 1 click, the selection of
    * both last and current contexts are cleaned up.
    */
   if (eventType.EqualsLiteral("mouseup")) {
 
     /* Selection controller of current event context */
     if (mCurSelCon) {
       rv = mCurSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
       if (mClickCount == 1) {
         nsCOMPtr<nsISelection> domSel;
-        mCurSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
-                                 getter_AddRefs(domSel));
+        rv = mCurSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
+                                      getter_AddRefs(domSel));
+        NS_ENSURE_SUCCESS(rv, rv);
         rv = domSel->RemoveAllRanges();
       }
     }
     /* Selection controller of previous event context */
     if (mLastSelCon) {
       rv = mLastSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
       if (mClickCount == 1) {
         nsCOMPtr<nsISelection> domSel;
-        mLastSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
-                                  getter_AddRefs(domSel));
+        rv = mLastSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
+                                       getter_AddRefs(domSel));
+        NS_ENSURE_SUCCESS(rv, rv);
         rv = domSel->RemoveAllRanges();
       }
     }
 
     /* If 1 click was done (despite the event type), sets the last context's
      * selection controller with current one
      */
     if (mClickCount == 1)
@@ -750,157 +949,150 @@
                                    NS_GET_IID(nsIIOService),
                                    (void **)ioService);
   return rv;
 }
 
 void
 EmbedEventListener::GeneratePixBuf()
 {
+  if (!::gFavLocation)
+    return;
   GdkPixbuf *pixbuf = NULL;
   pixbuf = gdk_pixbuf_new_from_file(::gFavLocation, NULL);
-  if (!pixbuf) {
+  if (!pixbuf && mOwner->mOwningWidget) {
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[ICON_CHANGED],
                     NULL );
 
     // remove the wrong favicon
     // FIXME: need better impl...
     nsCOMPtr<nsILocalFile> faviconFile = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
 
     if (!faviconFile) {
-      NS_Free(::gFavLocation);
-      gFavLocation = nsnull;
+      if (::gFavLocation) {
+        NS_Free(::gFavLocation);
+        gFavLocation = nsnull;
+      }
       return;
     }
 
     nsCString faviconLocation(::gFavLocation);
     faviconFile->InitWithNativePath(faviconLocation);
     faviconFile->Remove(FALSE);
-    NS_Free(::gFavLocation);
-    gFavLocation = nsnull;
+
+    if (::gFavLocation) {
+      NS_Free(::gFavLocation);
+      gFavLocation = nsnull;
+    }
     return;
   }
 
+  if (!(mOwner && mOwner->mOwningWidget))
+    return;
+
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[ICON_CHANGED],
                   pixbuf );
   //mOwner->mNeedFav = PR_FALSE;
-  NS_Free(::gFavLocation);
-  gFavLocation = nsnull;
+  if (::gFavLocation) {
+    NS_Free(::gFavLocation);
+    gFavLocation = nsnull;
+  }
 }
 
 void
 EmbedEventListener::GetFaviconFromURI(const char* aURI)
 {
-  gchar *file_name = NS_strdup(aURI);
-  gchar *favicon_uri = NS_strdup(aURI);
+  nsresult rv = NS_OK;
 
-  gint i = 0;
-  gint rv = 0;
+  if (!aURI)
+    return;
 
-  nsCOMPtr<nsIWebBrowserPersist> persist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
-  if (!persist) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
+  char *file_name = NS_strdup(aURI);
+  if (!file_name)
     return;
-  }
-  persist->SetProgressListener(this);
 
+  int i = 0;
   while (file_name[i] != '\0') {
     if (file_name[i] == '/' || file_name[i] == ':')
       file_name[i] = '_';
     i++;
   }
 
   nsCString fileName(file_name);
+  NS_Free(file_name);
 
-  nsCOMPtr<nsILocalFile> favicon_dir = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
-
-  if (!favicon_dir) {
-    NS_Free(favicon_uri);
-    NS_Free(file_name);
+  nsCOMPtr<nsIWebBrowserPersist> persist = do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
+  if (!persist)
     return;
-  }
+  persist->SetProgressListener(this);
 
-  nsCString faviconDir("~/.mozilla/favicon");
-  favicon_dir->InitWithNativePath(faviconDir);
+  nsCOMPtr<nsILocalFile> favicon_dir = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
+  if (!favicon_dir)
+    return;
+  favicon_dir->InitWithNativePath(NS_LITERAL_CSTRING("~/.mozilla/favicon"));
 
   PRBool isExist;
   rv = favicon_dir->Exists(&isExist);
   if (NS_SUCCEEDED(rv) && !isExist) {
     rv = favicon_dir->Create(nsIFile::DIRECTORY_TYPE,0775);
-    if (NS_FAILED(rv)) {
-      NS_Free(file_name);
-      NS_Free(favicon_uri);
+    if (NS_FAILED(rv))
       return;
-    }
   }
 
-  nsCAutoString favicon_path("~/.mozilla/favicon");
   nsCOMPtr<nsILocalFile> target_file = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
-  if (!target_file) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
+  if (!target_file)
     return;
-  }
-  target_file->InitWithNativePath(favicon_path);
+  target_file->InitWithNativePath(NS_LITERAL_CSTRING("~/.mozilla/favicon"));
   target_file->Append(NS_ConvertUTF8toUTF16(fileName));
 
   nsString path;
   target_file->GetPath(path);
   ::gFavLocation = NS_strdup(NS_ConvertUTF16toUTF8(path).get());
   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
   if (!ios) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
-    NS_Free(::gFavLocation);
+    if (::gFavLocation)
+      NS_Free(::gFavLocation);
     gFavLocation = nsnull;
     return;
   }
 
   nsCOMPtr<nsIURI> uri;
-
-  rv = ios->NewURI(nsDependentCString(favicon_uri), "", nsnull, getter_AddRefs(uri));
+  rv = ios->NewURI(nsDependentCString(aURI), "", nsnull, getter_AddRefs(uri));
   if (!uri) {
-    NS_Free(file_name);
-    NS_Free(favicon_uri);
-    NS_Free(::gFavLocation);
+    if (::gFavLocation)
+      NS_Free(::gFavLocation);
     gFavLocation = nsnull;
     return;
   }
-  NS_Free(file_name);
-  NS_Free(favicon_uri);
 
   // save the favicon if the icon does not exist
   rv = target_file->Exists(&isExist);
   if (NS_SUCCEEDED(rv) && !isExist) {
     rv = persist->SaveURI(uri, nsnull, nsnull, nsnull, "", target_file);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv))
       return;
-    }
   }
-  else {
+  else
     GeneratePixBuf();
-  }
-
 }
 
 NS_IMETHODIMP
 EmbedEventListener::OnStateChange(nsIWebProgress *aWebProgress,
                                   nsIRequest *aRequest,
                                   PRUint32 aStateFlags,
                                   nsresult aStatus)
 {
   /* if (!(aStateFlags & (STATE_STOP | STATE_IS_NETWORK | STATE_IS_DOCUMENT))){*/
 
   if (aStateFlags & STATE_STOP)
     /* FINISH DOWNLOADING */
     /* XXX sometimes this==0x0 and it cause crash in GeneratePixBuf, need workaround check for this */
-    if (NS_SUCCEEDED(aStatus) && this)
+    if (NS_SUCCEEDED(aStatus) && this && aRequest && aWebProgress)
       GeneratePixBuf();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedEventListener::OnProgressChange(nsIWebProgress *aWebProgress,
                                      nsIRequest *aRequest,
@@ -933,8 +1125,103 @@
 
 NS_IMETHODIMP
 EmbedEventListener::OnSecurityChange(nsIWebProgress *aWebProgress,
                                      nsIRequest *aRequest,
                                      PRUint32 aState)
 {
   return NS_OK;
 }
+
+void
+EmbedEventListener::DisableLongPressTimer(GtkWidget *aOwningWidget)
+{
+  gint return_val;
+
+  if (sLongPressTimer)
+    g_source_remove(sLongPressTimer);
+
+  gtk_signal_emit(GTK_OBJECT(aOwningWidget),
+                  moz_embed_signals[DOM_MOUSE_UP],
+                  NULL, &return_val);
+
+  sMPressed = sIsScrolling ? PR_FALSE : sMPressed;
+  sIsScrolling = PR_FALSE;
+}
+
+#include <gdk/gdkx.h>
+/* static */
+gboolean
+motion_notify_event_cb (GtkWidget *widget, GdkEventMotion *event, EmbedEventListener *self)
+{
+  gint intx = nscoord(event->x_root);
+  gint inty = nscoord(event->y_root);
+  // Filtering all motion events, because our hardware is sh...
+  //if (ABS(sgX - intx) < sScrollStep
+   //   && ABS(sgY - inty) < sScrollStep)
+   //   return TRUE;
+
+  sgX = intx;
+  sgY = inty;
+
+  if (sXulType == 3)
+    return TRUE;
+
+  if ((sIsScrolling || sXulType == 2) && sXulType != 0) {
+    XEvent xevent;
+    PRPackedBool synthEvent = PR_FALSE;
+    while (XCheckWindowEvent(GDK_WINDOW_XDISPLAY(event->window),
+                             GDK_WINDOW_XWINDOW(event->window),
+                             ButtonMotionMask, &xevent)) {
+      synthEvent = PR_TRUE;
+    }
+
+    if (sXulType == 2) {
+      self->MouseMove(nsnull);
+      return FALSE;
+    }
+    self->MouseMove(nsnull);
+    return TRUE;
+  }
+  return FALSE;
+}
+
+/* static */
+gboolean
+button_release_event_cb (GtkWidget *widget, GdkEvent *event, EmbedPrivate *self)
+{
+  PanStatesReset(self);
+  sDoubleClick = PR_FALSE;
+  return FALSE;
+}
+
+/* static */
+gboolean
+button_press_event_cb (GtkWidget *widget, GdkEvent *event, EmbedPrivate *self)
+{
+  spX = nscoord(((GdkEventButton*)event)->x_root);
+  spY = nscoord(((GdkEventButton*)event)->y_root);
+  if ((((GdkEventButton*)event)->button == 1) &&
+      (event->type == GDK_2BUTTON_PRESS || event->type == GDK_3BUTTON_PRESS)) {
+      sDoubleClick = PR_TRUE;
+  }
+  sMBPressed = PR_TRUE;
+  return FALSE;
+}
+
+/* static */
+gboolean
+enter_notify_event_cb (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self)
+{
+  if (sXulType == 3)
+    return TRUE;
+  return FALSE;
+}
+
+/* static */
+gboolean
+leave_notify_event_cb (GtkWidget *widget, GdkEventCrossing *event, EmbedEventListener *self)
+{
+  if (sXulType == 3)
+    return TRUE;
+  return FALSE;
+}
+
Index: mozilla/embedding/browser/gtk/src/EmbedEventListener.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedEventListener.h
+++ mozilla/embedding/browser/gtk/src/EmbedEventListener.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -129,21 +129,25 @@
 
   nsresult   NewURI            (nsIURI **result,
                                 const char *spec);
   nsresult   GetIOService      (nsIIOService **ioService);
 
   void       GeneratePixBuf    ();
 
   void       GetFaviconFromURI (const char*  aURI);
+
+  static void DisableLongPressTimer(GtkWidget *aOwningWidget);
  private:
 
   EmbedPrivate *mOwner;
   EmbedContextMenuInfo *mCtxInfo;
 
   // Selection and some clipboard stuff
   nsCOMPtr<nsISelectionController> mCurSelCon;
   nsCOMPtr<nsISelectionController> mLastSelCon;
   PRBool mFocusInternalFrame;
   PRInt32 mClickCount;
+  PRBool mXSLTransformed;
+  PRBool mAddonSignals;
 };
 
 #endif /* __EmbedEventListener_h */
Index: mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGlobalHistory.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.cpp
@@ -18,16 +18,17 @@
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Conrad Carlen <ccarlen@netscape.com>
  *   Oleg Romashin <romaxa@gmail.com>
+ *   Andre Pedralho <apedralho@gmail.com>
  *   (from original mozilla/embedding/lite/nsEmbedGlobalHistory.cpp)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
@@ -53,17 +54,17 @@
 #ifndef MOZILLA_INTERNAL_API
 #include "nsCRT.h"
 #endif
 #include "nsILineInputStream.h"
 
 // Constants
 #define defaultSeparator 1
 // Number of changes in history before automatic flush
-static const PRInt32 kNewEntriesBetweenFlush = 10;
+static const PRInt32 kNewEntriesBetweenFlush = 20;
 static const PRInt32 kMaxSafeReadEntriesCount = 2000;
 // Default expiration interval: used if can't get preference service value
 static const PRUint32 kDefaultExpirationIntervalDays = 7;
 // Mozilla and EAL standard are different each other
 static const PRInt64 kMSecsPerDay = LL_INIT(0, 60 * 60 * 24 * 1000);
 static const PRInt64 kOneThousand = LL_INIT(0, 1000);
 // The history list and the entries counter
 static GList *mURLList;                 /** < The history list */
@@ -151,29 +152,28 @@
 {
   g_return_val_if_fail(file_handle, false);
   nsresult rv;
   nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(file_handle, &rv);
   rv = seekable->SetEOF();
   return NS_SUCCEEDED(rv);
 }
 
-static guint64 file_handle_write(OUTPUT_STREAM *file_handle, gpointer line)
+static bool file_handle_write(OUTPUT_STREAM *file_handle, gpointer line)
 {
   g_return_val_if_fail(file_handle, 0);
   PRUint32 amt = 0;
   nsresult rv;
   rv = file_handle->Write((char*)line, strlen((char*)line), &amt);
-  /* XXX booleans are not equivalent to guint64 */
   return NS_SUCCEEDED(rv);
 }
 
 // Static Routine Prototypes
-//GnomeVFSHandle
 static nsresult writeEntry(OUTPUT_STREAM *file_handle, HistoryEntry *entry);
+
 // when an entry is visited
 nsresult OnVisited(HistoryEntry *entry)
 {
   NS_ENSURE_ARG(entry);
   entry->mLastVisitTime = PR_Now();
   LL_DIV(entry->mLastVisitTime, entry->mLastVisitTime, kOneThousand);
   return NS_OK;
 }
@@ -205,36 +205,49 @@
 nsresult SetIsWritten(HistoryEntry *entry)
 {
   NS_ENSURE_ARG(entry);
   entry->mWritten = PR_TRUE;
   return NS_OK;
 }
 
 // Change the entry title
-#define SET_TITLE(entry, aTitle) (entry->mTitle.Assign(aTitle))
-
-// Return the entry title
-#define GET_TITLE(entry) (entry && !entry->mTitle.IsEmpty() ? entry->mTitle.get() : "")
-
-// Change the entry title
 nsresult SET_URL(HistoryEntry *aEntry, const char *aUrl)
 {
   NS_ENSURE_ARG(aEntry);
   NS_ENSURE_ARG(aUrl);
   aEntry->mUrl.Assign(aUrl);
   return NS_OK;
 }
 
 // Return the entry url
 const char* GET_URL(HistoryEntry *aEntry)
 {
   return (aEntry && !aEntry->mUrl.IsEmpty()) ? aEntry->mUrl.get() : "";
 }
 
+// Return the entry url
+const char* GET_HOST(HistoryEntry *aEntry)
+{
+  nsCOMPtr<nsIURI> aURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(aURI), GET_URL(aEntry));
+  if (NS_FAILED(rv))
+    return GET_URL(aEntry);
+  aURI->GetHost(aEntry->mTitle);
+  if (aEntry->mTitle.IsEmpty())
+    return GET_URL(aEntry);
+  return aEntry->mTitle.get();
+}
+
+// Change the entry title
+#define SET_TITLE(entry, aTitle) (entry->mTitle.Assign(aTitle))
+
+// Return the entry title
+#define GET_TITLE(entry) (entry && !entry->mTitle.IsEmpty() ? entry->mTitle.get() : GET_HOST(entry))
+
 // Traverse the history list trying to find a frame
 int history_entry_find_exist(gconstpointer a, gconstpointer b)
 {
   return g_ascii_strcasecmp((char*)GET_URL((HistoryEntry *)a), (char *) b);
 }
 
 // Traverse the history list looking for the correct place to add a new item
 int find_insertion_place(gconstpointer a, gconstpointer b)
@@ -279,32 +292,32 @@
   {
     sEmbedGlobalHistory = new EmbedGlobalHistory();
     if (!sEmbedGlobalHistory)
       return nsnull;
     NS_ADDREF(sEmbedGlobalHistory);   // addref the global
     if (NS_FAILED(sEmbedGlobalHistory->Init()))
     {
       NS_RELEASE(sEmbedGlobalHistory);
+      sEmbedGlobalHistory = nsnull;
       return nsnull;
     }
   }
   else
     NS_ADDREF(sEmbedGlobalHistory);   // addref the return result
   return sEmbedGlobalHistory;
 }
 
 /* static */
 void
 EmbedGlobalHistory::DeleteInstance()
 {
   if (sEmbedGlobalHistory)
-  {
     delete sEmbedGlobalHistory;
-  }
+  sEmbedGlobalHistory = nsnull;
 }
 
 // The global history component constructor
 EmbedGlobalHistory::EmbedGlobalHistory()
 : mFileHandle(nsnull)
 {
   if (!mURLList) {
     mDataIsLoaded = PR_FALSE;
@@ -315,52 +328,54 @@
     LL_MUL(mExpirationInterval, mExpirationInterval, kMSecsPerDay);
   }
 }
 
 // The global history component destructor
 EmbedGlobalHistory::~EmbedGlobalHistory()
 {
   LoadData();
-  FlushData(kFlushModeFullWrite);
+  mFlushModeFullWriteNeeded = PR_TRUE;
+  FlushData();
   if (mURLList) {
     g_list_foreach(mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
     g_list_free(mURLList);
     mURLList = NULL;
   }
   if (mFileHandle) {
     CLOSE_FILE_HANDLE(mFileHandle);
   }
   if (mHistoryFile) {
-    g_free(mHistoryFile);
+    NS_Free(mHistoryFile);
     mHistoryFile = nsnull;
   }
   if (sEmbedGlobalHistory)
     sEmbedGlobalHistory = nsnull;
 }
 
 // Initialize the global history component
 NS_IMETHODIMP EmbedGlobalHistory::Init()
 {
-  if (mURLList) return NS_OK;
+  if (mURLList)
+    return NS_OK;
   // Get Pref and convert to millisecs
 
   PRInt32 expireDays;
   int success = gtk_moz_embed_common_get_pref(G_TYPE_INT, EMBED_HISTORY_PREF_EXPIRE_DAYS, &expireDays);
   if (success) {
     LL_I2L(mExpirationInterval, expireDays);
     LL_MUL(mExpirationInterval, mExpirationInterval, kMSecsPerDay);
   }
   // register to observe profile changes
   nsCOMPtr<nsIObserverService> observerService =
     do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
   NS_ASSERTION(observerService, "failed to get observer service");
   if (observerService) {
     observerService->AddObserver(this, "quit-application", PR_FALSE);
-    observerService->AddObserver(this, "RemoveEntries", PR_FALSE);
+    observerService->AddObserver(this, "history-item-removed", PR_FALSE);
   }
   nsresult rv = InitFile();
   if (NS_FAILED(rv))
     return NS_ERROR_FAILURE;
   rv = LoadData();
   NS_ENSURE_SUCCESS(rv, rv);
   return rv;
 }
@@ -424,497 +439,667 @@
   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
   // Only get valid uri schemes
   if (!isHTTP && !isHTTPS)
   {
     /* the following blacklist is silly.
      * if there's some need to whitelist http(s) + ftp,
      * that's what we should do.
      */
-    PRBool isAbout, isImap, isNews, isMailbox, isViewSource, isChrome, isData, isJavascript;
+    PRBool isAbout, isImap, isNews, isMailbox, isViewSource, isChrome, isData, isJavascript, isLocal;
     rv  = aURI->SchemeIs("about", &isAbout);
     rv |= aURI->SchemeIs("imap", &isImap);
     rv |= aURI->SchemeIs("news", &isNews);
+    rv |= aURI->SchemeIs("file", &isLocal);
     rv |= aURI->SchemeIs("mailbox", &isMailbox);
     rv |= aURI->SchemeIs("view-source", &isViewSource);
     rv |= aURI->SchemeIs("chrome", &isChrome);
     rv |= aURI->SchemeIs("data", &isData);
     rv |= aURI->SchemeIs("javascript", &isJavascript);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     if (isAbout ||
         isImap ||
         isNews ||
+        isLocal ||
         isMailbox ||
         isViewSource ||
         isChrome ||
         isData ||
         isJavascript) {
       return NS_OK;
     }
   }
-#ifdef DEBUG
-  //  NS_WARNING("[HISTORY] Visited URL: %s\n", aURL);
-#endif
+
   rv = LoadData();
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_FAILED(rv))
+    return rv;
+
   GList *node = g_list_find_custom(mURLList, aURL, (GCompareFunc) history_entry_find_exist);
   HistoryEntry *entry = NULL;
   if (node && node->data)
     entry = (HistoryEntry *)(node->data);
   nsCAutoString hostname;
   aURI->GetHost(hostname);
 
-  // It is not in the history
+  // It is not in the history: add a new entry
   if (!entry) {
     entry = new HistoryEntry;
-    ALLOC_NOT_CHECKED(entry);
-    rv |= OnVisited(entry);
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    rv = OnVisited(entry);
+    if (NS_FAILED(rv)) {
+      NS_Free(entry);
+      return rv;
+    }
+
     SET_TITLE(entry, hostname);
-    rv |= SET_URL(entry, aURL);
-    BROKEN_RV_HANDLING_CODE(rv);
+    rv = SET_URL(entry, aURL);
+    if (NS_FAILED(rv)) {
+      NS_Free(entry);
+      return rv;
+    }
+
     unsigned int listSize = g_list_length(mURLList);
     if (listSize+1 > kDefaultMaxSize) {
       GList *last = g_list_last(mURLList);
       mURLList = g_list_remove(mURLList, last->data);
     }
     mURLList = g_list_insert_sorted(mURLList, entry,
                                     (GCompareFunc) find_insertion_place);
+
     // Flush after kNewEntriesBetweenFlush changes
-    BROKEN_RV_HANDLING_CODE(rv);
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeAppend);
-    // At this point, something understands there's a new global history item
-  } else {
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return rv;
+    }
+  }
+  // It is already in the history: just update the entry
+  else {
     // update the last visited time
-    rv |= OnVisited(entry);
+    rv = OnVisited(entry);
+    if (NS_FAILED(rv))
+      return rv;
+
     SET_TITLE(entry, hostname);
     // Move the element to the start of the list
-    BROKEN_RV_HANDLING_CODE(rv);
     mURLList = g_list_remove(mURLList, entry);
     mURLList = g_list_insert_sorted(mURLList, entry, (GCompareFunc) find_insertion_place);
+
     // Flush after kNewEntriesBetweenFlush changes
-    BROKEN_RV_HANDLING_CODE(rv);
-    
     mFlushModeFullWriteNeeded = PR_TRUE;
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeFullWrite);
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return rv;
+    }
   }
-  return rv;
+  return NS_OK;
 }
 
 // Return TRUE if the url is already in history
 NS_IMETHODIMP EmbedGlobalHistory::IsVisited(nsIURI *aURI, PRBool *_retval)
 {
   NS_ENSURE_ARG(aURI);
   NS_ENSURE_ARG_POINTER(_retval);
   nsCAutoString URISpec;
   aURI->GetSpec(URISpec);
   const char *aURL = URISpec.get();
   nsresult rv = LoadData();
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  // find the element in the history list
   GList *node = g_list_find_custom(mURLList, aURL,
                                    (GCompareFunc) history_entry_find_exist);
   *_retval = (node && node->data);
-  return rv;
+  return NS_OK;
 }
 
 // It is called when Mozilla get real name of a URL
 NS_IMETHODIMP EmbedGlobalHistory::SetPageTitle(nsIURI *aURI,
                                                const nsAString & aTitle)
 {
   NS_ENSURE_ARG(aURI);
   nsresult rv;
   // skip about: URIs to avoid reading in the db (about:blank, especially)
   PRBool isAbout;
   rv = aURI->SchemeIs("about", &isAbout);
   NS_ENSURE_SUCCESS(rv, rv);
   if (isAbout)
     return NS_OK;
+
+  // load the stored history
+  rv = LoadData();
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsCAutoString URISpec;
   aURI->GetSpec(URISpec);
   const char *aURL = URISpec.get();
-  rv |= LoadData();
-  BROKEN_RV_HANDLING_CODE(rv);
-  NS_ENSURE_SUCCESS(rv, rv);
 
+  // find the entry in the history list
   GList *node = g_list_find_custom(mURLList, aURL,
                                    (GCompareFunc) history_entry_find_exist);
   HistoryEntry *entry = NULL;
-  if (node)
-    entry = (HistoryEntry *)(node->data);
-  if (entry) {
+
+  // entry not found
+  if (!node)
+    return NS_ERROR_FAILURE;
+
+  entry = (HistoryEntry *)(node->data);
+
+  // change the entry content
+  if (!entry) {
+    return NS_ERROR_FAILURE;
+  }
+  else {
     SET_TITLE(entry, NS_ConvertUTF16toUTF8(aTitle).get());
-    BROKEN_RV_HANDLING_CODE(rv);
-    
+
+    // flush after kNewEntriesBetweenFlush entries found
     mFlushModeFullWriteNeeded = PR_TRUE;
-    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush)
-      rv |= FlushData(kFlushModeFullWrite);
-    BROKEN_RV_HANDLING_CODE(rv);
+    if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+      rv = FlushData();
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+    }
   }
-  return rv;
+
+  return NS_OK;
 }
 
 nsresult EmbedGlobalHistory::RemoveEntries(const PRUnichar *url, int time)
 {
-  nsresult rv = NS_ERROR_FAILURE;
+  nsresult rv;
+
+  // there is no history list
   if (!mURLList)
-    return rv;
+    return NS_ERROR_FAILURE;
 
+  // the item to be removed is a URL
   if (url) {
     GList *node = g_list_find_custom(mURLList, NS_ConvertUTF16toUTF8(url).get(), (GCompareFunc) history_entry_find_exist);
-    if (!node) return rv;
-    if (node->data) {
-      HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry *,
-                                           node->data);
+    if (!node)
+      return NS_ERROR_FAILURE;
+    if (!(node->data)) {
+      return NS_ERROR_FAILURE;
+    }
+    else {
+      HistoryEntry *entry = static_cast<HistoryEntry *>
+                                           (node->data);
 
       entry->mLastVisitTime = 0;
+      mURLList = g_list_remove_link(mURLList, node);
       delete entry;
-      mURLList = g_list_remove(mURLList, entry);
     }
-  } else {
+  }
+  // the item to be removed is a folder
+  else {
     g_list_foreach (mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
     g_list_free(mURLList);
     mURLList = NULL;
   }
 
+  // flush after kNewEntriesBetweenFlush changes
   mFlushModeFullWriteNeeded = PR_TRUE;
-  mEntriesAddedSinceFlush++;
-  rv = FlushData(kFlushModeFullWrite);
-
-  return rv;
+  if (++mEntriesAddedSinceFlush >= kNewEntriesBetweenFlush) {
+    rv = FlushData();
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
 }
 
 //*****************************************************************************
 // EmbedGlobalHistory::nsIObserver
 //*****************************************************************************
 NS_IMETHODIMP EmbedGlobalHistory::Observe(nsISupports *aSubject,
                                           const char *aTopic,
                                           const PRUnichar *aData)
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+
   // used when the browser is closed and the EmbedGlobalHistory destructor is not called
   if (strcmp(aTopic, "quit-application") == 0) {
+    // load the history data to ensure that all the history items stored in the file were properly loaded
     rv = LoadData();
-    // we have to sort the list before flush it
-    rv |= FlushData(kFlushModeFullWrite);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+    // flush the history data
+    rv = FlushData();
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+    // free the history list
     if (mURLList) {
       g_list_foreach(mURLList, (GFunc) history_entry_foreach_to_remove, NULL);
       g_list_free(mURLList);
       mURLList = NULL;
     }
+    // close the history file
     if (mFileHandle) {
       CLOSE_FILE_HANDLE(mFileHandle);
     }
-  } else if (strcmp(aTopic, "RemoveEntries") == 0) {
-    rv |= RemoveEntries(aData, 0);
   }
-  return rv;
+  // used when the user wants to remove a history item
+  else if (strcmp(aTopic, "history-item-removed") == 0) {
+    rv = RemoveEntries(aData, 0);
+    if(NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
 }
 
 static nsresult
 GetHistoryFileName(char **aHistoryFile)
 {
   NS_ENSURE_ARG_POINTER(aHistoryFile);
   // Get the history file in our profile dir.
   // Notice we are not just getting NS_APP_HISTORY_50_FILE
   // because it is used by the "real" global history component.
+  nsCAutoString tempDirString;
+  // there is a profile set
   if (EmbedPrivate::sProfileDir) {
     nsCString path;
     EmbedPrivate::sProfileDir->GetNativePath(path);
-    *aHistoryFile = g_strdup_printf("%s/history.dat", path.get());
-    BROKEN_STRING_BUILDER(aHistoryFile);
-  } else {
-    *aHistoryFile = g_strdup_printf("%s/history.dat", g_get_tmp_dir());
-    BROKEN_STRING_BUILDER(aHistoryFile);
+
+    tempDirString.Assign(path.get());
+  }
+  // there is no profile set
+  else
+  {
+    // get the temporary directory
+    tempDirString.Assign(g_get_tmp_dir());
   }
+  // the history file name
+  tempDirString.Append(NS_LITERAL_CSTRING("/history.txt"));
+  // return the full history path
+  *aHistoryFile = ToNewCString(tempDirString);
+  if (!(*aHistoryFile))
+    return NS_ERROR_OUT_OF_MEMORY;
   return NS_OK;
 }
+
 //*****************************************************************************
 // EmbedGlobalHistory
 //*****************************************************************************
-// Open/Create the history.dat file if it does not exist
+// Open/Create the history.txt file if it does not exist
 nsresult EmbedGlobalHistory::InitFile()
 {
-  if (!mHistoryFile) {
+  // the history file is not initialized
+  if (!mHistoryFile)
     if (NS_FAILED(GetHistoryFileName(&mHistoryFile)))
       return NS_ERROR_FAILURE;
-  }
 
   LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
   if (!uri)
     return NS_ERROR_FAILURE;
 
   gboolean rs = FALSE;
+  // there is not a history file
   if (!file_handle_uri_exists(uri)) {
+    // create the history file
     if (!file_handle_create_uri(&mFileHandle, uri)) {
-      NS_WARNING("Could not create a history file\n");
+      NS_WARNING("Could not create a history file");
       file_handle_uri_release(uri);
       return NS_ERROR_FAILURE;
     }
+    // close the history file
     CLOSE_FILE_HANDLE(mFileHandle);
   }
+  // open the history file
   rs = file_handle_open_uri(&mFileHandle, uri);
 
   file_handle_uri_release(uri);
 
   if (!rs) {
-    NS_WARNING("Could not open a history file\n");
+    NS_WARNING("Could not open a history file");
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
-// Get the data from history.dat file
+// Get the data from history.txt file
 nsresult EmbedGlobalHistory::LoadData()
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // the data is not loaded
   if (!mDataIsLoaded) {
-    mDataIsLoaded = PR_TRUE;
+    // create the history file handle
     LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
-    if (uri) {
-      rv |= ReadEntries(uri);
+    // could not create a history file handle
+    if (!uri) {
+      return NS_ERROR_FAILURE;
+    }
+    else {
+      rv = ReadEntries(uri);
+      // could not read the history entries
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
       file_handle_uri_release(uri);
     }
+    mDataIsLoaded = PR_TRUE;
   }
-  return rv;
+  return NS_OK;
 }
 
-// Call a function to write each entry in the history hash table
 nsresult EmbedGlobalHistory::WriteEntryIfWritten(GList *list, OUTPUT_STREAM *file_handle)
 {
-  if (!file_handle)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_ARG_POINTER(file_handle);
 
+  // get the history length;
   unsigned int counter = g_list_length(list);
+
+  // for each history entry
   while (counter > 0) {
-    HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry*, g_list_nth_data(list, counter-1));
+    // get a history entry
+    HistoryEntry *entry = static_cast<HistoryEntry*>(g_list_nth_data(list, counter-1));
     counter--;
-    if (!entry || entryHasExpired(entry)) {
+
+    // could not get a history entry
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    // the entry has expired so does not store it in the history file
+    if (entryHasExpired(entry))
       continue;
-    }
+
+    // write the entry in the history file
     writeEntry(file_handle, entry);
   }
   return NS_OK;
 }
 
-// Call a function to write each unwritten entry in the history hash table
 nsresult EmbedGlobalHistory::WriteEntryIfUnwritten(GList *list, OUTPUT_STREAM *file_handle)
 {
-  if (!file_handle)
-    return NS_ERROR_FAILURE;
+  NS_ENSURE_ARG_POINTER(file_handle);
+
+  // get the history length;
   unsigned int counter = g_list_length(list);
+
+  // for each history entry
   while (counter > 0) {
-    HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry*, g_list_nth_data(list, counter-1));
-    if (!entry || entryHasExpired(entry)) {
-      counter--;
+    // get a history entry
+    HistoryEntry *entry = static_cast<HistoryEntry*>(g_list_nth_data(list, counter-1));
+    counter--;
+
+    // could not get a history entry
+    if (!entry)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    // the entry has expired so don't store it in the history file
+    if(entryHasExpired(entry))
       continue;
-    }
+
+    // the entry has not been written
     if (!GetIsWritten(entry))
       writeEntry(file_handle, entry);
-    counter--;
   }
   return NS_OK;
 }
 
-// Write the history in history.dat file
-nsresult EmbedGlobalHistory::FlushData(PRIntn mode)
+nsresult EmbedGlobalHistory::FlushData()
 {
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // there are no history entries to be added
   if (mEntriesAddedSinceFlush == 0)
     return NS_OK;
+
+  // there is no history file handle
   if (!mHistoryFile)
   {
+    // create the history file
     rv = InitFile();
     NS_ENSURE_SUCCESS(rv, rv);
-    rv = FlushData(kFlushModeFullWrite);
-    return rv;
-  }
-  LOCAL_FILE *uri = file_handle_uri_new(mHistoryFile);
-  if (!uri) return NS_ERROR_FAILURE;
 
-  gboolean rs = file_handle_uri_exists(uri);
-  file_handle_uri_release(uri);
-
-  if (!rs && NS_FAILED(rv))
-    return NS_ERROR_FAILURE;
+    mFlushModeFullWriteNeeded = PR_TRUE;
+    rv = FlushData();
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
 
-  if (mode == kFlushModeFullWrite || mFlushModeFullWriteNeeded == PR_TRUE)
+  if (mFlushModeFullWriteNeeded)
   {
     if (!file_handle_seek(mFileHandle, FALSE))
       return NS_ERROR_FAILURE;
     if (!file_handle_truncate(mFileHandle))
       return NS_ERROR_FAILURE;
     WriteEntryIfWritten(mURLList, mFileHandle);
     mFlushModeFullWriteNeeded = PR_FALSE;
   }
+  // just need to append some entries
   else
   {
+    // go to the end of the history file
     if (!file_handle_seek(mFileHandle, TRUE))
       return NS_ERROR_FAILURE;
     WriteEntryIfUnwritten(mURLList, mFileHandle);
   }
-
   mEntriesAddedSinceFlush = 0;
   return NS_OK;
 }
 
 // Split an entry in last visit time, title and url.
-// Add a stored entry in the history.dat file in the history hash table
-nsresult EmbedGlobalHistory::GetEntry(const char *entry)
+// Add a stored entry in the history.txt file in the history list
+nsresult EmbedGlobalHistory::GetEntry(nsCString& string)
 {
+  char *entry = string.BeginWriting();
+  PRInt32 str_len = string.Length();
   char separator = (char) defaultSeparator;
   int pos = 0;
   nsInt64 outValue = 0;
+  // get the last visit time from the given entry
   while (PR_TRUE) {
     PRInt32 digit;
+    // it is a separator: get the next digit
     if (entry[pos] == separator) {
       pos++;
       break;
     }
-    if (entry[pos] == '\0' || !isdigit(entry[pos]))
+    // it is the end of a word or is not a number
+    if (str_len <= pos || entry[pos] == '\0' || !isdigit(entry[pos]))
       return NS_ERROR_FAILURE;
     digit = entry[pos] - '0';
+    // add the new digit found to the previous ones
     outValue *= nsInt64(10);
     outValue += nsInt64(digit);
     pos++;
   }
-  char url[1024], title[1024];
+  char *url=&entry[pos];
   int urlLength= 0, titleLength= 0, numStrings=1;
-  // get the url and title
+  // get the url and title from the given entry
   // FIXME
   while(PR_TRUE) {
+    if (str_len <= pos) break;
+    // it is a separator: get the next character
     if (entry[pos] == separator) {
       numStrings++;
       pos++;
       continue;
     }
+    // there are no more strings to be found
     if (numStrings > 2)
       break;
-    if (numStrings==1) {
-      url[urlLength++] = entry[pos];
-    } else {
-      title[titleLength++] = entry[pos];
-  }
-  pos++;
+    // it is the first string found: the url
+    if (numStrings == 1)
+      urlLength++;
+    // it is the second string found: the title
+    else
+      titleLength++;
+    pos++;
   }
+  // terminate the strings properly
+  if (!urlLength || !titleLength)
+    return NS_ERROR_FAILURE;
+
   url[urlLength]='\0';
+  char *title=&url[urlLength + 1];
   title[titleLength]='\0';
+
+  // create a new history entry
   HistoryEntry *newEntry = new HistoryEntry;
   if (!newEntry)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  nsresult rv = NS_OK;
+  nsresult rv;
+  // initialize the title of the new entry
   SET_TITLE(newEntry, title);
-  rv |= SetLastVisitTime(newEntry, outValue);
-  rv |= SetIsWritten(newEntry);
-  rv |= SET_URL(newEntry, url);
-  BROKEN_RV_HANDLING_CODE(rv);
-  // Check wheter the entry has expired
-  if (!entryHasExpired(newEntry)) {
+  // initialize the last visit time of the new entry
+  rv = SetLastVisitTime(newEntry, outValue);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+  // initialize the isWritten flag of the new entry: it is in the history file
+  rv = SetIsWritten(newEntry);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+  // initialize the url of the new entry
+  rv = SET_URL(newEntry, url);
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  // Check whether the entry has expired and then add it to the history list
+  if (!entryHasExpired(newEntry))
     mURLList = g_list_prepend(mURLList, newEntry);
-  }
-  return rv;
+  return NS_OK;
 }
 
-
-// Get the history entries from history.dat file
+// Get the history entries from history.txt file
 nsresult EmbedGlobalHistory::ReadEntries(LOCAL_FILE *file_uri)
 {
+  // the history file handle has not been initialized
   if (!file_uri)
     return NS_ERROR_FAILURE;
 
   nsresult rv = NS_OK;
-
+  // create an input stream
   nsCOMPtr<nsIInputStream> fileStream;
   NS_NewLocalFileInputStream(getter_AddRefs(fileStream), file_uri);
   if (!fileStream)
     return NS_ERROR_OUT_OF_MEMORY;
   nsCOMPtr<nsILineInputStream> lineStream = do_QueryInterface(fileStream, &rv);
   NS_ASSERTION(lineStream, "File stream is not an nsILineInputStream");
   // Read the header
   nsCString utf8Buffer;
   PRBool moreData = PR_FALSE;
 
   PRInt32 safe_limit = 0;
+  // get the file content line by line
   do {
     rv = lineStream->ReadLine(utf8Buffer, &moreData);
     safe_limit++;
     if (NS_FAILED(rv))
-      return NS_OK;
+      break;
 
+    // go to the next line: might be a blank line in the file
     if (utf8Buffer.IsEmpty())
       continue;
-    rv = GetEntry(utf8Buffer.get());
+
+    // add the entry to the history
+    rv = GetEntry(utf8Buffer);
+    if (NS_FAILED(rv))
+      break;
   } while (moreData && safe_limit < kMaxSafeReadEntriesCount);
+  // close the file stream
   fileStream->Close();
-
   return rv;
 }
 
 //*****************************************************************************
 // Static Functions
 //*****************************************************************************
-// Get last visit time from a string
+// Transform the last visit time from a PRInt64 to a string
 static nsresult writePRInt64(char time[14], const PRInt64& inValue)
 {
   nsInt64 value(inValue);
+  // the inValue is 0, then return a "0" string
   if (value == nsInt64(0)) {
-    strcpy(time, "0");
+    strncpy(time, "0", 1);
     return NS_OK;
   }
   nsCAutoString tempString;
+  // transform the PRInt64 in a nsCAutoString, digit by digit
   while (value != nsInt64(0)) {
     PRInt32 ones = PRInt32(value % nsInt64(10));
     value /= nsInt64(10);
     tempString.Insert(char('0' + ones), 0);
   }
-  strcpy(time,(char *) tempString.get());
+  // transform the nsCAutoString to a string
+  strncpy(time,(char *) tempString.get(), 14);
   return NS_OK;
 }
 
-// Write an entry in the history.dat file
+// Write an entry in the history.txt file
 nsresult writeEntry(OUTPUT_STREAM *file_handle, HistoryEntry *entry)
 {
-  nsresult rv = NS_OK;
-  char sep = (char) defaultSeparator;
+  nsresult rv;
   char time[14];
+  nsCAutoString tempString;
+
+  // get the string equivalent to a PRInt64 value
   writePRInt64(time, GetLastVisitTime(entry));
-  char *line = g_strdup_printf("%s%c%s%c%s%c\n", time, sep, GET_URL(entry), sep, GET_TITLE(entry), sep);
-  BROKEN_STRING_BUILDER(line);
-  guint64 size = file_handle_write(file_handle, (gpointer)line);
-  if (size != strlen(line))
-    rv = NS_ERROR_FAILURE;
-  rv |= SetIsWritten(entry);
-  g_free(line);
-  return rv;
+
+  // add the time string to the entry line
+  tempString.Assign(time);
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the url string to the entry line
+  tempString.Append(GET_URL(entry));
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the title string to the entry line
+  tempString.Append(GET_TITLE(entry));
+  // add a separator to the entry line
+  tempString.Append(defaultSeparator);
+  // add the line separator to the entry line
+  tempString.Append("\n");
+
+  // write the new line to the file
+  guint64 size = file_handle_write(file_handle, (gpointer) tempString.get());
+
+  // could not write all the line to the file
+  if (size != tempString.Length())
+    rv = NS_ERROR_OUT_OF_MEMORY;
+  rv = SetIsWritten(entry);
+  if (NS_FAILED(rv))
+    return rv;
+  return NS_OK;
 }
 
-nsresult EmbedGlobalHistory::GetContentList(GtkMozHistoryItem **GtkHI, int *count)
+nsresult EmbedGlobalHistory::GetContentList(GtkMozHistoryItem **aHistoryVector, int *aCounter)
 {
-  if (!mURLList) return NS_ERROR_FAILURE;
+  // the history list has not been initialized
+  if (!mURLList)
+    return NS_ERROR_FAILURE;
 
-  unsigned int num_items = 0;
-  *GtkHI = g_new0(GtkMozHistoryItem, g_list_length(mURLList));
-  UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(*GtkHI);
-  GtkMozHistoryItem * item = (GtkMozHistoryItem *)*GtkHI;
-  while (num_items < g_list_length(mURLList)) {
-    HistoryEntry *entry = NS_STATIC_CAST(HistoryEntry*,
-                                         g_list_nth_data(mURLList, num_items));
+  // create a new history vector
+  *aHistoryVector = g_try_new0(GtkMozHistoryItem, g_list_length(mURLList));
+  if (!(*aHistoryVector))
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  GtkMozHistoryItem * aItem = (GtkMozHistoryItem *)*aHistoryVector;
+  // get the history items one by one
+  while ((uint)*aCounter < g_list_length(mURLList)) {
+    HistoryEntry *entry = static_cast<HistoryEntry*>
+                                         (g_list_nth_data(mURLList, *aCounter));
     // verify if the entry has expired and discard it
-    if (entryHasExpired(entry)) {
+    if (entryHasExpired(entry))
       break;
-    }
+
     glong accessed;
+    // transform the last visit time to a readable value in microsecs
     PRInt64 temp, outValue;
     LL_MUL(outValue, GetLastVisitTime(entry), kOneThousand);
     LL_DIV(temp, outValue, PR_USEC_PER_SEC);
     LL_L2I(accessed, temp);
-    // Set the External history list
-    item[num_items].title = GET_TITLE(entry);
-    BROKEN_STRING_BUILDER(item[num_items].title);
-    item[num_items].url = GET_URL(entry);
-    item[num_items].accessed = accessed;
-    num_items++;
+    // set history vector title value
+    aItem[*aCounter].title = (const char *) GET_TITLE(entry);
+
+    if (!aItem[*aCounter].title)
+      return NS_ERROR_OUT_OF_MEMORY;
+    // set history vector url value
+    aItem[*aCounter].url = (const char *)GET_URL(entry);
+    if (!aItem[*aCounter].url)
+      return NS_ERROR_OUT_OF_MEMORY;
+    // set history vector accessed flag
+    aItem[*aCounter].accessed = accessed;
+    // count one more history item
+    (*aCounter)++;
   }
-  *count = num_items;
   return NS_OK;
 }
-
Index: mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGlobalHistory.h
+++ mozilla/embedding/browser/gtk/src/EmbedGlobalHistory.h
@@ -16,17 +16,17 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Conrad Carlen <ccarlen@netscape.com>
- *   Changes: andre.pedralho@indt.org.br (from original:  mozilla/embedding/lite/nsEmbedGlobalHistory.h)
+ *   Changes: apedralho@gmail.com (from original:  mozilla/embedding/lite/nsEmbedGlobalHistory.h)
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -68,20 +68,16 @@
     NS_IMETHOD        Init();
     nsresult GetContentList(GtkMozHistoryItem**, int *count);
     NS_DECL_ISUPPORTS
     NS_DECL_NSIGLOBALHISTORY2
     NS_DECL_NSIOBSERVER
     nsresult RemoveEntries(const PRUnichar *url = nsnull, int time = 0);
 
     protected:
-    enum {
-        kFlushModeAppend,      /** < Add a new entry in the history file */
-        kFlushModeFullWrite    /** < Rewrite all history file */
-    };
 /** Initiates the history file
   * @return NS_OK on the success.
   */
     nsresult          InitFile();
 /** Loads the history file
   * @return NS_OK on the success.
   */
     nsresult          LoadData();
@@ -96,31 +92,31 @@
  * @param handle A Gnome VFS handle.
  * @return NS_OK on the success.
 */
     nsresult          WriteEntryIfUnwritten(GList *list, OUTPUT_STREAM *file_handle);
 /** Writes entries in the history file
   * @param mode How to write in the history file
   * @return NS_OK on the success.
   */
-    nsresult          FlushData(PRIntn mode = kFlushModeFullWrite);
+    nsresult          FlushData();
  /** Remove entries from the URL table
   * @return NS_OK on the success.
   */
     nsresult          ResetData();
 /** Reads the history entries using GnomeVFS
   * @param vfs_handle A Gnome VFS handle.
   * @return NS_OK on the success.
   */
     nsresult          ReadEntries(LOCAL_FILE *file_uri);
 /** Gets a history entry 
   * @param name The history entry name.
   * @return NS_OK if the history entry name was gotten.
   */
-    nsresult          GetEntry(const char *);
+    nsresult          GetEntry(nsCString &string);
     protected:
     OUTPUT_STREAM    *mFileHandle;              /** < The History File handle */
     PRBool            mDataIsLoaded;            /** < If the data is loaded */
     PRBool            mFlushModeFullWriteNeeded;/** < If needs a full flush */
     PRInt32           mEntriesAddedSinceFlush;  /** < Number of entries added since flush */
     gchar*            mHistoryFile;             /** < The history file path */
 };
 // Default maximum history entries
Index: mozilla/embedding/browser/gtk/src/EmbedGtkTools.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGtkTools.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedGtkTools.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
+ * Oleg Romashin.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -41,36 +41,40 @@
 #ifndef MOZILLA_INTERNAL_API
 #include "nsServiceManagerUtils.h"
 #endif
 #include "EmbedPrivate.h"
 
 GtkWidget * GetGtkWidgetForDOMWindow(nsIDOMWindow* aDOMWindow)
 {
   nsCOMPtr<nsIWindowWatcher> wwatch = do_GetService("@mozilla.org/embedcomp/window-watcher;1");
-  if (!aDOMWindow)
-    return NULL;
   nsCOMPtr<nsIWebBrowserChrome> chrome;
-  wwatch->GetChromeForWindow(aDOMWindow, getter_AddRefs(chrome));
-  if (!chrome) {
-    return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
+  if (wwatch) {
+    if (!aDOMWindow) {
+      nsCOMPtr <nsIDOMWindow> DOMWindow;
+      wwatch->GetActiveWindow(getter_AddRefs(DOMWindow));
+      wwatch->GetChromeForWindow(DOMWindow, getter_AddRefs(chrome));
+    } else
+      wwatch->GetChromeForWindow(aDOMWindow, getter_AddRefs(chrome));
   }
 
+  if (!chrome)
+    return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
+
   nsCOMPtr<nsIEmbeddingSiteWindow> siteWindow = nsnull;
   siteWindow = do_QueryInterface(chrome);
 
-  if (!siteWindow) {
+  if (!siteWindow)
     return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
-  }
 
   GtkWidget* parentWidget;
   siteWindow->GetSiteWindow((void**)&parentWidget);
   if (GTK_IS_WIDGET(parentWidget))
     return parentWidget;
-  return NULL;
+  return GTK_WIDGET(EmbedCommon::GetAnyLiveWidget());
 }
 
 GtkWindow * GetGtkWindowForDOMWindow(nsIDOMWindow* aDOMWindow)
 {
   GtkWidget* parentWidget = GetGtkWidgetForDOMWindow(aDOMWindow);
   if (!parentWidget)
     return NULL;
   GtkWidget* gtkWin = gtk_widget_get_toplevel(parentWidget);
Index: mozilla/embedding/browser/gtk/src/EmbedGtkTools.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedGtkTools.h
+++ mozilla/embedding/browser/gtk/src/EmbedGtkTools.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Oleg Romashin. Portions created by Oleg Romashin are Copyright (C) Oleg Romashin.  All Rights Reserved.
+ * Oleg Romashin.
  * Portions created by the Initial Developer are Copyright (C) 2006
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Oleg Romashin <romaxa@gmail.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -59,9 +59,22 @@
 GetGtkWidgetForDOMWindow(nsIDOMWindow* aDOMWindow);
 
 GtkWindow*
 GetGtkWindowForDOMWindow(nsIDOMWindow* aDOMWindow);
 
 nsresult
 GetContentViewer(nsIWebBrowser *webBrowser, nsIContentViewer **aViewer);
 
+/* Helper Macros */
+
+#define GLIB_IF_PTR_FUNC_NULL(_ptr, _func) \
+  PR_BEGIN_MACRO                           \
+    if (_ptr) {                            \
+      _func(_ptr);                         \
+      (_ptr) = 0;                          \
+    }                                      \
+  PR_END_MACRO
+
+#define GLIB_SOURCE_IF_REMOVE(_ptr) GLIB_IF_PTR_FUNC_NULL(_ptr, g_source_remove)
+
 #endif /* __EmbedTools_h */
+
Index: mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPasswordMgr.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.cpp
@@ -105,44 +105,47 @@
 #include "nsIPasswordInternal.h"
 #include <string.h>
 
 
 static const char kPMPropertiesURL[] = "chrome://passwordmgr/locale/passwordmgr.properties";
 static PRBool sRememberPasswords = PR_FALSE;
 static PRBool sForceAutocompletion = PR_FALSE;
 static PRBool sPrefsInitialized = PR_FALSE;
-static nsIStringBundle* sPMBundle;
-static nsISecretDecoderRing* sDecoderRing;
-static EmbedPasswordMgr* sPasswordManager;
+static nsIStringBundle* sPMBundle = nsnull;
+static nsISecretDecoderRing* sDecoderRing = nsnull;
+static EmbedPasswordMgr* sPasswordManager = nsnull;
+
 class EmbedPasswordMgr::SignonDataEntry
 {
 public:
   nsString userField;
   nsString userValue;
   nsString passField;
   nsString passValue;
   SignonDataEntry* next;
   SignonDataEntry() : next(nsnull) { }
   ~SignonDataEntry() {
     delete next;
+    next = nsnull;
   }
 };
 
 class EmbedPasswordMgr::SignonHashEntry
 {
   // Wraps a pointer to the linked list of SignonDataEntry objects.
   // This allows us to adjust the head of the linked list without a
   // hashtable operation.
 public:
   SignonDataEntry* head;
   SignonHashEntry(SignonDataEntry* aEntry) : head(aEntry) { }
   ~SignonHashEntry()
   {
     delete head;
+    head = nsnull;
   }
 };
 
 class EmbedPasswordMgr::PasswordEntry : public nsIPasswordInternal
 {
 public:
   PasswordEntry(const nsACString& aKey, SignonDataEntry* aData);
   virtual ~PasswordEntry() { }
@@ -236,37 +239,41 @@
   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIPasswordManager)
   NS_INTERFACE_MAP_ENTRY(nsIPromptFactory)
 NS_INTERFACE_MAP_END
 
 EmbedPasswordMgr::EmbedPasswordMgr()
 : mAutoCompletingField(nsnull), mCommonObject(nsnull)
 {
+  if (!sPasswordManager) {
+    sPasswordManager = this;
+    NS_ADDREF(sPasswordManager);   // addref the global
+  }
 }
 
 EmbedPasswordMgr::~EmbedPasswordMgr()
 {
+  sPasswordManager = nsnull;
 }
 
 /* static */
 EmbedPasswordMgr*
 EmbedPasswordMgr::GetInstance()
 {
   if (!sPasswordManager) {
-    sPasswordManager = new EmbedPasswordMgr();
+    EmbedPasswordMgr* pwd = new EmbedPasswordMgr();
     if (!sPasswordManager)
       return nsnull;
-    NS_ADDREF(sPasswordManager);   // addref the global
     if (NS_FAILED(sPasswordManager->Init())) {
       NS_RELEASE(sPasswordManager);
       return nsnull;
     }
   }
-  NS_ADDREF(sPasswordManager);   // addref the return result
+  NS_ADDREF(sPasswordManager);   // addref the global
   return sPasswordManager;
 }
 
 nsresult
 EmbedPasswordMgr::Init()
 {
   mSignonTable.Init();
   mRejectTable.Init();
@@ -287,24 +294,22 @@
   // prefill passwords.
   nsCOMPtr<nsIObserverService> obsService = do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
   NS_ASSERTION(obsService, "No observer service");
   obsService->AddObserver(this, NS_FORMSUBMIT_SUBJECT, PR_TRUE);
   nsCOMPtr<nsIWebProgress> progress = do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
   NS_ASSERTION(progress, "No web progress service");
   progress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_DOCUMENT);
   // Now read in the signon file
-  char* signonFile = nsnull;
-  mPrefBranch->GetCharPref("SignonFileName", &signonFile);
-  NS_ASSERTION(signonFile, "Fallback for signon filename not present");
+  nsCString signonFile;
+  mPrefBranch->GetCharPref("SignonFileName", getter_Copies(signonFile));
+  NS_ASSERTION(!signonFile.IsEmpty(), "Fallback for signon filename not present");
   NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(mSignonFile));
   NS_ENSURE_TRUE(mSignonFile, NS_ERROR_FAILURE);
-  mSignonFile->AppendNative(nsCString(signonFile));
-  nsCString path;
-  mSignonFile->GetNativePath(path);
+  mSignonFile->AppendNative(signonFile);
   ReadPasswords(mSignonFile);
   return NS_OK;
 }
 
 /* static */ PRBool
 EmbedPasswordMgr::SingleSignonEnabled()
 {
   if (!sPrefsInitialized) {
@@ -319,49 +324,57 @@
                            nsIFile* aPath,
                            const char* aRegistryLocation,
                            const char* aComponentType,
                            const nsModuleComponentInfo* aInfo)
 {
   // By registering in NS_PASSWORDMANAGER_CATEGORY, an instance of the password
   // manager will be created when a password input is added to a form.  We
   // can then register that singleton instance as a form submission observer.
+
   nsresult rv;
   nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
-  char* prevEntry;
+
   catman->AddCategoryEntry(NS_PASSWORDMANAGER_CATEGORY,
                            "MicroB Password Manager",
                            NS_PASSWORDMANAGER_CONTRACTID,
                            PR_TRUE,
                            PR_TRUE,
-                           &prevEntry);
+                           nsnull);
 
   catman->AddCategoryEntry("app-startup",
                            "MicroB Password Manager",
                            NS_PASSWORDMANAGER_CONTRACTID,
                            PR_TRUE,
                            PR_TRUE,
-                           &prevEntry);
+                           nsnull);
 
   return NS_OK;
 }
 
 /* static */ NS_METHOD
 EmbedPasswordMgr::Unregister(nsIComponentManager* aCompMgr,
                              nsIFile* aPath,
                              const char* aRegistryLocation,
                              const nsModuleComponentInfo* aInfo)
 {
+
   nsresult rv;
   nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
+
   catman->DeleteCategoryEntry(NS_PASSWORDMANAGER_CATEGORY,
                               NS_PASSWORDMANAGER_CONTRACTID,
                               PR_TRUE);
+
+  catman->DeleteCategoryEntry("app-startup",
+                              NS_PASSWORDMANAGER_CONTRACTID,
+                              PR_TRUE);
+
   return NS_OK;
 }
 
 /* static */ void
 EmbedPasswordMgr::Shutdown()
 {
   NS_IF_RELEASE(sDecoderRing);
   NS_IF_RELEASE(sPMBundle);
@@ -382,17 +395,20 @@
   if (!aHost.IsEmpty()) {
     SignonHashEntry *hashEnt;
     if (mSignonTable.Get(aHost, &hashEnt)) {
       nsString empty;
       SignonDataEntry *entry = nsnull;
       FindPasswordEntryInternal(hashEnt->head, aUser, empty, empty, &entry);
       if (entry) {
         // Just change the password
-        return EncryptDataUCS2(aPassword, entry->passValue);
+        if (NS_FAILED(EncryptDataUCS2(aPassword, entry->passValue)))
+            return NS_ERROR_FAILURE;
+        WritePasswords(mSignonFile);
+        return NS_OK;
       }
     }
   }
   SignonDataEntry* entry = new SignonDataEntry();
   if (NS_FAILED(EncryptDataUCS2(aUser, entry->userValue)) ||
       NS_FAILED(EncryptDataUCS2(aPassword, entry->passValue))) {
     delete entry;
     return NS_ERROR_FAILURE;
@@ -546,17 +562,17 @@
   return StringBeginsWith(aHost, mLastHostQuery);
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::BuildArrayEnumerator(const nsACString& aKey,
                                        SignonHashEntry* aEntry,
                                        void* aUserData)
 {
-  nsIMutableArray* array = NS_STATIC_CAST(nsIMutableArray*, aUserData);
+  nsIMutableArray* array = static_cast<nsIMutableArray*>(aUserData);
   for (SignonDataEntry* e = aEntry->head; e; e = e->next)
     array->AppendElement(new PasswordEntry(aKey, e), PR_FALSE);
   return PL_DHASH_NEXT;
 }
 
 NS_IMETHODIMP
 EmbedPasswordMgr::GetEnumerator(nsISimpleEnumerator** aEnumerator)
 {
@@ -568,17 +584,17 @@
   return signonArray->Enumerate(aEnumerator);
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::BuildRejectArrayEnumerator(const nsACString& aKey,
                                              PRInt32 aEntry,
                                              void* aUserData)
 {
-  nsIMutableArray* array = NS_STATIC_CAST(nsIMutableArray*, aUserData);
+  nsIMutableArray* array = static_cast<nsIMutableArray*>(aUserData);
   nsCOMPtr<nsIPassword> passwordEntry = new PasswordEntry(aKey, nsnull);
   //  if (!passwordEntry) {
   //    // XXX handle oom
   //  }
   array->AppendElement(passwordEntry, PR_FALSE);
   return PL_DHASH_NEXT;
 }
 
@@ -617,17 +633,17 @@
 };
 
 /* static */
 PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::FindEntryEnumerator(const nsACString& aKey,
                                       SignonHashEntry* aEntry,
                                       void* aUserData)
 {
-  findEntryContext* context = NS_STATIC_CAST(findEntryContext*, aUserData);
+  findEntryContext* context = static_cast<findEntryContext*>(aUserData);
   EmbedPasswordMgr* manager = context->manager;
   nsresult rv;
   SignonDataEntry* entry = nsnull;
   rv = manager->FindPasswordEntryInternal(aEntry->head,
                                           context->username,
                                           context->password,
                                           EmptyString(),
                                           &entry);
@@ -720,16 +736,27 @@
   EncryptDataUCS2(aUser, entry->userValue);
   EncryptDataUCS2(aPassword, entry->passValue);
   AddSignonData(aKey, entry);
   WritePasswords(mSignonFile);
   return NS_OK;
 }
 
 NS_IMETHODIMP
+EmbedPasswordMgr::AddUserFull2(const nsACString& aKey,
+                               const nsAString& aUser,
+                               const nsAString& aPassword,
+                               const nsAString& aUserFieldName,
+                               const nsAString& aPassFieldName,
+                               const nsACString& aActionURL)
+{
+  return AddUserFull(aKey, aUser, aPassword, aUserFieldName, aPassFieldName);
+}
+
+NS_IMETHODIMP
 EmbedPasswordMgr::ReadPasswords(nsIFile* aPasswordFile)
 {
   nsCOMPtr<nsIInputStream> fileStream;
   NS_NewLocalFileInputStream(getter_AddRefs(fileStream), aPasswordFile);
   if (!fileStream)
     return NS_ERROR_OUT_OF_MEMORY;
   nsCOMPtr<nsILineInputStream> lineStream = do_QueryInterface(fileStream);
   NS_ASSERTION(lineStream, "File stream is not an nsILineInputStream");
@@ -771,17 +798,19 @@
       break;
     case STATE_USERFIELD:
       // Commit any completed entry
       if (entry) {
         // Weed out empty username+password entries from corrupted signon files
         if (entry->userValue.IsEmpty() && entry->passValue.IsEmpty()) {
           NS_WARNING("Discarding empty password entry");
           writeOnFinish = PR_TRUE; // so we won't get this on the next startup
-          delete entry;
+          if (entry)
+            delete entry;
+          entry = nsnull;
         } else {
           AddSignonData(realm, entry);
         }
       }
       // If the line is a ., we've reached the end of this realm's entries.
       if (utf8Buffer.Equals(NS_LITERAL_CSTRING("."))) {
         entry = nsnull;
         state = STATE_REALM;
@@ -809,17 +838,19 @@
     case STATE_PASSVALUE:
       NS_ASSERTION(entry, "bad state");
       CopyUTF8toUTF16(utf8Buffer, entry->passValue);
       state = STATE_USERFIELD;
       break;
     }
   } while (moreData);
   // Don't leak if the file ended unexpectedly
-  delete entry;
+  if (entry)
+    delete entry;
+  entry = nsnull;
   if (writeOnFinish) {
     fileStream->Close();
     WritePasswords(mSignonFile);
   }
   return NS_OK;
 }
 
 // nsIObserver implementation
@@ -1033,17 +1064,17 @@
     mGlobalUserField = userField;
     mGlobalPassField = passField;
   }
 #endif
 done:
   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(domDoc);
   targ->AddEventListener(
       NS_LITERAL_STRING("unload"),
-      NS_STATIC_CAST(nsIDOMLoadListener*, this),
+      static_cast<nsIDOMLoadListener*>(this),
       PR_FALSE);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedPasswordMgr::OnProgressChange(nsIWebProgress* aWebProgress,
                                    nsIRequest* aRequest,
                                    PRInt32 aCurSelfProgress,
@@ -1112,16 +1143,32 @@
   // Count the number of password fields in the form.
   nsCOMPtr<nsIDOMHTMLInputElement> userField;
   nsCOMArray<nsIDOMHTMLInputElement> passFields;
   PRUint32 i, firstPasswordIndex = numControls;
   for (i = 0; i < numControls; ++i) {
     nsCOMPtr<nsIFormControl> control;
     formElement->GetElementAt(i, getter_AddRefs(control));
     PRInt32 ctype = control->GetType();
+
+    if (ctype == NS_FORM_INPUT_FILE) {
+
+      nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aWindow));
+      GtkWidget *parentWidget = GetGtkWidgetForDOMWindow(domWindow);
+      if (parentWidget) {
+
+        gtk_signal_emit(GTK_OBJECT(GTK_MOZ_EMBED(parentWidget)),
+                        moz_embed_signals[FILE_UPLOAD_STARTED]);
+
+        ((EmbedPrivate *) GTK_MOZ_EMBED(parentWidget)->data)->mIsUploading = PR_TRUE;
+        }
+
+      return NS_OK;
+    }
+
     if (ctype == NS_FORM_INPUT_PASSWORD) {
       nsCOMPtr<nsIDOMHTMLInputElement> elem = do_QueryInterface(control);
       passFields.AppendObject(elem);
       if (firstPasswordIndex == numControls)
         firstPasswordIndex = i;
     }
   }
   nsCOMPtr<nsIPrompt> prompt;
@@ -1216,17 +1263,17 @@
                    notNowButtonText;
       GetLocalizedString(NS_LITERAL_STRING("savePasswordTitle"), dialogTitle);
       GetLocalizedString(NS_LITERAL_STRING("neverForSiteButtonText"),
                          neverButtonText);
       GetLocalizedString(NS_LITERAL_STRING("rememberButtonText"),
                          rememberButtonText);
       GetLocalizedString(NS_LITERAL_STRING("notNowButtonText"),
                          notNowButtonText);
-      PRInt32 selection;
+      PRInt32 selection = GTK_MOZ_EMBED_LOGIN_REMEMBER_FOR_THIS_SITE;
       nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aWindow));
       GtkWidget *parentWidget = GetGtkWidgetForDOMWindow(domWindow);
       if (parentWidget)
         gtk_signal_emit(GTK_OBJECT(GTK_MOZ_EMBED(parentWidget)->common),
                         moz_embed_common_signals[COMMON_REMEMBER_LOGIN], &selection);
       // FIXME These values (0,1,2,3,4) need constant variable.
       if (selection == GTK_MOZ_EMBED_LOGIN_REMEMBER_FOR_THIS_SITE ) {
         SignonDataEntry* entry = new SignonDataEntry();
@@ -1400,17 +1447,17 @@
   if (NS_FAILED(rv))
     return rv;
 
   EmbedSignonPrompt2* wrapper = new EmbedSignonPrompt2(service, aParent);
   if (!wrapper)
     return NS_ERROR_OUT_OF_MEMORY;
 
   NS_ADDREF(wrapper);
-  *_retval = NS_STATIC_CAST(nsIAuthPrompt2*, wrapper);
+  *_retval = static_cast<nsIAuthPrompt2*>(wrapper);
   return NS_OK;
 }
 
 
 // nsIDOMLoadListener implementation
 NS_IMETHODIMP
 EmbedPasswordMgr::Load(nsIDOMEvent* aEvent)
 {
@@ -1423,17 +1470,17 @@
   return NS_OK;
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::RemoveForDOMDocumentEnumerator(nsISupports* aKey,
                                                  PRInt32& aEntry,
                                                  void* aUserData)
 {
-  nsIDOMDocument* domDoc = NS_STATIC_CAST(nsIDOMDocument*, aUserData);
+  nsIDOMDocument* domDoc = static_cast<nsIDOMDocument*>(aUserData);
   nsCOMPtr<nsIDOMHTMLInputElement> element = do_QueryInterface(aKey);
   nsCOMPtr<nsIDOMDocument> elementDoc;
   element->GetOwnerDocument(getter_AddRefs(elementDoc));
   if (elementDoc == domDoc)
     return PL_DHASH_REMOVE;
   return PL_DHASH_NEXT;
 }
 
@@ -1460,30 +1507,30 @@
   return NS_OK;
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::WriteRejectEntryEnumerator(const nsACString& aKey,
                                              PRInt32 aEntry,
                                              void* aUserData)
 {
-  nsIOutputStream* stream = NS_STATIC_CAST(nsIOutputStream*, aUserData);
+  nsIOutputStream* stream = static_cast<nsIOutputStream*>(aUserData);
   PRUint32 bytesWritten;
   nsCAutoString buffer(aKey);
   buffer.Append(NS_LINEBREAK);
   stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
   return PL_DHASH_NEXT;
 }
 
 /* static */ PLDHashOperator PR_CALLBACK
 EmbedPasswordMgr::WriteSignonEntryEnumerator(const nsACString& aKey,
                                              SignonHashEntry* aEntry,
                                              void* aUserData)
 {
-  nsIOutputStream* stream = NS_STATIC_CAST(nsIOutputStream*, aUserData);
+  nsIOutputStream* stream = static_cast<nsIOutputStream*>(aUserData);
   PRUint32 bytesWritten;
   nsCAutoString buffer(aKey);
   buffer.Append(NS_LINEBREAK);
   stream->Write(buffer.get(), buffer.Length(), &bytesWritten);
   for (SignonDataEntry* e = aEntry->head; e; e = e->next) {
     NS_ConvertUTF16toUTF8 userField(e->userField);
     userField.Append(NS_LINEBREAK);
     stream->Write(userField.get(), userField.Length(), &bytesWritten);
@@ -1657,17 +1704,17 @@
     if (aUserField.IsEmpty())
       matched = PR_TRUE;
     else
       matched = entry->userField.Equals(aUserField);
     if (matched)
       break;
   }
   if (entry) {
-    *aResult = NS_CONST_CAST(SignonDataEntry*, entry);
+    *aResult = const_cast<SignonDataEntry*>(entry);
     return NS_OK;
   }
   *aResult = nsnull;
   return NS_ERROR_FAILURE;
 }
 
 nsresult
 EmbedPasswordMgr::FillPassword(nsIDOMEvent* aEvent)
@@ -1723,25 +1770,26 @@
 #endif
   return NS_OK;
 }
 
 void
 EmbedPasswordMgr::AttachToInput(nsIDOMHTMLInputElement* aElement)
 {
   nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(aElement);
-  nsIDOMEventListener* listener = NS_STATIC_CAST(nsIDOMFocusListener*, this);
+  nsIDOMEventListener* listener = static_cast<nsIDOMFocusListener*>(this);
   targ->AddEventListener(NS_LITERAL_STRING("blur"), listener, PR_FALSE);
   targ->AddEventListener(NS_LITERAL_STRING("DOMAutoComplete"), listener, PR_FALSE);
   mAutoCompleteInputs.Put(aElement, 1);
 }
 
 PRBool
 EmbedPasswordMgr::GetPasswordRealm(nsIURI* aURI, nsACString& aRealm)
 {
+  NS_ENSURE_TRUE(aURI, PR_FALSE);
   // Note: this _is_ different from getting the uri's prePath!
   // We don't want to include a username or password that's part of the
   // URL in the host key... it will cause lookups to work incorrectly, and will
   // also cause usernames and passwords to be stored in cleartext.
   nsCAutoString buffer;
   aURI->GetScheme(buffer);
   aRealm.Append(buffer);
   aRealm.Append(NS_LITERAL_CSTRING("://"));
Index: mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPasswordMgr.h
+++ mozilla/embedding/browser/gtk/src/EmbedPasswordMgr.h
@@ -86,17 +86,16 @@
 {
 public:
   class SignonDataEntry;
   class SignonHashEntry;
   class PasswordEntry;
   EmbedPasswordMgr();
   virtual ~EmbedPasswordMgr();
   static EmbedPasswordMgr* GetInstance();
-  static EmbedPasswordMgr* GetInstance(EmbedPrivate *aOwner);
   nsresult Init();
   static PRBool SingleSignonEnabled();
   static NS_METHOD Register(nsIComponentManager* aCompMgr,
                             nsIFile* aPath,
                             const char* aRegistryLocation,
                             const char* aComponentType,
                             const nsModuleComponentInfo* aInfo);
   static NS_METHOD Unregister(nsIComponentManager* aCompMgr,
@@ -173,17 +172,16 @@
   nsClassHashtable<nsCStringHashKey,SignonHashEntry> mSignonTable;
   nsDataHashtable<nsCStringHashKey,PRInt32> mRejectTable;
   nsDataHashtable<nsISupportsHashKey,PRInt32> mAutoCompleteInputs;
   nsCOMPtr<nsIFile> mSignonFile;
   nsCOMPtr<nsIPrefBranch> mPrefBranch;
   nsIDOMHTMLInputElement* mAutoCompletingField;
   nsIDOMHTMLInputElement* mGlobalUserField;
   nsIDOMHTMLInputElement* mGlobalPassField;
-  SignonHashEntry * mLastSignonHashEntry;
   int lastIndex;
   nsCAutoString mLastHostQuery;
   EmbedCommon* mCommonObject;
 public:
   PRBool mFormAttachCount;
   //  nsAString mLastHostQuery;
 };
 
Index: mozilla/embedding/browser/gtk/src/EmbedPrivate.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPrivate.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -63,16 +63,17 @@
 // all of the crap that we need for event listeners
 // and when chrome windows finish loading
 #include "nsIDOMWindow.h"
 #include "nsPIDOMWindow.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIDOMAbstractView.h"
 #include "nsIDOMDocumentView.h"
 
+#include "nsICommandManager.h"
 // For seting scrollbar visibilty
 #include "nsIDOMBarProp.h"
 
 // for the focus hacking we need to do
 #include "nsIFocusController.h"
 
 #include "nsIFormControl.h"
 // for the clipboard actions we need to do
@@ -85,17 +86,16 @@
 // all of our local includes
 #include "EmbedPrivate.h"
 #include "EmbedWindow.h"
 #include "EmbedProgress.h"
 #include "EmbedContentListener.h"
 #include "EmbedEventListener.h"
 #include "EmbedWindowCreator.h"
 #include "GtkPromptService.h"
-#include "nsICookiePromptService.h"
 #include "EmbedCertificates.h"
 #include "EmbedDownloadMgr.h"
 #ifdef MOZ_GTKPASSWORD_INTERFACE
 #include "EmbedPasswordMgr.h"
 #endif
 #include "EmbedGlobalHistory.h"
 #include "EmbedFilePicker.h"
 
@@ -109,27 +109,53 @@
 #include "nsIDOMNSHTMLInputElement.h"
 #include "nsIDOMHTMLInputElement.h"
 #include "nsIDOMNSHTMLTextAreaElement.h"
 #include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMNSEditableElement.h"
 #include "nsIDOMNSDocument.h"
 #include "nsIEditingSession.h"
 #include "nsIEditor.h"
+#include "nsIPlaintextEditor.h"
 #include "nsIHTMLEditor.h"
 #include "nsEditorCID.h"
+#ifdef FIXED_BUG347731
+#include "nsIHTMLDocument.h"
+#endif
 
 #include "nsEmbedCID.h"
+#include "nsWidgetsCID.h"
 
 //#include "nsICache.h"
 #include "nsICacheService.h"
 #include "nsICacheSession.h"
 //#include "nsICacheListener.h"
+
+#ifdef MOZ_RDF
+#include "nsIExtensionManager.h"
+#ifndef MOZ_NO_COMMANDLINE
+#include "nsICommandLineRunner.h"
+#endif
+#endif
+
+#include "nsIDOMHTMLFrameElement.h"
+//Plugins
+#include "nsplugindefs.h"
+#include "nsIPluginInstance.h"
+#include "nsIDOMNodeList.h"
+#include "nsIPresShell.h"
+#include "nsIContent.h"
+#ifdef FIXED_BUG347731
+#include "nsIObjectFrame.h"
+#endif
+#include "nsIDOMHTMLIFrameElement.h"
+
 static NS_DEFINE_CID(kCacheServiceCID,           NS_CACHESERVICE_CID);
 static nsICacheService* sCacheService;
+static NS_DEFINE_CID(kAppShellCID,               NS_APPSHELL_CID);
 
 static EmbedCommon* sEmbedCommon = nsnull;
 
 /* static */
 EmbedCommon*
 EmbedCommon::GetInstance()
 {
   if (!sEmbedCommon)
@@ -148,30 +174,28 @@
 /* static */
 void
 EmbedCommon::DeleteInstance()
 {
   if (sEmbedCommon)
   {
     delete sEmbedCommon;
     sEmbedCommon = nsnull;
-
-    EmbedGlobalHistory::DeleteInstance();
-
   }
 }
 
 nsresult
 EmbedCommon::Init(void)
 {
     mCommon = NULL;
     return NS_OK;
 }
 
 PRUint32     EmbedPrivate::sWidgetCount = 0;
+PRBool       EmbedPrivate::sXpcomStarted= PR_FALSE;
 char        *EmbedPrivate::sPath        = nsnull;
 char        *EmbedPrivate::sCompPath    = nsnull;
 nsVoidArray *EmbedPrivate::sWindowList  = nsnull;
 nsILocalFile *EmbedPrivate::sProfileDir  = nsnull;
 nsISupports  *EmbedPrivate::sProfileLock = nsnull;
 GtkWidget   *EmbedPrivate::sOffscreenWindow = 0;
 GtkWidget   *EmbedPrivate::sOffscreenFixed  = 0;
 
@@ -186,23 +210,34 @@
   // Get the number of browser windows.
   PRInt32 count = EmbedPrivate::sWindowList->Count();
   // This function doesn't get called very often at all (only when
   // creating a new window) so it's OK to walk the list of open
   // windows.
   //FIXME need to choose right window
   GtkMozEmbed *ret = nsnull;
   for (int i = 0; i < count; i++) {
-    EmbedPrivate *tmpPrivate = NS_STATIC_CAST(EmbedPrivate *,
-                                              EmbedPrivate::sWindowList->ElementAt(i));
+    EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>
+                                          (EmbedPrivate::sWindowList->ElementAt(i));
     ret = tmpPrivate->mOwningWidget;
   }
   return ret;
 }
 
+nsresult
+EmbedCommon::SuspendNative(PRBool aOn) {
+static PRBool suspended = PR_FALSE;
+   if (suspended == aOn)
+     return NS_OK;
+   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
+   NS_ENSURE_TRUE(appShell, NS_ERROR_FAILURE);
+   suspended = aOn;
+   return aOn?appShell->SuspendNative():appShell->ResumeNative();
+}
+
 class GTKEmbedDirectoryProvider : public nsIDirectoryServiceProvider2
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIDIRECTORYSERVICEPROVIDER
   NS_DECL_NSIDIRECTORYSERVICEPROVIDER2
 };
 
@@ -289,50 +324,38 @@
 
   {
     EMBED_PASSWORDMANAGER_DESCRIPTION,
     NS_SINGLE_SIGNON_PROMPT_CID,
     "@mozilla.org/wallet/single-sign-on-prompt;1",
     EmbedSignonPromptConstructor
   },
 #endif
+#ifdef NECKO_COOKIES
   { "Prompt Service",
     NS_PROMPTSERVICE_CID,
     NS_COOKIEPROMPTSERVICE_CONTRACTID,
     GtkPromptServiceConstructor
   },
+#endif
   {
     "Prompt Service",
     NS_PROMPTSERVICE_CID,
     "@mozilla.org/embedcomp/prompt-service;1",
     GtkPromptServiceConstructor
   },
   {
     EMBED_CERTIFICATES_DESCRIPTION,
     EMBED_CERTIFICATES_CID,
     NS_TOKENPASSWORDSDIALOG_CONTRACTID,
     EmbedCertificatesConstructor
   },
   {
     EMBED_CERTIFICATES_DESCRIPTION,
     EMBED_CERTIFICATES_CID,
-    NS_BADCERTLISTENER_CONTRACTID,
-    EmbedCertificatesConstructor
-  },
-#ifdef BAD_CERT_LISTENER2
-  {
-    EMBED_CERTIFICATES_DESCRIPTION,
-    EMBED_CERTIFICATES_CID,
-    NS_BADCERTLISTENER2_CONTRACTID,
-    EmbedCertificatesConstructor
-  },
-#endif
-  {
-    EMBED_CERTIFICATES_DESCRIPTION,
-    EMBED_CERTIFICATES_CID,
     NS_CERTIFICATEDIALOGS_CONTRACTID,
     EmbedCertificatesConstructor
   },
   {
     EMBED_CERTIFICATES_DESCRIPTION,
     EMBED_CERTIFICATES_CID,
     NS_CLIENTAUTHDIALOGS_CONTRACTID,
     EmbedCertificatesConstructor
@@ -363,16 +386,24 @@
   },
 // content handler component info
   {
     EMBED_DOWNLOADMGR_DESCRIPTION,
     EMBED_DOWNLOADMGR_CID,
     NS_IHELPERAPPLAUNCHERDLG_CONTRACTID,
     EmbedDownloadMgrConstructor
   },
+#ifdef MOZ_XPINSTALL
+  {
+    EMBED_DOWNLOADMGR_DESCRIPTION,
+    EMBED_DOWNLOADMGR_CID,
+    "@mozilla.org/embedui/xpinstall-dialog-service;1",
+    EmbedDownloadMgrConstructor
+  },
+#endif
   // global history
   {
     "Global History",
     NS_EMBEDGLOBALHISTORY_CID,
     NS_GLOBALHISTORY2_CONTRACTID,
     EmbedGlobalHistoryConstructor
   },
   {
@@ -399,53 +430,57 @@
   mChromeLoaded     = PR_FALSE;
   mLoadFinished     = PR_TRUE;
   mListenersAttached = PR_FALSE;
   mMozWindowWidget  = 0;
   mIsDestroyed      = PR_FALSE;
   mDoResizeEmbed    = PR_TRUE;
   mOpenBlock        = PR_FALSE;
   mNeedFav          = PR_TRUE;
+  mIsUploading      = PR_FALSE;
+  mPluginSuspended  = PR_TRUE;
 
   PushStartup();
   if (!sWindowList) {
     sWindowList = new nsVoidArray();
   }
   sWindowList->AppendElement(this);
+  // increment the number of widgets
+  sWidgetCount++;
 }
 
 EmbedPrivate::~EmbedPrivate()
 {
   sWindowList->RemoveElement(this);
-  PopStartup();
+  sWidgetCount--;
 }
 
 nsresult
 EmbedPrivate::Init(GtkMozEmbed *aOwningWidget)
 {
   // are we being re-initialized?
   if (mOwningWidget)
     return NS_OK;
 
   // hang on with a reference to the owning widget
   mOwningWidget = aOwningWidget;
 
   // Create our embed window, and create an owning reference to it and
   // initialize it.  It is assumed that this window will be destroyed
   // when we go out of scope.
   mWindow = new EmbedWindow();
-  mWindowGuard = NS_STATIC_CAST(nsIWebBrowserChrome *, mWindow);
+  mWindowGuard = static_cast<nsIWebBrowserChrome *>(mWindow);
   mWindow->Init(this);
 
   // Create our progress listener object, make an owning reference,
   // and initialize it.  It is assumed that this progress listener
   // will be destroyed when we go out of scope.
   mProgress = new EmbedProgress();
-  mProgressGuard = NS_STATIC_CAST(nsIWebProgressListener *,
-               mProgress);
+  mProgressGuard = static_cast<nsIWebProgressListener *>
+                              (mProgress);
   mProgress->Init(this);
 
   // Create our content listener object, initialize it and attach it.
   // It is assumed that this will be destroyed when we go out of
   // scope.
   mContentListener = new EmbedContentListener();
   mContentListenerGuard = NS_ISUPPORTS_CAST(nsIURIContentListener*, mContentListener);
   mContentListener->Init(this);
@@ -463,17 +498,17 @@
   if (!initialized) {
     // We set this flag here instead of on success.  If it failed we
     // don't want to keep trying and leaking window creator objects.
     initialized = PR_TRUE;
 
     // create our local object
     EmbedWindowCreator *creator = new EmbedWindowCreator(&mOpenBlock);
     nsCOMPtr<nsIWindowCreator> windowCreator;
-    windowCreator = NS_STATIC_CAST(nsIWindowCreator *, creator);
+    windowCreator = static_cast<nsIWindowCreator *>(creator);
 
     // Attach it via the watcher service
     nsCOMPtr<nsIWindowWatcher> watcher = do_GetService(NS_WINDOWWATCHER_CONTRACTID);
     if (watcher)
       watcher->SetWindowCreator(windowCreator);
   }
   return NS_OK;
 }
@@ -526,24 +561,24 @@
   uriListener = do_QueryInterface(mContentListenerGuard);
   webBrowser->SetParentURIContentListener(uriListener);
 
   // save the window id of the newly created window
   nsCOMPtr<nsIWidget> mozWidget;
   mWindow->mBaseWindow->GetMainWidget(getter_AddRefs(mozWidget));
   // get the native drawing area
   GdkWindow *tmp_window =
-    NS_STATIC_CAST(GdkWindow *,
-      mozWidget->GetNativeData(NS_NATIVE_WINDOW));
+    static_cast<GdkWindow *>
+               (mozWidget->GetNativeData(NS_NATIVE_WINDOW));
   // and, thanks to superwin we actually need the parent of that.
   tmp_window = gdk_window_get_parent(tmp_window);
   // save the widget ID - it should be the mozarea of the window.
   gpointer data = nsnull;
   gdk_window_get_user_data(tmp_window, &data);
-  mMozWindowWidget = NS_STATIC_CAST(GtkWidget *, data);
+  mMozWindowWidget = static_cast<GtkWidget *>(data);
 
   // Apply the current chrome mask
   ApplyChromeMask();
   // Initialize focus for window, help for WINDOWWATCHER Service
   ChildFocusIn();
 
   return NS_OK;
 }
@@ -562,59 +597,38 @@
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // and set the visibility on the thing
   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(webBrowser);
 
   // XXX hack around problem. probably widget/gtk2 window initialization.
   baseWindow->SetVisibility(PR_FALSE);
-
+  mWindow->mHidden = 0;
   baseWindow->SetVisibility(PR_TRUE);
 }
 
 void
 EmbedPrivate::Hide(void)
 {
   // Get the nsIWebBrowser object for our embedded window.
   nsCOMPtr<nsIWebBrowser> webBrowser;
   mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
 
   // and set the visibility on the thing
   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(webBrowser);
   baseWindow->SetVisibility(PR_FALSE);
 }
 
-#include "nsIDOMScreen.h"
 void
 EmbedPrivate::Resize(PRUint32 aWidth, PRUint32 aHeight)
 {
-  PRInt32 sub   = 0;
-  PRInt32 diff  = 0;
-
-  if (mDoResizeEmbed){
-    EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-    gint x, y, width, height, depth;
-    gdk_window_get_geometry(gtk_widget_get_parent_window(GTK_WIDGET(mOwningWidget)),&x,&y,&width,&height,&depth);
-
-    if (ctx_menu) {
-      if (height < ctx_menu->mFormRect.y + ctx_menu->mFormRect.height) {
-        sub = ctx_menu->mFormRect.y - height + ctx_menu->mFormRect.height;
-        diff = height - aHeight;
-      }
-    }
-  }
-
   mWindow->SetDimensions(nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION |
                           nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER,
                           0, 0, aWidth, aHeight);
-
-  if (sub > 0 && diff >= 0){
-    SetScrollTop(sub + diff);
-  }
 }
 
 void
 EmbedPrivate::Destroy(void)
 {
   // This flag might have been set from
   // EmbedWindow::DestroyBrowserWindow() as well if someone used a
   // window.close() or something or some other script action to close
@@ -645,29 +659,33 @@
   mProgressGuard = nsnull;
   mProgress = nsnull;
 
   // detach our event listeners and release the event receiver
   DetachListeners();
   if (mEventTarget)
     mEventTarget = nsnull;
 
+  mEventListenerGuard = nsnull;
+  mEventListener = nsnull;
+
   // destroy our child window
   mWindow->ReleaseChildren();
 
   // release navigation
   mNavigation = nsnull;
 
   // release session history
   mSessionHistory = nsnull;
 
   mOwningWidget = nsnull;
 
   mMozWindowWidget = 0;
   mNeedFav = PR_TRUE;
+  mPluginSuspended = PR_TRUE;
 }
 
 void
 EmbedPrivate::SetURI(const char *aURI)
 {
   mURI.Assign(NS_ConvertUTF8toUTF16(aURI));
 }
 
@@ -675,18 +693,20 @@
 EmbedPrivate::LoadCurrentURI(void)
 {
   if (!mURI.IsEmpty()) {
     nsCOMPtr<nsPIDOMWindow> piWin;
     GetPIDOMWindow(getter_AddRefs(piWin));
 
     nsAutoPopupStatePusher popupStatePusher(piWin, openAllowed);
 
+    mWindow->mHidden = 1;
     mNavigation->LoadURI(mURI.get(),                        // URI string
-                         nsIWebNavigation::LOAD_FLAGS_NONE, // Load flags
+                         nsIWebNavigation::LOAD_FLAGS_NONE | // Load flags
+                         nsIWebNavigation::LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP,  // Allow keyword.URL.. functionality
                          nsnull,                            // Referring URI
                          nsnull,                            // Post data
                          nsnull);                           // extra headers
   }
 }
 
 void
 EmbedPrivate::Reload(PRUint32 reloadFlags)
@@ -740,94 +760,115 @@
     mDoResizeEmbed = PR_FALSE;
     return;
   }
   mChromeMask = aChromeMask;
 
   ApplyChromeMask();
 }
 
-
 /* static */
 void
 EmbedPrivate::PushStartup(void)
 {
-  // increment the number of widgets
-  sWidgetCount++;
 
   // if this is the first widget, fire up xpcom
-  if (sWidgetCount == 1) {
-    nsresult rv;
-    nsCOMPtr<nsILocalFile> binDir;
-    nsCOMPtr<nsILocalFile> compDir;
-    if (EmbedPrivate::sCompPath) {
-      rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(binDir));
-      rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(compDir));
-      if (NS_FAILED(rv))
-        return;
-      PRBool exists;
-      rv = compDir->AppendNative(nsDependentCString("components"));
-      compDir->Exists(&exists);
-      if (!exists)
-        rv = compDir->Create(nsIFile::DIRECTORY_TYPE, 0700);
-      if (NS_FAILED(rv))
-        return;
-    } else
-      NS_ASSERTION(EmbedPrivate::sCompPath, "Warning: Failed to init Component Path.\n");
+  if (EmbedPrivate::sXpcomStarted) return;
 
-    const char *grePath = sPath;
-    NS_ASSERTION(grePath, "Warning: Failed to init grePath.\n");
+  nsresult rv;
+  nsCOMPtr<nsILocalFile> binDir;
+  nsCOMPtr<nsILocalFile> compDir;
+  if (EmbedPrivate::sCompPath) {
+    rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(binDir));
+    rv = NS_NewNativeLocalFile(nsDependentCString(EmbedPrivate::sCompPath), 1, getter_AddRefs(compDir));
+    if (NS_FAILED(rv)) return;
+    PRBool exists;
+    rv = compDir->AppendNative(nsDependentCString("components"));
+    compDir->Exists(&exists);
+    if (!exists)
+      rv = compDir->Create(nsIFile::DIRECTORY_TYPE, 0700);
+    if (NS_FAILED(rv)) return;
+  } else
+    NS_ASSERTION(EmbedPrivate::sCompPath, "Warning: Failed to init Component Path.\n");
 
-    if (!grePath)
-      grePath = getenv("MOZILLA_FIVE_HOME");
+  const char *grePath = sPath;
+  NS_ASSERTION(grePath, "Warning: Failed to init grePath.\n");
 
-    if (!grePath)
-      return;
+  if (!grePath)
+    grePath = getenv("MOZILLA_FIVE_HOME");
 
-    nsCOMPtr<nsILocalFile> greDir;
-    rv = NS_NewNativeLocalFile(nsDependentCString(grePath), PR_TRUE,
-                               getter_AddRefs(greDir));
-    if (NS_FAILED(rv))
-      return;
+  if (!grePath) return;
 
-    rv = XRE_InitEmbedding(greDir, binDir,
-                           NS_CONST_CAST(GTKEmbedDirectoryProvider*,
-                                         &kDirectoryProvider),
-                           nsnull, nsnull);
-    if (NS_FAILED(rv))
-      return;
+  nsCOMPtr<nsILocalFile> greDir;
+  rv = NS_NewNativeLocalFile(nsDependentCString(grePath), PR_TRUE,
+                             getter_AddRefs(greDir));
+  if (NS_FAILED(rv)) return;
 
-    if (EmbedPrivate::sProfileDir) {
-      XRE_NotifyProfile();
-    }
+  PRBool needsRestart = PR_TRUE;
 
-    rv = RegisterAppComponents();
-    NS_ASSERTION(NS_SUCCEEDED(rv), "Warning: Failed to register app components.\n");
+  if (EmbedPrivate::sProfileDir && !EmbedPrivate::sProfileLock) {
+    rv = XRE_LockProfileDirectory(EmbedPrivate::sProfileDir,
+                                  &EmbedPrivate::sProfileLock);
+    if (NS_FAILED(rv)) return;
   }
+
+  rv = XRE_InitEmbedding(greDir, binDir,
+                         const_cast<GTKEmbedDirectoryProvider*>
+                         (&kDirectoryProvider),
+                         nsnull, nsnull);
+  if (NS_FAILED(rv)) return;
+
+  EmbedPrivate::sXpcomStarted = PR_TRUE;
+
+  if (EmbedPrivate::sProfileDir)
+    XRE_NotifyProfile();
+
+#ifdef MOZ_RDF
+  nsCOMPtr<nsIExtensionManager>
+    extensionManager(do_GetService("@mozilla.org/extensions/manager;1", &rv));
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Fail to initialize extension manager");
+    return;
+  }
+
+#ifndef MOZ_NO_COMMANDLINE
+  nsCOMPtr<nsICommandLineRunner>
+    cmdline(do_CreateInstance("@mozilla.org/toolkit/command-line;1", &rv));
+  extensionManager->Start(cmdline, &needsRestart);
+#else
+  extensionManager->Start(nsnull, &needsRestart);
+#endif
+#endif
+
+  rv = RegisterAppComponents(needsRestart);
+  NS_ASSERTION(NS_SUCCEEDED(rv), "Warning: Failed to register app components.\n");
 }
 
 /* static */
 void
 EmbedPrivate::PopStartup(void)
 {
-  sWidgetCount--;
-  if (sWidgetCount == 0) {
+  if (sWidgetCount == 0 && EmbedPrivate::sXpcomStarted) {
     NS_IF_RELEASE(sCacheService);
 
     // destroy the offscreen window
     DestroyOffscreenWindow();
 
     // we no longer need a reference to the DirectoryServiceProvider
     if (EmbedPrivate::sAppFileLocProvider) {
       NS_RELEASE(EmbedPrivate::sAppFileLocProvider);
       EmbedPrivate::sAppFileLocProvider = nsnull;
     }
 
+    NS_IF_RELEASE(EmbedPrivate::sProfileDir);
+    NS_IF_RELEASE(EmbedPrivate::sProfileLock);
+
     // shut down XPCOM/Embedding
     XRE_TermEmbedding();
+    EmbedPrivate::sXpcomStarted = PR_FALSE;
 
     EmbedGlobalHistory::DeleteInstance();
   }
 }
 
 /* static */
 void EmbedPrivate::SetPath(const char *aPath)
 {
@@ -967,20 +1008,20 @@
     return nsnull;
 
   // Get the number of browser windows.
   PRInt32 count = sWindowList->Count();
   // This function doesn't get called very often at all (only when
   // creating a new window) so it's OK to walk the list of open
   // windows.
   for (int i = 0; i < count; i++) {
-    EmbedPrivate *tmpPrivate = NS_STATIC_CAST(EmbedPrivate *, sWindowList->ElementAt(i));
+    EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>(sWindowList->ElementAt(i));
     // get the browser object for that window
     nsIWebBrowserChrome *chrome =
-      NS_STATIC_CAST(nsIWebBrowserChrome *, tmpPrivate->mWindow);
+      static_cast<nsIWebBrowserChrome *>(tmpPrivate->mWindow);
     if (chrome == aBrowser)
       return tmpPrivate;
   }
 
   return nsnull;
 }
 
 void
@@ -1041,17 +1082,17 @@
 
     GList *list_full = NULL, *users_list = NULL;
     gint retval = -1;
 
     if (gtk_moz_embed_common_get_logins(NS_ConvertUTF16toUTF8(mURI).get(), &list_full)) {
 
       GList *ptr = list_full;
       while(ptr) {
-        GtkMozLogin * login = NS_STATIC_CAST(GtkMozLogin*, ptr->data);
+        GtkMozLogin * login = static_cast<GtkMozLogin*>(ptr->data);
         if (login && login->user) {
           users_list = g_list_append(users_list, NS_strdup(login->user));
           NS_Free((void*)login->user);
           if (login->pass)
             NS_Free((void*)login->pass);
           if (login->host)
             NS_Free((void*)login->host);
         }
@@ -1086,17 +1127,19 @@
   rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
   if (NS_FAILED(rv))
     return;
 
   nsCOMPtr<nsIWebBrowserFocus> webBrowserFocus(do_QueryInterface(webBrowser));
   if (!webBrowserFocus)
     return;
 
+  mWindow->EnableFocusEmit(PR_FALSE);
   webBrowserFocus->Activate();
+  mWindow->EnableFocusEmit(PR_TRUE);
 }
 
 void
 EmbedPrivate::ChildFocusOut(void)
 {
   if (mIsDestroyed)
     return;
 
@@ -1134,18 +1177,18 @@
 
 void
 EmbedPrivate::AttachListeners(void)
 {
   if (!mEventTarget || mListenersAttached)
     return;
 
   nsIDOMEventListener *eventListener =
-    NS_STATIC_CAST(nsIDOMEventListener *,
-       NS_STATIC_CAST(nsIDOMKeyListener *, mEventListener));
+    static_cast<nsIDOMEventListener *>
+               (static_cast<nsIDOMKeyListener *>(mEventListener));
 
   // add the key listener
   nsresult rv;
   rv = mEventTarget->AddEventListenerByIID(
          eventListener,
          NS_GET_IID(nsIDOMKeyListener));
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to add key listener\n");
@@ -1179,34 +1222,36 @@
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mEventTarget));
   if (!target) {
     return;
   }
   
   rv = target->AddEventListener(NS_LITERAL_STRING("focus"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("blur"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("DOMLinkAdded"), eventListener, PR_TRUE);
+  rv = target->AddEventListener(NS_LITERAL_STRING("DOMPopupBlocked"), eventListener, PR_TRUE);
   rv = target->AddEventListener(NS_LITERAL_STRING("load"), eventListener, PR_TRUE);
+  rv = target->AddEventListener(NS_LITERAL_STRING("DOMLinkXSLParsed"), eventListener, PR_TRUE);
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to add Mouse Motion listener\n");
     return;
   }
   // ok, all set.
   mListenersAttached = PR_TRUE;
 }
 
 void
 EmbedPrivate::DetachListeners(void)
 {
   if (!mListenersAttached || !mEventTarget)
     return;
 
   nsIDOMEventListener *eventListener =
-    NS_STATIC_CAST(nsIDOMEventListener *,
-       NS_STATIC_CAST(nsIDOMKeyListener *, mEventListener));
+    static_cast<nsIDOMEventListener *>
+               (static_cast<nsIDOMKeyListener *>(mEventListener));
 
   nsresult rv;
   rv = mEventTarget->RemoveEventListenerByIID(
          eventListener,
          NS_GET_IID(nsIDOMKeyListener));
   if (NS_FAILED(rv)) {
     NS_WARNING("Failed to remove key listener\n");
     return;
@@ -1240,17 +1285,19 @@
   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mEventTarget));
   if (!target) {
     return;
   }
 
   rv = target->RemoveEventListener(NS_LITERAL_STRING("focus"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("blur"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMLinkAdded"), eventListener, PR_TRUE);
+  rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMPopupBlocked"), eventListener, PR_TRUE);
   rv = target->RemoveEventListener(NS_LITERAL_STRING("load"), eventListener, PR_TRUE);
+  rv = target->RemoveEventListener(NS_LITERAL_STRING("DOMLinkXSLParsed"), eventListener, PR_TRUE);
   mListenersAttached = PR_FALSE;
 }
 
 nsresult
 EmbedPrivate::GetFocusController(nsIFocusController * *controller)
 {
   nsresult rv;
   if (!controller) {
@@ -1330,17 +1377,17 @@
       return atkObj;
   }
   return nsnull;
 }
 #endif /* MOZ_ACCESSIBILITY_ATK */
 
 /* static */
 nsresult
-EmbedPrivate::RegisterAppComponents(void)
+EmbedPrivate::RegisterAppComponents(PRBool aAutoRegister)
 {
   nsCOMPtr<nsIComponentRegistrar> cr;
   nsresult rv = NS_GetComponentRegistrar(getter_AddRefs(cr));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIComponentManager> cm;
   rv = NS_GetComponentManager(getter_AddRefs(cm));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1361,16 +1408,19 @@
     // Call the registration hook of the component, if any
     if (sAppComps[i].mRegisterSelfProc) {
       rv = sAppComps[i].mRegisterSelfProc(cm, nsnull, nsnull, nsnull,
                                           &(sAppComps[i]));
       NS_ASSERTION(NS_SUCCEEDED(rv), "Unable to self-register component");
     }
   }
 
+  if (aAutoRegister)
+    cr->AutoRegister(nsnull);
+
   return rv;
 }
 
 /* static */
 void
 EmbedPrivate::EnsureOffscreenWindow(void)
 {
   if (sOffscreenWindow)
@@ -1408,18 +1458,17 @@
   switch (type) {
     case GTK_MOZ_EMBED_SELECT_ALL:
     {
       rv = clipboard->SelectAll();
       break;
     }
     case GTK_MOZ_EMBED_CAN_SELECT:
     {
-      //FIXME
-      break;
+      return CanSelect();
     }
     case GTK_MOZ_EMBED_CUT:
     {
       rv = clipboard->CutSelection();
       break;
     }
     case GTK_MOZ_EMBED_COPY:
     {
@@ -1500,64 +1549,97 @@
   rv = finder->FindNext(&match);
   NS_Free(text);
   if (NS_FAILED(rv))
     return FALSE;
 
   return match;
 }
 
-void
-EmbedPrivate::SetScrollTop(PRUint32 aTop)
-{
-  EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-  if (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_IFRAME){
-    if (ctx_menu) {
-      nsIDOMWindow *ctxDomWindows = ctx_menu->mCtxDomWindow;
-      if (ctxDomWindows)
-      {
-        nsCOMPtr<nsIDOMDocument> domDoc;
-        ctxDomWindows->GetDocument(getter_AddRefs(domDoc));
-        if (domDoc) {
-          ctx_menu->GetElementForScroll(domDoc);
-          if (ctx_menu->mNSHHTMLElementSc)
-            ctx_menu->mNSHHTMLElementSc->SetScrollTop(aTop);
-        }
-      }
-    }
-  } else {
-    nsCOMPtr<nsIDOMWindow> window;
-    nsCOMPtr<nsIWebBrowser> webBrowser;
-    mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
-    webBrowser->GetContentDOMWindow(getter_AddRefs(window));
-    window->ScrollBy(0, aTop);
-  }
-} 
-
 nsresult
 EmbedPrivate::ScrollToSelectedNode(nsIDOMNode *aDOMNode)
 {
   nsresult rv = NS_ERROR_FAILURE;
   if (aDOMNode) {
     nsCOMPtr<nsIDOMNSHTMLElement> nodeElement = do_QueryInterface(aDOMNode, &rv);
     if (NS_SUCCEEDED(rv) && nodeElement) {
       nodeElement->ScrollIntoView(PR_FALSE);
     }
   }
   return rv;
 }
 
 nsresult
-EmbedPrivate::InsertTextToNode(nsIDOMNode *aDOMNode, const char *string)
+EmbedPrivate::GetTextAndCursorPosition(gchar **aString, PRInt32 *aCursorPos)
+{
+  NS_ENSURE_ARG_POINTER(aString);
+  NS_ENSURE_ARG_POINTER(aCursorPos);
+
+  nsresult rv;
+  nsString cString;
+
+  nsCOMPtr<nsIWebBrowser> webBrowser;
+  rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+  if (NS_FAILED(rv))
+    return PR_FALSE;
+
+  nsCOMPtr<nsIWebBrowserFocus> focus(do_GetInterface(webBrowser));
+  if (!focus)
+    return PR_FALSE;
+
+  EmbedContextMenuInfo *ctxInfo;
+  ctxInfo = mEventListener->GetContextInfo();
+
+  nsIDOMElement *domElement;
+  rv = focus->GetFocusedElement(&domElement);
+  NS_ENSURE_SUCCESS(rv, rv);
+  /* if domElement is either an input or text area, get their content and
+     cursor position */
+  if (ctxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
+    if (ctxInfo->mCtxFormType == NS_FORM_TEXTAREA) {
+      nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea = do_QueryInterface(domElement, &rv);
+      if (textArea) {
+        rv = textArea->GetValue(cString);
+        if (NS_FAILED(rv))
+          return PR_FALSE;
+
+        nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaNS = do_QueryInterface(domElement);
+        if(textAreaNS)
+          textAreaNS->GetSelectionStart(aCursorPos);
+
+        *aString = strdup((gchar *)NS_ConvertUTF16toUTF8(cString).get());
+      }
+    } else {
+      nsCOMPtr<nsIDOMHTMLInputElement> inputElement = do_QueryInterface(domElement, &rv);
+      if (inputElement) {
+        rv = inputElement->GetValue(cString);
+        if (NS_FAILED(rv))
+          return PR_FALSE;
+
+        nsCOMPtr<nsIDOMNSHTMLInputElement> inputElementNS = do_QueryInterface(domElement);
+        if(inputElementNS)
+          inputElementNS->GetSelectionStart(aCursorPos);
+
+        *aString = strdup((gchar *)NS_ConvertUTF16toUTF8(cString).get());
+      }
+    }
+  }
+
+  return NS_OK;
+}
+
+nsresult
+EmbedPrivate::InsertTextToNode(nsIDOMNode *aDOMNode, const char *string, gint surr1, gint surr2)
 {
   nsIDOMNode *targetNode = nsnull;
   nsresult rv;
 
   EmbedContextMenuInfo * ctx_menu = mEventListener->GetContextInfo();
-  if (ctx_menu && ctx_menu->mEventNode && (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT)) {
+  if (ctx_menu && ctx_menu->mEventNode &&
+     (ctx_menu->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT | GTK_MOZ_EMBED_CTX_XUL)) {
     targetNode = ctx_menu->mEventNode;
   }
 
   if (!targetNode)
     return NS_ERROR_FAILURE;
 
   nsString nodeName;
   targetNode->GetNodeName(nodeName);
@@ -1572,64 +1654,100 @@
     input->GetReadOnly(&rdonly);
     if (rdonly)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNSHTMLTextAreaElement> nsinput;
     nsinput = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsinput->GetTextLength(&textLength);
+    nsString utfstring = NS_ConvertUTF8toUTF16(string);
     if (textLength > 0) {
       NS_ENSURE_SUCCESS(rv, rv);
       rv = input->GetValue(buffer);
       nsinput->GetSelectionStart(&selectionStart);
       nsinput->GetSelectionEnd(&selectionEnd);
 
       if (selectionStart != selectionEnd)
         buffer.Cut(selectionStart, selectionEnd - selectionStart);
-      buffer.Insert(NS_ConvertUTF8toUTF16(string), selectionStart);
-    } else {
-      buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    }
+      if (surr1 != 0 || surr2 != 0) {
+        buffer.Cut(textLength + surr1, surr2);
+        buffer.Insert(utfstring, selectionStart + surr1);
+      } else
+        buffer.Insert(utfstring, selectionStart);
+    } else
+      buffer.Assign(utfstring);
 
     input->SetValue(buffer);
-    int len = strlen(string);
+    int len = utfstring.Length();
     nsinput->SetSelectionRange(selectionStart + len, selectionStart + len);
+
+    nsCOMPtr<nsIDOMNSEditableElement> nseditable;
+    nseditable = do_QueryInterface(targetNode, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIEditor> theEditor;
+    nseditable->GetEditor(getter_AddRefs(theEditor));
+    NS_ENSURE_TRUE(theEditor, NS_OK);
+
+    nsCOMPtr<nsISelectionController> selectionController;
+    theEditor->GetSelectionController(getter_AddRefs(selectionController));
+    PRBool sync = PR_TRUE;
+    short selectionType = nsISelectionController::SELECTION_NORMAL;
+    selectionController->ScrollSelectionIntoView(selectionType, selectionType, sync);
   }
   else if (ctx_menu->mCtxFormType) {
     nsCOMPtr<nsIDOMHTMLInputElement> input;
     input = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     PRBool rdonly = PR_FALSE;
     input->GetReadOnly(&rdonly);
     if (rdonly)
       return NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIDOMNSHTMLInputElement> nsinput;
     nsinput = do_QueryInterface(targetNode, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsinput->GetTextLength(&textLength);
+    nsString utfstring = NS_ConvertUTF8toUTF16(string);
 
     if (textLength > 0) {
       NS_ENSURE_SUCCESS(rv, rv);
       rv = input->GetValue(buffer);
       nsinput->GetSelectionStart(&selectionStart);
       nsinput->GetSelectionEnd(&selectionEnd);
 
       if (selectionStart != selectionEnd) {
         buffer.Cut(selectionStart, selectionEnd - selectionStart);
       }
-      buffer.Insert(NS_ConvertUTF8toUTF16(string), selectionStart);
-    } else {
-      buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    }
+      if (surr1 != 0 || surr2 != 0) {
+        buffer.Cut(textLength + surr1, surr2);
+        buffer.Insert(utfstring, selectionStart + surr1);
+      } else
+        buffer.Insert(utfstring, selectionStart);
+    } else
+      buffer.Assign(utfstring);
 
     input->SetValue(buffer);
-    int len = strlen(string);
+    int len = utfstring.Length();
     nsinput->SetSelectionRange(selectionStart + len, selectionStart + len);
+
+    nsCOMPtr<nsIDOMNSEditableElement> nseditable;
+    nseditable = do_QueryInterface(targetNode, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIEditor> theEditor;
+    nseditable->GetEditor(getter_AddRefs(theEditor));
+    NS_ENSURE_TRUE(theEditor, NS_OK);
+
+    nsCOMPtr<nsISelectionController> selectionController;
+    theEditor->GetSelectionController(getter_AddRefs(selectionController));
+    PRBool sync = PR_TRUE;
+    short selectionType = nsISelectionController::SELECTION_NORMAL;
+    selectionController->ScrollSelectionIntoView(selectionType, selectionType, sync);
   }
   else {
     nsIWebBrowser *retval = nsnull;
     mWindow->GetWebBrowser(&retval);
     nsCOMPtr<nsIEditingSession> editingSession = do_GetInterface(retval);
     if (!editingSession)
       return NS_ERROR_FAILURE;
 
@@ -1639,27 +1757,60 @@
     if (!doc)
       return NS_OK;
     piWin = doc->GetWindow();
     editingSession->GetEditorForWindow(piWin, getter_AddRefs(theEditor));
     if (!theEditor) {
       return NS_ERROR_FAILURE;
     }
 
-    nsCOMPtr<nsIHTMLEditor> htmlEditor;
-    htmlEditor = do_QueryInterface(theEditor, &rv);
-    if (!htmlEditor)
+    nsCOMPtr<nsIPlaintextEditor> textEditor;
+    textEditor = do_QueryInterface(theEditor, &rv);
+    if (NS_FAILED(rv) || !textEditor)
       return NS_ERROR_FAILURE;
     buffer.Assign(NS_ConvertUTF8toUTF16(string));
-    htmlEditor->InsertHTML(buffer);
+    if (surr1 != 0 || surr2 != 0)
+      DoCommand("cmd_delete", surr2, aDOMNode);
+    textEditor->InsertText(buffer);
   }
   return NS_OK;
 }
 
 nsresult
+EmbedPrivate::DoCommand(const char *aCommand, PRInt32 aCount, nsIDOMNode *aDOMNode)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+  nsCOMPtr<nsIDOMWindow> DOMWindow;
+  if (aDOMNode) {
+    rv = GetDOMWindowByNode(aDOMNode, getter_AddRefs(DOMWindow));
+  } else {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
+  }
+  nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(DOMWindow));
+  NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
+
+  nsCOMPtr<nsICommandManager> cmdMgr(do_GetInterface(window->GetDocShell()));
+  NS_ENSURE_TRUE(cmdMgr, NS_ERROR_FAILURE);
+
+  if (!aCount) {
+    PRBool enabled = PR_FALSE;
+    rv = cmdMgr->IsCommandEnabled(aCommand, DOMWindow, &enabled);
+    if (enabled)
+      return NS_OK;
+    return NS_ERROR_FAILURE;
+  }
+  for (int i = 0; i < aCount && NS_SUCCEEDED(rv); i++)
+    rv = cmdMgr->DoCommand(aCommand, nsnull, DOMWindow);
+  return rv;
+}
+
+nsresult
 EmbedPrivate::GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow)
 {
   nsresult rv;
   nsCOMPtr<nsIDOMDocument> nodeDoc;
   rv = aNode->GetOwnerDocument(getter_AddRefs(nodeDoc));
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMDocumentView> docView = do_QueryInterface(nodeDoc, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1669,16 +1820,38 @@
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(absView, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   *aDOMWindow = window;
   NS_IF_ADDREF(*aDOMWindow);
   return rv;
 }
 
+static nsresult
+GetMarkupViewerByWindow(nsIDOMWindow *aDOMWindow,
+                        nsIMarkupDocumentViewer * *aMarkupDocViewver)
+{
+  nsresult rv;
+  NS_ENSURE_ARG_POINTER(aMarkupDocViewver);
+  nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aDOMWindow, &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsIDocShell *docShell = nsnull;
+  if (window)
+    docShell = window->GetDocShell();
+  NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
+  nsCOMPtr<nsIContentViewer> contentViewer;
+  rv = docShell->GetContentViewer(getter_AddRefs(contentViewer));
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer, &rv));
+  NS_ENSURE_TRUE(markupViewer, NS_ERROR_FAILURE);
+  *aMarkupDocViewver = markupViewer;
+  NS_IF_ADDREF(*aMarkupDocViewver);
+  return rv;
+}
+
 nsresult
 EmbedPrivate::GetZoom(PRInt32 *aZoomLevel, nsISupports *aContext)
 {
 
   NS_ENSURE_ARG_POINTER(aZoomLevel);
 
   nsresult rv;
   *aZoomLevel = 100;
@@ -1693,19 +1866,27 @@
     nsCOMPtr<nsIWebBrowser> webBrowser;
     rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
-  float zoomLevelFloat;
-  if (DOMWindow)
-    rv = DOMWindow->GetTextZoom(&zoomLevelFloat);
+  float zoomLevelFloat = 100;
+  if (DOMWindow) {
+    nsCOMPtr<nsIMarkupDocumentViewer> markupViewer;
+    rv = GetMarkupViewerByWindow(DOMWindow, getter_AddRefs(markupViewer));
+    NS_ENSURE_SUCCESS(rv, rv);
+    gboolean bval = FALSE;
+    if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.textzoom", &bval) && bval)
+      rv = markupViewer->GetTextZoom(&zoomLevelFloat);
+    else
+      rv = markupViewer->GetFullZoom(&zoomLevelFloat);
+  }
   NS_ENSURE_SUCCESS(rv, rv);
 
   *aZoomLevel = (int)round(zoomLevelFloat * 100.);
   return rv;
 }
 nsresult
 EmbedPrivate::SetZoom(PRInt32 aZoomLevel, nsISupports *aContext)
 {
@@ -1724,19 +1905,29 @@
 
     rv = webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   float zoomLevelFloat;
   zoomLevelFloat = (float) aZoomLevel / 100.;
 
-  if (DOMWindow)
-    rv = DOMWindow->SetTextZoom(zoomLevelFloat);
-
+  if (DOMWindow) {
+    nsCOMPtr<nsIMarkupDocumentViewer> markupViewer;
+    rv = GetMarkupViewerByWindow(DOMWindow, getter_AddRefs(markupViewer));
+    NS_ENSURE_SUCCESS(rv, rv);
+    gboolean bval = FALSE;
+    if (gtk_moz_embed_common_get_pref (G_TYPE_BOOLEAN,"gtkmozembed.textzoom", &bval) && bval)
+      rv = markupViewer->SetTextZoom(zoomLevelFloat);
+    else
+      rv = markupViewer->SetFullZoom(zoomLevelFloat);
+    gtk_widget_queue_draw(GTK_WIDGET(mOwningWidget));
+  }
+  //update
+  mWindow->mBaseWindow->SetPosition(0, 0);
   return rv;
 }
 
 nsresult
 EmbedPrivate::HasFrames  (PRUint32 *numberOfFrames)
 {
   // setting default value.
   *numberOfFrames = 0;
@@ -1889,8 +2080,222 @@
      if (type == GTK_MOZ_EMBED_BACK_SHISTORY)
        navIndex--;
      else if (type == GTK_MOZ_EMBED_FORWARD_SHISTORY)
        navIndex++;
    }
    *count = maxItems;
    return NS_OK;
 }
+
+PRBool
+EmbedPrivate::CanSelect()
+{
+  nsCOMPtr<nsIWebBrowser> webBrowser;
+  nsresult rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  nsCOMPtr<nsIWebBrowserFocus> focus = do_QueryInterface(webBrowser, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  EmbedContextMenuInfo *ctxInfo;
+  ctxInfo = mEventListener->GetContextInfo();
+  if (!ctxInfo)
+    return PR_TRUE;
+
+  nsCOMPtr<nsIDOMElement> domElement;
+  rv = focus->GetFocusedElement(getter_AddRefs(domElement));
+  if (NS_SUCCEEDED(rv)) {
+    /* if domElement is either an input or text area, get their length to
+       check if there is anything to select */
+    if (ctxInfo->mEmbedCtxType & GTK_MOZ_EMBED_CTX_INPUT_TEXT) {
+      PRInt32 textLength;
+      if (ctxInfo->mCtxFormType == NS_FORM_TEXTAREA) {
+        nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(domElement, &rv);
+        NS_ENSURE_SUCCESS(rv, PR_TRUE);
+        textArea->GetTextLength(&textLength);
+        if (textLength == 0)
+          return PR_FALSE;
+      } else {
+        nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(domElement, &rv);
+        NS_ENSURE_SUCCESS(rv, PR_TRUE);
+        input->GetTextLength(&textLength);
+        if (textLength == 0)
+          return PR_FALSE;
+      }
+    }
+    return PR_TRUE;
+  }
+
+  nsCOMPtr<nsIDOMWindow> domWindow;
+  rv = focus->GetFocusedWindow(getter_AddRefs(domWindow));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+  nsCOMPtr<nsIDOMDocument> domDoc;
+  rv = domWindow->GetDocument(getter_AddRefs(domDoc));
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+#ifdef FIXED_BUG347731
+  /* checks if focused document is a frameset */
+  nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(domDoc, &rv);
+  NS_ENSURE_SUCCESS(rv, PR_TRUE);
+  if (htmlDoc->GetIsFrameset())
+    return PR_FALSE;
+#endif
+
+  return PR_TRUE;
+}
+
+nsresult
+EmbedPrivate::NotifyPlugins(PRUint16 aEvent, nsIDOMWindow* aDomWindow)
+{
+  nsCOMPtr<nsIDOMDocument> domDoc;
+  nsresult rv;
+
+  if (!aDomWindow) {
+    nsCOMPtr<nsIWebBrowser> webBrowser;
+    rv = mWindow->GetWebBrowser(getter_AddRefs(webBrowser));
+    NS_ENSURE_SUCCESS(rv, PR_TRUE);
+    NS_ENSURE_TRUE(webBrowser, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIDOMWindow> domWin;
+    rv = webBrowser->GetContentDOMWindow(getter_AddRefs(domWin));
+    NS_ENSURE_SUCCESS(rv, PR_TRUE);
+    NS_ENSURE_TRUE(domWin, NS_ERROR_FAILURE);
+
+    rv = domWin->GetDocument(getter_AddRefs(domDoc));
+    NS_ENSURE_SUCCESS(rv, PR_TRUE);
+    NS_ENSURE_TRUE(domDoc, NS_ERROR_FAILURE);
+  }
+  else {
+    rv = aDomWindow->GetDocument(getter_AddRefs(domDoc));
+    NS_ENSURE_SUCCESS(rv, PR_TRUE);
+    NS_ENSURE_TRUE(domDoc, NS_ERROR_FAILURE);
+  }
+
+  EnumeratePlugins(domDoc, NS_LITERAL_STRING("object"),  aEvent);
+  EnumeratePlugins(domDoc, NS_LITERAL_STRING("embed"),  aEvent);
+  EnumerateFrames(domDoc, aEvent);
+}
+
+nsresult
+EmbedPrivate::EnumerateFrames(nsIDOMDocument* aDomDoc, PRUint16 aEvent)
+{
+  nsresult rv;
+
+  PRUint32 iframeLength;
+  PRUint32 frameLength;
+
+  nsCOMPtr<nsIDOMNodeList> iframeList;
+  nsCOMPtr<nsIDOMDocument> iframeDoc;
+  nsCOMPtr<nsIDOMNodeList> frameList;
+  nsCOMPtr<nsIDOMDocument> frameDoc;
+
+  rv = aDomDoc->GetElementsByTagName (NS_LITERAL_STRING("iframe"),
+                                     getter_AddRefs(iframeList));
+  if (iframeList) {
+    rv = iframeList->GetLength(&iframeLength);
+    nsCOMPtr<nsIDOMNode> node;
+    for (PRUint32 i = 0; i < iframeLength; i++) {
+      rv = iframeList->Item(i, getter_AddRefs(node));
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      nsCOMPtr<nsIDOMHTMLIFrameElement> element = do_QueryInterface(node, &rv);
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      element->GetContentDocument(getter_AddRefs(iframeDoc));
+      if (!iframeDoc)
+        return NS_ERROR_FAILURE;
+
+      EnumeratePlugins(iframeDoc, NS_LITERAL_STRING("object"), aEvent);
+      EnumeratePlugins(iframeDoc, NS_LITERAL_STRING("embed"), aEvent);
+      EnumerateFrames(iframeDoc, aEvent);
+    }
+  }
+
+  // Now try to get the plugin instance in frame
+  rv = aDomDoc->GetElementsByTagName (NS_LITERAL_STRING("frame"),
+                                    getter_AddRefs(frameList));
+  if (frameList) {
+    rv = frameList->GetLength(&frameLength);
+    nsCOMPtr<nsIDOMNode> node;
+    for (PRUint32 i = 0; i < frameLength; i++) {
+      rv = frameList->Item(i, getter_AddRefs(node));
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      nsCOMPtr<nsIDOMHTMLFrameElement> element = do_QueryInterface(node, &rv);
+      if (NS_FAILED(rv))
+        return NS_ERROR_FAILURE;
+
+      element->GetContentDocument(getter_AddRefs(frameDoc));
+      if (!frameDoc)
+        return NS_ERROR_FAILURE;
+
+      EnumeratePlugins(frameDoc, NS_LITERAL_STRING("object"), aEvent);
+      EnumeratePlugins(frameDoc, NS_LITERAL_STRING("embed"), aEvent);
+      EnumerateFrames(frameDoc, aEvent);
+    }
+  }
+}
+
+nsresult
+EmbedPrivate::EnumeratePlugins(nsIDOMDocument* aDomDoc, const nsAString& aPluginTag, PRUint16 aEvent)
+{
+  nsresult rv;
+#ifdef FIXED_BUG347731
+
+  PRUint32 length;
+  nsCOMPtr<nsIDocument> iDoc = do_QueryInterface(aDomDoc);
+  if (!iDoc)
+    return NS_ERROR_FAILURE;
+  nsIPresShell* presShell = iDoc->GetPrimaryShell();
+  if (!presShell)
+    return NS_ERROR_FAILURE;
+
+  PRBool handled;
+  nsPluginEvent pluginEvent;
+  pluginEvent.event.type = aEvent;
+
+  nsCOMPtr<nsIDOMNodeList> list;
+  rv = aDomDoc->GetElementsByTagName(aPluginTag, getter_AddRefs(list));
+  if (!list)
+    return NS_ERROR_FAILURE;
+
+  rv = list->GetLength(&length);
+  nsCOMPtr<nsIDOMNode> node;
+  for (PRUint32 i = 0; i < length; i++) {
+    rv = list->Item(i,getter_AddRefs(node));
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIDOMHTMLElement> element = do_QueryInterface(node, &rv);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsCOMPtr<nsIContent> iContent = do_QueryInterface(element, &rv);
+    if (NS_FAILED(rv))
+      return NS_ERROR_FAILURE;
+
+    nsIFrame* frame = nsnull;
+    frame = presShell->GetPrimaryFrameFor(iContent);
+
+
+    nsIObjectFrame* objectFrame = nsnull;
+    if (frame)
+      CallQueryInterface(frame,&objectFrame);
+    if (!objectFrame)
+      continue;
+
+    nsCOMPtr<nsIPluginInstance> instance;
+    objectFrame->GetPluginInstance(*getter_AddRefs(instance));
+
+    if (!instance)
+      continue;
+    instance->HandleEvent(&pluginEvent,&handled);
+    if (!handled)
+      return NS_ERROR_FAILURE;
+  }
+#endif
+}
+
Index: mozilla/embedding/browser/gtk/src/EmbedPrivate.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPrivate.h
+++ mozilla/embedding/browser/gtk/src/EmbedPrivate.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -86,16 +86,17 @@
  public:
   EmbedCommon() {
   }
   ~EmbedCommon() { }
   static EmbedCommon* GetInstance();
   static void DeleteInstance();
   nsresult    Init(void);
   GtkObject   *mCommon;
+  static nsresult SuspendNative(PRBool aOn);
   static GtkMozEmbed* GetAnyLiveWidget();
 };
 class EmbedPrivate {
 
  public:
 
   EmbedPrivate();
   ~EmbedPrivate();
@@ -148,19 +149,20 @@
   void        ChildFocusIn (void);
   void        ChildFocusOut(void);
   PRBool      ClipBoardAction(GtkMozEmbedClipboard type);
   char*       GetEncoding ();
   nsresult    SetEncoding (const char *encoding);
   PRBool      FindText(const char *exp, PRBool  reverse,
                        PRBool  whole_word, PRBool  case_sensitive,
                        PRBool  restart);
-  void        SetScrollTop(PRUint32 aTop);
   nsresult    ScrollToSelectedNode(nsIDOMNode *aDOMNode);
-  nsresult    InsertTextToNode(nsIDOMNode *aDOMNode, const char *string);
+  nsresult    DoCommand(const char *aCommand, PRInt32 aCount = 1, nsIDOMNode *aDOMNode = nsnull);
+  nsresult    InsertTextToNode(nsIDOMNode *aDOMNode, const char *string, gint surr1 = 0, gint surr2 = 0);
+  nsresult    GetTextAndCursorPosition(char **aString, PRInt32 *aCursorPos);
   nsresult    GetFocusController(nsIFocusController **controller);
   nsresult    GetDOMWindowByNode(nsIDOMNode *aNode, nsIDOMWindow * *aDOMWindow);
   nsresult    GetZoom(PRInt32 *aZoomLevel, nsISupports *aContext = nsnull);
   nsresult    SetZoom(PRInt32 aZoomLevel, nsISupports *aContext = nsnull);
   nsresult    HasFrames(PRUint32 *numberOfFrames);
   nsresult    GetMIMEInfo(const char **aMime, nsIDOMNode *aDOMNode = nsnull);
   nsresult    GetCacheEntry(const char *aStorage,
                             const char *aKeyName,
@@ -170,16 +172,18 @@
   nsresult    GetSHistoryList(GtkMozHistoryItem **GtkHI,
                                GtkMozEmbedSessionHistory type, gint *count);
 
 
 #ifdef MOZ_ACCESSIBILITY_ATK
   void *GetAtkObjectForCurrentDocument();
 #endif
 
+  nsresult    NotifyPlugins(PRUint16 aEvent, nsIDOMWindow* aDomWin = nsnull);
+
   GtkMozEmbed                   *mOwningWidget;
 
   // all of the objects that we own
   EmbedWindow                   *mWindow;
   nsCOMPtr<nsISupports>          mWindowGuard;
   EmbedProgress                 *mProgress;
   nsCOMPtr<nsISupports>          mProgressGuard;
   EmbedContentListener          *mContentListener;
@@ -193,16 +197,17 @@
   nsCOMPtr<nsPIDOMEventTarget>   mEventTarget;
 
   // the currently loaded uri
   nsString                       mURI;
   nsCString                      mPrePath;
 
   // the number of widgets that have been created
   static PRUint32                sWidgetCount;
+  static PRBool                  sXpcomStarted;
   // the path to the GRE
   static char                   *sPath;
   // the path to components
   static char                   *sCompPath;
   // the list of application-specific components to register
   static const nsModuleComponentInfo  *sAppComps;
   static int                     sNumAppComps;
   // the appshell we have created
@@ -220,41 +225,48 @@
   // is this a chrome window?
   PRBool                         mIsChrome;
   // has the chrome finished loading?
   PRBool                         mChromeLoaded;
 
   // has the network finished loading?
   PRBool                         mLoadFinished;
 
+  // is it uploadind a file ?
+  PRBool                         mIsUploading;
+
   // saved window ID for reparenting later
   GtkWidget                     *mMozWindowWidget;
   // has someone called Destroy() on us?
   PRBool                         mIsDestroyed;
 
   //Open Blocker for Create Window class //Fixme...
   //I just tried to block it on earlier moment
   PRBool                         mOpenBlock;
   PRBool                         mNeedFav;
+  PRBool                         mPluginSuspended;
  private:
 
   // is the chrome listener attached yet?
   PRBool                         mListenersAttached;
   PRBool                         mDoResizeEmbed;
 
   void GetListener    (void);
   void AttachListeners(void);
   void DetachListeners(void);
 
   // this will get the PIDOMWindow for this widget
   nsresult        GetPIDOMWindow   (nsPIDOMWindow **aPIWin);
 
-  static nsresult RegisterAppComponents();
+  static nsresult RegisterAppComponents(PRBool aAutoRegister = PR_FALSE);
 
   // offscreen window methods and the offscreen widget
   static void       EnsureOffscreenWindow(void);
   static void       DestroyOffscreenWindow(void);
   static GtkWidget *sOffscreenWindow;
   static GtkWidget *sOffscreenFixed;
 
+  PRBool          CanSelect();
+  nsresult        EnumerateFrames(nsIDOMDocument* aDomDoc, PRUint16 aEvent);
+  nsresult        EnumeratePlugins(nsIDOMDocument* aDomDoc, const nsAString& aPluginTag, PRUint16 aEvent);
 };
 
 #endif /* __EmbedPrivate_h */
Index: mozilla/embedding/browser/gtk/src/EmbedProgress.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedProgress.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Antonio Gomes <tonikitoo@gmail.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *
@@ -35,156 +35,228 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "EmbedProgress.h"
+#include "EmbedWindow.h"
 
 #ifdef MOZILLA_INTERNAL_API
 #include "nsXPIDLString.h"
 #endif
 #include "nsIChannel.h"
 #include "nsIHttpChannel.h"
 #include "nsIWebProgress.h"
 #include "nsIDOMWindow.h"
 #include "EmbedPasswordMgr.h"
+#ifdef FIXED_BUG347731
+#include "nsPresContext.h"
+#include "nsIFrame.h"
+#endif
 
 #include "nsIURI.h"
 #include "nsCRT.h"
 
 static PRInt32 sStopSignalTimer = 0;
+static PRBool sNastyProgress = PR_TRUE;
+
 static gboolean
 progress_emit_stop(void * data)
 {
     g_return_val_if_fail(data, FALSE);
     EmbedPrivate *owner = (EmbedPrivate*)data;
+
+    if (owner->mIsUploading) {
+        gtk_signal_emit(GTK_OBJECT(owner->mOwningWidget),
+                        moz_embed_signals[FILE_UPLOAD_FINISHED]);
+        owner->mIsUploading = PR_FALSE;
+        return FALSE;
+    }
+
     if (!owner->mLoadFinished) {
       owner->mLoadFinished = PR_TRUE;
       gtk_signal_emit(GTK_OBJECT(owner->mOwningWidget),
                       moz_embed_signals[NET_STOP]);
     }
+
+    PRBool enabled = PR_TRUE;
+    gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+
+    if (success && enabled) {
+      owner->NotifyPlugins(3);
+      owner->mPluginSuspended = PR_FALSE;
+    }
+    // when finished loading, disable flash suspending function
+    // with the help of pref
+    gboolean btval = FALSE;
+    gtk_moz_embed_common_set_pref (G_TYPE_BOOLEAN,"plugins.flashhack",&btval);
     return FALSE;
 }
 
 EmbedProgress::EmbedProgress(void)
 {
   mOwner = nsnull;
+  mConnectingState = PR_TRUE;
+  mPageDownloaded = PR_FALSE;
+  mPagePainted = PR_FALSE;
+  mShowProgressStopped = PR_TRUE;
 }
 
 EmbedProgress::~EmbedProgress()
 {
 }
 
 NS_IMPL_ISUPPORTS2(EmbedProgress,
                    nsIWebProgressListener,
                    nsISupportsWeakReference)
 
 nsresult
 EmbedProgress::Init(EmbedPrivate *aOwner)
 {
   mOwner = aOwner;
   mStopLevel = 0;
+  gboolean enabled = PR_TRUE;
+  if (gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"gtkmozembed.nasty_progress", &enabled)
+      && !enabled)
+    sNastyProgress = PR_FALSE;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnStateChange(nsIWebProgress *aWebProgress,
            nsIRequest     *aRequest,
            PRUint32        aStateFlags,
            nsresult        aStatus)
 {
+  PRBool mIsLoadingDocument = PR_TRUE;
+  aWebProgress->GetIsLoadingDocument(&mIsLoadingDocument);
+  if (mOwner->mWindow->mHidden == 2) {
+    mOwner->Show();
+    gtk_widget_grab_focus(GTK_WIDGET(mOwner->mOwningWidget));
+    mOwner->mWindow->mHidden = 0;
+  }
+  if (sNastyProgress &&
+      aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING &&
+      aStateFlags & GTK_MOZ_EMBED_FLAG_IS_DOCUMENT) {
+#ifdef FIXED_BUG347731
+    if (aStatus == NS_FRAME_HAS_VIEW) {
+      mPagePainted = PR_FALSE;
+      mConnectingState = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
+    }
+    if (aStatus == NS_FRAME_IMPL_RESERVED)
+      mPagePainted = PR_TRUE;
+#endif
+  }
+
   // give the widget a chance to attach any listeners
   mOwner->ContentStateChange();
 
   if (sStopSignalTimer &&
       (
        (aStateFlags & GTK_MOZ_EMBED_FLAG_TRANSFERRING)
        || (aStateFlags & GTK_MOZ_EMBED_FLAG_REDIRECTING)
        || (aStateFlags & GTK_MOZ_EMBED_FLAG_NEGOTIATING)
       )
      ) {
-      g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
       mStopLevel = 0;
       gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                       moz_embed_signals[NET_START]);
       mOwner->mLoadFinished = PR_FALSE;
+      mPageDownloaded = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
   }
 
   // if we've got the start flag, emit the signal
   if ((aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) &&
       (aStateFlags & GTK_MOZ_EMBED_FLAG_START)) {
     // FIXME: workaround for broken progress values.
     mOwner->mOwningWidget->current_number_of_requests = 0;
     mOwner->mOwningWidget->total_number_of_requests = 0;
 
     if (mOwner->mLoadFinished) {
       mOwner->mLoadFinished = PR_FALSE;
       mStopLevel = 0;
+      mConnectingState = PR_TRUE;
+      mPageDownloaded = PR_FALSE;
+      mPagePainted = PR_FALSE;
+      mShowProgressStopped = PR_FALSE;
       gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                       moz_embed_signals[NET_START]);
     }
   }
-  // get the uri for this request
-  nsCString tmpString;
-  RequestToURIString(aRequest, tmpString);
+
+  if (sNastyProgress && mPagePainted && mPageDownloaded && !mShowProgressStopped) {
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[PROGRESS_ALL],
+                    (const gchar *) nsnull,
+                    100, 100);
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[NET_STOP]);
+    mShowProgressStopped = PR_TRUE;
+  }
 
   // FIXME: workaround for broken progress values.
   if (mOwner->mOwningWidget) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_REQUEST) {
       if (aStateFlags & GTK_MOZ_EMBED_FLAG_START)
         mOwner->mOwningWidget->total_number_of_requests ++;
       else if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP)
         mOwner->mOwningWidget->current_number_of_requests++;
     }
 
-    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                    moz_embed_signals[PROGRESS_ALL],
-                    (const gchar *) tmpString.get(),
-                    mOwner->mOwningWidget->current_number_of_requests,
-                    mOwner->mOwningWidget->total_number_of_requests);
-  }
-  // is it the same as the current URI?
-  if (mOwner->mURI.Equals(NS_ConvertUTF8toUTF16(tmpString))) {
-    // for people who know what they are doing
-    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
-                    moz_embed_signals[NET_STATE],
-                    aStateFlags, aStatus);
+    if (!sNastyProgress || (!mConnectingState && !mShowProgressStopped))
+      gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                      moz_embed_signals[PROGRESS_ALL],
+                      (const gchar *) NULL,
+                      mOwner->mOwningWidget->current_number_of_requests,
+                      mOwner->mOwningWidget->total_number_of_requests);
   }
 
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[NET_STATE_ALL],
-                  (const gchar *)tmpString.get(),
+                    NULL,
                   (gint)aStateFlags, (gint)aStatus);
 
   // and for stop, too
   if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_REQUEST)
       mStopLevel = 1;
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_DOCUMENT)
        mStopLevel = mStopLevel == 1 ? 2 : 0;
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_WINDOW) {
       mStopLevel = mStopLevel == 2 ? 3 : 0;
     }
   }
 
   if (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP) {
     if (aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) {
-      if (sStopSignalTimer)
-        g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
+      mShowProgressStopped = PR_TRUE;
       progress_emit_stop(mOwner);
       // let our owner know that the load finished
       mOwner->ContentFinishedLoading();
 
+      // resume plugins
+      PRBool enabled = PR_TRUE;
+      gboolean success = gtk_moz_embed_common_get_pref(G_TYPE_BOOLEAN,"plugins.enableSuspending",&enabled);
+      if (success && enabled) {
+        nsCOMPtr<nsIDOMWindow> domWindow;
+        aWebProgress->GetDOMWindow(getter_AddRefs(domWindow));
+        mOwner->NotifyPlugins(3, domWindow);
+        mOwner->mPluginSuspended = PR_FALSE;
+      }
     } else if (mStopLevel == 3) {
-      if (sStopSignalTimer)
-        g_source_remove(sStopSignalTimer);
+      GLIB_SOURCE_IF_REMOVE(sStopSignalTimer);
       mStopLevel = 0;
+      mShowProgressStopped = PR_TRUE;
       sStopSignalTimer = g_timeout_add(1000, progress_emit_stop, mOwner);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnProgressChange(nsIWebProgress *aWebProgress,
@@ -193,16 +265,21 @@
                                 PRInt32         aMaxSelfProgress,
                                 PRInt32         aCurTotalProgress,
                                 PRInt32         aMaxTotalProgress)
 {
   nsCString tmpString;
   RequestToURIString(aRequest, tmpString);
 
   // is it the same as the current uri?
+  if (aMaxTotalProgress != -1 && aCurTotalProgress == aMaxTotalProgress
+      && aMaxSelfProgress != -1 && aCurSelfProgress == aMaxSelfProgress) {
+    mPageDownloaded = PR_TRUE;
+  }
+
   if (mOwner->mURI.Equals(NS_ConvertUTF8toUTF16(tmpString))) {
     gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                     moz_embed_signals[PROGRESS],
                     aCurTotalProgress, aMaxTotalProgress);
   }
 
   return NS_OK;
 }
@@ -247,38 +324,33 @@
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnStatusChange(nsIWebProgress  *aWebProgress,
                               nsIRequest      *aRequest,
                               nsresult         aStatus,
                               const PRUnichar *aMessage)
 {
-  // need to make a copy so we can safely cast to a void *
-  PRUnichar *tmpString = NS_strdup(aMessage);
-
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[STATUS_CHANGE],
-                  NS_STATIC_CAST(void *, aRequest),
-                  NS_STATIC_CAST(gint, aStatus),
-                  NS_STATIC_CAST(void *, tmpString));
-
-  NS_Free(tmpString);
+                  static_cast<void *>(aRequest),
+                  static_cast<gint>(aStatus),
+                  static_cast<const void *>(aMessage));
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedProgress::OnSecurityChange(nsIWebProgress *aWebProgress,
                                 nsIRequest     *aRequest,
                                 PRUint32         aState)
 {
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
                   moz_embed_signals[SECURITY_CHANGE],
-                  NS_STATIC_CAST(void *, aRequest),
+                  static_cast<void *>(aRequest),
                   aState);
   return NS_OK;
 }
 
 /* static */
 void
 EmbedProgress::RequestToURIString(nsIRequest *aRequest, nsCString& aString)
 {
Index: mozilla/embedding/browser/gtk/src/EmbedProgress.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedProgress.h
+++ mozilla/embedding/browser/gtk/src/EmbedProgress.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -59,11 +59,15 @@
 
  private:
 
   static void RequestToURIString(nsIRequest *aRequest, nsCString& aString);
   nsresult HandleHTTPStatus(nsIRequest *aRequest, const char *aUri, PRBool &aSucceeded);
 
   EmbedPrivate *mOwner;
   PRBool mStopLevel;
+  PRBool mConnectingState;
+  PRBool mPageDownloaded;
+  PRBool mPagePainted;
+  PRBool mShowProgressStopped;
 };
 
 #endif /* __EmbedProgress_h */
Index: mozilla/embedding/browser/gtk/src/EmbedPrompter.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPrompter.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedPrompter.cpp
@@ -34,16 +34,22 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "EmbedPrompter.h"
 
+#include <gtk/gtkversion.h>
+
+#if GTK_CHECK_VERSION(2,3,1)
+#define USE_GTK_COMBOBOX
+#endif
+
 #define ALLOC_NOT_CHECKED(newed) PR_BEGIN_MACRO               \
   /* This might not crash, but the code probably isn't really \
    * designed to handle it, perhaps the code should be fixed? \
    */                                                         \
   if (!newed) {                                               \
   }                                                           \
   PR_END_MACRO
 
@@ -235,27 +241,36 @@
                    mCheckValue);
     gtk_label_set_line_wrap(
       GTK_LABEL(gtk_bin_get_child(GTK_BIN(mCheckBox))),
       TRUE);
     gtk_box_pack_start(GTK_BOX(contentsVBox), mCheckBox, FALSE, FALSE, 0);
   }
   // Add a dropdown menu
   if (aType == TYPE_SELECT) {
+#ifdef USE_GTK_COMBOBOX
+    // Build up a GtkComboBox containing the items
+    mOptionMenu = gtk_combo_box_new_text ();
+
+    for (PRUint32 i = 0; i < mItemCount; ++i) {
+      gtk_combo_box_append_text(GTK_COMBO_BOX(mOptionMenu), mItemList[i].get());
+    }
+#else
     // Build up a GtkMenu containing the items
     GtkWidget* menu = gtk_menu_new();
     for (PRUint32 i = 0; i < mItemCount; ++i) {
       GtkWidget* item = gtk_menu_item_new_with_label(mItemList[i].get());
       gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
     }
 
     // Now create an OptionMenu and set this as the menu
     mOptionMenu = gtk_option_menu_new();
 
     gtk_option_menu_set_menu(GTK_OPTION_MENU(mOptionMenu), menu);
+#endif /* USE_GTK_COMBOBOX */
     gtk_box_pack_start(GTK_BOX(contentsVBox), mOptionMenu, FALSE, FALSE, 0);
   }
 
   if (aType == TYPE_UNIVERSAL) {
     // Create buttons based on the flags passed in.
     for (int i = EMBED_MAX_BUTTONS; i >= 0; --i) {
       if (!mButtonLabels[i].IsEmpty())
         gtk_dialog_add_button(GTK_DIALOG(mWindow),
@@ -425,10 +440,14 @@
 
   if (mCheckBox)
     mCheckValue = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(mCheckBox));
 
   if (mTextField)
     mTextValue.Assign(gtk_entry_get_text(GTK_ENTRY(mTextField)));
 
   if (mOptionMenu)
+#ifdef USE_GTK_COMBOBOX
+    mSelectedItem = gtk_combo_box_get_active(GTK_COMBO_BOX(mOptionMenu));
+#else
     mSelectedItem = gtk_option_menu_get_history(GTK_OPTION_MENU(mOptionMenu));
+#endif /* USE_GTK_COMBOBOX */
 }
Index: mozilla/embedding/browser/gtk/src/EmbedPrompter.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedPrompter.h
+++ mozilla/embedding/browser/gtk/src/EmbedPrompter.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Brian Ryner <bryner@brianryner.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
Index: mozilla/embedding/browser/gtk/src/EmbedWindow.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindow.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedWindow.cpp
@@ -12,17 +12,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -53,16 +53,18 @@
 
 GtkWidget *EmbedWindow::sTipWindow = nsnull;
 
 EmbedWindow::EmbedWindow(void)
 {
   mOwner       = nsnull;
   mVisibility  = PR_FALSE;
   mIsModal     = PR_FALSE;
+  mJSFocusEmit = PR_TRUE;
+  mHidden      = 0;
 }
 
 EmbedWindow::~EmbedWindow(void)
 {
   ExitModalEventLoop(PR_FALSE);
 }
 
 nsresult
@@ -71,17 +73,17 @@
   // save our owner for later
   mOwner = aOwner;
 
   // create our nsIWebBrowser object and set up some basic defaults.
   mWebBrowser = do_CreateInstance(NS_WEBBROWSER_CONTRACTID);
   if (!mWebBrowser)
     return NS_ERROR_FAILURE;
 
-  mWebBrowser->SetContainerWindow(NS_STATIC_CAST(nsIWebBrowserChrome *, this));
+  mWebBrowser->SetContainerWindow(static_cast<nsIWebBrowserChrome *>(this));
 
   nsCOMPtr<nsIDocShellTreeItem> item = do_QueryInterface(mWebBrowser);
   item->SetItemType(nsIDocShellTreeItem::typeContentWrapper);
 
   return NS_OK;
 }
 
 nsresult
@@ -123,16 +125,17 @@
 NS_IMPL_ADDREF(EmbedWindow)
 NS_IMPL_RELEASE(EmbedWindow)
 
 NS_INTERFACE_MAP_BEGIN(EmbedWindow)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebBrowserChrome)
   NS_INTERFACE_MAP_ENTRY(nsIWebBrowserChrome)
   NS_INTERFACE_MAP_ENTRY(nsIWebBrowserChromeFocus)
   NS_INTERFACE_MAP_ENTRY(nsIEmbeddingSiteWindow)
+  NS_INTERFACE_MAP_ENTRY(nsIEmbeddingSiteWindow2)
 //  NS_INTERFACE_MAP_ENTRY(nsITooltipListener)
   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
 NS_INTERFACE_MAP_END
 
 // nsIWebBrowserChrome
 
 NS_IMETHODIMP
 EmbedWindow::SetStatus(PRUint32 aStatusType, const PRUnichar *aStatus)
@@ -288,59 +291,83 @@
   }
   return NS_ERROR_INVALID_ARG;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetDimensions(PRUint32 aFlags, PRInt32 *aX,
          PRInt32 *aY, PRInt32 *aCX, PRInt32 *aCY)
 {
-  if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION &&
-      (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
-     nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER))) {
-    return mBaseWindow->GetPositionAndSize(aX, aY, aCX, aCY);
-  }
-  else if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION) {
-    return mBaseWindow->GetPosition(aX, aY);
-  }
-  else if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
+  nsresult rv = NS_ERROR_INVALID_ARG;
+  if (aFlags & nsIEmbeddingSiteWindow::DIM_FLAGS_POSITION && aX && aY) {
+    GdkWindow *window = gtk_widget_get_parent_window(GTK_WIDGET(mOwner->mOwningWidget));
+    if (window) {
+      gdk_window_get_position(window, aX, aY);
+      rv = NS_OK;
+    }
+  } else
+    rv = NS_OK;
+  if (aFlags & (nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_INNER |
          nsIEmbeddingSiteWindow::DIM_FLAGS_SIZE_OUTER)) {
-    return mBaseWindow->GetSize(aCX, aCY);
+    rv |= mBaseWindow->GetSize(aCX, aCY);
   }
-  return NS_ERROR_INVALID_ARG;
+  return rv;
 }
 
 NS_IMETHODIMP
 EmbedWindow::SetFocus(void)
 {
   // XXX might have to do more here.
-  return mBaseWindow->SetFocus();
+  gboolean return_val = FALSE;
+  nsresult rv = NS_OK;
+  rv = mBaseWindow->SetFocus();
+  if (mJSFocusEmit && mOwner->mOwningWidget)
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_WINDOW_FOCUS],
+                    &return_val);
+  return rv;
+}
+
+NS_IMETHODIMP
+EmbedWindow::Blur(void)
+{
+  // XXX might have to do more here.
+  gboolean handled = FALSE;
+  if (mOwner->mOwningWidget)
+    gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
+                    moz_embed_signals[DOM_WINDOW_BLUR],
+                    &handled);
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetTitle(PRUnichar **aTitle)
 {
   *aTitle = ToNewUnicode(mTitle);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::SetTitle(const PRUnichar *aTitle)
 {
   mTitle = aTitle;
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
       moz_embed_signals[TITLE]);
+  if (mHidden == 1) {
+    mOwner->Hide();
+    mHidden = 2;
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetSiteWindow(void **aSiteWindow)
 {
   GtkWidget *ownerAsWidget(GTK_WIDGET(mOwner->mOwningWidget));
-  *aSiteWindow = NS_STATIC_CAST(void *, ownerAsWidget);
+  *aSiteWindow = static_cast<void *>(ownerAsWidget);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::GetVisibility(PRBool *aVisibility)
 {
   *aVisibility = mVisibility ||
                  !mOwner->mIsChrome &&
@@ -393,18 +420,18 @@
 
   if (sTipWindow)
     gtk_widget_destroy(sTipWindow);
 
   // get the root origin for this content window
   nsCOMPtr<nsIWidget> mainWidget;
   mBaseWindow->GetMainWidget(getter_AddRefs(mainWidget));
   GdkWindow *window;
-  window = NS_STATIC_CAST(GdkWindow *,
-        mainWidget->GetNativeData(NS_NATIVE_WINDOW));
+  window = static_cast<GdkWindow *>
+                      (mainWidget->GetNativeData(NS_NATIVE_WINDOW));
   gint root_x, root_y;
   gdk_window_get_origin(window, &root_x, &root_y);
 
   // XXX work around until I can get pink to figure out why
   // tooltips vanish if they show up right at the origin of the
   // cursor.
   root_y += 10;
 
Index: mozilla/embedding/browser/gtk/src/EmbedWindow.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindow.h
+++ mozilla/embedding/browser/gtk/src/EmbedWindow.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -43,65 +43,70 @@
 #ifdef MOZILLA_INTERNAL_API
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #endif
 #include "nsIWebBrowserChrome.h"
 #include "nsIWebBrowserChromeFocus.h"
 #include "nsIEmbeddingSiteWindow.h"
+#include "nsIEmbeddingSiteWindow2.h"
 //#include "nsITooltipListener.h"
 #include "nsISupports.h"
 #include "nsIWebBrowser.h"
 #include "nsIBaseWindow.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsCOMPtr.h"
 
 #include <gtk/gtk.h>
 
 class EmbedPrivate;
 
 class EmbedWindow : public nsIWebBrowserChrome,
         public nsIWebBrowserChromeFocus,
-                    public nsIEmbeddingSiteWindow,
+        public nsIEmbeddingSiteWindow2,
 //                    public nsITooltipListener,
         public nsIInterfaceRequestor
 {
 
  public:
 
   EmbedWindow();
   virtual ~EmbedWindow();
 
   nsresult Init            (EmbedPrivate *aOwner);
   nsresult CreateWindow    (void);
   void     ReleaseChildren (void);
+  void     EnableFocusEmit (PRBool aEnable = PR_TRUE) { mJSFocusEmit = aEnable; };
 
   NS_DECL_ISUPPORTS
 
   NS_DECL_NSIWEBBROWSERCHROME
 
   NS_DECL_NSIWEBBROWSERCHROMEFOCUS
 
   NS_DECL_NSIEMBEDDINGSITEWINDOW
 
+  NS_DECL_NSIEMBEDDINGSITEWINDOW2
+
 //  NS_DECL_NSITOOLTIPLISTENER
 
   NS_DECL_NSIINTERFACEREQUESTOR
 
   nsString                 mTitle;
   nsString                 mJSStatus;
   nsString                 mLinkMessage;
 
   nsCOMPtr<nsIBaseWindow>  mBaseWindow; // [OWNER]
+  PRInt32                  mHidden;
 
 private:
 
   EmbedPrivate            *mOwner;
   nsCOMPtr<nsIWebBrowser>  mWebBrowser; // [OWNER]
   static GtkWidget        *sTipWindow;
   PRBool                   mVisibility;
   PRBool                   mIsModal;
-
+  PRBool                   mJSFocusEmit;
 };
 
 
 #endif /* __EmbedWindow_h */
Index: mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindowCreator.cpp
+++ mozilla/embedding/browser/gtk/src/EmbedWindowCreator.cpp
@@ -12,17 +12,17 @@
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard.
- * Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ *
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -36,43 +36,47 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "EmbedWindowCreator.h"
 #include "EmbedPrivate.h"
 #include "EmbedWindow.h"
+#include "nsWidgetsCID.h"
+#include "nsAppShellCID.h"
+#include "nsIAppShellService.h"
+#include "nsIXULWindow.h"
+static NS_DEFINE_CID(kAppShellCID,               NS_APPSHELL_CID);
 
 // in order to create orphaned windows
 #include "gtkmozembedprivate.h"
 
 EmbedWindowCreator::EmbedWindowCreator(PRBool *aOpenBlockPtr)
 {
   mOpenBlock = aOpenBlockPtr;
+  mAppShell = do_GetService(kAppShellCID);
 }
 
 EmbedWindowCreator::~EmbedWindowCreator()
 {
 }
 
-NS_IMPL_ISUPPORTS1(EmbedWindowCreator, nsIWindowCreator)
+NS_IMPL_ISUPPORTS2(EmbedWindowCreator, nsIWindowCreator, nsIWindowCreator2)
 
 NS_IMETHODIMP
 EmbedWindowCreator::CreateChromeWindow(nsIWebBrowserChrome *aParent,
                PRUint32 aChromeFlags,
                nsIWebBrowserChrome **_retval)
 {
   NS_ENSURE_ARG_POINTER(_retval);
 
-  if (mOpenBlock) {
-    if (*mOpenBlock == PR_TRUE) {
+  if (mOpenBlock && *mOpenBlock) {
       *mOpenBlock = PR_FALSE;
       return NS_ERROR_FAILURE;
-    }
   }
   GtkMozEmbed *newEmbed = nsnull;
 
   // No parent?  Ask via the singleton object instead.
   if (!aParent) {
     gtk_moz_embed_single_create_window(&newEmbed,
                (guint)aChromeFlags);
   } else {
@@ -93,25 +97,90 @@
     return NS_ERROR_FAILURE;
 
   // The window _must_ be realized before we pass it back to the
   // function that created it. Functions that create new windows
   // will do things like GetDocShell() and the widget has to be
   // realized before that can happen.
   gtk_widget_realize(GTK_WIDGET(newEmbed));
 
-  EmbedPrivate *newEmbedPrivate = NS_STATIC_CAST(EmbedPrivate *,
-             newEmbed->data);
+  EmbedPrivate *newEmbedPrivate = static_cast<EmbedPrivate *>
+                                             (newEmbed->data);
 
   // set the chrome flag on the new window if it's a chrome open
   if (aChromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME)
     newEmbedPrivate->mIsChrome = PR_TRUE;
 
-  *_retval = NS_STATIC_CAST(nsIWebBrowserChrome *,
-            (newEmbedPrivate->mWindow));
+  *_retval = static_cast<nsIWebBrowserChrome *>
+                           ((newEmbedPrivate->mWindow));
 
-  if (*_retval) {
+  if (*_retval)
     NS_ADDREF(*_retval);
-    return NS_OK;
+
+  return *_retval ? NS_OK : NS_ERROR_FAILURE;
+
+//  PRBool cancel;
+//  return CreateChromeWindow2(aParent, aChromeFlags, 0, 0, &cancel, _retval);
+}
+
+NS_IMETHODIMP
+EmbedWindowCreator::CreateChromeWindow2(nsIWebBrowserChrome *aParent,
+                                        PRUint32 aChromeFlags,
+                                        PRUint32 aContextFlags,
+                                        nsIURI *aURI,
+                                        PRBool *aCancel,
+                                        nsIWebBrowserChrome **_retval)
+{
+#if 1
+  return CreateChromeWindow(aParent, aChromeFlags, _retval);
+#else
+  NS_ENSURE_ARG_POINTER(aCancel);
+  NS_ENSURE_ARG_POINTER(_retval);
+  *aCancel = PR_FALSE;
+  *_retval = 0;
+
+  if (mOpenBlock && *mOpenBlock) {
+      *mOpenBlock = PR_FALSE;
+      *aCancel = PR_TRUE;
+      return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIXULWindow> newWindow;
+  nsCOMPtr<nsIXULWindow> xulParent;
+
+  if (aParent) {
+    xulParent = do_GetInterface(aParent);
+    NS_ASSERTION(xulParent, "window created using non-XUL parent. that's unexpected, but may work.");
+
+    if (xulParent)
+      xulParent->CreateNewWindow(aChromeFlags, mAppShell, getter_AddRefs(newWindow));
+    // And if it fails, don't try again without a parent. It could fail
+    // intentionally (bug 115969).
+  }
+
+  if (!newWindow) { // try using basic methods:
+    /* You really shouldn't be making dependent windows without a parent.
+      But unparented modal (and therefore dependent) windows happen
+      in our codebase, so we allow it after some bellyaching: */
+    if (aChromeFlags & nsIWebBrowserChrome::CHROME_DEPENDENT)
+      NS_WARNING("dependent window created without a parent");
+
+    nsCOMPtr<nsIAppShellService> appShell(do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
+    if (!appShell)
+        return NS_ERROR_FAILURE;
+
+    appShell->CreateTopLevelWindow(xulParent, 0, aChromeFlags,
+                                   nsIAppShellService::SIZE_TO_CONTENT,
+                                   nsIAppShellService::SIZE_TO_CONTENT,
+                                   mAppShell, getter_AddRefs(newWindow));
+  }
+
+  // if anybody gave us anything to work with, use it
+  if (newWindow) {
+    newWindow->SetContextFlags(aContextFlags);
+    nsCOMPtr<nsIInterfaceRequestor> thing(do_QueryInterface(newWindow));
+    if (thing)
+        CallGetInterface(thing.get(), _retval);
   }
 
-  return NS_ERROR_FAILURE;
+  return *_retval ? NS_OK : NS_ERROR_FAILURE;
+#endif
 }
Index: mozilla/embedding/browser/gtk/src/EmbedWindowCreator.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/EmbedWindowCreator.h
+++ mozilla/embedding/browser/gtk/src/EmbedWindowCreator.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -35,24 +35,28 @@
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __EmbedWindowCreator_h
 #define __EmbedWindowCreator_h
 
-#include "nsIWindowCreator.h"
+#include "nsIWindowCreator2.h"
+#include "nsIAppShell.h"
+#include "nsCOMPtr.h"
 
-class EmbedWindowCreator : public nsIWindowCreator
+class EmbedWindowCreator : public nsIWindowCreator2
 {
  public:
   EmbedWindowCreator(PRBool *aOpenBlockPtr);
   virtual ~EmbedWindowCreator();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIWINDOWCREATOR
+  NS_DECL_NSIWINDOWCREATOR2
 
  private:
   PRBool *mOpenBlock;
+  nsCOMPtr<nsIAppShell> mAppShell;
 };
 
 #endif /* __EmbedWindowCreator_h */
Index: mozilla/embedding/browser/gtk/src/GtkPromptService.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/GtkPromptService.cpp
+++ mozilla/embedding/browser/gtk/src/GtkPromptService.cpp
@@ -49,16 +49,17 @@
 #else
 #include "nsStringAPI.h"
 #endif
 #include "nsIWindowWatcher.h"
 #include "nsIWebBrowserChrome.h"
 #include "nsIEmbeddingSiteWindow.h"
 #include "nsCOMPtr.h"
 #include "nsIServiceManager.h"
+#include "EmbedEventListener.h"
 
 #define UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(newed) PR_BEGIN_MACRO \
   /* OOPS this code is using a glib allocation function which     \
    * will cause the application to crash when it runs out of      \
    * memory. This is not cool. either g_try methods should be     \
    * used or malloc, or new (note that gecko /will/ be replacing  \
    * its operator new such that new will not throw exceptions).   \
    * XXX please fix me.                                           \
@@ -70,26 +71,31 @@
 GtkPromptService::GtkPromptService()
 {
 }
 
 GtkPromptService::~GtkPromptService()
 {
 }
 
+#ifdef NECKO_COOKIES
 NS_IMPL_ISUPPORTS2(GtkPromptService, nsIPromptService, nsICookiePromptService)
+#else
+NS_IMPL_ISUPPORTS1(GtkPromptService, nsIPromptService)
+#endif
 
 NS_IMETHODIMP
 GtkPromptService::Alert(
   nsIDOMWindow* aParent,
   const PRUnichar* aDialogTitle,
   const PRUnichar* aDialogText)
 {
   GtkWidget* parentWidget = GetGtkWidgetForDOMWindow(aParent);
   if (parentWidget && gtk_signal_handler_pending(parentWidget, moz_embed_signals[ALERT], TRUE)) {
+    EmbedEventListener::DisableLongPressTimer(parentWidget);
     gtk_signal_emit(GTK_OBJECT(parentWidget),
       moz_embed_signals[ALERT],
       (const gchar *) NS_ConvertUTF16toUTF8(aDialogTitle).get(),
       (const gchar *) NS_ConvertUTF16toUTF8(aDialogText).get());
     return NS_OK;
   }
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
   EmbedPrompter prompter;
@@ -489,16 +495,18 @@
   prompter.Create(EmbedPrompter::TYPE_SELECT,
                   GetGtkWindowForDOMWindow(aParent));
   prompter.Run();
   prompter.GetSelectedItem(outSelection);
   prompter.GetConfirmValue(aConfirm);
 #endif
   return NS_OK;
 }
+
+#ifdef NECKO_COOKIES
 /* nsCookiePromptService */
 NS_IMETHODIMP
 GtkPromptService::CookieDialog(
   nsIDOMWindow *aParent,
   nsICookie *aCookie,
   const nsACString &aHostname,
   PRInt32 aCookiesFromHost,
   PRBool aChangingCookie,
@@ -519,35 +527,38 @@
   /* We have to investigate a value to use here */
   gboolean illegal_path = FALSE;
   PRUint64 aExpires;
   aCookie->GetExpires(&aExpires);
   nsCOMPtr<nsIDOMWindow> domWindow(do_QueryInterface(aParent));
   GtkMozEmbed *parentWidget = GTK_MOZ_EMBED(GetGtkWidgetForDOMWindow(domWindow));
   GtkMozEmbedCookie *cookie_struct = g_new0(GtkMozEmbedCookie, 1);
   UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(cookie_struct);
-  if (parentWidget && cookie_struct) {
+  if (!cookie_struct) return NS_ERROR_OUT_OF_MEMORY;
+
+  if (parentWidget) {
     g_signal_emit_by_name(
       GTK_OBJECT(parentWidget->common),
       "ask-cookie",
       cookie_struct,
       actions,
       (const gchar *) hostName.get(),
       (const gchar *) aName.get(),
       (const gchar *) aValue.get(),
       (const gchar *) aDomain.get(),
       (const gchar *) aPath.get(),
       illegal_path,
       aExpires,
       NULL);
   }
-  *aRememberDecision = cookie_struct->remember_decision;
+  *aRememberDecision = !!(cookie_struct->remember_decision);
   *aAccept = cookie_struct->accept;
   return NS_OK;
 }
+#endif
 
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 void
 GtkPromptService::GetButtonLabel(
   PRUint32 aFlags,
   PRUint32 aPos,
   const PRUnichar* aStringValue,
   nsAString& aLabel)
Index: mozilla/embedding/browser/gtk/src/GtkPromptService.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/GtkPromptService.h
+++ mozilla/embedding/browser/gtk/src/GtkPromptService.h
@@ -34,39 +34,45 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsIPromptService.h"
+#ifdef NECKO_COOKIES
 #include "nsICookiePromptService.h"
 #include "nsICookie.h"
+#endif
 #include "nsNetCID.h"
 #include <gtk/gtk.h>
 #ifdef MOZILLA_INTERNAL_API
 #include "nsString.h"
 #else
 #include "nsStringAPI.h"
 #endif
 #define NS_PROMPTSERVICE_CID \
  {0x95611356, 0xf583, 0x46f5, {0x81, 0xff, 0x4b, 0x3e, 0x01, 0x62, 0xc6, 0x19}}
 
 class nsIDOMWindow;
 
-class GtkPromptService : public nsIPromptService,
-                         public nsICookiePromptService
+class GtkPromptService : public nsIPromptService
+#ifdef NECKO_COOKIES
+                         , public nsICookiePromptService
+#endif
 {
 public:
     GtkPromptService();
     virtual ~GtkPromptService();
 
     NS_DECL_ISUPPORTS
     NS_DECL_NSIPROMPTSERVICE
+#ifdef NECKO_COOKIES
     NS_DECL_NSICOOKIEPROMPTSERVICE
+#endif
 
 #ifndef MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 private:
     void GetButtonLabel(PRUint32 aFlags, PRUint32 aPos,
                         const PRUnichar* aStringValue, nsAString &aLabel);
 #endif
 };
Index: mozilla/embedding/browser/gtk/src/Makefile.in
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/Makefile.in
+++ mozilla/embedding/browser/gtk/src/Makefile.in
@@ -62,27 +62,27 @@
 ifdef MOZ_ENABLE_LIBXUL
 LIBXUL_LIBRARY  = 
 endif
 endif
 
 DEFINES += -DIMPL_XREAPI
 
 # New Stuff in GtkMozEmbed
-ifdef MOZ_MICROBEMBED
+#ifdef MOZ_MICROBEMBED
 DEFINES += -DBAD_CERT_LISTENER2
 #Probably scrolling can be fixed without this hack
-DEFINES += -DMOZ_SCROLL_TOP_LEFT_HACK
+#DEFINES += -DMOZ_SCROLL_TOP_LEFT_HACK
 
-MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT = 1
-DEFINES += -DMOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
+#MOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT = 1
+#DEFINES += -DMOZ_NO_GECKO_UI_FALLBACK_1_8_COMPAT
 
 MOZ_GTKPASSWORD_INTERFACE = 1
 DEFINES += -DMOZ_GTKPASSWORD_INTERFACE
-endif
+#endif
 
 REQUIRES	= xpcom \
 		  string \
 		  content \
 		  docshell \
 		  necko \
 		  widget \
 		  dom \
@@ -108,16 +108,24 @@
 		  exthandler \
 		  mimetype \
 		  chardet \
 		  find \
 		  webbrowserpersist \
 		  cookie \
 		  nkcache \
 		  pipboot \
+		  plugin \
+		  extensions \
+		  rdf \
+		  toolkitcomps \
+		  view \
+		  commandhandler \
+		  xpinstall \
+		  appshell \
 		  $(NULL)
 
 ifdef ACCESSIBILITY
 REQUIRES        += accessibility
 endif
 
 CPPSRCS		= \
 		gtkmozembed2.cpp \
@@ -182,16 +190,17 @@
 endif
 
 ifdef MOZ_GTKEMBED_DYN
 ifneq (,$(filter gtk2 qt,$(MOZ_WIDGET_TOOLKIT)))
 EXTRA_DSO_LDOPTS += \
 		$(DIST)/lib/libxpcomglue_s.$(LIB_SUFFIX) \
 		$(MOZ_COMPONENT_LIBS) \
 		$(MOZ_GTK2_LIBS) \
+		$(XLIBS) \
 		$(NULL)
 
 #Any Idea what can be used instead -lxul in FF configuration?
 ifndef MOZ_ENABLE_LIBXUL
 EXTRA_DSO_LDOPTS += \
 		-lxul \
 		$(NULL)
 endif
Index: mozilla/embedding/browser/gtk/src/gtkmozembed.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *   Antonio Gomes <tonikitoo@gmail.com>
@@ -182,16 +182,22 @@
   gboolean (* select)          (GtkMozEmbed *embed, const char *title, const char *text,
                                 GList *list, gint *selected_item);
   void     (* download_request)(GtkMozEmbed *, const char *, const char *, const char *, long, int, gpointer);
   gboolean (* upload_dialog)   (GtkMozEmbed *, const char *, const char *, char **);
   void     (* icon_changed)    (GtkMozEmbed *, gpointer*);
   void     (* mailto)          (GtkMozEmbed *, gchar *);
   void     (* network_error)   (GtkMozEmbed *, gchar *, const gint, const gchar **);
   void     (* rss_request)     (GtkMozEmbed *, gchar *, gchar *);
+  gint     (* dom_window_focus)(GtkMozEmbed *embed);
+  gint     (* dom_window_blur) (GtkMozEmbed *embed);
+  void     (* dom_content_blocked)(GtkMozEmbed *embed, const char *aURI,const char * url);
+  void     (* file_upload_started)(GtkMozEmbed *embed);
+  void     (* file_upload_finished)(GtkMozEmbed *embed);
+
 };
 
 GTKMOZEMBED_API(GtkType,       gtk_moz_embed_get_type,            (void))
 GTKMOZEMBED_API(GtkWidget*,    gtk_moz_embed_new,                 (void))
 GTKMOZEMBED_API(void,          gtk_moz_embed_push_startup,        (void))
 GTKMOZEMBED_API(void,          gtk_moz_embed_pop_startup,         (void))
 
 /* Tell gtkmozembed where the gtkmozembed libs live. If this is not specified,
@@ -229,22 +235,25 @@
 GTKMOZEMBED_API(void,          gtk_moz_embed_set_encoding,        (GtkMozEmbed *embed, const gchar *, gint))
 GTKMOZEMBED_API(guint,         gtk_moz_embed_get_context_info,    (GtkMozEmbed *embed, gpointer event, gpointer *node,
                                                                    gint *x, gint *y, gint *docindex,
                                                                    const gchar **url, const gchar **objurl, const gchar **docurl))
 GTKMOZEMBED_API(const gchar*,  gtk_moz_embed_get_selection,       (GtkMozEmbed *embed))
 GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_doc_info,        (GtkMozEmbed *embed, gpointer node, gint docindex, const gchar**title,
                                                                    const gchar**location, const gchar **file_type, guint *file_size,
                                                                    gint *width, gint *height))
-GTKMOZEMBED_API(gboolean,      gtk_moz_embed_insert_text,         (GtkMozEmbed *embed, const gchar*, gpointer node))
-GTKMOZEMBED_API(gboolean,      gtk_moz_embed_save_target,         (GtkMozEmbed *embed, gchar*, gchar*, gint))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_insert_text,         (GtkMozEmbed *embed, const gchar*, gpointer node, gint surr1, gint surr2))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_save_target,         (GtkMozEmbed *embed, const gchar*, const gchar*, gint, gpointer))
 GTKMOZEMBED_API(gint,          gtk_moz_embed_get_shistory_list,   (GtkMozEmbed *embed, GtkMozHistoryItem **GtkHI, guint type))
 GTKMOZEMBED_API(gint,          gtk_moz_embed_get_shistory_index,  (GtkMozEmbed *embed))
 GTKMOZEMBED_API(void,          gtk_moz_embed_shistory_goto_index, (GtkMozEmbed *embed, gint index))
 GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_server_cert,     (GtkMozEmbed *embed, gpointer *aCert, gpointer))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_do_command,          (GtkMozEmbed *embed, const gchar*, gint, gpointer))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_get_text,            (GtkMozEmbed *embed, gchar**, gint *curpos))
+GTKMOZEMBED_API(gboolean,      gtk_moz_embed_load_image,          (GtkMozEmbed *embed, const gchar*))
 
 typedef enum
 {
   GTK_MOZ_EMBED_BACK_SHISTORY,
   GTK_MOZ_EMBED_FORWARD_SHISTORY
 } GtkMozEmbedSessionHistory;
 
 typedef enum
@@ -262,21 +271,23 @@
 {
   GTK_MOZ_EMBED_CTX_NONE       = 0,
   GTK_MOZ_EMBED_CTX_XUL        = 1 << 1,
   GTK_MOZ_EMBED_CTX_SIDEBAR    = 1 << 2,
   GTK_MOZ_EMBED_CTX_DOCUMENT   = 1 << 3,
   GTK_MOZ_EMBED_CTX_LINK       = 1 << 4,
   GTK_MOZ_EMBED_CTX_IMAGE      = 1 << 5,
   GTK_MOZ_EMBED_CTX_IFRAME     = 1 << 6,
-  GTK_MOZ_EMBED_CTX_INPUT      = 1 << 7,
+  GTK_MOZ_EMBED_CTX_INPUT_TEXT = 1 << 7,
   GTK_MOZ_EMBED_CTX_IPASSWORD  = 1 << 8,
   GTK_MOZ_EMBED_CTX_EMAIL      = 1 << 9,
   GTK_MOZ_EMBED_CTX_RICHEDIT   = 1 << 10,
-  GTK_MOZ_EMBED_CTX_ROINPUT    = 1 << 11
+  GTK_MOZ_EMBED_CTX_ROINPUT    = 1 << 11,
+  GTK_MOZ_EMBED_CTX_MULTILINE  = 1 << 12,
+  GTK_MOZ_EMBED_CTX_SELECT     = 1 << 13
 } GtkMozEmbedContext;
 typedef enum
 {
   GTK_MOZ_EMBED_DIALOG_BUTTON_OK,
   GTK_MOZ_EMBED_DIALOG_BUTTON_CANCEL,
   GTK_MOZ_EMBED_DIALOG_BUTTON_YES,
   GTK_MOZ_EMBED_DIALOG_BUTTON_NO,
   GTK_MOZ_EMBED_DIALOG_BUTTON_SAVE,
Index: mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed2.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp
@@ -12,17 +12,17 @@
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard.
- * Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ *
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *   Oleg Romashin <romaxa@gmail.com>
  *   Antonio Gomes <tonikitoo@gmail.com>
@@ -48,16 +48,20 @@
 #include "gtkmozembed_internal.h"
 
 #include "EmbedPrivate.h"
 #include "EmbedWindow.h"
 #include "EmbedContextMenuInfo.h"
 #include "EmbedEventListener.h"
 #include "EmbedDownloadMgr.h"
 
+// for images
+#include "nsIImageLoadingContent.h"
+#include "nsIDOMNodeList.h"
+
 #include "nsIWebBrowserPersist.h"
 #include "nsCWebBrowserPersist.h"
 #include "nsIDOMDocument.h"
 #include "nsNetCID.h"
 #include "nsIIOService.h"
 #include "nsIFileURL.h"
 #include "nsIURI.h"
 #include "nsILocalFile.h"
@@ -544,16 +548,32 @@
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, upload_dialog),
                    gtkmozembed_BOOL__STRING_STRING_POINTER,
                    GTK_TYPE_BOOL,
                    3,
                    GTK_TYPE_STRING,
                    GTK_TYPE_STRING,
                    GTK_TYPE_POINTER);
+  moz_embed_signals[FILE_UPLOAD_STARTED] =
+    gtk_signal_new("file_upload_started",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, file_upload_started),
+                   gtk_marshal_VOID__VOID,
+                   GTK_TYPE_NONE,
+                   0);
+  moz_embed_signals[FILE_UPLOAD_FINISHED] =
+    gtk_signal_new("file_upload_finished",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, file_upload_finished),
+                   gtk_marshal_VOID__VOID,
+                   GTK_TYPE_NONE,
+                   0);
   moz_embed_signals[ICON_CHANGED] =
     gtk_signal_new("icon_changed",
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, icon_changed),
                    gtkmozembed_VOID__POINTER,
                    GTK_TYPE_NONE,
                    1,
@@ -585,16 +605,40 @@
                    GTK_RUN_LAST,
                    GET_OBJECT_CLASS_TYPE(klass),
                    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, rss_request),
                    gtkmozembed_VOID__STRING_STRING,
                    GTK_TYPE_NONE,
                    2,
                    GTK_TYPE_STRING, GTK_TYPE_STRING);
 
+  moz_embed_signals[DOM_WINDOW_BLUR] =
+    gtk_signal_new("dom_window_blur",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_window_blur),
+                   gtk_marshal_BOOL__NONE,
+                   GTK_TYPE_BOOL, 0);
+
+  moz_embed_signals[DOM_WINDOW_FOCUS] =
+    gtk_signal_new("dom_window_focus",
+                   GTK_RUN_LAST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_window_focus),
+                   gtk_marshal_BOOL__NONE,
+                   GTK_TYPE_BOOL, 0);
+
+  moz_embed_signals[DOM_CONTENT_BLOCKED] =
+    gtk_signal_new("dom_content_blocked",
+                   GTK_RUN_FIRST,
+                   GET_OBJECT_CLASS_TYPE(klass),
+                   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_content_blocked),
+                   gtk_marshal_NONE__POINTER_POINTER,
+                   GTK_TYPE_NONE, 2,
+                   GTK_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE,GTK_TYPE_STRING | G_SIGNAL_TYPE_STATIC_SCOPE);
 }
 
 static void
 gtk_moz_embed_init(GtkMozEmbed *embed)
 {
   EmbedPrivate *priv = new EmbedPrivate();
   embed->data = priv;
   embed->common = NULL;
@@ -788,18 +832,18 @@
 static AtkObject*
 gtk_moz_embed_get_accessible (GtkWidget *widget)
 {
   g_return_val_if_fail(widget != NULL, NULL);
   g_return_val_if_fail(GTK_IS_MOZ_EMBED(widget), NULL);
 
   GtkMozEmbed  *embed = GTK_MOZ_EMBED(widget);;
   EmbedPrivate *embedPrivate = (EmbedPrivate *)embed->data;
-  return NS_STATIC_CAST(AtkObject *,
-                        embedPrivate->GetAtkObjectForCurrentDocument());
+  return static_cast<AtkObject *>
+                    (embedPrivate->GetAtkObjectForCurrentDocument());
 }
 #endif /* MOZ_ACCESSIBILITY_ATK */
 
 static gint
 handle_child_focus_in(GtkWidget     *aWidget,
                       GdkEventFocus *aGdkFocusEvent,
                       GtkMozEmbed   *aEmbed)
 {
@@ -1362,17 +1406,17 @@
                         gboolean case_sensitive, gboolean restart, gint target)
 {
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail (embed != NULL, FALSE);
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), FALSE);
   g_return_val_if_fail (GTK_WIDGET_REALIZED(GTK_WIDGET(embed)), FALSE);
   embedPrivate = (EmbedPrivate *)embed->data;
   if (embedPrivate->mWindow)
-    return embedPrivate->FindText(string, reverse, whole_word, case_sensitive, restart);
+    return embedPrivate->FindText(string, !!reverse, !!whole_word, !!case_sensitive, !!restart);
   return FALSE;
 }
 
 gboolean
 gtk_moz_embed_clipboard(GtkMozEmbed *embed, guint action, gint target)
 {
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail (embed != NULL, FALSE);
@@ -1475,50 +1519,87 @@
     if (!ctx_menu)
       return NULL;
     return ctx_menu->GetSelectedText();
   }
 
   return NULL;
 }
 gboolean
-gtk_moz_embed_insert_text(GtkMozEmbed *embed, const gchar *string, gpointer node)
+gtk_moz_embed_insert_text(GtkMozEmbed *embed, const gchar *string, gpointer node, gint surr1, gint surr2)
 {
   EmbedPrivate *embedPrivate;
   g_return_val_if_fail(embed != NULL, FALSE);
   g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
   embedPrivate = (EmbedPrivate *)embed->data;
   if (!embedPrivate || !embedPrivate->mEventListener)
     return FALSE;
   if (!string && node) {
     embedPrivate->ScrollToSelectedNode((nsIDOMNode*)node);
     return TRUE;
   }
   if (string) {
-    embedPrivate->InsertTextToNode((nsIDOMNode*)node, string);
+    embedPrivate->InsertTextToNode((nsIDOMNode*)node, string, surr1, surr2);
     return TRUE;
   }
   return FALSE;
 }
 
+gboolean
+gtk_moz_embed_do_command(GtkMozEmbed *embed,
+                         const gchar* command_name,
+                         gint count, gpointer object)
+{
+  EmbedPrivate *embedPrivate;
+  g_return_val_if_fail(command_name, FALSE);
+  g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
+  embedPrivate = (EmbedPrivate *)embed->data;
+  if (!embedPrivate)
+    return FALSE;
+  return NS_SUCCEEDED(embedPrivate->DoCommand(command_name, count, (nsIDOMNode*)object))?TRUE:FALSE;
+}
 
 gboolean
-gtk_moz_embed_save_target(GtkMozEmbed *aEmbed, gchar* aUrl,
-                          gchar* aDestination, gint aSetting)
+gtk_moz_embed_get_text(GtkMozEmbed *embed, gchar** string, gint *curpos)
 {
-  //FIXME
-  nsresult rv;
+  EmbedPrivate *embedPrivate;
+  g_return_val_if_fail(embed != NULL, FALSE);
+  g_return_val_if_fail(GTK_IS_MOZ_EMBED(embed), FALSE);
+  embedPrivate = (EmbedPrivate *)embed->data;
+  if (!embedPrivate || !embedPrivate->mEventListener)
+    return FALSE;
+
+  if(embedPrivate->GetTextAndCursorPosition((gchar**)string, curpos))
+    return TRUE;
 
+  return FALSE;
+}
+
+gboolean
+gtk_moz_embed_save_target(GtkMozEmbed *aEmbed, const gchar* aUrl,
+                          const gchar* aDestination, gint aSetting, gpointer aCtx)
+{
   g_return_val_if_fail (aEmbed != NULL, FALSE);
-  nsIWebBrowser *webBrowser = nsnull;
-  gtk_moz_embed_get_nsIWebBrowser(GTK_MOZ_EMBED(aEmbed), &webBrowser);
-  g_return_val_if_fail (webBrowser != NULL, FALSE);
 
+  nsresult rv;
   nsCOMPtr<nsIDOMWindow> DOMWindow;
-  webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
+
+  if (aCtx) {
+    nsCOMPtr<nsIDOMNode> node = do_QueryInterface((nsISupports*)aCtx, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    EmbedPrivate *embedPrivate;
+    embedPrivate = (EmbedPrivate *) aEmbed->data;
+    rv = embedPrivate->GetDOMWindowByNode(node, getter_AddRefs(DOMWindow));
+  } else {
+    nsIWebBrowser *webBrowser = nsnull;
+    gtk_moz_embed_get_nsIWebBrowser(GTK_MOZ_EMBED(aEmbed), &webBrowser);
+    g_return_val_if_fail (webBrowser != NULL, FALSE);
+    webBrowser->GetContentDOMWindow(getter_AddRefs(DOMWindow));
+  }
+
   g_return_val_if_fail (DOMWindow != NULL, FALSE);
 
   nsCOMPtr<nsIDOMDocument> doc;
   DOMWindow->GetDocument(getter_AddRefs(doc));
   g_return_val_if_fail (doc != NULL, FALSE);
 
   nsCOMPtr<nsIWebBrowserPersist> persist =
     do_CreateInstance(NS_WEBBROWSERPERSIST_CONTRACTID);
@@ -1529,49 +1610,65 @@
   if (!ios)
     return FALSE;
 
   nsCOMPtr<nsIURI> uri;
   rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
   if (!uri)
     return FALSE;
 
-  if (aSetting == 0)
-  {
+  if (aSetting == 0) {
     nsCOMPtr<nsIURI> uri_s;
     rv = ios->NewURI(nsDependentCString(aUrl), "", nsnull, getter_AddRefs(uri_s));
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
 
     if (!uri_s)
       return FALSE;
-    rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);  
+    //rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);
+    rv = persist->SaveDocument(doc, uri, nsnull, nsnull, 0, 0);
 
     if (NS_SUCCEEDED(rv))
       return TRUE;
 
-  } else if (aSetting == 1)
-  {
+  }
+  else if (aSetting == 1) {
     nsCOMPtr<nsIURI> contentFolder;
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
     rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(contentFolder));
 
     nsCString contentFolderPath;
     contentFolder->GetSpec(contentFolderPath);
     contentFolderPath.Append("_content");
     printf("GetNativePath=%s ", contentFolderPath.get());
     rv = ios->NewURI(contentFolderPath, "", nsnull, getter_AddRefs(contentFolder));
 
     if (NS_FAILED(rv))
       return FALSE;
     
     rv = persist->SaveDocument(doc, uri, contentFolder, nsnull, 0, 0);
     if (NS_SUCCEEDED(rv))
       return TRUE;
-  } else if (aSetting == 2)
-  {
+  }
+  else if (aSetting == 2) {
+    nsCOMPtr<nsIURI> uri_s;
+    rv = ios->NewURI(nsDependentCString(aUrl), "", nsnull, getter_AddRefs(uri_s));
+    rv = ios->NewURI(nsDependentCString(aDestination), "", nsnull, getter_AddRefs(uri));
+
+    PRInt32 persist_flags = nsIWebBrowserPersist::PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION;
+    persist->SetPersistFlags(persist_flags);
+
+    if (!uri_s)
+      return FALSE;
+    rv = persist->SaveURI(uri_s, nsnull, nsnull, nsnull, "", uri);
+
+    if (NS_SUCCEEDED(rv))
+      return TRUE;
+    return FALSE;
+  }
+  else if (aSetting == 3) {
     // FIXME: How should I handle this option G_WEBENGINE_SAVE_FRAMES ?
     return FALSE;
   }
   return FALSE;
 }
 
 gboolean
 gtk_moz_embed_get_doc_info(GtkMozEmbed *embed, gpointer node, gint docindex,
@@ -1589,26 +1686,26 @@
   if (file_type) {
     embedPrivate->GetMIMEInfo(file_type, (nsIDOMNode*)node);
   }
 
   if (width && height) {
     nsString imgSrc;
     EmbedContextMenuInfo * ctx_menu = embedPrivate->mEventListener->GetContextInfo();
     if (ctx_menu)
-      ctx_menu->CheckDomImageElement((nsIDOMNode*)node, imgSrc, width, height);
+      ctx_menu->CheckDomImageElement((nsIDOMNode*)node, imgSrc, width, height, file_size);
   }
 
   if (title) {
     EmbedContextMenuInfo * ctx_menu = embedPrivate->mEventListener->GetContextInfo();
     if (ctx_menu)
       *title = NEW_TOOLKIT_STRING(ctx_menu->GetCtxDocTitle());
   }
 
-  if (file_size && location && *location != nsnull) {
+  if (file_size && *file_size == 0 && location && *location != nsnull) {
     nsCOMPtr<nsICacheEntryDescriptor> descriptor;
     nsresult rv;
     rv = embedPrivate->GetCacheEntry("HTTP", *location, nsICache::ACCESS_READ, PR_FALSE, getter_AddRefs(descriptor));
     if (descriptor) {
       rv = descriptor->GetDataSize(file_size);
     }
   }
 
@@ -1631,17 +1728,17 @@
 }
 
 gint
 gtk_moz_embed_get_shistory_index(GtkMozEmbed *embed)
 {
   g_return_val_if_fail ((embed != NULL), -1);
   g_return_val_if_fail (GTK_IS_MOZ_EMBED(embed), -1);
 
-  PRInt32 curIndex;
+  PRInt32 curIndex = -1;
   EmbedPrivate *embedPrivate;
   
   embedPrivate = (EmbedPrivate *)embed->data;
   if (embedPrivate->mSessionHistory)
     embedPrivate->mSessionHistory->GetIndex(&curIndex);
 
   return (gint)curIndex;
 }
@@ -1685,8 +1782,69 @@
 
   nsCOMPtr<nsIX509Cert> serverCert;
   SSLStatus->GetServerCert(getter_AddRefs(serverCert));
   if (!serverCert) return FALSE;
 
   *aCert = serverCert;
   return TRUE;
 }
+
+gboolean
+gtk_moz_embed_load_image(GtkMozEmbed *embed, const gchar *url)
+{
+  g_return_val_if_fail(embed != NULL, FALSE);
+  g_return_val_if_fail(url != NULL, FALSE);
+
+  EmbedPrivate *embedPrivate;
+  embedPrivate = (EmbedPrivate *)embed->data;
+
+  if (!embedPrivate || !embedPrivate->mEventListener)
+    return FALSE;
+
+  EmbedContextMenuInfo *ctx_menu = embedPrivate->mEventListener->GetContextInfo();
+  if (!ctx_menu->mCtxDocument)
+    return FALSE;
+
+  nsCOMPtr<nsIDOMNodeList> imgList;
+  nsresult rv = ctx_menu->mCtxDocument->GetElementsByTagName(NS_LITERAL_STRING("img"),
+                                                             getter_AddRefs(imgList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 imgCount;
+  rv = imgList->GetLength(&imgCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  for (guint32 i = 0; i < imgCount; i++) {
+    nsCOMPtr<nsIDOMNode> imgNode;
+    rv = imgList->Item(i, getter_AddRefs(imgNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(imgNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIURI> imgUri;
+    rv = imgContent->GetCurrentURI(getter_AddRefs(imgUri));
+    if (NS_FAILED(rv) || !imgUri)
+      continue;
+
+    nsCAutoString spec;
+    rv = imgUri->GetSpec(spec);
+    if (NS_FAILED(rv))
+      continue;
+
+    if (spec.Equals(url)) {
+      gint tmp_value = 1, cur_value;
+      gtk_moz_embed_common_get_pref(G_TYPE_INT, "permissions.default.image", &cur_value);
+      if (cur_value != 1) {
+        gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &tmp_value);
+        imgContent->ForceReload();
+        gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &cur_value);
+      }
+      else
+        imgContent->ForceReload();
+    }
+  }
+
+  return TRUE;
+}
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_common.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_common.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_common.cpp
@@ -12,17 +12,17 @@
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Christopher Blizzard.
- * Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ *
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -73,32 +73,52 @@
 #include "nsStringAPI.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #endif
 // for plugins
 #include "nsIDOMNavigator.h"
 #include "nsIDOMPluginArray.h"
 #include "nsIDOMPlugin.h"
-#include <plugin/nsIPluginHost.h>
+#include "nsIPluginHost.h"
 #include "nsIDOMMimeType.h"
 #include "nsIObserverService.h"
 
+#ifdef MOZ_RDF
+#include "nsIRDFDataSource.h"
+#include "nsIRDFService.h"
+#include "nsIExtensionManager.h"
+#endif
+
 //for security
 #include "nsIWebProgressListener.h"
 
 //for cache
 #include "nsICacheService.h"
 #include "nsICache.h"
 
+// for image loading
+#include "nsIDOMDocument.h"
+#include "nsIDOMNodeList.h"
+#include "nsIImageLoadingContent.h"
+#include "nsIDOMHTMLIFrameElement.h"
+#include "nsIDOMHTMLFrameElement.h"
+#include "nsIDOMHTMLDocument.h"
+#include "nsIDOMHTMLCollection.h"
+
 #include "gtkmozembedmarshal.h"
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_TOOLKIT_STRING(x) NS_ConvertUTF16toUTF8(x).get()
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
+#define EM_RDF_EXT_DES "http://www.mozilla.org/2004/em-rdf#description"
+#define EM_RDF_EXT_CREATOR "http://www.mozilla.org/2004/em-rdf#creator"
+#define EM_RDF_EXT_STATE "http://www.mozilla.org/2004/em-rdf#userDisabled"
+#define EM_RDF_EXT_APP_DISABLED "http://www.mozilla.org/2004/em-rdf#appDisabled"
+
 #define UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(newed) PR_BEGIN_MACRO \
   /* OOPS this code is using a glib allocation function which     \
    * will cause the application to crash when it runs out of      \
    * memory. This is not cool. either g_try methods should be     \
    * used or malloc, or new (note that gecko /will/ be replacing  \
    * its operator new such that new will not throw exceptions).   \
    * XXX please fix me.                                           \
    */                                                             \
@@ -284,26 +304,20 @@
   priv->mCommon = GTK_OBJECT(common);
   common->data = priv;
   EmbedGlobalHistory::GetInstance();
 }
 
 static void
 gtk_moz_embed_common_destroy(GtkObject *object)
 {
-  g_return_if_fail(object != NULL);
-  g_return_if_fail(GTK_IS_MOZ_EMBED_COMMON(object));
-  GtkMozEmbedCommon  *embed = nsnull;
-  EmbedCommon *commonPrivate = nsnull;
-  embed = GTK_MOZ_EMBED_COMMON(object);
-  commonPrivate = (EmbedCommon *)embed->data;
-  if (commonPrivate) {
-    delete commonPrivate;
-    embed->data = NULL;
-  }
+  EmbedCommon::DeleteInstance();
+#ifdef MOZ_GTKPASSWORD_INTERFACE
+  EmbedPasswordMgr::Shutdown();
+#endif
 }
 
 GtkWidget *
 gtk_moz_embed_common_new(void)
 {
   GtkWidget *widget = (GtkWidget*) gtk_type_new(gtk_moz_embed_common_get_type());
   gtk_widget_set_name(widget, "gtkmozembedcommon");
   return (GtkWidget *) widget;
@@ -469,17 +483,17 @@
   nsresult rv;
   // The global history service
   nsCOMPtr<nsIGlobalHistory2> globalHistory(do_GetService("@mozilla.org/browser/global-history;2"));
   if (!globalHistory) return NS_ERROR_NULL_POINTER;
   // The browser history interface
   nsCOMPtr<nsIObserver> myHistory = do_QueryInterface(globalHistory, &rv);
   if (!myHistory) return NS_ERROR_NULL_POINTER ;
   if (!url)
-    myHistory->Observe(nsnull, "RemoveEntries", nsnull);
+    myHistory->Observe(nsnull, "history-item-removed", nsnull);
   else {
     EmbedGlobalHistory *history = EmbedGlobalHistory::GetInstance();
     PRUnichar *uniurl = ToNewUnicode(NS_ConvertUTF8toUTF16(url));
     rv = history->RemoveEntries(uniurl, time);
     NS_Free(uniurl);
   }
   return 1;
 }
@@ -556,88 +570,234 @@
     return NULL;
   unsigned char *data;
   ((nsIX509Cert*)nsIX509Ptr)->GetRawDER(len, (PRUint8 **)&data);
   if (!data)
     return NULL;
   return data;
 }
 
-gint
-gtk_moz_embed_common_get_plugins_list(GList **pluginArray)
+#ifdef MOZ_RDF
+static PRBool
+gtk_moz_embed_common_get_node_value(nsIRDFDataSource *eDataSource,
+                                    nsIRDFResource *itemResource,
+                                    nsIRDFService *rdfService,
+                                    gchar* nodeType, PRUnichar **retval)
+{
+  nsCOMPtr<nsIRDFResource> nodeRDFResource;
+  rdfService->GetResource(NS_LITERAL_CSTRING(nodeType), getter_AddRefs(nodeRDFResource));
+  if (!nodeRDFResource)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFNode> itemNode;
+  eDataSource->GetTarget(itemResource, nodeRDFResource, PR_TRUE, getter_AddRefs(itemNode));
+  if (!itemNode)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFLiteral> itemNodeLiteral = do_QueryInterface(itemNode);
+  if (!itemNodeLiteral)
+    return PR_FALSE;
+
+  PRUnichar *itemType = nsnull;
+  itemNodeLiteral->GetValue(&itemType);
+  *retval= itemType;
+
+  return PR_TRUE;
+}
+#endif
+
+gboolean
+gtk_moz_embed_common_set_extension_status(gchar *extensionID, gboolean status)
+{
+#ifdef MOZ_RDF
+  g_return_val_if_fail (extensionID != NULL, FALSE);
+  nsCOMPtr<nsIExtensionManager> eManager(do_GetService("@mozilla.org/extensions/manager;1"));
+  if (!eManager)
+    return FALSE;
+
+  nsAutoString id;
+  id.Append(NS_ConvertUTF8toUTF16(extensionID));
+
+  if (status)
+    eManager->EnableItem(id);
+  else
+    eManager->DisableItem(id);
+#endif
+
+  return TRUE;
+}
+
+static PRBool
+gtk_moz_embed_common_get_component_list(PRUint32 *length, GList **pluginArray)
+{
+  PRUint32 count = 0;
+  nsIUpdateItem **extensions = nsnull;
+
+#ifdef MOZ_RDF
+  nsCOMPtr<nsIExtensionManager> eManager(do_GetService("@mozilla.org/extensions/manager;1"));
+  if (!eManager)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFService> rdfService;
+  rdfService = do_GetService("@mozilla.org/rdf/rdf-service;1");
+  if (!rdfService)
+    return PR_FALSE;
+
+  nsCOMPtr<nsIRDFDataSource> eDataSource;
+  eManager->GetDatasource(getter_AddRefs(eDataSource));
+  if (!eDataSource)
+    return PR_FALSE;
+
+  eManager->GetItemList(nsIUpdateItem::TYPE_EXTENSION, &count,
+                                &extensions);
+
+  for (PRUint32 i = 0; i < count; i++) {
+    nsIUpdateItem *extension = extensions[i];
+    if (extension) {
+      GtkMozPlugin *list_item = g_new0(GtkMozPlugin, 1);
+      nsAutoString itemName;
+      extension->GetName(itemName);
+      if (itemName.IsEmpty())
+        return PR_FALSE;
+
+      nsAutoString itemId;
+      extension->GetId(itemId);
+      if (itemId.IsEmpty())
+        return PR_FALSE;
+
+      nsCString resourceID("urn:mozilla:item:");
+      resourceID.Append(NS_ConvertUTF16toUTF8(itemId));
+      nsCOMPtr<nsIRDFResource> itemResource;
+      rdfService->GetResource(resourceID, getter_AddRefs(itemResource));
+      if (!itemResource)
+        return PR_FALSE;
+
+      PRUnichar *extAppDisabled = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_APP_DISABLED, &extAppDisabled);
+      if ((extAppDisabled) && (nsDependentString(extAppDisabled).Equals(NS_LITERAL_STRING("true"))))
+        return PR_FALSE;
+
+      list_item->title = g_strdup((gchar *)NS_ConvertUTF16toUTF8(itemName).get());
+      list_item->path =  g_strdup((gchar *)NS_ConvertUTF16toUTF8(itemId).get());
+
+      PRUnichar *itemCreator = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_CREATOR, &itemCreator);
+      if (itemCreator)
+        list_item->creator = g_strdup(NS_ConvertUTF16toUTF8(itemCreator).get());
+
+      PRUnichar *itemDescrption = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_DES, &itemDescrption);
+      if(itemDescrption)
+        list_item->type = g_strdup(NS_ConvertUTF16toUTF8(itemDescrption).get());
+
+      PRUnichar *itemState = nsnull;
+      gtk_moz_embed_common_get_node_value(eDataSource, itemResource, rdfService,
+          EM_RDF_EXT_STATE, &itemState);
+      if ((itemState) && (nsDependentString(itemState).Equals(NS_LITERAL_STRING("true"))))
+        list_item->isDisabled = TRUE;
+      else
+        list_item->isDisabled = FALSE;
+
+      list_item->isPlugin = FALSE;
+      *pluginArray = g_list_append(*pluginArray, list_item);
+      *length = *length + 1;
+    }
+  }
+  return PR_TRUE;
+#else
+  return PR_FALSE;
+#endif
+}
+
+static PRBool
+gtk_moz_embed_common_get_npplugin_list(PRUint32 *aLength, GList **pluginArray)
 {
   nsresult rv;
   nsCOMPtr<nsIPluginManager> pluginMan =
     do_GetService(kPluginManagerCID, &rv);
   if (NS_FAILED(rv)) {
-    g_print("Could not get the plugin manager\n");
-    return -1;
+    NS_WARNING("Could not get the plugin manager\n");
+    return FALSE;
   }
-  pluginMan->ReloadPlugins(PR_TRUE);  //FIXME XXX MEMLEAK
+  pluginMan->ReloadPlugins(PR_FALSE);  //FIXME XXX MEMLEAK
 
   nsCOMPtr<nsIPluginHost> pluginHost =
     do_GetService(kPluginManagerCID, &rv);
-  if (NS_FAILED(rv))
-    return -1;
+  NS_ENSURE_SUCCESS(rv, FALSE);
 
-  PRUint32 aLength;
-  pluginHost->GetPluginCount(&aLength);
+  pluginHost->GetPluginCount(aLength);
 
   if (!pluginArray)
-    return (gint)aLength;
+    return FALSE;
 
-  nsIDOMPlugin **aItems = nsnull;
-  aItems = new nsIDOMPlugin*[aLength];
-  if (!aItems)
-    return -1; //NO MEMORY
+  nsIDOMPlugin **aItems = new nsIDOMPlugin*[*aLength];
+  NS_ENSURE_TRUE(aItems, FALSE); // OUT OF Memory
 
-  rv = pluginHost->GetPlugins(aLength, aItems);
+  rv = pluginHost->GetPlugins(*aLength, aItems);
   if (NS_FAILED(rv)) {
+    for (PRUint32 i = 0; i < *aLength; i++)
+      NS_IF_RELEASE(aItems[i]);
     delete [] aItems;
-    return -1;
+    return FALSE;
   }
 
   nsString string;
-  for (int plugin_index = 0; plugin_index < (gint) aLength; plugin_index++)
-  {
+  for (int plugin_index = 0; plugin_index < (gint) *aLength; plugin_index++) {
     GtkMozPlugin *list_item = g_new0(GtkMozPlugin, 1);
     UNACCEPTABLE_CRASHY_GLIB_ALLOCATION(list_item);
 
     rv = aItems[plugin_index]->GetName(string);
     if (!NS_FAILED(rv))
       list_item->title = g_strdup(NS_ConvertUTF16toUTF8(string).get());
 
     aItems[plugin_index]->GetFilename(string);
     if (!NS_FAILED(rv))
       list_item->path = g_strdup(NS_ConvertUTF16toUTF8(string).get());
 
     nsCOMPtr<nsIDOMMimeType> mimeType;
     PRUint32 mime_count = 0;
     rv = aItems[plugin_index]->GetLength(&mime_count);
     if (NS_FAILED(rv))
       continue;
-    
+
     nsString single_mime;
     string.SetLength(0);
     for (int mime_index = 0; mime_index < mime_count; ++mime_index) {
       rv = aItems[plugin_index]->Item(mime_index, getter_AddRefs(mimeType));
       if (NS_FAILED(rv))
         continue;
       rv = mimeType->GetDescription(single_mime);
       if (!NS_FAILED(rv)) {
+        if (mime_index > 0)
+          string.AppendLiteral(";");
         string.Append(single_mime);
-        string.AppendLiteral(";");
       }
     }
-    
+
     list_item->type = g_strdup(NS_ConvertUTF16toUTF8(string).get());
+    list_item->isPlugin = TRUE;
+
     if (!NS_FAILED(rv))
       *pluginArray = g_list_append(*pluginArray, list_item);
   }
+  for (PRUint32 i = 0; i < *aLength; i++)
+    NS_IF_RELEASE(aItems[i]);
   delete [] aItems;
+  return TRUE;
+}
+
+gint
+gtk_moz_embed_common_get_plugins_list(GList **pluginArray)
+{
+  PRUint32 aLength = 0;
+  gtk_moz_embed_common_get_npplugin_list(&aLength, pluginArray);
+  gtk_moz_embed_common_get_component_list(&aLength, pluginArray);
   return (gint)aLength;
 }
 
 void
 gtk_moz_embed_common_reload_plugins()
 {
   nsresult rv;
   nsCOMPtr<nsIPluginManager> pluginMan =
@@ -645,17 +805,27 @@
   pluginMan->ReloadPlugins(PR_TRUE); //FIXME XXX MEMLEAK
 }
 
 guint
 gtk_moz_embed_common_get_security_mode(guint sec_state)
 {
   GtkMozEmbedSecurityMode sec_mode;
 
-  switch (sec_state) {
+  const guint wpl_security_bits = nsIWebProgressListener::STATE_IS_SECURE |
+                                  nsIWebProgressListener::STATE_IS_BROKEN |
+                                  nsIWebProgressListener::STATE_IS_INSECURE |
+                                  nsIWebProgressListener::STATE_SECURE_HIGH |
+                                  nsIWebProgressListener::STATE_SECURE_MED |
+                                  nsIWebProgressListener::STATE_SECURE_LOW;
+
+  /* sec_state is defined as a bitmask that may be extended in the future.
+   * We filter out any unknown bits before testing for known values.
+   */
+  switch (sec_state & wpl_security_bits) {
     case nsIWebProgressListener::STATE_IS_INSECURE:
       sec_mode = GTK_MOZ_EMBED_NO_SECURITY;
       //g_print("GTK_MOZ_EMBED_NO_SECURITY\n");
       break;
     case nsIWebProgressListener::STATE_IS_BROKEN:
       sec_mode = GTK_MOZ_EMBED_NO_SECURITY;
       //g_print("GTK_MOZ_EMBED_NO_SECURITY\n");
       break;
@@ -716,8 +886,140 @@
     //This is the correct?
     nsCOMPtr<nsIObserverService> obsService =
       do_GetService("@mozilla.org/observer-service;1", &rv);
     if (obsService)
       rv = obsService->NotifyObservers((nsISupports*)object, topic, (PRUnichar*)data);
   }
   return NS_FAILED(rv) ? FALSE : TRUE;
 }
+
+/* Loads all images from all documents (frames and iframes) inside aDoc, recursively */
+static gboolean
+gtk_moz_embed_common_load_images(nsIDOMDocument *aDoc)
+{
+  /* look for img tags */
+  nsresult rv;
+  nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(aDoc, &rv);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  nsCOMPtr<nsIDOMHTMLCollection> imgList;
+  rv = htmlDoc->GetImages(getter_AddRefs(imgList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 imgCount;
+  rv = imgList->GetLength(&imgCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  guint32 i;
+  for (i = 0; i < imgCount; i++) {
+    nsCOMPtr<nsIDOMNode> imgNode;
+    rv = imgList->Item(i, getter_AddRefs(imgNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(imgNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    imgContent->ForceReload();
+  }
+
+  /* Look for iframes */
+  nsCOMPtr<nsIDOMNodeList> iframeList;
+  rv = aDoc->GetElementsByTagName(NS_LITERAL_STRING("iframe"),
+                                  getter_AddRefs(iframeList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 iframeCount;
+  rv = iframeList->GetLength(&iframeCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  /* look for frames */
+  nsCOMPtr<nsIDOMNodeList> frameList;
+  rv = aDoc->GetElementsByTagName(NS_LITERAL_STRING("frame"),
+                                  getter_AddRefs(frameList));
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  PRUint32 frameCount;
+  rv = frameList->GetLength(&frameCount);
+  NS_ENSURE_SUCCESS(rv, FALSE);
+
+  if (iframeCount == 0 && frameCount == 0)
+    return TRUE;
+
+  for (i = 0; i < iframeCount; i++) {
+    nsCOMPtr<nsIDOMNode> iframeNode;
+    rv = iframeList->Item(i, getter_AddRefs(iframeNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMHTMLIFrameElement> iframeElement = do_QueryInterface(iframeNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMDocument> iframeDoc;
+    rv = iframeElement->GetContentDocument(getter_AddRefs(iframeDoc));
+    if (NS_FAILED(rv))
+      continue;
+
+    gtk_moz_embed_common_load_images(iframeDoc);
+  }
+
+  for (i = 0; i < frameCount; i++) {
+    nsCOMPtr<nsIDOMNode> frameNode;
+    rv = frameList->Item(i, getter_AddRefs(frameNode));
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMHTMLFrameElement> frameElement = do_QueryInterface(frameNode, &rv);
+    if (NS_FAILED(rv))
+      continue;
+
+    nsCOMPtr<nsIDOMDocument> frameDoc;
+    rv = frameElement->GetContentDocument(getter_AddRefs(frameDoc));
+    if (NS_FAILED(rv))
+      continue;
+
+    gtk_moz_embed_common_load_images(frameDoc);
+  }
+
+  return TRUE;
+}
+
+gboolean
+gtk_moz_embed_common_set_image_policy(gint policy)
+{
+  if (gtk_moz_embed_common_set_pref(G_TYPE_INT, "permissions.default.image", &policy))
+     gtk_moz_embed_common_save_prefs();
+
+  PRInt32 winCount = 0;
+  if (EmbedPrivate::sWindowList)
+    winCount = EmbedPrivate::sWindowList->Count();
+
+  for (gint i = 0; i < winCount; i++) {
+    EmbedPrivate *tmpPrivate = static_cast<EmbedPrivate *>
+                                             (EmbedPrivate::sWindowList->ElementAt(i));
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    nsresult rv = tmpPrivate->mNavigation->GetDocument(getter_AddRefs(domDoc));
+    if (NS_FAILED(rv))
+      continue;
+
+    switch (policy) {
+    case GTK_MOZ_EMBED_IMAGE_POLICY_ALWAYS:
+      if (!gtk_moz_embed_common_load_images(domDoc));
+        continue;
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_NEVER:
+      tmpPrivate->Reload(nsIWebNavigation::LOAD_FLAGS_NONE);
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_NO_EXTERNAL:
+      /* Hide images from external servers */
+      break;
+    case GTK_MOZ_EMBED_IMAGE_POLICY_ONLY_LOADED:
+      if (!gtk_moz_embed_common_load_images(domDoc));
+        continue;
+      break;
+    }
+  }
+
+  return TRUE;
+}
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_common.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_common.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_common.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -157,30 +157,43 @@
 };
 /** @struct GtkMozPlugin.
  * Defines a Mozilla Plugin.
  */
 typedef struct _GtkMozPlugin GtkMozPlugin;
 struct _GtkMozPlugin
 {
     gchar *title;  /** < Plugin title */
+    gchar *creator;  /** < Plugin creator */
     gchar *path;   /** < Plugin path */
     gchar *type;   /** < Plugin type */
     gboolean isDisabled; /** < is plugin enabled */
+    gboolean isPlugin; /** <is plugin or extension*/
 };
 
 typedef struct _GtkMozLogin GtkMozLogin;
 struct _GtkMozLogin
 {
-    const gchar *user; /** < Plugin title */
-    const gchar *pass; /** < Plugin path */
-    const gchar *host; /** < Plugin type */
+    gchar *user; /** < Plugin title */
+    gchar *pass; /** < Plugin path */
+    gchar *host; /** < Plugin type */
     guint index;
 };
 
+/** GtkMozEmbedImagePolicy
+  * Enumerates image policy
+  */
+typedef enum
+{
+  GTK_MOZ_EMBED_IMAGE_POLICY_ALWAYS = 1,
+  GTK_MOZ_EMBED_IMAGE_POLICY_NEVER,
+  GTK_MOZ_EMBED_IMAGE_POLICY_NO_EXTERNAL,
+  GTK_MOZ_EMBED_IMAGE_POLICY_ONLY_LOADED
+} GtkMozEmbedImagePolicy;
+
 GTKMOZEMBED_API(GtkType,    gtk_moz_embed_common_get_type,          (void))
 GTKMOZEMBED_API(GtkWidget*, gtk_moz_embed_common_new,               (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_pref,          (GtkType type, gchar*, gpointer))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_get_pref,          (GtkType type, gchar*, gpointer))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_save_prefs,        (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_login,             (GtkWidget *embed, const gchar* username))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_remove_passwords,  (const gchar *host, const gchar *user, gint index))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_logins,        (const char* uri, GList **list))
@@ -189,16 +202,18 @@
 GTKMOZEMBED_API(GSList*,    gtk_moz_embed_common_get_cookie_list,   (void))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_delete_all_cookies,(GSList *deletedCookies))
 GTKMOZEMBED_API(unsigned char*, gtk_moz_embed_common_nsx509_to_raw, (void *nsIX509Ptr, guint *len))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_get_plugins_list,  (GList **pluginArray))
 GTKMOZEMBED_API(void,       gtk_moz_embed_common_reload_plugins,    (void))
 GTKMOZEMBED_API(guint,      gtk_moz_embed_common_get_security_mode, (guint sec_state))
 GTKMOZEMBED_API(gint,       gtk_moz_embed_common_clear_cache,       (void))
 GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_observe,           (const gchar*, gpointer, const gchar*, gunichar*))
+GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_extension_status,  (gchar *extensionID, gboolean status))
+GTKMOZEMBED_API(gboolean,   gtk_moz_embed_common_set_image_policy,  (gint policy))
 
 
 /*typedef struct _GtkMozEmbedCertContext GtkMozEmbedCertContext;
 struct _GtkMozEmbedCertContext
 {
     GObject * cert;
     guint message;
     GtkWidget *parent;
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_download.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_download.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_download.cpp
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -57,25 +57,28 @@
 #include "nsStringAPI.h"
 #endif
 
 #include "gtkmozembedmarshal.h"
 #define NEW_TOOLKIT_STRING(x) g_strdup(NS_ConvertUTF16toUTF8(x).get())
 #define GET_TOOLKIT_STRING(x) NS_ConvertUTF16toUTF8(x).get()
 #define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
 
-static void gtk_moz_embed_download_set_latest_object(GtkObject *o);
+// static stuff
+static void gtk_moz_embed_download_set_latest_object (GtkObject *o);
 static GtkObject *latest_download_object = nsnull;
+static gboolean  is_restart = FALSE;
 
 // class and instance initialization
 guint moz_embed_download_signals[DOWNLOAD_LAST_SIGNAL] = { 0 };
 static void gtk_moz_embed_download_class_init(GtkMozEmbedDownloadClass *klass);
 static void gtk_moz_embed_download_init(GtkMozEmbedDownload *embed);
 static void gtk_moz_embed_download_destroy(GtkObject *object);
 GtkObject * gtk_moz_embed_download_new(void);
+GtkObject * gtk_moz_embed_download_new_with_url_filename (const gchar *url, const gchar *filename);
 
 // GtkObject + class-related functions
 GtkType
 gtk_moz_embed_download_get_type(void)
 {
   static GtkType moz_embed_download_type = 0;
   if (!moz_embed_download_type)
   {
@@ -177,17 +180,36 @@
     embed->data = NULL;
   }
 }
 
 GtkObject *
 gtk_moz_embed_download_new(void)
 {
   GtkObject *instance = (GtkObject *) gtk_type_new(gtk_moz_embed_download_get_type());
+  g_return_val_if_fail(instance, NULL);
   gtk_moz_embed_download_set_latest_object(instance);
+  gtk_moz_embed_download_set_restart_flag (FALSE);
+
+  return instance;
+}
+
+GtkObject *
+gtk_moz_embed_download_new_with_url_filename (const gchar *url, const gchar *filename)
+{
+  g_return_val_if_fail((url && filename), nsnull);
+  GtkObject *instance = (GtkObject *) gtk_type_new(gtk_moz_embed_download_get_type());
+  g_return_val_if_fail(instance, NULL);
+
+  GtkMozEmbedDownload *download = GTK_MOZ_EMBED_DOWNLOAD(instance);
+  gtk_moz_embed_download_set_latest_object(instance);
+  gtk_moz_embed_download_set_restart_flag (TRUE);
+
+  EmbedDownloadMgr::CreateIncrementalDownload(url, filename);
+  //gtk_moz_embed_load_url (EmbedCommon::GetAnyLiveWidget(), url);
 
   return instance;
 }
 
 GtkObject *
 gtk_moz_embed_download_get_latest_object(void)
 {
   return latest_download_object;
@@ -195,90 +217,122 @@
 
 static void
 gtk_moz_embed_download_set_latest_object(GtkObject *obj)
 {
   latest_download_object = obj;
   return ;
 }
 
+gboolean
+gtk_moz_embed_download_get_restart_flag (void)
+{
+  return is_restart;
+}
+
+void
+gtk_moz_embed_download_set_restart_flag (gboolean restart)
+{
+  is_restart = restart;
+  return ;
+}
+
 void
 gtk_moz_embed_download_do_command(GtkMozEmbedDownload *item, guint command)
 {
+  g_return_if_fail(item);
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return;
 
   if (command == GTK_MOZ_EMBED_DOWNLOAD_CANCEL) {
-    download_priv->launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
-    download_priv->launcher->SetWebProgressListener(nsnull);
+    if (download_priv->launcher) {
+      download_priv->isCanceled = PR_TRUE;
+      download_priv->launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+      download_priv->launcher->SetWebProgressListener(nsnull);
+    } else if (download_priv->incr_launcher) {
+      download_priv->isCanceled = PR_TRUE;
+      item->is_paused = FALSE;
+      download_priv->incr_launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+    }
 
     return;
   }
 
-  if (command == GTK_MOZ_EMBED_DOWNLOAD_RESUME) {
-    download_priv->request->Resume();
-    download_priv->is_paused = FALSE;
+  if (command == GTK_MOZ_EMBED_DOWNLOAD_RESUME && item->is_paused) {
+    if (download_priv->incr_launcher) {
+      EmbedDownloadMgr::CreateIncrementalDownload(download_priv);
 
+    } else
+    if (download_priv->request) {
+        download_priv->request->Resume();
+    }
+    item->is_paused = FALSE;
     return;
   }
 
-  if (command == GTK_MOZ_EMBED_DOWNLOAD_PAUSE) {
-    if (download_priv->request) {
-      download_priv->request->Suspend();
-      download_priv->is_paused = TRUE;
+  if (command == GTK_MOZ_EMBED_DOWNLOAD_PAUSE && !item->is_paused) {
+    if (download_priv->incr_launcher) {
+      download_priv->incr_launcher->Cancel(GTK_MOZ_EMBED_STATUS_FAILED_USERCANCELED);
+    } else {
+      if (download_priv->request) {
+        download_priv->request->Suspend();
+      }
     }
-
+    item->is_paused = TRUE;
     return;
   }
 
   if (command == GTK_MOZ_EMBED_DOWNLOAD_RELOAD) {
     if (download_priv->gtkMozEmbedParentWidget) {}
   }
   // FIXME: missing GTK_MOZ_EMBED_DOWNLOAD_STORE and GTK_MOZ_EMBED_DOWNLOAD_RESTORE implementation.
 }
 
 gchar*
 gtk_moz_embed_download_get_file_name(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, nsnull); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return nsnull;
 
-  return (gchar *) download_priv->file_name;
+  return (gchar *) item->file_name;
 }
 
 gchar*
 gtk_moz_embed_download_get_url(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, nsnull); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return nsnull;
 
   // FIXME : 'server' is storing the wrong value. See EmbedDownloadMgr.cpp l. 189.
-  return (gchar *) download_priv->server;
+  return (gchar *) item->server;
 }
 
 glong
 gtk_moz_embed_download_get_progress(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, -1); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return -1;
 
-  return (glong) download_priv->downloaded_size;
+  return (glong) item->downloaded_size;
 }
 
 glong
 gtk_moz_embed_download_get_file_size(GtkMozEmbedDownload *item)
 {
+  g_return_val_if_fail(item, -1); // do we really need download_priv here?
   EmbedDownload *download_priv = (EmbedDownload *) item->data;
 
   if (!download_priv)
     return -1;
 
-  return (glong) download_priv->file_size;
+  return (glong) item->file_size;
 }
-
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_download.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_download.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_download.h
@@ -9,17 +9,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *   Ramiro Estrugo <ramiro@eazel.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
@@ -77,18 +77,28 @@
 #define GTK_IS_MOZ_EMBED_DOWNLOAD(obj)          GTK_CHECK_TYPE((obj), GTK_TYPE_MOZ_EMBED_DOWNLOAD)
 #define GTK_IS_MOZ_EMBED_DOWNLOAD_CLASS(klass)  GTK_CHECK_CLASS_TYPE((klass), GTK_TYPE_MOZ_EMBED_DOWNLOAD)
 
 typedef struct _GtkMozEmbedDownload      GtkMozEmbedDownload;
 typedef struct _GtkMozEmbedDownloadClass GtkMozEmbedDownloadClass;
 
 struct _GtkMozEmbedDownload
 {
-  GtkObject  object;
-  void *data;
+  GtkObject   object;
+  void        *data;
+
+  char*       file_name;             /** < The file's name */
+  char*       file_name_with_path;   /** < The file's name */
+  const char* server;                /** < The server's name */
+  const char* file_type;             /** < The file's type */
+  const char* handler_app;           /** < The application's name */
+  gulong      file_size;             /** < The file's size */
+  glong       downloaded_size;       /** < The download's size */
+  gboolean    is_paused;             /** < If download is paused or not */
+  gboolean    open_with;             /** < If the file can be opened by other application */
 };
 
 struct _GtkMozEmbedDownloadClass
 {
   GtkObjectClass parent_class;
   void (*started) (GtkMozEmbedDownload* item, gchar **file_name_with_path);
   void (*completed) (GtkMozEmbedDownload* item);
   void (*error) (GtkMozEmbedDownload* item);
@@ -101,23 +111,23 @@
   GTK_MOZ_EMBED_DOWNLOAD_RESUME,
   GTK_MOZ_EMBED_DOWNLOAD_CANCEL,
   GTK_MOZ_EMBED_DOWNLOAD_PAUSE,
   GTK_MOZ_EMBED_DOWNLOAD_RELOAD,
   GTK_MOZ_EMBED_DOWNLOAD_STORE,
   GTK_MOZ_EMBED_DOWNLOAD_RESTORE
 } GtkMozEmbedDownloadActions;
 
-GTKMOZEMBED_API(GtkType,      gtk_moz_embed_download_get_type,           (void))
-GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new,                (void))
-GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_get_latest_object,  (void))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,         (GtkMozEmbedDownload *item, guint command))
-GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_file_name,      (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_url,            (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_progress,       (GtkMozEmbedDownload *item))
-GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_file_size,      (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(GtkType,      gtk_moz_embed_download_get_type,             (void))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new,                  (void))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_new_with_url_filename,(const gchar *url, const gchar *filename))
+GTKMOZEMBED_API(GtkObject *,  gtk_moz_embed_download_get_latest_object,    (void))
+GTKMOZEMBED_API(gboolean,     gtk_moz_embed_download_get_restart_flag,     (void))
+GTKMOZEMBED_API(void,         gtk_moz_embed_download_set_restart_flag,     (gboolean))
+GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_file_name,        (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(gchar*,       gtk_moz_embed_download_get_url,              (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_progress,         (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(glong,        gtk_moz_embed_download_get_file_size,        (GtkMozEmbedDownload *item))
+GTKMOZEMBED_API(void,         gtk_moz_embed_download_do_command,           (GtkMozEmbedDownload *item, guint command))
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
 #endif /* gtkmozembed_download_h */
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_glue.cpp
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_glue.cpp
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_glue.cpp
@@ -49,38 +49,32 @@
 
 #ifndef XPCOM_GLUE
 #error This file only makes sense when XPCOM_GLUE is defined.
 #endif
 
 #define GTKMOZEMBED2_FUNCTIONS \
   GTKF(gtk_moz_embed_download_get_type) \
   GTKF(gtk_moz_embed_download_new) \
+  GTKF(gtk_moz_embed_download_new_with_url_filename) \
   GTKF(gtk_moz_embed_common_get_type) \
   GTKF(gtk_moz_embed_common_new) \
   GTKF(gtk_moz_embed_common_set_pref) \
   GTKF(gtk_moz_embed_common_get_pref) \
   GTKF(gtk_moz_embed_common_save_prefs) \
   GTKF(gtk_moz_embed_common_remove_passwords) \
   GTKF(gtk_moz_embed_common_get_history_list) \
   GTKF(gtk_moz_embed_get_zoom_level) \
   GTKF(gtk_moz_embed_set_zoom_level) \
   GTKF(gtk_moz_embed_find_text) \
-  GTKF(gtk_moz_embed_clipboard) \
   GTKF(gtk_moz_embed_notify_plugins) \
   GTKF(gtk_moz_embed_get_context_info) \
-  GTKF(gtk_moz_embed_get_selection) \
   GTKF(gtk_moz_embed_get_doc_info) \
-  GTKF(gtk_moz_embed_insert_text) \
   GTKF(gtk_moz_embed_common_nsx509_to_raw) \
   GTKF(gtk_moz_embed_common_observe) \
-  GTKF(gtk_moz_embed_get_shistory_list) \
-  GTKF(gtk_moz_embed_get_shistory_index) \
-  GTKF(gtk_moz_embed_shistory_goto_index) \
-  GTKF(gtk_moz_embed_get_server_cert) \
   GTKF(gtk_moz_embed_get_nsIWebBrowser)
 
 #define GTKMOZEMBED_FUNCTIONS \
   GTKF(gtk_moz_embed_get_type) \
   GTKF(gtk_moz_embed_new) \
   GTKF(gtk_moz_embed_push_startup) \
   GTKF(gtk_moz_embed_pop_startup) \
   GTKF(gtk_moz_embed_set_path) \
Index: mozilla/embedding/browser/gtk/src/gtkmozembed_internal.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembed_internal.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembed_internal.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
Index: mozilla/embedding/browser/gtk/src/gtkmozembedprivate.h
===================================================================
--- mozilla.orig/embedding/browser/gtk/src/gtkmozembedprivate.h
+++ mozilla/embedding/browser/gtk/src/gtkmozembedprivate.h
@@ -11,17 +11,17 @@
  * Software distributed under the License is distributed on an "AS IS" basis,
  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  * for the specific language governing rights and limitations under the
  * License.
  *
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
- * Christopher Blizzard. Portions created by Christopher Blizzard are Copyright (C) Christopher Blizzard.  All Rights Reserved.
+ * Christopher Blizzard.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Christopher Blizzard <blizzard@mozilla.org>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -87,20 +87,25 @@
   PROMPT_AUTH,
   SELECT,
   DOWNLOAD_REQUEST,
   DOM_MOUSE_SCROLL,
   DOM_MOUSE_LONG_PRESS,
   DOM_FOCUS,
   DOM_BLUR,
   UPLOAD_DIALOG,
+  FILE_UPLOAD_STARTED,
+  FILE_UPLOAD_FINISHED,
   ICON_CHANGED,
   MAILTO,
   NETWORK_ERROR,
   RSS_REQUEST,
+  DOM_WINDOW_FOCUS,
+  DOM_WINDOW_BLUR,
+  DOM_CONTENT_BLOCKED,
   EMBED_LAST_SIGNAL
 };
 
 //  DOM_MOUSE_MOVE,
 extern guint moz_embed_signals[EMBED_LAST_SIGNAL];
 
 #if 0
 enum {
