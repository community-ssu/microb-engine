# BUG347854_Building_XULRunner
--- mozilla/widget/src/gtk2/nsWindow.h.orig	2007-09-19 09:37:56.000000000 +0300
+++ mozilla/widget/src/gtk2/nsWindow.h	2007-10-24 15:35:45.000000000 +0300
@@ -341,13 +341,11 @@
 
    void                ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight);
    void                ApplyTransparencyBitmap();
-#ifdef MOZ_XUL
    NS_IMETHOD          SetWindowTranslucency(PRBool aTransparent);
    NS_IMETHOD          GetWindowTranslucency(PRBool& aTransparent);
    nsresult            UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                             PRUint8* aAlphas, PRInt32 aStride);
    NS_IMETHOD          UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
-#endif
 
     gfxASurface       *GetThebesSurface();
 
--- mozilla/widget/src/gtk2/nsWindow.cpp.orig	2007-10-12 06:02:26.000000000 +0300
+++ mozilla/widget/src/gtk2/nsWindow.cpp	2007-10-24 15:37:29.000000000 +0300
@@ -3332,17 +3332,6 @@
         GrabKeyboard();
 }
 
-#ifndef MOZ_XUL
-void
-nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
-{
-}
-
-void
-nsWindow::ApplyTransparencyBitmap()
-{
-}
-#else
 NS_IMETHODIMP
 nsWindow::SetWindowTranslucency(PRBool aTranslucent)
 {
@@ -3563,7 +3552,6 @@
 {
     return UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aRect.width);
 }
-#endif
 
 void
 nsWindow::GrabPointer(void)
--- mozilla/gfx/src/nsBlender.cpp.orig	2005-08-02 22:48:39.000000000 +0300
+++ mozilla/gfx/src/nsBlender.cpp	2007-12-10 14:41:42.000000000 +0200
@@ -230,23 +230,16 @@ NS_IMETHODIMP nsBlender::Blend(PRInt32 a
   aDest->GetDrawingSurface(&destSurface);
   if (aSecondSrc != nsnull)
     aSecondSrc->GetDrawingSurface(&secondSrcSurface);
   return Blend(aSX, aSY, aWidth, aHeight, srcSurface, destSurface,
                aDX, aDY, aSrcOpacity, secondSrcSurface, aSrcBackColor,
                aSecondSrcBackColor);
 }
 
-#ifndef MOZ_XUL
-NS_IMETHODIMP nsBlender::GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                                   nsIDrawingSurface* aWhite, PRUint8** aAlphas) {
-  NS_ERROR("GetAlphas not implemented because XUL support not built");
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-#else
 /**
  * Let A be the unknown source pixel's alpha value and let C be its (unknown) color.
  * Let S be the value painted onto black and T be the value painted onto white.
  * Then S = C*(A/255) and T = 255*(1 - A/255) + C*(A/255).
  * Therefore A = 255 - (T - S)
  * This is true no matter what color component we look at.
  */
 static void ComputeAlphasByByte(PRInt32 aNumLines, PRInt32 aBytesPerLine,
@@ -400,17 +393,16 @@ NS_IMETHODIMP nsBlender::GetAlphas(const
       whiteSurface->Unlock();
     }
 
     blackSurface->Unlock();
   }
   
   return result;
 }
-#endif // MOZ_XUL
 
 /**
   This is a simple case for 8-bit blending. We treat the opacity as binary.
 */
 static void Do8Blend(float aOpacity, PRInt32 aNumLines, PRInt32 aNumBytes,
                      PRUint8 *aSImage, PRUint8 *aS2Image, PRUint8 *aDImage,
                      PRInt32 aSLSpan, PRInt32 aDLSpan)
 {
