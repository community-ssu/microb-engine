Index: mozilla/dom/src/base/nsGlobalWindow.cpp
===================================================================
--- mozilla.orig/dom/src/base/nsGlobalWindow.cpp
+++ mozilla/dom/src/base/nsGlobalWindow.cpp
@@ -156,17 +156,19 @@
 #include "nsContentUtils.h"
 #include "nsCSSProps.h"
 #include "nsIURIFixup.h"
 #include "nsCDefaultURIFixup.h"
 #include "nsEventDispatcher.h"
 #include "nsIObserverService.h"
 #include "nsIXULAppInfo.h"
 #include "nsNetUtil.h"
+#ifdef MOZ_XUL
 #include "nsXULPopupManager.h"
+#endif
 
 #include "plbase64.h"
 
 #ifdef NS_PRINTING
 #include "nsIPrintSettings.h"
 #include "nsIPrintSettingsService.h"
 #include "nsIWebBrowserPrint.h"
 #endif
@@ -3033,23 +3035,25 @@
                     NS_ERROR_FAILURE);
 
   return NS_OK;
 }
 
 nsresult
 nsGlobalWindow::CheckSecurityWidthAndHeight(PRInt32* aWidth, PRInt32* aHeight)
 {
+#ifdef MOZ_XUL
   if (!nsContentUtils::IsCallerTrustedForWrite()) {
     // if attempting to resize the window, hide any open popups
     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
     if (pm && doc)
       pm->HidePopupsInDocument(doc);
   }
+#endif
 
   // This one is easy. Just ensure the variable is greater than 100;
   if ((aWidth && *aWidth < 100) || (aHeight && *aHeight < 100)) {
     // Check security state for use in determing window dimensions
 
     if (!nsContentUtils::IsCallerTrustedForWrite()) {
       //sec check failed
       if (aWidth && *aWidth < 100) {
@@ -3068,20 +3072,22 @@
 nsGlobalWindow::CheckSecurityLeftAndTop(PRInt32* aLeft, PRInt32* aTop)
 {
   // This one is harder. We have to get the screen size and window dimensions.
 
   // Check security state for use in determing window dimensions
 
   if (!nsContentUtils::IsCallerTrustedForWrite()) {
     // if attempting to move the window, hide any open popups
+#ifdef MOZ_XUL
     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
     if (pm && doc)
       pm->HidePopupsInDocument(doc);
+#endif
 
     PRInt32 screenLeft, screenTop, screenWidth, screenHeight;
     PRInt32 winLeft, winTop, winWidth, winHeight;
 
     nsGlobalWindow* rootWindow =
       static_cast<nsGlobalWindow*>(GetPrivateRoot());
     if (rootWindow) {
       rootWindow->FlushPendingNotifications(Flush_Layout);
Index: mozilla/layout/xul/base/src/nsXULTooltipListener.cpp
===================================================================
--- mozilla.orig/layout/xul/base/src/nsXULTooltipListener.cpp
+++ mozilla/layout/xul/base/src/nsXULTooltipListener.cpp
@@ -46,24 +46,24 @@
 #include "nsGkAtoms.h"
 #include "nsIPresShell.h"
 #include "nsIFrame.h"
 #include "nsIPopupBoxObject.h"
 #include "nsIServiceManager.h"
 #ifdef MOZ_XUL
 #include "nsIDOMNSDocument.h"
 #include "nsITreeView.h"
+#include "nsXULPopupManager.h"
 #endif
 #include "nsGUIEvent.h"
 #include "nsIPrivateDOMEvent.h"
 #include "nsPresContext.h"
 #include "nsIScriptContext.h"
 #include "nsPIDOMWindow.h"
 #include "nsContentUtils.h"
-#include "nsXULPopupManager.h"
 #include "nsIRootBox.h"
 
 nsXULTooltipListener* nsXULTooltipListener::mInstance = nsnull;
 
 //////////////////////////////////////////////////////////////////////////
 //// nsISupports
 
 nsXULTooltipListener::nsXULTooltipListener()
@@ -502,35 +502,38 @@
     mCurrentTooltip->SetAttr(nsnull, nsGkAtoms::titletip, NS_LITERAL_STRING("true"), PR_TRUE);
   } else {
     mCurrentTooltip->UnsetAttr(nsnull, nsGkAtoms::titletip, PR_TRUE);
   }
   if (!mCurrentTooltip) {
     // Because of mutation events, mCurrentTooltip can be null.
     return;
   }
-#endif
 
   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
   if (pm) {
     pm->ShowPopupAtScreen(mCurrentTooltip, mMouseClientX, mMouseClientY, PR_FALSE);
     // Clear the current tooltip if the popup was not opened successfully.
     if (!pm->IsPopupOpen(mCurrentTooltip))
       mCurrentTooltip = nsnull;
   }
+#endif
+
 }
 
 nsresult
 nsXULTooltipListener::HideTooltip()
 {
+#ifdef MOZ_XUL
   if (mCurrentTooltip) {
     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
     if (pm)
       pm->HidePopup(mCurrentTooltip, PR_FALSE, PR_FALSE, PR_FALSE);
   }
+#endif
 
   DestroyTooltip();
   return NS_OK;
 }
 
 static void
 GetImmediateChild(nsIContent* aContent, nsIAtom *aTag, nsIContent** aResult) 
 {
Index: mozilla/layout/base/nsCSSFrameConstructor.cpp
===================================================================
--- mozilla.orig/layout/base/nsCSSFrameConstructor.cpp
+++ mozilla/layout/base/nsCSSFrameConstructor.cpp
@@ -13030,22 +13030,24 @@
   mPresShell->GetDocument()->FlushPendingNotifications(Flush_Layout);
 
   // this is hard-coded to handle only menu popup frames
   nsIFrame* frame = mPresShell->GetPrimaryFrameFor(mContent);
   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
     // it is possible that the frame is different than the one that requested
     // the lazy generation, but as long as it's a popup frame that hasn't
     // generated its children yet, that's OK.
+#ifdef MOZ_XUL
     nsMenuPopupFrame* menuPopupFrame = static_cast<nsMenuPopupFrame *>(frame);
     if (menuPopupFrame->HasGeneratedChildren())
       return NS_OK;
 
     // indicate that the children have been generated
     menuPopupFrame->SetGeneratedChildren();
+#endif
 
     nsFrameItems childItems;
     nsFrameConstructorState state(mPresShell, nsnull, nsnull, nsnull);
     nsCSSFrameConstructor* fc = mPresShell->FrameConstructor();
     nsresult rv = fc->ProcessChildren(state, mContent, frame, PR_FALSE,
                                       childItems, PR_FALSE);
     if (NS_FAILED(rv))
       return rv;
Index: mozilla/layout/base/nsPresShell.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresShell.cpp
+++ mozilla/layout/base/nsPresShell.cpp
@@ -5377,31 +5377,33 @@
     NS_ASSERTION(rootPresContext = mPresContext->RootPresContext(),
                  "How did we end up outside the connected prescontext/viewmanager hierarchy?"); 
     // If we aren't starting our event dispatch from the root frame of the root prescontext,
     // then someone must be capturing the mouse. In that case we don't want to search the popup
     // list.
     if (framePresContext == rootPresContext &&
         frame == FrameManager()->GetRootFrame()) {
 
+#ifdef MOZ_XUL
       nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
       if (pm) {
         nsTArray<nsIFrame*> popups = pm->GetOpenPopups();
         PRInt32 i;
         // Search from top to bottom
         for (i = 0; i < popups.Length(); i++) {
           nsIFrame* popup = popups[i];
           if (popup->GetOverflowRect().Contains(
               nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, popup))) {
             // The event should target the popup
             frame = popup;
             break;
           }
         }
       }
+#endif
     }
 
     nsPoint eventPoint
         = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, frame);
     nsIFrame* targetFrame = nsLayoutUtils::GetFrameForPoint(frame, eventPoint);
     if (targetFrame) {
       PresShell* shell =
           static_cast<PresShell*>(targetFrame->PresContext()->PresShell());
Index: mozilla/layout/base/nsDocumentViewer.cpp
===================================================================
--- mozilla.orig/layout/base/nsDocumentViewer.cpp
+++ mozilla/layout/base/nsDocumentViewer.cpp
@@ -104,18 +104,18 @@
 #include "nsIDOMHTMLAnchorElement.h"
 #include "nsIDOMHTMLAreaElement.h"
 #include "nsIDOMHTMLLinkElement.h"
 #include "nsIImageLoadingContent.h"
 #include "nsCopySupport.h"
 #include "nsIDOMHTMLFrameSetElement.h"
 #ifdef MOZ_XUL
 #include "nsIXULDocument.h"
-#endif
 #include "nsXULPopupManager.h"
+#endif
 #include "nsPrintfCString.h"
 
 #include "nsIClipboardHelper.h"
 
 #include "nsPIDOMWindow.h"
 #include "nsJSEnvironment.h"
 #include "nsIFocusController.h"
 #include "nsIMenuParent.h"
@@ -1148,21 +1148,23 @@
 
     // Never permit popups from the unload handler, no matter how we get
     // here.
     nsAutoPopupStatePusher popupStatePusher(openAbused, PR_TRUE);
 
     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
   }
 
+#ifdef MOZ_XUL
   // look for open menupopups and close them after the unload event, in case
   // the unload event listeners open any new popups
   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
   if (pm && mDocument)
     pm->HidePopupsInDocument(mDocument);
+#endif
 
   return NS_OK;
 }
 
 static void
 AttachContainerRecurse(nsIDocShell* aShell)
 {
   nsCOMPtr<nsIContentViewer> viewer;
Index: mozilla/layout/build/nsLayoutStatics.cpp
===================================================================
--- mozilla.orig/layout/build/nsLayoutStatics.cpp
+++ mozilla/layout/build/nsLayoutStatics.cpp
@@ -74,20 +74,20 @@
 #include "nsStyleSet.h"
 #include "nsTextControlFrame.h"
 #include "nsXBLWindowKeyHandler.h"
 #include "txMozillaXSLTProcessor.h"
 #include "nsDOMStorage.h"
 #include "nsCellMap.h"
 #include "nsTextFrameTextRunCache.h"
 #include "nsCCUncollectableMarker.h"
-#include "nsXULPopupManager.h"
 #include "nsTextFragment.h"
 
 #ifdef MOZ_XUL
+#include "nsXULPopupManager.h"
 #include "nsXULContentUtils.h"
 #include "nsXULElement.h"
 #include "nsXULPrototypeCache.h"
 #include "nsXULTooltipListener.h"
 
 #ifndef MOZ_NO_INSPECTOR_APIS
 #include "inDOMView.h"
 #endif
@@ -215,29 +215,33 @@
   }
 
   rv = nsCCUncollectableMarker::Init();
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not initialize nsCCUncollectableMarker");
     return rv;
   }
 
+#ifdef MOZ_XUL
   rv = nsXULPopupManager::Init();
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not initialize nsXULPopupManager");
     return rv;
   }
+#endif
 
   return NS_OK;
 }
 
 void
 nsLayoutStatics::Shutdown()
 {
+#ifdef MOZ_XUL
   nsXULPopupManager::Shutdown();
+#endif
   nsDOMStorageManager::Shutdown();
   txMozillaXSLTProcessor::Shutdown();
   nsDOMAttribute::Shutdown();
   nsDOMEventRTTearoff::Shutdown();
   nsEventListenerManager::Shutdown();
   nsContentList::Shutdown();
   nsComputedDOMStyle::Shutdown();
   CSSLoaderImpl::Shutdown();
