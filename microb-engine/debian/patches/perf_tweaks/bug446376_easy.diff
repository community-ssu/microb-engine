# temporary fix for bug 446376
# we have to fix clipping properly and replace this fix
Index: mozilla/layout/generic/nsImageFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsImageFrame.cpp
+++ mozilla/layout/generic/nsImageFrame.cpp
@@ -1143,46 +1143,66 @@
  * image itself, and hence receive events just as if the image itself
  * received events.
  */
 class nsDisplayImage : public nsDisplayItem {
 public:
   nsDisplayImage(nsImageFrame* aFrame, imgIContainer* aImage)
     : nsDisplayItem(aFrame), mImage(aImage) {
     MOZ_COUNT_CTOR(nsDisplayImage);
+    mDirtyRegion.SetEmpty();
   }
   virtual ~nsDisplayImage() {
     MOZ_COUNT_DTOR(nsDisplayImage);
   }
+  virtual PRBool OptimizeVisibility(nsDisplayListBuilder* aBuilder,
+                                    nsRegion* aVisibleRegion);
   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
      const nsRect& aDirtyRect);
   NS_DISPLAY_DECL_NAME("Image")
 private:
   nsCOMPtr<imgIContainer> mImage;
+  nsRegion                mDirtyRegion;
 };
 
+PRBool
+nsDisplayImage::OptimizeVisibility(nsDisplayListBuilder* aBuilder,
+                                   nsRegion* aVisibleRegion) {
+  if (!nsDisplayItem::OptimizeVisibility(aBuilder, aVisibleRegion))
+    return PR_FALSE;
+  mDirtyRegion = *aVisibleRegion;
+  return PR_TRUE;
+}
+
 void
 nsDisplayImage::Paint(nsDisplayListBuilder* aBuilder,
      nsIRenderingContext* aCtx, const nsRect& aDirtyRect) {
   static_cast<nsImageFrame*>(mFrame)->
-    PaintImage(*aCtx, aBuilder->ToReferenceFrame(mFrame), aDirtyRect, mImage);
+    PaintImage(*aCtx, aBuilder->ToReferenceFrame(mFrame),
+               mDirtyRegion.IsEmpty() ? nsRegion(aDirtyRect) : mDirtyRegion, mImage);
 }
 
 void
 nsImageFrame::PaintImage(nsIRenderingContext& aRenderingContext, nsPoint aPt,
-                         const nsRect& aDirtyRect, imgIContainer* aImage)
+                         const nsRegion& aDirtyRegion, imgIContainer* aImage)
 {
   // Render the image into our content area (the area inside
   // the borders and padding)
   NS_ASSERTION(GetInnerArea().width == mComputedSize.width, "bad width");
   nsRect inner = GetInnerArea() + aPt;
   nsRect dest(inner.TopLeft(), mComputedSize);
   dest.y -= GetContinuationOffset();
 
-  nsLayoutUtils::DrawSingleImage(&aRenderingContext, aImage, dest, aDirtyRect);
+  nsRegionRectIterator ri (aDirtyRegion);
+  const nsRect* subRect;
+  while ((subRect = ri.Next ())) {
+    nsRect clip;
+    clip.IntersectRect(inner, *subRect);
+    nsLayoutUtils::DrawSingleImage(&aRenderingContext, aImage, dest, clip);
+  }
 
   nsPresContext* presContext = PresContext();
   nsImageMap* map = GetImageMap(presContext);
   if (nsnull != map) {
     aRenderingContext.PushState();
     aRenderingContext.SetColor(NS_RGB(0, 0, 0));
     aRenderingContext.SetLineStyle(nsLineStyle_kDotted);
     aRenderingContext.Translate(inner.x, inner.y);
Index: mozilla/layout/generic/nsImageFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsImageFrame.h
+++ mozilla/layout/generic/nsImageFrame.h
@@ -47,16 +47,17 @@
 #include "nsPresContext.h"
 #include "nsIImageFrame.h"
 #include "nsIIOService.h"
 #include "nsIObserver.h"
 
 #include "nsTransform2D.h"
 #include "imgIRequest.h"
 #include "nsStubImageDecoderObserver.h"
+#include "nsRegion.h"
 
 class nsIFrame;
 class nsImageMap;
 class nsIURI;
 class nsILoadGroup;
 struct nsHTMLReflowState;
 struct nsHTMLReflowMetrics;
 struct nsSize;
@@ -213,17 +214,17 @@
                         nsIRenderingContext& aContext);
 
   void DisplayAltText(nsPresContext*      aPresContext,
                       nsIRenderingContext& aRenderingContext,
                       const nsString&      aAltText,
                       const nsRect&        aRect);
 
   void PaintImage(nsIRenderingContext& aRenderingContext, nsPoint aPt,
-                  const nsRect& aDirtyRect, imgIContainer* aImage);
+                  const nsRegion& aDirtyRegion, imgIContainer* aImage);
                   
 protected:
   friend class nsImageListener;
   nsresult OnStartContainer(imgIRequest *aRequest, imgIContainer *aImage);
   nsresult OnDataAvailable(imgIRequest *aRequest,
                            gfxIImageFrame *aFrame,
                            const nsRect * rect);
   nsresult OnStopDecode(imgIRequest *aRequest,
