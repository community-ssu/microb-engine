#Proposed way to render plugins content directly to gfx surface
diff -r aa32fe123f05 layout/generic/nsObjectFrame.cpp
--- a/layout/generic/nsObjectFrame.cpp	Wed Feb 11 15:48:52 2009 +0200
+++ b/layout/generic/nsObjectFrame.cpp	Thu Feb 12 01:20:54 2009 +0200
@@ -140,6 +140,8 @@
 #include "gfxWindowsSurface.h"
 #endif
 
+#include "gfxImageSurface.h"
+
 // accessibility support
 #ifdef ACCESSIBILITY
 #include "nsIAccessibilityService.h"
@@ -536,6 +538,10 @@ private:
     const nsIntRect& mDirtyRect;
   };
 #endif
+  nsresult NativeImageDraw(gfxContext *aContext,
+                           nsPluginWindow* mWindow,
+                           const nsIntSize& mPluginSize,
+                           const nsIntRect& mDirtyRect);
 
 };
 
@@ -2516,6 +2522,7 @@ NS_IMETHODIMP nsPluginInstanceOwner::Inv
                 presContext->DevPixelsToAppUnits(invalidRect->top),
                 presContext->DevPixelsToAppUnits(invalidRect->right - invalidRect->left),
                 presContext->DevPixelsToAppUnits(invalidRect->bottom - invalidRect->top));
+
     mOwner->Invalidate(rect);
   }
 
@@ -4227,7 +4234,6 @@ void nsPluginInstanceOwner::Paint(gfxCon
   nsPluginWindow* window;
   GetWindow(window);
 
-  Renderer renderer(window, mInstance, pluginSize, pluginDirtyRect);
   PRUint32 rendererFlags =
     Renderer::DRAW_SUPPORTS_OFFSET |
     Renderer::DRAW_SUPPORTS_CLIP_RECT |
@@ -4244,6 +4250,15 @@ void nsPluginInstanceOwner::Paint(gfxCon
   gfxContextAutoSaveRestore autoSR(aContext);
   aContext->Translate(pluginRect.pos);
 
+  PRBool simpleImageRender = PR_FALSE;
+  mInstance->GetValue(nsPluginInstanceVariable_WindowlessLocalBool,
+                      (void *)&simpleImageRender);
+  if (simpleImageRender) {
+    NativeImageDraw(aContext, window, pluginSize, pluginDirtyRect);
+    return;
+  }
+
+  Renderer renderer(window, mInstance, pluginSize, pluginDirtyRect);
   renderer.Draw(aContext, window->width, window->height,
                 rendererFlags, nsnull);
 }
@@ -4265,6 +4280,114 @@ DepthOfVisual(const Screen* screen, cons
 }
 #endif
 
+nsresult
+nsPluginInstanceOwner::NativeImageDraw(gfxContext *aContext,
+                                       nsPluginWindow* mWindow,
+                                       const nsIntSize& mPluginSize,
+                                       const nsIntRect& mDirtyRect)
+
+{
+  PRBool doupdatewindow = PR_FALSE;
+
+  int offsetX = 0, offsetY = 0;
+  if (mWindow->x != offsetX || mWindow->y != offsetY) {
+    mWindow->x = offsetX;
+    mWindow->y = offsetY;
+    doupdatewindow = PR_TRUE;
+  }
+
+  if (nsIntSize(mWindow->width, mWindow->height) != mPluginSize) {
+    mWindow->width = mPluginSize.width;
+    mWindow->height = mPluginSize.height;
+    doupdatewindow = PR_TRUE;
+  }
+
+  // The clip rect is relative to drawable top-left.
+  nsIntRect clipRect;
+  // nsPluginRect members are unsigned, but
+  // we should have been given a clip if an offset is -ve.
+  NS_ASSERTION(offsetX >= 0 && offsetY >= 0,
+               "Clip rectangle offsets are negative!");
+  clipRect.x = offsetX;
+  clipRect.y = offsetY;
+  clipRect.width  = mWindow->width;
+  clipRect.height = mWindow->height;
+
+  nsPluginRect newClipRect;
+  newClipRect.left = clipRect.x;
+  newClipRect.top = clipRect.y;
+  newClipRect.right = clipRect.XMost();
+  newClipRect.bottom = clipRect.YMost();
+  if (mWindow->clipRect.left    != newClipRect.left   ||
+      mWindow->clipRect.top     != newClipRect.top    ||
+      mWindow->clipRect.right   != newClipRect.right  ||
+      mWindow->clipRect.bottom  != newClipRect.bottom) {
+    mWindow->clipRect = newClipRect;
+    doupdatewindow = PR_TRUE;
+  }
+
+  NPSetWindowCallbackStruct* ws_info =
+    static_cast<NPSetWindowCallbackStruct*>(mWindow->ws_info);
+  ws_info->visual = 0;
+  ws_info->colormap = 0;
+  ws_info->depth = 24;
+
+  if (doupdatewindow)
+      mInstance->SetWindow(mWindow);
+
+#ifdef MOZ_X11
+  // Translate the dirty rect to drawable coordinates.
+  nsIntRect dirtyRect = mDirtyRect + nsIntPoint(offsetX, offsetY);
+  // Intersect the dirty rect with the clip rect to ensure that it lies within
+  // the drawable.
+  if (!dirtyRect.IntersectRect(dirtyRect, clipRect))
+    return NS_OK;
+
+  nsPluginEvent pluginEvent;
+  NPImageExpose imageExpose;
+  XGraphicsExposeEvent& exposeEvent = pluginEvent.event.xgraphicsexpose;
+  // set the drawing info
+  exposeEvent.type = GraphicsExpose;
+  exposeEvent.display = 0;
+  // Store imageExpose structure pointer as drawable member
+  exposeEvent.drawable = (Drawable)&imageExpose;
+  exposeEvent.x = mDirtyRect.x + offsetX;
+  exposeEvent.y = mDirtyRect.y + offsetY;
+  exposeEvent.width = mDirtyRect.width;
+  exposeEvent.height = mDirtyRect.height;
+  exposeEvent.count = 0;
+  // information not set:
+  exposeEvent.serial = 0;
+  exposeEvent.send_event = False;
+  exposeEvent.major_code = 0;
+  exposeEvent.minor_code = 0;
+
+  nsRefPtr<gfxImageSurface> surface = static_cast<gfxImageSurface*>(aContext->OriginalSurface());
+  NS_ENSURE_TRUE(surface, NS_ERROR_OUT_OF_MEMORY);
+  // Calculate src buffer pointer according to translation
+  // and set it as drawable member
+  gfxMatrix matr = aContext->CurrentMatrix();
+  gfxPoint pt = matr.GetTranslation();
+  imageExpose.stride = 4*(int)surface->Width();
+  imageExpose.data = ((char *)surface->Data() + 4*(int)pt.y*(int)surface->Width() + 4*(int)pt.x);
+  imageExpose.depth = 24;
+  imageExpose.x = mDirtyRect.x + offsetX;
+  imageExpose.y = mDirtyRect.y + offsetY;
+  imageExpose.width = mDirtyRect.width;
+  imageExpose.height = mDirtyRect.height;
+  // Setup temporary context scaled size
+  imageExpose.scaledSize.width = (int)((float)mPluginSize.width * matr.xx);
+  imageExpose.scaledSize.height = (int)((float)mPluginSize.height * matr.yy);
+  imageExpose.hasBuffer = FALSE;
+  PRBool eventHandled = PR_FALSE;
+  // Get Image surface from original context
+  // Draw plugin content to temp surface
+  mInstance->HandleEvent(&pluginEvent, &eventHandled);
+#endif
+
+  return NS_OK;
+}
+
 #if defined(MOZ_WIDGET_GTK2)
 nsresult
 nsPluginInstanceOwner::Renderer::NativeDraw(GdkDrawable * drawable, 
diff -r aa32fe123f05 modules/plugin/base/public/npapi.h
--- a/modules/plugin/base/public/npapi.h	Wed Feb 11 15:48:52 2009 +0200
+++ b/modules/plugin/base/public/npapi.h	Thu Feb 12 01:20:54 2009 +0200
@@ -333,6 +333,7 @@ typedef enum {
   /* Used for negotiating drawing models */
   , NPPVpluginDrawingModel = 1000
 #endif
+  , NPPVpluginWindowlessLocalBool = 2002
 } NPPVariable;
 
 /*
@@ -371,6 +372,7 @@ typedef enum {
 #endif
   , NPNVsupportsCoreGraphicsBool = 2001
 #endif
+  , NPNVSupportsWindowlessLocal = 2002
 } NPNVariable;
 
 typedef enum {
@@ -412,6 +414,18 @@ typedef struct _NPWindow
   NPWindowType type; /* Is this a window or a drawable? */
 } NPWindow;
 
+typedef struct _NPImageExpose
+{
+  char*    data;     /* image pointer */
+  int32_t  stride;   /* Stride of data image pointer */
+  int32_t  depth;    /* Depth of image pointer */
+  int32_t  x;        /* Expose x */
+  int32_t  y;        /* Expose y */
+  uint32_t width;    /* Expose width */
+  uint32_t height;   /* Expose height */
+  NPSize   scaledSize; /* Context scaled port size */
+  NPBool   hasBuffer;
+} NPImageExpose;
 
 typedef struct _NPFullPrint
 {
@@ -580,6 +594,7 @@ enum NPEventType {
 #define NPVERS_HAS_PLUGIN_THREAD_ASYNC_CALL 19
 #define NPVERS_HAS_ALL_NETWORK_STREAMS      20
 #define NPVERS_HAS_URL_AND_AUTH_INFO        21
+#define NPVERS_HAS_WINDOWLESS_LOCAL         22
 
 /*----------------------------------------------------------------------*/
 /*                        Function Prototypes                           */
diff -r aa32fe123f05 modules/plugin/base/public/nsplugindefs.h
--- a/modules/plugin/base/public/nsplugindefs.h	Wed Feb 11 15:48:52 2009 +0200
+++ b/modules/plugin/base/public/nsplugindefs.h	Thu Feb 12 01:20:54 2009 +0200
@@ -204,6 +204,7 @@ enum nsPluginInstanceVariable {
 #ifdef XP_MACOSX
     , nsPluginInstanceVariable_DrawingModel          = 20
 #endif
+    , nsPluginInstanceVariable_WindowlessLocalBool   = 21
 };
 
 ////////////////////////////////////////////////////////////////////////////////
diff -r aa32fe123f05 modules/plugin/base/src/nsNPAPIPlugin.cpp
--- a/modules/plugin/base/src/nsNPAPIPlugin.cpp	Wed Feb 11 15:48:52 2009 +0200
+++ b/modules/plugin/base/src/nsNPAPIPlugin.cpp	Thu Feb 12 01:20:54 2009 +0200
@@ -2052,6 +2052,15 @@ _getvalue(NPP npp, NPNVariable variable,
     return NPERR_GENERIC_ERROR;
   }
 
+  case NPNVSupportsWindowlessLocal: {
+#if defined(XP_WIN) || defined(XP_MACOSX) || (defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2))
+    *(NPBool*)result = PR_TRUE;
+#else
+    *(NPBool*)result = PR_FALSE;
+#endif
+    return NPERR_NO_ERROR;
+  }
+
 #ifdef XP_MACOSX
   case NPNVpluginDrawingModel: {
     if (npp) {
@@ -2126,6 +2135,11 @@ _setvalue(NPP npp, NPPVariable variable,
 #endif
     }
 
+    case NPPVpluginWindowlessLocalBool: {
+      NPBool bWindowlessLocal = (result != nsnull);
+      return inst->SetWindowlessLocal(bWindowlessLocal);
+    }
+
     case NPPVpluginTransparentBool: {
       NPBool bTransparent = (result != nsnull);
       return inst->SetTransparent(bTransparent);
diff -r aa32fe123f05 modules/plugin/base/src/nsNPAPIPluginInstance.cpp
--- a/modules/plugin/base/src/nsNPAPIPluginInstance.cpp	Wed Feb 11 15:48:52 2009 +0200
+++ b/modules/plugin/base/src/nsNPAPIPluginInstance.cpp	Thu Feb 12 01:20:54 2009 +0200
@@ -764,6 +764,7 @@ nsNPAPIPluginInstance::nsNPAPIPluginInst
 #endif
 #endif
     mWindowless(PR_FALSE),
+    mWindowlessLocal(PR_FALSE),
     mTransparent(PR_FALSE),
     mStarted(PR_FALSE),
     mCached(PR_FALSE),
@@ -1256,6 +1257,10 @@ NS_IMETHODIMP nsNPAPIPluginInstance::Get
       *(PRBool *)value = mWindowless;
       break;
 
+    case nsPluginInstanceVariable_WindowlessLocalBool:
+      *(PRBool *)value = mWindowlessLocal;
+      break;
+
     case nsPluginInstanceVariable_TransparentBool:
       *(PRBool *)value = mTransparent;
       break;
@@ -1307,6 +1312,12 @@ NPError nsNPAPIPluginInstance::SetWindow
   return NPERR_NO_ERROR;
 }
 
+NPError nsNPAPIPluginInstance::SetWindowlessLocal(PRBool aWindowlessLocal)
+{
+  mWindowlessLocal = aWindowlessLocal;
+  return NPERR_NO_ERROR;
+}
+
 NPError nsNPAPIPluginInstance::SetTransparent(PRBool aTransparent)
 {
   mTransparent = aTransparent;
diff -r aa32fe123f05 modules/plugin/base/src/nsNPAPIPluginInstance.h
--- a/modules/plugin/base/src/nsNPAPIPluginInstance.h	Wed Feb 11 15:48:52 2009 +0200
+++ b/modules/plugin/base/src/nsNPAPIPluginInstance.h	Thu Feb 12 01:20:54 2009 +0200
@@ -96,6 +96,8 @@ public:
 
     NPError SetWindowless(PRBool aWindowless);
 
+    NPError SetWindowlessLocal(PRBool aWindowlessLocal);
+
     NPError SetTransparent(PRBool aTransparent);
 
     NPError SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams);
@@ -158,6 +160,7 @@ protected:
     // these are used to store the windowless properties
     // which the browser will later query
     PRPackedBool  mWindowless;
+    PRPackedBool  mWindowlessLocal;
     PRPackedBool  mTransparent;
     PRPackedBool  mStarted;
     PRPackedBool  mCached;
