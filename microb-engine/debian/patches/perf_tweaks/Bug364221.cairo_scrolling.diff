#Bug 364221  [cairo] bad page scrolling performance with large background images 
#testcase https://bugzilla.mozilla.org/attachment.cgi?id=212976
Index: mozilla/gfx/src/thebes/nsThebesImage.cpp
===================================================================
RCS file: /cvsroot/mozilla/gfx/src/thebes/nsThebesImage.cpp,v
retrieving revision 1.51
diff -u -8 -p -r1.51 nsThebesImage.cpp
--- mozilla/gfx/src/thebes/nsThebesImage.cpp	3 Oct 2007 21:27:43 -0000	1.51
+++ mozilla/gfx/src/thebes/nsThebesImage.cpp	8 Nov 2007 08:16:05 -0000
@@ -61,16 +61,17 @@ NS_IMPL_ISUPPORTS1(nsThebesImage, nsIIma
 
 nsThebesImage::nsThebesImage()
     : mFormat(gfxImageSurface::ImageFormatRGB24),
       mWidth(0),
       mHeight(0),
       mDecoded(0,0,0,0),
       mImageComplete(PR_FALSE),
       mSinglePixel(PR_FALSE),
+      mFormatChanged(PR_FALSE),
       mAlphaDepth(0)
 {
     static PRBool hasCheckedOptimize = PR_FALSE;
     if (!hasCheckedOptimize) {
         if (PR_GetEnv("MOZ_DISABLE_IMAGE_OPTIMIZE")) {
             gDisableOptimize = PR_TRUE;
         }
         hasCheckedOptimize = PR_TRUE;
@@ -249,16 +250,18 @@ nsThebesImage::Optimize(nsIDeviceContext
         // never hit this.
     }
 
     // if we're being forced to use image surfaces due to
     // resource constraints, don't try to optimize beyond single-pixel.
     if (ShouldUseImageSurfaces())
         return NS_OK;
 
+    mOptSurface = nsnull;
+
 #ifdef XP_WIN
     // we need to special-case windows here, because windows has
     // a distinction between DIB and DDB and we want to use DDBs as much
     // as we can.
     if (mWinSurface) {
         // Don't do DDBs for large images; see bug 359147
         // Note that we bother with DDBs at all because they are much faster
         // on some systems; on others there isn't much of a speed difference
@@ -283,31 +286,32 @@ nsThebesImage::Optimize(nsIDeviceContext
             nsRefPtr<gfxWindowsSurface> wsurf = mWinSurface->OptimizeToDDB(nsnull, gfxIntSize(mWidth, mHeight), mFormat);
             if (wsurf) {
                 gTotalDDBs++;
                 gTotalDDBSize += ddbSize;
                 mIsDDBSurface = PR_TRUE;
                 mOptSurface = wsurf;
             }
         }
-
-        if (!mOptSurface) {
-            // just use the DIB
+        if (!mOptSurface && !mFormatChanged) {
+            // just use the DIB if the format has not changed
             mOptSurface = mWinSurface;
         }
-    } else {
-        mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface);
     }
-
-    mWinSurface = nsnull;
-#else
-    mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface);
 #endif
 
-    mImageSurface = nsnull;
+    if (mOptSurface == nsnull)
+        mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface, mFormat);
+
+    if (mOptSurface) {
+        mImageSurface = nsnull;
+#ifdef XP_WIN
+        mWinSurface = nsnull;
+#endif
+    }
 
     return NS_OK;
 }
 
 nsColorMap *
 nsThebesImage::GetColorMap()
 {
     return NULL;
@@ -631,11 +635,13 @@ nsThebesImage::ShouldUseImageSurfaces()
 // though we created is ARGB32.  This changes our format to RGB24,
 // which in turn will cause us to Optimize() to RGB24.  Has no effect
 // after Optimize() is called, though in all cases it will be just a
 // performance win -- the pixels are still correct and have the A byte
 // set to 0xff.
 void
 nsThebesImage::SetHasNoAlpha()
 {
-    if (mFormat == gfxASurface::ImageFormatARGB32)
+    if (mFormat == gfxASurface::ImageFormatARGB32) {
         mFormat = gfxASurface::ImageFormatRGB24;
+        mFormatChanged = PR_TRUE;
+    }
 }
Index: mozilla/gfx/src/thebes/nsThebesImage.h
===================================================================
RCS file: /cvsroot/mozilla/gfx/src/thebes/nsThebesImage.h,v
retrieving revision 1.16
diff -u -8 -p -r1.16 nsThebesImage.h
--- mozilla/gfx/src/thebes/nsThebesImage.h	3 Oct 2007 21:27:43 -0000	1.16
+++ mozilla/gfx/src/thebes/nsThebesImage.h	8 Nov 2007 08:16:05 -0000
@@ -137,16 +137,17 @@ protected:
 
     gfxImageSurface::gfxImageFormat mFormat;
     PRInt32 mWidth;
     PRInt32 mHeight;
     PRInt32 mStride;
     nsRect mDecoded;
     PRPackedBool mImageComplete;
     PRPackedBool mSinglePixel;
+    PRPackedBool mFormatChanged;
 #ifdef XP_WIN
     PRPackedBool mIsDDBSurface;
 #endif
 
     gfxRGBA mSinglePixelColor;
 
     nsRefPtr<gfxImageSurface> mImageSurface;
     nsRefPtr<gfxASurface> mOptSurface;
Index: mozilla/gfx/thebes/public/gfxPlatform.h
===================================================================
RCS file: /cvsroot/mozilla/gfx/thebes/public/gfxPlatform.h,v
retrieving revision 1.25
diff -u -8 -p -r1.25 gfxPlatform.h
--- mozilla/gfx/thebes/public/gfxPlatform.h	30 Aug 2007 16:21:16 -0000	1.25
+++ mozilla/gfx/thebes/public/gfxPlatform.h	8 Nov 2007 08:16:06 -0000
@@ -82,25 +82,24 @@ public:
 
     /**
      * Force the glitz state to on or off
      */
     static void SetUseGlitz(PRBool use);
 
     /**
      * Create an offscreen surface of the given dimensions
-     * and image format.  If fastPixelAccess is TRUE,
-     * create a surface that is optimized for rapid pixel
-     * changing.
+     * and image format.
      */
     virtual already_AddRefed<gfxASurface> CreateOffscreenSurface(const gfxIntSize& size,
                                                                  gfxASurface::gfxImageFormat imageFormat) = 0;
 
 
-    virtual already_AddRefed<gfxASurface> OptimizeImage(gfxImageSurface *aSurface);
+    virtual already_AddRefed<gfxASurface> OptimizeImage(gfxImageSurface *aSurface,
+                                                        gfxASurface::gfxImageFormat format);
 
     /*
      * Font bits
      */
 
     /**
      * Fill aListOfFonts with the results of querying the list of font names
      * that correspond to the given language group or generic font family
Index: mozilla/gfx/thebes/src/gfxPlatform.cpp
===================================================================
RCS file: /cvsroot/mozilla/gfx/thebes/src/gfxPlatform.cpp,v
retrieving revision 1.27
diff -u -8 -p -r1.27 gfxPlatform.cpp
--- mozilla/gfx/thebes/src/gfxPlatform.cpp	26 Oct 2007 01:21:50 -0000	1.27
+++ mozilla/gfx/thebes/src/gfxPlatform.cpp	8 Nov 2007 08:16:06 -0000
@@ -190,25 +190,23 @@ gfxPlatform::UseGlitz()
 
 void
 gfxPlatform::SetUseGlitz(PRBool use)
 {
     gGlitzState = (use ? 1 : 0);
 }
 
 already_AddRefed<gfxASurface>
-gfxPlatform::OptimizeImage(gfxImageSurface *aSurface)
+gfxPlatform::OptimizeImage(gfxImageSurface *aSurface,
+                           gfxASurface::gfxImageFormat format)
 {
     const gfxIntSize& surfaceSize = aSurface->GetSize();
 
-    gfxASurface::gfxImageFormat realFormat = aSurface->Format();
-
-    nsRefPtr<gfxASurface> optSurface = CreateOffscreenSurface(surfaceSize, realFormat);
-
-    if (!optSurface)
+    nsRefPtr<gfxASurface> optSurface = CreateOffscreenSurface(surfaceSize, format);
+    if (!optSurface || optSurface->CairoStatus() != 0)
         return nsnull;
 
     nsRefPtr<gfxContext> tmpCtx(new gfxContext(optSurface));
     tmpCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
     tmpCtx->SetSource(aSurface);
     tmpCtx->Paint();
 
     gfxASurface *ret = optSurface;
--- mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.h.orig	2007-08-26 08:08:53.000000000 +0300
+++ mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.h	2007-11-08 14:30:34.000000000 +0200
@@ -94,13 +94,14 @@ private:
   PRInt32 mLastFlushedRow;
 
   PRUint32 *mImageData;      // Pointer to image data in Cairo format
   PRUint32 *mColormap;       // Current colormap to be used in Cairo format
   PRUint32 mOldColor;        // The old value of the transparent pixel
   PRUint8 mCurrentPass;
   PRUint8 mLastFlushedPass;
   PRPackedBool mGIFOpen;
+  PRPackedBool mSawTransparency;
 
   gif_struct mGIFStruct;
 };
 
 #endif
--- mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp.orig	2007-11-08 12:20:35.000000000 +0200
+++ mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp	2007-11-08 14:33:31.000000000 +0200
@@ -118,16 +118,17 @@ NS_IMPL_ISUPPORTS1(nsGIFDecoder2, imgIDe
 nsGIFDecoder2::nsGIFDecoder2()
   : mCurrentRow(-1)
   , mLastFlushedRow(-1)
   , mImageData(nsnull)
   , mCurrentPass(0)
   , mLastFlushedPass(0)
   , mOldColor(0)
   , mGIFOpen(PR_FALSE)
+  , mSawTransparency(PR_FALSE)
 {
   // Clear out the structure, excluding the arrays
   memset(&mGIFStruct, 0, sizeof(mGIFStruct));
 }
 
 nsGIFDecoder2::~nsGIFDecoder2()
 {
   Close();
@@ -370,16 +371,21 @@ void nsGIFDecoder2::EndImageFrame()
     // This will clear the remaining bits of the placeholder. (Bug 37589)
     const PRUint32 realFrameHeight = mGIFStruct.height + mGIFStruct.y_offset;
     if (realFrameHeight < mGIFStruct.screen_height) {
       nsIntRect r(0, realFrameHeight, 
                   mGIFStruct.screen_width, 
 				  mGIFStruct.screen_height - realFrameHeight);
       mObserver->OnDataAvailable(nsnull, mImageFrame, &r);
     }
+    // This transparency check is only valid for first frame
+    if (mGIFStruct.is_transparent && !mSawTransparency) {
+      nsCOMPtr<nsIImage> img(do_GetInterface(mImageFrame));
+      img->SetHasNoAlpha();
+    }
   }
 
   mGIFStruct.images_decoded++;
 
   // We actually have the timeout information before we get the lzw encoded 
   // image data, at least according to the spec, but we delay in setting the 
   // timeout for the image until here to help ensure that we have the whole 
   // image frame decoded before we go off and try to display another frame.
@@ -433,16 +439,26 @@ PRUint32 nsGIFDecoder2::OutputRow()
   }
 
   /* Protect against too much image data */
   if ((PRUintn)drow_start >= mGIFStruct.height) {
     NS_WARNING("GIF2.cpp::OutputRow - too much image data");
     return 0;
   }
 
+  // check for alpha (only for first frame)
+  if (mGIFStruct.is_transparent && !mSawTransparency) {
+    const PRUint32 *rgb = (PRUint32*)mGIFStruct.rowp; // rowp = mImageData + mGIFStruct.irow * mGIFStruct.width;
+    for (PRUint32 i = mGIFStruct.width; i > 0; i--) {
+      if (*rgb++ == 0) {
+        mSawTransparency = PR_TRUE;
+        break;
+      }
+    }
+  }
   
   // Duplicate rows
   if (drow_end > drow_start) {
     // irow is the current row filled
     const PRUint32 width = mGIFStruct.width; 
     PRUint32 *rgbRowIndex = mImageData + mGIFStruct.irow * width;
     for (int r = drow_start; r <= drow_end; r++) {
       if (r != mGIFStruct.irow) {
