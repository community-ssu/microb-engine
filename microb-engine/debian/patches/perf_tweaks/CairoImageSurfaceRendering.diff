# Experimental patch for Rendering layout through CairoImage surface instead XlibSurface
Index: mozilla/widget/src/gtk2/nsWindow.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsWindow.cpp
+++ mozilla/widget/src/gtk2/nsWindow.cpp
@@ -71,22 +71,22 @@
 #include "gtk2xtbin.h"
 
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 #include "nsIServiceManager.h"
 #include "nsIStringBundle.h"
 #include "nsGfxCIID.h"
 
+#include "prenv.h"
 #ifdef ACCESSIBILITY
 #include "nsIAccessibleRole.h"
 #include "nsPIAccessNode.h"
 #include "nsPIAccessible.h"
 #include "nsIAccessibleEvent.h"
-#include "prenv.h"
 #include "stdlib.h"
 static PRBool sAccessibilityChecked = PR_FALSE;
 /* static */
 PRBool nsWindow::sAccessibilityEnabled = PR_FALSE;
 static const char sSysPrefService [] = "@mozilla.org/system-preference-service;1";
 static const char sAccEnv [] = "GNOME_ACCESSIBILITY";
 static const char sAccessibilityKey [] = "config.use_system_prefs.accessibility";
 #endif
@@ -111,16 +111,17 @@
 #include "gfxXlibSurface.h"
 #include "gfxContext.h"
 #include "gfxImageSurface.h"
 
 #ifdef MOZ_ENABLE_GLITZ
 #include "gfxGlitzSurface.h"
 #include "glitz-glx.h"
 #endif
+static PRBool            gImageSurface         = PR_FALSE;
 
 /* For PrepareNativeWidget */
 static NS_DEFINE_IID(kDeviceContextCID, NS_DEVICE_CONTEXT_CID);
 
 /* utility functions */
 static PRBool     check_for_rollup(GdkWindow *aWindow,
                                    gdouble aMouseX, gdouble aMouseY,
                                    PRBool aIsWheel);
@@ -1826,16 +1827,30 @@
             g_object_unref(G_OBJECT(bufferPixmap));
         }
 
         ctx->Restore();
     }
 
     g_free(rects);
 
+    if (gImageSurface) {
+      GdkDrawable* d = GDK_DRAWABLE(mDrawingarea->inner_window);
+      gint width, height;
+      gdk_drawable_get_size(d, &width, &height);
+      gfxASurface *surface = new gfxXlibSurface
+            (GDK_WINDOW_XDISPLAY(d),
+             GDK_WINDOW_XWINDOW(d),
+             GDK_VISUAL_XVISUAL(gdk_drawable_get_visual(d)),
+             gfxIntSize(width, height));
+      nsRefPtr<gfxContext> ctx = new gfxContext(surface);
+      ctx->SetSource(GetThebesSurface());
+      ctx->Paint();
+    }
+
     // check the return value!
     return TRUE;
 }
 
 gboolean
 nsWindow::OnConfigureEvent(GtkWidget *aWidget, GdkEventConfigure *aEvent)
 {
     LOG(("configure event [%p] %d %d %d %d\n", (void *)this,
@@ -5013,16 +5028,23 @@
         return NS_OK;
 
     PRBool val = PR_TRUE;
     nsresult rv;
     rv = prefs->GetBoolPref("mozilla.widget.raise-on-setfocus", &val);
     if (NS_SUCCEEDED(rv))
         gRaiseWindows = val;
 
+    val = PR_FALSE;
+    rv = prefs->GetBoolPref("mozilla.widget.use_image_surface", &val);
+    if (NS_SUCCEEDED(rv))
+        gImageSurface = val;
+    if (PR_GetEnv("MOZ_USE_IMAGE_SURFACE"))
+        gImageSurface = PR_TRUE;
+
     return NS_OK;
 }
 
 void
 nsWindow::ResetDragMotionTimer(GtkWidget *aWidget,
                                GdkDragContext *aDragContext,
                                gint aX, gint aY, guint aTime)
 {
Index: mozilla/gfx/cairo/cairo/src/cairo-xlib-surface.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-xlib-surface.c
+++ mozilla/gfx/cairo/cairo/src/cairo-xlib-surface.c
@@ -98,23 +98,23 @@
 #define CAIRO_SURFACE_RENDER_HAS_COMPOSITE_TEXT(surface)	CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 0)
 
 #define CAIRO_SURFACE_RENDER_HAS_FILL_RECTANGLE(surface)		CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 1)
 #define CAIRO_SURFACE_RENDER_HAS_FILL_RECTANGLES(surface)		CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 1)
 
 #define CAIRO_SURFACE_RENDER_HAS_DISJOINT(surface)			CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 2)
 #define CAIRO_SURFACE_RENDER_HAS_CONJOINT(surface)			CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 2)
 
-#define CAIRO_SURFACE_RENDER_HAS_TRAPEZOIDS(surface)		CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 4)
-#define CAIRO_SURFACE_RENDER_HAS_TRIANGLES(surface)		CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 4)
+#define CAIRO_SURFACE_RENDER_HAS_TRAPEZOIDS(surface)		CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 0)
+#define CAIRO_SURFACE_RENDER_HAS_TRIANGLES(surface)		CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 0)
 #define CAIRO_SURFACE_RENDER_HAS_TRISTRIP(surface)			CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 4)
 #define CAIRO_SURFACE_RENDER_HAS_TRIFAN(surface)			CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 4)
 
 #define CAIRO_SURFACE_RENDER_HAS_PICTURE_TRANSFORM(surface)	CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 6)
-#define CAIRO_SURFACE_RENDER_HAS_FILTERS(surface)	CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 6)
+#define CAIRO_SURFACE_RENDER_HAS_FILTERS(surface)	CAIRO_SURFACE_RENDER_AT_LEAST((surface), 0, 0)
 
 static int
 _CAIRO_FORMAT_DEPTH (cairo_format_t format)
 {
     switch (format) {
     case CAIRO_FORMAT_A1:
 	return 1;
     case CAIRO_FORMAT_A8:
@@ -1289,17 +1289,19 @@
 
     _cairo_xlib_display_notify (dst->screen_info->display);
 
     if (!CAIRO_SURFACE_RENDER_HAS_COMPOSITE (dst))
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     operation = _categorize_composite_operation (dst, op, src_pattern,
 						 mask_pattern != NULL);
-    if (operation == DO_UNSUPPORTED)
+    if (operation == DO_UNSUPPORTED
+    //|| operation == DO_RENDER
+    )
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     status = _cairo_pattern_acquire_surfaces (src_pattern, mask_pattern,
 					      &dst->base,
 					      src_x, src_y,
 					      mask_x, mask_y,
 					      width, height,
 					      (cairo_surface_t **) &src,
@@ -2012,24 +2014,25 @@
     surface->drawable = drawable;
     surface->screen = screen;
     surface->owns_pixmap = FALSE;
     surface->use_pixmap = 0;
     surface->width = width;
     surface->height = height;
 
     surface->buggy_repeat = screen_info->display->buggy_repeat;
+    surface->buggy_repeat = TRUE;
 
     surface->dst_picture = None;
     surface->src_picture = None;
 
     surface->visual = visual;
     surface->xrender_format = xrender_format;
     surface->depth = depth;
-    surface->filter = CAIRO_FILTER_NEAREST;
+    surface->filter = CAIRO_FILTER_FAST;
     surface->repeat = FALSE;
     surface->xtransform = identity;
 
     surface->have_clip_rects = FALSE;
     surface->clip_rects = surface->embedded_clip_rects;
     surface->num_clip_rects = 0;
 
     return (cairo_surface_t *) surface;
Index: mozilla/gfx/thebes/src/gfxPlatformGtk.cpp
===================================================================
--- mozilla.orig/gfx/thebes/src/gfxPlatformGtk.cpp
+++ mozilla/gfx/thebes/src/gfxPlatformGtk.cpp
@@ -139,18 +139,18 @@
     // in more context, including the display and/or target surface type that
     // we should try to match
     Display* display = GDK_DISPLAY();
     if (!display)
         return nsnull;
 
     if (!UseGlitz()) {
         GdkPixmap* pixmap = nsnull;
-        XRenderPictFormat* xrenderFormat =
-            XRenderFindStandardFormat(display, xrenderFormatID);
+        XRenderPictFormat* xrenderFormat = nsnull;
+        xrenderFormat = XRenderFindStandardFormat(display, xrenderFormatID);
 
         if (!xrenderFormat) {
             // We don't have Render; see if we can just create a pixmap
             // of the requested depth.
             GdkVisual* vis;
 
             if (imageFormat == gfxASurface::ImageFormatRGB24) {
                 vis = gdk_rgb_get_visual();
