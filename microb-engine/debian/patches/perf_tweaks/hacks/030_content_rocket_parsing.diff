# This will allow to increase mMaxTokenProcessingTime for fast first painting and good performance
# 495_layout_state_listener.trunk.diff also there
Index: mozilla/content/base/src/nsContentSink.h
===================================================================
--- mozilla.orig/content/base/src/nsContentSink.h
+++ mozilla/content/base/src/nsContentSink.h
@@ -350,16 +350,18 @@ protected:
   // If true, we did get a ReadyToCallDidBuildModel call
   PRUint8 mDidGetReadyToCallDidBuildModelCall : 1;
   
   // -- Can interrupt parsing members --
   PRUint32 mDelayTimerStart;
 
   // Interrupt parsing during token procesing after # of microseconds
   PRInt32 mMaxTokenProcessingTime;
+  PRInt32 mMaxTokenProcessingPerfTime;
+  PRInt32 mCountInterruptsBeforePerfMode;
 
   // Switch between intervals when time is exceeded
   PRInt32 mDynamicIntervalSwitchThreshold;
 
   PRInt32 mMaxTokensDeflectedInLowFreqMode;
 
   PRInt32 mBeginLoadTime;
 
Index: mozilla/content/base/src/nsContentSink.cpp
===================================================================
--- mozilla.orig/content/base/src/nsContentSink.cpp
+++ mozilla/content/base/src/nsContentSink.cpp
@@ -286,16 +286,24 @@ nsContentSink::Init(nsIDocument* aDoc,
   // The current ratio of 3 to 1 was determined to be the lowest
   // mMaxTokenProcessingTime which does not impact page load
   // performance.  See bugzilla bug 76722 for details.
 
   mMaxTokenProcessingTime =
     nsContentUtils::GetIntPref("content.max.tokenizing.time",
                                mNotificationInterval * 3);
 
+  mMaxTokenProcessingPerfTime =
+    nsContentUtils::GetIntPref("content.max.perf.tokenizing.time",
+                               mMaxTokenProcessingTime * 15);
+
+  mCountInterruptsBeforePerfMode =
+    nsContentUtils::GetIntPref("content.perf.interrupts.count",
+                               3);
+
   // 3/4 second (750000us) default for switching
   mDynamicIntervalSwitchThreshold =
     nsContentUtils::GetIntPref("content.switch.threshold", 750000);
 
   mCanInterruptParser =
     nsContentUtils::GetBoolPref("content.interrupt.parsing", PR_TRUE);
 
   // 200 determined empirically to provide good user response without
@@ -1618,16 +1626,22 @@ nsContentSink::DidProcessATokenImpl()
       mDynamicLowerValue = PR_FALSE;
       // Reset the hint that to favoring performance for PLEvent dispatch.
       FavorPerformanceHint(PR_TRUE, 0);
     }
   }
 
   if ((currentTime - mDelayTimerStart) >
       static_cast<PRUint32>(GetMaxTokenProcessingTime())) {
+    if (mCountInterruptsBeforePerfMode >= 0) {
+      if (mCountInterruptsBeforePerfMode == 0)
+        mMaxTokenProcessingTime = mMaxTokenProcessingPerfTime;
+      else
+        mCountInterruptsBeforePerfMode--;
+    }
     return NS_ERROR_HTMLPARSER_INTERRUPTED;
   }
 
   return NS_OK;
 }
 
 //----------------------------------------------------------------------
 
