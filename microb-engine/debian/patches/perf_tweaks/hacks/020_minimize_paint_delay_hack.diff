# Immediate painting (User perception hacks)
Index: mozilla/layout/base/nsPresShell.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresShell.cpp
+++ mozilla/layout/base/nsPresShell.cpp
@@ -422,16 +422,23 @@
 // microseconds.  When this bound is exceeded and reflow commands are
 // still queued up, a reflow event is posted.  The idea is for reflow
 // to not hog the processor beyond the time specifed in
 // gMaxRCProcessingTime.  This data member is initialized from the
 // layout.reflow.timeslice pref.
 #define NS_MAX_REFLOW_TIME    1000000
 static PRInt32 gMaxRCProcessingTime = -1;
 
+#define PAINTLOCK_EVENT_DELAY 250 // 250ms.  This is actually
+                                  // pref-controlled, but we use this
+                                  // value if we fail to get the pref
+                                  // for any reason.
+
+static PRInt32 gPaintDelay = PAINTLOCK_EVENT_DELAY;
+
 // Largest chunk size we recycle
 static const size_t gMaxRecycledSize = 400;
 
 #define MARK_INCREMENT 50
 #define BLOCK_INCREMENT 4044 /* a bit under 4096, for malloc overhead */
 
 /**A block of memory that the stack will 
  * chop up and hand out
@@ -1163,21 +1170,16 @@
   PRPackedBool      mPaintingSuppressed;  // For all documents we initially lock down painting.
                                           // We will refuse to paint the document until either
                                           // (a) our timer fires or (b) all frames are constructed.
   PRPackedBool      mShouldUnsuppressPainting;  // Indicates that it is safe to unlock painting once all pending
                                                 // reflows have been processed.
   nsCOMPtr<nsITimer> mPaintSuppressionTimer; // This timer controls painting suppression.  Until it fires
                                              // or all frames are constructed, we won't paint anything but
                                              // our <body> background and scrollbars.
-#define PAINTLOCK_EVENT_DELAY 250 // 250ms.  This is actually
-                                  // pref-controlled, but we use this
-                                  // value if we fail to get the pref
-                                  // for any reason.
-
   static void sPaintSuppressionCallback(nsITimer* aTimer, void* aPresShell); // A callback for the timer.
 
   MOZ_TIMER_DECLARE(mReflowWatch)  // Used for measuring time spent in reflow
   MOZ_TIMER_DECLARE(mFrameCreationWatch)  // Used for measuring time spent in frame creation 
 
 #ifdef MOZ_REFLOW_PERF
   ReflowCountMgr * mReflowCountMgr;
 #endif
@@ -2493,23 +2495,25 @@
     mPaintSuppressionTimer = do_CreateInstance("@mozilla.org/timer;1");
     if (!mPaintSuppressionTimer)
       // Uh-oh.  We must be out of memory.  No point in keeping painting locked down.
       mPaintingSuppressed = PR_FALSE;
     else {
       // Initialize the timer.
 
       // Default to PAINTLOCK_EVENT_DELAY if we can't get the pref value.
-      PRInt32 delay =
+      gPaintDelay =
         nsContentUtils::GetIntPref("nglayout.initialpaint.delay",
                                    PAINTLOCK_EVENT_DELAY);
-
-      mPaintSuppressionTimer->InitWithFuncCallback(sPaintSuppressionCallback,
-                                                   this, delay, 
-                                                   nsITimer::TYPE_ONE_SHOT);
+      if (gPaintDelay == -1 || gPaintDelay == -3)
+        UnsuppressPainting();
+      else
+        mPaintSuppressionTimer->InitWithFuncCallback(sPaintSuppressionCallback,
+                                                     this, gPaintDelay < 0 ? 0 : gPaintDelay,
+                                                     nsITimer::TYPE_ONE_SHOT);
     }
   }
 
   return NS_OK; //XXX this needs to be real. MMP
 }
 
 void
 PresShell::sPaintSuppressionCallback(nsITimer *aTimer, void* aPresShell)
