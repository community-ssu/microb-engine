RCS file: /cvsroot/mozilla configure.in,v
retrieving revision 1.1882
retrieving revision 1.1883
Index: mozilla/config/system-headers
===================================================================
--- mozilla.orig/config/system-headers
+++ mozilla/config/system-headers
@@ -211,17 +211,16 @@
 FSp_fopen.h
 fstream.h
 ft2build.h
 gconf/gconf-client.h
 Gdiplus.h
 gdk/gdkevents.h
 gdk/gdk.h
 gdk/gdkkeysyms.h
-gdk/gdkpango.h
 gdk/gdkprivate.h
 gdk/gdkregion.h
 gdk/gdkwindow.h
 gdk/gdkx.h
 gdk-pixbuf/gdk-pixbuf.h
 Gestalt.h
 getopt.h
 glibconfig.h
@@ -507,26 +506,24 @@
 osreldate.h
 OSUtils.h
 Packages.h
 Palettes.h
 PALM_CMN.H
 pango-engine.h
 pango-glyph.h
 pango-modules.h
-pango/pangocairo.h
 pango/pangofc-decoder.h
 pango/pangofc-font.h
 pango/pangofc-fontmap.h
 pango/pango-break.h
 pango/pango-fontmap.h
 pango/pango.h
 pango/pangoxft.h
 pango/pangox.h
-pango/pango-utils.h
 pango-types.h
 pascal.h
 Patches.h
 Path.h
 pcfs/pc_dir.h
 Pgenerr.h
 PGenErr.h
 Ph.h
Index: mozilla/gfx/thebes/public/gfxPangoFonts.h
===================================================================
--- mozilla.orig/gfx/thebes/public/gfxPangoFonts.h
+++ mozilla/gfx/thebes/public/gfxPangoFonts.h
@@ -108,17 +108,17 @@
 class THEBES_API gfxPangoFontGroup : public gfxFontGroup {
 public:
     gfxPangoFontGroup (const nsAString& families,
                        const gfxFontStyle *aStyle);
     virtual ~gfxPangoFontGroup ();
 
     virtual gfxFontGroup *Copy(const gfxFontStyle *aStyle);
 
-    // Create and initialize a textrun using Pango
+    // Create and initialize a textrun using Pango (or Xft)
     virtual gfxTextRun *MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
                                     const Parameters *aParams, PRUint32 aFlags);
     virtual gfxTextRun *MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
                                     const Parameters *aParams, PRUint32 aFlags);
 
     gfxPangoFont *GetFontAt(PRInt32 i) {
         return static_cast<gfxPangoFont*>(static_cast<gfxFont*>(mFonts[i]));
     }
@@ -193,9 +193,35 @@
 
     void Put(const PangoFontDescription *aFontDesc, PangoFont *aPangoFont);
     PangoFont* Get(const PangoFontDescription *aFontDesc);
 private:
     static gfxPangoFontCache *sPangoFontCache;
     nsClassHashtable<nsUint32HashKey,  gfxPangoFontWrapper> mPangoFonts;
 };
 
+// XXX we should remove this class, because this class is used only in |HasGlyph| of gfxPangoFont.
+// But it can use fontconfig directly after bug 366664.
+class gfxPangoFontNameMap
+{
+public:
+    gfxPangoFontNameMap();
+    ~gfxPangoFontNameMap();
+
+    static gfxPangoFontNameMap* GetPangoFontNameMap() {
+        if (!sPangoFontNameMap)
+            sPangoFontNameMap = new gfxPangoFontNameMap();
+        return sPangoFontNameMap;
+    }
+    static void Shutdown() {
+        if (sPangoFontNameMap)
+            delete sPangoFontNameMap;
+        sPangoFontNameMap = nsnull;
+    }
+
+    void Put(const nsACString &aName, PangoFont *aPangoFont);
+    PangoFont* Get(const nsACString &aName);
+
+private:
+    static gfxPangoFontNameMap *sPangoFontNameMap;
+    nsClassHashtable<nsCStringHashKey, gfxPangoFontWrapper> mPangoFonts;
+};
 #endif /* GFX_PANGOFONTS_H */
Index: mozilla/gfx/thebes/public/gfxPlatformGtk.h
===================================================================
--- mozilla.orig/gfx/thebes/public/gfxPlatformGtk.h
+++ mozilla/gfx/thebes/public/gfxPlatformGtk.h
@@ -69,17 +69,17 @@
 
     gfxFontGroup *CreateFontGroup(const nsAString &aFamilies,
                                   const gfxFontStyle *aStyle);
 
     static PRInt32 DPI() {
         if (sDPI == -1) {
             InitDPI();
         }
-        NS_ASSERTION(sDPI > 0, "Something is wrong");
+        NS_ASSERTION(sDPI != 0, "Something is wrong");
         return sDPI;
     }
 
 protected:
     static void InitDPI();
 
     static PRInt32 sDPI;
     static gfxFontconfigUtils *sFontconfigUtils;
Index: mozilla/gfx/thebes/src/gfxPlatformGtk.cpp
===================================================================
--- mozilla.orig/gfx/thebes/src/gfxPlatformGtk.cpp
+++ mozilla/gfx/thebes/src/gfxPlatformGtk.cpp
@@ -57,16 +57,22 @@
 
 #ifdef MOZ_ENABLE_GLITZ
 #include "gfxGlitzSurface.h"
 #include "glitz-glx.h"
 #endif
 
 #include <fontconfig/fontconfig.h>
 
+#ifndef THEBES_USE_PANGO_CAIRO
+#include <pango/pangoxft.h>
+#endif // THEBES_USE_PANGO_CAIRO
+
+#include <pango/pango-font.h>
+
 #ifndef MOZ_NO_LCMS
 #include "nsMathUtils.h"
 
 #include "lcms.h"
 #endif
 
 PRInt32 gfxPlatformGtk::sDPI = -1;
 gfxFontconfigUtils *gfxPlatformGtk::sFontconfigUtils = nsnull;
@@ -81,27 +87,29 @@
 gfxPlatformGtk::gfxPlatformGtk()
 {
 #ifdef MOZ_ENABLE_GLITZ
     if (UseGlitz())
         glitz_glx_init(NULL);
 #endif
     if (!sFontconfigUtils)
         sFontconfigUtils = gfxFontconfigUtils::GetFontconfigUtils();
-
-    InitDPI();
 }
 
 gfxPlatformGtk::~gfxPlatformGtk()
 {
     gfxFontconfigUtils::Shutdown();
     sFontconfigUtils = nsnull;
 
     gfxPangoFont::Shutdown();
 
+#ifndef THEBES_USE_PANGO_CAIRO
+    pango_xft_shutdown_display(GDK_DISPLAY(), 0);
+#endif
+
 #if 0
     // It would be nice to do this (although it might need to be after
     // the cairo shutdown that happens in ~gfxPlatform).  It even looks
     // idempotent.  But it has fatal assertions that fire if stuff is
     // leaked, and we hit them.
     FcFini();
 #endif
 }
@@ -257,27 +265,103 @@
 
 gfxFontGroup *
 gfxPlatformGtk::CreateFontGroup(const nsAString &aFamilies,
                                 const gfxFontStyle *aStyle)
 {
     return new gfxPangoFontGroup(aFamilies, aStyle);
 }
 
+static PRInt32
+GetXftDPI()
+{
+  char *val = XGetDefault(GDK_DISPLAY(), "Xft", "dpi");
+  if (val) {
+    char *e;
+    double d = strtod(val, &e);
+
+    if (e != val)
+      return NS_lround(d);
+  }
+
+  return -1;
+}
+
+static PRInt32
+GetDPIFromPangoFont()
+{
+#ifndef THEBES_USE_PANGO_CAIRO
+    PangoContext* ctx = pango_xft_get_context(GDK_DISPLAY(), 0);
+    gdk_pango_context_set_colormap(ctx, gdk_rgb_get_cmap());
+#else
+    PangoContext* ctx =
+        pango_cairo_font_map_create_context(
+          PANGO_CAIRO_FONT_MAP(pango_cairo_font_map_get_default()));
+#endif
+
+    if (!ctx) {
+        return 0;
+    }
+
+    double dblDPI = 0.0f;
+    GList *items = nsnull;
+    PangoItem *item = nsnull;
+    PangoFcFont *fcfont = nsnull;
+
+    PangoAttrList *al = pango_attr_list_new();
+
+    if (!al) {
+        goto cleanup;
+    }
+
+    // Just using the string "a" because we need _some_ text.
+    items = pango_itemize(ctx, "a", 0, 1, al, NULL);
+
+    if (!items) {
+        goto cleanup;
+    }
+
+    item = (PangoItem*)items->data;
+
+    if (!item) {
+        goto cleanup;
+    }
+
+    fcfont = PANGO_FC_FONT(item->analysis.font);
+
+    if (!fcfont) {
+        goto cleanup;
+    }
+
+    FcPatternGetDouble(fcfont->font_pattern, FC_DPI, 0, &dblDPI);
+
+ cleanup:
+    if (al)
+        pango_attr_list_unref(al);
+    if (item)
+        pango_item_free(item);
+    if (items)
+        g_list_free(items);
+    if (ctx)
+        g_object_unref(ctx);
+
+    return NS_lround(dblDPI);
+}
+
 /* static */
 void
 gfxPlatformGtk::InitDPI()
 {
-    PangoContext *context = gdk_pango_context_get ();
-    sDPI = pango_cairo_context_get_resolution (context);
-    g_object_unref (context);
-
+    sDPI = GetXftDPI();
     if (sDPI <= 0) {
-	// Fall back to something sane
-	sDPI = 96;
+        sDPI = GetDPIFromPangoFont();
+        if (sDPI <= 0) {
+            // Fall back to something sane
+            sDPI = 96;
+        }
     }
 }
 
 #ifndef MOZ_NO_LCMS
 cmsHPROFILE
 gfxPlatformGtk::GetPlatformCMSOutputProfile()
 {
     const char EDID1_ATOM_NAME[] = "XFree86_DDC_EDID1_RAWDATA";
Index: mozilla/gfx/thebes/src/gfxPangoFonts.cpp
===================================================================
--- mozilla.orig/gfx/thebes/src/gfxPangoFonts.cpp
+++ mozilla/gfx/thebes/src/gfxPangoFonts.cpp
@@ -37,16 +37,21 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
+#ifdef XP_BEOS
+#define THEBES_USE_PANGO_CAIRO
+#endif
+
+#define PANGO_ENABLE_ENGINE
 #define PANGO_ENABLE_BACKEND
 
 #include "prtypes.h"
 #include "prlink.h"
 #include "gfxTypes.h"
 
 #include "nsUnicodeRange.h"
 
@@ -776,17 +781,17 @@
     run->RecordSurrogates(aString);
 
     nsCAutoString utf8;
     PRInt32 headerLen = AppendDirectionalIndicatorUTF8(run->IsRightToLeft(), utf8);
     AppendUTF16toUTF8(Substring(aString, aString + aLength), utf8);
     PRBool is8Bit = PR_FALSE;
 
 #if !defined(ENABLE_FAST_PATH_ALWAYS)
-#if defined(ENABLE_FAST_PATH_8BIT)
+#if defined(ENABLE_XFT_FAST_PATH_8BIT)
     if (CanTakeFastPath(aFlags)) {
         PRUint32 allBits = 0;
         PRUint32 i;
         for (i = 0; i < aLength; ++i) {
             allBits |= aString[i];
         }
         is8Bit = (allBits & 0xFF00) == 0;
     }
@@ -848,17 +853,16 @@
     cairo_get_font_options(aCR, fontOptions);
     cairo_scaled_font_t *scaledFont =
         cairo_scaled_font_create(face, &fontMatrix, aCTM, fontOptions);
     cairo_font_options_destroy(fontOptions);
     cairo_font_face_destroy(face);
     NS_ASSERTION(cairo_scaled_font_status(scaledFont) == CAIRO_STATUS_SUCCESS,
                  "Failed to create scaled font");
     return scaledFont;
-#endif
 }
 
 PRBool
 gfxPangoFont::SetupCairoFont(gfxContext *aContext)
 {
     cairo_t *cr = aContext->GetCairo();
     cairo_matrix_t currentCTM;
     cairo_get_matrix(cr, &currentCTM);
@@ -888,18 +892,16 @@
 
 static void
 SetupClusterBoundaries(gfxTextRun* aTextRun, const gchar *aUTF8, PRUint32 aUTF8Length,
                        PRUint32 aUTF16Offset, PangoAnalysis *aAnalysis)
 {
     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) {
         // 8-bit text doesn't have clusters.
         // XXX is this true in all languages???
-        // behdad: don't think so.  Czech for example IIRC has a
-        // 'ch' grapheme.
         return;
     }
 
     // Pango says "the array of PangoLogAttr passed in must have at least N+1
     // elements, if there are N characters in the text being broken".
     // Could use g_utf8_strlen(aUTF8, aUTF8Length) + 1 but the memory savings
     // may not be worth the call.
     nsAutoTArray<PangoLogAttr,2000> buffer;
@@ -1158,25 +1160,25 @@
         // We produced this UTF8 so we don't need to worry about malformed stuff
         index = g_utf8_next_char(aUTF8 + index) - aUTF8;
     }
 
     *aUTF16Offset = utf16Offset;
     return NS_OK;
 }
 
-#if defined(ENABLE_FAST_PATH_8BIT) || defined(ENABLE_FAST_PATH_ALWAYS)
+#if defined(ENABLE_XFT_FAST_PATH_8BIT) || defined(ENABLE_XFT_FAST_PATH_ALWAYS)
 nsresult
-gfxPangoFontGroup::CreateGlyphRunsFast(gfxTextRun *aTextRun,
-                                       const gchar *aUTF8, PRUint32 aUTF8Length)
+gfxPangoFontGroup::CreateGlyphRunsXft(gfxTextRun *aTextRun,
+                                      const gchar *aUTF8, PRUint32 aUTF8Length)
 {
     const gchar *p = aUTF8;
     gfxPangoFont *font = GetFontAt(0);
-    PangoFont *pangofont = font->GetPangoFont();
-    PangoFcFont *fcfont = PANGO_FC_FONT (pangofont);
+    Display *dpy = GDK_DISPLAY();
+    XftFont *xfont = font->GetXftFont();
     PRUint32 utf16Offset = 0;
     gfxTextRun::CompressedGlyph g;
     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
 
     aTextRun->AddGlyphRun(font, 0);
 
     while (p < aUTF8 + aUTF8Length) {
         // glib-2.12.9: "If p does not point to a valid UTF-8 encoded
@@ -1187,24 +1189,26 @@
         p = g_utf8_next_char(p);
         
         if (ch == 0) {
             // treat this null byte as a missing glyph. Pango
             // doesn't create glyphs for these, not even missing-glyphs.
             aTextRun->SetMissingGlyph(utf16Offset, 0);
         } else {
             NS_ASSERTION(!IsInvalidChar(ch), "Invalid char detected");
-            FT_UInt glyph = pango_fc_font_get_glyph (fcfont, ch);
+            FT_UInt glyph = XftCharIndex(dpy, xfont, ch);
             if (!glyph)                  // character not in font,
                 return NS_ERROR_FAILURE; // fallback to CreateGlyphRunsItemizing
+            XGlyphInfo info;
+            XftGlyphExtents(dpy, xfont, &glyph, 1, &info);
+            if (info.yOff > 0) {
+                NS_WARNING("vertical offsets not supported");
+            }
 
-            PangoRectangle rect;
-            pango_font_get_glyph_extents (pangofont, glyph, NULL, &rect);
-
-            PRInt32 advance = PANGO_PIXELS (rect.width * appUnitsPerDevUnit);
+            PRInt32 advance = info.xOff*appUnitsPerDevUnit;
             if (advance >= 0 &&
                 gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
                 gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
                 aTextRun->SetSimpleGlyph(utf16Offset,
                                          g.SetSimpleGlyph(advance, glyph));
             } else {
                 gfxTextRun::DetailedGlyph details;
                 details.mGlyphID = glyph;
@@ -1225,16 +1229,17 @@
         }
 
         ++utf16Offset;
     }
     return NS_OK;
 }
 #endif
 
+#ifdef NEW_ITEMIZING
 void 
 gfxPangoFontGroup::CreateGlyphRunsItemizing(gfxTextRun *aTextRun,
                                             const gchar *aUTF8, PRUint32 aUTF8Length,
                                             PRUint32 aUTF8HeaderLen)
 {
 
     PangoContext *context = gdk_pango_context_get();
 
@@ -1395,17 +1400,17 @@
     //
     // we're casting away the const here for the strings - should be
     // safe.
     if (!langGroup)
         return pango_language_from_string(nsPromiseFlatCString(cname).get());
     else if (langGroup->PangoLang) 
         return pango_language_from_string(langGroup->PangoLang);
 
-    return nsnull;
+    return pango_language_from_string("en");
 }
 
 // See pango-script-lang-table.h in pango.
 static const MozPangoLangGroup PangoAllLangGroup[] = {
     { "x-western",      "aa"    },
     { "x-cyrillic",     "ab"    },
     { "x-western",      "af"    },
     { "x-ethi",         "am"    },
@@ -1579,17 +1584,48 @@
     { "zh-CN",          "zh-cn" },
     { "zh-HK",          "zh-hk" },
     { "zh-HK",          "zh-mo" },
     { "zh-CN",          "zh-sg" },
     { "zh-TW",          "zh-tw" },
     { "x-western",      "zu"    },
 };
 
-#define NUM_PANGO_ALL_LANG_GROUPS (G_N_ELEMENTS (PangoAllLangGroup))
+#define NUM_PANGO_ALL_LANG_GROUPS (sizeof (PangoAllLangGroup) / \
+                                   sizeof (PangoAllLangGroup[0]))
+
+/* static */
+void
+GetMozLanguage(const PangoLanguage *aLang, nsACString &aMozLang)
+{
+    aMozLang.Truncate();
+    if (!aLang)
+        return;
+
+    nsCAutoString lang(pango_language_to_string(aLang));
+    if (lang.IsEmpty() || lang.Equals("xx"))
+        return;
+
+    while (1) {
+        for (PRUint32 i = 0; i < NUM_PANGO_ALL_LANG_GROUPS; ++i) {
+            if (lang.Equals(PangoAllLangGroup[i].PangoLang)) {
+                if (PangoAllLangGroup[i].mozLangGroup)
+                    aMozLang.Assign(PangoAllLangGroup[i].mozLangGroup);
+                return;
+            }
+        }
+
+        PRInt32 hyphen = lang.FindChar('-');
+        if (hyphen != kNotFound) {
+            lang.Cut(hyphen, lang.Length());
+            continue;
+        }
+        break;
+    }
+}
 
 gfxPangoFontCache::gfxPangoFontCache()
 {
     mPangoFonts.Init(500);
 }
 
 gfxPangoFontCache::~gfxPangoFontCache()
 {
@@ -1613,8 +1649,44 @@
     PRUint32 key = pango_font_description_hash(aFontDesc);
     gfxPangoFontWrapper *value;
     if (!mPangoFonts.Get(key, &value))
         return nsnull;
     PangoFont *font = value->Get();
     g_object_ref(font);
     return font;
 }
+
+gfxPangoFontNameMap::gfxPangoFontNameMap()
+{
+    mPangoFonts.Init(100);
+}
+
+gfxPangoFontNameMap::~gfxPangoFontNameMap()
+{
+}
+
+void
+gfxPangoFontNameMap::Put(const nsACString &aName, PangoFont *aPangoFont)
+{
+    nsCAutoString key(aName);
+    ToLowerCase(key);
+    gfxPangoFontWrapper *value;
+    if (!mPangoFonts.Get(key, &value)) {
+        value = new gfxPangoFontWrapper(aPangoFont);
+        if (!value)
+            return;
+        mPangoFonts.Put(key, value);
+    }
+}
+
+PangoFont*
+gfxPangoFontNameMap::Get(const nsACString &aName)
+{
+    nsCAutoString key(aName);
+    ToLowerCase(key);
+    gfxPangoFontWrapper *value;
+    if (!mPangoFonts.Get(key, &value))
+        return nsnull;
+    PangoFont *font = value->Get();
+    g_object_ref(font);
+    return font;
+}
