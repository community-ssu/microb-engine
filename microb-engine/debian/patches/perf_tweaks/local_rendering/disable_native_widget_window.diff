###microb-engine
Index: mozilla/widget/src/gtk2/mozdrawingarea.c
===================================================================
--- mozilla.orig/widget/src/gtk2/mozdrawingarea.c
+++ mozilla/widget/src/gtk2/mozdrawingarea.c
@@ -141,16 +141,18 @@ moz_drawingarea_create_windows (MozDrawi
     attributes.window_type = GDK_WINDOW_CHILD;
     if (!visual) {
         attributes.visual = gtk_widget_get_visual (widget);
         attributes.colormap = gtk_widget_get_colormap (widget);
     } else {
         attributes.visual = visual;
         attributes.colormap = gdk_colormap_new(visual, 0);
     }
+    if (widget && !GTK_WIDGET_REALIZED(widget))
+      return;
 
     attributes_mask |= GDK_WA_VISUAL | GDK_WA_COLORMAP |
         GDK_WA_X | GDK_WA_Y;
 
     drawingarea->clip_window = gdk_window_new (parent, &attributes,
                                                attributes_mask);
     gdk_window_set_user_data(drawingarea->clip_window, widget);
 
@@ -202,32 +204,35 @@ moz_drawingarea_move (MozDrawingarea *dr
 {
     gdk_window_move(drawingarea->clip_window, x, y);
 }
 
 void
 moz_drawingarea_resize (MozDrawingarea *drawingarea,
                         gint width, gint height)
 {
+    if (!drawingarea) return;
     gdk_window_resize(drawingarea->clip_window, width, height);
     gdk_window_resize(drawingarea->inner_window, width, height);
 }
 
 void
 moz_drawingarea_move_resize (MozDrawingarea *drawingarea,
                              gint x, gint y, gint width, gint height)
 {
+    if (!drawingarea) return;
     gdk_window_resize(drawingarea->inner_window, width, height);
     gdk_window_move_resize(drawingarea->clip_window, x, y, width, height);
 }
 
 void
 moz_drawingarea_set_visibility (MozDrawingarea *drawingarea,
                                 gboolean visibility)
 {
+    if (!drawingarea) return;
     if (visibility) {
         gdk_window_show_unraised(drawingarea->inner_window);
         gdk_window_show_unraised(drawingarea->clip_window);
     }
     else    {
         gdk_window_hide(drawingarea->clip_window);
         gdk_window_hide(drawingarea->inner_window);
     }
Index: mozilla/widget/src/gtk2/nsWindow.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsWindow.cpp
+++ mozilla/widget/src/gtk2/nsWindow.cpp
@@ -351,16 +351,18 @@ typedef void (*_gdk_window_set_urgency_h
 static GdkCursor *gCursorCache[eCursorCount];
 
 // Global update pixmap
 static PRBool gUseBufferPixmap = PR_FALSE;
 static GdkPixmap *gBufferPixmap = nsnull;
 static gfxIntSize gBufferPixmapSize(0,0);
 static gfxIntSize gBufferPixmapMaxSize(0,0);
 static int gBufferPixmapUsageCount = 0;
+static PRBool gBlockWidgetActivity = PR_FALSE;
+static PRBool gBlockWidgetActivity_full = PR_FALSE;
 
 // imported in nsWidgetFactory.cpp
 PRBool gDisableNativeTheme = PR_FALSE;
 
 // If this is 1, then a 24bpp buffer surface is always
 // created for exposes, even if the display has a different depth
 static PRBool gForce24bpp = PR_FALSE;
 
@@ -1369,18 +1371,26 @@ NS_IMETHODIMP
 nsWindow::SetFocus(PRBool aRaise)
 {
     // Make sure that our owning widget has focus.  If it doesn't try to
     // grab it.  Note that we don't set our focus flag in this case.
 
     LOGFOCUS(("  SetFocus [%p]\n", (void *)this));
 
     GtkWidget *owningWidget = GetMozContainerWidget();
-    if (!owningWidget)
+    if (!owningWidget) {
+        if (gBlockWidgetActivity_full) {
+            if (gFocusWindow == this)
+                return NS_OK;
+            gFocusWindow = this;
+            DispatchActivateEvent();
+            return NS_OK;
+        }
         return NS_ERROR_FAILURE;
+    }
 
     // Raise the window if someone passed in PR_TRUE and the prefs are
     // set properly.
     GtkWidget *toplevelWidget = gtk_widget_get_toplevel(owningWidget);
 
     if (gRaiseWindows && aRaise && toplevelWidget &&
         !GTK_WIDGET_HAS_FOCUS(owningWidget) &&
         !GTK_WIDGET_HAS_FOCUS(toplevelWidget)) {
@@ -1693,17 +1703,17 @@ nsWindow::SetCursor(imgIContainer* aCurs
 }
 
 
 NS_IMETHODIMP
 nsWindow::Validate()
 {
     // Get the update for this window and, well, just drop it on the
     // floor.
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     GdkRegion *region = gdk_window_get_update_area(mDrawingarea->inner_window);
 
     if (region)
         gdk_region_destroy(region);
 
     return NS_OK;
@@ -1717,17 +1727,17 @@ nsWindow::Invalidate(PRBool aIsSynchrono
     rect.x = mBounds.x;
     rect.y = mBounds.y;
     rect.width = mBounds.width;
     rect.height = mBounds.height;
 
     LOGDRAW(("Invalidate (all) [%p]: %d %d %d %d\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height));
 
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     gdk_window_invalidate_rect(mDrawingarea->inner_window,
                                &rect, FALSE);
     if (aIsSynchronous)
         gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
 
     return NS_OK;
@@ -1742,31 +1752,31 @@ nsWindow::Invalidate(const nsIntRect &aR
     rect.x = aRect.x;
     rect.y = aRect.y;
     rect.width = aRect.width;
     rect.height = aRect.height;
 
     LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d (sync: %d)\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
 
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     gdk_window_invalidate_rect(mDrawingarea->inner_window,
                                &rect, FALSE);
     if (aIsSynchronous)
         gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::Update()
 {
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::Scroll(PRInt32     aDx,
@@ -2146,17 +2156,17 @@ gboolean
 nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
 {
     if (mIsDestroyed) {
         LOG(("Expose event on destroyed window [%p] window %p\n",
              (void *)this, (void *)aEvent->window));
         return FALSE;
     }
 
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return FALSE;
 
     // handle exposes for the inner window only
     if (aEvent->window != mDrawingarea->inner_window)
         return FALSE;
 
     static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
 
@@ -3936,31 +3946,34 @@ nsWindow::NativeCreate(nsIWidget        
         mContainer = MOZ_CONTAINER(moz_container_new());
         gtk_container_add(GTK_CONTAINER(mShell), GTK_WIDGET(mContainer));
         gtk_widget_realize(GTK_WIDGET(mContainer));
 
         // make sure this is the focus widget in the container
         gtk_window_set_focus(GTK_WINDOW(mShell), GTK_WIDGET(mContainer));
 
         // and the drawing area
-        mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
+        if (!gBlockWidgetActivity_full)
+            mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
 
         if (mWindowType == eWindowType_popup) {
             // gdk does not automatically set the cursor for "temporary"
             // windows, which are what gtk uses for popups.
 
             mCursor = eCursor_wait; // force SetCursor to actually set the
                                     // cursor, even though our internal state
                                     // indicates that we already have the
                                     // standard cursor.
             SetCursor(eCursor_standard);
         }
     }
         break;
     case eWindowType_child: {
+        if (gBlockWidgetActivity_full)
+          break;
         if (parentMozContainer) {
             mDrawingarea = moz_drawingarea_new(parentArea, parentMozContainer, visual);
         }
         else if (parentGtkContainer) {
             mContainer = MOZ_CONTAINER(moz_container_new());
             gtk_container_add(parentGtkContainer, GTK_WIDGET(mContainer));
             gtk_widget_realize(GTK_WIDGET(mContainer));
 
@@ -3982,25 +3995,27 @@ nsWindow::NativeCreate(nsIWidget        
     // double-buffering everywhere
 #ifdef MOZ_X11
     if (mContainer)
         gtk_widget_set_double_buffered (GTK_WIDGET(mContainer),FALSE);
 #endif
 
     // label the drawing area with this object so we can find our way
     // home
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "nsWindow",
-                      this);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "nsWindow",
-                      this);
+    if (mDrawingarea) {
+        g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "nsWindow",
+                          this);
+        g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "nsWindow",
+                          this);
 
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "mozdrawingarea",
-                      mDrawingarea);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "mozdrawingarea",
-                      mDrawingarea);
+        g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "mozdrawingarea",
+                          mDrawingarea);
+        g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "mozdrawingarea",
+                          mDrawingarea);
+    }
 
     if (mContainer)
         g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
 
     if (mShell)
         g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
 
     // attach listeners for events
@@ -4281,17 +4296,18 @@ nsWindow::NativeResize(PRInt32 aX, PRInt
         // We only move the toplevel window if someone has
         // actually placed the window somewhere.  If no placement
         // has taken place, we just let the window manager Do The
         // Right Thing.
         if (mPlaced)
             gtk_window_move(GTK_WINDOW(mShell), aX, aY);
 
         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
-        moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
+        if (mDrawingarea)
+            moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
     }
     else if (mContainer) {
         GtkAllocation allocation;
         allocation.x = 0;
         allocation.y = 0;
         allocation.width = aWidth;
         allocation.height = aHeight;
         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
@@ -5960,16 +5976,25 @@ initialize_prefs(void)
     rv = prefs->GetBoolPref("mozilla.widget.use-buffer-pixmap", &val);
     if (NS_SUCCEEDED(rv))
         gUseBufferPixmap = val;
 
     rv = prefs->GetBoolPref("mozilla.widget.disable-native-theme", &val);
     if (NS_SUCCEEDED(rv))
         gDisableNativeTheme = val;
 
+    rv = prefs->GetBoolPref("mozilla.widget.not-active", &val);
+    if (NS_SUCCEEDED(rv))
+        gBlockWidgetActivity = val;
+
+    rv = prefs->GetBoolPref("mozilla.widget.not-realized", &val);
+    if (NS_SUCCEEDED(rv))
+        gBlockWidgetActivity_full = val;
+
+
     return NS_OK;
 }
 
 void
 nsWindow::ResetDragMotionTimer(GtkWidget *aWidget,
                                GdkDragContext *aDragContext,
                                gint aX, gint aY, guint aTime)
 {
@@ -7205,16 +7230,24 @@ nsWindow::GetSurfaceForGdkDrawable(GdkDr
     return result;
 }
 #endif
 
 // return the gfxASurface for rendering to this widget
 gfxASurface*
 nsWindow::GetThebesSurface()
 {
+    if (!mDrawingarea) {
+        if (!mThebesSurface)
+            mThebesSurface = new gfxImageSurface(gfxIntSize(1,1),
+                                                 gdk_rgb_get_visual()->depth == 16 ?
+                                                     gfxImageSurface::ImageFormatRGB16 :
+                                                     gfxImageSurface::ImageFormatRGB24);
+        return mThebesSurface;
+    }
     GdkDrawable* d;
     gint x_offset, y_offset;
     gdk_window_get_internal_paint_info(mDrawingarea->inner_window,
                                        &d, &x_offset, &y_offset);
 
 #ifdef MOZ_X11
     gint width, height;
     gdk_drawable_get_size(d, &width, &height);
