# In local layout rendering (RenderDocument API) we are not using native widget
# We should be able to disable some events for not used widget
# bug 102984
diff -r 2d5c910cc651 widget/src/gtk2/nsWindow.cpp
--- a/widget/src/gtk2/nsWindow.cpp	Mon Feb 16 10:18:33 2009 +0200
+++ b/widget/src/gtk2/nsWindow.cpp	Tue Feb 24 09:30:51 2009 +0200
@@ -339,20 +339,21 @@ typedef void (*_gdk_window_set_urgency_h
 
 // cursor cache
 static GdkCursor *gCursorCache[eCursorCount];
 
 // Global update pixmap
 static PRBool gUseBufferPixmap = PR_FALSE;
 static GdkPixmap *gBufferPixmap = nsnull;
 static gfxIntSize gBufferPixmapSize(0,0);
 static gfxIntSize gBufferPixmapMaxSize(0,0);
 static int gBufferPixmapUsageCount = 0;
+static PRBool gBlockWidgetActivity = PR_FALSE;
 
 // imported in nsWidgetFactory.cpp
 PRBool gDisableNativeTheme = PR_FALSE;
 
 // If this is 1, then a 24bpp buffer surface is always
 // created for exposes, even if the display has a different depth
 static PRBool gForce24bpp = PR_FALSE;
 
 nsWindow::nsWindow()
 {
@@ -1626,21 +1627,21 @@ nsWindow::SetCursor(imgIContainer* aCurs
 
     return rv;
 }
 
 
 NS_IMETHODIMP
 nsWindow::Validate()
 {
     // Get the update for this window and, well, just drop it on the
     // floor.
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     GdkRegion *region = gdk_window_get_update_area(mDrawingarea->inner_window);
 
     if (region)
         gdk_region_destroy(region);
 
     return NS_OK;
 }
 
@@ -1650,21 +1651,21 @@ nsWindow::Invalidate(PRBool aIsSynchrono
     GdkRectangle rect;
 
     rect.x = mBounds.x;
     rect.y = mBounds.y;
     rect.width = mBounds.width;
     rect.height = mBounds.height;
 
     LOGDRAW(("Invalidate (all) [%p]: %d %d %d %d\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height));
 
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     gdk_window_invalidate_rect(mDrawingarea->inner_window,
                                &rect, FALSE);
     if (aIsSynchronous)
         gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
 
     return NS_OK;
 }
 
@@ -1675,39 +1676,39 @@ nsWindow::Invalidate(const nsIntRect &aR
     GdkRectangle rect;
 
     rect.x = aRect.x;
     rect.y = aRect.y;
     rect.width = aRect.width;
     rect.height = aRect.height;
 
     LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d (sync: %d)\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
 
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     gdk_window_invalidate_rect(mDrawingarea->inner_window,
                                &rect, FALSE);
     if (aIsSynchronous)
         gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::InvalidateRegion(const nsIRegion* aRegion,
                            PRBool           aIsSynchronous)
 {
     GdkRegion *region = nsnull;
     aRegion->GetNativeRegion((void *&)region);
 
-    if (region && mDrawingarea) {
+    if (region && mDrawingarea && !gBlockWidgetActivity) {
         GdkRectangle rect;
         gdk_region_get_clipbox(region, &rect);
 
         LOGDRAW(("Invalidate (region) [%p]: %d %d %d %d (sync: %d)\n",
                  (void *)this,
                  rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
 
         gdk_window_invalidate_region(mDrawingarea->inner_window,
                                      region, FALSE);
     }
@@ -1715,21 +1716,21 @@ nsWindow::InvalidateRegion(const nsIRegi
         LOGDRAW(("Invalidate (region) [%p] with empty region\n",
                  (void *)this));
     }
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::Update()
 {
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return NS_OK;
 
     gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::SetColorMap(nsColorMap *aColorMap)
 {
     return NS_ERROR_NOT_IMPLEMENTED;
@@ -2150,21 +2151,21 @@ gdk_window_flash(GdkWindow *    aGdkWind
 
 gboolean
 nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
 {
     if (mIsDestroyed) {
         LOG(("Expose event on destroyed window [%p] window %p\n",
              (void *)this, (void *)aEvent->window));
         return FALSE;
     }
 
-    if (!mDrawingarea)
+    if (!mDrawingarea || gBlockWidgetActivity)
         return FALSE;
 
     // handle exposes for the inner window only
     if (aEvent->window != mDrawingarea->inner_window)
         return FALSE;
 
     static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
 
     nsCOMPtr<nsIRegion> updateRegion = do_CreateInstance(kRegionCID);
     if (!updateRegion)
@@ -5919,20 +5920,24 @@ initialize_prefs(void)
         gForce24bpp = val;
 
     rv = prefs->GetBoolPref("mozilla.widget.use-buffer-pixmap", &val);
     if (NS_SUCCEEDED(rv))
         gUseBufferPixmap = val;
 
     rv = prefs->GetBoolPref("mozilla.widget.disable-native-theme", &val);
     if (NS_SUCCEEDED(rv))
         gDisableNativeTheme = val;
 
+    rv = prefs->GetBoolPref("mozilla.widget.not-active", &val);
+    if (NS_SUCCEEDED(rv))
+        gBlockWidgetActivity = val;
+
     return NS_OK;
 }
 
 void
 nsWindow::ResetDragMotionTimer(GtkWidget *aWidget,
                                GdkDragContext *aDragContext,
                                gint aX, gint aY, guint aTime)
 {
 
     // We have to be careful about ref ordering here.  if aWidget ==
