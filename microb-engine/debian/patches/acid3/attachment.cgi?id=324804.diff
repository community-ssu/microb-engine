Index: mozilla/content/base/src/nsAttrValue.cpp
===================================================================
--- mozilla.orig/content/base/src/nsAttrValue.cpp
+++ mozilla/content/base/src/nsAttrValue.cpp
@@ -112,20 +112,16 @@
   delete sEnumTableArray;
   sEnumTableArray = nsnull;
 }
 
 nsAttrValue::ValueType
 nsAttrValue::Type() const
 {
   switch (BaseType()) {
-    case eIntegerBase:
-    {
-      return static_cast<ValueType>(mBits & NS_ATTRVALUE_INTEGERTYPE_MASK);
-    }
     case eOtherBase:
     {
       return GetMiscContainer()->mType;
     }
     default:
     {
       return static_cast<ValueType>(static_cast<PRUint16>(BaseType()));
     }
@@ -154,20 +150,16 @@
     }
     case eAtomBase:
     {
       nsIAtom* atom = GetAtomValue();
       NS_RELEASE(atom);
 
       break;
     }
-    case eIntegerBase:
-    {
-      break;
-    }
   }
 
   mBits = 0;
 }
 
 void
 nsAttrValue::SetTo(const nsAttrValue& aOther)
 {
@@ -189,93 +181,104 @@
     case eAtomBase:
     {
       ResetIfSet();
       nsIAtom* atom = aOther.GetAtomValue();
       NS_ADDREF(atom);
       SetPtrValueAndType(atom, eAtomBase);
       return;
     }
-    case eIntegerBase:
-    {
-      ResetIfSet();
-      mBits = aOther.mBits;
-      return;      
-    }
   }
 
   MiscContainer* otherCont = aOther.GetMiscContainer();
+  if (!EnsureEmptyMiscContainer()) {
+    return;
+  }
+
+  MiscContainer* cont = GetMiscContainer();
   switch (otherCont->mType) {
+    case eInteger:
+    {
+      cont->mInteger = otherCont->mInteger;
+      break;
+    }
+    case eEnum:
+    {
+      cont->mEnumValue = otherCont->mEnumValue;
+      break;
+    }
+    case ePercent:
+    {
+      cont->mPercent = otherCont->mPercent;
+      break;
+    }
     case eColor:
     {
-      if (EnsureEmptyMiscContainer()) {
-        MiscContainer* cont = GetMiscContainer();
-        cont->mColor = otherCont->mColor;
-        cont->mType = eColor;
-      }
+      cont->mColor = otherCont->mColor;
       break;
     }
     case eCSSStyleRule:
     {
-      SetTo(otherCont->mCSSStyleRule);
+      NS_ADDREF(cont->mCSSStyleRule = otherCont->mCSSStyleRule);
       break;
     }
     case eAtomArray:
     {
       if (!EnsureEmptyAtomArray() ||
           !GetAtomArrayValue()->AppendObjects(*otherCont->mAtomArray)) {
         Reset();
+        return;
       }
       break;
     }
 #ifdef MOZ_SVG
     case eSVGValue:
     {
-      SetTo(otherCont->mSVGValue);
+      NS_ADDREF(cont->mSVGValue = otherCont->mSVGValue);
+      break;
     }
 #endif
     default:
     {
       NS_NOTREACHED("unknown type stored in MiscContainer");
       break;
     }
   }
+
+  void* otherPtr =
+    reinterpret_cast<void*>(otherCont->mBits & NS_ATTRVALUE_POINTERVALUE_MASK);
+  if (otherPtr) {
+    if (static_cast<ValueBaseType>(otherCont->mBits & NS_ATTRVALUE_BASETYPE_MASK) ==
+        eStringBase) {
+      static_cast<nsStringBuffer*>(otherPtr)->AddRef();
+    } else {
+      static_cast<nsIAtom*>(otherPtr)->AddRef();
+    }
+    cont->mBits = otherCont->mBits;
+  }
+  // Note, set mType after switch-case, otherwise EnsureEmptyAtomArray doesn't
+  // work correctly.
+  cont->mType = otherCont->mType;
 }
 
 void
 nsAttrValue::SetTo(const nsAString& aValue)
 {
   ResetIfSet();
-  if (!aValue.IsEmpty()) {
-    PRUint32 len = aValue.Length();
-
-    nsStringBuffer* buf = nsStringBuffer::FromString(aValue);
-    if (buf && (buf->StorageSize()/sizeof(PRUnichar) - 1) == len) {
-      buf->AddRef();
-      SetPtrValueAndType(buf, eStringBase);
-      return;
-    }
-
-    buf = nsStringBuffer::Alloc((len + 1) * sizeof(PRUnichar));
-    if (!buf) {
-      return;
-    }
-    PRUnichar *data = static_cast<PRUnichar*>(buf->Data());
-    CopyUnicodeTo(aValue, 0, data, len);
-    data[len] = PRUnichar(0);
-
+  nsStringBuffer* buf = GetStringBuffer(aValue);
+  if (buf) {
     SetPtrValueAndType(buf, eStringBase);
   }
 }
 
 void
-nsAttrValue::SetTo(PRInt16 aInt)
+nsAttrValue::SetTo(PRInt16 aInt, const nsAString& aStringValue)
 {
   ResetIfSet();
-  SetIntValueAndType(aInt, eInteger);
+  SetIntValueAndType(aInt, eInteger, &aStringValue);
 }
 
 void
 nsAttrValue::SetTo(nsICSSStyleRule* aValue)
 {
   if (EnsureEmptyMiscContainer()) {
     MiscContainer* cont = GetMiscContainer();
     NS_ADDREF(cont->mCSSStyleRule = aValue);
@@ -320,134 +323,131 @@
     }
     case eAtom:
     {
       nsIAtom *atom = static_cast<nsIAtom*>(GetPtr());
       atom->ToString(aResult);
 
       break;
     }
-    case eInteger:
-    {
-      nsAutoString intStr;
-      intStr.AppendInt(GetIntInternal());
-      aResult = intStr;
-
-      break;
-    }
     case eColor:
     {
       nscolor v;
       GetColorValue(v);
       NS_RGBToHex(v, aResult);
 
       break;
     }
-    case eEnum:
-    {
-      PRInt16 val = GetEnumValue();
-      const EnumTable* table = sEnumTableArray->
-          ElementAt(GetIntInternal() & NS_ATTRVALUE_ENUMTABLEINDEX_MASK);
-      while (table->tag) {
-        if (table->value == val) {
-          aResult.AssignASCII(table->tag);
-
-          return;
-        }
-        table++;
-      }
-
-      NS_NOTREACHED("couldn't find value in EnumTable");
-
-      break;
-    }
-    case ePercent:
-    {
-      nsAutoString intStr;
-      intStr.AppendInt(GetIntInternal());
-      aResult = intStr + NS_LITERAL_STRING("%");
-
-      break;
-    }
     case eCSSStyleRule:
     {
       aResult.Truncate();
       MiscContainer *container = GetMiscContainer();
       nsCSSDeclaration* decl = container->mCSSStyleRule->GetDeclaration();
       if (decl) {
         decl->ToString(aResult);
       }
 
       break;
     }
-    case eAtomArray:
-    {
-      MiscContainer* cont = GetMiscContainer();
-      PRInt32 count = cont->mAtomArray->Count();
-      if (count) {
-        cont->mAtomArray->ObjectAt(0)->ToString(aResult);
-        nsAutoString tmp;
-        PRInt32 i;
-        for (i = 1; i < count; ++i) {
-          cont->mAtomArray->ObjectAt(i)->ToString(tmp);
-          aResult.Append(NS_LITERAL_STRING(" ") + tmp);
-        }
-      }
-      else {
-        aResult.Truncate();
-      }
-      break;
-    }
 #ifdef MOZ_SVG
     case eSVGValue:
     {
       GetMiscContainer()->mSVGValue->GetValueString(aResult);
       break;
     }
 #endif
     case eFloatValue:
     {
       nsAutoString str;
       str.AppendFloat(GetFloatValue());
       aResult = str;
 
       break;
     }
+    default:
+    {
+      MiscContainer* cont = GetMiscContainer();
+      void* ptr =
+        reinterpret_cast<void*>(cont->mBits & NS_ATTRVALUE_POINTERVALUE_MASK);
+      if (ptr) {
+        if (static_cast<ValueBaseType>(cont->mBits & NS_ATTRVALUE_BASETYPE_MASK) ==
+            eStringBase) {
+          nsStringBuffer* str = static_cast<nsStringBuffer*>(ptr);
+          if (str) {
+            str->ToString(str->StorageSize()/sizeof(PRUnichar) - 1, aResult);
+          }
+        } else {
+          nsIAtom *atom = static_cast<nsIAtom*>(ptr);
+          atom->ToString(aResult);
+        }
+      } else {
+        switch (Type()) {
+          case eInteger:
+          {
+            nsAutoString intStr;
+            intStr.AppendInt(cont->mInteger);
+            aResult = intStr;
+            break;
+          }
+          case eEnum:
+          {
+            PRInt16 val = GetEnumValue();
+            const EnumTable* table = sEnumTableArray->
+              ElementAt(cont->mEnumValue & NS_ATTRVALUE_ENUMTABLEINDEX_MASK);
+            while (table->tag) {
+              if (table->value == val) {
+                aResult.AssignASCII(table->tag);
+                return;
+              }
+              table++;
+            }
+            NS_NOTREACHED("couldn't find value in EnumTable");
+            break;
+          }
+          case ePercent:
+          {
+            nsAutoString intStr;
+            intStr.AppendInt(cont->mPercent);
+            aResult = intStr + NS_LITERAL_STRING("%");
+            break;
+          }
+          default:
+          {
+            aResult.Truncate();
+            break;
+          }
+        }
+      }
+    }
   }
 }
 
 const nsCheapString
 nsAttrValue::GetStringValue() const
 {
   NS_PRECONDITION(Type() == eString, "wrong type");
 
   return nsCheapString(static_cast<nsStringBuffer*>(GetPtr()));
 }
 
 PRBool
 nsAttrValue::GetColorValue(nscolor& aColor) const
 {
   NS_PRECONDITION(Type() == eColor || Type() == eString, "wrong type");
-  switch (BaseType()) {
+  switch (Type()) {
     case eString:
     {
       return GetPtr() && NS_ColorNameToRGB(GetStringValue(), &aColor);
     }
-    case eOtherBase:
+    case eColor:
     {
       aColor = GetMiscContainer()->mColor;
       
       break;
     }
-    case eIntegerBase:
-    {
-      aColor = static_cast<nscolor>(GetIntInternal());
-      
-      break;
-    }
     default:
     {
       NS_NOTREACHED("unexpected basetype");
       
       break;
     }
   }
 
@@ -499,27 +499,38 @@
 
       return 0;
     }
     case eOtherBase:
     {
       break;
     }
     case eAtomBase:
-    case eIntegerBase:
     {
       // mBits and PRUint32 might have different size. This should silence
       // any warnings or compile-errors. This is what the implementation of
       // NS_PTR_TO_INT32 does to take care of the same problem.
       return mBits - 0;
     }
   }
 
   MiscContainer* cont = GetMiscContainer();
   switch (cont->mType) {
+    case eInteger:
+    {
+      return cont->mInteger;
+    }
+    case eEnum:
+    {
+      return cont->mEnumValue;
+    }
+    case ePercent:
+    {
+      return cont->mPercent;
+    }
     case eColor:
     {
       return cont->mColor;
     }
     case eCSSStyleRule:
     {
       return NS_PTR_TO_INT32(cont->mCSSStyleRule);
     }
@@ -542,45 +553,56 @@
     {
       NS_NOTREACHED("unknown type stored in MiscContainer");
       return 0;
     }
   }
 }
 
 PRBool
-nsAttrValue::Equals(const nsAttrValue& aOther) const
+nsAttrValue::TypeAndValueEquals(const nsAttrValue& aOther) const
 {
   if (BaseType() != aOther.BaseType()) {
     return PR_FALSE;
   }
 
   switch(BaseType()) {
     case eStringBase:
     {
       return GetStringValue().Equals(aOther.GetStringValue());
     }
     case eOtherBase:
     {
       break;
     }
     case eAtomBase:
-    case eIntegerBase:
     {
       return mBits == aOther.mBits;
     }
   }
 
   MiscContainer* thisCont = GetMiscContainer();
   MiscContainer* otherCont = aOther.GetMiscContainer();
   if (thisCont->mType != otherCont->mType) {
     return PR_FALSE;
   }
 
   switch (thisCont->mType) {
+    case eInteger:
+    {
+      return thisCont->mInteger == otherCont->mInteger;
+    }
+    case eEnum:
+    {
+      return thisCont->mEnumValue == otherCont->mEnumValue;
+    }
+    case ePercent:
+    {
+      return thisCont->mPercent == otherCont->mPercent;
+    }
     case eColor:
     {
       return thisCont->mColor == otherCont->mColor;
     }
     case eCSSStyleRule:
     {
       return thisCont->mCSSStyleRule == otherCont->mCSSStyleRule;
     }
@@ -736,19 +758,21 @@
 }
 
 void
 nsAttrValue::ParseAtomArray(const nsAString& aValue)
 {
   nsAString::const_iterator iter, end;
   aValue.BeginReading(iter);
   aValue.EndReading(end);
+  PRBool hasSpace = PR_FALSE;
 
   // skip initial whitespace
   while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
+    hasSpace = PR_TRUE;
     ++iter;
   }
 
   if (iter == end) {
     ResetIfSet();
     return;
   }
 
@@ -762,21 +786,23 @@
   nsCOMPtr<nsIAtom> classAtom = do_GetAtom(Substring(start, iter));
   if (!classAtom) {
     Reset();
     return;
   }
 
   // skip whitespace
   while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
+    hasSpace = PR_TRUE;
     ++iter;
   }
 
-  if (iter == end) {
-    // we only found one classname so don't bother storing a list
+  if (iter == end && !hasSpace) {
+    // we only found one classname and there was no whitespace so
+    // don't bother storing a list
     ResetIfSet();
     nsIAtom* atom = nsnull;
     classAtom.swap(atom);
     SetPtrValueAndType(atom, eAtomBase);
     return;
   }
 
   if (!EnsureEmptyAtomArray()) {
@@ -786,17 +812,17 @@
   nsCOMArray<nsIAtom>* array = GetAtomArrayValue();
   
   if (!array->AppendObject(classAtom)) {
     Reset();
     return;
   }
 
   // parse the rest of the classnames
-  do {
+  while (iter != end) {
     start = iter;
 
     do {
       ++iter;
     } while (iter != end && !nsContentUtils::IsHTMLWhitespace(*iter));
 
     classAtom = do_GetAtom(Substring(start, iter));
 
@@ -804,18 +830,19 @@
       Reset();
       return;
     }
 
     // skip whitespace
     while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
       ++iter;
     }
-  } while (iter != end);
+  }
 
+  SetMiscAtomOrString(&aValue);
   return;
 }
 
 void
 nsAttrValue::ParseStringOrAtom(const nsAString& aValue)
 {
   PRUint32 len = aValue.Length();
   // Don't bother with atoms if it's an empty string since
@@ -838,27 +865,26 @@
   while (aTable->tag) {
     if (aCaseSensitive ? aValue.EqualsASCII(aTable->tag) :
                          aValue.LowerCaseEqualsASCII(aTable->tag)) {
 
       // Find index of EnumTable
       PRInt16 index = sEnumTableArray->IndexOf(aTable);
       if (index < 0) {
         index = sEnumTableArray->Length();
-        NS_ASSERTION(index <= NS_ATTRVALUE_ENUMTABLEINDEX_MAXVALUE,
-                     "too many enum tables");
         if (!sEnumTableArray->AppendElement(aTable)) {
           return PR_FALSE;
         }
       }
 
       PRInt32 value = (aTable->value << NS_ATTRVALUE_ENUMTABLEINDEX_BITS) +
                       index;
 
-      SetIntValueAndType(value, eEnum);
+      PRBool equals = aCaseSensitive || aValue.EqualsASCII(aTable->tag);
+      SetIntValueAndType(value, eEnum, equals ? nsnull : &aValue);
       NS_ASSERTION(GetEnumValue() == aTable->value,
                    "failed to store enum properly");
 
       return PR_TRUE;
     }
     aTable++;
   }
 
@@ -867,60 +893,53 @@
 
 PRBool
 nsAttrValue::ParseSpecialIntValue(const nsAString& aString,
                                   PRBool aCanBePercent)
 {
   ResetIfSet();
 
   PRInt32 ec;
+  PRBool strict;
+  PRBool isPercent = PR_FALSE;
   nsAutoString tmp(aString);
-  PRInt32 val = tmp.ToInteger(&ec);
+  PRInt32 originalVal = StringToInteger(aString, &strict, &ec, aCanBePercent, &isPercent);
 
   if (NS_FAILED(ec)) {
     return PR_FALSE;
   }
 
-  val = PR_MAX(val, 0);
-  val = PR_MIN(val, NS_ATTRVALUE_INTEGERTYPE_MAXVALUE);
+  PRInt32 val = PR_MAX(originalVal, 0);
+  strict = strict && (originalVal == val);
 
-  // % (percent)
-  // XXX RFindChar means that 5%x will be parsed!
-  if (aCanBePercent && tmp.RFindChar('%') >= 0) {
-    if (val > 100) {
-      val = 100;
-    }
-    SetIntValueAndType(val, ePercent);
-    return PR_TRUE;
-  }
-
-  // Straight number is interpreted as integer
-  SetIntValueAndType(val, eInteger);
+  SetIntValueAndType(val,
+                     isPercent ? ePercent : eInteger,
+                     strict ? nsnull : &aString);
   return PR_TRUE;
 }
 
 PRBool
 nsAttrValue::ParseIntWithBounds(const nsAString& aString,
                                 PRInt32 aMin, PRInt32 aMax)
 {
-  NS_PRECONDITION(aMin < aMax &&
-                  aMin >= NS_ATTRVALUE_INTEGERTYPE_MINVALUE &&
-                  aMax <= NS_ATTRVALUE_INTEGERTYPE_MAXVALUE, "bad boundaries");
+  NS_PRECONDITION(aMin < aMax, "bad boundaries");
 
   ResetIfSet();
 
   PRInt32 ec;
-  PRInt32 val = PromiseFlatString(aString).ToInteger(&ec);
+  PRBool strict;
+  PRInt32 originalVal = StringToInteger(aString, &strict, &ec);
   if (NS_FAILED(ec)) {
     return PR_FALSE;
   }
 
-  val = PR_MAX(val, aMin);
+  PRInt32 val = PR_MAX(originalVal, aMin);
   val = PR_MIN(val, aMax);
-  SetIntValueAndType(val, eInteger);
+  strict = strict && (originalVal == val);
+  SetIntValueAndType(val, eInteger, strict ? nsnull : &aString);
 
   return PR_TRUE;
 }
 
 PRBool
 nsAttrValue::ParseColor(const nsAString& aString, nsIDocument* aDocument)
 {
   nsAutoString colorStr(aString);
@@ -949,31 +968,65 @@
     }
     colorStr.Cut(0, 1);
     if (!NS_HexToRGB(colorStr, &color)) {
       Reset();
       return PR_FALSE;
     }
   }
 
-  PRInt32 colAsInt = static_cast<PRInt32>(color);
-  PRInt32 tmp = colAsInt * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER;
-  if (tmp / NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER == colAsInt) {
-    ResetIfSet();
-    SetIntValueAndType(colAsInt, eColor);
-  }
-  else if (EnsureEmptyMiscContainer()) {
+  if (EnsureEmptyMiscContainer()) {
     MiscContainer* cont = GetMiscContainer();
     cont->mColor = color;
     cont->mType = eColor;
   }
 
   return PR_TRUE;
 }
 
+void
+nsAttrValue::SetMiscAtomOrString(const nsAString* aValue)
+{
+  NS_ASSERTION(GetMiscContainer(), "Must have MiscContainer!");
+  NS_ASSERTION(!GetMiscContainer()->mBits, "Trying to re-set atom or string!");
+  if (aValue) {
+    PRUint32 len = aValue->Length();
+    if (len) {
+      MiscContainer* cont = GetMiscContainer();
+      if (len <= NS_ATTRVALUE_MAX_STRINGLENGTH_ATOM) {
+        nsIAtom* atom = NS_NewAtom(*aValue);
+        if (atom) {
+          cont->mBits = reinterpret_cast<PtrBits>(atom) | eAtomBase;
+        }
+      } else {
+        nsStringBuffer* buf = GetStringBuffer(*aValue);
+        if (buf) {
+          cont->mBits = reinterpret_cast<PtrBits>(buf) | eStringBase;
+        }
+      }
+    }
+  }
+}
+
+void
+nsAttrValue::ResetMiscAtomOrString()
+{
+  MiscContainer* cont = GetMiscContainer();
+  void* ptr = reinterpret_cast<void*>(cont->mBits & NS_ATTRVALUE_POINTERVALUE_MASK);
+  if (ptr) {
+    if (static_cast<ValueBaseType>(cont->mBits & NS_ATTRVALUE_BASETYPE_MASK) ==
+        eStringBase) {
+      static_cast<nsStringBuffer*>(ptr)->Release();
+    } else {
+      static_cast<nsIAtom*>(ptr)->Release();
+    }
+    cont->mBits = 0;
+  }
+}
+
 PRBool nsAttrValue::ParseFloatValue(const nsAString& aString)
 {
   ResetIfSet();
 
   PRInt32 ec;
   float val = PromiseFlatString(aString).ToFloat(&ec);
   if (NS_FAILED(ec)) {
     return PR_FALSE;
@@ -982,16 +1035,17 @@
   return PR_TRUE;
 }
 
 PRBool
 nsAttrValue::EnsureEmptyMiscContainer()
 {
   MiscContainer* cont;
   if (BaseType() == eOtherBase) {
+    ResetMiscAtomOrString();
     cont = GetMiscContainer();
     switch (cont->mType) {
       case eCSSStyleRule:
       {
         NS_RELEASE(cont->mCSSStyleRule);
         break;
       }
       case eAtomArray:
@@ -1017,25 +1071,27 @@
 
     cont = new MiscContainer;
     NS_ENSURE_TRUE(cont, PR_FALSE);
 
     SetPtrValueAndType(cont, eOtherBase);
   }
 
   cont->mType = eColor;
+  cont->mBits = 0;
   cont->mColor = 0;
 
   return PR_TRUE;
 }
 
 PRBool
 nsAttrValue::EnsureEmptyAtomArray()
 {
   if (Type() == eAtomArray) {
+    ResetMiscAtomOrString();
     GetAtomArrayValue()->Clear();
     return PR_TRUE;
   }
 
   if (!EnsureEmptyMiscContainer()) {
     // should already be reset
     return PR_FALSE;
   }
@@ -1047,8 +1103,116 @@
   }
 
   MiscContainer* cont = GetMiscContainer();
   cont->mAtomArray = array;
   cont->mType = eAtomArray;
 
   return PR_TRUE;
 }
+
+nsStringBuffer*
+nsAttrValue::GetStringBuffer(const nsAString& aValue) const
+{
+  PRUint32 len = aValue.Length();
+  if (!len) {
+    return nsnull;
+  }
+
+  nsStringBuffer* buf = nsStringBuffer::FromString(aValue);
+  if (buf && (buf->StorageSize()/sizeof(PRUnichar) - 1) == len) {
+    buf->AddRef();
+    return buf;
+  }
+
+  buf = nsStringBuffer::Alloc((len + 1) * sizeof(PRUnichar));
+  if (!buf) {
+    return nsnull;
+  }
+  PRUnichar *data = static_cast<PRUnichar*>(buf->Data());
+  CopyUnicodeTo(aValue, 0, data, len);
+  data[len] = PRUnichar(0);
+  return buf;
+}
+
+PRInt32
+nsAttrValue::StringToInteger(const nsAString& aValue, PRBool* aStrict,
+                             PRInt32* aErrorCode,
+                             PRBool aCanBePercent,
+                             PRBool* aIsPercent) const
+{
+  *aStrict = PR_FALSE;
+  *aErrorCode = NS_ERROR_ILLEGAL_VALUE;
+  if (aCanBePercent) {
+    *aIsPercent = PR_FALSE;
+  }
+
+  nsAString::const_iterator iter, end;
+  aValue.BeginReading(iter);
+  aValue.EndReading(end);
+  PRBool negate = PR_FALSE;
+  PRInt32 value = 0;
+  if (iter != end) {
+    if (*iter == PRUnichar('-')) {
+      negate = PR_TRUE;
+      ++iter;
+    }
+    if (iter != end) {
+      if ((*iter >= PRUnichar('1') || (*iter == PRUnichar('0') && !negate)) &&
+          *iter <= PRUnichar('9')) {
+        value = *iter - PRUnichar('0');
+        ++iter;
+        *aStrict = (value != 0 || iter == end ||
+                    (aCanBePercent && *iter == PRUnichar('%')));
+        while (iter != end && *aStrict) {
+          if (*iter >= PRUnichar('0') && *iter <= PRUnichar('9')) {
+            value = (value * 10) + (*iter - PRUnichar('0'));
+            ++iter;
+            if (iter != end && value > ((PR_INT32_MAX / 10) - 9)) {
+              *aStrict = PR_FALSE;
+            }
+          } else if (aCanBePercent && *iter == PRUnichar('%')) {
+            ++iter;
+            if (iter == end) {
+              *aIsPercent = PR_TRUE;
+            } else {
+              *aStrict = PR_FALSE;
+            }
+          } else {
+            *aStrict = PR_FALSE;
+          }
+        }
+        if (*aStrict) {
+          if (negate) {
+            value = -value;
+          }
+          if (!aCanBePercent || !*aIsPercent || (value >= 0 && value <= 100)) {
+            *aErrorCode = NS_OK;
+#ifdef DEBUG
+            nsAutoString stringValue;
+            stringValue.AppendInt(value);
+            if (aCanBePercent && *aIsPercent) {
+              stringValue.AppendLiteral("%");
+            }
+            NS_ASSERTION(stringValue.Equals(aValue), "Wrong conversion!");
+#endif
+            return value;
+          }
+        }
+      }
+    }
+  }
+
+  nsAutoString tmp(aValue);
+  value = tmp.ToInteger(aErrorCode);
+  if (NS_FAILED(*aErrorCode)) {
+    return value;
+  }
+  // % (percent)
+  // XXX RFindChar means that 5%x will be parsed!
+  if (aCanBePercent && tmp.RFindChar('%') >= 0) {
+    if (value > 100) {
+      value = 100;
+    }
+    *aIsPercent = PR_TRUE;
+  }
+  return value;
+}
Index: mozilla/content/base/src/nsAttrValue.h
===================================================================
--- mozilla.orig/content/base/src/nsAttrValue.h
+++ mozilla/content/base/src/nsAttrValue.h
@@ -59,24 +59,17 @@
 template<class E> class nsCOMArray;
 template<class E> class nsTPtrArray;
 
 #define NS_ATTRVALUE_MAX_STRINGLENGTH_ATOM 12
 
 #define NS_ATTRVALUE_BASETYPE_MASK (PtrBits(3))
 #define NS_ATTRVALUE_POINTERVALUE_MASK (~NS_ATTRVALUE_BASETYPE_MASK)
 
-#define NS_ATTRVALUE_INTEGERTYPE_BITS 4
-#define NS_ATTRVALUE_INTEGERTYPE_MASK (PtrBits((1 << NS_ATTRVALUE_INTEGERTYPE_BITS) - 1))
-#define NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER (1 << NS_ATTRVALUE_INTEGERTYPE_BITS)
-#define NS_ATTRVALUE_INTEGERTYPE_MAXVALUE ((1 << (31 - NS_ATTRVALUE_INTEGERTYPE_BITS)) - 1)
-#define NS_ATTRVALUE_INTEGERTYPE_MINVALUE (-NS_ATTRVALUE_INTEGERTYPE_MAXVALUE - 1)
-
-#define NS_ATTRVALUE_ENUMTABLEINDEX_BITS (32 - 16 - NS_ATTRVALUE_INTEGERTYPE_BITS)
-#define NS_ATTRVALUE_ENUMTABLEINDEX_MAXVALUE ((1 << NS_ATTRVALUE_ENUMTABLEINDEX_BITS) - 1)
+#define NS_ATTRVALUE_ENUMTABLEINDEX_BITS 16
 #define NS_ATTRVALUE_ENUMTABLEINDEX_MASK (PtrBits((1 << NS_ATTRVALUE_ENUMTABLEINDEX_BITS) - 1))
 
 /**
  * A class used to construct a nsString from a nsStringBuffer (we might
  * want to move this to nsString at some point).
  */
 class nsCheapString : public nsString {
 public:
@@ -101,37 +94,36 @@
   static nsresult Init();
   static void Shutdown();
 
   // This has to be the same as in ValueBaseType
   enum ValueType {
     eString =       0x00, //   00
                           //   01  this value indicates an 'misc' struct
     eAtom =         0x02, //   10
+    // All other types will be stored in misc struct
     eInteger =      0x03, // 0011
     eColor =        0x07, // 0111
     eEnum =         0x0B, // 1011  This should eventually die
     ePercent =      0x0F, // 1111
-    // Values below here won't matter, they'll be stored in the 'misc' struct
-    // anyway
     eCSSStyleRule = 0x10,
     eAtomArray =    0x11 
 #ifdef MOZ_SVG
     ,eSVGValue =    0x12
 #endif
     ,eFloatValue  = 0x13
   };
 
   ValueType Type() const;
 
   void Reset();
 
   void SetTo(const nsAttrValue& aOther);
   void SetTo(const nsAString& aValue);
-  void SetTo(PRInt16 aInt);
+  void SetTo(PRInt16 aInt, const nsAString& aStringValue);
   void SetTo(nsICSSStyleRule* aValue);
 #ifdef MOZ_SVG
   void SetTo(nsISVGValue* aValue);
 #endif
 
   void SwapValueWith(nsAttrValue& aOther);
 
   void ToString(nsAString& aResult) const;
@@ -156,17 +148,19 @@
   // Returns the number of atoms we have; 0 if we have none.  It's OK
   // to call this without checking the type first; it handles that.
   PRInt32 GetAtomCount() const;
   // Returns the atom at aIndex (0-based).  Do not call this with
   // aIndex >= GetAtomCount().
   nsIAtom* AtomAt(PRInt32 aIndex) const;
 
   PRUint32 HashValue() const;
-  PRBool Equals(const nsAttrValue& aOther) const;
+  // TypeAndValueEquals compares the type and value of naAttrValue objects,
+  // not the string values.
+  PRBool TypeAndValueEquals(const nsAttrValue& aOther) const;
   PRBool Equals(const nsAString& aValue, nsCaseTreatment aCaseSensitive) const;
   PRBool Equals(nsIAtom* aValue, nsCaseTreatment aCaseSensitive) const;
 
   /**
    * Returns true if this AttrValue is equal to the given atom, or is an
    * array which contains the given atom.
    */
   PRBool Contains(nsIAtom* aValue, nsCaseTreatment aCaseSensitive) const;
@@ -219,30 +213,29 @@
 
   /**
    * Parse a string value into an integer.
    *
    * @param aString the string to parse
    * @return whether the value could be parsed
    */
   PRBool ParseIntValue(const nsAString& aString) {
-    return ParseIntWithBounds(aString, NS_ATTRVALUE_INTEGERTYPE_MINVALUE,
-                              NS_ATTRVALUE_INTEGERTYPE_MAXVALUE);
+    return ParseIntWithBounds(aString, PR_INT32_MIN, PR_INT32_MAX);
   }
 
   /**
    * Parse a string value into an integer with minimum value and maximum value.
    *
    * @param aString the string to parse
    * @param aMin the minimum value (if value is less it will be bumped up)
    * @param aMax the maximum value (if value is greater it will be chopped down)
    * @return whether the value could be parsed
    */
   PRBool ParseIntWithBounds(const nsAString& aString, PRInt32 aMin,
-                            PRInt32 aMax = NS_ATTRVALUE_INTEGERTYPE_MAXVALUE);
+                            PRInt32 aMax = PR_INT32_MAX);
 
   /**
    * Parse a string into a color.
    *
    * @param aString the string to parse
    * @param aDocument the document (to find out whether we're in quirks mode)
    * @return whether the value could be parsed
    */
@@ -256,47 +249,63 @@
    */
   PRBool ParseFloatValue(const nsAString& aString);
 
 private:
   // These have to be the same as in ValueType
   enum ValueBaseType {
     eStringBase =    eString,    // 00
     eOtherBase =     0x01,       // 01
-    eAtomBase =      eAtom,      // 10
-    eIntegerBase =   0x03        // 11
+    eAtomBase =      eAtom       // 10
   };
 
   struct MiscContainer
   {
     ValueType mType;
+    // mBits points to either nsIAtom* or nsStringBuffer* and is used when mType
+    // isn't mCSSStyleRule or eSVGValue.
+    // Note eStringBase and eAtomBase is used also to handle the type of mBits.
+    PtrBits mBits;
     union {
+      PRInt32 mInteger;
       nscolor mColor;
+      PRUint32 mEnumValue;
+      PRInt32 mPercent;
       nsICSSStyleRule* mCSSStyleRule;
       nsCOMArray<nsIAtom>* mAtomArray;
 #ifdef MOZ_SVG
       nsISVGValue* mSVGValue;
 #endif
       float mFloatValue;
     };
   };
 
   inline ValueBaseType BaseType() const;
 
   inline void SetPtrValueAndType(void* aValue, ValueBaseType aType);
-  inline void SetIntValueAndType(PRInt32 aValue, ValueType aType);
+  inline void SetIntValueAndType(PRInt32 aValue, ValueType aType,
+                                 const nsAString* aStringValue);
+  void SetMiscAtomOrString(const nsAString* aValue);
+  void ResetMiscAtomOrString();
   inline void SetFloatValue(float aValue);
   inline void ResetIfSet();
 
   inline void* GetPtr() const;
   inline MiscContainer* GetMiscContainer() const;
-  inline PRInt32 GetIntInternal() const;
 
   PRBool EnsureEmptyMiscContainer();
   PRBool EnsureEmptyAtomArray();
+  nsStringBuffer* GetStringBuffer(const nsAString& aValue) const;
+  // aStrict is set PR_TRUE if stringifying the return value equals with
+  // aValue.
+  PRInt32 StringToInteger(const nsAString& aValue,
+                          PRBool* aStrict,
+                          PRInt32* aErrorCode,
+                          PRBool aCanBePercent = PR_FALSE,
+                          PRBool* aIsPercent = nsnull) const;
 
   static nsTPtrArray<const EnumTable>* sEnumTableArray;
 
   PtrBits mBits;
 };
 
 /**
  * Implementation of inline methods
@@ -308,35 +317,32 @@
   NS_PRECONDITION(Type() == eAtom, "wrong type");
   return reinterpret_cast<nsIAtom*>(GetPtr());
 }
 
 inline PRInt32
 nsAttrValue::GetIntegerValue() const
 {
   NS_PRECONDITION(Type() == eInteger, "wrong type");
-  return GetIntInternal();
+  return GetMiscContainer()->mInteger;
 }
 
 inline PRInt16
 nsAttrValue::GetEnumValue() const
 {
   NS_PRECONDITION(Type() == eEnum, "wrong type");
-  // We don't need to worry about sign extension here since we're
-  // returning an PRInt16 which will cut away the top bits.
-  return static_cast<PRInt16>
-                    (GetIntInternal() >> NS_ATTRVALUE_ENUMTABLEINDEX_BITS);
+  return static_cast<PRInt16>(
+    GetMiscContainer()->mEnumValue >> NS_ATTRVALUE_ENUMTABLEINDEX_BITS);
 }
 
 inline float
 nsAttrValue::GetPercentValue() const
 {
   NS_PRECONDITION(Type() == ePercent, "wrong type");
-  return static_cast<float>(GetIntInternal()) /
-         100.0f;
+  return static_cast<float>(GetMiscContainer()->mPercent) / 100.0f;
 }
 
 inline nsCOMArray<nsIAtom>*
 nsAttrValue::GetAtomArrayValue() const
 {
   NS_PRECONDITION(Type() == eAtomArray, "wrong type");
   return GetMiscContainer()->mAtomArray;
 }
@@ -374,26 +380,46 @@
 nsAttrValue::SetPtrValueAndType(void* aValue, ValueBaseType aType)
 {
   NS_ASSERTION(!(NS_PTR_TO_INT32(aValue) & ~NS_ATTRVALUE_POINTERVALUE_MASK),
                "pointer not properly aligned, this will crash");
   mBits = reinterpret_cast<PtrBits>(aValue) | aType;
 }
 
 inline void
-nsAttrValue::SetIntValueAndType(PRInt32 aValue, ValueType aType)
+nsAttrValue::SetIntValueAndType(PRInt32 aValue, ValueType aType,
+                                const nsAString* aStringValue)
 {
-#ifdef DEBUG
-  {
-    PRInt32 tmp = aValue * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER;
-    NS_ASSERTION(tmp / NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER == aValue,
-                 "Integer too big to fit");
-  }
-#endif
-  mBits = (aValue * NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER) | aType;
+  if (EnsureEmptyMiscContainer()) {
+    MiscContainer* cont = GetMiscContainer();
+    switch (aType) {
+      case eInteger:
+      {
+        cont->mInteger = aValue;
+        break;
+      }
+      case ePercent:
+      {
+        cont->mPercent = aValue;
+        break;
+      }
+      case eEnum:
+      {
+        cont->mEnumValue = aValue;
+        break;
+      }
+      default:
+      {
+        NS_NOTREACHED("unknown integer type");
+        break;
+      }
+    }
+    cont->mType = aType;
+    SetMiscAtomOrString(aStringValue);
+	}
 }
 
 inline void
 nsAttrValue::SetFloatValue(float aValue)
 {
   if (EnsureEmptyMiscContainer()) {
     MiscContainer* cont = GetMiscContainer();
     cont->mFloatValue = aValue;
@@ -406,39 +432,25 @@
   if (mBits) {
     Reset();
   }
 }
 
 inline void*
 nsAttrValue::GetPtr() const
 {
-  NS_ASSERTION(BaseType() != eIntegerBase,
-               "getting pointer from non-pointer");
   return reinterpret_cast<void*>(mBits & NS_ATTRVALUE_POINTERVALUE_MASK);
 }
 
 inline nsAttrValue::MiscContainer*
 nsAttrValue::GetMiscContainer() const
 {
   NS_ASSERTION(BaseType() == eOtherBase, "wrong type");
   return static_cast<MiscContainer*>(GetPtr());
 }
 
-inline PRInt32
-nsAttrValue::GetIntInternal() const
-{
-  NS_ASSERTION(BaseType() == eIntegerBase,
-               "getting integer from non-integer");
-  // Make sure we get a signed value.
-  // Lets hope the optimizer optimizes this into a shift. Unfortunatly signed
-  // bitshift right is implementaion dependant.
-  return static_cast<PRInt32>(mBits & ~NS_ATTRVALUE_INTEGERTYPE_MASK) /
-         NS_ATTRVALUE_INTEGERTYPE_MULTIPLIER;
-}
-
 inline PRBool
 nsAttrValue::IsEmptyString() const
 {
   return !mBits;
 }
 
 #endif
Index: mozilla/content/base/src/nsMappedAttributes.cpp
===================================================================
--- mozilla.orig/content/base/src/nsMappedAttributes.cpp
+++ mozilla/content/base/src/nsMappedAttributes.cpp
@@ -160,17 +160,17 @@
 
   if (mRuleMapper != aOther->mRuleMapper || mAttrCount != aOther->mAttrCount) {
     return PR_FALSE;
   }
 
   PRUint32 i;
   for (i = 0; i < mAttrCount; ++i) {
     if (!Attrs()[i].mName.Equals(aOther->Attrs()[i].mName) ||
-        !Attrs()[i].mValue.Equals(aOther->Attrs()[i].mValue)) {
+        !Attrs()[i].mValue.TypeAndValueEquals(aOther->Attrs()[i].mValue)) {
       return PR_FALSE;
     }
   }
 
   return PR_TRUE;
 }
 
 PRUint32
Index: mozilla/content/base/test/Makefile.in
===================================================================
--- mozilla.orig/content/base/test/Makefile.in
+++ mozilla/content/base/test/Makefile.in
@@ -77,16 +77,17 @@
 _TEST_FILES = 	test_bug5141.html \
 		test_bug51034.html \
 		test_bug199959.html \
 		test_bug218236.html \
 		file_bug218236_multipart.txt \
 		file_bug218236_multipart.txt^headers^ \
 		test_bug218277.html \
 		test_bug238409.html \
+		test_bug254337.html \
 		test_bug276037-1.html \
 		test_bug276037-2.xhtml \
 		test_bug308484.html \
 		test_bug311681.xml \
 		test_bug322317.html \
 		test_bug330925.xhtml \
 		test_bug337631.html \
 		test_bug338541.xhtml \
@@ -180,16 +181,17 @@
 		file_bug428847-2.xhtml \
 		test_bug425201.html \
 		test_bug431833.html \
 		test_bug438519.html \
 		test_bug444722.html \
 		test_text_replaceWholeText.html \
 		test_text_wholeText.html \
 		wholeTexty-helper.xml \
+		test_bug433533.html \
 		test_bug444030.xhtml \
 		$(NULL)
 
 libs:: $(_TEST_FILES)
 	$(INSTALL) $(foreach f,$^,"$f") $(DEPTH)/_tests/testing/mochitest/tests/$(relativesrcdir)
 
 check::
 	@$(EXIT_ON_ERROR) \
Index: mozilla/content/html/content/src/nsHTMLTableCellElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsHTMLTableCellElement.cpp
+++ mozilla/content/html/content/src/nsHTMLTableCellElement.cpp
@@ -281,28 +281,28 @@
     if (aAttribute == nsGkAtoms::colspan) {
       PRBool res = aResult.ParseIntWithBounds(aValue, -1);
       if (res) {
         PRInt32 val = aResult.GetIntegerValue();
         // reset large colspan values as IE and opera do
         // quirks mode does not honor the special html 4 value of 0
         if (val > MAX_COLSPAN || val < 0 ||
             (0 == val && InNavQuirksMode(GetOwnerDoc()))) {
-          aResult.SetTo(1);
+          aResult.SetTo(1, NS_LITERAL_STRING("1"));
         }
       }
       return res;
     }
     if (aAttribute == nsGkAtoms::rowspan) {
       PRBool res = aResult.ParseIntWithBounds(aValue, -1, MAX_ROWSPAN);
       if (res) {
         PRInt32 val = aResult.GetIntegerValue();
         // quirks mode does not honor the special html 4 value of 0
         if (val < 0 || (0 == val && InNavQuirksMode(GetOwnerDoc()))) {
-          aResult.SetTo(1);
+          aResult.SetTo(1, NS_LITERAL_STRING("1"));
         }
       }
       return res;
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
     }
     if (aAttribute == nsGkAtoms::width) {
Index: mozilla/content/html/content/src/nsHTMLTableElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsHTMLTableElement.cpp
+++ mozilla/content/html/content/src/nsHTMLTableElement.cpp
@@ -929,17 +929,17 @@
       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
     }
     if (aAttribute == nsGkAtoms::cols) {
       return aResult.ParseIntWithBounds(aValue, 0);
     }
     if (aAttribute == nsGkAtoms::border) {
       if (!aResult.ParseIntWithBounds(aValue, 0)) {
         // XXX this should really be NavQuirks only to allow non numeric value
-        aResult.SetTo(1);
+        aResult.SetTo(1, NS_LITERAL_STRING("1"));
       }
 
       return PR_TRUE;
     }
     if (aAttribute == nsGkAtoms::height) {
       return aResult.ParseSpecialIntValue(aValue, PR_TRUE);
     }
     if (aAttribute == nsGkAtoms::width) {
Index: mozilla/parser/htmlparser/tests/mochitest/regressions.txt
===================================================================
--- mozilla.orig/parser/htmlparser/tests/mochitest/regressions.txt
+++ mozilla/parser/htmlparser/tests/mochitest/regressions.txt
@@ -114,17 +114,17 @@
 | <html>
 |   <head>
 |   <body>
 |     <table>
 |       <tbody>
 |         <tr>
 |           <td>
 |           <input>
-|             type="hidden"
+|             type="hiDDen"
 |           <td>
 
 #data
 <!DOCTYPE html><body><table><tr><td></td><input tYPe="  hiDDen  "><td></td></tr></table></body>
 #errors
 #document
 | <!DOCTYPE HTML>
 | <html>
Index: mozilla/content/base/test/test_bug254337.html
===================================================================
--- /dev/null
+++ mozilla/content/base/test/test_bug254337.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=254337
+-->
+<head>
+  <title>Test for Bug 254337</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=254337">Mozilla Bug 254337</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 254337 **/
+
+var el = document.createElement("div");
+el.setAttribute("class", "foobar1");
+is(el.className, "foobar1", "Wrong className!");
+el.className += " foobar2 ";
+is(el.className, "foobar1 foobar2 ", "Appending to className didn't work!");
+el.className += "foobar3";
+is(el.className, "foobar1 foobar2 foobar3", "Appending to className didn't work!");
+
+var el = document.createElement("div");
+el.setAttribute("class", " foobar1 ");
+is(el.className, " foobar1 ", "Wrong className!");
+el.className += "foobar2";
+is(el.className, " foobar1 foobar2", "Appending to className didn't work!");
+
+
+</script>
+</pre>
+</body>
+</html>
+
Index: mozilla/content/base/test/test_bug433533.html
===================================================================
--- /dev/null
+++ mozilla/content/base/test/test_bug433533.html
@@ -0,0 +1,172 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=433533
+-->
+<head>
+  <title>Test for Bug 433533</title>
+  <script type="text/javascript" src="/MochiKit/MochiKit.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=433533">Mozilla Bug 433533</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+<script class="testbody" type="text/javascript">
+
+/** Test for Bug 433533 **/
+
+var input = document.createElement("input");
+input.setAttribute("type", "hidden");
+is(input.getAttribute("type"), "hidden", "Setting type attribute didn't work!");
+input.setAttribute("type", "hiDDen");
+is(input.getAttribute("type"), "hiDDen", "Type attribute didn't store the original value");
+is(input.type, "hidden", "Wrong input.type!");
+
+var td = document.createElement("td");
+td.setAttribute("scope", "rOW");
+is(td.getAttribute("scope"), "rOW", "Scope attribute didn't store the original value");
+td.setAttribute("scope", "row");
+is(td.getAttribute("scope"), "row", "Scope attribute didn't store the original value");
+td.setAttribute("colspan", "100k");
+is(td.getAttribute("colspan"), "100k", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", " 100 ");
+is(td.getAttribute("colspan"), " 100 ", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", "100");
+is(td.getAttribute("colspan"), "100", "Colspan attribute didn't store the original value");
+
+// Note, if colspan is negative, it is set to 1, because of backwards compatibility.
+// @see nsHTMLTableCellElement::ParseAttribute
+td.setAttribute("colspan", "-100k");
+is(td.getAttribute("colspan"), "1", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", " -100 ");
+is(td.getAttribute("colspan"), "1", "Colspan attribute didn't store the original value");
+td.setAttribute("colspan", "-100");
+is(td.getAttribute("colspan"), "1", "Colspan attribute didn't store the original value");
+
+
+td.setAttribute("colspan", "foobar");
+is(td.getAttribute("colspan"), "foobar", "Colspan attribute didn't store the original value");
+
+var iframe = document.createElement("iframe");
+iframe.setAttribute("marginwidth", "50%");
+is(iframe.getAttribute("marginwidth"), "50%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "50");
+is(iframe.getAttribute("marginwidth"), "50",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "0");
+is(iframe.getAttribute("marginwidth"), "0",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "0%");
+is(iframe.getAttribute("marginwidth"), "0%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "9999999999999999999999");
+is(iframe.getAttribute("marginwidth"), "9999999999999999999999",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "9999999999999999999999%");
+is(iframe.getAttribute("marginwidth"), "9999999999999999999999%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-9999999999999999999999");
+is(iframe.getAttribute("marginwidth"), "-9999999999999999999999",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-9999999999999999999999%");
+is(iframe.getAttribute("marginwidth"), "-9999999999999999999999%",
+   "Marginwidth attribute didn't store the original value");
+
+
+// Test PRInt32 min/max value
+iframe.setAttribute("marginwidth", "2147483647");
+is(iframe.getAttribute("marginwidth"), "2147483647",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "2147483647%");
+is(iframe.getAttribute("marginwidth"), "2147483647%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-2147483648");
+is(iframe.getAttribute("marginwidth"), "-2147483648",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-2147483648%");
+is(iframe.getAttribute("marginwidth"), "-2147483648%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "2147483646");
+is(iframe.getAttribute("marginwidth"), "2147483646",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "2147483647%");
+is(iframe.getAttribute("marginwidth"), "2147483647%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-2147483647");
+is(iframe.getAttribute("marginwidth"), "-2147483647",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-2147483647%");
+is(iframe.getAttribute("marginwidth"), "-2147483647%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "2147483648");
+is(iframe.getAttribute("marginwidth"), "2147483648",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "2147483648%");
+is(iframe.getAttribute("marginwidth"), "2147483648%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-2147483649");
+is(iframe.getAttribute("marginwidth"), "-2147483649",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-2147483649%");
+is(iframe.getAttribute("marginwidth"), "-2147483649%",
+   "Marginwidth attribute didn't store the original value");
+
+iframe.setAttribute("marginwidth", "-0");
+is(iframe.getAttribute("marginwidth"), "-0",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-0%");
+is(iframe.getAttribute("marginwidth"), "-0%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", " 0 ");
+is(iframe.getAttribute("marginwidth"), " 0 ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", " 0% ");
+is(iframe.getAttribute("marginwidth"), " 0% ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-50%");
+is(iframe.getAttribute("marginwidth"), "-50%",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "-50");
+is(iframe.getAttribute("marginwidth"), "-50",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", " -50% ");
+is(iframe.getAttribute("marginwidth"), " -50% ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", " -50 ");
+is(iframe.getAttribute("marginwidth"), " -50 ",
+   "Marginwidth attribute didn't store the original value");
+iframe.setAttribute("marginwidth", "foobar");
+is(iframe.getAttribute("marginwidth"), "foobar",
+   "Marginwidth attribute didn't store the original value");
+
+var bd = document.createElement("body");
+bd.setAttribute("bgcolor", "red");
+is(bd.getAttribute("bgcolor"), "red", "Bgcolor attribute didn't store the original value");
+bd.setAttribute("bgcolor", "  red  ");
+todo(bd.getAttribute("bgcolor") == "  red  ", "Bgcolor attribute didn't store the original value");
+td.setAttribute("colspan", "100k");
+is(td.getAttribute("colspan"), "100k", "Colspan attribute didn't store the original value");
+bd.setAttribute("bgcolor", "red");
+is(bd.bgColor, "#ff0000", ".bgColor didn't return the right value!");
+bd.setAttribute("bgcolor", "  red  ");
+is(bd.bgColor, "#ff0000", ".bgColor didn't return the right value!");
+bd.setAttribute("bgcolor", "#ff0000");
+is(bd.bgColor, "#ff0000", ".bgColor didn't return the right value!");
+</script>
+</pre>
+</body>
+</html>
+
