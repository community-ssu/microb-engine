Index: content/base/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/Makefile.in,v
retrieving revision 1.126
diff -u -8 -p -r1.126 Makefile.in
--- mozilla/content/base/src/Makefile.in	11 Apr 2008 17:29:06 -0000	1.126
+++ mozilla/content/base/src/Makefile.in	22 Apr 2008 04:12:12 -0000
@@ -141,16 +141,17 @@ CPPSRCS		= \
 		nsLineBreaker.cpp \
 		nsLoadListenerProxy.cpp \
 		nsMappedAttributeElement.cpp \
 		nsMappedAttributes.cpp \
 		nsNameSpaceManager.cpp \
 		nsNoDataProtocolContentPolicy.cpp \
 		nsNodeInfo.cpp \
 		nsNodeInfoManager.cpp \
+		nsNodeIterator.cpp \
 		nsNodeUtils.cpp \
 		nsObjectLoadingContent.cpp \
 		nsParserUtils.cpp \
 		nsPlainTextSerializer.cpp \
 		nsPropertyTable.cpp \
 		nsRange.cpp \
 		nsScriptElement.cpp \
 		nsScriptEventManager.cpp \
@@ -158,16 +159,17 @@ CPPSRCS		= \
 		nsStubDocumentObserver.cpp \
 		nsStubImageDecoderObserver.cpp \
 		nsStubMutationObserver.cpp \
 		nsStyledElement.cpp \
 		nsStyleLinkElement.cpp \
 		nsSyncLoadService.cpp \
 		nsTextFragment.cpp \
 		nsTextNode.cpp \
+		nsTraversal.cpp \
 		nsTreeWalker.cpp \
 		nsXMLContentSerializer.cpp \
 		nsXMLHttpRequest.cpp \
 		nsXMLNameSpaceMap.cpp \
 		$(NULL)
 
 GQI_SRCS = contentbase.gqi
 
Index: content/base/src/nsDocument.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsDocument.cpp,v
retrieving revision 3.819
diff -u -8 -p -r3.819 nsDocument.cpp
--- mozilla/content/base/src/nsDocument.cpp	14 Apr 2008 23:59:22 -0000	3.819
+++ mozilla/content/base/src/nsDocument.cpp	22 Apr 2008 04:12:12 -0000
@@ -80,16 +80,17 @@
 #include "nsNodeUtils.h"
 #include "nsLayoutUtils.h" // for GetFrameForPoint
 #include "nsIFrame.h"
 
 #include "nsRange.h"
 #include "nsIDOMText.h"
 #include "nsIDOMComment.h"
 #include "nsDOMDocumentType.h"
+#include "nsNodeIterator.h"
 #include "nsTreeWalker.h"
 
 #include "nsIServiceManager.h"
 
 #include "nsContentCID.h"
 #include "nsDOMError.h"
 #include "nsIPresShell.h"
 #include "nsPresContext.h"
@@ -3658,17 +3659,29 @@ nsDocument::CreateRange(nsIDOMRange** aR
 
 NS_IMETHODIMP
 nsDocument::CreateNodeIterator(nsIDOMNode *aRoot,
                                PRUint32 aWhatToShow,
                                nsIDOMNodeFilter *aFilter,
                                PRBool aEntityReferenceExpansion,
                                nsIDOMNodeIterator **_retval)
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  *_retval = nsnull;
+
+  if (!aRoot) {
+    return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
+  }
+
+  nsresult rv = nsContentUtils::CheckSameOrigin(this, aRoot);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return NS_NewNodeIterator(aRoot, aWhatToShow, aFilter,
+                            aEntityReferenceExpansion, _retval);
 }
 
 NS_IMETHODIMP
 nsDocument::CreateTreeWalker(nsIDOMNode *aRoot,
                              PRUint32 aWhatToShow,
                              nsIDOMNodeFilter *aFilter,
                              PRBool aEntityReferenceExpansion,
                              nsIDOMTreeWalker **_retval)
Index: content/base/src/nsNodeIterator.cpp
===================================================================
RCS file: content/base/src/nsNodeIterator.cpp
diff -N content/base/src/nsNodeIterator.cpp
--- mozilla//dev/null	1 Jan 1970 00:00:00 -0000
+++ mozilla/content/base/src/nsNodeIterator.cpp	22 Apr 2008 04:12:12 -0000
@@ -0,0 +1,346 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is this file as it was released on May 1 2001.
+ *
+ * The Initial Developer of the Original Code is
+ * Jonas Sicking.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Craig Topper <craig.topper@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/*
+ * Implementation of DOM Traversal's nsIDOMNodeIterator
+ */
+
+#include "nsNodeIterator.h"
+
+#include "nsIDOMNode.h"
+#include "nsIDOMNodeFilter.h"
+#include "nsDOMError.h"
+
+#include "nsIContent.h"
+#include "nsIDocument.h"
+
+#include "nsContentUtils.h"
+#include "nsMemory.h"
+#include "nsCOMArray.h"
+#include "nsGkAtoms.h"
+
+/*
+ * NodePointer implementation
+ */
+nsNodeIterator::NodePointer::NodePointer(nsINode *aNode,
+                                         PRBool aBeforeNode) :
+    mNode(aNode),
+    mBeforeNode(aBeforeNode)
+{ 
+}
+
+PRBool nsNodeIterator::NodePointer::moveToNext(nsINode *aRoot) {
+
+    if (mBeforeNode) {
+        mBeforeNode = PR_FALSE;
+        return PR_TRUE;
+    }
+
+    return moveForward(aRoot, mNode, -1);
+}
+
+PRBool nsNodeIterator::NodePointer::moveToPrevious(nsINode *aRoot) {
+
+    if (!mBeforeNode) {
+        mBeforeNode = PR_TRUE;
+        return PR_TRUE;
+    }
+
+    if (mNode == aRoot)
+        return PR_FALSE;
+
+    nsINode *parent = mNode->GetNodeParent();
+
+    moveBackward(parent, parent->IndexOf(mNode));
+
+    return PR_TRUE;
+}
+
+void nsNodeIterator::NodePointer::adjustAfterRemoval(nsINode* aRoot, nsINode *aContainer, nsIContent *aChild, PRInt32 aIndexInContainer) {
+
+    if (!mNode)
+        return;
+
+    if (!nsContentUtils::ContentIsDescendantOf(mNode, aChild))
+        return;
+
+    if (mBeforeNode) {
+
+        if (moveForward(aRoot, aContainer, aIndexInContainer-1))
+            return;
+
+        // No suitable node was found so try going backwards
+        mBeforeNode = PR_FALSE;
+    }
+
+    moveBackward(aContainer, aIndexInContainer);
+}
+
+PRBool nsNodeIterator::NodePointer::moveForward(nsINode *aRoot, nsINode *aParent, PRInt32 aChildNum) {
+
+    while (1) {
+        nsINode *sibling = aParent->GetChildAt(aChildNum+1);
+        if (sibling) {
+            mNode = sibling;
+            return PR_TRUE;
+        }
+
+        if (aParent == aRoot)
+            break;
+
+        nsINode *node = aParent;
+
+        aParent = node->GetNodeParent();
+
+        aChildNum = aParent->IndexOf(node);
+    }
+
+    return PR_FALSE;
+}
+
+void nsNodeIterator::NodePointer::moveBackward(nsINode *aParent, PRInt32 aChildNum) {
+    nsINode *sibling = aParent->GetChildAt(aChildNum-1);
+    if (sibling) {
+        nsINode* child;
+        do {
+            child = sibling->GetChildAt(sibling->GetChildCount()-1);
+            if (child)
+                sibling = child;
+        } while (child);
+
+        mNode = sibling;
+    } else {
+        mNode = aParent;
+    }
+}
+
+/*
+ * Factories, constructors and destructors
+ */
+
+nsresult
+NS_NewNodeIterator(nsIDOMNode *aRoot,
+                   PRUint32 aWhatToShow,
+                   nsIDOMNodeFilter *aFilter,
+                   PRBool aEntityReferenceExpansion,
+                   nsIDOMNodeIterator **aInstancePtrResult)
+{
+    NS_ENSURE_ARG_POINTER(aInstancePtrResult);
+
+    nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
+    NS_ENSURE_TRUE(root, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
+
+    nsNodeIterator *iterator = new nsNodeIterator(root,
+                                                  aWhatToShow,
+                                                  aFilter,
+                                                  aEntityReferenceExpansion);
+    NS_ENSURE_TRUE(iterator, NS_ERROR_OUT_OF_MEMORY);
+
+    return CallQueryInterface(iterator, aInstancePtrResult);
+}
+
+nsNodeIterator::nsNodeIterator(nsINode *aRoot,
+                               PRUint32 aWhatToShow,
+                               nsIDOMNodeFilter *aFilter,
+                               PRBool aExpandEntityReferences) :
+    nsTraversal(aRoot, aWhatToShow, aFilter, aExpandEntityReferences),
+    mDetached(PR_FALSE),
+    mPointer(mRoot, PR_TRUE)
+{
+    aRoot->AddMutationObserver(this);
+}
+
+nsNodeIterator::~nsNodeIterator()
+{
+    /* destructor code */
+    if (!mDetached && mRoot)
+        mRoot->RemoveMutationObserver(this);
+}
+
+/*
+ * nsISupports and cycle collection stuff
+ */
+
+NS_IMPL_CYCLE_COLLECTION_CLASS(nsNodeIterator)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsNodeIterator)
+    if (!tmp->mDetached && tmp->mRoot)
+        tmp->mRoot->RemoveMutationObserver(tmp);
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRoot)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFilter)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPointer.mNode)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mWorkingPointer.mNode)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsNodeIterator)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRoot)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFilter)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPointer.mNode)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mWorkingPointer.mNode)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
+// QueryInterface implementation for nsNodeIterator
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeIterator)
+    NS_INTERFACE_MAP_ENTRY(nsIDOMNodeIterator)
+    NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNodeIterator)
+    NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeIterator)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeIterator)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeIterator)
+
+/* readonly attribute nsIDOMNode root; */
+NS_IMETHODIMP nsNodeIterator::GetRoot(nsIDOMNode * *aRoot)
+{
+    if (mRoot)
+        return CallQueryInterface(mRoot, aRoot);
+
+    *aRoot = nsnull;
+
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long whatToShow; */
+NS_IMETHODIMP nsNodeIterator::GetWhatToShow(PRUint32 *aWhatToShow)
+{
+    *aWhatToShow = mWhatToShow;
+    return NS_OK;
+}
+
+/* readonly attribute nsIDOMNodeFilter filter; */
+NS_IMETHODIMP nsNodeIterator::GetFilter(nsIDOMNodeFilter **aFilter)
+{
+    NS_ENSURE_ARG_POINTER(aFilter);
+
+    nsCOMPtr<nsIDOMNodeFilter> filter = mFilter;
+    filter.swap((*aFilter = nsnull));
+
+    return NS_OK;
+}
+
+/* readonly attribute boolean expandEntityReferences; */
+NS_IMETHODIMP nsNodeIterator::GetExpandEntityReferences(PRBool *aExpandEntityReferences)
+{
+    *aExpandEntityReferences = mExpandEntityReferences;
+    return NS_OK;
+}
+
+/* nsIDOMNode nextNode ()  raises (DOMException); */
+NS_IMETHODIMP nsNodeIterator::NextNode(nsIDOMNode **_retval)
+{
+    nsresult rv;
+    PRInt16 filtered;
+
+    *_retval = nsnull;
+
+    if (mDetached)
+        return NS_ERROR_DOM_INVALID_STATE_ERR;
+
+    mWorkingPointer = mPointer;
+
+    while (mWorkingPointer.moveToNext(mRoot)) {
+        nsCOMPtr<nsINode> testNode = mWorkingPointer.mNode;
+        rv = TestNode(testNode, &filtered);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        if (filtered == nsIDOMNodeFilter::FILTER_ACCEPT) {
+            mPointer = mWorkingPointer;
+            mWorkingPointer.clear();
+            return CallQueryInterface(testNode, _retval);
+        }
+    }
+
+    mWorkingPointer.clear();
+    return NS_OK;
+}
+
+/* nsIDOMNode previousNode ()  raises (DOMException); */
+NS_IMETHODIMP nsNodeIterator::PreviousNode(nsIDOMNode **_retval)
+{
+    nsresult rv;
+    PRInt16 filtered;
+
+    *_retval = nsnull;
+
+    if (mDetached)
+        return NS_ERROR_DOM_INVALID_STATE_ERR;
+
+    mWorkingPointer = mPointer;
+
+    while (mWorkingPointer.moveToPrevious(mRoot)) {
+        nsCOMPtr<nsINode> testNode = mWorkingPointer.mNode;
+        rv = TestNode(testNode, &filtered);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        if (filtered == nsIDOMNodeFilter::FILTER_ACCEPT) {
+            mPointer = mWorkingPointer;
+            mWorkingPointer.clear();
+            return CallQueryInterface(testNode, _retval);
+        }
+    }
+
+    mWorkingPointer.clear();
+    return NS_OK;
+}
+
+/* void detach (); */
+NS_IMETHODIMP nsNodeIterator::Detach(void)
+{
+    mRoot->RemoveMutationObserver(this);
+
+    mPointer.clear();
+
+    mDetached = PR_TRUE;
+
+    return NS_OK;
+}
+
+/*
+ * nsNodeIterator helper functions
+ */
+
+void nsNodeIterator::ContentRemoved(nsIDocument *aDocument,
+                                    nsIContent *aContainer,
+                                    nsIContent *aChild,
+                                    PRInt32 aIndexInContainer)
+{
+    nsINode *container = NODE_FROM(aContainer, aDocument);
+
+    mPointer.adjustAfterRemoval(mRoot, container, aChild, aIndexInContainer);
+    mWorkingPointer.adjustAfterRemoval(mRoot, container, aChild, aIndexInContainer);
+}
Index: content/base/src/nsNodeIterator.h
===================================================================
RCS file: content/base/src/nsNodeIterator.h
diff -N content/base/src/nsNodeIterator.h
--- mozilla//dev/null	1 Jan 1970 00:00:00 -0000
+++ mozilla/content/base/src/nsNodeIterator.h	22 Apr 2008 04:12:13 -0000
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is this file as it was released on May 1 2001.
+ *
+ * The Initial Developer of the Original Code is
+ * Jonas Sicking.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Craig Topper <craig.topper@gmail.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+ 
+/*
+ * Implementation of DOM Traversal's nsIDOMNodeIterator
+ */
+
+#ifndef nsNodeIterator_h___
+#define nsNodeIterator_h___
+
+#include "nsIDOMNodeIterator.h"
+#include "nsTraversal.h"
+#include "nsCOMPtr.h"
+#include "nsCycleCollectionParticipant.h"
+#include "nsStubMutationObserver.h"
+
+class nsINode;
+class nsIDOMNode;
+class nsIDOMNodeFilter;
+
+class nsNodeIterator : public nsIDOMNodeIterator,
+                       public nsTraversal,
+                       public nsStubMutationObserver
+{
+public:
+    NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+    NS_DECL_NSIDOMNODEITERATOR
+
+    nsNodeIterator(nsINode *aRoot,
+                   PRUint32 aWhatToShow,
+                   nsIDOMNodeFilter *aFilter,
+                   PRBool aExpandEntityReferences);
+    virtual ~nsNodeIterator();
+
+    virtual void ContentRemoved(nsIDocument* aDocument,
+                                nsIContent* aContainer,
+                                nsIContent* aChild,
+                                PRInt32 aIndexInContainer);
+
+    NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsNodeIterator, nsIDOMNodeIterator)
+
+private:
+    class NodePointer {
+    public:
+        NodePointer() {};
+        NodePointer(nsINode *aNode, PRBool aBeforeNode);
+        PRBool moveToNext(nsINode *aRoot);
+        PRBool moveToPrevious(nsINode *aRoot);
+        void adjustAfterRemoval(nsINode *aRoot, nsINode *aContainer, nsIContent *aChild, PRInt32 aIndexInContainer);
+        void clear() { mNode = nsnull; }
+        nsCOMPtr<nsINode> mNode;
+    private:
+        PRBool moveForward(nsINode *aRoot, nsINode *aParent, PRInt32 aChildNum);
+        void moveBackward(nsINode *aParent, PRInt32 aChildNum);
+        PRBool mBeforeNode;
+    };
+
+    PRBool mDetached;
+    NodePointer mPointer;
+    NodePointer mWorkingPointer;
+};
+
+// Make a new nsIDOMNodeIterator object
+nsresult NS_NewNodeIterator(nsIDOMNode *aRoot,
+                            PRUint32 aWhatToShow,
+                            nsIDOMNodeFilter *aFilter,
+                            PRBool aEntityReferenceExpansion,
+                            nsIDOMNodeIterator **aInstancePtrResult);
+
+#endif
+
Index: content/base/src/nsTraversal.cpp
===================================================================
RCS file: content/base/src/nsTraversal.cpp
diff -N content/base/src/nsTraversal.cpp
--- mozilla//dev/null	1 Jan 1970 00:00:00 -0000
+++ mozilla/content/base/src/nsTraversal.cpp	22 Apr 2008 04:12:13 -0000
@@ -0,0 +1,122 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is this file as it was released on May 1 2001.
+ *
+ * The Initial Developer of the Original Code is
+ * Jonas Sicking.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Jonas Sicking <sicking@bigfoot.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsTraversal.h"
+
+#include "nsIDOMNode.h"
+#include "nsIDOMNodeFilter.h"
+#include "nsDOMError.h"
+
+#include "nsIContent.h"
+
+#include "nsGkAtoms.h"
+
+nsTraversal::nsTraversal(nsINode *aRoot,
+                         PRUint32 aWhatToShow,
+                         nsIDOMNodeFilter *aFilter,
+                         PRBool aExpandEntityReferences) :
+    mRoot(aRoot),
+    mWhatToShow(aWhatToShow),
+    mFilter(aFilter),
+    mExpandEntityReferences(aExpandEntityReferences)
+{
+    NS_ASSERTION(aRoot, "invalid root in call to nsTraversal constructor");
+}
+
+nsTraversal::~nsTraversal()
+{
+    /* destructor code */
+}
+
+/*
+ * Tests if and how a node should be filtered. Uses mWhatToShow and
+ * mFilter to test the node.
+ * @param aNode     Node to test
+ * @param _filtered Returned filtervalue. See nsIDOMNodeFilter.idl
+ * @returns         Errorcode
+ */
+nsresult nsTraversal::TestNode(nsINode* aNode, PRInt16* _filtered)
+{
+    nsresult rv;
+
+    *_filtered = nsIDOMNodeFilter::FILTER_SKIP;
+
+    PRUint16 nodeType = 0;
+    // Check the most common cases
+    if (aNode->IsNodeOfType(nsINode::eELEMENT)) {
+        nodeType = nsIDOMNode::ELEMENT_NODE;
+    }
+    else if (aNode->IsNodeOfType(nsINode::eCONTENT)) {
+        nsIAtom* tag = static_cast<nsIContent*>(aNode)->Tag();
+        if (tag == nsGkAtoms::textTagName) {
+            nodeType = nsIDOMNode::TEXT_NODE;
+        }
+        else if (tag == nsGkAtoms::cdataTagName) {
+            nodeType = nsIDOMNode::CDATA_SECTION_NODE;
+        }
+        else if (tag == nsGkAtoms::commentTagName) {
+            nodeType = nsIDOMNode::COMMENT_NODE;
+        }
+        else if (tag == nsGkAtoms::processingInstructionTagName) {
+            nodeType = nsIDOMNode::PROCESSING_INSTRUCTION_NODE;
+        }
+    }
+
+    nsCOMPtr<nsIDOMNode> domNode;
+    if (!nodeType) {
+        domNode = do_QueryInterface(aNode);
+        rv = domNode->GetNodeType(&nodeType);
+        NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    if (nodeType <= 12 && !((1 << (nodeType-1)) & mWhatToShow)) {
+        return NS_OK;
+    }
+
+    if (mFilter) {
+        if (!domNode) {
+            domNode = do_QueryInterface(aNode);
+        }
+
+        return mFilter->AcceptNode(domNode, _filtered);
+    }
+
+    *_filtered = nsIDOMNodeFilter::FILTER_ACCEPT;
+    return NS_OK;
+}
Index: content/base/src/nsTraversal.h
===================================================================
RCS file: content/base/src/nsTraversal.h
diff -N content/base/src/nsTraversal.h
--- mozilla//dev/null	1 Jan 1970 00:00:00 -0000
+++ mozilla/content/base/src/nsTraversal.h	22 Apr 2008 04:12:13 -0000
@@ -0,0 +1,79 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is this file as it was released on May 1 2001.
+ *
+ * The Initial Developer of the Original Code is
+ * Jonas Sicking.
+ * Portions created by the Initial Developer are Copyright (C) 2001
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Jonas Sicking <sicking@bigfoot.com> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+ 
+/*
+ * Implementation of DOM Traversal's nsIDOMTreeWalker
+ */
+
+#ifndef nsTraversal_h___
+#define nsTraversal_h___
+
+#include "nsCOMPtr.h"
+
+class nsINode;
+class nsIDOMNode;
+class nsIDOMNodeFilter;
+
+class nsTraversal
+{
+public:
+    nsTraversal(nsINode *aRoot,
+                PRUint32 aWhatToShow,
+                nsIDOMNodeFilter *aFilter,
+                PRBool aExpandEntityReferences);
+    virtual ~nsTraversal();
+
+protected:
+    nsCOMPtr<nsINode> mRoot;
+    PRUint32 mWhatToShow;
+    nsCOMPtr<nsIDOMNodeFilter> mFilter;
+    PRBool mExpandEntityReferences;
+
+    /*
+     * Tests if and how a node should be filtered. Uses mWhatToShow and
+     * mFilter to test the node.
+     * @param aNode     Node to test
+     * @param _filtered Returned filtervalue. See nsIDOMNodeFilter.idl
+     * @returns         Errorcode
+     */
+    nsresult TestNode(nsINode* aNode, PRInt16* _filtered);
+};
+
+#endif
+
Index: content/base/src/nsTreeWalker.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsTreeWalker.cpp,v
retrieving revision 1.24
diff -u -8 -p -r1.24 nsTreeWalker.cpp
--- mozilla/content/base/src/nsTreeWalker.cpp	9 Feb 2008 18:05:13 -0000	1.24
+++ mozilla/content/base/src/nsTreeWalker.cpp	22 Apr 2008 04:12:13 -0000
@@ -79,24 +79,20 @@ NS_NewTreeWalker(nsIDOMNode *aRoot,
 
     return CallQueryInterface(walker, aInstancePtrResult);
 }
 
 nsTreeWalker::nsTreeWalker(nsINode *aRoot,
                            PRUint32 aWhatToShow,
                            nsIDOMNodeFilter *aFilter,
                            PRBool aExpandEntityReferences) :
-    mRoot(aRoot),
-    mWhatToShow(aWhatToShow),
-    mFilter(aFilter),
-    mExpandEntityReferences(aExpandEntityReferences),
+    nsTraversal(aRoot, aWhatToShow, aFilter, aExpandEntityReferences),
     mCurrentNode(aRoot),
     mPossibleIndexesPos(-1)
 {
-    NS_ASSERTION(aRoot, "invalid root in call to nsTreeWalker constructor");
 }
 
 nsTreeWalker::~nsTreeWalker()
 {
     /* destructor code */
 }
 
 /*
@@ -568,73 +564,16 @@ nsTreeWalker::ChildOf(nsINode* aNode,
         }
     }
 
     *_retval = nsnull;
     return NS_OK;
 }
 
 /*
- * Tests if and how a node should be filtered. Uses mWhatToShow and
- * mFilter to test the node.
- * @param aNode     Node to test
- * @param _filtered Returned filtervalue. See nsIDOMNodeFilter.idl
- * @returns         Errorcode
- */
-nsresult nsTreeWalker::TestNode(nsINode* aNode, PRInt16* _filtered)
-{
-    nsresult rv;
-
-    *_filtered = nsIDOMNodeFilter::FILTER_SKIP;
-
-    PRUint16 nodeType = 0;
-    // Check the most common cases
-    if (aNode->IsNodeOfType(nsINode::eELEMENT)) {
-        nodeType = nsIDOMNode::ELEMENT_NODE;
-    }
-    else if (aNode->IsNodeOfType(nsINode::eCONTENT)) {
-        nsIAtom* tag = static_cast<nsIContent*>(aNode)->Tag();
-        if (tag == nsGkAtoms::textTagName) {
-            nodeType = nsIDOMNode::TEXT_NODE;
-        }
-        else if (tag == nsGkAtoms::cdataTagName) {
-            nodeType = nsIDOMNode::CDATA_SECTION_NODE;
-        }
-        else if (tag == nsGkAtoms::commentTagName) {
-            nodeType = nsIDOMNode::COMMENT_NODE;
-        }
-        else if (tag == nsGkAtoms::processingInstructionTagName) {
-            nodeType = nsIDOMNode::PROCESSING_INSTRUCTION_NODE;
-        }
-    }
-
-    nsCOMPtr<nsIDOMNode> domNode;
-    if (!nodeType) {
-        domNode = do_QueryInterface(aNode);
-        rv = domNode->GetNodeType(&nodeType);
-        NS_ENSURE_SUCCESS(rv, rv);
-    }
-
-    if (nodeType <= 12 && !((1 << (nodeType-1)) & mWhatToShow)) {
-        return NS_OK;
-    }
-
-    if (mFilter) {
-        if (!domNode) {
-            domNode = do_QueryInterface(aNode);
-        }
-
-        return mFilter->AcceptNode(domNode, _filtered);
-    }
-
-    *_filtered = nsIDOMNodeFilter::FILTER_ACCEPT;
-    return NS_OK;
-}
-
-/*
  * Gets the child index of a node within it's parent. Gets a possible index
  * from mPossibleIndexes to gain speed. If the value in mPossibleIndexes
  * isn't correct it'll get the index the usual way
  * @param aParent   in which to get the index
  * @param aChild    node to get the index of
  * @param aIndexPos position in mPossibleIndexes that contains the possible.
  *                  index
  * @returns         resulting index
Index: content/base/src/nsTreeWalker.h
===================================================================
RCS file: /cvsroot/mozilla/content/base/src/nsTreeWalker.h,v
retrieving revision 1.12
diff -u -8 -p -r1.12 nsTreeWalker.h
--- mozilla/content/base/src/nsTreeWalker.h	9 Feb 2008 18:05:14 -0000	1.12
+++ mozilla/content/base/src/nsTreeWalker.h	22 Apr 2008 04:12:13 -0000
@@ -40,44 +40,41 @@
 /*
  * Implementation of DOM Traversal's nsIDOMTreeWalker
  */
 
 #ifndef nsTreeWalker_h___
 #define nsTreeWalker_h___
 
 #include "nsIDOMTreeWalker.h"
+#include "nsTraversal.h"
 #include "nsCOMPtr.h"
 #include "nsVoidArray.h"
 #include "nsJSUtils.h"
 #include "nsCycleCollectionParticipant.h"
 
 class nsINode;
 class nsIDOMNode;
 class nsIDOMNodeFilter;
 
-class nsTreeWalker : public nsIDOMTreeWalker
+class nsTreeWalker : public nsIDOMTreeWalker, public nsTraversal
 {
 public:
     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
     NS_DECL_NSIDOMTREEWALKER
 
     nsTreeWalker(nsINode *aRoot,
                  PRUint32 aWhatToShow,
                  nsIDOMNodeFilter *aFilter,
                  PRBool aExpandEntityReferences);
     virtual ~nsTreeWalker();
 
     NS_DECL_CYCLE_COLLECTION_CLASS(nsTreeWalker)
 
 private:
-    nsCOMPtr<nsINode> mRoot;
-    PRUint32 mWhatToShow;
-    nsCOMPtr<nsIDOMNodeFilter> mFilter;
-    PRBool mExpandEntityReferences;
     nsCOMPtr<nsINode> mCurrentNode;
     
     /*
      * Array with all child indexes up the tree. This should only be
      * considered a hint and the value could be wrong.
      * The array contains casted PRInt32's
      */
     nsAutoVoidArray mPossibleIndexes;
@@ -146,25 +143,16 @@ private:
      */
     nsresult ChildOf(nsINode* aNode,
                      PRInt32 childNum,
                      PRBool aReversed,
                      PRInt32 aIndexPos,
                      nsINode** _retval);
 
     /*
-     * Tests if and how a node should be filtered. Uses mWhatToShow and
-     * mFilter to test the node.
-     * @param aNode     Node to test
-     * @param _filtered Returned filtervalue. See nsIDOMNodeFilter.idl
-     * @returns         Errorcode
-     */
-    nsresult TestNode(nsINode* aNode, PRInt16* _filtered);
-    
-    /*
      * Gets the child index of a node within it's parent. Gets a possible index
      * from mPossibleIndexes to gain speed. If the value in mPossibleIndexes
      * isn't correct it'll get the index the usual way.
      * @param aParent   in which to get the index
      * @param aChild    node to get the index of
      * @param aIndexPos position in mPossibleIndexes that contains the possible.
      *                  index
      * @returns         resulting index
Index: dom/public/nsDOMClassInfoID.h
===================================================================
RCS file: /cvsroot/mozilla/dom/public/nsDOMClassInfoID.h,v
retrieving revision 1.35
diff -u -8 -p -r1.35 nsDOMClassInfoID.h
--- mozilla/dom/public/nsDOMClassInfoID.h	12 Mar 2008 00:51:12 -0000	1.35
+++ mozilla/dom/public/nsDOMClassInfoID.h	22 Apr 2008 04:12:15 -0000
@@ -419,16 +419,19 @@ enum nsDOMClassInfoID {
 
   // Data Events
   eDOMClassInfo_DataContainerEvent_id,
 
   // event used for cross-domain message-passing and for server-sent events in
   // HTML5
   eDOMClassInfo_MessageEvent_id,
 
+  // DOM Traversal NodeIterator class
+  eDOMClassInfo_NodeIterator_id,
+
   // This one better be the last one in this list
   eDOMClassInfoIDCount
 };
 
 /**
  * nsIClassInfo helper macros
  */
 
Index: dom/src/base/nsDOMClassInfo.cpp
===================================================================
RCS file: /cvsroot/mozilla/dom/src/base/nsDOMClassInfo.cpp,v
retrieving revision 1.541
diff -u -8 -p -r1.541 nsDOMClassInfo.cpp
--- mozilla/dom/src/base/nsDOMClassInfo.cpp	18 Mar 2008 20:42:19 -0000	1.541
+++ mozilla/dom/src/base/nsDOMClassInfo.cpp	22 Apr 2008 04:12:16 -0000
@@ -320,16 +320,17 @@
 #include "nsIDOMCSSMozDocumentRule.h"
 #include "nsIDOMCSSPrimitiveValue.h"
 #include "nsIDOMCSSStyleRule.h"
 #include "nsIDOMCSSStyleSheet.h"
 #include "nsIDOMCSSValueList.h"
 #include "nsIDOMRange.h"
 #include "nsIDOMNSRange.h"
 #include "nsIDOMRangeException.h"
+#include "nsIDOMNodeIterator.h"
 #include "nsIDOMTreeWalker.h"
 #include "nsIDOMXULDocument.h"
 #include "nsIDOMXULElement.h"
 #include "nsIDOMXULCommandDispatcher.h"
 #include "nsIDOMCrypto.h"
 #include "nsIDOMCRMFObject.h"
 #include "nsIDOMPkcs11.h"
 #include "nsIControllers.h"
@@ -1227,16 +1228,20 @@ static nsDOMClassInfoData sClassInfoData
                            DEFAULT_SCRIPTABLE_FLAGS |
                            WINDOW_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(DataContainerEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(MessageEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
+
+  // DOM Traversal NodeIterator class  
+  NS_DEFINE_CLASSINFO_DATA(NodeIterator, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
 };
 
 // Objects that shuld be constructable through |new Name();|
 struct nsContractIDMapData
 {
   PRInt32 mDOMClassInfoID;
   const char *mContractID;
 };
@@ -2466,16 +2471,20 @@ nsDOMClassInfo::Init()
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNSRGBAColor)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(Range, nsIDOMRange)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMRange)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMNSRange)
   DOM_CLASSINFO_MAP_END
 
+  DOM_CLASSINFO_MAP_BEGIN(NodeIterator, nsIDOMNodeIterator)
+    DOM_CLASSINFO_MAP_ENTRY(nsIDOMNodeIterator)
+  DOM_CLASSINFO_MAP_END
+
   DOM_CLASSINFO_MAP_BEGIN(TreeWalker, nsIDOMTreeWalker)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMTreeWalker)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(Selection, nsISelection)
     DOM_CLASSINFO_MAP_ENTRY(nsISelection)
   DOM_CLASSINFO_MAP_END
 
