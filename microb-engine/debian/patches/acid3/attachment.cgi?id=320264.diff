#https://bugzilla.mozilla.org/show_bug.cgi?id=216462
Index: mozilla/Makefile.in
===================================================================
--- mozilla.orig/Makefile.in
+++ mozilla/Makefile.in
@@ -63,16 +63,20 @@
 	$(NULL)
 
 ifdef MOZ_MEMORY
 tier_base_dirs += memory/jemalloc
 endif
 
 include $(topsrcdir)/$(MOZ_BUILD_APP)/build.mk
 
+ifdef MOZ_SMIL
+DIRS		+= smil
+endif
+
 TIERS += testharness
 
 # test harnesses
 ifdef ENABLE_TESTS
 tier_testharness_dirs += tools/test-harness
 endif
 
 GARBAGE_DIRS += dist _javagen _profile _tests staticlib
Index: mozilla/smil/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/smil/Makefile.in
@@ -0,0 +1,48 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+DIRS		= public src
+
+include $(topsrcdir)/config/rules.mk
+
Index: mozilla/smil/public/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/smil/public/Makefile.in
@@ -0,0 +1,64 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH           = ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= content
+
+EXPORTS		= \
+	  nsISMILAttr.h \
+	  nsISMILAnimationController.h \
+	  nsISMILAnimationFunction.h \
+	  nsISMILAnimationObserver.h \
+	  nsISMILAnimationRegistry.h \
+	  nsISMILComposable.h \
+	  nsISMILTimeClient.h \
+	  nsISMILTimeContainer.h \
+	  nsISMILTimedElement.h \
+	  nsISMILType.h \
+	  nsSMILValue.h \
+	  nsSMILFloatType.h \
+	  nsSMILNullType.h \
+	  $(NULL)
+
+include $(topsrcdir)/config/rules.mk
+
Index: mozilla/smil/public/nsISMILAnimationController.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILAnimationController.h
@@ -0,0 +1,78 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONCONTROLLER_H__
+#define __NS_ISMILANIMATIONCONTROLLER_H__
+
+#include "nsIAnimationController.h"
+
+#define NS_ISMILANIMATIONCONTROLLER_IID \
+{ 0xd2c81398, 0x1f30, 0x4303, { 0xbe, 0xbe, 0xc5, 0x0c, 0x01, 0xfd, 0xd8, 0x85 } }
+
+class nsISMILTimeContainer;
+class nsIDocument;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAnimationController: Animation controller
+
+class nsISMILAnimationController : public nsIAnimationController
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONCONTROLLER_IID)
+
+  // nsIAnimationController methods
+  virtual nsresult  Pause()=0;
+  virtual nsresult  Resume()=0;
+  virtual nsresult  Reset()=0;
+
+  //
+  // Eventually, this will probably be all nsISMILTimedElements so that it is
+  // possible to have hierarchies of containers (which will implement
+  // nsISMILTimedElement), and then these methods will be replaced with
+  // SetRootElement.
+  //
+  virtual nsresult  AddTimeContainer(nsISMILTimeContainer* aContainer)=0;
+  virtual nsresult  RemoveTimeContainer(nsISMILTimeContainer* aContainer)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationController,
+                              NS_ISMILANIMATIONCONTROLLER_IID)
+
+nsISMILAnimationController* NS_NewSMILAnimationController(nsIDocument *doc);
+
+#endif // __NS_ISMILANIMATIONCONTROLLER_H__
+
Index: mozilla/smil/public/nsISMILAnimationFunction.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILAnimationFunction.h
@@ -0,0 +1,109 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONFUNCTION_H__
+#define __NS_ISMILANIMATIONFUNCTION_H__
+
+#include "nsISupports.h"
+
+class nsISMILAttr;
+class nsIAtom;
+
+// {14eb1aab-e4ba-4c77-be89-195ef975c90d}
+#define NS_ISMILANIMATIONFUNCTION_IID \
+{ 0x14eb1aab, 0xe4ba, 0x4c77, { 0xbe, 0x89, 0x19, 0x5e, 0xf9, 0x75, 0xc9, 0x0d } }
+
+/**
+ * Provides the animation function for an interpolating animation element. This
+ * includes the animation-related attributes. It is intended to be used by
+ * elements such as <animate>, <animateColor> and so on.
+ *
+ * It will likely be split into nsISMILInterpolatingAnimFunc and
+ * nsISMILSimpleAnimFunc when <set> is introduced. Extra parameters or perhaps
+ * a subclass will probably be needed to support <animateTransform>,
+ * <animateMotion> and the like.
+ */
+class nsISMILAnimationFunction : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONFUNCTION_IID)
+
+  virtual nsresult         SetTargetAttribute(nsISMILAttr* aAttribute)=0;
+  virtual nsISMILAttr*     GetTargetAttribute()=0;
+  virtual void             SetDocumentPosition(PRUint16 aDocPosition)=0;
+
+  /**
+   * Attempts to set an attribute on this animation function.
+   *
+   * @param aAttribute  The name of the attribute to set. The namespace of this
+   *                    attribute is not specified as it is checked by the host
+   *                    element. Only attributes in the namespace defined for
+   *                    SMIL attributes in the host language are passed to the
+   *                    animation function.
+   *
+   * @param aValue      The attribute value.
+   *
+   * @param[out] aResult
+   *                    The result of parsing the attribute. May be nsnull. Only
+   *                    used for unit testing.
+   *
+   * @return PR_TRUE if the given attribute is an animation attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool           SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                                   nsresult* aResult = nsnull)=0;
+
+  /**
+   * Attempts to unset an attribute on this animation function.
+   *
+   * @param aAttribute  The name of the attribute to set. As with SetAttr the
+   *                    namespace of the attribute is not specified (see
+   *                    SetAttr).
+   *
+   * @return PR_TRUE if the given attribute is an animation attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool           UnsetAttr(nsIAtom* aAttribute)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationFunction,
+                              NS_ISMILANIMATIONFUNCTION_IID)
+
+nsISMILAnimationFunction* NS_NewSMILAnimationFunction();
+
+#endif //__NS_ISMILANIMATIONFUNCTION_H__
+
Index: mozilla/smil/public/nsISMILAnimationObserver.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILAnimationObserver.h
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONOBSERVER_H__
+#define __NS_ISMILANIMATIONOBSERVER_H__
+
+#include "nsISupports.h"
+#include "nsWeakReference.h"
+
+#define NS_ISMILANIMATIONOBSERVER_IID \
+{ 0x8f96dd0c, 0x9c70, 0x4b3a, { 0xa0, 0x72, 0xce, 0x71, 0x0f, 0x47, 0xa0, 0x06 } }
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAnimationObserver: Interfaces for clients that want to be informed of
+//                           stages in the animation's life cycle
+
+class nsISMILAnimationObserver : public nsSupportsWeakReference
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONOBSERVER_IID)
+
+  virtual void      StartSample()=0;
+  virtual void      StartCompositing()=0;
+  virtual void      EndCompositing()=0;
+  virtual void      EndSample()=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationObserver,
+                              NS_ISMILANIMATIONOBSERVER_IID)
+
+#endif // __NS_ISMILANIMATIONOBSERVER_H__
+
Index: mozilla/smil/public/nsISMILAnimationRegistry.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILAnimationRegistry.h
@@ -0,0 +1,158 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILANIMATIONREGISTRY_H__
+#define __NS_ISMILANIMATIONREGISTRY_H__
+
+#include "nsISupports.h"
+
+class nsISMILAnimationController;
+class nsISMILAnimationObserver;
+class nsISMILComposable;
+class nsISMILAttr;
+class nsISMILTimedElement;
+
+#define NS_ISMILANIMATIONREGISTRY_IID \
+{ 0xdd3c7124, 0xcc1f, 0x447b, { 0xa1, 0x35, 0x4a, 0xd8, 0xfc, 0xd4, 0x9f, 0x31 } }
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAnimationRegistry: Entry point for SMIL animated documents
+
+class nsISMILAnimationRegistry : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILANIMATIONREGISTRY_IID)
+
+  /**
+   * Sets the animation controller which is needed for registering the time
+   * container managed by this registry.
+   *
+   * @param aController The animation controller. May be nsnull to disassociate
+   *                    this registry from any controller.
+   */
+  virtual nsresult  SetController(nsISMILAnimationController* aController)=0;
+
+  /**
+   * Sets the object which will be notified each time a sample begins and ends
+   * and when compositing takes place. Currently only one observer can be set at
+   * a time.
+   *
+   * @param aObserver The observer to receive notifications. May be nsnull to
+   *                  remove the currently set observer if any.
+   */
+  virtual void      SetObserver(nsISMILAnimationObserver* aObserver)=0;
+
+  /*
+   * The next six methods correspond to methods in the nsIDOMSVGSVGElement
+   * interface.
+   */
+
+  /**
+   * Starts animation. After creating the registry this method needs to be
+   * called before animation starts. This allows more precise control over when
+   * the animation starts allowing the registry to be created and set up but
+   * only started when the conditions are right.
+   */
+  virtual nsresult  Start()=0;
+
+  /**
+   * Pauses animation.
+   */
+  virtual void      Pause()=0;
+
+  /**
+   * Unpauses animation.
+   */
+  virtual void      Unpause()=0;
+
+  /**
+   * @return true if the animation is in a paused state.
+   */
+  virtual PRBool    IsPaused()=0;
+
+  /**
+   * Returns the current time in seconds relative to the start time of the
+   * animation.
+   */
+  virtual float     GetCurrentTime()=0;
+
+  /**
+   * Adjusts the clock for the animation to the specified time.
+   *
+   * @param aSeconds  The new current time in seconds relative to the start time
+   *                  for this animation.
+   */
+  virtual nsresult  SetCurrentTime(float aSeconds)=0;
+
+  /**
+   * Registers a composable object with the compositor for the specified target
+   * attribute. The composable object may be registered with several target
+   * attributes and each target attribute may have several composable objects
+   * associated with it.
+   */
+  virtual nsresult  RegisterComposable(nsISMILAttr* aTargetAttr,
+                                       nsISMILComposable* aComposable)=0;
+
+  /**
+   * Removes the specified composable object from all compositors with which is
+   * it registered.
+   */
+  virtual nsresult  UnregisterComposable(nsISMILComposable* aComposable)=0;
+
+  /**
+   * Registers the timed element with the time container managed by this
+   * registry.
+   */
+  virtual nsresult  RegisterTimedElement(nsISMILTimedElement* aElement)=0;
+
+  /**
+   * Unregisters the timed element from the time container managed by this
+   * registry.
+   */
+  virtual nsresult  UnregisterTimedElement(nsISMILTimedElement* aElement)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILAnimationRegistry,
+                              NS_ISMILANIMATIONREGISTRY_IID)
+
+/**
+ * Creates a new animation registry object.
+ */
+nsISMILAnimationRegistry* NS_NewSMILAnimationRegistry();
+
+#endif // __NS_ISMILANIMATIONREGISTRY_H__
+
Index: mozilla/smil/public/nsISMILAttr.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILAttr.h
@@ -0,0 +1,121 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILATTR_H__
+#define __NS_ISMILATTR_H__
+
+#include "nscore.h"
+#include "nsStringFwd.h"
+
+struct nsSMILValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILAttr: Interfaces for data types that can have a base and animated
+//                  value.
+
+/**
+ * Interfaces for data types that can have a base and animated value.
+ */
+class nsISMILAttr
+{
+public:
+  /**
+   * Gets the underlying value of this attribute.
+   *
+   * @param aValue  The value to fill.
+   * @return NS_OK on success or an error code if getting failed.
+   */
+  virtual nsresult  GetBaseValue(nsSMILValue& aValue) = 0;
+
+  /**
+   * Sets the presentation value of this attribute.
+   *
+   * @param aValue  The value to set.
+   * @return NS_OK on success or an error code if setting failed.
+   */
+  virtual nsresult  SetAnimValue(const nsSMILValue& aValue) = 0;
+
+  /**
+   * Creates a new nsSMILValue from the given specification.
+   *
+   * @param aStr    A string defining the new value to be created.
+   * @param aValue  The value to assign to.
+   * @return NS_OK on success or an error code if creation failed.
+   */
+  virtual nsresult  ValueFromString(const nsAString& aStr,
+                                    nsSMILValue& aValue) = 0;
+
+  /**
+   * Returns true if this animation attribute refers to the same content
+   * attribute as aOther.
+   *
+   * This is necessary because sometimes independent nsISMILAttr's are created
+   * that refer to the same attribute as it is too costly to cache previously
+   * created attributes. Caching these attributes might require an extra pointer
+   * member on each animatable data type or on each nsIContent object that can
+   * be animated.
+   *
+   * @return PR_TRUE if the attributes refer to the same target. PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool EqualTarget(const nsISMILAttr &aOther) const = 0;
+
+  // Ref-counting
+  nsrefcnt AddRef() { return ++mRefCnt; }
+  nsrefcnt Release() {
+    --mRefCnt;
+    if (mRefCnt == 0) {
+      mRefCnt = 1; // stabilize
+      delete this;
+      return 0;
+    }
+    return mRefCnt;
+  }
+
+  /**
+   * DIY RTTI
+   */
+  void* mType;
+
+protected:
+  nsISMILAttr(void* aType) : mType(aType), mRefCnt(0) {}
+
+  PRUint32 mRefCnt;
+};
+
+#endif // __NS_ISMILATTR_H__
+
Index: mozilla/smil/public/nsISMILComposable.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILComposable.h
@@ -0,0 +1,142 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILCOMPOSABLE_H__
+#define __NS_ISMILCOMPOSABLE_H__
+
+#include "nsISupports.h"
+#include "nsWeakReference.h"
+
+struct nsSMILValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILComposable : Interface for animations that can be composited
+//                     by the compositor
+
+// {4b05aa22-712e-4a9e-8452-f7c4b2e507e7}
+#define NS_ISMILCOMPOSABLE_IID \
+{ 0x4b05aa22, 0x712e, 0x4a9e, { 0x84, 0x52, 0xf7, 0xc4, 0xb2, 0xe5, 0x07, 0xe7 } }
+
+class nsISMILComposable : public nsSupportsWeakReference
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILCOMPOSABLE_IID)
+
+  /**
+   * Combines the result of this animation function for the last sample with the
+   * specified value.
+   *
+   * @param aResult The value to compose with.
+   */
+  virtual void      ComposeResult(nsSMILValue &aResult)=0;
+
+  /**
+   * Returns the relative priority of this animation to another. The priority is
+   * used for determining the position of the animation in the animation
+   * sandwich.
+   *
+   * @return  -1 if this animation has lower priority or 1 if this animation has
+   *          higher priority
+   *
+   * This method should never return any other value including 0.
+   */
+  virtual PRInt8    CompareTo(const nsISMILComposable& composable) const=0;
+
+  /*
+   * The following methods are used in sorting.
+   */
+
+  /**
+   * Returns the begin time of this animation for the interval it is currently
+   * animating. For inactive animations this will be LL_MinInt but such
+   * animations should be filtered from compositing anyway.
+   *
+   * The time returned is in document time. This is used for sorting as
+   * animations that start later have a higher priority (SMILANIM 3.3.6).
+   *
+   * @return  A 64-bit integer representing the begin time of this animation.
+   */
+  virtual const PRInt64&  GetBeginTime() const=0;
+
+  /**
+   * Returns a unique (0-based) index indicating the position of this animation
+   * in the document. The first animation will have index 0 as so on. Positions
+   * are recalculated when the document structure is changed.
+   *
+   * @return  An unsigned integer representing this animation's position in the
+   *          document.
+   */
+  virtual PRUint16   GetDocumentPosition() const=0;
+
+  /*
+   * The following methods are provided so that the compositor can optimise its
+   * operations by only composing those animation that will affect the final
+   * result.
+   */
+
+  /**
+   * Indicates if the animation is currently active. Inactive animations will
+   * not contribute to the composed result.
+   *
+   * @return  True if the animation active, false otherwise.
+   */
+  virtual PRBool    IsActive() const=0;
+
+  /**
+   * Indicates if this animation will replace the passed in result rather than
+   * adding to it. Animations that replace the underlying value may be called
+   * without first calling lower priority animations.
+   *
+   * @return  True if the animation will replace, false if it will add or
+   *          otherwise build on the passed in value.
+   */
+  virtual PRBool    WillReplace() const=0;
+
+  /**
+   * Indicates if the parameters for this animation have changed since the last
+   * time it was composited. This allows rendering to be performed only when
+   * necessary, particularly when no animations are active.
+   *
+   * @return  True if the animation parameters have changed, false otherwise.
+   */
+  virtual PRBool    HasChanged() const=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILComposable, NS_ISMILCOMPOSABLE_IID)
+
+#endif // __NS_ISMILCOMPOSABLE_H__
+
Index: mozilla/smil/public/nsISMILTimeClient.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILTimeClient.h
@@ -0,0 +1,108 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMECLIENT_H__
+#define __NS_ISMILTIMECLIENT_H__
+
+#include "nsISupports.h"
+
+class nsSMILTimeValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimeClient
+
+// {196f66f4-e6f6-420b-a337-da42a2efccde}
+#define NS_ISMILTIMECLIENT_IID \
+{ 0x196f66f4, 0xe6f6, 0x420b, { 0xa3, 0x37, 0xda, 0x42, 0xa2, 0xef, 0xcc, 0xde } }
+
+class nsISMILTimeClient : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMECLIENT_IID)
+
+  /**
+   * Indicate a new sample has occurred.
+   *
+   * @param aSimpleTime The sample time for this timed element expressed in
+   *                    simple time.
+   * @param aSimpleDuration The simple duration for this timed element.
+   * @param aRepeatIteration  The repeat iteration for this sample. The first
+   *                          iteration has a value of 0.
+   */
+  virtual void      SampleAt(const PRInt64& aSimpleTime,
+                             const nsSMILTimeValue& aSimpleDuration,
+                             const PRUint32& aRepeatIteration)=0;
+
+  /**
+   * Indicate to sample using the last value defined for the animation function.
+   * This value is not normally sampled due to the end-point exclusive timing
+   * model but only occurs when the fill mode is "freeze" and the active
+   * duration is an even multiple of the simple duration.
+   *
+   * @param aRepeatIteration  The repeat iteration for this sample. The first
+   *                          iteration has a value of 0.
+   */
+  virtual void      SampleLastValue(const PRUint32& aRepeatIteration)=0;
+
+  /**
+   * Indicate that the timed element is now active. This is used, for example,
+   * to instruct the animation function that it should now add its result to the
+   * animation sandwich. The begin time is also provided for proper
+   * prioritisation of animation functions and for this reason this method must
+   * be called before either of the Sample methods.
+   *
+   * @param aBeginTime The begin time for the newly active interval.
+   */
+  virtual void      ToActive(const PRInt64& aBeginTime)=0;
+
+  /**
+   * Indicate that the timed element is no longer active. This is used, for
+   * example, to instruct the animation function that it should no longer add
+   * its result to the animation sandwich.
+   *
+   * @param aIsFrozen True if this animation should continue to contribute to
+   *                  the animation sandwich using the most recent sample
+   *                  parameters even though these parameters are unlikely to
+   *                  change between samples.
+   */
+  virtual void      ToInactive(PRBool aIsFrozen)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimeClient, NS_ISMILTIMECLIENT_IID)
+
+#endif // __NS_ISMILTIMECLIENT_H__
+
Index: mozilla/smil/public/nsISMILTimeContainer.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILTimeContainer.h
@@ -0,0 +1,130 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMECONTAINER_H__
+#define __NS_ISMILTIMECONTAINER_H__
+
+#include "nsISupports.h"
+#include "nsISMILTimedElement.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimeContainer: Time container
+
+// {46b51a7b-d857-45f1-9c7d-4d0d12719238}
+#define NS_ISMILTIMECONTAINER_IID \
+{ 0x46b51a7b, 0xd857, 0x45f1, { 0x9c, 0x7d, 0x4d, 0x0d, 0x12, 0x71, 0x92, 0x38 } }
+
+/**
+ * A SMIL time container.
+ *
+ * When implementing SMIL 2.0 time containers, this interface will most likely
+ * inherit from nsISMILTimedElement, amongst other changes
+ */
+class nsISMILTimeContainer : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMECONTAINER_IID)
+
+  /**
+   * Pause the time container. The time container is initially unpaused.
+   */
+  virtual nsresult  Pause()=0;
+
+  /**
+   * Resume the time container.
+   */
+  virtual nsresult  Resume()=0;
+
+  /**
+   * Returns the paused state of the time container independently of the paused
+   * state of the container's parent.
+   */
+  virtual PRBool    IsPaused()=0;
+
+  /**
+   * Inform the time container that its parent has been paused.
+   *
+   * Currently this is necessary so that the time container will accumulate
+   * pause offsets correctly as these are not maintained by the parent.
+   *
+   * Re-using Pause() and maintaining pause counts can lead to unwanted
+   * behaviour when calls to pause and resume are unbalanced.
+   */
+  virtual nsresult  ParentPaused()=0;
+
+  /**
+   * Inform the time container that its parent has been resumed.
+   */
+  virtual nsresult  ParentResumed()=0;
+
+  /**
+   * Reset the time container's internal state. This is particularly useful when
+   * a cached time container is to be re-used.
+   */
+  virtual nsresult  Reset()=0;
+
+  /**
+   * We may later change this to SampleAt and maintain separate host document
+   * and document fragment times. This would allow more advanced time
+   * manipulations for documents with several animated SVG document fragments.
+   */
+  virtual void      Sample()=0;
+
+  /**
+   * Add a timed element to this container. No attempt is made to check if the
+   * timed element is already a child of this container--in that case the timed
+   * element will be added twice and will be sampled twice.
+   *
+   * @param aElement  The element to add.
+   * @return  NS_OK if the element was successfully added or an error otherwise.
+   */
+  virtual nsresult  AddTimedElement(nsISMILTimedElement* aElement)=0;
+
+  /**
+   * Remove the specified timed element from this container.
+   *
+   * @param aElement  The element to remove.
+   * @return NS_OK if the element is found and successfully removed or an error
+   * otherwise.
+   */
+  virtual nsresult  RemoveTimedElement(nsISMILTimedElement* aElement)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimeContainer, NS_ISMILTIMECONTAINER_IID)
+
+#endif // __NS_ISMILTIMECONTAINER_H__
+
Index: mozilla/smil/public/nsISMILTimedElement.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILTimedElement.h
@@ -0,0 +1,157 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTIMEDELEMENT_H__
+#define __NS_ISMILTIMEDELEMENT_H__
+
+#include "nsISupports.h"
+
+class nsISMILTimeClient;
+class nsSMILTimeValue;
+class nsSMILInstanceTime;
+class nsSMILTimedDocumentRoot;
+class nsIAtom;
+
+////////////////////////////////////////////////////////////////////////
+// nsISMILTimedElement
+
+// {c5f60446-5c1a-4f3b-8ce3-646199ac97f2}
+#define NS_ISMILTIMEDELEMENT_IID \
+{ 0xc5f60446, 0x5c1a, 0x4f3b, { 0x8c, 0xe3, 0x64, 0x61, 0x99, 0xac, 0x97, 0xf2 } }
+
+class nsISMILTimedElement : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISMILTIMEDELEMENT_IID)
+
+  /**
+   * Adds an instance time object this element's list of instance times.
+   * These instance times are used when creating intervals.
+   *
+   * This method is typically called by an nsSMILTimeValueSpec.
+   *
+   * @param aInstanceTime   The time to add.
+   *
+   * @param aIsBegin        True if the time to be added represents a begin time
+   *                        or false if it represents an end time.
+   */
+  virtual void      AddInstanceTime(nsSMILInstanceTime* aInstanceTime,
+                                    PRBool aIsBegin)=0;
+
+  /**
+   * Associates a timed document root. This is required for resolving wallclock
+   * values and getting the document time in order to create new instance times.
+   *
+   * @param aRoot The timed document root to associate.
+   */
+  virtual void      SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot)=0;
+
+  /**
+   * Sets the object that will be called by this timed element each time it is
+   * sampled.
+   *
+   * In Schmitz's model it is possible to associate several time clients with
+   * a timed element but for now we only allow one.
+   *
+   * @param aClient   The time client to associate. Any previous time client
+   *                  will be disassociated and no longer sampled. Setting this
+   *                  to nsnull will simply disassociate the previous client, if
+   *                  any.
+   */
+  virtual void      SetTimeClient(nsISMILTimeClient* aClient)=0;
+
+  /**
+   * Samples the object at the given document time. Timing intervals are updated
+   * and if this element is active at the given time the associated time client
+   * will be sampled with the appropriate simple time.
+   *
+   * @param aDocumentTime The document time at which to sample.
+   */
+  virtual void      SampleAt(const PRInt64& aDocumentTime)=0;
+
+  /**
+   * Reset the element's internal state. This is useful for repeating time
+   * containers and so that the timing model can be cached.
+   *
+   * @param aHardReset  Perform a hard reset such that all instance times are
+   *                    cleared. For a soft reset only instance times created by
+   *                    DOM calls and events are cleared. A hard reset is needed
+   *                    in the case of a cached timing model whilst for
+   *                    repeating only a soft reset is required.
+   */
+  virtual void      Reset(PRBool aHardReset = PR_FALSE)=0;
+
+  /**
+   * Attempts to set an attribute on this timed element.
+   *
+   * @param aAttribute  The name of the attribute to set. The namespace of this
+   *                    attribute is not specified as it is checked by the host
+   *                    element. Only attributes in the namespace defined for
+   *                    SMIL attributes in the host language are passed to the
+   *                    timed element.
+   *
+   * @param aValue      The attribute value.
+   *
+   * @param[out] aResult
+   *                    The result of parsing the attribute. May be nsnull. Only
+   *                    used for unit testing.
+   *
+   * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool    SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult = nsnull)=0;
+
+  /**
+   * Attempts to unset an attribute on this timed element.
+   *
+   * @param aAttribute  The name of the attribute to set. As with SetAttr the
+   *                    namespace of the attribute is not specified (see
+   *                    SetAttr).
+   *
+   * @return PR_TRUE if the given attribute is a timing attribute, PR_FALSE
+   * otherwise.
+   */
+  virtual PRBool    UnsetAttr(nsIAtom* aAttribute)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISMILTimedElement, NS_ISMILTIMEDELEMENT_IID)
+
+nsISMILTimedElement* NS_NewSMILTimedElement();
+
+#endif // __NS_ISMILTIMEDELEMENT_H__
+
Index: mozilla/smil/public/nsISMILType.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsISMILType.h
@@ -0,0 +1,169 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISMILTYPE_H__
+#define __NS_ISMILTYPE_H__
+
+#include "nscore.h"
+
+struct nsSMILValue;
+
+class nsISMILType
+{
+public:
+  /**
+   * Sets the value to some identity value such that adding this value with
+   * another has no effect.
+   *
+   * @pre aValue.mType == this
+   */
+  virtual void SetValueIdentity(nsSMILValue& aValue) = 0;
+
+  /**
+   * Destroys any data associated with a value of this type.
+   *
+   * @pre aValue.mType == this
+   */
+  virtual void DestroyValue(nsSMILValue& aValue) = 0;
+
+  /**
+   * Assign this object the value of another. Think of this as the assignment
+   * operator.
+   *
+   * @param   aDest       The left-hand side of the assignment.
+   * @param   aSrc        The right-hand side of the assignment.
+   * @return  NS_OK on success, an error code on failure such as when the
+   *          underlying type of the specified object differs.
+   *
+   * @pre aDest.mType == aSrc.mType == this
+   * @pre aDest's data has been destroyed
+   */
+  virtual nsresult  AssignValue(nsSMILValue& aDest,
+                                const nsSMILValue& aSrc) = 0;
+
+  /**
+   * Adds two values. This method facilitates additive and cumulative animation.
+   *
+   * This method will fail if the underlying datatype is not additive or was not
+   * specified using an additive syntax.
+   *
+   * See SVG 1.1, section 19.2.5. In particular,
+   *
+   * "If a given attribute or property can take values of keywords (which are
+   * not additive) or numeric values (which are additive), then additive
+   * animations are possible if the subsequent animation uses a numeric value
+   * even if the base animation uses a keyword value; however, if the subsequent
+   * animation uses a keyword value, additive animation is not possible."
+   *
+   * Add and Interpolate should be defined in such a way that Add followed by
+   * Interpolate produces the same result as Interpolate followed by Add. If
+   * this is a problem for a particular datatype we will need to change the way
+   * 'by' animation is implemented.
+   *
+   * @param   aDest       The value that will be adjusted.
+   * @param   aSrc        The value to add.
+   * @return  NS_OK on success, an error code on failure.
+   *
+   * @pre aDest.mType == this
+   */
+  virtual nsresult  Add(nsSMILValue& aDest,
+                        const nsSMILValue& aSrc) = 0;
+
+  /**
+   * Calculates the 'distance' between two values. This is the distance used in
+   * paced interpolation.
+   *
+   * @param   aFrom     The start of the interval for which the distance should
+   *                    be calculated.
+   * @param   aTo       The end of the interval for which the distance should be
+   *                    calculated.
+   * @param   aDistance The result of the calculation.
+   * @return  NS_OK on success, or an appropriate error code if there is no
+   *          notion of distance for the underlying data type or the distance
+   *          could not be calculated.
+   *
+   * @pre aFrom.mType == aTo.mType == this
+   */
+  virtual nsresult ComputeDistance(const nsSMILValue& aFrom,
+                                   const nsSMILValue& aTo,
+                                   PRFloat64& aDistance) const = 0;
+
+  /**
+   * Calculates an interpolated value between two values using the specified
+   * proportion.
+   *
+   * @param   aStartVal     The value defining the start of the interval of
+   *                        interpolation.
+   * @param   aEndVal       The value defining the end of the interval of
+   *                        interpolation.
+   * @param   aUnitDistance A number between 0.0 and 1.0 (inclusive) defining
+   *                        the distance of the interpolated value in the
+   *                        interval.
+   * @param   aResult       The interpolated value.
+   * @result  NS_OK on success, NS_ERROR_FAILURE if this data type cannot be
+   *          interpolated or NS_ERROR_OUT_OF_MEMORY if insufficient memory was
+   *          available for storing the result.
+   *
+   * @pre aStartVal.mType == aEndVal.mType == this
+   * @pre Any data in aResult has been destroyed
+   */
+  virtual nsresult  Interpolate(const nsSMILValue& aStartVal,
+                                const nsSMILValue& aEndVal,
+                                float aUnitDistance,
+                                nsSMILValue& aResult) = 0;
+
+  /**
+   * Repeats this value or the specified value a number of times. This method
+   * will fail if the underlying data type is not additive.
+   *
+   * @param   aDest         The value to alter.
+   * @param   aCount        The number of times to repeat the value.
+   * @param   aRepeatValue  The value to repeat. If this parameter is null the
+   *                        destination value will be repeated.
+   * @return  NS_OK on success, an error code on failure.
+   *
+   * @pre aDest.mType == this
+   * @pre aRepeatValue == nsnull || aRepeatValue->mType == this
+   */
+  virtual nsresult  Repeat(nsSMILValue& aDest,
+                           PRUint32 aCount,
+                           const nsSMILValue* aRepeatValue = nsnull) = 0;
+};
+
+#endif
+
Index: mozilla/smil/public/nsSMILFloatType.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsSMILFloatType.h
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILFLOATTYPE_H__
+#define __NS_SMILFLOATTYPE_H__
+
+#include "nsISMILType.h"
+
+class nsSMILFloatType : public nsISMILType
+{
+public:
+  virtual void        SetValueIdentity(nsSMILValue& aValue);
+  virtual void        DestroyValue(nsSMILValue&) {}
+  virtual nsresult    AssignValue(nsSMILValue& aDest,
+                                  const nsSMILValue& aSrc);
+  virtual nsresult    Add(nsSMILValue& aDest, const nsSMILValue& aSrc);
+  virtual nsresult    ComputeDistance(const nsSMILValue& aFrom,
+                                      const nsSMILValue& aTo,
+                                      PRFloat64& aDistance) const;
+  virtual nsresult    Interpolate(const nsSMILValue& aStartVal,
+                                  const nsSMILValue& aEndVal,
+                                         float aUnitDistance,
+                                         nsSMILValue& aResult);
+  virtual nsresult    Repeat(nsSMILValue& aDest,
+                             PRUint32 aCount,
+                             const nsSMILValue* aRepeatValue);
+
+  static nsSMILFloatType sSingleton;
+
+private:
+  nsSMILFloatType() {}
+};
+
+#endif
+
Index: mozilla/smil/public/nsSMILNullType.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsSMILNullType.h
@@ -0,0 +1,71 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILNULLTYPE_H__
+#define __NS_SMILNULLTYPE_H__
+
+#include "nsISMILType.h"
+
+class nsSMILNullType : public nsISMILType
+{
+public:
+  virtual void SetValueIdentity(nsSMILValue&) {}
+  virtual void DestroyValue(nsSMILValue&) {}
+  virtual nsresult AssignValue(nsSMILValue&, const nsSMILValue&);
+
+  //
+  // The remaining methods should never be called, so although they're very
+  // simple they don't need to be inline.
+  //
+  virtual nsresult Add(nsSMILValue&, const nsSMILValue&);
+  virtual nsresult ComputeDistance(const nsSMILValue&,
+                                   const nsSMILValue&,
+                                   PRFloat64& aDistance) const;
+  virtual nsresult Interpolate(const nsSMILValue&,
+                               const nsSMILValue&,
+                               float,
+                               nsSMILValue&);
+  virtual nsresult Repeat(nsSMILValue&,
+                          PRUint32,
+                          const nsSMILValue*);
+
+  static nsSMILNullType sSingleton;
+};
+
+#endif
+
Index: mozilla/smil/public/nsSMILValue.h
===================================================================
--- /dev/null
+++ mozilla/smil/public/nsSMILValue.h
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILVALUE_H__
+#define __NS_SMILVALUE_H__
+
+#include "nsISMILType.h"
+#include "nsSMILNullType.h"
+
+struct nsSMILValue
+{
+  nsSMILValue(nsISMILType* aType) : mType(aType)
+  {
+    mType->SetValueIdentity(*this);
+  }
+  nsSMILValue() : mType(&nsSMILNullType::sSingleton) {}
+
+  ~nsSMILValue()
+  {
+    mType->DestroyValue(*this);
+  }
+
+  nsSMILValue(const nsSMILValue& aVal) : mType( aVal.mType)
+  {
+    mType->AssignValue(*this, aVal);
+  }
+
+  // XXX Add a 'Swap' method to nsISMILType. In many cases whilst compositing
+  // we're using the assignment operator when a swap would do and would save the
+  // unnecessary allocations and deallocations that this requires for types that
+  // use dynamically allocated memory (mU.mPtr)
+  const nsSMILValue& operator=(const nsSMILValue& aVal)
+  {
+    if (&aVal == this)
+      return *this;
+
+    mType->DestroyValue(*this);
+    mType = aVal.mType;
+    mType->AssignValue(*this, aVal);
+    return *this;
+  }
+
+  bool IsNull() const
+  {
+    return (mType == &nsSMILNullType::sSingleton);
+  }
+
+  nsresult Add(const nsSMILValue& aSrc)
+  {
+    return mType->Add(*this, aSrc);
+  }
+
+  nsresult ComputeDistance(const nsSMILValue& aTo,
+                           PRFloat64& aDistance)
+  {
+    return mType->ComputeDistance(*this, aTo, aDistance);
+  }
+
+  nsresult Interpolate(const nsSMILValue& aEndVal,
+                       float aUnitDistance,
+                       nsSMILValue& aResult)
+  {
+    aResult.mType->DestroyValue(aResult);
+    return mType->Interpolate(*this, aEndVal, aUnitDistance, aResult);
+  }
+
+  nsresult Repeat(PRUint32 aCount,
+                  const nsSMILValue* aRepeatValue = nsnull)
+  {
+    return mType->Repeat(*this, aCount, aRepeatValue);
+  }
+
+  union {
+    PRInt64 mInt;
+    double mDouble;
+    void* mPtr;
+  } mU;
+  nsISMILType* mType;
+};
+
+#endif
+
Index: mozilla/smil/src/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/smil/src/Makefile.in
@@ -0,0 +1,85 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= content
+LIBRARY_NAME	= gkconsmil_s
+LIBXUL_LIBRARY	= 1
+
+REQUIRES	= xpcom \
+		  string \
+		  layout \
+		  content \
+		  unicharutil \
+		  widget \
+		  dom \
+		  $(NULL)
+
+CPPSRCS		= \
+	nsSMILAnimationController.cpp \
+	nsSMILAnimationFunction.cpp \
+	nsSMILAnimationRegistry.cpp \
+	nsSMILCompositor.cpp \
+	nsSMILEnum.cpp \
+	nsSMILFloatType.cpp \
+	nsSMILInstanceTime.cpp \
+	nsSMILInterval.cpp \
+	nsSMILKeySpline.cpp \
+	nsSMILNullType.cpp \
+	nsSMILParserUtils.cpp \
+	nsSMILTimedDocumentRoot.cpp \
+	nsSMILTimedElement.cpp \
+	nsSMILTimeValue.cpp \
+	nsSMILTimeValueSpec.cpp \
+		$(NULL)
+
+include $(topsrcdir)/config/config.mk
+
+# we don't want the shared lib, but we want to force the creation of a static lib.
+FORCE_STATIC_LIB = 1
+# DIRS		= tests
+
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -D_IMPL_NS_LAYOUT
+
Index: mozilla/smil/src/nsSMILAnimationController.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILAnimationController.cpp
@@ -0,0 +1,407 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILAnimationController.h"
+#include "nsComponentManagerUtils.h"
+#include "nsWeakReference.h"
+#include "nsITimer.h"
+#include "nsISMILTimeContainer.h"
+#include "nsCOMArray.h"
+#include "nsISimpleEnumerator.h"
+#include "nsArrayEnumerator.h"
+#include "nsIDocument.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIDOMEventListener.h"
+#include "nsIDOMEvent.h"
+
+class nsSMILAnimationController : public nsISMILAnimationController,
+                                  public nsIDOMEventListener,
+                                  public nsSupportsWeakReference
+{
+public:
+  nsSMILAnimationController();
+  ~nsSMILAnimationController();
+
+  NS_DECL_ISUPPORTS
+
+  // nsISMILAnimationController
+  virtual nsresult  Pause();
+  virtual nsresult  Resume();
+  virtual nsresult  Reset();
+  virtual nsresult  AddTimeContainer(nsISMILTimeContainer* aContainer);
+  virtual nsresult  RemoveTimeContainer(nsISMILTimeContainer* aContainer);
+
+  // nsIDOMEventListener
+  NS_IMETHOD        HandleEvent(nsIDOMEvent *event);
+
+protected:
+  friend nsISMILAnimationController*
+  NS_NewSMILAnimationController(nsIDocument* doc);
+
+  // nsISMILAnimationController
+  nsresult          Init(nsIDocument* doc);
+  nsresult          StartTimer();
+  nsresult          StopTimer();
+  void              SampleChildren();
+  static void       Notify(nsITimer* aTimer, void* aClosure);
+
+  static const PRUint32         kTimerInterval;
+  nsCOMPtr<nsITimer>            mTimer;
+  nsCOMArray<nsIWeakReference>  mTimeContainers;
+  PRUint16                      mPauseCount;
+  PRBool                        mHidden;
+};
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILAnimationController implementation
+
+// In my testing the minimum needed for smooth animation is 36 frames per
+// second which seems like a lot (Flash traditionally uses 14fps).
+//
+// Redrawing is synchronous. This is deliberate so that later we can tune the
+// timer based on how long the callback takes. To achieve 36fps we'd need 28ms
+// between frames. For now we set the timer interval to be a little less than
+// this (to allow for the render itself) and then let performance decay as the
+// image gets more complicated and render times increase.
+//
+const PRUint32 nsSMILAnimationController::kTimerInterval = 22;
+
+//----------------------------------------------------------------------
+// ctors, dtors, factory methods
+
+nsSMILAnimationController::nsSMILAnimationController()
+  : mPauseCount(0),
+    mHidden(PR_FALSE)
+{
+}
+
+nsSMILAnimationController::~nsSMILAnimationController()
+{
+  if (mTimer) {
+    mTimer->Cancel();
+    mTimer = nsnull;
+  }
+}
+
+nsISMILAnimationController* NS_NewSMILAnimationController(nsIDocument* doc)
+{
+  nsSMILAnimationController* animationController =
+    new nsSMILAnimationController();
+  NS_ENSURE_TRUE(animationController, nsnull);
+
+  nsresult rv = animationController->Init(doc);
+  if (NS_FAILED(rv)) {
+    delete animationController;
+    animationController = nsnull;
+  }
+
+  return animationController;
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS4(nsSMILAnimationController,
+                   nsISMILAnimationController,
+                   nsIAnimationController,
+                   nsIDOMEventListener,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// Timer callback
+
+//
+// We use the function callback rather than implementing nsITimerCallback to
+// avoid circular ownership between the timer and this object.
+//
+
+/*static*/ void
+nsSMILAnimationController::Notify(nsITimer* timer, void* aClosure)
+{
+  nsSMILAnimationController* controller = (nsSMILAnimationController*)aClosure;
+
+  NS_ASSERTION(controller->mTimer == timer,
+               "nsSMILAnimationController::Notify called with incorrect timer");
+
+  controller->SampleChildren();
+}
+
+//----------------------------------------------------------------------
+// nsISMILAnimationController methods:
+
+nsresult
+nsSMILAnimationController::Pause()
+{
+  if (++mPauseCount > 1)
+    return NS_OK;
+
+  nsresult rv = NS_OK;
+
+  rv = StopTimer();
+
+  // We must tell the children too so they can keep their accumulated offsets
+  // accurate
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer>
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    // This mess means that we continue processing all the children even if an
+    // error occurs but that we report the first error encountered
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->ParentPaused();
+      else
+        container->ParentPaused();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::Resume()
+{
+  nsresult rv = NS_OK;
+
+  NS_ASSERTION(mPauseCount > 0, "Unbalanced calls to Pause() and Resume()");
+  if (mPauseCount == 0)
+    return NS_ERROR_FAILURE;
+
+  if (--mPauseCount > 0)
+    return NS_OK;
+
+  // We must tell the children so they can keep their accumulated offsets
+  // accurate
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer>
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->ParentResumed();
+      else
+        container->ParentResumed();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  if (mTimeContainers.Count() > 0)
+    StartTimer();
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::Reset()
+{
+  nsresult rv = NS_OK;
+
+  PRUint32 i = mTimeContainers.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimeContainer>
+      container( do_QueryReferent(mTimeContainers[i]) );
+
+    if (container) {
+      if (NS_SUCCEEDED(rv))
+        rv = container->Reset();
+      else
+        container->Reset();
+    } else {
+      mTimeContainers.RemoveObjectAt(i);
+    }
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::AddTimeContainer(nsISMILTimeContainer* aContainer)
+{
+  NS_ENSURE_ARG_POINTER(aContainer);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aContainer, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimeContainers.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (mPauseCount > 0) {
+    aContainer->ParentPaused();
+  } else if (mTimeContainers.Count() == 1) {
+    rv = StartTimer();
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILAnimationController::RemoveTimeContainer(nsISMILTimeContainer* aContainer)
+{
+  NS_ENSURE_ARG_POINTER(aContainer);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aContainer, &rv)) );
+
+  if (NS_SUCCEEDED(rv))
+    rv = (mTimeContainers.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  if (NS_SUCCEEDED(rv) && mPauseCount == 0 && mTimeContainers.Count() == 0)
+    rv = StopTimer();
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// nsIDOMPageTransitionListener methods
+
+nsresult
+nsSMILAnimationController::HandleEvent(nsIDOMEvent *aEvent)
+{
+  nsAutoString eventType;
+  aEvent->GetType(eventType);
+
+  if (eventType.EqualsLiteral("pageshow")) {
+    if (!mHidden)
+      return NS_OK;
+
+    mHidden = PR_FALSE;
+
+    if (NS_SUCCEEDED(Reset())) {
+      Resume();
+    }
+  } else if (eventType.EqualsLiteral("pagehide")) {
+    mHidden = PR_TRUE;
+    Pause();
+  }
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers:
+
+nsresult
+nsSMILAnimationController::Init(nsIDocument *doc)
+{
+  mTimer = do_CreateInstance("@mozilla.org/timer;1");
+
+  // SMIL should be able to be used from a wide variety of contexts so in the
+  // following we fail silently. It is only necessary to support the bfcache.
+  if (doc) {
+    nsCOMPtr<nsIScriptGlobalObject> global(doc->GetScriptGlobalObject());
+    if (global) {
+      nsCOMPtr<nsIDOMEventTarget> receiver( do_QueryInterface(global) );
+      if (receiver) {
+        receiver->AddEventListener(NS_LITERAL_STRING("pageshow"), this,
+                                   PR_FALSE);
+        receiver->AddEventListener(NS_LITERAL_STRING("pagehide"), this,
+                                   PR_FALSE);
+      }
+    }
+  }
+
+  return (mTimer) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
+}
+
+nsresult
+nsSMILAnimationController::StartTimer()
+{
+  NS_ENSURE_TRUE(mTimer, NS_ERROR_FAILURE);
+  NS_ASSERTION(mPauseCount == 0, "Starting timer but controller is paused.");
+
+  // Run the first sample manually
+  SampleChildren();
+
+  //
+  // XXX Make this self-tuning. Sounds like control theory to me and not
+  // something I'm familiar with.
+  //
+  return mTimer->InitWithFuncCallback(nsSMILAnimationController::Notify,
+                                      this,
+                                      kTimerInterval,
+                                      nsITimer::TYPE_REPEATING_SLACK);
+}
+
+nsresult
+nsSMILAnimationController::StopTimer()
+{
+  NS_ENSURE_TRUE(mTimer, NS_ERROR_FAILURE);
+
+  return mTimer->Cancel();
+}
+
+void
+nsSMILAnimationController::SampleChildren()
+{
+  // Creating a new enumerator each sample provides thread-safety but I'm not
+  // sure what the cost is
+
+  if (mPauseCount > 0)
+    return;
+
+  nsCOMPtr<nsISimpleEnumerator> enumerator;
+  nsresult rv =
+    NS_NewArrayEnumerator(getter_AddRefs(enumerator), mTimeContainers);
+  NS_ENSURE_SUCCESS(rv,);
+
+  PRBool more = PR_FALSE;
+  nsCOMPtr<nsISMILTimeContainer> container;
+  nsCOMPtr<nsIWeakReference> weakRef;
+
+  while (NS_SUCCEEDED(enumerator->HasMoreElements(&more)) && more) {
+    if (NS_FAILED(enumerator->GetNext(getter_AddRefs(weakRef))) || !weakRef)
+      break;
+
+    container = do_QueryReferent(weakRef);
+
+    if (container)
+      container->Sample();
+  }
+}
+
Index: mozilla/smil/src/nsSMILAnimationFunction.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILAnimationFunction.cpp
@@ -0,0 +1,1170 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILAnimationFunction.h"
+#include "nsISMILComposable.h"
+#include "nsISMILTimeClient.h"
+#include "nsISMILAttr.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILValue.h"
+#include "nsSMILEnum.h"
+#include "nsSMILKeySpline.h"
+#include "nsSMILParserUtils.h"
+#include "nsGkAtoms.h"
+#include "nsCOMPtr.h"
+#include "nsCOMArray.h"
+#include "nsAutoPtr.h"
+#include "nsTArray.h"
+#include "nsReadableUtils.h"
+#include "nsString.h"
+#include <math.h>
+
+#define ALLOW_BAD_KEYTIMES
+
+//----------------------------------------------------------------------
+// nsSMILAnimationFunction
+
+class nsSMILAnimationFunction : public nsISMILAnimationFunction,
+                                public nsISMILComposable,
+                                public nsISMILTimeClient
+{
+public:
+  nsSMILAnimationFunction();
+
+  NS_DECL_ISUPPORTS
+
+  // nsISMILAnimationFunction
+  virtual nsresult         SetTargetAttribute(nsISMILAttr* aAttribute);
+  virtual nsISMILAttr*     GetTargetAttribute();
+  virtual void             SetDocumentPosition(PRUint16 aDocPosition);
+  virtual PRBool           SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                                   nsresult* aResult);
+  virtual PRBool           UnsetAttr(nsIAtom* aAttribute);
+
+  // nsISMILTimeClient methods
+  virtual void             SampleAt(const PRInt64& aSimpleTime,
+                                    const nsSMILTimeValue& aSimpleDuration,
+                                    const PRUint32& aRepeatIteration);
+  virtual void             SampleLastValue(const PRUint32& aRepeatIteration);
+  virtual void             ToActive(const PRInt64& aBeginTime);
+  virtual void             ToInactive(PRBool aIsFrozen);
+
+  // nsISMILComposable methods
+  virtual void             ComposeResult(nsSMILValue &aResult);
+  virtual PRInt8           CompareTo(const nsISMILComposable& composable) const;
+  virtual const PRInt64&   GetBeginTime() const;
+  virtual PRUint16         GetDocumentPosition() const;
+  virtual PRBool           IsActive() const;
+  virtual PRBool           WillReplace() const;
+  virtual PRBool           HasChanged() const;
+
+protected:
+  // Implementation helpers
+  nsISMILAnimationFunction*     NS_NewSMILAnimationFunction();
+
+  // Property setters
+  nsresult  SetAccumulate(const nsAString& aAccumulate);
+  nsresult  SetAdditive(const nsAString& aAdditive);
+  nsresult  SetBy(const nsAString& aBy);
+  nsresult  SetCalcMode(const nsAString& aCalcMode);
+  nsresult  SetFrom(const nsAString& aFrom);
+  nsresult  SetKeyTimes(const nsAString& aKeyTimes);
+  nsresult  SetKeySplines(const nsAString& aKeySplines);
+  nsresult  SetTo(const nsAString& aTo);
+  nsresult  SetValues(const nsAString& aValues);
+
+  // Property un-setters
+  void      UnsetAdditive();
+  void      UnsetBy();
+  void      UnsetCalcMode();
+  void      UnsetAccumulate();
+  void      UnsetFrom();
+  void      UnsetKeyTimes();
+  void      UnsetKeySplines();
+  void      UnsetTo();
+  void      UnsetValues();
+
+  nsresult  InterpolateResult(nsSMILValue& aResult,
+                              nsSMILValue& aBaseValue);
+  nsresult  AccumulateResult(nsSMILValue& aResult);
+  void      ScaleSimpleDistance(PRFloat64& aDist);
+  void      ScaleIntervalDistance(PRFloat64& aDist, PRUint32 aIntervalIndex,
+                                  PRUint32 aNumIntervals);
+  void      FillValuesArray();
+  PRBool    IsToAnimation() const;
+  PRBool    IsAdditive() const;
+  void      CheckKeyTimes();
+  void      CheckKeySplines();
+
+  // Members
+
+  /**
+   * The attribute being targeted. This is needed for parsing animation function
+   * values and creating temporary objects.
+   */
+  nsRefPtr<nsISMILAttr>         mAttribute;
+
+  //
+  // Animation function values.
+  //
+  nsSMILValue                   mFrom;
+  nsSMILValue                   mTo;
+  nsSMILValue                   mBy;
+  nsTArray<nsSMILValue>         mValues;
+
+  enum nsSMILCalcMode
+  {
+    calc_linear,
+    calc_discrete,
+    calc_paced,
+    calc_spline
+  };
+  static nsSMILEnumMapping      sCalcModeMap[];
+  nsSMILEnum                    mCalcMode;
+
+  static nsSMILEnumMapping      sAdditiveMap[];
+  nsSMILEnum                    mAdditive;
+
+  static nsSMILEnumMapping      sAccumulateMap[];
+  nsSMILEnum                    mAccumulate;
+
+  nsTArray<PRFloat64>           mKeyTimes;
+  nsTArray<nsSMILKeySpline>     mKeySplines;
+
+  PRPackedBool                  mIsActive;
+  PRPackedBool                  mIsFrozen;
+
+  //
+  // These are the parameters provided by the previous sample. Currently we
+  // perform lazy calculation. That is, we only calculate the result if and when
+  // instructed by the compositor. This allows us to apply the result directly
+  // to the animation value and allows the compositor to filter out functions
+  // that it determines will not contribute to the final result.
+  //
+  PRInt64                       mSimpleTime;
+  nsSMILTimeValue               mSimpleDuration;
+  PRUint32                      mRepeatIteration;
+  PRPackedBool                  mLastValue;
+  PRPackedBool                  mHasChanged;
+
+  PRInt64                       mBeginTime;
+  PRUint16                      mDocumentPosition;
+
+  // Keep track of which attributes have been set. This is mostly necessary for
+  // correct error handling but it also used to distinguish between when the
+  // mValues array is filled from a 'values' spec or from the values of
+  // 'from', 'to' and 'by'.
+  //
+  // Currently it is not used for all attributes.
+  PRUint16                      mSetFlags;
+
+  // Which attributes have been set but have had errors. This is not used for
+  // all attributes but only those which have specified error behaviour
+  // associated with them.
+  PRUint16                      mErrorFlags;
+
+  //
+  // This is for the very specific case where we have a 'to' animation that is
+  // frozen part way through the simple duration and there are other active
+  // lower-priority animations targetting the same attribute. In this case
+  // SMILANIM 3.3.6 says:
+  //
+  //   The value for F(t) when a to-animation is frozen (at the end of the
+  //   simple duration) is just the to value. If a to-animation is frozen
+  //   anywhere within the simple duration (e.g., using a repeatCount of "2.5"),
+  //   the value for F(t) when the animation is frozen is the value computed for
+  //   the end of the active duration. Even if other, lower priority animations
+  //   are active while a to-animation is frozen, the value for F(t) does not
+  //   change.
+  //
+  // To implement this properly we'd need to force a resample of all the lower
+  // priority animations at the active end of this animation--something which
+  // would introduce unwanted coupling between the timing and animation model.
+  // Instead we just save the value calculated when this animation is frozen (in
+  // which case this animation will be sampled at the active end and the lower
+  // priority animations should be sampled at a time pretty close to this,
+  // provided we have a reasonable frame rate and we aren't seeking).
+  //
+  // @see
+  // http://www.w3.org/TR/2001/REC-smil-animation-20010904/#FromToByAndAdditive
+  //
+  nsSMILValue                   mFrozenValue;
+};
+
+//----------------------------------------------------------------------
+// Static members
+
+nsSMILEnumMapping nsSMILAnimationFunction::sCalcModeMap[] = {
+      {&nsGkAtoms::linear, calc_linear},
+      {&nsGkAtoms::discrete, calc_discrete},
+      {&nsGkAtoms::paced, calc_paced},
+      {&nsGkAtoms::spline, calc_spline},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILAnimationFunction::sAdditiveMap[] = {
+      {&nsGkAtoms::replace, PR_FALSE},
+      {&nsGkAtoms::sum, PR_TRUE},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILAnimationFunction::sAccumulateMap[] = {
+      {&nsGkAtoms::none, PR_FALSE},
+      {&nsGkAtoms::sum, PR_TRUE},
+      {nsnull, 0}
+};
+
+#define BF_ACCUMULATE  0
+#define BF_ADDITIVE    1
+#define BF_BY          2
+#define BF_CALC_MODE   3
+#define BF_FROM        4
+#define BF_KEY_TIMES   5
+#define BF_KEY_SPLINES 6
+#define BF_TO          7
+#define BF_VALUES      8
+
+// Based on GET/SET_BOOLBIT in nsHTMLInputElement.cpp
+#define GET_FLAG(bitfield, field) (((bitfield) & (0x01 << (field))) \
+                                     ? PR_TRUE : PR_FALSE)
+#define SET_FLAG(bitfield, field, b) ((b) \
+                                     ? ((bitfield) |=  (0x01 << (field))) \
+                                     : ((bitfield) &= ~(0x01 << (field))))
+
+//----------------------------------------------------------------------
+// Constructors etc.
+
+nsSMILAnimationFunction::nsSMILAnimationFunction()
+  : mCalcMode(calc_linear, sCalcModeMap),
+    mAdditive(PR_FALSE, sAdditiveMap),
+    mAccumulate(PR_FALSE, sAccumulateMap),
+    mIsActive(PR_FALSE),
+    mIsFrozen(PR_FALSE),
+    mSimpleTime(-1),
+    mRepeatIteration(0),
+    mLastValue(PR_FALSE),
+    mHasChanged(PR_TRUE),
+    mBeginTime(LL_MinInt()),
+    mDocumentPosition(PR_UINT16_MAX),
+    mSetFlags(0),
+    mErrorFlags(0)
+{
+}
+
+nsISMILAnimationFunction*
+NS_NewSMILAnimationFunction()
+{
+  nsSMILAnimationFunction *func = new nsSMILAnimationFunction();
+  NS_ENSURE_TRUE(func, nsnull);
+
+  return func;
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS4(nsSMILAnimationFunction,
+                   nsISMILAnimationFunction,
+                   nsISMILComposable,
+                   nsISMILTimeClient,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsISMILAnimationFunction methods:
+
+nsresult
+nsSMILAnimationFunction::SetTargetAttribute(nsISMILAttr* aAttribute)
+{
+  mAttribute = aAttribute;
+  mValues.Clear();
+  SET_FLAG(mSetFlags, BF_VALUES, PR_FALSE);
+  mFrom = nsSMILValue();
+  mTo = nsSMILValue();
+  mBy = nsSMILValue();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+nsISMILAttr*
+nsSMILAnimationFunction::GetTargetAttribute()
+{
+  return mAttribute;
+}
+
+PRBool
+nsSMILAnimationFunction::SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                                 nsresult* aResult)
+{
+  PRBool rv = PR_TRUE;
+
+  nsresult result = NS_OK;
+
+  if (aAttribute == nsGkAtoms::by)
+    result = SetBy(aValue);
+  else if (aAttribute == nsGkAtoms::from)
+    result = SetFrom(aValue);
+  else if (aAttribute == nsGkAtoms::to)
+    result = SetTo(aValue);
+  else if (aAttribute == nsGkAtoms::values)
+    result = SetValues(aValue);
+  else if (aAttribute == nsGkAtoms::accumulate)
+    result = SetAccumulate(aValue);
+  else if (aAttribute == nsGkAtoms::additive)
+    result = SetAdditive(aValue);
+  else if (aAttribute == nsGkAtoms::calcMode)
+    result = SetCalcMode(aValue);
+  else if (aAttribute == nsGkAtoms::keyTimes)
+    result = SetKeyTimes(aValue);
+  else if (aAttribute == nsGkAtoms::keySplines)
+    result = SetKeySplines(aValue);
+  else
+    rv = PR_FALSE;
+
+  if (rv && aResult)
+    *aResult = result;
+
+  return rv;
+}
+
+PRBool
+nsSMILAnimationFunction::UnsetAttr(nsIAtom* aAttribute)
+{
+  PRBool rv = PR_TRUE;
+
+  if (aAttribute == nsGkAtoms::by)
+    UnsetBy();
+  else if (aAttribute == nsGkAtoms::from)
+    UnsetFrom();
+  else if (aAttribute == nsGkAtoms::to)
+    UnsetTo();
+  else if (aAttribute == nsGkAtoms::values)
+    UnsetValues();
+  else if (aAttribute == nsGkAtoms::accumulate)
+    UnsetAccumulate();
+  else if (aAttribute == nsGkAtoms::additive)
+    UnsetAdditive();
+  else if (aAttribute == nsGkAtoms::calcMode)
+    UnsetCalcMode();
+  else if (aAttribute == nsGkAtoms::keyTimes)
+    UnsetKeyTimes();
+  else if (aAttribute == nsGkAtoms::keySplines)
+    UnsetKeySplines();
+  else
+    rv = PR_FALSE;
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimeClient methods
+
+void
+nsSMILAnimationFunction::SampleAt(const PRInt64& aSimpleTime,
+                                  const nsSMILTimeValue& aSimpleDuration,
+                                  const PRUint32& aRepeatIteration)
+{
+  if (mHasChanged || mLastValue || LL_NE(mSimpleTime, aSimpleTime) ||
+      mSimpleDuration.CompareTo(aSimpleDuration) ||
+      mRepeatIteration != aRepeatIteration)
+    mHasChanged = PR_TRUE;
+
+  mSimpleTime       = aSimpleTime;
+  mSimpleDuration   = aSimpleDuration;
+  mRepeatIteration  = aRepeatIteration;
+  mLastValue        = PR_FALSE;
+}
+
+void
+nsSMILAnimationFunction::SampleLastValue(const PRUint32& aRepeatIteration)
+{
+ if (mHasChanged || !mLastValue || mRepeatIteration != aRepeatIteration)
+    mHasChanged = PR_TRUE;
+
+  mRepeatIteration  = aRepeatIteration;
+  mLastValue        = PR_TRUE;
+}
+
+void
+nsSMILAnimationFunction::ToActive(const PRInt64& aBeginTime)
+{
+  mBeginTime = aBeginTime;
+  mIsActive = PR_TRUE;
+  mIsFrozen = PR_FALSE;
+  mFrozenValue = nsSMILValue();
+}
+
+void
+nsSMILAnimationFunction::ToInactive(PRBool aIsFrozen)
+{
+  mIsActive = PR_FALSE;
+  mIsFrozen = aIsFrozen;
+  mFrozenValue = nsSMILValue();
+  mHasChanged = PR_TRUE;
+}
+
+//----------------------------------------------------------------------
+// nsISMILComposable methods
+
+void
+nsSMILAnimationFunction::ComposeResult(nsSMILValue &aResult)
+{
+  mHasChanged = PR_FALSE;
+
+  // This checks if mValues is empty so we don't need to check it again later
+  if (!IsActive())
+    return;
+
+  if (!mAttribute)
+    return;
+
+  NS_ENSURE_TRUE(mSimpleTime >= 0,);
+  NS_ENSURE_TRUE(mSimpleDuration.IsResolved() ||
+                 mSimpleDuration.IsIndefinite(), );
+
+  nsSMILValue result(aResult.mType);
+
+  if (mSimpleDuration.IsIndefinite() ||
+      (GET_FLAG(mSetFlags, BF_VALUES) && mValues.Length() == 1)) {
+
+    // Indefinite duration or only one value set: Always set the first value
+    result = mValues[0];
+
+  } else if (mLastValue) {
+
+    // Sampling last value
+    nsSMILValue last(mValues[mValues.Length() - 1]);
+    if (mAccumulate.GetIntegerValue() && mRepeatIteration > 0) {
+      if (NS_FAILED(result.Repeat(mRepeatIteration, &last)))
+        result = last;
+    } else {
+      result = last;
+    }
+
+  } else if (!mFrozenValue.IsNull() && !mHasChanged) {
+
+    // Frozen to animation
+    result = mFrozenValue;
+
+  } else {
+
+    // Interpolation
+    NS_ENSURE_SUCCESS(InterpolateResult(result, aResult),);
+    NS_ENSURE_SUCCESS(AccumulateResult(result),);
+
+    if (IsToAnimation() && mIsFrozen) {
+      mFrozenValue = result;
+    }
+  }
+
+  //
+  // If additive animation isn't required or isn't supported, set the value.
+  //
+  if (!IsAdditive() || NS_FAILED(aResult.Add(result)))
+    aResult = result;
+}
+
+PRInt8
+nsSMILAnimationFunction::CompareTo(const nsISMILComposable& composable) const
+{
+  //
+  // Inactive animations sort first
+  //
+  if (!IsActive() && composable.IsActive())
+    return -1;
+
+  if (IsActive() && !composable.IsActive())
+    return 1;
+
+  //
+  // Sort based on begin time
+  //
+  if (LL_NE(mBeginTime, composable.GetBeginTime()))
+    return LL_CMP(mBeginTime, >, composable.GetBeginTime()) ? 1 : -1;
+
+  // XXX When syncbase timing is implemented, we next need to sort based on
+  // dependencies
+
+  //
+  // Animations that appear later in the document sort after those earlier in
+  // the document
+  //
+  NS_ASSERTION(mDocumentPosition != composable.GetDocumentPosition(),
+      "Two animations cannot have the same document position!");
+
+  return (mDocumentPosition > composable.GetDocumentPosition())
+    ? 1
+    : (mDocumentPosition == composable.GetDocumentPosition()) ? 0 : -1;
+}
+
+const PRInt64&
+nsSMILAnimationFunction::GetBeginTime() const
+{
+  return mBeginTime;
+}
+
+PRUint16
+nsSMILAnimationFunction::GetDocumentPosition() const
+{
+  return mDocumentPosition;
+}
+
+PRBool
+nsSMILAnimationFunction::IsActive() const
+{
+  //
+  // Even if an animation should be active, if its attributes are set
+  // incorrectly, it will have no effect and should be considered by the
+  // compositor to be inactive.
+  //
+  // Frozen animations should be considered active for the purposes of
+  // compositing.
+  //
+  return ((mIsActive || mIsFrozen) && mValues.Length() > 0 && mErrorFlags == 0);
+}
+
+
+PRBool
+nsSMILAnimationFunction::WillReplace() const
+{
+  /*
+   * In IsAdditive() we don't consider to-animation to be additive as it is
+   * a special case that is dealt with differently in the compositing method but
+   * here we return false for to animation as it builds on the underlying value
+   * unless its a frozen to animation.
+   */
+  return !(IsAdditive() || IsToAnimation()) ||
+    (IsToAnimation() && mIsFrozen && !mHasChanged);
+}
+
+PRBool
+nsSMILAnimationFunction::HasChanged() const
+{
+  return mHasChanged;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSMILAnimationFunction::InterpolateResult(nsSMILValue& aResult,
+                                           nsSMILValue& aBaseValue)
+{
+  nsresult        rv = NS_OK;
+  double          fTime;
+  double          fDur;
+  double          simpleDistance;
+  double          intervalDistance;
+  PRInt32         index;
+  nsSMILValue     from;
+  nsSMILValue     to;
+  const PRInt64&  dur  = mSimpleDuration.GetMillis();
+
+  LL_L2D(fTime, mSimpleTime);
+  LL_L2D(fDur, dur);
+
+  if (LL_CMP(mSimpleTime, >=, dur) || !LL_GE_ZERO(mSimpleTime)) {
+    NS_ERROR("Animation sampled outside interval.");
+    return NS_ERROR_FAILURE;
+  }
+
+  if (mValues.Length() < 2 && !IsToAnimation()) {
+    NS_ERROR("Unexpected number of values.");
+    return NS_ERROR_FAILURE;
+  }
+
+  simpleDistance = (fDur > 0.0) ? fTime / fDur : 0.0;
+
+#ifdef ALLOW_BAD_KEYTIMES
+  if (GET_FLAG(mSetFlags, BF_KEY_TIMES)) {
+    PRFloat64 first = mKeyTimes[0];
+    if (first > 0.0 && simpleDistance < first) {
+      if (!IsToAnimation())
+        aResult = mValues[0];
+      return rv;
+    }
+    PRFloat64 last = mKeyTimes[mKeyTimes.Length() - 1];
+    if (last < 1.0 && simpleDistance >= last) {
+      if (IsToAnimation())
+        aResult = mValues[0];
+      else
+        aResult = mValues[mValues.Length() - 1];
+      return rv;
+    }
+  }
+#endif
+
+  ScaleSimpleDistance(simpleDistance);
+
+  if (IsToAnimation()) {
+    index = 0;
+
+    if (mCalcMode.GetIntegerValue() != calc_discrete) {
+      from = aBaseValue;
+      to = mValues[0];
+
+      intervalDistance = simpleDistance;
+      ScaleIntervalDistance(intervalDistance, 0, 1);
+    }
+  } else {
+    index = (PRInt32) floor(simpleDistance * (mValues.Length() - 1));
+
+    if (mCalcMode.GetIntegerValue() != calc_discrete) {
+      from = mValues[index];
+      to = mValues[index + 1];
+      intervalDistance = simpleDistance * (mValues.Length() - 1) - index;
+      ScaleIntervalDistance(intervalDistance, index, mValues.Length() - 1);
+    }
+  }
+
+  if (mCalcMode.GetIntegerValue() == calc_discrete) {
+    aResult = mValues[index];
+    return NS_OK;
+  }
+  else {
+    return from.Interpolate(to,
+                            static_cast<float>(intervalDistance),
+                            aResult);
+  }
+}
+
+nsresult
+nsSMILAnimationFunction::AccumulateResult(nsSMILValue& aResult)
+{
+  if (!IsToAnimation() && mAccumulate.GetIntegerValue() && mRepeatIteration)
+  {
+    nsSMILValue repeatValue(aResult.mType);
+    nsSMILValue lastValue = mValues[mValues.Length() - 1];
+
+    // If the target attribute doesn't support addition, Repeat will fail and we
+    // leave aResult untouched.
+    if (NS_SUCCEEDED(repeatValue.Repeat(mRepeatIteration - 1,
+                                        &lastValue)))
+      aResult.Add(repeatValue);
+  }
+
+  return NS_OK;
+}
+
+/*
+ * Scale the simple distance taking into account any keyTimes.
+ */
+void
+nsSMILAnimationFunction::ScaleSimpleDistance(PRFloat64& dist)
+{
+  if (!GET_FLAG(mSetFlags, BF_KEY_TIMES))
+    return;
+
+  PRUint32 numTimes = mKeyTimes.Length();
+
+  if (numTimes < 2)
+    return;
+
+  PRUint32 i = 0;
+  for (; i < numTimes - 2 && dist >= mKeyTimes[i+1]; ++i);
+
+  PRFloat64& intervalStart = mKeyTimes[i];
+  PRFloat64& intervalEnd   = mKeyTimes[i+1];
+
+  PRFloat64 intervalLength = intervalEnd - intervalStart;
+  if (intervalLength <= 0.0) {
+    dist = intervalStart;
+    return;
+  }
+
+  dist = (i + (dist - intervalStart) / intervalLength) *
+         1.0 / (PRFloat64)(numTimes - 1);
+}
+
+/*
+ * Scale the interval distance taking into account any keySplines
+ * or discrete methods.
+ */
+void
+nsSMILAnimationFunction::ScaleIntervalDistance(PRFloat64& aDist,
+                                               PRUint32 aIntervalIndex,
+                                               PRUint32 aNumIntervals)
+{
+  if (mCalcMode.GetIntegerValue() != calc_spline)
+    return;
+
+  if (!GET_FLAG(mSetFlags, BF_KEY_SPLINES))
+    return;
+
+  NS_ASSERTION(aIntervalIndex >= 0 &&
+               aIntervalIndex < (PRUint32)mKeySplines.Length(),
+               "Invalid interval index.");
+  NS_ASSERTION(aNumIntervals >= 1, "Invalid number of intervals.");
+
+  if (aIntervalIndex < 0 ||
+      aIntervalIndex >= (PRUint32)mKeySplines.Length() ||
+      aNumIntervals < 1)
+    return;
+
+  nsSMILKeySpline const &spline = mKeySplines[aIntervalIndex];
+  aDist = spline.GetSplineValue(aDist);
+}
+
+/*
+ * SMILANIM specifies the following rules for animation function values:
+ *
+ * (1) if values is set, it overrides everything
+ * (2) for from/to/by animation at least to or by must be specified, from on its
+ *     own (or nothing) is an error--which we will ignore
+ * (3) if both by and to are specified only to will be used, by will be ignored
+ * (4) if by is specified without from (by animation), forces additive behaviour
+ * (5) if to is specified without from (to animation), special care needs to be
+ *     taken when compositing animation as such animations are composited last.
+ *
+ * This helper method applies these rules to fill in the values list and to set
+ * some internal state.
+ */
+void
+nsSMILAnimationFunction::FillValuesArray()
+{
+  if (!GET_FLAG(mSetFlags, BF_VALUES)) {
+    mValues.Clear();
+    mValues.SetCapacity(2);
+
+    if (!mTo.IsNull()) {
+      if (!mFrom.IsNull()) {
+        mValues.AppendElement(mFrom);
+        mValues.AppendElement(mTo);
+      } else {
+        mValues.AppendElement(mTo);
+      }
+    } else if (!mBy.IsNull()) {
+      if (!mFrom.IsNull()) {
+        //
+        // Set values to 'from; from + by'
+        //
+        mValues.AppendElement(mFrom);
+        nsSMILValue to = mFrom;
+        if (!to.IsNull() && NS_SUCCEEDED(to.Add(mBy))) {
+          mValues.AppendElement(to);
+        } else {
+          mValues.Clear();
+        }
+      } else {
+        //
+        // Set values to '0; by'
+        //
+        nsSMILValue from(mBy.mType);
+        if (!from.IsNull()) {
+          mValues.AppendElement(from);
+          mValues.AppendElement(mBy);
+        } else {
+          mValues.Clear();
+        }
+      }
+    }
+    // else, do nothing, mValues has been cleared already.
+  }
+
+  // mValues has changed, do we still have the right number of keySplines and
+  // keyTimes?
+  CheckKeyTimes();
+  CheckKeySplines();
+}
+
+inline PRBool
+nsSMILAnimationFunction::IsToAnimation() const
+{
+  return (!GET_FLAG(mSetFlags, BF_VALUES) && !mTo.IsNull() && mFrom.IsNull());
+}
+
+inline PRBool
+nsSMILAnimationFunction::IsAdditive() const
+{
+  /*
+   * Animation is additive if:
+   *
+   * (1) additive = "sum" (mAdditive == true), or
+   * (2) it is 'by animation' (by is set, from and values are not)
+   *
+   * Although animation is not additive if it is 'to animation'
+   */
+  return (!IsToAnimation() &&
+      (mAdditive.GetIntegerValue() ||
+       (!GET_FLAG(mSetFlags, BF_VALUES) && !mBy.IsNull() && mFrom.IsNull())));
+}
+
+/**
+ * Performs checks for the keyTimes attribute required by the SMIL spec but
+ * which depend on other attributes and therefore needs to be updated as
+ * dependent attributes are set.
+ */
+void
+nsSMILAnimationFunction::CheckKeyTimes()
+{
+  if (!GET_FLAG(mSetFlags, BF_KEY_TIMES))
+    return;
+
+  // attribute is ignored for calcMode = paced
+  if (mCalcMode.GetIntegerValue() == calc_paced) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+    return;
+  }
+
+  if (mKeyTimes.Length() < 1) {
+    // keyTimes isn't set or failed preliminary checks
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // no. keyTimes == no. values
+  if ((mKeyTimes.Length() != mValues.Length() && !IsToAnimation()) ||
+      (IsToAnimation() && mKeyTimes.Length() != 2)) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // special handling if there is only one keyTime. The spec doesn't say what to
+  // do in this case so we allow the keyTime to be either 0 or 1.
+  if (mKeyTimes.Length() == 1) {
+    PRFloat64 time = mKeyTimes[0];
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, !(time == 0.0 || time == 1.0));
+    return;
+  }
+
+  // there is a contradiction in the spec here. We're told the last value must
+  // be 1 for linear or spline calcMode's but then an example is given later of
+  // a from-to animation with a spline calcMode and keyTimes "0.0; 0.7".
+
+#ifndef ALLOW_BAD_KEYTIMES
+  // first value must be 0
+  if (mKeyTimes[0] != 0.0) {
+    SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+    return;
+  }
+
+  // last value must be 1 for linear or spline calcMode's
+  if (mCalcMode.GetIntegerValue() == calc_linear ||
+      mCalcMode.GetIntegerValue() == calc_spline) {
+    PRFloat64 lastValue = mKeyTimes[mKeyTimes.Length() - 1];
+    if (lastValue != 1.0) {
+      SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_TRUE);
+      return;
+    }
+  }
+#endif
+
+  SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+}
+
+void
+nsSMILAnimationFunction::CheckKeySplines()
+{
+  // attribute is ignored if calc mode is not spline
+  if (mCalcMode.GetIntegerValue() != calc_spline) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  // calc mode is spline but the attribute is not set
+  if (!GET_FLAG(mSetFlags, BF_KEY_SPLINES)) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  if (mKeySplines.Length() < 1) {
+    // keyTimes isn't set or failed preliminary checks
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_TRUE);
+    return;
+  }
+
+  // ignore splines if there's only one value
+  if (mValues.Length() == 1 && !IsToAnimation()) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+    return;
+  }
+
+  // no. keySpline specs == no. values - 1
+  PRUint32 splineSpecs = mKeySplines.Length();
+  if ((splineSpecs != mValues.Length() - 1 && !IsToAnimation()) ||
+      (IsToAnimation() && splineSpecs != 1)) {
+    SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_TRUE);
+    return;
+  }
+
+  SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+}
+
+//----------------------------------------------------------------------
+// Property setters / un-setters:
+
+void
+nsSMILAnimationFunction::SetDocumentPosition(PRUint16 aDocPosition)
+{
+  mDocumentPosition = aDocPosition;
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetAdditive(const nsAString& aAdditive)
+{
+  mHasChanged = PR_TRUE;
+  return mAdditive.SetStringValue(aAdditive);
+}
+
+void
+nsSMILAnimationFunction::UnsetAdditive()
+{
+  mAdditive.SetIntegerValue((PRUint16)PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetBy(const nsAString& aBy)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = mAttribute->ValueFromString(aBy, mBy);
+  SET_FLAG(mErrorFlags, BF_BY, NS_FAILED(rv));
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  FillValuesArray();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetBy()
+{
+  mBy = nsSMILValue();
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_BY, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetCalcMode(const nsAString& aCalcMode)
+{
+  mHasChanged = PR_TRUE;
+  nsresult rv = mCalcMode.SetStringValue(aCalcMode);
+  SET_FLAG(mErrorFlags, BF_CALC_MODE, NS_FAILED(rv));
+  CheckKeyTimes();
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetCalcMode()
+{
+  mCalcMode.SetIntegerValue(calc_linear);
+  SET_FLAG(mErrorFlags, BF_CALC_MODE, PR_FALSE);
+  mHasChanged = PR_TRUE;
+  CheckKeyTimes();
+  CheckKeySplines();
+}
+
+nsresult
+nsSMILAnimationFunction::SetAccumulate(const nsAString& aAccumulate)
+{
+  mHasChanged = PR_TRUE;
+  return mAccumulate.SetStringValue(aAccumulate);
+}
+
+void
+nsSMILAnimationFunction::UnsetAccumulate()
+{
+  mAccumulate.SetIntegerValue((PRUint16)PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+
+nsresult
+nsSMILAnimationFunction::SetFrom(const nsAString& aFrom)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = mAttribute->ValueFromString(aFrom, mFrom);
+  SET_FLAG(mErrorFlags, BF_FROM, NS_FAILED(rv));
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  FillValuesArray();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetFrom()
+{
+  mFrom = nsSMILValue();
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_FROM, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetKeySplines(const nsAString& aKeySplines)
+{
+  mKeySplines.Clear();
+
+  nsTArray<PRFloat64> keySplines;
+  nsresult rv = nsSMILParserUtils::GetKeySplines(aKeySplines, keySplines);
+
+  if (keySplines.Length() < 1 || keySplines.Length() % 4)
+    rv = NS_ERROR_FAILURE;
+
+  if (NS_SUCCEEDED(rv))
+  {
+    mKeySplines.SetCapacity(keySplines.Length() % 4);
+    for (PRUint32 i = 0; i < keySplines.Length() && NS_SUCCEEDED(rv); i += 4)
+    {
+      if (!mKeySplines.AppendElement(nsSMILKeySpline(keySplines[i],
+                                                     keySplines[i+1],
+                                                     keySplines[i+2],
+                                                     keySplines[i+3]))) {
+        rv = NS_ERROR_OUT_OF_MEMORY;
+      }
+    }
+  }
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mSetFlags, BF_KEY_SPLINES, PR_TRUE);
+
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetKeySplines()
+{
+  mKeySplines.Clear();
+  SET_FLAG(mErrorFlags, BF_KEY_SPLINES, PR_FALSE);
+  SET_FLAG(mSetFlags, BF_KEY_SPLINES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetKeyTimes(const nsAString& aKeyTimes)
+{
+  mKeyTimes.Clear();
+  nsresult rv = nsSMILParserUtils::GetKeyTimes(aKeyTimes, mKeyTimes);
+
+  if (NS_SUCCEEDED(rv) && mKeyTimes.Length() < 1)
+    rv = NS_ERROR_FAILURE;
+
+  if (NS_FAILED(rv))
+    mKeyTimes.Clear();
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mSetFlags, BF_KEY_TIMES, PR_TRUE);
+
+  CheckKeyTimes();
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetKeyTimes()
+{
+  mKeyTimes.Clear();
+  SET_FLAG(mErrorFlags, BF_KEY_TIMES, PR_FALSE);
+  SET_FLAG(mSetFlags, BF_KEY_TIMES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetTo(const nsAString& aTo)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  nsresult rv = mAttribute->ValueFromString(aTo, mTo);
+  SET_FLAG(mErrorFlags, BF_TO, NS_FAILED(rv));
+  if (NS_FAILED(rv))
+    return NS_ERROR_FAILURE;
+
+  FillValuesArray();
+  mHasChanged = PR_TRUE;
+
+  return NS_OK;
+}
+
+void
+nsSMILAnimationFunction::UnsetTo()
+{
+  mTo = nsSMILValue();
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_TO, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
+nsresult
+nsSMILAnimationFunction::SetValues(const nsAString& aValues)
+{
+  if (!mAttribute)
+    return NS_ERROR_FAILURE;
+
+  mValues.Clear();
+  SET_FLAG(mSetFlags, BF_VALUES, PR_FALSE);
+
+  nsresult rv = nsSMILParserUtils::GetValues(aValues, mValues, *mAttribute);
+
+  if (NS_SUCCEEDED(rv))
+    SET_FLAG(mSetFlags, BF_VALUES, PR_TRUE);
+  else
+    mValues.Clear();
+
+  mHasChanged = PR_TRUE;
+  SET_FLAG(mErrorFlags, BF_VALUES, NS_FAILED(rv));
+  CheckKeyTimes();
+  CheckKeySplines();
+
+  return rv;
+}
+
+void
+nsSMILAnimationFunction::UnsetValues()
+{
+  SET_FLAG(mSetFlags, BF_VALUES, PR_FALSE);
+  FillValuesArray();
+  SET_FLAG(mErrorFlags, BF_VALUES, PR_FALSE);
+  mHasChanged = PR_TRUE;
+}
+
Index: mozilla/smil/src/nsSMILAnimationRegistry.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILAnimationRegistry.cpp
@@ -0,0 +1,295 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILAnimationRegistry.h"
+#include "nsISMILAnimationObserver.h"
+#include "nsISMILAttr.h"
+#include "nsISMILComposable.h"
+#include "nsSMILTimedDocumentRoot.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILAnimationRegistry implementation
+
+//----------------------------------------------------------------------
+// ctors, dtors, factory methods
+
+nsSMILAnimationRegistry::~nsSMILAnimationRegistry()
+{
+  if (mController && mTimedDocumentRoot)
+    mController->RemoveTimeContainer(mTimedDocumentRoot);
+}
+
+nsISMILAnimationRegistry*
+NS_NewSMILAnimationRegistry()
+{
+  nsSMILAnimationRegistry* animationRegistry = new nsSMILAnimationRegistry();
+
+  if (!animationRegistry)
+    return nsnull;
+
+  nsresult rv = animationRegistry->Init();
+  if (NS_FAILED(rv)) {
+    delete animationRegistry;
+    animationRegistry = nsnull;
+  }
+
+  return animationRegistry;
+}
+
+nsresult
+nsSMILAnimationRegistry::Init()
+{
+  mTimedDocumentRoot = new nsSMILTimedDocumentRoot(this);
+  NS_ENSURE_TRUE(mTimedDocumentRoot, NS_ERROR_OUT_OF_MEMORY);
+
+  mTimedDocumentRoot->Pause();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS1(nsSMILAnimationRegistry,
+                   nsISMILAnimationRegistry)
+
+//----------------------------------------------------------------------
+// nsISMILAnimationRegistry methods:
+
+nsresult
+nsSMILAnimationRegistry::SetController(nsISMILAnimationController* aController)
+{
+  nsresult rv = NS_OK;
+
+  NS_ENSURE_TRUE(mTimedDocumentRoot, NS_ERROR_FAILURE);
+
+  if (mController) {
+    rv = mController->RemoveTimeContainer(mTimedDocumentRoot);
+    NS_ENSURE_SUCCESS(rv,rv);
+  }
+
+  mController = aController;
+
+  if (mController)
+    rv = mController->AddTimeContainer(mTimedDocumentRoot);
+
+  return rv;
+}
+
+void
+nsSMILAnimationRegistry::SetObserver(nsISMILAnimationObserver* aObserver)
+{
+  if (aObserver) {
+    mObserver = do_GetWeakReference(aObserver);
+  } else {
+    mObserver = nsnull;
+  }
+}
+
+nsresult
+nsSMILAnimationRegistry::Start()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,NS_ERROR_FAILURE);
+  if (!mStarted) {
+    mTimedDocumentRoot->Resume();
+    mStarted = PR_TRUE;
+  }
+  return NS_OK;
+}
+
+void
+nsSMILAnimationRegistry::Pause()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,);
+  NS_ENSURE_TRUE(mStarted,);
+  mTimedDocumentRoot->Pause();
+}
+
+void
+nsSMILAnimationRegistry::Unpause()
+{
+  NS_ENSURE_TRUE(mTimedDocumentRoot,);
+  NS_ENSURE_TRUE(mStarted,);
+  mTimedDocumentRoot->Resume();
+}
+
+PRBool
+nsSMILAnimationRegistry::IsPaused()
+{
+  if (!mStarted)
+    return PR_TRUE;
+
+  NS_ENSURE_TRUE(mTimedDocumentRoot,PR_FALSE);
+
+  return mTimedDocumentRoot->IsPaused();
+}
+
+float
+nsSMILAnimationRegistry::GetCurrentTime()
+{
+  PRFloat64 fCurrentTime;
+  PRInt64 currentTime = mTimedDocumentRoot->GetDocumentTime();
+  LL_L2D(fCurrentTime, currentTime);
+  return (float)(fCurrentTime / PR_MSEC_PER_SEC);
+}
+
+nsresult
+nsSMILAnimationRegistry::SetCurrentTime(float aSeconds)
+{
+  PRInt64 lSeconds;
+  LL_D2L(lSeconds, aSeconds);
+  LL_MUL(lSeconds, PR_MSEC_PER_SEC, lSeconds);
+  return mTimedDocumentRoot->SeekToTime(lSeconds);
+}
+
+nsresult
+nsSMILAnimationRegistry::RegisterComposable(nsISMILAttr* aTargetAttr,
+                                            nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aTargetAttr);
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  nsSMILCompositor*   compositor = nsnull;
+
+  //
+  // Iterate in reverse as if a compositor already exists for this attribute it
+  // is most likely to be the most recently added entry.
+  //
+  for (PRUint32 i = mCompositors.Length(); i > 0 && !compositor;) {
+    CompositorEntry &entry = mCompositors[--i];
+    if (entry.mKey->EqualTarget(*aTargetAttr))
+      compositor = &entry.mCompositor;
+  }
+
+  if (!compositor) {
+    CompositorEntry *new_entry = mCompositors.AppendElement();
+    NS_ENSURE_TRUE(new_entry,NS_ERROR_OUT_OF_MEMORY);
+
+    nsresult rv = new_entry->mCompositor.Init(aTargetAttr);
+    if (NS_FAILED(rv)) {
+      mCompositors.RemoveElementAt(mCompositors.Length() - 1);
+      return rv;
+    }
+    NS_ENSURE_SUCCESS(rv,rv);
+
+    new_entry->mKey = aTargetAttr;
+
+    compositor = &new_entry->mCompositor;
+  }
+
+  return compositor->AddComposable(aComposable);
+}
+
+nsresult
+nsSMILAnimationRegistry::UnregisterComposable(nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  PRBool              found = PR_FALSE;
+  nsresult            result = NS_OK;
+  nsresult            rv = NS_ERROR_FAILURE;
+  PRUint32            count = mCompositors.Length();
+
+  for (PRUint32 i = 0; i < count; ++i) {
+    CompositorEntry &entry = mCompositors[i];
+    rv = entry.mCompositor.RemoveComposable(aComposable);
+
+    // This rather complicated error handling just ensures that we report the
+    // first error that occurs, or a generic error if the item wasn't found.
+    if (NS_SUCCEEDED(result))
+      result = rv;
+    found = PR_TRUE;
+
+    // Even if the entry now no longer has any compositors we don't bother
+    // deleting it as it may be re-used again later.
+  }
+
+  return (found) ? rv : NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILAnimationRegistry::RegisterTimedElement(nsISMILTimedElement *aElement)
+{
+  return (mTimedDocumentRoot) ? mTimedDocumentRoot->AddTimedElement(aElement)
+                              : NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILAnimationRegistry::UnregisterTimedElement(nsISMILTimedElement *aElement)
+{
+  return (mTimedDocumentRoot) ? mTimedDocumentRoot->RemoveTimedElement(aElement)
+                              : NS_ERROR_FAILURE;
+}
+
+void
+nsSMILAnimationRegistry::StartSample()
+{
+  if (mObserver) {
+    nsCOMPtr<nsISMILAnimationObserver> observer = do_QueryReferent(mObserver);
+    if (observer)
+      observer->StartSample();
+  }
+
+  // Do any pre-animation actions here, e.g. acquiring locks, blocking scripts
+  // etc.
+}
+
+void
+nsSMILAnimationRegistry::EndSample()
+{
+  nsCOMPtr<nsISMILAnimationObserver> observer;
+
+  if (mObserver)
+    observer = do_QueryReferent(mObserver);
+
+  if (observer)
+    observer->StartCompositing();
+
+  PRUint32 count = mCompositors.Length();
+  for (PRUint32 i = 0; i < count; ++i) {
+    mCompositors[i].mCompositor.ComposeSample();
+  }
+
+  if (observer)
+    observer->EndCompositing();
+
+  // Release any locks etc.
+
+  if (observer)
+    observer->EndSample();
+}
+
Index: mozilla/smil/src/nsSMILAnimationRegistry.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILAnimationRegistry.h
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILANIMATIONREGISTRY_H__
+#define __NS_SMILANIMATIONREGISTRY_H__
+
+#include "nsISMILAnimationRegistry.h"
+#include "nsISMILAnimationController.h"
+#include "nsSMILCompositor.h"
+#include "nsTArray.h"
+#include "nsAutoPtr.h"
+#include "nsWeakPtr.h"
+
+class nsSMILTimedDocumentRoot;
+class nsISMILAttr;
+
+class nsSMILAnimationRegistry : public nsISMILAnimationRegistry
+{
+public:
+  ~nsSMILAnimationRegistry();
+
+  NS_DECL_ISUPPORTS
+
+  virtual void      StartSample();
+  virtual void      EndSample();
+
+  // nsISMILAnimationRegistry
+  virtual nsresult  SetController(nsISMILAnimationController* aController);
+  virtual void      SetObserver(nsISMILAnimationObserver* aObserver);
+  virtual nsresult  Start();
+  virtual void      Pause();
+  virtual void      Unpause();
+  virtual PRBool    IsPaused();
+  virtual float     GetCurrentTime();
+  virtual nsresult  SetCurrentTime(float aSeconds);
+  virtual nsresult  RegisterComposable(nsISMILAttr *aTargetAttr,
+                                       nsISMILComposable *aComposable);
+  virtual nsresult  UnregisterComposable(nsISMILComposable *aComposable);
+  virtual nsresult  RegisterTimedElement(nsISMILTimedElement *aElement);
+  virtual nsresult  UnregisterTimedElement(nsISMILTimedElement *aElement);
+
+protected:
+  friend nsISMILAnimationRegistry* NS_NewSMILAnimationRegistry();
+
+  nsresult          Init();
+
+  struct CompositorEntry
+  {
+    nsISMILAttr*      mKey;
+    nsSMILCompositor  mCompositor;
+  };
+
+  nsTArray<CompositorEntry>             mCompositors;
+  nsRefPtr<nsSMILTimedDocumentRoot>     mTimedDocumentRoot;
+  nsCOMPtr<nsISMILAnimationController>  mController;
+  nsWeakPtr                             mObserver;
+  PRBool                                mStarted;
+
+private:
+  // This class should only be created by the factory method
+  nsSMILAnimationRegistry() : mStarted(PR_FALSE) {}
+
+  // Pass by value and assignment should not be used
+  nsSMILAnimationRegistry(const nsSMILAnimationRegistry& other);
+  nsSMILAnimationRegistry& operator=(const nsSMILAnimationRegistry& right);
+};
+
+#endif // __NS_SMILANIMATIONREGISTRY_H__
+
Index: mozilla/smil/src/nsSMILCompositor.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILCompositor.cpp
@@ -0,0 +1,144 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILCompositor.h"
+#include "nsISMILComposable.h"
+#include "nsISimpleEnumerator.h"
+#include "nsArrayEnumerator.h"
+#include "nsISMILAttr.h"
+#include "nsSMILValue.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILCompositor implementation
+
+nsresult
+nsSMILCompositor::Init(nsISMILAttr* aTargetAttribute)
+{
+  NS_ENSURE_ARG_POINTER(aTargetAttribute);
+
+  mTargetAttribute = aTargetAttribute;
+
+  return aTargetAttribute->GetBaseValue(mResult);
+}
+
+nsresult
+nsSMILCompositor::AddComposable(nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aComposable, &rv)) );
+
+  if (NS_SUCCEEDED(rv))
+    rv = (mChildren.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  return rv;
+}
+
+nsresult
+nsSMILCompositor::RemoveComposable(nsISMILComposable* aComposable)
+{
+  NS_ENSURE_ARG_POINTER(aComposable);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aComposable, &rv)) );
+
+  if (NS_SUCCEEDED(rv))
+    rv = (mChildren.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  return rv;
+}
+
+void
+nsSMILCompositor::ComposeSample()
+{
+  NS_ENSURE_TRUE(mTargetAttribute,);
+  nsresult rv;
+
+  rv = mTargetAttribute->GetBaseValue(mResult);
+  NS_ENSURE_SUCCESS(rv,);
+
+  mChildren.Sort(SortCompositors, nsnull);
+
+  PRBool changed = PR_FALSE;
+  nsCOMPtr<nsISMILComposable> composable;
+  PRUint32 length = mChildren.Count();
+  PRUint32 i;
+
+  for (i = length; i > 0; --i) {
+    composable = do_QueryReferent(mChildren[i-1]);
+    if (composable) {
+      changed |= composable->HasChanged();
+      if (composable->WillReplace()) {
+        --i;
+        break;
+     }
+    }
+  }
+
+  if (!changed)
+    return;
+
+  for (; i < length; ++i)
+  {
+    composable = do_QueryReferent(mChildren[i]);
+    if (composable)
+      composable->ComposeResult(mResult);
+  }
+
+  // We can't just call Set on the animated value itself, because the observers
+  // of the animated object as a whole need to be updated too.
+  rv = mTargetAttribute->SetAnimValue(mResult);
+  NS_ENSURE_SUCCESS(rv,);
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+PR_CALLBACK int
+nsSMILCompositor::SortCompositors(nsIWeakReference* aRef1,
+                                  nsIWeakReference* aRef2,
+                                  void* /*aData*/)
+{
+  nsCOMPtr<nsISMILComposable> a = do_QueryReferent(aRef1);
+  nsCOMPtr<nsISMILComposable> b = do_QueryReferent(aRef2);
+
+  return (a && b) ? a->CompareTo(*b) : (a) ? 1 : (b) ? -1 : 0;
+}
+
Index: mozilla/smil/src/nsSMILCompositor.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILCompositor.h
@@ -0,0 +1,79 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILCOMPOSITOR_H__
+#define __NS_SMILCOMPOSITOR_H__
+
+#include "nsCOMArray.h"
+#include "nsWeakReference.h"
+#include "nsSMILValue.h"
+#include "nsISMILAttr.h"
+#include "nsAutoPtr.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILCompositor: Collection of nsISMILComposable animations
+
+class nsISMILComposable;
+
+class nsSMILCompositor
+{
+public:
+  nsSMILCompositor() {}
+
+  nsresult  Init(nsISMILAttr* aTargetAttribute);
+
+  nsresult  AddComposable(nsISMILComposable* aComposable);
+  nsresult  RemoveComposable(nsISMILComposable* aComposable);
+  void      ComposeSample();
+
+protected:
+  PR_STATIC_CALLBACK(int) SortCompositors(nsIWeakReference* aRef1,
+                                          nsIWeakReference* aRef2,
+                                          void* aData);
+
+  nsCOMArray<nsIWeakReference>   mChildren;
+  nsSMILValue                    mResult;
+  nsRefPtr<nsISMILAttr>          mTargetAttribute;
+
+private:
+  // Pass by value and assignment should not be used
+  nsSMILCompositor(const nsSMILCompositor& other);
+  nsSMILCompositor& operator=(const nsSMILCompositor& right);
+};
+
+#endif // __NS_SMILCOMPOSITOR_H__
+
Index: mozilla/smil/src/nsSMILEnum.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILEnum.cpp
@@ -0,0 +1,95 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Rowley <tor@cs.brown.edu> (original author)
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILEnum.h"
+#include "nsGkAtoms.h"
+#include "nsString.h"
+#include "nsCRT.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSMILEnum::nsSMILEnum(PRUint16 value,
+                       nsSMILEnumMapping *mapping)
+    : mValue(value), mMapping(mapping)
+{
+  nsGkAtoms::AddRefAtoms();
+}
+
+nsresult
+nsSMILEnum::SetStringValue(const nsAString& aValue)
+{
+  //
+  // According to XML 1.0, section 3.3.3 we need to discard leading and trailing
+  // whitespace for this attribute. Currently nsSVGEnum doesn't do this
+  // otherwise we might try and re-use some of that functionality here
+  //
+  nsAString::const_iterator start;
+  nsAString::const_iterator end;
+
+  aValue.BeginReading(start);
+  aValue.EndReading(end);
+
+  while (*start && NS_IS_SPACE(*start))
+    ++start;
+
+  do --end; while (start != end && NS_IS_SPACE(*end));
+    ++end;
+
+  nsCOMPtr<nsIAtom> valAtom = do_GetAtom(Substring(start, end));
+
+  nsSMILEnumMapping *tmp = mMapping;
+
+  if (!tmp)
+    return NS_ERROR_FAILURE;
+
+  while (tmp->key) {
+    if (valAtom == *(tmp->key)) {
+      mValue = tmp->val;
+      return NS_OK;
+    }
+    tmp++;
+  }
+
+  // XXXbb Should be report a warning somehow?
+  // NS_WARNING("Unknown enumeration key");
+
+  return NS_ERROR_FAILURE;
+}
+
Index: mozilla/smil/src/nsSMILEnum.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILEnum.h
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is
+ * IBM Corporation
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Tim Rowley <tor@cs.brown.edu> (original author)
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILENUM_H__
+#define __NS_SMILENUM_H__
+
+#include "nsIAtom.h"
+
+struct nsSMILEnumMapping
+{
+    nsIAtom **key;
+    PRUint16 val;
+};
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILEnum class
+
+class nsSMILEnum
+{
+public:
+  nsSMILEnum(PRUint16 value, nsSMILEnumMapping *mapping);
+
+  PRUint16  GetIntegerValue() const { return mValue; }
+  void      SetIntegerValue(const PRUint16 &aValue) { mValue = aValue; }
+  nsresult  SetStringValue(const nsAString &aValue);
+
+protected:
+  PRUint16          mValue;
+  nsSMILEnumMapping *mMapping;
+};
+
+#endif //__NS_SMILENUM_H__
+
Index: mozilla/smil/src/nsSMILFloatType.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILFloatType.cpp
@@ -0,0 +1,116 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILFloatType.h"
+#include "nsSMILValue.h"
+#include "nsDebug.h"
+
+/*static*/ nsSMILFloatType nsSMILFloatType::sSingleton;
+
+void
+nsSMILFloatType::SetValueIdentity(nsSMILValue& aValue)
+{
+  aValue.mU.mDouble = 0.0;
+}
+
+nsresult
+nsSMILFloatType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mType = &sSingleton;
+  aDest.mU.mDouble = aSrc.mU.mDouble;
+  return NS_OK;
+}
+
+nsresult nsSMILFloatType::Add(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == aDest.mType, "Trying to add invalid types");
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mU.mDouble += aSrc.mU.mDouble;
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::ComputeDistance(const nsSMILValue& aFrom,
+                                 const nsSMILValue& aTo,
+                                 PRFloat64& aDistance) const
+{
+  NS_ASSERTION(aFrom.mType == aTo.mType, "Trying to compare different types");
+  NS_ASSERTION(aFrom.mType == &sSingleton, "Unexpected source type");
+  NS_NOTYETIMPLEMENTED("nsSMILFloatType::ComputeDistance");
+  aDistance = 0.0;
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Interpolate(const nsSMILValue& aStartVal,
+                             const nsSMILValue& aEndVal,
+                             float aUnitDistance,
+                             nsSMILValue& aResult)
+{
+  NS_ASSERTION(aStartVal.mType == aEndVal.mType,
+      "Trying to interpolate different types");
+  NS_ASSERTION(aStartVal.mType == &sSingleton, "Unexpected type");
+
+  const double &startVal = aStartVal.mU.mDouble;
+  const double &endVal   = aEndVal.mU.mDouble;
+
+  aResult.mU.mDouble = (startVal + (endVal - startVal) * aUnitDistance);
+  aResult.mType      = &sSingleton;
+
+  return NS_OK;
+}
+
+nsresult
+nsSMILFloatType::Repeat(nsSMILValue& aDest,
+                        PRUint32 aCount,
+                        const nsSMILValue* aRepeatValue)
+{
+
+  NS_ASSERTION(aDest.mType == &sSingleton, "Trying to repeat invalid type");
+  NS_ASSERTION(!aRepeatValue || aRepeatValue->mType == &sSingleton,
+    "Invalid repeat type");
+
+  double const &value = (aRepeatValue)
+                      ? aRepeatValue->mU.mDouble
+                      : aDest.mU.mDouble;
+  aDest.mU.mDouble = value * (aCount + 1);
+
+  return NS_OK;
+}
+
Index: mozilla/smil/src/nsSMILInstanceTime.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILInstanceTime.cpp
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILInstanceTime.h"
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILTimeValue.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSMILInstanceTime::nsSMILInstanceTime(const nsSMILTimeValue &aTime,
+                                       nsSMILTimeValueSpec *aCreator,
+                                       PRBool aClearOnReset /*=false*/)
+  : mTime(aTime), // Copy the time
+    mClearOnReset(aClearOnReset)
+{
+  if (aCreator)
+    mCreator = do_GetWeakReference(aCreator);
+}
+
+NS_IMPL_ISUPPORTS1(nsSMILInstanceTime,
+                   nsSMILInstanceTime)
+
+//----------------------------------------------------------------------
+// nsSMILInstanceTime
+
+PR_CALLBACK int
+nsSMILInstanceTime::ComparisonCallback(nsSMILInstanceTime* aElement1,
+                                       nsSMILInstanceTime* aElement2,
+                                       void* /*aData*/)
+{
+  return aElement1->Time().CompareTo(aElement2->Time());
+}
+
Index: mozilla/smil/src/nsSMILInstanceTime.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILInstanceTime.h
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILINSTANCETIME_H__
+#define __NS_SMILINSTANCETIME_H__
+
+#include "nsISupports.h"
+#include "nsSMILTimeValue.h"
+#include "nsWeakReference.h"
+
+class nsSMILTimeValueSpec;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILInstanceTime : An instant in document simple time that may be
+//                      used in creating a new interval
+
+// {8d5be43a-f4ce-445b-9c85-181eb6f8e34c}
+#define NS_SMILINSTANCETIME_IID \
+{ 0x8d5be43a, 0xf4ce, 0x445b, { 0x9c, 0x85, 0x18, 0x1e, 0xb6, 0xf8, 0xe3, 0x4c } }
+
+class nsSMILInstanceTime : public nsISupports
+{
+public:
+  nsSMILInstanceTime(const nsSMILTimeValue &aTime,
+                     nsSMILTimeValueSpec *aCreator,
+                     PRBool aClearOnReset = PR_FALSE);
+
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_SMILINSTANCETIME_IID)
+  NS_DECL_ISUPPORTS
+
+  const nsSMILTimeValue&  Time() const { return mTime; }
+
+  PRBool                  ClearOnReset() const { return mClearOnReset; }
+
+  // void DependentUpdate(const nsSMILTimeValue& aNewTime); -- NOT YET IMPL.
+
+  PR_STATIC_CALLBACK(int) ComparisonCallback(nsSMILInstanceTime* aElement1,
+                                             nsSMILInstanceTime* aElement2,
+                                             void* aData);
+
+protected:
+  nsSMILTimeValue     mTime;
+
+  /**
+   * The nsSMILTimeValueSpec that created this instance time if any. This will
+   * be NULL for instance times created via DOM calls etc.
+   */
+  nsWeakPtr           mCreator;
+
+  /**
+   * Indicates if this instance time should be removed when the owning timed
+   * element is reset. True for events and DOM calls.
+   */
+  PRBool              mClearOnReset;
+
+  /*
+   * This will only be used for for identifying the instance times associated
+   * with a deleting interval. We will never de-reference this pointer, but only
+   * use it for pointer comparisons. Therefore it's not necessary for instances
+   * of nsSMILInterval to be reference-counted.
+   */
+  // nsSMILInterval   *mTimebase -- NOT YET IMPLEMENTED
+
+private:
+  // Pass by value and assignment should not be used
+  nsSMILInstanceTime(const nsSMILInstanceTime& other);
+  nsSMILInstanceTime& operator=(const nsSMILInstanceTime& right);
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsSMILInstanceTime, NS_SMILINSTANCETIME_IID)
+
+#endif // __NS_SMILINSTANCETIME_H__
+
Index: mozilla/smil/src/nsSMILInterval.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILInterval.cpp
@@ -0,0 +1,75 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILInterval.h"
+#include "nsSMILInstanceTime.h"
+#include "nsCRT.h"
+
+// Creates a new interval with unresolved begin and end times
+nsSMILInterval::nsSMILInterval()
+: mBegin(),
+  mEnd()
+{
+}
+
+nsSMILInterval::nsSMILInterval(const nsSMILTimeValue& aBegin,
+                               const nsSMILTimeValue& aEnd)
+: mBegin(aBegin),
+  mEnd(aEnd)
+{
+}
+
+//----------------------------------------------------------------------
+// Implementation
+
+NS_IMPL_ISUPPORTS1(nsSMILInterval,
+                   nsSMILInterval)
+
+void
+nsSMILInterval::UpdateBegin(const nsSMILTimeValue &aNewTime)
+{
+  mBegin = aNewTime;
+  // XXX notify dependents
+}
+
+void
+nsSMILInterval::UpdateEnd(const nsSMILTimeValue &aNewTime)
+{
+  mEnd = aNewTime;
+  // XXX notify dependents
+}
+
Index: mozilla/smil/src/nsSMILInterval.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILInterval.h
@@ -0,0 +1,84 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILINTERVAL_H__
+#define __NS_SMILINTERVAL_H__
+
+#include "nsISupports.h"
+#include "nsSMILTimeValue.h"
+
+class nsSMILInstanceTime;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILInterval class
+
+// {443cdd3f-1d0c-4eb9-b043-5cde9e4ca35b}
+#define NS_SMILINTERVAL_IID \
+{ 0x443cdd3f, 0x1d0c, 0x4eb9, { 0xb0, 0x43, 0x5c, 0xde, 0x9e, 0x4c, 0xa3, 0x5b } }
+
+class nsSMILInterval : public nsISupports
+{
+public:
+  nsSMILInterval();
+  nsSMILInterval(const nsSMILTimeValue &aBegin,
+                 const nsSMILTimeValue &aEnd);
+
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_SMILINTERVAL_IID)
+  NS_DECL_ISUPPORTS
+
+  const nsSMILTimeValue& Begin() { return mBegin; }
+  const nsSMILTimeValue& End() { return mEnd; }
+
+  void UpdateBegin(const nsSMILTimeValue &aNewTime);
+  void UpdateEnd(const nsSMILTimeValue &aNewTime);
+
+  // We will need to track dependent instance times from here
+  //
+  // e.g.
+  //
+  // void  AddDependent(nsSMILInstanceTime& aDependent, PRBool aForBegin);
+  // void  RemoveDependent(nsSMILInstanceTime& aDependent, PRBool aForBegin);
+
+protected:
+  nsSMILTimeValue   mBegin;
+  nsSMILTimeValue   mEnd;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsSMILInterval, NS_SMILINTERVAL_IID)
+
+#endif // __NS_SMILINTERVAL_H__
+
Index: mozilla/smil/src/nsSMILKeySpline.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILKeySpline.cpp
@@ -0,0 +1,120 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILKeySpline.h"
+#include <math.h>
+
+#define NEWTON_ITERATIONS   4
+
+const PRFloat64 nsSMILKeySpline::kSampleStepSize =
+                                        1.0 / (PRFloat64)(kSplineTableSize - 1);
+
+nsSMILKeySpline::nsSMILKeySpline(const PRFloat64& aX1,
+                                 const PRFloat64& aY1,
+                                 const PRFloat64& aX2,
+                                 const PRFloat64& aY2)
+: mX1(aX1),
+  mY1(aY1),
+  mX2(aX2),
+  mY2(aY2)
+{
+  if (mX1 != mY1 || mX2 != mY2)
+    CalcSampleValues();
+}
+
+PRFloat64
+nsSMILKeySpline::GetSplineValue(const PRFloat64& x) const
+{
+  if (mX1 == mY1 && mX2 == mY2)
+    return x;
+
+  return CalcBezier(GetTForX(x), mY1, mY2);
+}
+
+void
+nsSMILKeySpline::CalcSampleValues()
+{
+  for (int i = 0; i < kSplineTableSize; ++i)
+    mSampleValues[i] = CalcBezier((PRFloat64)i * kSampleStepSize, mX1, mX2);
+}
+
+/*static*/ PRFloat64
+nsSMILKeySpline::CalcBezier(const PRFloat64& t,
+                            const PRFloat64& a1,
+                            const PRFloat64& a2)
+{
+  return A(a1, a2) * pow(t,3) + B(a1, a2)*t*t + C(a1) * t;
+}
+
+/*static*/ PRFloat64
+nsSMILKeySpline::GetSlope(const PRFloat64& t,
+                             const PRFloat64& a1,
+                             const PRFloat64& a2)
+{
+  PRFloat64 denom = (3.0 * A(a1, a2)*t*t + 2.0 * B(a1, a2) * t + C(a1));
+  return (denom == 0.0) ? 0.0 : 1.0 / denom;
+}
+
+PRFloat64
+nsSMILKeySpline::GetTForX(const PRFloat64& x) const
+{
+  int i;
+
+  // Get an initial guess.
+  //
+  // Note: This is better than just taking x as our initial guess as cases such
+  // as where the control points are (1, 1), (0, 0) will take some 20 iterations
+  // to converge to a good accuracy. By taking an initial guess in this way we
+  // only need 3~4 iterations depending on the size of the table.
+  for (i = 0; i < kSplineTableSize - 2 && mSampleValues[i] < x; ++i);
+  PRFloat64 currentT =
+    (PRFloat64)i * kSampleStepSize + (x - mSampleValues[i]) * kSampleStepSize;
+
+  // Refine with Newton-Raphson iteration
+  for (i = 0; i < NEWTON_ITERATIONS; ++i) {
+    PRFloat64 currentX = CalcBezier(currentT, mX1, mX2);
+    PRFloat64 currentSlope = GetSlope(currentT, mX1, mX2);
+
+    if (currentSlope == 0.0)
+      return currentT;
+
+    currentT -= (currentX - x) * currentSlope;
+  }
+
+  return currentT;
+}
+
Index: mozilla/smil/src/nsSMILKeySpline.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILKeySpline.h
@@ -0,0 +1,97 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILKEYSPLINE_H__
+#define __NS_SMILKEYSPLINE_H__
+
+#include "prtypes.h"
+
+/**
+ * Utility class to provide scaling defined in a keySplines element.
+ */
+class nsSMILKeySpline
+{
+public:
+  nsSMILKeySpline(const PRFloat64& aX1, const PRFloat64& aY1,
+                  const PRFloat64& aX2, const PRFloat64& aY2);
+
+  PRFloat64 GetSplineValue(const PRFloat64& x) const;
+
+private:
+  void
+  CalcSampleValues();
+
+  static PRFloat64
+  CalcBezier(const PRFloat64& t, const PRFloat64& a1, const PRFloat64& a2);
+
+  static PRFloat64
+  GetSlope(const PRFloat64& t, const PRFloat64& a1, const PRFloat64& a2);
+
+  PRFloat64
+  GetTForX(const PRFloat64& x) const;
+
+  static PRFloat64
+  A(const PRFloat64& a1, const PRFloat64& a2)
+  {
+    return 1.0 - 3.0 * a2 + 3.0 * a1;
+  }
+
+  static PRFloat64
+  B(const PRFloat64& a1, const PRFloat64& a2)
+  {
+    return 3.0 * a2 - 6.0 * a1;
+  }
+
+  static PRFloat64
+  C(const PRFloat64& a1)
+  {
+    return 3.0 * a1;
+  }
+
+  const PRFloat64         mX1;
+  const PRFloat64         mY1;
+  const PRFloat64         mX2;
+  const PRFloat64         mY2;
+
+  enum { kSplineTableSize = 11 };
+  PRFloat64               mSampleValues[kSplineTableSize];
+
+  static const PRFloat64  kSampleStepSize;
+};
+
+#endif // __NS_SMILKEYSPLINE_H__
+
Index: mozilla/smil/src/nsSMILNullType.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILNullType.cpp
@@ -0,0 +1,88 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Robert O'Callahan <roc+moz@cs.cmu.edu>
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILNullType.h"
+#include "nsSMILValue.h"
+#include "nsDebug.h"
+
+/*static*/ nsSMILNullType nsSMILNullType::sSingleton;
+
+nsresult
+nsSMILNullType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aSrc.mType == &sSingleton, "Unexpected source type");
+  aDest.mType = &sSingleton;
+  return NS_OK;
+}
+
+nsresult
+nsSMILNullType::Add(nsSMILValue&, const nsSMILValue&)
+{
+  NS_NOTREACHED("Adding NULL type.");
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::ComputeDistance(const nsSMILValue&,
+                                const nsSMILValue&,
+                                PRFloat64& aDistance) const
+{
+  NS_NOTREACHED("Computing distance for NULL type.");
+  aDistance = 0.0;
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::Interpolate(const nsSMILValue&,
+                            const nsSMILValue&,
+                            float,
+                            nsSMILValue&)
+{
+  NS_NOTREACHED("Interpolating NULL type.");
+  return NS_ERROR_FAILURE;
+}
+
+nsresult
+nsSMILNullType::Repeat(nsSMILValue&,
+                       PRUint32,
+                       const nsSMILValue*)
+{
+  NS_NOTREACHED("Repeating NULL type.");
+  return NS_ERROR_FAILURE;
+}
+
Index: mozilla/smil/src/nsSMILParserUtils.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILParserUtils.cpp
@@ -0,0 +1,617 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILParserUtils.h"
+#include "nsISMILAttr.h"
+#include "nsSMILValue.h"
+#include "nsSMILTimeValue.h"
+#include "nsString.h"
+#include "prdtoa.h"
+#include "nsCRT.h"
+#include "nsCOMPtr.h"
+#include "prlong.h"
+
+const PRUint32 nsSMILParserUtils::MSEC_PER_SEC   = 1000;
+const PRUint32 nsSMILParserUtils::MSEC_PER_MIN   = 1000 * 60;
+const PRUint32 nsSMILParserUtils::MSEC_PER_HOUR  = 1000 * 60 * 60;
+
+//------------------------------------------------------------------------------
+// Inlines
+
+// NS_IS_SPACE relies on isspace which may return true for \xB and \xC but
+// SMILANIM does not consider these characters to be whitespace.
+inline PRBool
+nsSMILParserUtils::IsSpace(const char c)
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline PRBool
+nsSMILParserUtils::IsSpace(const PRUnichar c)
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline void
+nsSMILParserUtils::SkipWsp(nsACString::const_iterator& aIter,
+                           const nsACString::const_iterator& aIterEnd)
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+inline void
+nsSMILParserUtils::SkipWsp(nsAString::const_iterator& aIter,
+                           const nsAString::const_iterator& aIterEnd)
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+inline PRFloat64
+nsSMILParserUtils::GetFloat(nsACString::const_iterator& aIter,
+                            const nsACString::const_iterator& aIterEnd,
+                            nsresult *aErrorCode)
+{
+  char *end;
+  const char *start = aIter.get();
+  PRFloat64 value = PR_strtod(start, &end);
+
+  nsresult rv = NS_OK;
+
+  if (end == start || end > aIterEnd.get())
+    rv = NS_ERROR_FAILURE;
+  else
+    aIter.advance(end - start);
+
+  if (aErrorCode)
+    *aErrorCode = rv;
+
+  return value;
+}
+
+inline PRBool
+nsSMILParserUtils::ConsumeSubstring(nsACString::const_iterator& aIter,
+                                    const nsACString::const_iterator& aIterEnd,
+                                    const char *aSubstring)
+{
+  size_t substrLen = PL_strlen(aSubstring);
+  typedef nsACString::const_iterator::difference_type diff_type;
+
+  if (aIterEnd.get() - aIter.get() < static_cast<diff_type>(substrLen))
+    return PR_FALSE;
+
+  PRBool result = PR_FALSE;
+
+  if (PL_strstr(aIter.get(), aSubstring) == aIter.get()) {
+    aIter.advance(substrLen);
+    result = PR_TRUE;
+  }
+
+  return result;
+}
+
+//------------------------------------------------------------------------------
+// Implementation
+
+nsresult
+nsSMILParserUtils::GetKeySplines(const nsAString& aSpec,
+                                 nsTArray<PRFloat64> &aSplineArray)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  int i = 0;
+
+  while (start != end)
+  {
+    PRFloat64 value = GetFloat(start, end, &rv);
+    if (NS_FAILED(rv))
+      break;
+
+    if (value > 1.0 || value < 0.0) {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    if (!aSplineArray.AppendElement(value)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+
+    ++i;
+
+    SkipWsp(start, end);
+    if (start == end)
+      break;
+
+    if (i % 4) {
+      if (*start == ',')
+        ++start;
+    } else {
+      if (*start != ';') {
+        rv = NS_ERROR_FAILURE;
+        break;
+      }
+      ++start;
+    }
+
+    SkipWsp(start, end);
+  }
+
+  if (i % 4)
+    rv = NS_ERROR_FAILURE; // wrong number of points
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetKeyTimes(const nsAString& aSpec,
+                               nsTArray<PRFloat64> &aTimeArray)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  PRFloat64 previousValue = -1.0;
+
+  while (start != end) {
+    PRFloat64 value = GetFloat(start, end, &rv);
+    if (NS_FAILED(rv))
+      break;
+
+    if (value > 1.0 || value < 0.0 || value < previousValue) {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    if (!aTimeArray.AppendElement(value)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+    previousValue = value;
+
+    SkipWsp(start, end);
+    if (start == end)
+      break;
+
+    if (*start++ != ';') {
+      rv = NS_ERROR_FAILURE;
+      break;
+    }
+
+    SkipWsp(start, end);
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetValues(const nsAString& aSpec,
+                             nsTArray<nsSMILValue>& aValuesArray,
+                             nsISMILAttr& aAttribute)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+  nsAString::const_iterator start;
+  nsAString::const_iterator end;
+  nsAString::const_iterator substr_end;
+  nsAString::const_iterator next;
+
+  aSpec.BeginReading(start);
+  aSpec.EndReading(end);
+
+  while (start != end) {
+    rv = NS_ERROR_FAILURE;
+
+    SkipWsp(start, end);
+
+    if (start == end || *start == ';')
+      break;
+
+    substr_end = start;
+
+    while (substr_end != end && *substr_end != ';')
+      ++substr_end;
+
+    next = substr_end;
+    if (*substr_end == ';') {
+      ++next;
+      if (next == end)
+        break;
+    }
+
+    do --substr_end; while (start != substr_end && NS_IS_SPACE(*substr_end));
+      ++substr_end;
+
+    nsSMILValue newValue;
+    rv = aAttribute.ValueFromString(Substring(start, substr_end), newValue);
+    if (NS_FAILED(rv))
+      break;
+
+    if (!aValuesArray.AppendElement(newValue)) {
+      rv = NS_ERROR_OUT_OF_MEMORY;
+      break;
+    }
+
+    rv = NS_OK;
+    start = next;
+  }
+
+  return rv;
+}
+
+nsresult
+nsSMILParserUtils::GetRepeatCount(const nsAString& aSpec,
+                                  nsSMILTimeValue& aResult)
+{
+  nsresult rv = NS_OK;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  if (start != end)
+  {
+    if (ConsumeSubstring(start, end, "indefinite")) {
+      aResult.SetIndefinite();
+    } else {
+      PRFloat64 value = GetFloat(start, end, &rv);
+
+      if (NS_SUCCEEDED(rv))
+      {
+        PRInt64 count;
+        value *= 1000.0;
+
+        LL_D2L(count, value);
+
+        aResult.SetMillis(count);
+
+        if (!LL_GE_ZERO(count) || LL_IS_ZERO(count))
+          rv = NS_ERROR_FAILURE;
+      }
+    }
+
+    /* Check for trailing junk */
+    SkipWsp(start, end);
+    if (start != end)
+      rv = NS_ERROR_FAILURE;
+  } else {
+    /* Empty spec */
+    rv = NS_ERROR_FAILURE;
+  }
+
+  if (NS_FAILED(rv))
+    aResult.SetUnresolved();
+
+  return rv;
+}
+
+//
+// This method can actually parse more than a clock value as defined in the
+// SMIL Animation specification. It can also parse:
+//  - the + or - before an offset
+//  - the special value "indefinite"
+//  - the special value "media"
+//
+// Because the value "media" cannot be represented as part of an nsSMILTimeValue
+// and has different meanings depending on where it is used, it is passed out as
+// a separate parameter (which can be set to null if the media attribute is not
+// allowed).
+//
+// aResult may be NULL, e.g. to check if the string is a valid clock value
+//
+nsresult
+nsSMILParserUtils::GetClockValue(const nsAString& aSpec,
+                                 nsSMILTimeValue* aResult,
+                                 PRBool aAllowSign,       // = false
+                                 PRBool aAllowIndefinite, // = false
+                                 PRBool aAllowMedia,      // = false
+                                 PRBool* aIsMedia)        // = nsnull
+{
+  PRInt64 offset = LL_Zero();
+  PRFloat64 component = 0.0;
+
+  PRInt8 sign = 0;
+  PRUint8 colonCount = 0;
+
+  PRBool started = PR_FALSE;
+  PRBool isValid = PR_TRUE;
+
+  PRInt32 metricMultiplicand = MSEC_PER_SEC;
+
+  PRBool numIsReal = PR_FALSE;
+  PRBool prevNumCouldBeMin = PR_FALSE;
+  PRBool numCouldBeMin = PR_FALSE;
+  PRBool numCouldBeSec = PR_FALSE;
+  PRBool isIndefinite = PR_FALSE;
+
+  if (aIsMedia)
+    *aIsMedia = PR_FALSE;
+
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  while (start != end) {
+    if (IsSpace(*start)) {
+      if (started) {
+        ++start;
+        break;
+      }
+      // else, we haven't started yet, ignore initial whitespace
+      ++start;
+
+    } else if (aAllowSign && (*start == '+' || *start == '-')) {
+      if (sign != 0) {
+        // sign has already been set
+        isValid = PR_FALSE;
+        break;
+      }
+
+      if (started) {
+        // sign appears in the middle of the string
+        isValid = PR_FALSE;
+        break;
+      }
+
+      sign = (*start == '+') ? 1 : -1;
+      ++start;
+    // The NS_IS_DIGIT etc. macros are not locale-specific
+    } else if (NS_IS_DIGIT(*start)) {
+      prevNumCouldBeMin = numCouldBeMin;
+
+      if (!GetClockComponent(start, end, component, numIsReal, numCouldBeMin,
+                             numCouldBeSec)) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      started = PR_TRUE;
+    } else if (*start == ':') {
+      ++colonCount;
+
+      // Neither minutes nor hours can be reals
+      if (numIsReal) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Clock value can't start with a ':'
+      if (!started) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Can't have more than two colons
+      if (colonCount > 2) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Multiply the offset by 60 and add the last accumulated component
+      PRInt64 component64;
+      LL_D2L(component64, component);
+      LL_MUL(offset, offset, LL_INIT(0,60));
+      LL_ADD(offset, offset, component64);
+
+      component = 0.0l;
+      ++start;
+    } else if (NS_IS_ALPHA(*start)) {
+      if (colonCount > 0) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      if (aAllowIndefinite && ConsumeSubstring(start, end, "indefinite")) {
+        // We set a separate flag because we don't know what the state of the
+        // passed in time value is and we shouldn't change it in the case of a
+        // bad input string (so we can't initialise it to 0ms for example).
+        isIndefinite = PR_TRUE;
+        if (aResult)
+          aResult->SetIndefinite();
+      } else if (aAllowMedia && ConsumeSubstring(start, end, "media")) {
+        if (aIsMedia)
+          *aIsMedia = PR_TRUE;
+      } else if (!GetMetricMultiplicand(start, end, metricMultiplicand)) {
+        isValid = PR_FALSE;
+        break;
+      }
+
+      // Nothing must come after the string except whitespace
+      break;
+    } else {
+      isValid = PR_FALSE;
+      break;
+    }
+  }
+
+  if (!started) isValid = PR_FALSE;
+
+  // Process remainder of string (if any) to ensure it is only trailing
+  // whitespace (embedded whitespace is not allowed)
+  SkipWsp(start, end);
+  if (start != end)
+    isValid = PR_FALSE;
+
+  // No more processing required if the value was "indefinite" or "media".
+  if (isIndefinite || (aIsMedia && *aIsMedia))
+    return NS_OK;
+
+  // If there is more than one colon then the previous component must be a
+  // correctly formatted minute (i.e. two digits between 00 and 59) and the
+  // latest component must be a correctly formatted second (i.e. two digits
+  // before the .)
+  if (colonCount > 0 && (!prevNumCouldBeMin || !numCouldBeSec))
+    isValid = PR_FALSE;
+
+  if (isValid) {
+    // Tack on the last component
+    if (colonCount > 0) {
+      LL_MUL(offset, offset, LL_INIT(0,60));
+      LL_MUL(offset, offset, LL_INIT(0,1000));
+      component *= 1000;
+      // rounding
+      component = (component >= 0) ? component + 0.5l : component - 0.5l;
+      PRInt64 component64;
+      LL_D2L(component64, component);
+      LL_ADD(offset, offset, component64);
+    } else {
+      component *= metricMultiplicand;
+      // rounding
+      component = (component >= 0) ? component + 0.5l : component - 0.5l;
+      LL_D2L(offset, component);
+    }
+
+    if (aResult) {
+      PRInt64 millis = offset;
+
+      if (sign == -1)
+        LL_NEG(millis, offset);
+
+      aResult->SetMillis(millis);
+    }
+  }
+
+  return (isValid) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+PRBool
+nsSMILParserUtils::GetClockComponent(nsACString::const_iterator& aSpec,
+                                     const nsACString::const_iterator& aEnd,
+                                     PRFloat64& aResult,
+                                     PRBool& aIsReal,
+                                     PRBool& aCouldBeMin,
+                                     PRBool& aCouldBeSec)
+{
+  nsresult rv;
+  char const *begin = aSpec.get();
+  PRFloat64 value = GetFloat(aSpec, aEnd, &rv);
+
+  // Check a number was found
+  if (NS_FAILED(rv))
+    return PR_FALSE;
+
+  // Check it's not expressed in exponential form
+  size_t len = aSpec.get() - begin;
+  PRBool isExp = (PL_strnpbrk(begin, "eE", len) != nsnull);
+  if (isExp)
+    return PR_FALSE;
+
+  // Don't allow real numbers of the form "23."
+  if (*(aSpec.get() - 1) == '.')
+    return PR_FALSE;
+
+  // Number looks good
+  aResult = value;
+
+  // Set some flags so we can check this number is valid once we know
+  // whether it's an hour, minute string etc.
+  aIsReal = (PL_strnchr(begin, '.', len) != nsnull);
+  aCouldBeMin = (value < 60.0l && (len == 2));
+  aCouldBeSec = (value < 60.0l ||
+      (value == 60.0l && begin[0] == '5')); // Take care of rounding error
+  aCouldBeSec &= (len >= 2 &&
+      (begin[2] == '\0' || begin[2] == '.' || IsSpace(begin[2])));
+
+  return PR_TRUE;
+}
+
+inline PRBool
+nsSMILParserUtils::GetMetricMultiplicand(nsACString::const_iterator& aSpec,
+                                         const nsACString::const_iterator& aEnd,
+                                         PRInt32& multiplicand)
+{
+  PRBool result = PR_FALSE;
+
+  size_t len = aEnd.get() - aSpec.get();
+  nsACString::const_iterator spec(aSpec);
+
+  if (len) {
+    switch (*spec++)
+    {
+      case 'h':
+        multiplicand = MSEC_PER_HOUR;
+        result = PR_TRUE;
+        break;
+      case 'm':
+        if (len >= 2) {
+          if (*spec == 's') {
+            ++spec;
+            multiplicand = 1;
+            result = PR_TRUE;
+          } else if (len >=3 && *spec++ == 'i' && *spec++ == 'n') {
+            multiplicand = MSEC_PER_MIN;
+            result = PR_TRUE;
+          }
+        }
+        break;
+      case 's':
+        multiplicand = MSEC_PER_SEC;
+        result = PR_TRUE;
+        break;
+    }
+  }
+
+  if (result)
+    aSpec = spec;
+
+  return result;
+}
+
Index: mozilla/smil/src/nsSMILParserUtils.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILParserUtils.h
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILPARSERUTILS_H__
+#define __NS_SMILPARSERUTILS_H__
+
+#include "nscore.h"
+#include "nsTArray.h"
+#include "nsString.h"
+
+class nsISMILAttr;
+class nsSMILTimeValue;
+struct nsSMILValue;
+
+/**
+ * Common parsing utilities for the SMIL module. There is little re-use here, it
+ * simply serves to simplify other classes by moving parsing outside and aid
+ * unit testing.
+ */
+class nsSMILParserUtils
+{
+public:
+  static nsresult   GetKeySplines(const nsAString& aSpec,
+                                  nsTArray<PRFloat64> &aSplineArray);
+
+  static nsresult   GetKeyTimes(const nsAString& aSpec,
+                                nsTArray<PRFloat64> &aTimesArray);
+
+  static nsresult   GetValues(const nsAString& aSpec,
+                              nsTArray<nsSMILValue>& aValuesArray,
+                              nsISMILAttr& aAttribute);
+
+  static nsresult   GetRepeatCount(const nsAString& aSpec,
+                                   nsSMILTimeValue& aResult);
+
+  static nsresult   GetClockValue(const nsAString& aSpec,
+                                  nsSMILTimeValue* aResult,
+                                  PRBool aAllowSign = false,
+                                  PRBool aAllowIndefinite = false,
+                                  PRBool aAllowMedia = false,
+                                  PRBool* aIsMedia = nsnull);
+
+
+private:
+  static void   SkipWsp(nsACString::const_iterator& aIter,
+                        const nsACString::const_iterator& aIterEnd);
+  static void   SkipWsp(nsAString::const_iterator& aIter,
+                        const nsAString::const_iterator& aIterEnd);
+  static PRFloat64 GetFloat(nsACString::const_iterator& aIter,
+                            const nsACString::const_iterator& aIterEnd,
+                            nsresult *aErrorCode = nsnull);
+  static PRBool IsSpace(const char c);
+  static PRBool IsSpace(const PRUnichar c);
+  static PRBool ConsumeSubstring(nsACString::const_iterator& aIter,
+                                 const nsACString::const_iterator& aIterEnd,
+                                 const char *aSubstring);
+  static PRBool GetClockComponent(nsACString::const_iterator& aSpec,
+                                  const nsACString::const_iterator& aEnd,
+                                  PRFloat64& aResult,
+                                  PRBool& aIsReal,
+                                  PRBool& aCouldBeMin,
+                                  PRBool& aCouldBeSec);
+  static PRBool GetMetricMultiplicand(nsACString::const_iterator& aSpec,
+                                      const nsACString::const_iterator& aEnd,
+                                      PRInt32& multiplicand);
+
+  static const PRUint32 MSEC_PER_SEC;
+  static const PRUint32 MSEC_PER_MIN;
+  static const PRUint32 MSEC_PER_HOUR;
+};
+
+#endif // __NS_SMILPARSERUTILS_H__
+
Index: mozilla/smil/src/nsSMILTimeValue.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILTimeValue.cpp
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimeValue.h"
+#include "nsDebug.h"
+
+PRInt64 nsSMILTimeValue::mUnresolvedSeconds = LL_MaxInt();
+
+//----------------------------------------------------------------------
+// Implementation
+
+// Default constructor creates an unresolved time
+nsSMILTimeValue::nsSMILTimeValue()
+  : mMilliseconds(LL_MaxInt()),
+    mIndefinite(PR_FALSE),
+    mResolved(PR_FALSE)
+{
+}
+
+//----------------------------------------------------------------------
+// nsSMILTimeValue methods:
+
+void
+nsSMILTimeValue::SetIndefinite()
+{
+  mResolved = PR_FALSE;
+  mIndefinite = PR_TRUE;
+  mMilliseconds = LL_MaxInt();
+}
+
+void
+nsSMILTimeValue::SetUnresolved()
+{
+  mResolved = PR_FALSE;
+  mIndefinite = PR_FALSE;
+  mMilliseconds = LL_MaxInt();
+}
+
+const PRInt64&
+nsSMILTimeValue::GetMillis() const
+{
+  NS_ASSERTION(mResolved, "GetMillis() called for unresolved time.");
+
+  if (!mResolved)
+      return mUnresolvedSeconds;
+
+  return mMilliseconds;
+}
+
+void
+nsSMILTimeValue::SetMillis(const PRInt64& aMillis)
+{
+  mResolved = PR_TRUE;
+  mIndefinite = PR_FALSE;
+  mMilliseconds = aMillis;
+}
+
+PRInt8
+nsSMILTimeValue::CompareTo(const nsSMILTimeValue& aCompare) const
+{
+  PRInt8 result;
+
+  if (mResolved) {
+    result = (aCompare.mResolved)
+           ? CmpLL(mMilliseconds, aCompare.mMilliseconds)
+           : -1;
+  } else if (mIndefinite) {
+    if (aCompare.mResolved)
+      result = 1;
+    else if (aCompare.mIndefinite)
+      result = 0;
+    else
+      result = -1;
+  } else {
+    result = (aCompare.mResolved || aCompare.mIndefinite) ? 1 : 0;
+  }
+
+  return result;
+}
+
Index: mozilla/smil/src/nsSMILTimeValue.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILTimeValue.h
@@ -0,0 +1,128 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEVALUE_H__
+#define __NS_SMILTIMEVALUE_H__
+
+#include "prtypes.h"
+#include "prlong.h"
+
+/**
+ * nsSMILTimeValue class
+ *
+ * Objects of this class may be in one of three orthogonal states:
+ *
+ * 1) The time is resolved and has a millisecond value
+ * 2) The time is indefinite
+ * 3) The time in unresolved
+ *
+ * There is considerable chance for confusion with regards to the indefinite
+ * state. Is it resolved? We adopt the convention that it is NOT resolved (but
+ * nor is it unresolved). This simplifies implementation as you can then write:
+ *
+ * if (time.IsResolved())
+ *    x = time.GetMillis()
+ *
+ * instead of:
+ *
+ * if (time.IsResolved() && !time.IsIndefinite())
+ *    x = time.GetMillis()
+ *
+ * Testing if a time is unresolved becomes more complicated but this is tested
+ * much less often.
+ *
+ * In summary:
+ *
+ * State         |  GetMillis         |  IsResolved        |  IsIndefinite
+ * --------------+--------------------+--------------------+-------------------
+ * Resolved      |  The millisecond   |  PR_TRUE           |  PR_FALSE
+ *               |  time              |                    |
+ * --------------+--------------------+--------------------+-------------------
+ * Indefinite    |  LL_MaxInt         |  PR_FALSE          |  PR_TRUE
+ * --------------+--------------------+--------------------+-------------------
+ * Unresolved    |  LL_MaxInt         |  PR_FALSE          |  PR_FALSE
+ *
+ */
+
+class nsSMILTimeValue
+{
+public:
+  // Creates an unresolved time value
+  nsSMILTimeValue();
+
+  PRBool            IsIndefinite() const;
+  void              SetIndefinite();
+
+  PRBool            IsResolved() const;
+  void              SetUnresolved();
+
+  const PRInt64&    GetMillis() const;
+  void              SetMillis(const PRInt64& aMillis);
+
+  PRInt8            CompareTo(const nsSMILTimeValue& aCompare) const;
+
+private:
+  PRInt8            CmpLL(const PRInt64& a, const PRInt64& b) const;
+
+  static PRInt64    mUnresolvedSeconds;
+
+  PRInt64           mMilliseconds;
+  PRBool            mIndefinite;
+  PRBool            mResolved;
+};
+
+inline PRBool
+nsSMILTimeValue::IsIndefinite() const
+{
+  return mIndefinite;
+}
+
+inline PRBool
+nsSMILTimeValue::IsResolved() const
+{
+  return mResolved;
+}
+
+// A signed comparison of two signed 64-bit integers
+inline PRInt8
+nsSMILTimeValue::CmpLL(const PRInt64& a, const PRInt64& b) const
+{
+  return (LL_EQ(a, b)) ? 0 : (LL_CMP(a, >, b)) ? 1 : -1;
+}
+
+#endif // __NS_SMILTIMEVALUE_H__
+
Index: mozilla/smil/src/nsSMILTimeValueSpec.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILTimeValueSpec.cpp
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILInstanceTime.h"
+#include "nsSMILParserUtils.h"
+#include "nsString.h"
+#include "nsAutoPtr.h"
+
+//----------------------------------------------------------------------
+// Implementation
+
+already_AddRefed<nsSMILTimeValueSpec>
+NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                        PRBool aIsBegin,
+                        const nsAString& aStringSpec)
+{
+  nsSMILTimeValueSpec* result = new nsSMILTimeValueSpec(aOwner, aIsBegin);
+  NS_ENSURE_TRUE(result, nsnull);
+
+  NS_ADDREF(result); // Need to addref as SetSpec calls getWeakReference
+  nsresult rv = result->SetSpec(aStringSpec);
+  if (NS_FAILED(rv)) {
+    NS_RELEASE(result);
+    return nsnull;
+  }
+  return result;
+}
+
+nsSMILTimeValueSpec::nsSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                                         PRBool aIsBegin)
+  : mIsBegin(aIsBegin),
+    mOffset() // initalises to zero
+{
+  if (aOwner)
+    mOwner = do_GetWeakReference(aOwner);
+}
+
+//----------------------------------------------------------------------
+// nsISupports
+
+NS_IMPL_ISUPPORTS2(nsSMILTimeValueSpec,
+                   nsSMILTimeValueSpec,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsSMILTimeValueSpec
+
+nsresult
+nsSMILTimeValueSpec::SetSpec(const nsAString& aStringSpec)
+{
+  // XXX Need to parse other specifiers, not just offset type
+  nsSMILTimeValue clockTime;
+  nsresult rv =
+    nsSMILParserUtils::GetClockValue(aStringSpec,
+                                     &clockTime,
+                                     true,  // allow + or -
+                                     true); // allow 'indefinite'
+
+  if (NS_FAILED(rv) || (!clockTime.IsResolved() && !clockTime.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+
+  if (clockTime.IsResolved())
+    mOffset = clockTime.GetMillis();
+
+  if (mOwner) {
+    nsRefPtr<nsSMILInstanceTime> instance =
+      new nsSMILInstanceTime(clockTime, this);
+    NS_ENSURE_TRUE(instance, NS_ERROR_OUT_OF_MEMORY);
+
+    nsCOMPtr<nsISMILTimedElement> owner = do_QueryReferent(mOwner);
+    NS_ENSURE_TRUE(owner, NS_ERROR_FAILURE);
+
+    owner->AddInstanceTime(instance, mIsBegin);
+  }
+
+  return rv;
+}
+
Index: mozilla/smil/src/nsSMILTimeValueSpec.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILTimeValueSpec.h
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEVALUESPEC_H__
+#define __NS_SMILTIMEVALUESPEC_H__
+
+#include "nsISupports.h"
+#include "nsWeakReference.h"
+#include "nsISMILTimedElement.h"
+
+class nsAString;
+class nsSMILTimeValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimeValueSpec class
+
+// {39d2f376-6bda-42c0-8510-a93b24828a80}
+#define NS_SMILTIMEVALUESPEC_IID \
+{ 0x39d2f376, 0x6bda, 0x42c0, { 0x85, 0x10, 0xa9, 0x3b, 0x24, 0x82, 0x8a, 0x80 } }
+
+class nsSMILTimeValueSpec : public nsSupportsWeakReference
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_SMILTIMEVALUESPEC_IID)
+  NS_DECL_ISUPPORTS
+
+protected:
+  nsSMILTimeValueSpec(nsISMILTimedElement* aOwner, PRBool aIsBegin);
+
+  friend already_AddRefed<nsSMILTimeValueSpec>
+  NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                          PRBool aIsBegin,
+                          const nsAString& aStringSpec);
+
+  nsresult      SetSpec(const nsAString& aStringSpec);
+
+  nsWeakPtr mOwner;
+  PRBool    mIsBegin;
+  PRInt64   mOffset;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsSMILTimeValueSpec, NS_SMILTIMEVALUESPEC_IID)
+
+////////////////////////////////////////////////////////////////////////
+// Factory methods
+
+already_AddRefed<nsSMILTimeValueSpec>
+NS_NewSMILTimeValueSpec(nsISMILTimedElement* aOwner,
+                        PRBool aIsBegin,
+                        const nsAString& aStringSpec);
+
+#endif // __NS_SMILTIMEVALUESPEC_H__
+
Index: mozilla/smil/src/nsSMILTimedDocumentRoot.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILTimedDocumentRoot.cpp
@@ -0,0 +1,274 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsSMILTimeValue.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimedDocumentRoot implementation
+
+nsSMILTimedDocumentRoot::nsSMILTimedDocumentRoot(
+    nsSMILAnimationRegistry* registry)
+:
+  mStartTime(),
+  mAccumulatedOffset(),
+  mAnimationRegistry(registry),
+  mParentPaused(PR_FALSE),
+  mContainerPaused(PR_FALSE)
+{
+}
+
+//----------------------------------------------------------------------
+// nsISupports methods:
+
+NS_IMPL_ISUPPORTS2(nsSMILTimedDocumentRoot,
+                   nsISMILTimeContainer,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsSMILTimedDocumentRoot methods
+
+PRInt64
+nsSMILTimedDocumentRoot::GetDocumentTime()
+{
+  if (LL_IS_ZERO(mStartTime))
+    return LL_Zero();
+
+  PRInt64 now;
+  LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+
+  PRInt64 currentTime = (mParentPaused || mContainerPaused)
+                      ? mPauseStart
+                      : now;
+
+  PRInt64 timeSinceStart;
+  LL_SUB(timeSinceStart, currentTime, mStartTime);
+
+  PRInt64 adjustedTime;
+  LL_SUB(adjustedTime, timeSinceStart, mAccumulatedOffset);
+
+  return adjustedTime;
+}
+
+nsSMILTimeValue
+nsSMILTimedDocumentRoot::WallclockToDocumentTime(nsISMILTimeValueSpec*
+                                                   aWallclockSpec)
+{
+  // XXX
+  (void)aWallclockSpec;
+  NS_NOTYETIMPLEMENTED("nsSMILTimedDocumentRoot::SeekToTime");
+  return nsSMILTimeValue();
+}
+
+nsresult
+nsSMILTimedDocumentRoot::SeekToTime(PRInt64 aSeekTo)
+{
+  PRInt64 now;
+  LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+  LL_SUB(mStartTime, now, aSeekTo);
+  mAccumulatedOffset = LL_Zero();
+  mParentPaused = PR_FALSE;
+  mContainerPaused = PR_FALSE;
+
+  ResetChildren(PR_FALSE);
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimeContainer methods
+
+nsresult
+nsSMILTimedDocumentRoot::Pause()
+{
+  if (!mContainerPaused && !mParentPaused)
+    LL_DIV(mPauseStart, PR_Now(), PR_USEC_PER_MSEC);
+  mContainerPaused = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::Resume()
+{
+  if (mContainerPaused && !mParentPaused) {
+    PRInt64 extraOffset;
+    PRInt64 now;
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+    LL_SUB(extraOffset, now, mPauseStart);
+    LL_ADD(mAccumulatedOffset, extraOffset, mAccumulatedOffset);
+  }
+  mContainerPaused = PR_FALSE;
+  return NS_OK;
+}
+
+PRBool
+nsSMILTimedDocumentRoot::IsPaused()
+{
+  return mContainerPaused;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::ParentPaused()
+{
+  if (!mContainerPaused && !mParentPaused)
+    LL_DIV(mPauseStart, PR_Now(), PR_USEC_PER_MSEC);
+  mParentPaused = PR_TRUE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::ParentResumed()
+{
+  if (!mContainerPaused && mParentPaused) {
+    PRInt64 extraOffset;
+    PRInt64 now;
+    LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+    LL_SUB(extraOffset, now, mPauseStart);
+    LL_ADD(mAccumulatedOffset, extraOffset, mAccumulatedOffset);
+  }
+  mParentPaused = PR_FALSE;
+  return NS_OK;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::Reset()
+{
+  mStartTime = LL_Zero();
+  mAccumulatedOffset = LL_Zero();
+  mParentPaused = PR_FALSE;
+  mContainerPaused = PR_FALSE;
+
+  ResetChildren(PR_TRUE);
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedDocumentRoot::Sample()
+{
+  if (mParentPaused || mContainerPaused)
+    return;
+
+  PRInt64 now;
+  LL_DIV(now, PR_Now(), PR_USEC_PER_MSEC);
+
+  // If this is the first time, record the document begin time
+  if (LL_IS_ZERO(mStartTime))
+    mStartTime = now;
+
+  PRInt64 instant;
+  LL_SUB(instant, now, mStartTime);
+  LL_SUB(instant, instant, mAccumulatedOffset);
+
+  if (mAnimationRegistry)
+    mAnimationRegistry->StartSample();
+
+  SampleChildren(instant);
+
+  if (mAnimationRegistry)
+    mAnimationRegistry->EndSample();
+}
+
+nsresult
+nsSMILTimedDocumentRoot::AddTimedElement(nsISMILTimedElement* aElement)
+{
+  NS_ENSURE_ARG_POINTER(aElement);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aElement, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimedElements.AppendObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  aElement->SetDocumentRoot(this);
+
+  return rv;
+}
+
+nsresult
+nsSMILTimedDocumentRoot::RemoveTimedElement(nsISMILTimedElement* aElement)
+{
+  NS_ENSURE_ARG_POINTER(aElement);
+
+  nsresult rv;
+  nsCOMPtr<nsIWeakReference> weakRef(
+      getter_AddRefs(do_GetWeakReference(aElement, &rv)) );
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  rv = (mTimedElements.RemoveObject(weakRef)) ? NS_OK : NS_ERROR_FAILURE;
+
+  aElement->SetDocumentRoot(nsnull);
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers:
+
+void
+nsSMILTimedDocumentRoot::SampleChildren(PRInt64 aDocumentTime)
+{
+  PRUint32 i = mTimedElements.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimedElement>
+      element( do_QueryReferent(mTimedElements[i]) );
+
+    if (element)
+      element->SampleAt(aDocumentTime);
+    else
+      mTimedElements.RemoveObjectAt(i);
+  }
+}
+
+void
+nsSMILTimedDocumentRoot::ResetChildren(PRBool aHardReset)
+{
+  PRUint32 i = mTimedElements.Count();
+  while (i > 0) {
+    --i;
+    nsCOMPtr<nsISMILTimedElement>
+      element( do_QueryReferent(mTimedElements[i]) );
+
+    if (element)
+      element->Reset(aHardReset);
+    else
+      mTimedElements.RemoveObjectAt(i);
+  }
+}
+
Index: mozilla/smil/src/nsSMILTimedDocumentRoot.h
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILTimedDocumentRoot.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SMILTIMEDDOCUMENTROOT_H__
+#define __NS_SMILTIMEDDOCUMENTROOT_H__
+
+#include "nsISupports.h"
+#include "nsISMILTimeContainer.h"
+#include "nsSMILAnimationRegistry.h"
+#include "nsWeakReference.h"
+#include "nsCOMArray.h"
+
+class nsISMILTimeValueSpec;
+class nsISMILTimedElement;
+class nsSMILTimeValue;
+
+////////////////////////////////////////////////////////////////////////
+// nsSMILTimedDocumentRoot: Timed document root
+
+class nsSMILTimedDocumentRoot : public nsISMILTimeContainer,
+                                public nsSupportsWeakReference
+{
+public:
+  nsSMILTimedDocumentRoot(nsSMILAnimationRegistry* registry);
+
+  NS_DECL_ISUPPORTS
+
+  PRInt64           GetDocumentTime();
+  nsSMILTimeValue   WallclockToDocumentTime(nsISMILTimeValueSpec*
+                                              aWallclockSpec);
+  nsresult          SeekToTime(PRInt64 aSeekTo);
+
+  // nsISMILTimeContainer
+  virtual PRBool    IsPaused();
+  virtual nsresult  Pause();
+  virtual nsresult  Resume();
+  virtual nsresult  ParentPaused();
+  virtual nsresult  ParentResumed();
+  virtual nsresult  Reset();
+  virtual void      Sample();
+  virtual nsresult  AddTimedElement(nsISMILTimedElement* aElement);
+  virtual nsresult  RemoveTimedElement(nsISMILTimedElement* aElement);
+
+protected:
+  void              SampleChildren(PRInt64 aDocumentTime);
+  void              ResetChildren(PRBool aHardReset);
+
+  PRInt64                       mStartTime;
+  PRInt64                       mAccumulatedOffset;
+  nsCOMArray<nsIWeakReference>  mTimedElements;
+  nsSMILAnimationRegistry*      mAnimationRegistry;
+  PRBool                        mParentPaused;
+  PRBool                        mContainerPaused;
+  PRInt64                       mPauseStart;
+};
+
+#endif // __NS_SMILTIMEDDOCUMENTROOT_H__
+
Index: mozilla/smil/src/nsSMILTimedElement.cpp
===================================================================
--- /dev/null
+++ mozilla/smil/src/nsSMILTimedElement.cpp
@@ -0,0 +1,1256 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILTimedElement.h"
+#include "nsIDOMElementTimeControl.h"
+#include "nsWeakReference.h"
+#include "nsSMILTimeValue.h"
+#include "nsSMILTimeValueSpec.h"
+#include "nsSMILInstanceTime.h"
+#include "nsSMILInterval.h"
+#include "nsISMILTimeClient.h"
+#include "nsSMILEnum.h"
+#include "nsSMILParserUtils.h"
+#include "nsSMILTimedDocumentRoot.h"
+#include "nsGkAtoms.h"
+#include "nsCOMArray.h"
+#include "nsReadableUtils.h"
+#include "nsAutoPtr.h"
+#include "prdtoa.h"
+#include "plstr.h"
+#include "nsString.h"
+
+//----------------------------------------------------------------------
+// Class declaration
+
+class nsSMILTimedElement : public nsISMILTimedElement,
+                           public nsIDOMElementTimeControl,
+                           public nsSupportsWeakReference
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDOMELEMENTTIMECONTROL
+
+  // nsISMILTimedElement
+  virtual void      AddInstanceTime(nsSMILInstanceTime* aInstanceTime,
+                                    PRBool aIsBegin);
+  virtual void      SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot);
+  virtual void      SetTimeClient(nsISMILTimeClient* aClient);
+  virtual void      SampleAt(const PRInt64& aDocumentTime);
+  virtual void      Reset(PRBool aHardReset = PR_FALSE);
+  virtual PRBool    SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult);
+  virtual PRBool    UnsetAttr(nsIAtom* aAttribute);
+
+protected:
+  nsSMILTimedElement();
+  nsresult          Init();
+
+  friend nsISMILTimedElement* NS_NewSMILTimedElement();
+
+  //
+  // Implementation helpers
+  //
+
+  nsresult          SetBeginSpec(const nsAString& aBeginSpec);
+  nsresult          SetEndSpec(const nsAString& aEndSpec);
+  nsresult          SetSimpleDuration(const nsAString& aDurSpec);
+  nsresult          SetMin(const nsAString& aMinSpec);
+  nsresult          SetMax(const nsAString& aMaxSpec);
+  nsresult          SetRestart(const nsAString& aRestartSpec);
+  nsresult          SetRepeatCount(const nsAString& aRepeatCountSpec);
+  nsresult          SetRepeatDur(const nsAString& aRepeatDurSpec);
+  nsresult          SetFillMode(const nsAString& aFillModeSpec);
+
+  void              UnsetBeginSpec();
+  void              UnsetEndSpec();
+  void              UnsetSimpleDuration();
+  void              UnsetMin();
+  void              UnsetMax();
+  void              UnsetRestart();
+  void              UnsetRepeatCount();
+  void              UnsetRepeatDur();
+  void              UnsetFillMode();
+
+  nsresult          SetBeginOrEndSpec(const nsAString& aSpec, PRBool aIsBegin);
+
+  /**
+   * Calculates the first acceptable interval for this element.
+   *
+   * @see SMILANIM 3.6.8
+   */
+  nsresult          GetNextInterval(const nsSMILTimeValue& aBeginAfter,
+                                  PRBool aFirstInstance,
+                                  nsSMILInterval& aResult);
+
+  PRBool            GetNextGreater(const nsCOMArray<nsSMILInstanceTime>& aList,
+                                   const nsSMILTimeValue& aBase,
+                                   PRInt32& aPosition,
+                                   nsSMILTimeValue& aResult);
+  nsSMILTimeValue   CalcActiveEnd(const nsSMILTimeValue& aBegin,
+                                  const nsSMILTimeValue& aEnd);
+  nsSMILTimeValue   GetRepeatDuration();
+  nsSMILTimeValue   ApplyMinAndMax(const nsSMILTimeValue& aDuration);
+  PRInt64           ActiveTimeToSimpleTime(const PRInt64& aActiveTime,
+                                           PRUint32& aRepeatIteration);
+  void              CheckForEarlyEnd(const nsSMILTimeValue &aDocumentTime);
+  void              UpdateCurrentInterval();
+  void              SampleSimpleTime(PRInt64 aActiveTime);
+  void              SampleFillValue();
+  PRInt64           MinLL(const PRInt64& a, const PRInt64& b);
+
+  //
+  // Members
+  //
+  nsCOMArray<nsSMILTimeValueSpec> mBeginSpecs;
+  nsCOMArray<nsSMILTimeValueSpec> mEndSpecs;
+
+  //
+  // We need to distinguish between attempting to set the begin spec and failing
+  // (in which case the mBeginSpecs array will be empty) and not attempting to
+  // set the begin spec at all. In the first case, we should act as if the begin
+  // was indefinite, and in the second, we should act as if begin was 0s.
+  //
+  PRBool                          mBeginSpecSet;
+
+  nsSMILTimeValue                 mSimpleDur;
+
+  /**
+   * The number of iterations of the animation function. We use an
+   * nsSMILTimeValue type where:
+   *
+   * milliseconds = the number of iterations * 1000,
+   * indefinite   = repeating indefinitely, until the document ends, and
+   * unresolved   = the attribute is not set, therefore no repeating.
+   */
+  nsSMILTimeValue                 mRepeatCount;
+  nsSMILTimeValue                 mRepeatDur;
+
+  nsSMILTimeValue                 mMin;
+  nsSMILTimeValue                 mMax;
+
+  enum nsSMILFillMode
+  {
+    fill_remove,
+    fill_freeze
+  };
+  static nsSMILEnumMapping        sFillModeMap[];
+  nsSMILEnum                      mFillMode;
+
+  enum nsSMILRestartMode
+  {
+    restart_always,
+    restart_whennotactive,
+    restart_never
+  };
+  static nsSMILEnumMapping        sRestartModeMap[];
+  nsSMILEnum                      mRestartMode;
+
+  PRBool                          mEndHasEventConditions;
+
+  nsCOMArray<nsSMILInstanceTime>  mBeginInstances;
+  nsCOMArray<nsSMILInstanceTime>  mEndInstances;
+
+  nsCOMPtr<nsISMILTimeClient>     mClient;
+  nsCOMPtr<nsSMILInterval>        mCurrentInterval;
+  nsCOMArray<nsSMILInterval>      mOldIntervals;
+  nsRefPtr<nsSMILTimedDocumentRoot> mDocumentRoot;
+
+  /**
+   * The state of the element in its life-cycle. These states are based on the
+   * element life-cycle described in SMILANIM 3.6.8
+   */
+  enum nsSMILElementState
+  {
+    state_startup,
+    state_waiting,
+    state_active,
+    state_postactive
+  };
+  nsSMILElementState              mElementState;
+};
+
+//----------------------------------------------------------------------
+// Static members
+
+nsSMILEnumMapping nsSMILTimedElement::sFillModeMap[] = {
+      {&nsGkAtoms::remove, fill_remove},
+      {&nsGkAtoms::freeze, fill_freeze},
+      {nsnull, 0}
+};
+
+nsSMILEnumMapping nsSMILTimedElement::sRestartModeMap[] = {
+      {&nsGkAtoms::always, restart_always},
+      {&nsGkAtoms::whennotactive, restart_whennotactive},
+      {&nsGkAtoms::never, restart_never},
+      {nsnull, 0}
+};
+
+//----------------------------------------------------------------------
+// Factory method
+
+nsISMILTimedElement* NS_NewSMILTimedElement()
+{
+  nsSMILTimedElement* element = new nsSMILTimedElement();
+
+  if (element && NS_FAILED(element->Init())) {
+      delete element;
+      return nsnull;
+  }
+
+  return element;
+}
+
+//----------------------------------------------------------------------
+// Ctor, dtor
+
+nsSMILTimedElement::nsSMILTimedElement()
+:
+  mBeginSpecs(),
+  mEndSpecs(),
+  mBeginSpecSet(PR_FALSE),
+  mFillMode(fill_remove, sFillModeMap),
+  mRestartMode(restart_always, sRestartModeMap),
+  mEndHasEventConditions(PR_FALSE),
+  mElementState(state_startup)
+{
+  mSimpleDur.SetIndefinite();
+  mMin.SetMillis(LL_Zero());
+  mMax.SetIndefinite();
+}
+
+nsresult
+nsSMILTimedElement::Init()
+{
+  mCurrentInterval = new nsSMILInterval();
+
+  return (mCurrentInterval) ? NS_OK : NS_ERROR_FAILURE;
+}
+
+//----------------------------------------------------------------------
+// nsISupports
+
+NS_IMPL_ISUPPORTS3(nsSMILTimedElement,
+                   nsISMILTimedElement,
+                   nsIDOMElementTimeControl,
+                   nsISupportsWeakReference)
+
+//----------------------------------------------------------------------
+// nsIDOMElementTimeControl methods
+//
+// The definition of the ElementTimeControl interface differs between SMIL
+// Animation and SVG 1.1. In SMIL Animation all methods have a void return
+// type and the new instance time is simply added to the list and restart
+// semantics are applied as with any other instance time. In the SVG definition
+// the methods return a bool depending on the restart mode. There are some
+// cases where this is problematic.
+//
+// For example, if a call is made to beginElementAt and the resolved time
+// after including the offset falls outside the current interval then using
+// the SMIL Animation definition an element with restart == whenNotActive
+// would restart with this new instance time. The SVG definition however seems
+// to imply that in this case the implementation should ignore the new
+// instance time if the restart mode == whenNotActive and the element is
+// currently active and return false.
+//
+// It is tempting to try and determine when a new instance time will actually
+// cause a restart but this is not possible as in the meantime a new event may
+// trump the new instance time. We take a compromise of returning true and
+// false according to the SVG definition but adding the instance time to the
+// list regardless. This may produce different results to an implementation that
+// follows strictly the behaviour implied by the SVG spec.
+//
+
+/* boolean beginElement (); */
+NS_IMETHODIMP
+nsSMILTimedElement::BeginElement(PRBool *_retval)
+{
+  return BeginElementAt(0.0, _retval);
+}
+
+/* boolean beginElementAt (in float offset); */
+NS_IMETHODIMP
+nsSMILTimedElement::BeginElementAt(float offset, PRBool *_retval)
+{
+  // Check for restart == never
+  if (mRestartMode.GetIntegerValue() == restart_never &&
+      mElementState == state_active ||
+      mElementState == state_postactive) {
+    *_retval = PR_FALSE;
+  }
+
+  // Check for restart == whenNotActive
+  if (mRestartMode.GetIntegerValue() == restart_whennotactive &&
+      mElementState == state_active) {
+    *_retval = PR_FALSE;
+  }
+
+  if (!mDocumentRoot) {
+    *_retval = PR_FALSE;
+    NS_ERROR("Attempting to begin but there is no document root.");
+    return NS_ERROR_FAILURE;
+  }
+
+  PRInt64 offsetVal;
+  LL_D2L(offsetVal, offset);
+  PRInt64 timeWithOffset;
+  LL_ADD(timeWithOffset, mDocumentRoot->GetDocumentTime(), offsetVal);
+  nsSMILTimeValue timeVal;
+  timeVal.SetMillis(timeWithOffset);
+  nsRefPtr<nsSMILInstanceTime>
+    instanceTime(new nsSMILInstanceTime(timeVal, nsnull, PR_TRUE));
+  NS_ENSURE_TRUE(instanceTime, NS_ERROR_OUT_OF_MEMORY);
+
+  AddInstanceTime(instanceTime, PR_TRUE);
+
+  *_retval = PR_TRUE;
+  return NS_OK;
+}
+
+/* boolean endElement (); */
+NS_IMETHODIMP
+nsSMILTimedElement::EndElement(PRBool *_retval)
+{
+  return EndElementAt(0.0, _retval);
+}
+
+/* boolean endElementAt (in float offset); */
+NS_IMETHODIMP
+nsSMILTimedElement::EndElementAt(float offset, PRBool *_retval)
+{
+  if (mElementState != state_active)
+    *_retval = PR_FALSE;
+
+  if (!mDocumentRoot) {
+    *_retval = PR_FALSE;
+    NS_ERROR("Attempting to end but there is no document root.");
+    return NS_ERROR_FAILURE;
+  }
+
+  PRInt64 offsetVal;
+  LL_D2L(offsetVal, offset);
+  PRInt64 timeWithOffset;
+  LL_ADD(timeWithOffset, mDocumentRoot->GetDocumentTime(), offsetVal);
+  nsSMILTimeValue timeVal;
+  timeVal.SetMillis(timeWithOffset);
+  nsRefPtr<nsSMILInstanceTime>
+    instanceTime(new nsSMILInstanceTime(timeVal, nsnull, PR_TRUE));
+  NS_ENSURE_TRUE(instanceTime, NS_ERROR_OUT_OF_MEMORY);
+
+  AddInstanceTime(instanceTime, PR_FALSE);
+
+  *_retval = PR_TRUE;
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsISMILTimedElement
+
+void
+nsSMILTimedElement::AddInstanceTime(nsSMILInstanceTime* aInstanceTime,
+                                    PRBool aIsBegin)
+{
+  NS_ASSERTION(aInstanceTime, "NULL instance time");
+
+  if (aIsBegin)
+    mBeginInstances.AppendObject(aInstanceTime);
+  else
+    mEndInstances.AppendObject(aInstanceTime);
+
+  UpdateCurrentInterval();
+}
+
+void
+nsSMILTimedElement::SetDocumentRoot(nsSMILTimedDocumentRoot* aRoot)
+{
+  mDocumentRoot = aRoot;
+}
+
+void
+nsSMILTimedElement::SetTimeClient(nsISMILTimeClient* aClient)
+{
+  //
+  // No need to check for NULL. A NULL parameter simply means to remove the
+  // previous client which we do by setting to NULL anyway.
+  //
+
+  mClient = aClient;
+}
+
+void
+nsSMILTimedElement::SampleAt(const PRInt64& aDocumentTime)
+{
+  PRBool          stateChanged;
+  nsSMILTimeValue docTime;
+  docTime.SetMillis(aDocumentTime);
+
+  // XXX Cache previous sample time and if this time is less then perform
+  // backwards seeking behaviour (see SMILANIM 3.6.5 Hyperlinks and timing)
+
+  do {
+    stateChanged = false;
+
+    switch (mElementState)
+    {
+    case state_startup:
+      {
+        nsSMILTimeValue beginAfter;
+        beginAfter.SetMillis(LL_MININT);
+
+        mElementState =
+          (NS_SUCCEEDED(GetNextInterval(beginAfter, true,
+                                        *mCurrentInterval)))
+          ? state_waiting
+          : state_postactive;
+        stateChanged = true;
+      }
+      break;
+
+    case state_waiting:
+      {
+        if (mCurrentInterval->Begin().CompareTo(docTime) < 1) {
+          mElementState = state_active;
+          if (mClient)
+            mClient->ToActive(mCurrentInterval->Begin().GetMillis());
+          stateChanged = true;
+        }
+      }
+      break;
+
+    case state_active:
+      {
+        CheckForEarlyEnd(docTime);
+        if (mCurrentInterval->End().CompareTo(docTime) < 1) {
+          nsCOMPtr<nsSMILInterval> newInterval(new nsSMILInterval());
+          mElementState =
+            (NS_SUCCEEDED(GetNextInterval(mCurrentInterval->End(),
+                                          false,
+                                          *newInterval)))
+            ? state_waiting
+            : state_postactive;
+          if (mClient)
+            mClient->ToInactive(mFillMode.GetIntegerValue() == fill_freeze);
+          SampleFillValue();
+          mOldIntervals.AppendObject(mCurrentInterval);
+          mCurrentInterval = newInterval;
+          Reset();
+          stateChanged = true;
+        } else {
+          PRInt64 beginTime = mCurrentInterval->Begin().GetMillis();
+
+          PRInt64 activeTime;
+          LL_SUB(activeTime, aDocumentTime, beginTime);
+
+          SampleSimpleTime(activeTime);
+        }
+      }
+      break;
+
+    case state_postactive:
+      break;
+    }
+  } while (stateChanged);
+}
+
+void
+nsSMILTimedElement::Reset(PRBool aHardReset /* = PR_FALSE */)
+{
+  nsSMILInstanceTime* instance;
+
+  PRInt32    count = mBeginInstances.Count();
+
+  for (PRInt32 i = 0; i < count; ++i) {
+    instance = static_cast<nsSMILInstanceTime*>(mBeginInstances[0]);
+    if (instance->ClearOnReset())
+      mBeginInstances.RemoveObjectAt(0);
+  }
+
+  count = mEndInstances.Count();
+
+  for (PRInt32 j = 0; j < count; ++j) {
+    instance = static_cast<nsSMILInstanceTime*>(mEndInstances[0]);
+    if (instance->ClearOnReset())
+      mEndInstances.RemoveObjectAt(0);
+  }
+
+  if (aHardReset) {
+    mCurrentInterval = new nsSMILInterval();
+    mElementState    = state_startup;
+    mOldIntervals.Clear();
+
+    // Remove any fill
+    if (mClient)
+      mClient->ToInactive(PR_FALSE);
+  }
+}
+
+PRBool
+nsSMILTimedElement::SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
+                            nsresult* aResult)
+{
+  PRBool rv = PR_TRUE;
+
+  nsresult result = NS_OK;
+
+  if (aAttribute == nsGkAtoms::begin)
+    result = SetBeginSpec(aValue);
+  else if (aAttribute == nsGkAtoms::dur)
+    result = SetSimpleDuration(aValue);
+  else if (aAttribute == nsGkAtoms::end)
+    result = SetEndSpec(aValue);
+  else if (aAttribute == nsGkAtoms::fill)
+    result = SetFillMode(aValue);
+  else if (aAttribute == nsGkAtoms::max)
+    result = SetMax(aValue);
+  else if (aAttribute == nsGkAtoms::min)
+    result = SetMin(aValue);
+  else if (aAttribute == nsGkAtoms::repeatCount)
+    result = SetRepeatCount(aValue);
+  else if (aAttribute == nsGkAtoms::repeatDur)
+    result = SetRepeatDur(aValue);
+  else if (aAttribute == nsGkAtoms::restart)
+    result = SetRestart(aValue);
+  else
+    rv = PR_FALSE;
+
+  if (rv && aResult)
+    *aResult = result;
+
+  return rv;
+}
+
+PRBool
+nsSMILTimedElement::UnsetAttr(nsIAtom* aAttribute)
+{
+  PRBool rv = PR_TRUE;
+
+  if (aAttribute == nsGkAtoms::begin)
+    UnsetBeginSpec();
+  else if (aAttribute == nsGkAtoms::dur)
+    UnsetSimpleDuration();
+  else if (aAttribute == nsGkAtoms::end)
+    UnsetEndSpec();
+  else if (aAttribute == nsGkAtoms::fill)
+    UnsetFillMode();
+  else if (aAttribute == nsGkAtoms::max)
+    UnsetMax();
+  else if (aAttribute == nsGkAtoms::min)
+    UnsetMin();
+  else if (aAttribute == nsGkAtoms::repeatCount)
+    UnsetRepeatCount();
+  else if (aAttribute == nsGkAtoms::repeatDur)
+    UnsetRepeatDur();
+  else if (aAttribute == nsGkAtoms::restart)
+    UnsetRestart();
+  else
+    rv = PR_FALSE;
+
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// Setters and unsetters
+
+nsresult
+nsSMILTimedElement::SetBeginSpec(const nsAString& aBeginSpec)
+{
+  mBeginSpecSet = PR_TRUE;
+  return SetBeginOrEndSpec(aBeginSpec, PR_TRUE);
+}
+
+void
+nsSMILTimedElement::UnsetBeginSpec()
+{
+  mBeginSpecs.Clear();
+  mBeginInstances.Clear();
+  mBeginSpecSet = PR_FALSE;
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetEndSpec(const nsAString& aEndSpec)
+{
+  //
+  // When implementing events etc., don't forget to ensure
+  // mEndHasEventConditions is set if the specification contains conditions that
+  // describe event-values, repeat-values or accessKey-values.
+  //
+  return SetBeginOrEndSpec(aEndSpec, PR_FALSE);
+}
+
+void
+nsSMILTimedElement::UnsetEndSpec()
+{
+  mEndSpecs.Clear();
+  mEndInstances.Clear();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetSimpleDuration(const nsAString& aDurSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+
+  rv = nsSMILParserUtils::GetClockValue(aDurSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        true,  // allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+
+  if (duration.IsResolved() && LL_IS_ZERO(duration.GetMillis()))
+    return NS_ERROR_FAILURE;
+
+  //
+  // SVG-specific: "For SVG's animation elements, if "media" is specified, the
+  // attribute will be ignored." (SVG 1.1, section 19.2.6)
+  //
+  if (isMedia)
+    duration.SetIndefinite();
+
+  mSimpleDur = duration;
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetSimpleDuration()
+{
+  mSimpleDur.SetIndefinite();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetMin(const nsAString& aMinSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+
+  rv = nsSMILParserUtils::GetClockValue(aMinSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        false, // don't allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (isMedia)
+    duration.SetMillis(LL_Zero());
+
+  if (NS_FAILED(rv) || !duration.IsResolved()) {
+    mMin.SetMillis(LL_Zero());
+    return NS_ERROR_FAILURE;
+  }
+
+  if (!LL_GE_ZERO(duration.GetMillis())) {
+    mMin.SetMillis(LL_Zero());
+    return NS_ERROR_FAILURE;
+  }
+
+  mMin = duration;
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetMin()
+{
+  mMin.SetMillis(LL_Zero());
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetMax(const nsAString& aMaxSpec)
+{
+  nsSMILTimeValue duration;
+  PRBool isMedia;
+  nsresult rv;
+
+  rv = nsSMILParserUtils::GetClockValue(aMaxSpec,
+                                        &duration,
+                                        false, // don't allow + or -
+                                        true,  // allow indefinite
+                                        true,  // allow media
+                                        &isMedia);
+
+  if (isMedia)
+    duration.SetIndefinite();
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite())) {
+    mMax.SetIndefinite();
+    return NS_ERROR_FAILURE;
+  }
+
+  if (duration.IsResolved() &&
+      (!LL_GE_ZERO(duration.GetMillis()) || LL_IS_ZERO(duration.GetMillis()))) {
+    mMax.SetIndefinite();
+    return NS_ERROR_FAILURE;
+  }
+
+  mMax = duration;
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetMax()
+{
+  mMax.SetIndefinite();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRestart(const nsAString& aRestartSpec)
+{
+  nsresult rv = mRestartMode.SetStringValue(aRestartSpec);
+  UpdateCurrentInterval();
+  return rv;
+}
+
+void
+nsSMILTimedElement::UnsetRestart()
+{
+  mRestartMode.SetIntegerValue(restart_always);
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRepeatCount(const nsAString& aRepeatCountSpec)
+{
+  nsSMILTimeValue newRepeatCount;
+  nsresult rv =
+    nsSMILParserUtils::GetRepeatCount(aRepeatCountSpec, newRepeatCount);
+
+  UpdateCurrentInterval();
+
+  if (NS_SUCCEEDED(rv))
+    mRepeatCount = newRepeatCount;
+  else
+    mRepeatCount.SetUnresolved();
+
+  return rv;
+}
+
+void
+nsSMILTimedElement::UnsetRepeatCount()
+{
+  mRepeatCount.SetUnresolved();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetRepeatDur(const nsAString& aRepeatDurSpec)
+{
+  nsresult        rv;
+  nsSMILTimeValue duration;
+
+  rv = nsSMILParserUtils::GetClockValue(aRepeatDurSpec,
+                                        &duration,
+                                        false,  // don't allow + or -
+                                        true);  // allow indefinite
+
+  if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite()))
+    return NS_ERROR_FAILURE;
+
+  UpdateCurrentInterval();
+
+  mRepeatDur = duration;
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetRepeatDur()
+{
+  mRepeatDur.SetUnresolved();
+  UpdateCurrentInterval();
+}
+
+nsresult
+nsSMILTimedElement::SetFillMode(const nsAString& aFillModeSpec)
+{
+  PRUint16 previousFillMode = mFillMode.GetIntegerValue();
+  nsresult rv = mFillMode.SetStringValue(aFillModeSpec);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (previousFillMode == mFillMode.GetIntegerValue())
+    return NS_OK;
+
+  if ((mElementState == state_waiting || mElementState == state_postactive) &&
+      mClient)
+      mClient->ToInactive(mFillMode.GetIntegerValue() == fill_freeze);
+
+  return NS_OK;
+}
+
+void
+nsSMILTimedElement::UnsetFillMode()
+{
+  PRUint16 previousFillMode = mFillMode.GetIntegerValue();
+  mFillMode.SetIntegerValue(fill_remove);
+  if ((mElementState == state_waiting || mElementState == state_postactive) &&
+      previousFillMode == fill_freeze &&
+      mClient)
+    mClient->ToInactive(PR_FALSE);
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSMILTimedElement::SetBeginOrEndSpec(const nsAString& aSpec,
+                                      PRBool aIsBegin)
+{
+  nsRefPtr<nsSMILTimeValueSpec>    spec;
+  nsCOMArray<nsSMILTimeValueSpec>& timeSpecsList = (aIsBegin)
+                                                 ? mBeginSpecs
+                                                 : mEndSpecs;
+  nsCOMArray<nsSMILInstanceTime>&  instancesList = (aIsBegin)
+                                                 ? mBeginInstances
+                                                 : mEndInstances;
+
+  timeSpecsList.Clear();
+  instancesList.Clear();
+
+  PRInt32 start;
+  PRInt32 end = -1;
+  PRInt32 length;
+
+  do {
+    start        = end + 1;
+    end          = aSpec.FindChar(';', start);
+    length       = (end == -1) ? -1 : end - start;
+
+    spec = NS_NewSMILTimeValueSpec(this, aIsBegin,
+                                   Substring(aSpec, start, length));
+
+    if (spec)
+      timeSpecsList.AppendObject(spec);
+  } while (end != -1 && spec);
+
+  if (!spec) {
+    timeSpecsList.Clear();
+    instancesList.Clear();
+    Reset(PR_TRUE);
+    return NS_ERROR_FAILURE;
+  }
+
+  UpdateCurrentInterval();
+
+  return NS_OK;
+}
+
+//
+// This method is based on the pseudocode given in the SMILANIM spec.
+//
+// See:
+// http://www.w3.org/TR/2001/REC-smil-animation-20010904/#Timing-BeginEnd-LC-Start
+//
+nsresult
+nsSMILTimedElement::GetNextInterval(const nsSMILTimeValue& aBeginAfter,
+                                    PRBool aFirstInterval,
+                                    nsSMILInterval& aResult)
+{
+  static nsSMILTimeValue zeroTime;
+  zeroTime.SetMillis(LL_Zero());
+
+  nsSMILTimeValue beginAfter = aBeginAfter;
+  nsSMILTimeValue tempBegin;
+  nsSMILTimeValue tempEnd;
+  PRInt32         beginPos = 0;
+  PRInt32         endPos = 0;
+
+  //
+  // This is to handle the special case when a we are calculating the first
+  // interval and we have a non-0-duration interval immediately after
+  // a 0-duration in which case but we have to be careful not to re-use an end
+  // that has already been used in another interval. See the pseudocode in
+  // SMILANIM 3.6.8 for getFirstInterval.
+  //
+  PRInt32         endMaxPos = 0;
+
+  if (mRestartMode.GetIntegerValue() == restart_never && !aFirstInterval)
+    return NS_ERROR_FAILURE;
+
+  mBeginInstances.Sort(nsSMILInstanceTime::ComparisonCallback, nsnull);
+  mEndInstances.Sort(nsSMILInstanceTime::ComparisonCallback, nsnull);
+
+  while (true) {
+    if (!mBeginSpecSet && beginAfter.CompareTo(zeroTime) < 1) {
+      tempBegin.SetMillis(0);
+    } else {
+      PRBool beginFound = GetNextGreater(mBeginInstances, beginAfter,
+                                         beginPos, tempBegin);
+      if (!beginFound)
+        return NS_ERROR_FAILURE;
+    }
+
+    if (mEndInstances.Count() == 0) {
+      nsSMILTimeValue indefiniteEnd;
+      indefiniteEnd.SetIndefinite();
+
+      tempEnd = CalcActiveEnd(tempBegin, indefiniteEnd);
+    } else {
+      //
+      // Start searching from the beginning again.
+      //
+      endPos = 0;
+
+      PRBool endFound = GetNextGreater(mEndInstances, tempBegin,
+                                       endPos, tempEnd);
+
+      if (!aFirstInterval && tempEnd.CompareTo(aBeginAfter)==0 ||
+       (aFirstInterval && tempEnd.CompareTo(tempBegin)==0 && endPos<=endMaxPos))
+        endFound = GetNextGreater(mEndInstances, tempBegin, endPos, tempEnd);
+
+      endMaxPos = endPos;
+
+      if (!endFound) {
+        if (mEndHasEventConditions || mEndInstances.Count() == 0)
+          tempEnd.SetUnresolved();
+        else
+          //
+          // This is a little counter-intuitive but according to SMILANIM, if
+          // all the end's are after the begin, we _don't_ just assume an
+          // infinite end, it's actually a bad interval. ASV however will just
+          // use an infinite end.
+          //
+          return NS_ERROR_FAILURE;
+      }
+
+      tempEnd = CalcActiveEnd(tempBegin, tempEnd);
+    }
+
+    if (tempEnd.CompareTo(zeroTime) == 1) {
+      aResult.UpdateBegin(tempBegin);
+      aResult.UpdateEnd(tempEnd);
+      return NS_OK;
+    } else if (mRestartMode.GetIntegerValue() == restart_never) {
+      return NS_ERROR_FAILURE;
+    } else {
+      beginAfter = tempEnd;
+    }
+  }
+  NS_NOTREACHED("Hmm... we really shouldn't be here");
+
+  return NS_ERROR_FAILURE;
+}
+
+PRBool
+nsSMILTimedElement::GetNextGreater(const nsCOMArray<nsSMILInstanceTime>& aList,
+                                   const nsSMILTimeValue& aBase,
+                                   PRInt32 &aPosition,
+                                   nsSMILTimeValue& aResult)
+{
+    PRBool              found = PR_FALSE;
+    nsSMILInstanceTime* val;
+    PRInt32             count = aList.Count();
+
+    for (; aPosition < count && !found; ++aPosition) {
+      val = static_cast<nsSMILInstanceTime*>(aList[aPosition]);
+      if (val->Time().CompareTo(aBase) > -1) {
+        aResult = val->Time();
+        found = PR_TRUE;
+      }
+    }
+
+    return found;
+}
+
+inline PRInt64
+nsSMILTimedElement::MinLL(const PRInt64& a, const PRInt64& b)
+{
+  return (LL_CMP(a, <, b)) ? a : b;
+}
+
+/**
+ * @see SMILANIM 3.3.4
+ */
+nsSMILTimeValue
+nsSMILTimedElement::CalcActiveEnd(const nsSMILTimeValue& aBegin,
+                                  const nsSMILTimeValue& aEnd)
+{
+  nsSMILTimeValue result;
+
+  if (!mSimpleDur.IsIndefinite() && !mSimpleDur.IsResolved()) {
+    NS_ERROR("Unresolved simple duration in CalcActiveEnd.");
+    result.SetIndefinite();
+    return result;
+  }
+
+  if (!aBegin.IsResolved() && !aBegin.IsIndefinite()) {
+    NS_ERROR("Unresolved begin time passed to CalcActiveEnd.");
+    result.SetIndefinite();
+    return result;
+  }
+
+  if (mRepeatDur.IsIndefinite() || aBegin.IsIndefinite()) {
+    result.SetIndefinite();
+  } else {
+    result = GetRepeatDuration();
+  }
+
+  if (aEnd.IsResolved() && aBegin.IsResolved()) {
+    PRInt64 activeDur;
+    LL_SUB(activeDur, aEnd.GetMillis(), aBegin.GetMillis());
+
+    if (result.IsResolved())
+      result.SetMillis(MinLL(result.GetMillis(), activeDur));
+    else
+      result.SetMillis(activeDur);
+  }
+
+  result = ApplyMinAndMax(result);
+
+  if (result.IsResolved()) {
+    PRInt64 activeEnd;
+    LL_ADD(activeEnd, result.GetMillis(), aBegin.GetMillis());
+    result.SetMillis(activeEnd);
+  }
+
+  return result;
+}
+
+nsSMILTimeValue
+nsSMILTimedElement::GetRepeatDuration()
+{
+  nsSMILTimeValue result;
+
+  if (mRepeatCount.IsResolved() && mRepeatDur.IsResolved()) {
+    if (mSimpleDur.IsResolved()) {
+      PRInt64 activeDur;
+      LL_MUL(activeDur, mRepeatCount.GetMillis(), mSimpleDur.GetMillis());
+      LL_DIV(activeDur, activeDur, 1000);
+      result.SetMillis(MinLL(activeDur, mRepeatDur.GetMillis()));
+    } else {
+      result = mRepeatDur;
+    }
+  } else if (mRepeatCount.IsResolved() && mSimpleDur.IsResolved()) {
+    PRInt64 activeDur;
+    LL_MUL(activeDur, mRepeatCount.GetMillis(), mSimpleDur.GetMillis());
+    LL_DIV(activeDur, activeDur, 1000);
+    result.SetMillis(activeDur);
+  } else if (mRepeatDur.IsResolved()) {
+    result = mRepeatDur;
+  } else {
+    if (mRepeatCount.IsIndefinite())
+      result.SetIndefinite();
+    else
+      result = mSimpleDur;
+  }
+
+  return result;
+}
+
+nsSMILTimeValue
+nsSMILTimedElement::ApplyMinAndMax(const nsSMILTimeValue& aDuration)
+{
+  if (!aDuration.IsResolved() && !aDuration.IsIndefinite())
+    return aDuration;
+
+  if (mMax.CompareTo(mMin) < 0)
+    return aDuration;
+
+  nsSMILTimeValue result;
+
+  if (aDuration.CompareTo(mMax) > 0) {
+    result = mMax;
+  } else if (aDuration.CompareTo(mMin) < 0) {
+    nsSMILTimeValue repeatDur = GetRepeatDuration();
+    result = (mMin.CompareTo(repeatDur) > 0) ? repeatDur : mMin;
+  } else {
+    result = aDuration;
+  }
+
+  return result;
+}
+
+PRInt64
+nsSMILTimedElement::ActiveTimeToSimpleTime(const PRInt64& aActiveTime,
+                                           PRUint32& aRepeatIteration)
+{
+  PRInt64 result;
+
+  NS_ASSERTION(mSimpleDur.IsResolved() || mSimpleDur.IsIndefinite(),
+      "Trying to calculate active time with unresolved duration");
+
+  if (mSimpleDur.IsIndefinite() || LL_IS_ZERO(mSimpleDur.GetMillis())) {
+    aRepeatIteration = 0;
+    result = aActiveTime;
+  } else {
+    PRInt64 repeatResult;
+    LL_MOD(result, aActiveTime, mSimpleDur.GetMillis());
+    LL_DIV(repeatResult, aActiveTime, mSimpleDur.GetMillis());
+
+    LL_L2UI(aRepeatIteration, repeatResult);
+  }
+
+  return result;
+}
+
+//
+// Although in many cases it would be possible to check for an early end and
+// adjust the current interval well in advance the SMIL Animation spec seems to
+// indicate that we should only apply an early end at the latest possible
+// moment. In particular, this paragraph from section 3.6.8:
+//
+// 'If restart  is set to "always", then the current interval will end early if
+// there is an instance time in the begin list that is before (i.e. earlier
+// than) the defined end for the current interval. Ending in this manner will
+// also send a changed time notice to all time dependents for the current
+// interval end.'
+//
+void
+nsSMILTimedElement::CheckForEarlyEnd(const nsSMILTimeValue& aDocumentTime)
+{
+  if (mRestartMode.GetIntegerValue() != restart_always)
+    return;
+
+  nsSMILTimeValue nextBegin;
+  PRInt32 position = 0;
+
+  //
+  // Despite its name, GetNextGreater actually gets the next instance time that
+  // is greater than _or_equal_to_ the reference time so we have to loop to make
+  // sure we're getting an instance time that is actually _after_ the interval
+  // begin time
+  //
+  while (GetNextGreater(mBeginInstances, mCurrentInterval->Begin(),
+                        position, nextBegin) &&
+         nextBegin.CompareTo(mCurrentInterval->Begin()) == 0);
+
+  if (nextBegin.IsResolved() &&
+      nextBegin.CompareTo(mCurrentInterval->Begin()) > 0 &&
+      nextBegin.CompareTo(mCurrentInterval->End()) < 0 &&
+      nextBegin.CompareTo(aDocumentTime) <= 0) {
+    mCurrentInterval->UpdateEnd(nextBegin);
+  }
+}
+
+void
+nsSMILTimedElement::UpdateCurrentInterval()
+{
+  if (mElementState == state_startup)
+    return;
+
+  nsCOMPtr<nsSMILInterval> updatedInterval = new nsSMILInterval();
+  PRBool isFirstInterval = (mOldIntervals.Count() == 0);
+
+  nsSMILTimeValue beginAfter;
+  if (!isFirstInterval)
+    beginAfter = mOldIntervals[mOldIntervals.Count()-1]->End();
+  else
+    beginAfter.SetMillis(LL_MININT);
+
+  nsresult rv =
+    GetNextInterval(beginAfter, isFirstInterval, *updatedInterval);
+
+  if (NS_SUCCEEDED(rv)) {
+
+    if (mElementState != state_active &&
+        updatedInterval->Begin().CompareTo(mCurrentInterval->Begin())) {
+        mCurrentInterval->UpdateBegin(updatedInterval->Begin());
+    }
+
+    if (updatedInterval->End().CompareTo(mCurrentInterval->End()))
+      mCurrentInterval->UpdateEnd(updatedInterval->End());
+
+    if (mElementState == state_postactive)
+      // XXX notify dependents of new interval
+      mElementState = state_waiting;
+  } else {
+
+    nsSMILTimeValue unresolvedTime;
+    mCurrentInterval->UpdateEnd(unresolvedTime);
+    if (mElementState != state_active)
+      mCurrentInterval->UpdateBegin(unresolvedTime);
+
+    if (mElementState == state_waiting)
+      // XXX notify dependents the current interval has been deleted
+      mElementState = state_postactive;
+
+    if (mElementState == state_active) {
+      // XXX notify dependents the current interval has been deleted
+      mElementState = state_postactive;
+      if (mClient)
+        mClient->ToInactive(PR_FALSE);
+    }
+  }
+}
+
+void
+nsSMILTimedElement::SampleSimpleTime(PRInt64 aActiveTime)
+{
+  if (mClient) {
+    PRUint32 repeatIteration;
+    PRInt64  simpleTime =
+      ActiveTimeToSimpleTime(aActiveTime, repeatIteration);
+    mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
+  }
+}
+
+void
+nsSMILTimedElement::SampleFillValue()
+{
+  if (mFillMode.GetIntegerValue() != fill_freeze)
+    return;
+
+  if (!mClient)
+    return;
+
+  PRUint32 repeatIteration;
+  PRInt64 activeTime;
+  LL_SUB(activeTime,
+         mCurrentInterval->End().GetMillis(),
+         mCurrentInterval->Begin().GetMillis());
+
+  PRInt64  simpleTime =
+    ActiveTimeToSimpleTime(activeTime, repeatIteration);
+
+  if (LL_IS_ZERO(simpleTime))
+    mClient->SampleLastValue(--repeatIteration);
+  else
+    mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
+}
+
Index: mozilla/svg/content/src/nsISVGAnimationElement.h
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsISVGAnimationElement.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_ISVGANIMATIONELEMENT__
+#define __NS_ISVGANIMATIONELEMENT__
+
+#include "nsISupports.h"
+
+//////////////////////////////////////////////////////////////////////////////
+// nsISVGAnimationElement: private interface implemented by animation elements
+
+#define NS_ISVGANIMATIONELEMENT_IID \
+{ 0x70ac6eed, 0x0dba, 0x4c11, { 0xa6, 0xc5, 0x15, 0x73, 0xbc, 0x2f, 0x1a, 0xd8 } }
+
+class nsISVGAnimationElement : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISVGANIMATIONELEMENT_IID)
+
+  /**
+   * For setting the ordinal position of this animation within the document.
+   */
+  virtual void            SetDocumentPosition(PRUint16 aDocPosition)=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsISVGAnimationElement,
+                              NS_ISVGANIMATIONELEMENT_IID)
+
+#endif // __NS_ISVGANIMATIONELEMENT__
+
Index: mozilla/svg/content/src/nsSVGAnimateElement.cpp
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGAnimateElement.cpp
@@ -0,0 +1,186 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGAnimateElement.h"
+
+typedef nsSVGAnimationElement nsSVGAnimateElementBase;
+
+class nsSVGAnimateElement : public nsSVGAnimateElementBase,
+                            public nsIDOMSVGAnimateElement
+                              // : nsIDOMSVGAnimationElement
+{
+protected:
+  friend nsresult NS_NewSVGAnimateElement(nsIContent **aResult,
+                                          nsINodeInfo *aNodeInfo);
+  nsSVGAnimateElement(nsINodeInfo* aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATEELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGAnimateElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGAnimateElementBase::)
+
+  // nsIContent specializations
+  virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                           nsIAtom* aPrefix, const nsAString& aValue,
+                           PRBool aNotify);
+  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+
+protected:
+  // Implementation helpers
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute();
+  virtual nsIAtom** GetAnimationProperties();
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(Animate)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimateElement,nsSVGAnimateElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimateElement,nsSVGAnimateElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimateElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimateElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimateElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimateElement::nsSVGAnimateElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimateElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGAnimateElement::Init()
+{
+  return nsSVGAnimateElementBase::Init();
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGAnimateElement)
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+nsresult
+nsSVGAnimateElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                             nsIAtom* aPrefix, const nsAString& aValue,
+                             PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateElementBase::SetAttr(aNameSpaceID, aName, aPrefix,
+                                                 aValue, aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aName == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGAnimateElement::UnsetAttr(PRInt32 aNameSpaceID,
+                               nsIAtom* aAttribute, PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateElementBase::UnsetAttr(aNameSpaceID, aAttribute,
+                                                   aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aAttribute == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+already_AddRefed<nsISMILAttr>
+nsSVGAnimateElement::GetTargetAttribute()
+{
+  nsISMILAttr* result = nsnull;
+
+  if (mTargetElement) {
+    nsAutoString attributeName;
+
+    GetAttr(kNameSpaceID_None, nsGkAtoms::attributeName, attributeName);
+
+    nsCOMPtr<nsIAtom> attributeAtom( do_GetAtom(attributeName) );
+    nsCOMPtr<nsIContent> targetElement(do_QueryReferent(mTargetElement));
+
+    if (targetElement && attributeAtom) {
+      result =
+        static_cast<nsSVGElement*>(targetElement.get())->GetAnimAttribute(kNameSpaceID_None,
+                                                                          attributeAtom).get();
+    }
+  }
+
+  return result;
+}
+
+nsIAtom** nsSVGAnimateElement::GetAnimationProperties()
+{
+  static nsIAtom *atoms[] = { nsGkAtoms::by, nsGkAtoms::from,
+                              nsGkAtoms::to, nsGkAtoms::values,
+                              nsnull };
+
+  return atoms;
+}
Index: mozilla/svg/content/src/nsSVGAnimateTransformElement.cpp
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGAnimateTransformElement.cpp
@@ -0,0 +1,229 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGAnimateTransformElement.h"
+#include "nsSVGEnum.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsIDOMSVGTransformable.h"
+#include "nsSVGAnimatedTransformList.h"
+#include "nsSVGTransformSMILAttr.h"
+
+typedef nsSVGAnimationElement nsSVGAnimateTransformElementBase;
+
+class nsSVGAnimateTransformElement : public nsSVGAnimateTransformElementBase,
+                                     public nsIDOMSVGAnimateTransformElement
+                                       // : nsIDOMSVGAnimationElement
+{
+protected:
+  friend nsresult NS_NewSVGAnimateTransformElement(nsIContent **aResult,
+                                                   nsINodeInfo *aNodeInfo);
+  nsSVGAnimateTransformElement(nsINodeInfo* aNodeInfo);
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATETRANSFORMELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGAnimateTransformElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGAnimateTransformElementBase::)
+
+  // nsIContent specializations
+  virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                           nsIAtom* aPrefix, const nsAString& aValue,
+                           PRBool aNotify);
+  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+
+protected:
+  virtual nsIAtom** GetAnimationProperties();
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute();
+  virtual EnumAttributesInfo GetEnumInfo();
+
+  enum { TYPE };
+  nsSVGEnum mEnumAttributes[1];
+  static nsSVGEnumMapping sTransformTypeMap[];
+  static EnumInfo sEnumInfo[1];
+};
+
+nsSVGEnumMapping nsSVGAnimateTransformElement::sTransformTypeMap[] = {
+  {&nsGkAtoms::translate, nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE},
+  {&nsGkAtoms::scale, nsIDOMSVGTransform::SVG_TRANSFORM_SCALE},
+  {&nsGkAtoms::rotate, nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE},
+  {&nsGkAtoms::skewX, nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX},
+  {&nsGkAtoms::skewY, nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY},
+  {nsnull, 0}
+};
+
+nsSVGElement::EnumInfo nsSVGAnimateTransformElement::sEnumInfo[1] =
+{
+  { &nsGkAtoms::type,
+    sTransformTypeMap,
+    nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE
+  }
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(AnimateTransform)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimateTransformElement,nsSVGAnimateTransformElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimateTransformElement,nsSVGAnimateTransformElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimateTransformElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimateTransformElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimateTransformElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimateTransformElement::nsSVGAnimateTransformElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimateTransformElementBase(aNodeInfo)
+{
+}
+
+nsSVGElement::EnumAttributesInfo
+nsSVGAnimateTransformElement::GetEnumInfo()
+{
+  return EnumAttributesInfo(mEnumAttributes, sEnumInfo,
+                            NS_ARRAY_LENGTH(sEnumInfo));
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGAnimateTransformElement)
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+nsresult
+nsSVGAnimateTransformElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                                      nsIAtom* aPrefix, const nsAString& aValue,
+                                      PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateTransformElementBase::SetAttr(aNameSpaceID, aName,
+                                                          aPrefix, aValue,
+                                                          aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aName == nsGkAtoms::type)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGAnimateTransformElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                                        PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimateTransformElementBase::UnsetAttr(aNameSpaceID,
+                                                            aAttribute,
+                                                            aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aAttribute == nsGkAtoms::type)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+already_AddRefed<nsISMILAttr>
+nsSVGAnimateTransformElement::GetTargetAttribute()
+{
+  nsISMILAttr* result = nsnull;
+
+  if (!HasAttr(kNameSpaceID_None, nsGkAtoms::type))
+    return nsnull;
+
+  if (mTargetElement) {
+    /* Get the list */
+    nsCOMPtr<nsIDOMSVGTransformable> transformable(
+        do_QueryReferent(mTargetElement) );
+    NS_ENSURE_TRUE(transformable, nsnull);
+    nsCOMPtr<nsIDOMSVGAnimatedTransformList> transformList;
+    nsresult rv = transformable->GetTransform(getter_AddRefs(transformList));
+    NS_ENSURE_SUCCESS(rv,nsnull);
+    nsSVGAnimatedTransformList* list =
+      (nsSVGAnimatedTransformList*)transformList.get();
+    NS_ENSURE_TRUE(list,nsnull);
+
+    /* Get the SVG element */
+    nsCOMPtr<nsIDOMSVGElement> svgElement(do_QueryReferent(mTargetElement));
+    NS_ENSURE_TRUE(svgElement, nsnull);
+    nsSVGElement *target = (nsSVGElement*)svgElement.get();
+
+    /* Get the type */
+    PRUint16 transformType = mEnumAttributes[TYPE].GetAnimValue();
+
+    result = new nsSVGTransformSMILAttr(list, target, transformType);
+    NS_ENSURE_SUCCESS(rv,nsnull);
+    NS_ADDREF(result);
+  }
+
+  return result;
+}
+
+nsIAtom** nsSVGAnimateTransformElement::GetAnimationProperties()
+{
+  static nsIAtom *atoms[] = { nsGkAtoms::by, nsGkAtoms::from,
+                              nsGkAtoms::to, nsGkAtoms::values,
+                              nsnull };
+
+  return atoms;
+}
Index: mozilla/svg/content/src/nsSVGAnimationElement.cpp
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGAnimationElement.cpp
@@ -0,0 +1,351 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsSVGSVGElement.h"
+#include "nsISMILAnimationRegistry.h"
+#include "nsISMILAttr.h"
+#include "nsISMILComposable.h"
+#include "nsISMILTimeClient.h"
+#include "nsBindingManager.h"
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGAnimationElement, nsSVGAnimationElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsISVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElementTimeControl)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGAnimationElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGAnimationElement::nsSVGAnimationElement(nsINodeInfo *aNodeInfo)
+  : nsSVGAnimationElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGAnimationElement::Init()
+{
+  nsresult rv = nsSVGAnimationElementBase::Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mAnimation = NS_NewSMILAnimationFunction();
+  NS_ENSURE_TRUE(mAnimation, NS_ERROR_FAILURE);
+
+  mTimedElement = NS_NewSMILTimedElement();
+  NS_ENSURE_TRUE(mTimedElement, NS_ERROR_FAILURE);
+
+  mTimeControl = do_QueryInterface(mTimedElement);
+  NS_ENSURE_TRUE(mTimeControl, NS_ERROR_FAILURE);
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// nsIDOMSVGAnimationElement methods
+
+/* readonly attribute SVGElement targetElement; */
+NS_IMETHODIMP
+nsSVGAnimationElement::GetTargetElement(nsIDOMSVGElement * *aTarget)
+{
+  if (mTargetElement) {
+    nsCOMPtr<nsIDOMSVGElement> target = do_QueryReferent(mTargetElement);
+    NS_IF_RELEASE(*aTarget);
+    NS_IF_ADDREF(*aTarget = target);
+  } else {
+    *aTarget = nsnull;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetStartTime(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetStartTime");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetCurrentTime(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetStartTime");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsSVGAnimationElement::GetSimpleDuration(float* retval)
+{
+  // XXX
+  (void)retval;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimationElement::GetStartTime");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+//----------------------------------------------------------------------
+// nsISVGAnimationElement methods
+
+void
+nsSVGAnimationElement::SetDocumentPosition(PRUint16 aDocPosition)
+{
+  if (mAnimation->GetTargetAttribute())
+    mAnimation->SetDocumentPosition(aDocPosition);
+}
+
+//----------------------------------------------------------------------
+// nsISVGContent methods
+
+nsresult
+nsSVGAnimationElement::BindToTree(nsIDocument* aDocument,
+                                nsIContent* aParent,
+                                nsIContent* aBindingParent,
+                                PRBool aCompileEventHandlers)
+{
+  nsresult rv = nsSVGAnimationElementBase::BindToTree(aDocument, aParent,
+                                                    aBindingParent,
+                                                    aCompileEventHandlers);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
+  rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
+
+  if (NS_FAILED(rv) || !ownerDOMSVG)
+    // No use proceeding. We don't have an SVG parent (yet) so we won't be able
+    // to register ourselves etc. Maybe next time we'll have more luck.
+    // (This sort of situation will arise a lot when trees are being constructed
+    // piece by piece via script)
+    return NS_OK;
+
+  nsCOMPtr<nsISMILAnimationRegistry> registry = GetAnimationRegistry();
+  if (!registry)
+    // Registry hasn't been created yet. This will be created when the SVG
+    // parent is bound.
+    return NS_OK;
+
+  UpdateTargetElement();
+
+  nsSVGSVGElement *ownerSVG = static_cast<nsSVGSVGElement*>(ownerDOMSVG.get());
+  ownerSVG->EnumerateAnimationNodes();
+
+  rv = registry->RegisterTimedElement(mTimedElement);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  return rv;
+}
+
+void
+nsSVGAnimationElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
+{
+  nsCOMPtr<nsISMILAnimationRegistry> registry = GetAnimationRegistry();
+
+  if (mAnimation->GetTargetAttribute()) {
+      if (registry) {
+        nsCOMPtr<nsISMILComposable> composable(do_QueryInterface(mAnimation));
+        registry->UnregisterComposable(composable);
+      }
+      mAnimation->SetTargetAttribute(nsnull);
+  }
+
+  if (registry)
+    registry->UnregisterTimedElement(mTimedElement);
+
+  nsSVGAnimationElementBase::UnbindFromTree(aDeep, aNullParent);
+}
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+PRBool
+nsSVGAnimationElement::ParseAttribute(PRInt32 aNamespaceID,
+                                      nsIAtom* aAttribute,
+                                      const nsAString& aValue,
+                                      nsAttrValue& aResult)
+{
+  PRBool result = PR_FALSE;
+
+  if (aNamespaceID == kNameSpaceID_None)
+  {
+    result = mAnimation->SetAttr(aAttribute, aValue);
+
+    if (!result)
+      mTimedElement->SetAttr(aAttribute, aValue);
+
+    if (result)
+      aResult.SetTo(aValue);
+  }
+
+  return nsSVGAnimationElementBase::ParseAttribute(aNamespaceID, aAttribute,
+                                                   aValue, aResult);
+}
+
+nsresult
+nsSVGAnimationElement::UnsetAttr(PRInt32 aNamespaceID,
+                                 nsIAtom* aAttribute, PRBool aNotify)
+{
+  nsresult rv = nsSVGAnimationElementBase::UnsetAttr(aNamespaceID, aAttribute,
+                                                     aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNamespaceID == kNameSpaceID_None)
+  {
+    if (!mAnimation->UnsetAttr(aAttribute))
+      mTimedElement->UnsetAttr(aAttribute);
+  }
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsISMILAnimationRegistry*
+nsSVGAnimationElement::GetAnimationRegistry()
+{
+  nsISMILAnimationRegistry*     result = nsnull;
+  nsCOMPtr<nsIDOMSVGSVGElement> ownerDOMSVG;
+
+  nsresult rv = GetOwnerSVGElement(getter_AddRefs(ownerDOMSVG));
+
+  if (NS_SUCCEEDED(rv) && ownerDOMSVG) {
+    nsSVGSVGElement *ownerSVG =
+      static_cast<nsSVGSVGElement*>(ownerDOMSVG.get());
+    result = ownerSVG->GetAnimationRegistry();
+  }
+
+  return result;
+}
+
+nsIContent*
+nsSVGAnimationElement::GetParentElement()
+{
+  nsCOMPtr<nsIContent> result;
+  nsBindingManager*   bindingManager = nsnull;
+  nsIDocument*        ownerDoc = GetOwnerDoc();
+
+  if (ownerDoc)
+    bindingManager = ownerDoc->BindingManager();
+
+  if (bindingManager)
+    // we have a binding manager -- do we have an anonymous parent?
+    result = bindingManager->GetInsertionParent(this);
+
+  if (!result)
+    // if we didn't find an anonymous parent, use the explicit one,
+    // whether it's null or not...
+    result = GetParent();
+
+  return result;
+}
+
+void
+nsSVGAnimationElement::UpdateTargetElement()
+{
+  // XXX Follow xlink:href attributes when provided
+
+  nsCOMPtr<nsIContent> target = GetParentElement();
+  if (!target)
+    return;
+
+  nsWeakPtr targetElement = do_GetWeakReference(target);
+  if (mTargetElement != targetElement || !mAnimation->GetTargetAttribute()) {
+    mTargetElement = targetElement;
+    UpdateTargetAttribute();
+  }
+}
+
+void
+nsSVGAnimationElement::UpdateTargetAttribute()
+{
+  nsresult rv;
+
+  if (mTargetElement) {
+    nsRefPtr<nsISMILAttr> prevAttribute = mAnimation->GetTargetAttribute();
+    nsRefPtr<nsISMILAttr> targetAttribute = GetTargetAttribute();
+
+    rv = mAnimation->SetTargetAttribute(targetAttribute);
+    NS_ENSURE_SUCCESS(rv,);
+
+    SetAnimationProperties();
+
+    nsCOMPtr<nsISMILTimeClient> timeClient( do_QueryInterface(mAnimation) );
+    NS_ENSURE_TRUE(timeClient,);
+    mTimedElement->SetTimeClient(timeClient);
+
+    if (targetAttribute != prevAttribute) {
+      nsCOMPtr<nsISMILAnimationRegistry> registry = GetAnimationRegistry();
+      NS_ENSURE_TRUE(registry,);
+
+      nsCOMPtr<nsISMILComposable> composable( do_QueryInterface(mAnimation) );
+      NS_ENSURE_TRUE(composable,);
+
+      if (prevAttribute)
+        registry->UnregisterComposable(composable);
+
+      if (targetAttribute)
+        registry->RegisterComposable(targetAttribute, composable);
+    }
+  }
+}
+
+void
+nsSVGAnimationElement::SetAnimationProperties()
+{
+  NS_ENSURE_TRUE(mAnimation,);
+  if (!mAnimation->GetTargetAttribute())
+    return;
+
+  nsIAtom** property = GetAnimationProperties();
+  nsAutoString attrValue;
+  while (*property) {
+    nsIAtom* atom = *property++;
+    if (HasAttr(kNameSpaceID_None, atom)) {
+      if (NS_SUCCEEDED(GetAttr(kNameSpaceID_None, atom, attrValue)))
+        mAnimation->SetAttr(atom, attrValue);
+    }
+  }
+}
+
Index: mozilla/svg/content/src/nsSVGAnimationElement.h
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGAnimationElement.h
@@ -0,0 +1,105 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_SVGANIMATIONELEMENT_H__
+#define __NS_SVGANIMATIONELEMENT_H__
+
+#include "nsSVGElement.h"
+#include "nsIDOMSVGAnimationElement.h"
+#include "nsIDOMElementTimeControl.h"
+#include "nsISVGAnimationElement.h"
+#include "nsISMILAnimationFunction.h"
+#include "nsISMILTimedElement.h"
+
+class nsISMILAnimationRegistry;
+
+typedef nsSVGElement nsSVGAnimationElementBase;
+
+class nsSVGAnimationElement : public nsSVGAnimationElementBase,
+                              public nsISVGAnimationElement,
+                              public nsIDOMElementTimeControl
+{
+protected:
+  nsSVGAnimationElement(nsINodeInfo *aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGANIMATIONELEMENT
+
+  NS_FORWARD_SAFE_NSIDOMELEMENTTIMECONTROL(mTimeControl)
+
+  // nsISVGAnimationElement
+  virtual void     SetDocumentPosition(PRUint16 aDocPosition);
+
+  // nsISVGContent specializations
+  virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
+                              nsIContent* aBindingParent,
+                              PRBool aCompileEventHandlers);
+  virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
+                              PRBool aNullParent = PR_TRUE);
+
+  // nsIContent specializations
+  virtual nsresult UnsetAttr(PRInt32 aNamespaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  // nsGenericElement specializations
+  virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
+                                nsIAtom* aAttribute,
+                                const nsAString& aValue,
+                                nsAttrValue& aResult);
+
+protected:
+  // Implementation helpers
+  nsISMILAnimationRegistry*          GetAnimationRegistry();
+  nsIContent*                        GetParentElement();
+  void                               UpdateTargetElement();
+  void                               UpdateTargetAttribute();
+  void                               SetAnimationProperties();
+
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute() = 0;
+  virtual nsIAtom** GetAnimationProperties() = 0;
+
+  nsWeakPtr                          mTargetElement;
+  nsRefPtr<nsISMILAnimationFunction> mAnimation;
+  nsCOMPtr<nsISMILTimedElement>      mTimedElement;
+  nsCOMPtr<nsIDOMElementTimeControl> mTimeControl; // QI'ed version of the above
+};
+
+#endif // __NS_SVGANIMATIONELEMENT_H__
Index: mozilla/svg/content/src/nsSVGSetElement.cpp
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGSetElement.cpp
@@ -0,0 +1,188 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *   Chris Double  <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGAnimationElement.h"
+#include "nsIDOMSVGSetElement.h"
+
+typedef nsSVGAnimationElement nsSVGSetElementBase;
+
+class nsSVGSetElement : public nsSVGSetElementBase,
+                        public nsIDOMSVGSetElement
+{
+protected:
+  friend nsresult NS_NewSVGSetElement(nsIContent **aResult,
+                                      nsINodeInfo *aNodeInfo);
+  nsSVGSetElement(nsINodeInfo* aNodeInfo);
+  nsresult Init();
+
+public:
+  // interfaces:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIDOMSVGSETELEMENT
+
+  NS_FORWARD_NSIDOMNODE(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMELEMENT(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMSVGELEMENT(nsSVGSetElementBase::)
+  NS_FORWARD_NSIDOMSVGANIMATIONELEMENT(nsSVGSetElementBase::)
+
+  // nsIContent specializations
+  virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                           nsIAtom* aPrefix, const nsAString& aValue,
+                           PRBool aNotify);
+  virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
+                             PRBool aNotify);
+
+  virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
+
+protected:
+  // Implementation helpers
+  virtual already_AddRefed<nsISMILAttr> GetTargetAttribute();
+  virtual nsIAtom** GetAnimationProperties();
+};
+
+NS_IMPL_NS_NEW_SVG_ELEMENT(Set)
+
+
+//----------------------------------------------------------------------
+// nsISupports methods
+
+NS_IMPL_ADDREF_INHERITED(nsSVGSetElement,nsSVGSetElementBase)
+NS_IMPL_RELEASE_INHERITED(nsSVGSetElement,nsSVGSetElementBase)
+
+NS_INTERFACE_MAP_BEGIN(nsSVGSetElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimationElement)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSetElement)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGAnimateElement)
+NS_INTERFACE_MAP_END_INHERITING(nsSVGSetElementBase)
+
+//----------------------------------------------------------------------
+// Implementation
+
+nsSVGSetElement::nsSVGSetElement(nsINodeInfo *aNodeInfo)
+  : nsSVGSetElementBase(aNodeInfo)
+{
+}
+
+nsresult
+nsSVGSetElement::Init()
+{
+  nsresult rv = nsSVGSetElementBase::Init();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mAnimation->SetAttr(nsGkAtoms::calcMode, NS_LITERAL_STRING("discrete"), &rv);
+  return rv;
+}
+
+//----------------------------------------------------------------------
+// nsIDOMNode methods
+
+NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGSetElement)
+
+//----------------------------------------------------------------------
+// nsIContent methods
+
+nsresult
+nsSVGSetElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
+                             nsIAtom* aPrefix, const nsAString& aValue,
+                             PRBool aNotify)
+{
+  nsresult rv = nsSVGSetElementBase::SetAttr(aNameSpaceID, aName, aPrefix,
+                                                 aValue, aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aName == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGSetElement::UnsetAttr(PRInt32 aNameSpaceID,
+                               nsIAtom* aAttribute, PRBool aNotify)
+{
+  nsresult rv = nsSVGSetElementBase::UnsetAttr(aNameSpaceID, aAttribute,
+                                                   aNotify);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  if (aNameSpaceID != kNameSpaceID_None)
+    return NS_OK;
+
+  if (aAttribute == nsGkAtoms::attributeName)
+    UpdateTargetAttribute();
+
+  return NS_OK;
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+already_AddRefed<nsISMILAttr>
+nsSVGSetElement::GetTargetAttribute()
+{
+  nsISMILAttr* result = nsnull;
+
+  if (mTargetElement) {
+    nsAutoString attributeName;
+
+    GetAttr(kNameSpaceID_None, nsGkAtoms::attributeName, attributeName);
+
+    nsCOMPtr<nsIAtom> attributeAtom( do_GetAtom(attributeName) );
+    nsCOMPtr<nsIContent> targetElement(do_QueryReferent(mTargetElement));
+
+    if (targetElement && attributeAtom) {
+      result =
+        static_cast<nsSVGElement*>(targetElement.get())->GetAnimAttribute(kNameSpaceID_None,
+                                                                          attributeAtom).get();
+    }
+  }
+
+  return result;
+}
+
+nsIAtom** nsSVGSetElement::GetAnimationProperties()
+{
+  static nsIAtom *atoms[] = { nsGkAtoms::to, nsnull };
+
+  return atoms;
+}
Index: mozilla/svg/content/src/nsSVGTransformSMILAttr.cpp
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGTransformSMILAttr.cpp
@@ -0,0 +1,341 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGTransformSMILAttr.h"
+#include "nsSVGTransformSMILType.h"
+#include "nsSVGAnimatedTransformList.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsIDOMSVGMatrix.h"
+#include "nsSVGTransformList.h"
+#include "nsSVGMatrix.h"
+#include "nsSMILValue.h"
+#include "nsSVGElement.h"
+#include "nsISVGValue.h"
+#include "prdtoa.h"
+
+int nsSVGTransformSMILAttr::sType = 1;
+
+nsresult
+nsSVGTransformSMILAttr::GetBaseValue(nsSMILValue& aValue)
+{
+  nsCOMPtr<nsIDOMSVGTransform> transform;
+  nsresult rv = mVal->mBaseVal->Consolidate(getter_AddRefs(transform));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  nsCOMPtr<nsIDOMSVGMatrix> matrix;
+  /* Consolidate sets transform to NULL if there are no matrices */
+  if (transform)
+    rv = transform->GetMatrix(getter_AddRefs(matrix));
+  else
+    rv = NS_NewSVGMatrix(getter_AddRefs(matrix));
+  NS_ENSURE_SUCCESS(rv,rv);
+  NS_ENSURE_TRUE(matrix,NS_ERROR_FAILURE);
+
+  nsSMILValue val;
+
+  /*
+   * Assign the type first or if something goes wrong the matrix might never be
+   * released.
+   */
+  val.mType = GetSMILType();
+  NS_ENSURE_TRUE(val.mType, NS_ERROR_FAILURE);
+
+  nsIDOMSVGMatrix *raw_matrix = matrix;
+  val.mU.mPtr = raw_matrix;
+  NS_ADDREF(raw_matrix);
+
+  aValue = val;
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILAttr::SetAnimValue(const nsSMILValue& aValue)
+{
+  if (aValue.mType != &nsSVGTransformSMILType::sTranslateTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sScaleTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sRotateTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sSkewXTransformType &&
+      aValue.mType != &nsSVGTransformSMILType::sSkewYTransformType) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *value = (nsIDOMSVGMatrix *)aValue.mU.mPtr;
+  NS_ENSURE_TRUE(value,NS_ERROR_FAILURE);
+
+  mVal->WillModify(nsISVGValue::mod_other);
+
+  nsresult rv = NS_OK;
+
+  if (!mVal->mAnimVal)
+  {
+    rv = nsSVGTransformList::Create(getter_AddRefs(mVal->mAnimVal));
+    NS_ENSURE_SUCCESS(rv,NS_ERROR_FAILURE);
+  }
+
+  mVal->mAnimVal->Clear();
+
+  nsCOMPtr<nsIDOMSVGTransform> transform;
+  rv = mVal->mBaseVal->CreateSVGTransformFromMatrix(value,
+                                                    getter_AddRefs(transform));
+
+  nsCOMPtr<nsIDOMSVGTransform> result;
+  rv = mVal->mAnimVal->AppendItem(transform, getter_AddRefs(result));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  mVal->DidModify(nsISVGValue::mod_other);
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILAttr::ValueFromString(const nsAString& aStr,
+                                        nsSMILValue &aValue)
+{
+  nsISMILType *type = GetSMILType();
+  NS_ENSURE_TRUE(type, NS_ERROR_FAILURE);
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  nsresult rv = ParseValue(aStr, mTransformType, &matrix);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  aValue.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+  aValue.mType   = type;
+
+  return NS_OK;
+}
+
+PRBool
+nsSVGTransformSMILAttr::EqualTarget(const nsISMILAttr &aOther) const
+{
+  if (aOther.mType != &sType)
+    return PR_FALSE;
+
+  nsSVGTransformSMILAttr const *other =
+    static_cast<const nsSVGTransformSMILAttr*>(&aOther);
+  return (mVal == other->mVal);
+}
+
+nsISMILType *
+nsSVGTransformSMILAttr::GetSMILType() const
+{
+  switch (mTransformType)
+  {
+  case nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE:
+    return &nsSVGTransformSMILType::sTranslateTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SCALE:
+    return &nsSVGTransformSMILType::sScaleTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE:
+    return &nsSVGTransformSMILType::sRotateTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX:
+    return &nsSVGTransformSMILType::sSkewXTransformType;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY:
+    return &nsSVGTransformSMILType::sSkewYTransformType;
+    break;
+
+  default:
+    NS_NOTREACHED("Bad transform type");
+    return nsnull;
+  }
+}
+
+//----------------------------------------------------------------------
+// Implementation helpers
+
+nsresult
+nsSVGTransformSMILAttr::ParseValue(const nsAString &aSpec,
+                                   PRUint16 aTransformType,
+                                   nsIDOMSVGMatrix** aMatrix) const
+{
+  nsresult rv = NS_OK;
+
+  switch (aTransformType)
+  {
+  case nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE:
+    {
+      // tx [ty=0]
+      float t[2] = { 0.f };
+      PRInt32 num_parsed = ParseParameterList(aSpec, t, 2);
+      if (num_parsed != 1 && num_parsed != 2) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      rv = NS_NewSVGMatrix(aMatrix, 1.f, 0.f, 0.f, 1.f, t[0], t[1]);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SCALE:
+    {
+      // sx [sy=sx]
+      float s[2] = { 0.f };
+      PRInt32 num_parsed = ParseParameterList(aSpec, s, 2);
+      if (num_parsed != 1 && num_parsed != 2) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      if (num_parsed == 1)
+        s[1] = s[0];
+
+      rv = NS_NewSVGMatrix(aMatrix, s[0], 0.f, 0.f, s[1], 0.f, 0.f);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE:
+    {
+      // r [x0=0 y0=0]
+      float r[3] = { 0.f };
+      PRInt32 num_parsed = ParseParameterList(aSpec, r, 3);
+      if (num_parsed != 1 && num_parsed != 3) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp2;
+      rv = temp->Rotate(r[0], getter_AddRefs(temp2));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp2->Translate(-r[1],-r[2], getter_AddRefs(temp));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      *aMatrix = temp;
+      NS_ADDREF(*aMatrix);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX:
+    {
+      // x-angle
+      float angle;
+      PRInt32 num_parsed = ParseParameterList(aSpec, &angle, 1);
+      if (num_parsed != 1) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp_matrix;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp_matrix));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp_matrix->SkewX(angle, aMatrix);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY:
+    {
+      // y-angle
+      float angle;
+      PRInt32 num_parsed = ParseParameterList(aSpec, &angle, 1);
+      if (num_parsed != 1) {
+        rv = NS_ERROR_FAILURE;
+        break; // parse error
+      }
+
+      nsCOMPtr<nsIDOMSVGMatrix> temp_matrix;
+      rv = NS_NewSVGMatrix(getter_AddRefs(temp_matrix));
+      NS_ENSURE_SUCCESS(rv,rv);
+
+      rv = temp_matrix->SkewY(angle, aMatrix);
+    }
+    break;
+
+  default:
+    rv = NS_ERROR_FAILURE;
+    break;
+  }
+
+  return rv;
+}
+
+inline PRBool
+nsSVGTransformSMILAttr::IsSpace(const char c) const
+{
+  return (c == 0x9 || c == 0xA || c == 0xD || c == 0x20);
+}
+
+inline void
+nsSVGTransformSMILAttr::SkipWsp(nsACString::const_iterator& aIter,
+                                const nsACString::const_iterator& aIterEnd) const
+{
+  while (aIter != aIterEnd && IsSpace(*aIter))
+    ++aIter;
+}
+
+PRInt32
+nsSVGTransformSMILAttr::ParseParameterList(const nsAString &aSpec,
+                                           float *aVars,
+                                           PRInt32 aNVars) const
+{
+  nsCAutoString spec;
+  LossyCopyUTF16toASCII(aSpec, spec);
+
+  nsACString::const_iterator start, end;
+  spec.BeginReading(start);
+  spec.EndReading(end);
+
+  SkipWsp(start, end);
+
+  int num_args_found = 0;
+
+  while (start != end) {
+    char const *arg = start.get();
+    char *argend;
+    float f = (float)PR_strtod(arg, &argend);
+    if (arg == argend || argend > end.get())
+      return -1;
+
+    if (num_args_found < aNVars) {
+      aVars[num_args_found] = f;
+    }
+
+    start.advance(argend - arg);
+    num_args_found++;
+
+    SkipWsp(start, end);
+  }
+
+  return num_args_found;
+}
+
Index: mozilla/svg/content/src/nsSVGTransformSMILAttr.h
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGTransformSMILAttr.h
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILAttr.h"
+#include "nsAutoPtr.h"
+#include "nsString.h"
+
+class nsSVGElement;
+class nsSVGAnimatedTransformList;
+class nsISMILType;
+class nsIDOMSVGMatrix;
+
+class nsSVGTransformSMILAttr : public nsISMILAttr
+{
+public:
+  nsSVGTransformSMILAttr(nsSVGAnimatedTransformList* aTransform,
+                         nsSVGElement* aSVGElement,
+                         PRUint16 aTransformType)
+    : nsISMILAttr(&sType),
+      mVal(aTransform),
+      mSVGElement(aSVGElement),
+      mTransformType(aTransformType) {}
+
+  virtual nsresult  GetBaseValue(nsSMILValue& aValue);
+  virtual nsresult  SetAnimValue(const nsSMILValue& aValue);
+  virtual nsresult  ValueFromString(const nsAString& aStr,
+                                    nsSMILValue &aValue);
+  virtual PRBool    EqualTarget(const nsISMILAttr &aOther) const;
+
+protected:
+  nsresult  ParseValue(const nsAString &aSpec,
+                       PRUint16 aTransformType,
+                       nsIDOMSVGMatrix** aMatrix) const;
+  PRInt32   ParseParameterList(const nsAString &aSpec, float *aVars,
+                               PRInt32 aNVars) const;
+  PRBool    IsSpace(const char c) const;
+  void      SkipWsp(nsACString::const_iterator& aIter,
+                    const nsACString::const_iterator& aIterEnd) const;
+
+private:
+  static int sType; // Type checking only
+
+  nsISMILType *
+  GetSMILType() const;
+
+  nsSVGAnimatedTransformList* mVal;// kept alive because it belongs to content
+  nsRefPtr<nsSVGElement> mSVGElement;
+  PRUint16 mTransformType;
+
+};
+
Index: mozilla/svg/content/src/nsSVGTransformSMILType.cpp
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGTransformSMILType.cpp
@@ -0,0 +1,312 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSVGTransformSMILType.h"
+#include "nsSMILValue.h"
+#include "nsIDOMSVGTransform.h"
+#include "nsSVGMatrix.h"
+#include "nsCOMPtr.h"
+#include "nsCRT.h"
+#include <math.h>
+
+nsSVGTransformSMILType nsSVGTransformSMILType::sTranslateTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sScaleTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SCALE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sRotateTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE);
+nsSVGTransformSMILType nsSVGTransformSMILType::sSkewXTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX);
+nsSVGTransformSMILType nsSVGTransformSMILType::sSkewYTransformType(
+    nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY);
+
+void
+nsSVGTransformSMILType::SetValueIdentity(nsSMILValue &value)
+{
+  NS_ASSERTION(value.mType == this, "Unexpected SMIL value type.");
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  if (NS_FAILED(NS_NewSVGMatrix(&matrix))) {
+    value.mType = &nsSMILNullType::sSingleton;
+    return;
+  }
+
+  value.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+}
+
+void
+nsSVGTransformSMILType::DestroyValue(nsSMILValue& value)
+{
+  NS_ASSERTION(value.mType == this, "Unexpected SMIL value type.");
+  nsIDOMSVGMatrix *matrix = (nsIDOMSVGMatrix *)value.mU.mPtr;
+  NS_IF_RELEASE(matrix);
+}
+
+nsresult
+nsSVGTransformSMILType::AssignValue(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aDest.mType == aSrc.mType, "Incompatible SMIL types.");
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL value.");
+
+  float a, b, c, d, e, f;
+  nsIDOMSVGMatrix *src_matrix = (nsIDOMSVGMatrix *)aSrc.mU.mPtr;
+
+  src_matrix->GetA(&a);
+  src_matrix->GetB(&b);
+  src_matrix->GetC(&c);
+  src_matrix->GetD(&d);
+  src_matrix->GetE(&e);
+  src_matrix->GetF(&f);
+
+  nsIDOMSVGMatrix *matrix = nsnull;
+  nsresult rv = NS_NewSVGMatrix(&matrix, a, b, c, d, e, f);
+  if (NS_FAILED(rv)) {
+    aDest.mType = &nsSMILNullType::sSingleton;
+    return rv;
+  }
+
+  aDest.mU.mPtr = matrix; /* NS_NewSVGMatrix will addref */
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::Add(nsSMILValue& aDest, const nsSMILValue& aSrc)
+{
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL type.");
+
+  if (aSrc.mType != &nsSVGTransformSMILType::sTranslateTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sScaleTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sRotateTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sSkewXTransformType &&
+      aSrc.mType != &nsSVGTransformSMILType::sSkewYTransformType) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *dest_matrix = (nsIDOMSVGMatrix *)aDest.mU.mPtr;
+  nsIDOMSVGMatrix *src_matrix  = (nsIDOMSVGMatrix *)aSrc.mU.mPtr;
+
+  if (!dest_matrix || !src_matrix)
+    return NS_ERROR_FAILURE;
+
+  nsIDOMSVGMatrix *temp;
+  nsresult rv = dest_matrix->Multiply(src_matrix, &temp);
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  NS_ADDREF(temp);
+  NS_RELEASE(dest_matrix);
+  aDest.mU.mPtr = temp;
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::ComputeDistance(const nsSMILValue& aFrom,
+                                     const nsSMILValue& aTo,
+                                     PRFloat64& aDistance) const
+{
+  NS_ASSERTION(aFrom.mType == aTo.mType,
+      "Can't compute difference between different SMIL types.");
+  NS_ASSERTION(aFrom.mType == this, "Unexpected SMIL type.");
+
+  (void)aFrom;
+  (void)aTo;
+
+  aDistance = 0.0;
+  NS_NOTYETIMPLEMENTED("nsSVGAnimatedTransformList::ComputeDistance");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult
+nsSVGTransformSMILType::Interpolate(const nsSMILValue& aStartVal,
+                                    const nsSMILValue& aEndVal,
+                                    float aUnitDistance,
+                                    nsSMILValue& aResult)
+{
+  NS_ASSERTION(aStartVal.mType == aEndVal.mType,
+      "Can't interpolate between different SMIL types.");
+  NS_ASSERTION(aStartVal.mType == this, "Unexpected SMIL type.");
+
+  /*
+   * We cast away constness here because nsIDOMSVGMatrix getters aren't marked
+   * as const.
+   */
+  nsIDOMSVGMatrix* start = (nsIDOMSVGMatrix*)aStartVal.mU.mPtr;
+  nsIDOMSVGMatrix* end   = (nsIDOMSVGMatrix*)aEndVal.mU.mPtr;
+  NS_ENSURE_TRUE(start && end, NS_ERROR_FAILURE);
+
+  nsresult rv = NS_OK;
+
+  nsCOMPtr<nsIDOMSVGMatrix> result = nsnull;
+  rv = NS_NewSVGMatrix(getter_AddRefs(result));
+  NS_ENSURE_SUCCESS(rv,rv);
+
+  switch (mTransformType)
+  {
+  case nsIDOMSVGTransform::SVG_TRANSFORM_TRANSLATE:
+    {
+      float txa,tya;
+      start->GetE(&txa);
+      start->GetF(&tya);
+
+      float txb,tyb;
+      end->GetE(&txb);
+      end->GetF(&tyb);
+
+      result->SetE(txa + (txb - txa) * aUnitDistance);
+      result->SetF(tya + (tyb - tya) * aUnitDistance);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SCALE:
+    {
+      float sxa,sya;
+      start->GetA(&sxa);
+      start->GetD(&sya);
+
+      float sxb,syb;
+      end->GetA(&sxb);
+      end->GetD(&syb);
+
+      result->SetA(sxa + (sxb - sxa) * aUnitDistance);
+      result->SetD(sya + (syb - sya) * aUnitDistance);
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_ROTATE:
+    {
+      float da;
+      start->GetA(&da);
+      float aa = acos(da);
+
+      float db;
+      end->GetA(&db);
+      float ab = acos(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetA(cos(newa));
+      result->SetB(sin(newa));
+      result->SetC(-sin(newa));
+      result->SetD(cos(newa));
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWX:
+    {
+      float da;
+      start->GetC(&da);
+      float aa = atan(da);
+
+      float db;
+      end->GetC(&db);
+      float ab = atan(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetC(tan(newa));
+    }
+    break;
+
+  case nsIDOMSVGTransform::SVG_TRANSFORM_SKEWY:
+    {
+      float da;
+      start->GetB(&da);
+      float aa = atan(da);
+
+      float db;
+      end->GetB(&db);
+      float ab = atan(db);
+
+      float newa = (aa + (ab - aa) * aUnitDistance);
+      result->SetB(tan(newa));
+    }
+    break;
+
+  default:
+    return NS_ERROR_FAILURE;
+  }
+
+  nsIDOMSVGMatrix *raw_result = result.get();
+  aResult.mType   = this;
+  aResult.mU.mPtr = raw_result;
+  NS_ADDREF(raw_result);
+
+  return NS_OK;
+}
+
+nsresult
+nsSVGTransformSMILType::Repeat(nsSMILValue& aDest,
+                               PRUint32 aCount,
+                               const nsSMILValue* aRepeatValue)
+{
+  NS_ASSERTION(aDest.mType == this, "Unexpected SMIL type.");
+  NS_ASSERTION(!aRepeatValue || aRepeatValue->mType == this,
+      "Unexpected SMIL type for repeat value.");
+
+  nsCOMPtr<nsIDOMSVGMatrix> target =
+    static_cast<nsIDOMSVGMatrix*>(aDest.mU.mPtr);
+  NS_ENSURE_TRUE(target, NS_ERROR_FAILURE);
+
+  nsCOMPtr<nsIDOMSVGMatrix> repeatValue(target);
+
+  if (aRepeatValue) {
+    /*
+     * Casting away const-ness because nsIDOMSVGMatrix::Multiply is non-const
+     * (although it should be const).
+     */
+    repeatValue = (nsIDOMSVGMatrix *)(aRepeatValue->mU.mPtr);
+  }
+
+  // XXX Do matrix multiplication here. nsSVGMatrix::Multiply does an allocation
+  // every time it is called.
+  for (PRUint32 i = 0; i <= aCount; ++i)
+  {
+    nsCOMPtr<nsIDOMSVGMatrix> temp;
+    nsresult rv = target->Multiply(repeatValue, getter_AddRefs(temp));
+    NS_ENSURE_SUCCESS(rv,rv);
+    target = temp;
+  }
+
+  nsIDOMSVGMatrix *dest = static_cast<nsIDOMSVGMatrix*>(aDest.mU.mPtr);
+  NS_RELEASE(dest);
+  /* Even if aDest and target point to the same matrix target will keep it
+   * alive. */
+  nsIDOMSVGMatrix *raw_target = target.get();
+  aDest.mU.mPtr = raw_target;
+  NS_ADDREF(raw_target);
+
+  return NS_OK;
+}
Index: mozilla/svg/content/src/nsSVGTransformSMILType.h
===================================================================
--- /dev/null
+++ mozilla/svg/content/src/nsSVGTransformSMILType.h
@@ -0,0 +1,72 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISMILType.h"
+
+struct nsSMILValue;
+class nsIDOMSVGMatrix;
+
+class nsSVGTransformSMILType : public nsISMILType
+{
+public:
+  virtual void        SetValueIdentity(nsSMILValue& aValue);
+  virtual void        DestroyValue(nsSMILValue&);
+  virtual nsresult    AssignValue(nsSMILValue& aDest,
+                                  const nsSMILValue& aSrc);
+  virtual nsresult    Add(nsSMILValue& aDest, const nsSMILValue& aSrc);
+  virtual nsresult    ComputeDistance(const nsSMILValue& aFrom,
+                                      const nsSMILValue& aTo,
+                                      PRFloat64& aDistance) const;
+  virtual nsresult    Interpolate(const nsSMILValue& aStartVal,
+                                         const nsSMILValue& aEndVal,
+                                         float aUnitDistance,
+                                         nsSMILValue& aResult);
+  virtual nsresult    Repeat(nsSMILValue& aDest,
+                             PRUint32 aCount,
+                             const nsSMILValue* aRepeatValue);
+
+  static nsSVGTransformSMILType sTranslateTransformType;
+  static nsSVGTransformSMILType sScaleTransformType;
+  static nsSVGTransformSMILType sRotateTransformType;
+  static nsSVGTransformSMILType sSkewXTransformType;
+  static nsSVGTransformSMILType sSkewYTransformType;
+
+private:
+  nsSVGTransformSMILType(PRUint16 aType) : mTransformType(aType) {}
+
+  PRUint16                    mTransformType;
+};
Index: mozilla/public/idl/smil/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/public/idl/smil/Makefile.in
@@ -0,0 +1,54 @@
+#!nmake
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla SMIL module.
+#
+# The Initial Developer of the Original Code is Brian Birtles.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+# 	Brian Birtles <birtles@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either of the GNU General Public License Version 2 or later (the "GPL"),
+# or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= dom
+XPIDL_MODULE	= dom_smil
+
+XPIDLSRCS	= \
+		nsIDOMElementTimeControl.idl \
+		$(NULL)
+
+include $(topsrcdir)/config/rules.mk
Index: mozilla/public/idl/smil/nsIDOMElementTimeControl.idl
===================================================================
--- /dev/null
+++ mozilla/public/idl/smil/nsIDOMElementTimeControl.idl
@@ -0,0 +1,59 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGElement.idl"
+
+/*
+ * The definitions of this interface in SMIL Animation and SVG 1.1 differ in the
+ * return type and semantics. Returning a boolean shouldn't present a problem
+ * for anyone expecting the method to have a void return type so we use the SVG
+ * definition of the interface here (boolean return types).
+ */
+
+[scriptable, uuid(276a6678-7844-4d5e-8dfe-938c46089b84)]
+interface nsIDOMElementTimeControl : nsISupports
+{
+  boolean beginElement ( );
+          // raises (nsIDOMDOMException)
+  boolean beginElementAt ( in float offset );
+          // raises (nsIDOMDOMException)
+  boolean endElement ( );
+          // raises (nsIDOMDOMException)
+  boolean endElementAt ( in float offset );
+          // raises (nsIDOMDOMException)
+};
+
Index: mozilla/public/idl/svg/nsIDOMSVGAnimateElement.idl
===================================================================
--- /dev/null
+++ mozilla/public/idl/svg/nsIDOMSVGAnimateElement.idl
@@ -0,0 +1,42 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(0c4297e8-68d0-471d-a933-64132ccc5b97)]
+interface nsIDOMSVGAnimateElement : nsIDOMSVGAnimationElement {};
+
Index: mozilla/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl
===================================================================
--- /dev/null
+++ mozilla/public/idl/svg/nsIDOMSVGAnimateTransformElement.idl
@@ -0,0 +1,42 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(735e0f75-c6aa-4aee-bcd2-46426d6ac90c)]
+interface nsIDOMSVGAnimateTransformElement : nsIDOMSVGAnimationElement {};
+
Index: mozilla/public/idl/svg/nsIDOMSVGAnimationElement.idl
===================================================================
--- /dev/null
+++ mozilla/public/idl/svg/nsIDOMSVGAnimationElement.idl
@@ -0,0 +1,63 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGElement.idl"
+
+[scriptable, uuid(8f2ccf31-5544-4a9d-8927-ef35d242039e)]
+interface nsIDOMSVGAnimationElement
+  : nsIDOMSVGElement
+/*
+        The SVG DOM makes use of multiple interface inheritance.
+        Since XPCOM only supports single interface inheritance,
+        the best thing that we can do is to promise that whenever
+        an object implements _this_ interface it will also
+        implement the following interfaces. (We then have to QI to
+        hop between them.)
+
+    nsIDOMSVGTests,
+    nsIDOMSVGExternalResourcesRequired,
+    smil::nsIDOMElementTimeControl,
+    events::nsIDOMEventTarget
+*/
+{
+  readonly attribute nsIDOMSVGElement targetElement;
+  float getStartTime ( );
+  float getCurrentTime ( );
+  float getSimpleDuration ( );
+          // raises (nsIDOMDOMException)
+};
+
Index: mozilla/public/idl/svg/nsIDOMSVGSetElement.idl
===================================================================
--- /dev/null
+++ mozilla/public/idl/svg/nsIDOMSVGSetElement.idl
@@ -0,0 +1,42 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SVG project.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Chris Double <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIDOMSVGAnimationElement.idl"
+
+[scriptable, uuid(b6c27cdc-4d8b-4343-8ccb-3b68adb1052a)]
+interface nsIDOMSVGSetElement : nsIDOMSVGAnimationElement {};
+
Index: mozilla/base/nsIAnimationController.h
===================================================================
--- /dev/null
+++ mozilla/base/nsIAnimationController.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Mozilla SMIL module.
+ *
+ * The Initial Developer of the Original Code is Brian Birtles.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Brian Birtles <birtles@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef __NS_IANIMATIONCONTROLLER_H__
+#define __NS_IANIMATIONCONTROLLER_H__
+
+#include "nsISupports.h"
+
+////////////////////////////////////////////////////////////////////////
+// nsIAnimationController: Animation controller
+
+// {7aa203ea-e6e1-4cca-84af-a29f0eaedef5}
+#define NS_IANIMATIONCONTROLLER_IID \
+{ 0x7aa203ea, 0xe6e1, 0x4cca, { 0x84, 0xaf, 0xa2, 0x9f, 0x0e, 0xae, 0xde, 0xf5 } }
+
+class nsIAnimationController : public nsISupports
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IANIMATIONCONTROLLER_IID)
+
+  virtual nsresult  Pause()=0;
+  virtual nsresult  Resume()=0;
+  virtual nsresult  Reset()=0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsIAnimationController,
+                              NS_IANIMATIONCONTROLLER_IID)
+
+#endif // __NS_IANIMATIONCONTROLLER_H__
+
Index: mozilla/build/Makefile.in
===================================================================
--- mozilla.orig/build/Makefile.in
+++ mozilla/build/Makefile.in
@@ -53,16 +53,21 @@
 ifeq (WINNT,$(OS_ARCH))
 DIRS = win32
 endif
 
 DIRS += pgo
 
 include $(topsrcdir)/config/rules.mk
 
+ifdef MOZ_SMIL
+SHARED_LIBRARY_LIBS += \
+		$(DEPTH)/content/smil/src/$(LIB_PREFIX)gkconsmil_s.$(LIB_SUFFIX) \
+		$(NULL)
+endif
 
 ifeq ($(USE_SHORT_LIBNAME), 1)
 PROGRAM = $(MOZ_APP_NAME)$(BIN_SUFFIX)
 else
 PROGRAM = $(MOZ_APP_NAME)-bin$(BIN_SUFFIX)
 endif
 
 ifeq ($(MOZ_BUILD_APP),camino)
