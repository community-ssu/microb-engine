Fix media queries calculation of screen size for at least multi-monitor mirroring cases (where test_media_queries fails).  (Bug 156716)

diff --git a/dom/src/base/nsScreen.cpp b/dom/src/base/nsScreen.cpp
--- a/dom/src/base/nsScreen.cpp
+++ b/dom/src/base/nsScreen.cpp
@@ -33,26 +33,23 @@
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nscore.h"
 #include "nsScreen.h"
-#include "nsPIDOMWindow.h"
-#include "nsIBaseWindow.h"
 #include "nsIDocShell.h"
-#include "nsIDocShellTreeItem.h"
 #include "nsIDeviceContext.h"
-#include "nsIWidget.h"
 #include "nsPresContext.h"
 #include "nsCOMPtr.h"
 #include "nsDOMClassInfo.h"
 #include "nsIInterfaceRequestorUtils.h"
+#include "nsLayoutUtils.h"
 
 //
 //  Screen class implementation
 //
 nsScreen::nsScreen(nsIDocShell* aDocShell)
   : mDocShell(aDocShell)
 {
 }
@@ -194,46 +191,17 @@ nsScreen::GetAvailTop(PRInt32* aAvailTop
   *aAvailTop = rect.y;
 
   return rv;
 }
 
 nsIDeviceContext*
 nsScreen::GetDeviceContext()
 {
-  nsCOMPtr<nsIDocShell> docShell = mDocShell;
-  while (docShell) {
-    // Now make sure our size is up to date.  That will mean that the device
-    // context does the right thing on multi-monitor systems when we return it to
-    // the caller.  It will also make sure that our prescontext has been created,
-    // if we're supposed to have one.
-    nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(docShell);
-    if (!win) {
-      // No reason to go on
-      return nsnull;
-    }
-
-    win->EnsureSizeUpToDate();
-
-    nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(docShell);
-    NS_ENSURE_TRUE(baseWindow, nsnull);
-
-    nsCOMPtr<nsIWidget> mainWidget;
-    baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
-    if (mainWidget) {
-      return mainWidget->GetDeviceContext();
-    }
-
-    nsCOMPtr<nsIDocShellTreeItem> curItem = do_QueryInterface(docShell);
-    nsCOMPtr<nsIDocShellTreeItem> parentItem;
-    curItem->GetParent(getter_AddRefs(parentItem));
-    docShell = do_QueryInterface(parentItem);
-  }
-
-  return nsnull;
+  return nsLayoutUtils::GetDeviceContextForScreenInfo(mDocShell);
 }
 
 nsresult
 nsScreen::GetRect(nsRect& aRect)
 {
   nsIDeviceContext *context = GetDeviceContext();
 
   if (!context) {
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -65,16 +65,21 @@
 #include "imgIContainer.h"
 #include "gfxRect.h"
 #include "gfxContext.h"
 #include "gfxFont.h"
 #include "nsIImage.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsCSSRendering.h"
 #include "nsContentUtils.h"
+#include "nsPIDOMWindow.h"
+#include "nsIBaseWindow.h"
+#include "nsIDocShell.h"
+#include "nsIDocShellTreeItem.h"
+#include "nsIWidget.h"
 
 #ifdef MOZ_SVG
 #include "nsSVGUtils.h"
 #endif
 #ifdef MOZ_SVG_FOREIGNOBJECT
 #include "nsSVGForeignObjectFrame.h"
 #include "nsSVGOuterSVGFrame.h"
 #endif
@@ -2724,16 +2729,51 @@ nsLayoutUtils::GetRectDifferenceStrips(c
   *aVStrip = unionRect;
   aVStrip->x += VStripStart;
   aVStrip->width -= VStripStart;
   *aHStrip = unionRect;
   aHStrip->y += HStripStart;
   aHStrip->height -= HStripStart;
 }
 
+nsIDeviceContext*
+nsLayoutUtils::GetDeviceContextForScreenInfo(nsIDocShell* aDocShell)
+{
+  nsCOMPtr<nsIDocShell> docShell = aDocShell;
+  while (docShell) {
+    // Now make sure our size is up to date.  That will mean that the device
+    // context does the right thing on multi-monitor systems when we return it to
+    // the caller.  It will also make sure that our prescontext has been created,
+    // if we're supposed to have one.
+    nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(docShell);
+    if (!win) {
+      // No reason to go on
+      return nsnull;
+    }
+
+    win->EnsureSizeUpToDate();
+
+    nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(docShell);
+    NS_ENSURE_TRUE(baseWindow, nsnull);
+
+    nsCOMPtr<nsIWidget> mainWidget;
+    baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
+    if (mainWidget) {
+      return mainWidget->GetDeviceContext();
+    }
+
+    nsCOMPtr<nsIDocShellTreeItem> curItem = do_QueryInterface(docShell);
+    nsCOMPtr<nsIDocShellTreeItem> parentItem;
+    curItem->GetParent(getter_AddRefs(parentItem));
+    docShell = do_QueryInterface(parentItem);
+  }
+
+  return nsnull;
+}
+
 nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
                                      const nsAString& aValue)
   : mContent(aContent),
     mAttrName(aAttrName),
     mValue(aValue)
 {
   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
 }
diff --git a/layout/base/nsLayoutUtils.h b/layout/base/nsLayoutUtils.h
--- a/layout/base/nsLayoutUtils.h
+++ b/layout/base/nsLayoutUtils.h
@@ -800,16 +800,24 @@ public:
    * the difference between their union and their intersection as two
    * rectangles. (This difference is a superset of the difference
    * between the two rectangles.)
    */
   static void GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
                                       nsRect* aHStrip, nsRect* aVStrip);
 
   /**
+   * Get a device context that can be used to get up-to-date device
+   * dimensions for the given docshell.  For some reason, this is more
+   * complicated than it ought to be in multi-monitor situations.
+   */
+  static nsIDeviceContext*
+  GetDeviceContextForScreenInfo(nsIDocShell* aDocShell);
+
+  /**
    * Indicates if the nsIFrame::GetUsedXXX assertions in nsFrame.cpp should
    * disabled.
    */
 #ifdef DEBUG
   static PRBool sDisableGetUsedXAssertions;
 #endif
 };
 
diff --git a/layout/style/Makefile.in b/layout/style/Makefile.in
--- a/layout/style/Makefile.in
+++ b/layout/style/Makefile.in
@@ -67,16 +67,17 @@ REQUIRES	= xpcom \
 		  webshell \
 		  uconv \
 		  xuldoc \
 		  xpconnect \
 		  view \
 		  intl \
 		  pref \
 		  imglib2 \
+		  docshell \
 		  $(NULL)
 
 EXPORTS		= \
 		nsCSSAnonBoxList.h \
 		nsCSSAnonBoxes.h \
 		nsCSSKeywordList.h \
 		nsCSSKeywords.h \
 		nsCSSPropList.h \
diff --git a/layout/style/nsMediaFeatures.cpp b/layout/style/nsMediaFeatures.cpp
--- a/layout/style/nsMediaFeatures.cpp
+++ b/layout/style/nsMediaFeatures.cpp
@@ -37,16 +37,18 @@
 
 #include "nsMediaFeatures.h"
 #include "nsGkAtoms.h"
 #include "nsCSSKeywords.h"
 #include "nsStyleConsts.h"
 #include "nsPresContext.h"
 #include "nsIDeviceContext.h"
 #include "nsCSSValue.h"
+#include "nsIDocShell.h"
+#include "nsLayoutUtils.h"
 
 static const PRInt32 kOrientationKeywords[] = {
   eCSSKeyword_portrait,                 NS_STYLE_ORIENTATION_PORTRAIT,
   eCSSKeyword_landscape,                NS_STYLE_ORIENTATION_LANDSCAPE,
   eCSSKeyword_UNKNOWN,                  -1
 };
 
 static const PRInt32 kScanKeywords[] = {
@@ -68,35 +70,47 @@ GetHeight(nsPresContext* aPresContext, n
 GetHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
 {
     nscoord height = aPresContext->GetVisibleArea().height;
     float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(height);
     aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
     return NS_OK;
 }
 
+static nsIDeviceContext*
+GetDeviceContextFor(nsPresContext* aPresContext)
+{
+  // Do this dance rather than aPresContext->DeviceContext() to get
+  // things right in multi-monitor situations.
+  // (It's not clear if this is really needed for GetDepth and GetColor,
+  // but do it anyway.)
+  return nsLayoutUtils::GetDeviceContextForScreenInfo(
+    nsCOMPtr<nsIDocShell>(do_QueryInterface(
+      nsCOMPtr<nsISupports>(aPresContext->GetContainer()))));
+}
+
 PR_STATIC_CALLBACK(nsresult)
 GetDeviceWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
 {
     // XXX: I'm not sure if this is really the right thing for print:
     // do we want to include unprintable areas / page margins?
-    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     nscoord width, height;
     dx->GetDeviceSurfaceDimensions(width, height);
     float pixelWidth = aPresContext->AppUnitsToFloatCSSPixels(width);
     aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
     return NS_OK;
 }
 
 PR_STATIC_CALLBACK(nsresult)
 GetDeviceHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
 {
     // XXX: I'm not sure if this is really the right thing for print:
     // do we want to include unprintable areas / page margins?
-    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     nscoord width, height;
     dx->GetDeviceSurfaceDimensions(width, height);
     float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(height);
     aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
     return NS_OK;
 }
 
 PR_STATIC_CALLBACK(nsresult)
@@ -132,17 +146,17 @@ PR_STATIC_CALLBACK(nsresult)
 PR_STATIC_CALLBACK(nsresult)
 GetDeviceAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
 {
     nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
     NS_ENSURE_TRUE(a, NS_ERROR_OUT_OF_MEMORY);
 
     // XXX: I'm not sure if this is really the right thing for print:
     // do we want to include unprintable areas / page margins?
-    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     nscoord width, height;
     dx->GetDeviceSurfaceDimensions(width, height);
     a->Item(0).SetIntValue(width, eCSSUnit_Integer);
     a->Item(1).SetIntValue(height, eCSSUnit_Integer);
 
     aResult.SetArrayValue(a, eCSSUnit_Array);
     return NS_OK;
 }
@@ -150,17 +164,17 @@ GetDeviceAspectRatio(nsPresContext* aPre
 
 PR_STATIC_CALLBACK(nsresult)
 GetColor(nsPresContext* aPresContext, nsCSSValue& aResult)
 {
     // FIXME:  This implementation is bogus.  nsThebesDeviceContext
     // doesn't provide reliable information (should be fixed in bug
     // 424386).
     // FIXME: On a monochrome device, return 0!
-    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     PRUint32 depth;
     dx->GetDepth(depth);
     // Some graphics backends may claim 32-bit depth when it's really 24
     // (because they're counting the Alpha component).
     if (depth == 32) {
         depth = 24;
     }
     // The spec says to use bits *per color component*, so divide by 3,
@@ -194,17 +208,17 @@ GetMonochrome(nsPresContext* aPresContex
     return NS_OK;
 }
 
 PR_STATIC_CALLBACK(nsresult)
 GetResolution(nsPresContext* aPresContext, nsCSSValue& aResult)
 {
     // XXX: The spec isn't clear whether this is CSS pixels or device
     // pixels.  For now, do device pixels.
-    nsIDeviceContext *dx = aPresContext->DeviceContext();
+    nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
     float dpi = float(dx->AppUnitsPerInch()) / float(dx->AppUnitsPerDevPixel());
     aResult.SetFloatValue(dpi, eCSSUnit_Inch);
     return NS_OK;
 }
 
 PR_STATIC_CALLBACK(nsresult)
 GetScan(nsPresContext* aPresContext, nsCSSValue& aResult)
 {
