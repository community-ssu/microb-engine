Implement Media Queries, part 4: infrastructure for dynamic change handling at the pres context level.  (Bug 156716)

Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -15,16 +15,17 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -731,16 +732,17 @@
       vm->GetWindowDimensions(&oldWidthAppUnits, &oldHeightAppUnits);
       float oldWidthDevPixels = oldWidthAppUnits/oldAppUnitsPerDevPixel;
       float oldHeightDevPixels = oldHeightAppUnits/oldAppUnitsPerDevPixel;
 
       nscoord width = NSToCoordRound(oldWidthDevPixels*AppUnitsPerDevPixel());
       nscoord height = NSToCoordRound(oldHeightDevPixels*AppUnitsPerDevPixel());
       vm->SetWindowDimensions(width, height);
 
+      MediaFeatureValuesChanged();
       RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
     }
     return;
   }
   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("font."))) {
     // Changes to font family preferences don't change anything in the
     // computed style data, so the style system won't generate a reflow
     // hint for us.  We need to do that manually.
@@ -1169,16 +1171,17 @@
   mFullZoom = aZoom;
   if (nsContentUtils::GetBoolPref("layout.full.zoom.mode.fast", PR_TRUE)) {
     mShell->FrameNeedsReflow(mShell->GetRootFrame(), nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
 		mShell->ResizeReflow(NSToCoordRound(oldWidthDevPixels*AppUnitsPerDevPixel()),
 												 NSToCoordRound(oldHeightDevPixels*AppUnitsPerDevPixel()));
   } else {
     GetViewManager()->SetWindowDimensions(NSToCoordRound(oldWidthDevPixels * AppUnitsPerDevPixel()),
                                           NSToCoordRound(oldHeightDevPixels * AppUnitsPerDevPixel()));
+		MediaFeatureValuesChanged();
     RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
 	}
 
   mSupressResizeReflow = PR_FALSE;
 
   mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 }
 
@@ -1430,16 +1433,49 @@
   if (!mShell) {
     // We must have been torn down. Nothing to do here.
     return;
   }
   mShell->FrameConstructor()->PostRebuildAllStyleDataEvent();
 }
 
 void
+nsPresContext::MediaFeatureValuesChanged(PRBool aCallerWillRebuildStyleData)
+{
+  mPendingMediaFeatureValuesChanged = PR_FALSE;
+  if (mShell->StyleSet()->MediumFeaturesChanged(this) &&
+      !aCallerWillRebuildStyleData) {
+    RebuildAllStyleData(nsChangeHint(0));
+  }
+}
+
+void
+nsPresContext::PostMediaFeatureValuesChangedEvent()
+{
+  if (!mPendingMediaFeatureValuesChanged) {
+    nsCOMPtr<nsIRunnable> ev =
+      new nsRunnableMethod<nsPresContext>(this,
+                         &nsPresContext::HandleMediaFeatureValuesChangedEvent);
+    if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
+      mPendingMediaFeatureValuesChanged = PR_TRUE;
+    }
+  }
+}
+
+void
+nsPresContext::HandleMediaFeatureValuesChangedEvent()
+{
+  // Null-check mShell in case the shell has been destroyed (and the
+  // event is the only thing holding the pres context alive).
+  if (mPendingMediaFeatureValuesChanged && mShell) {
+    MediaFeatureValuesChanged();
+  }
+}
+
+void
 nsPresContext::SetPaginatedScrolling(PRBool aPaginated)
 {
   if (mType == eContext_PrintPreview || mType == eContext_PageLayout)
     mCanPaginatedScroll = aPaginated;
 }
 
 void
 nsPresContext::SetPrintSettings(nsIPrintSettings *aPrintSettings)
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -15,16 +15,17 @@
  * The Original Code is mozilla.org code.
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 1998
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
+ *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either of the GNU General Public License Version 2 or later (the "GPL"),
  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -204,16 +205,22 @@
 
   nsFrameManager* FrameManager()
     { return GetPresShell()->FrameManager(); } 
 #endif
 
   void RebuildAllStyleData(nsChangeHint aExtraHint);
   void PostRebuildAllStyleDataEvent();
 
+  void MediaFeatureValuesChanged(PRBool aCallerWillRebuildStyleData = PR_FALSE);
+  void PostMediaFeatureValuesChangedEvent();
+  NS_HIDDEN_(void) HandleMediaFeatureValuesChangedEvent();
+  void FlushPendingMediaFeatureValuesChanged()
+    { if (mPendingMediaFeatureValuesChanged) MediaFeatureValuesChanged(); }
+
   /**
    * Access compatibility mode for this context.  This is the same as
    * our document's compatibility mode.
    */
   nsCompatibility CompatibilityMode() const {
     return Document()->GetCompatibilityMode();
   }
   /**
@@ -402,17 +409,20 @@
    * nscoord units (as scaled by the device context).
    */
   nsRect GetVisibleArea() { return mVisibleArea; }
 
   /**
    * Set the currently visible area. The units for r are standard
    * nscoord units (as scaled by the device context).
    */
-  void SetVisibleArea(const nsRect& r) { mVisibleArea = r; }
+  void SetVisibleArea(const nsRect& r) {
+    mVisibleArea = r;
+    PostMediaFeatureValuesChangedEvent();
+  }
 
   /**
    * Return true if this presentation context is a paginated
    * context.
    */
   PRBool IsPaginated() const { return mPaginated; }
   
   PRBool GetRenderedPositionVaryingContent() const { return mRenderedPositionVaryingContent; }
@@ -865,16 +875,17 @@
   unsigned              mCanPaginatedScroll : 1;
   unsigned              mDoScaledTwips : 1;
   unsigned              mEnableJapaneseTransform : 1;
   unsigned              mIsRootPaginatedDocument : 1;
   unsigned              mPrefBidiDirection : 1;
   unsigned              mPrefScrollbarSide : 2;
   unsigned              mPendingSysColorChanged : 1;
   unsigned              mPendingThemeChanged : 1;
+  unsigned              mPendingMediaFeatureValuesChanged : 1;
   unsigned              mPrefChangePendingNeedsReflow : 1;
   unsigned              mRenderedPositionVaryingContent : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
 
 #ifdef IBMBIDI
Index: mozilla/layout/base/nsPresShell.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresShell.cpp
+++ mozilla/layout/base/nsPresShell.cpp
@@ -4548,16 +4548,18 @@
     // queued up while our event was pending.  That will ensure that we don't
     // construct frames for content right now that's still waiting to be
     // notified on,
     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 
     // Process pending restyles, since any flush of the presshell wants
     // up-to-date style data.
     if (!mIsDestroying) {
+      mPresContext->FlushPendingMediaFeatureValuesChanged();
+
       mFrameConstructor->ProcessPendingRestyles();
     }
 
     // Process whatever XBL constructors those restyles queued up.  This
     // ensures that onload doesn't fire too early and that we won't do extra
     // reflows after those constructors run.
     if (!mIsDestroying) {
       mDocument->BindingManager()->ProcessAttachedQueue();
