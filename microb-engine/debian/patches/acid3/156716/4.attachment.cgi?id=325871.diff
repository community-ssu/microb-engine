Implement Media Queries, part 2: infrastructure for dynamic change handling at the rule cascade and style sheet level.  (Bug 156716)

diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -75,16 +75,17 @@
 #include "nsQuickSort.h"
 #include "nsAttrValue.h"
 #include "nsAttrName.h"
 #include "nsILookAndFeel.h"
 #include "nsWidgetsCID.h"
 #include "nsServiceManagerUtils.h"
 #include "nsTArray.h"
 #include "nsContentUtils.h"
+#include "nsIMediaList.h"
 
 static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
 static nsTArray< nsCOMPtr<nsIAtom> >* sSystemMetrics = 0;
 
 struct RuleValue {
   /**
    * |RuleValue|s are constructed before they become part of the
    * |RuleHash|, to act as rule/selector pairs.  |Add| is called when
@@ -678,17 +679,17 @@ static const PLDHashTableOps AttributeSe
 
 
 //--------------------------------
 
 struct RuleCascadeData {
   RuleCascadeData(nsIAtom *aMedium, PRBool aQuirksMode)
     : mRuleHash(aQuirksMode),
       mStateSelectors(),
-      mMedium(aMedium),
+      mCacheKey(aMedium),
       mNext(nsnull)
   {
     PL_DHashTableInit(&mAttributeSelectors, &AttributeSelectorOps, nsnull,
                       sizeof(AttributeSelectorEntry), 16);
   }
 
   ~RuleCascadeData()
   {
@@ -699,17 +700,17 @@ struct RuleCascadeData {
   nsVoidArray       mClassSelectors;
   nsVoidArray       mIDSelectors;
   PLDHashTable      mAttributeSelectors; // nsIAtom* -> nsVoidArray*
 
   // Looks up or creates the appropriate list in |mAttributeSelectors|.
   // Returns null only on allocation failure.
   nsVoidArray* AttributeListFor(nsIAtom* aAttribute);
 
-  nsCOMPtr<nsIAtom> mMedium;
+  nsMediaQueryResultCacheKey mCacheKey;
   RuleCascadeData*  mNext; // for a different medium
 };
 
 nsVoidArray*
 RuleCascadeData::AttributeListFor(nsIAtom* aAttribute)
 {
   AttributeSelectorEntry *entry = static_cast<AttributeSelectorEntry*>
                                              (PL_DHashTableOperate(&mAttributeSelectors, aAttribute, PL_DHASH_ADD));
@@ -2188,32 +2189,36 @@ static PLDHashTableOps gRulesByWeightOps
     MatchWeightEntry,
     PL_DHashMoveEntryStub,
     PL_DHashClearEntryStub,
     PL_DHashFinalizeStub,
     NULL
 };
 
 struct CascadeEnumData {
-  CascadeEnumData(nsPresContext* aPresContext, PLArenaPool& aArena)
+  CascadeEnumData(nsPresContext* aPresContext,
+                  nsMediaQueryResultCacheKey& aKey,
+                  PLArenaPool& aArena)
     : mPresContext(aPresContext),
+      mCacheKey(aKey),
       mArena(aArena)
   {
     if (!PL_DHashTableInit(&mRulesByWeight, &gRulesByWeightOps, nsnull,
                           sizeof(RuleByWeightEntry), 64))
       mRulesByWeight.ops = nsnull;
   }
 
   ~CascadeEnumData()
   {
     if (mRulesByWeight.ops)
       PL_DHashTableFinish(&mRulesByWeight);
   }
 
   nsPresContext* mPresContext;
+  nsMediaQueryResultCacheKey& mCacheKey;
   // Hooray, a manual PLDHashTable since nsClassHashtable doesn't
   // provide a getter that gives me a *reference* to the value.
   PLDHashTable mRulesByWeight; // of RuleValue* linked lists (?)
   PLArenaPool& mArena;
 };
 
 static PRBool
 InsertRuleByWeight(nsICSSRule* aRule, void* aData)
@@ -2239,33 +2244,34 @@ InsertRuleByWeight(nsICSSRule* aRule, vo
       // entry->data.mRules must be in backwards order.
       info->mNext = entry->data.mRules;
       entry->data.mRules = info;
     }
   }
   else if (nsICSSRule::MEDIA_RULE == type ||
            nsICSSRule::DOCUMENT_RULE == type) {
     nsICSSGroupRule* groupRule = (nsICSSGroupRule*)aRule;
-    if (groupRule->UseForPresentation(data->mPresContext))
+    if (groupRule->UseForPresentation(data->mPresContext, data->mCacheKey))
       if (!groupRule->EnumerateRulesForwards(InsertRuleByWeight, aData))
         return PR_FALSE;
   }
   return PR_TRUE;
 }
 
 
 static PRBool
 CascadeSheetRulesInto(nsICSSStyleSheet* aSheet, void* aData)
 {
   nsCSSStyleSheet*  sheet = static_cast<nsCSSStyleSheet*>(aSheet);
   CascadeEnumData* data = static_cast<CascadeEnumData*>(aData);
   PRBool bSheetApplicable = PR_TRUE;
   sheet->GetApplicable(bSheetApplicable);
 
-  if (bSheetApplicable && sheet->UseForMedium(data->mPresContext)) {
+  if (bSheetApplicable &&
+      sheet->UseForPresentation(data->mPresContext, data->mCacheKey)) {
     nsCSSStyleSheet* child = sheet->mFirstChild;
     while (child) {
       CascadeSheetRulesInto(child, data);
       child = child->mNext;
     }
 
     if (sheet->mInner) {
       if (!sheet->mInner->mOrderedRules.EnumerateForwards(InsertRuleByWeight, data))
@@ -2311,33 +2317,31 @@ nsCSSRuleProcessor::GetRuleCascade(nsPre
 nsCSSRuleProcessor::GetRuleCascade(nsPresContext* aPresContext)
 {
   // Having RuleCascadeData objects be per-medium works for now since
   // nsCSSRuleProcessor objects are per-document.  (For a given set
   // of stylesheets they can vary based on medium (@media) or document
   // (@-moz-document).)  Things will get a little more complicated if
   // we implement media queries, though.
 
-  // FIXME: per-medium caching is now invalid; fix using boundary
-  // conditions per feature
   RuleCascadeData **cascadep = &mRuleCascades;
   RuleCascadeData *cascade;
-  nsIAtom *medium = aPresContext->Medium();
   while ((cascade = *cascadep)) {
-    if (cascade->mMedium == medium)
+    if (cascade->mCacheKey.Matches(aPresContext))
       return cascade;
     cascadep = &cascade->mNext;
   }
 
   if (mSheets.Count() != 0) {
     nsAutoPtr<RuleCascadeData> newCascade(
-      new RuleCascadeData(medium,
+      new RuleCascadeData(aPresContext->Medium(),
                           eCompatibility_NavQuirks == aPresContext->CompatibilityMode()));
     if (newCascade) {
-      CascadeEnumData data(aPresContext, newCascade->mRuleHash.Arena());
+      CascadeEnumData data(aPresContext, newCascade->mCacheKey,
+                           newCascade->mRuleHash.Arena());
       if (!data.mRulesByWeight.ops)
         return nsnull;
       if (!mSheets.EnumerateForwards(CascadeSheetRulesInto, &data))
         return nsnull;
 
       // Sort the hash table of per-weight linked lists by weight.
       PRUint32 weightCount = data.mRulesByWeight.entryCount;
       nsAutoArrayPtr<PerWeightData> weightArray(new PerWeightData[weightCount]);
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -1031,20 +1031,21 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsCSSMediaRule::DeleteRule(PRUint32 aIndex)
 {
   return nsCSSGroupRule::DeleteRule(aIndex);
 }
 
 // nsICSSGroupRule interface
 NS_IMETHODIMP_(PRBool)
-nsCSSMediaRule::UseForPresentation(nsPresContext* aPresContext)
+nsCSSMediaRule::UseForPresentation(nsPresContext* aPresContext,
+                                   nsMediaQueryResultCacheKey& aKey)
 {
   if (mMedia) {
-    return mMedia->Matches(aPresContext);
+    return mMedia->Matches(aPresContext, aKey);
   }
   return PR_TRUE;
 }
 
 
 nsCSSDocumentRule::nsCSSDocumentRule(void)
 {
 }
@@ -1191,17 +1192,18 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsCSSDocumentRule::DeleteRule(PRUint32 aIndex)
 {
   return nsCSSGroupRule::DeleteRule(aIndex);
 }
 
 // nsICSSGroupRule interface
 NS_IMETHODIMP_(PRBool)
-nsCSSDocumentRule::UseForPresentation(nsPresContext* aPresContext)
+nsCSSDocumentRule::UseForPresentation(nsPresContext* aPresContext,
+                                      nsMediaQueryResultCacheKey& aKey)
 {
   nsIURI *docURI = aPresContext->Document()->GetDocumentURI();
   nsCAutoString docURISpec;
   if (docURI)
     docURI->GetSpec(docURISpec);
 
   for (URL *url = mURLs; url; url = url->next) {
     switch (url->func) {
diff --git a/layout/style/nsCSSRules.h b/layout/style/nsCSSRules.h
--- a/layout/style/nsCSSRules.h
+++ b/layout/style/nsCSSRules.h
@@ -130,17 +130,18 @@ public:
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
 
   // nsIDOMCSSMediaRule interface
   NS_DECL_NSIDOMCSSMEDIARULE
 
   // rest of nsICSSGroupRule interface
-  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext);
+  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext,
+                                         nsMediaQueryResultCacheKey& aKey);
 
   // @media rule methods
   nsresult SetMedia(nsMediaList* aMedia);
   
 protected:
   nsCOMPtr<nsMediaList> mMedia;
 };
 
@@ -165,17 +166,18 @@ public:
 
   // nsIDOMCSSRule interface
   NS_DECL_NSIDOMCSSRULE
 
   // nsIDOMCSSMozDocumentRule interface
   NS_DECL_NSIDOMCSSMOZDOCUMENTRULE
 
   // rest of nsICSSGroupRule interface
-  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext);
+  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext,
+                                         nsMediaQueryResultCacheKey& aKey);
 
   enum Function {
     eURL,
     eURLPrefix,
     eDomain
   };
 
   struct URL {
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -160,16 +160,17 @@ CSSRuleListImpl::Item(PRUint32 aIndex, n
         result = NS_OK; // per spec: "Return Value ... null if ... not a valid index."
       }
     }
   }
   
   return result;
 }
 
+
 template <class Numeric>
 PRInt32 DoCompare(Numeric a, Numeric b)
 {
   if (a == b)
     return 0;
   if (a < b)
     return -1;
   return 1;
@@ -281,16 +282,65 @@ nsMediaExpression::Matches(nsPresContext
     case nsMediaExpression::eEqual:
       return cmp == 0;
   }
   NS_NOTREACHED("unexpected mRange");
   return PR_FALSE;
 }
 
 void
+nsMediaQueryResultCacheKey::AddExpression(const nsMediaExpression* aExpression,
+                                          PRBool aExpressionMatches)
+{
+  const nsMediaFeature *feature = aExpression->mFeature;
+  FeatureEntry *entry = nsnull;
+  for (PRUint32 i = 0; i < mFeatureCache.Length(); ++i) {
+    if (mFeatureCache[i].mFeature == feature) {
+      entry = &mFeatureCache[i];
+      break;
+    }
+  }
+  if (!entry) {
+    entry = mFeatureCache.AppendElement();
+    if (!entry) {
+      return; /* out of memory */
+    }
+    entry->mFeature = feature;
+  }
+
+  ExpressionEntry eentry = { aExpression, aExpressionMatches };
+  entry->mExpressions.AppendElement(eentry);
+}
+
+PRBool
+nsMediaQueryResultCacheKey::Matches(nsPresContext* aPresContext) const
+{
+  if (aPresContext->Medium() != mMedium) {
+    return PR_FALSE;
+  }
+
+  for (PRUint32 i = 0; i < mFeatureCache.Length(); ++i) {
+    const FeatureEntry *entry = &mFeatureCache[i];
+    nsCSSValue actual;
+    nsresult rv = (entry->mFeature->mGetter)(aPresContext, actual);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE); // any better ideas?
+
+    for (PRUint32 j = 0; j < entry->mExpressions.Length(); ++j) {
+      const ExpressionEntry &eentry = entry->mExpressions[j];
+      if (eentry.mExpression->Matches(aPresContext, actual) !=
+          eentry.mExpressionMatches) {
+        return PR_FALSE;
+      }
+    }
+  }
+
+  return PR_TRUE;
+}
+
+void
 nsMediaQuery::AppendToString(nsAString& aString) const
 {
   nsAutoString buffer;
 
   NS_ASSERTION(!mNegated || !mHasOnly, "can't have not and only");
   NS_ASSERTION(!mTypeOmitted || (!mNegated && !mHasOnly),
                "can't have not or only when type is omitted");
   if (!mTypeOmitted) {
@@ -392,30 +442,33 @@ nsMediaQuery::Clone() const
   nsAutoPtr<nsMediaQuery> result(new nsMediaQuery(*this));
   NS_ENSURE_TRUE(result &&
                    result->mExpressions.Length() == mExpressions.Length(),
                  nsnull);
   return result.forget();
 }
 
 PRBool
-nsMediaQuery::Matches(nsPresContext* aPresContext) const
+nsMediaQuery::Matches(nsPresContext* aPresContext,
+                      nsMediaQueryResultCacheKey& aKey) const
 {
   if (mHadUnknownExpression)
     return mNegated; // FIXME: Editor's draft says PR_FALSE, but that
                      // disagrees with Acid3 and is likely to change.
 
   PRBool match =
     mMediaType == aPresContext->Medium() || mMediaType == nsGkAtoms::all;
   for (PRUint32 i = 0, i_end = mExpressions.Length(); match && i < i_end; ++i) {
     const nsMediaExpression &expr = mExpressions[i];
     nsCSSValue actual;
     nsresult rv = (expr.mFeature->mGetter)(aPresContext, actual);
     NS_ENSURE_SUCCESS(rv, PR_FALSE); // any better ideas?
+
     match = expr.Matches(aPresContext, actual);
+    aKey.AddExpression(&expr, match);
   }
 
   return match == !mNegated;
 }
 
 NS_INTERFACE_MAP_BEGIN(nsMediaList)
   NS_INTERFACE_MAP_ENTRY(nsIDOMMediaList)
   NS_INTERFACE_MAP_ENTRY(nsISupports)
@@ -473,20 +526,21 @@ nsMediaList::SetText(const nsAString& aM
     htmlMode = !!node;
   }
 
   return parser->ParseMediaList(nsString(aMediaText), nsnull, 0,
                                 this, htmlMode);
 }
 
 PRBool
-nsMediaList::Matches(nsPresContext* aPresContext)
+nsMediaList::Matches(nsPresContext* aPresContext,
+                     nsMediaQueryResultCacheKey& aKey)
 {
   for (PRInt32 i = 0, i_end = mArray.Length(); i < i_end; ++i) {
-    if (mArray[i]->Matches(aPresContext)) {
+    if (mArray[i]->Matches(aPresContext, aKey)) {
       return PR_TRUE;
     }
   }
   return mIsEmpty;
 }
 
 nsresult
 nsMediaList::SetStyleSheet(nsICSSStyleSheet *aSheet)
@@ -1100,21 +1154,22 @@ nsCSSStyleSheet::SetTitle(const nsAStrin
 
 NS_IMETHODIMP
 nsCSSStyleSheet::GetType(nsString& aType) const
 {
   aType.AssignLiteral("text/css");
   return NS_OK;
 }
 
-NS_IMETHODIMP_(PRBool)
-nsCSSStyleSheet::UseForMedium(nsPresContext* aPresContext) const
+PRBool
+nsCSSStyleSheet::UseForPresentation(nsPresContext* aPresContext,
+                                    nsMediaQueryResultCacheKey& aKey) const
 {
   if (mMedia) {
-    return mMedia->Matches(aPresContext);
+    return mMedia->Matches(aPresContext, aKey);
   }
   return PR_TRUE;
 }
 
 
 NS_IMETHODIMP
 nsCSSStyleSheet::SetMedia(nsMediaList* aMedia)
 {
diff --git a/layout/style/nsCSSStyleSheet.h b/layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h
+++ b/layout/style/nsCSSStyleSheet.h
@@ -50,16 +50,17 @@
 #include "nsICSSStyleSheet.h"
 #include "nsIDOMCSSStyleSheet.h"
 #include "nsICSSLoaderObserver.h"
 #include "nsVoidArray.h"
 #include "nsCOMArray.h"
 
 class nsIURI;
 class nsMediaList;
+class nsMediaQueryResultCacheKey;
 
 // -------------------------------
 // CSS Style Sheet Inner Data Container
 //
 
 class nsCSSStyleSheetInner {
 public:
   nsCSSStyleSheetInner(nsICSSStyleSheet* aParentSheet);
@@ -104,17 +105,16 @@ public:
 
   NS_DECL_ISUPPORTS
 
   // nsIStyleSheet interface
   NS_IMETHOD GetSheetURI(nsIURI** aSheetURI) const;
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURI) const;
   NS_IMETHOD GetTitle(nsString& aTitle) const;
   NS_IMETHOD GetType(nsString& aType) const;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const;
   NS_IMETHOD_(PRBool) HasRules() const;
   NS_IMETHOD GetApplicable(PRBool& aApplicable) const;
   NS_IMETHOD SetEnabled(PRBool aEnabled);
   NS_IMETHOD GetComplete(PRBool& aComplete) const;
   NS_IMETHOD SetComplete();
   NS_IMETHOD GetParentSheet(nsIStyleSheet*& aParent) const;  // may be null
   NS_IMETHOD GetOwningDocument(nsIDocument*& aDocument) const;  // may be null
   NS_IMETHOD SetOwningDocument(nsIDocument* aDocument);
@@ -159,16 +159,19 @@ public:
   NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
                                 PRUint32 aIndex, PRUint32* aReturn);  
 
   // nsICSSLoaderObserver interface
   NS_IMETHOD StyleSheetLoaded(nsICSSStyleSheet* aSheet, PRBool aWasAlternate,
                               nsresult aStatus);
   
   nsresult EnsureUniqueInner();
+
+  PRBool UseForPresentation(nsPresContext* aPresContext,
+                            nsMediaQueryResultCacheKey& aKey) const;
 
   // nsIDOMStyleSheet interface
   NS_DECL_NSIDOMSTYLESHEET
 
   // nsIDOMCSSStyleSheet interface
   NS_DECL_NSIDOMCSSSTYLESHEET
 
 private:
diff --git a/layout/style/nsHTMLCSSStyleSheet.cpp b/layout/style/nsHTMLCSSStyleSheet.cpp
--- a/layout/style/nsHTMLCSSStyleSheet.cpp
+++ b/layout/style/nsHTMLCSSStyleSheet.cpp
@@ -337,17 +337,16 @@ public:
 
   // basic style sheet data
   NS_IMETHOD Init(nsIURI* aURL, nsIDocument* aDocument);
   NS_IMETHOD Reset(nsIURI* aURL);
   NS_IMETHOD GetSheetURI(nsIURI** aSheetURL) const;
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURL) const;
   NS_IMETHOD GetTitle(nsString& aTitle) const;
   NS_IMETHOD GetType(nsString& aType) const;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const;
   NS_IMETHOD_(PRBool) HasRules() const;
 
   NS_IMETHOD GetApplicable(PRBool& aApplicable) const;
   
   NS_IMETHOD SetEnabled(PRBool aEnabled);
 
   NS_IMETHOD GetComplete(PRBool& aComplete) const;
   NS_IMETHOD SetComplete();
@@ -530,22 +529,16 @@ HTMLCSSStyleSheetImpl::GetTitle(nsString
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HTMLCSSStyleSheetImpl::GetType(nsString& aType) const
 {
   aType.AssignLiteral("text/html");
   return NS_OK;
-}
-
-NS_IMETHODIMP_(PRBool)
-HTMLCSSStyleSheetImpl::UseForMedium(nsPresContext* aPresContext) const
-{
-  return PR_TRUE; // works for all media
 }
 
 NS_IMETHODIMP_(PRBool)
 HTMLCSSStyleSheetImpl::HasRules() const
 {
   return PR_TRUE;  // We always have rules, since mFirstLineRule and
                    // mFirstLetterRule are created on request.
 }
diff --git a/layout/style/nsHTMLStyleSheet.cpp b/layout/style/nsHTMLStyleSheet.cpp
--- a/layout/style/nsHTMLStyleSheet.cpp
+++ b/layout/style/nsHTMLStyleSheet.cpp
@@ -604,22 +604,16 @@ NS_IMETHODIMP
 NS_IMETHODIMP
 nsHTMLStyleSheet::GetType(nsString& aType) const
 {
   aType.AssignLiteral("text/html");
   return NS_OK;
 }
 
 NS_IMETHODIMP_(PRBool)
-nsHTMLStyleSheet::UseForMedium(nsPresContext* aPresContext) const
-{
-  return PR_TRUE; // works for all media
-}
-
-NS_IMETHODIMP_(PRBool)
 nsHTMLStyleSheet::HasRules() const
 {
   return PR_TRUE; // We have rules at all reasonable times
 }
 
 NS_IMETHODIMP
 nsHTMLStyleSheet::GetApplicable(PRBool& aApplicable) const
 {
diff --git a/layout/style/nsHTMLStyleSheet.h b/layout/style/nsHTMLStyleSheet.h
--- a/layout/style/nsHTMLStyleSheet.h
+++ b/layout/style/nsHTMLStyleSheet.h
@@ -59,17 +59,16 @@ public:
 
   NS_DECL_ISUPPORTS
 
   // nsIStyleSheet api
   NS_IMETHOD GetSheetURI(nsIURI** aSheetURL) const;
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURL) const;
   NS_IMETHOD GetTitle(nsString& aTitle) const;
   NS_IMETHOD GetType(nsString& aType) const;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const;
   NS_IMETHOD_(PRBool) HasRules() const;
   NS_IMETHOD GetApplicable(PRBool& aApplicable) const;
   NS_IMETHOD SetEnabled(PRBool aEnabled);
   NS_IMETHOD GetComplete(PRBool& aComplete) const;
   NS_IMETHOD SetComplete();
   NS_IMETHOD GetParentSheet(nsIStyleSheet*& aParent) const;  // will be null
   NS_IMETHOD GetOwningDocument(nsIDocument*& aDocument) const;
   NS_IMETHOD SetOwningDocument(nsIDocument* aDocumemt);
diff --git a/layout/style/nsICSSGroupRule.h b/layout/style/nsICSSGroupRule.h
--- a/layout/style/nsICSSGroupRule.h
+++ b/layout/style/nsICSSGroupRule.h
@@ -43,16 +43,17 @@
 #ifndef nsICSSGroupRule_h___
 #define nsICSSGroupRule_h___
 
 #include "nsICSSRule.h"
 #include "nsCOMArray.h"
 
 class nsIAtom;
 class nsPresContext;
+class nsMediaQueryResultCacheKey;
 
 // IID for the nsICSSGroupRule interface {67b8492e-6d8d-43a5-8037-71eb269f24fe}
 #define NS_ICSS_GROUP_RULE_IID     \
 {0x67b8492e, 0x6d8d, 0x43a5, {0x80, 0x37, 0x71, 0xeb, 0x26, 0x9f, 0x24, 0xfe}}
 
 class nsICSSGroupRule : public nsICSSRule {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICSS_GROUP_RULE_IID)
@@ -70,15 +71,16 @@ public:
    * called WillDirty() on the parent stylesheet.  After they are
    * called, DidDirty() needs to be called on the sheet.
    */
   NS_IMETHOD  DeleteStyleRuleAt(PRUint32 aIndex) = 0;
   NS_IMETHOD  InsertStyleRulesAt(PRUint32 aIndex,
                                  nsCOMArray<nsICSSRule>& aRules) = 0;
   NS_IMETHOD  ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew) = 0;
 
-  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext) = 0;
+  NS_IMETHOD_(PRBool) UseForPresentation(nsPresContext* aPresContext,
+                                         nsMediaQueryResultCacheKey& aKey) = 0;
    
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsICSSGroupRule, NS_ICSS_GROUP_RULE_IID)
 
 #endif /* nsICSSGroupRule_h___ */
diff --git a/layout/style/nsIMediaList.h b/layout/style/nsIMediaList.h
--- a/layout/style/nsIMediaList.h
+++ b/layout/style/nsIMediaList.h
@@ -43,16 +43,17 @@
  */
 
 #ifndef nsIMediaList_h_
 #define nsIMediaList_h_
 
 #include "nsIDOMMediaList.h"
 #include "nsAString.h"
 #include "nsTArray.h"
+#include "nsTPtrArray.h"
 #include "nsIAtom.h"
 #include "nsMediaFeatures.h"
 #include "nsCSSValue.h"
 
 class nsPresContext;
 class nsICSSStyleSheet;
 class nsCSSStyleSheet;
 
@@ -61,16 +62,57 @@ struct nsMediaExpression {
 
   const nsMediaFeature *mFeature;
   Range mRange;
   nsCSSValue mValue;
 
   // aActualValue must be obtained from mFeature->mGetter
   PRBool Matches(nsPresContext* aPresContext,
                  const nsCSSValue& aActualValue) const;
+};
+
+/**
+ * An nsMediaQueryResultCacheKey records what feature/value combinations
+ * a set of media query results are valid for.  This allows the caller
+ * to quickly learn whether a prior result of media query evaluation is
+ * still valid (e.g., due to a window size change) without rerunning all
+ * of the evaluation and rebuilding the list of rules.
+ *
+ * This object may not be used after any any media rules in any of the
+ * sheets it was given to have been modified.  However, this is
+ * generally not a problem since ClearRuleCascades is called on the
+ * sheet whenever this happens, and these objects are stored inside the
+ * rule cascades.
+ *
+ * The implementation could be further optimized in the future to store
+ * ranges (combinations of less-than, less-than-or-equal, greater-than,
+ * greater-than-or-equal, equal, not-equal, present, not-present) for
+ * each feature rather than simply storing the list of expressions.
+ * However, this requires combining any such ranges.
+ */
+class nsMediaQueryResultCacheKey {
+public:
+  nsMediaQueryResultCacheKey(nsIAtom* aMedium)
+    : mMedium(aMedium)
+  {}
+
+  void AddExpression(const nsMediaExpression* aExpression,
+                     PRBool aExpressionMatches);
+  PRBool Matches(nsPresContext* aPresContext) const;
+private:
+  struct ExpressionEntry {
+    const nsMediaExpression *mExpression;
+    PRBool mExpressionMatches;
+  };
+  struct FeatureEntry {
+    const nsMediaFeature *mFeature;
+    nsTArray<ExpressionEntry> mExpressions;
+  };
+  nsCOMPtr<nsIAtom> mMedium;
+  nsTArray<FeatureEntry> mFeatureCache;
 };
 
 class nsMediaQuery {
 public:
   nsMediaQuery()
     : mNegated(PR_FALSE)
     , mHasOnly(PR_FALSE)
     , mTypeOmitted(PR_FALSE)
@@ -105,17 +147,18 @@ public:
   // Returns null on out-of-memory.
   nsMediaExpression* NewExpression()    { return mExpressions.AppendElement(); }
 
   void AppendToString(nsAString& aString) const;
 
   nsMediaQuery* Clone() const;
 
   // Does this query apply to the presentation?
-  PRBool Matches(nsPresContext* aPresContext) const;
+  PRBool Matches(nsPresContext* aPresContext,
+                 nsMediaQueryResultCacheKey& aKey) const;
 
 private:
   PRPackedBool mNegated;
   PRPackedBool mHasOnly; // only needed for serialization
   PRPackedBool mTypeOmitted; // only needed for serialization
   PRPackedBool mHadUnknownExpression;
   nsCOMPtr<nsIAtom> mMediaType;
   nsTArray<nsMediaExpression> mExpressions;
@@ -126,17 +169,18 @@ public:
   nsMediaList();
 
   NS_DECL_ISUPPORTS
 
   NS_DECL_NSIDOMMEDIALIST
 
   nsresult GetText(nsAString& aMediaText);
   nsresult SetText(const nsAString& aMediaText);
-  PRBool Matches(nsPresContext* aPresContext);
+  PRBool Matches(nsPresContext* aPresContext,
+                 nsMediaQueryResultCacheKey& aKey);
   nsresult SetStyleSheet(nsICSSStyleSheet* aSheet);
   nsresult AppendQuery(nsMediaQuery *aQuery) {
     // Takes ownership of aQuery
     return mArray.AppendElement(aQuery) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
   }
 
   nsresult Clone(nsMediaList** aResult);
 
diff --git a/layout/style/nsIStyleSheet.h b/layout/style/nsIStyleSheet.h
--- a/layout/style/nsIStyleSheet.h
+++ b/layout/style/nsIStyleSheet.h
@@ -73,17 +73,16 @@ public:
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ISTYLE_SHEET_IID)
 
   // basic style sheet data
   NS_IMETHOD GetSheetURI(nsIURI** aSheetURI) const = 0;
   NS_IMETHOD GetBaseURI(nsIURI** aBaseURI) const = 0;
   NS_IMETHOD GetTitle(nsString& aTitle) const = 0;
   NS_IMETHOD GetType(nsString& aType) const = 0;
-  NS_IMETHOD_(PRBool) UseForMedium(nsPresContext* aPresContext) const = 0;
   NS_IMETHOD_(PRBool) HasRules() const = 0;
 
   /**
    * Whether the sheet is applicable.  A sheet that is not applicable
    * should never be inserted into a style set.  A sheet may not be
    * applicable for a variety of reasons including being disabled and
    * being incomplete.
    *
