Index: mozilla/xpcom/base/nsMemoryImpl.cpp
===================================================================
--- mozilla.orig/xpcom/base/nsMemoryImpl.cpp
+++ mozilla/xpcom/base/nsMemoryImpl.cpp
@@ -54,16 +54,17 @@
 
 #if defined(XP_WIN)
 #include <windows.h>
 #define NS_MEMORY_FLUSHER
 #elif defined (NS_OSSO)
 #include <osso-mem.h>
 #include <fcntl.h>
 #include <unistd.h>
+#include <time.h>
 const char* kHighMark = "/sys/kernel/high_watermark";
 #else
 // Need to implement the nsIMemory::IsLowMemory() predicate
 #undef NS_MEMORY_FLUSHER
 #endif
 
 #ifdef NS_MEMORY_FLUSHER
 #include "nsITimer.h"
@@ -187,16 +188,20 @@ nsMemoryImpl::HeapMinimize(PRBool aImmed
  * and after all, 40mb should be good enough for any web app
  * unless it's part of an office suite.
  */
 static const int kRequiredMemory = 0x3000000;
 
 NS_IMETHODIMP
 nsMemoryImpl::IsLowMemory(PRBool *result)
 {
+    if (sLowMemState >= 0) {
+        *result = sLowMemState == 1;
+        return NS_OK;
+    }
 #if defined(WINCE)
     *result = PR_FALSE;
     // See bug 475595 -- this is incorrect right now, and causes a big
     // perf hit since GlobalMemoryStatus has to grab a kernel VM lock
     // and do a bunch of munging through VM pages to get the data
     // that's requested.  We call IsLowMemory in some performance
     // critical code (e.g. during painting), so that's bad.
 #if 0
@@ -206,31 +211,46 @@ nsMemoryImpl::IsLowMemory(PRBool *result
 #endif
 #elif defined(XP_WIN)
     MEMORYSTATUSEX stat;
     stat.dwLength = sizeof stat;
     GlobalMemoryStatusEx(&stat);
     *result = (stat.ullAvailPageFile < kRequiredMemory) &&
         ((float)stat.ullAvailPageFile / stat.ullTotalPageFile) < 0.1;
 #elif defined(NS_OSSO)
+    static time_t sTimeLastCheck = 0;
+    static PRBool sLastLowMemValue = PR_FALSE;
+    time_t newTime = time(0);
+    if (newTime - sTimeLastCheck < 1) {
+      *result = sLastLowMemValue;
+      return NS_OK;
+    }
+    sTimeLastCheck = newTime;
     int fd = open (kHighMark, O_RDONLY);
     if (fd == -1) {
         *result = PR_FALSE;
         return NS_OK;
     }
     int c = 0;
     read (fd, &c, 1);
     close(fd);
-    *result = (c == '1');
+    sLastLowMemValue = (c == '1');
+    *result = sLastLowMemValue;
 #else
     *result = PR_FALSE;
 #endif
     return NS_OK;
 }
 
+NS_IMETHODIMP
+nsMemoryImpl::SetLowMemory(PRInt32 aLowMemState)
+{
+    sLowMemState = aLowMemState;
+    return NS_OK;
+}
 
 /*static*/ nsresult 
 nsMemoryImpl::InitFlusher()
 {
 #ifdef NS_MEMORY_FLUSHER
     return sGlobalMemoryFlusher.Init();
 #else
     return NS_OK;
@@ -297,16 +317,19 @@ NS_IMETHODIMP
 nsMemoryImpl::FlushEvent::Run()
 {
     sGlobalMemory.RunFlushers(mReason);
     return NS_OK;
 }
 
 PRInt32
 nsMemoryImpl::sIsFlushing = 0;
+PRInt32
+nsMemoryImpl::sLowMemState = -1;
+
 
 nsMemoryImpl::FlushEvent
 nsMemoryImpl::sFlushEvent;
 
 XPCOM_API(void*)
 NS_Alloc(PRSize size)
 {
     if (size > PR_INT32_MAX)
Index: mozilla/xpcom/base/nsIMemory.idl
===================================================================
--- mozilla.orig/xpcom/base/nsIMemory.idl
+++ mozilla/xpcom/base/nsIMemory.idl
@@ -121,10 +121,17 @@ interface nsIMemory : nsISupports
     void heapMinimize(in boolean immediate);
 
     /**
      * This predicate can be used to determine if we're in a low-memory
      * situation (what constitutes low-memory is platform dependent). This
      * can be used to trigger the memory pressure observers.
      */
     boolean isLowMemory();
+
+    /**
+     * This can setup lowmemory situation from third party instance
+     * @param isLowMem - enable or disable internal lowmem flag
+     */
+    void setLowMemory(in long lowMemState);
+
 };
 
Index: mozilla/xpcom/base/nsMemoryImpl.h
===================================================================
--- mozilla.orig/xpcom/base/nsMemoryImpl.h
+++ mozilla/xpcom/base/nsMemoryImpl.h
@@ -66,11 +66,13 @@ protected:
     struct FlushEvent : public nsIRunnable {
         NS_DECL_ISUPPORTS_INHERITED
         NS_DECL_NSIRUNNABLE
         const PRUnichar* mReason;
     };
 
     static PRInt32    sIsFlushing;
     static FlushEvent sFlushEvent;
+private:
+    static PRInt32    sLowMemState;
 };
 
 #endif // nsMemoryImpl_h__
Index: mozilla/xpcom/ds/nsRecyclingAllocator.cpp
===================================================================
--- mozilla.orig/xpcom/ds/nsRecyclingAllocator.cpp
+++ mozilla/xpcom/ds/nsRecyclingAllocator.cpp
@@ -323,14 +323,21 @@ nsRecyclingAllocatorImpl::Init(size_t nb
 NS_IMETHODIMP
 nsRecyclingAllocatorImpl::HeapMinimize(PRBool immediate)
 {
     // XXX Not yet implemented
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+nsRecyclingAllocatorImpl::SetLowMemory(PRInt32 aLowMemState)
+{
+    // XXX Not yet implemented
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 nsRecyclingAllocatorImpl::IsLowMemory(PRBool *lowmemoryb_ptr)
 {
     // XXX Not yet implemented
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
Index: mozilla/xpcom/tests/TestPipe.cpp
===================================================================
--- mozilla.orig/xpcom/tests/TestPipe.cpp
+++ mozilla/xpcom/tests/TestPipe.cpp
@@ -174,16 +174,21 @@ NS_IMETHODIMP BackwardsAllocator::HeapMi
 }
 
 NS_IMETHODIMP BackwardsAllocator::IsLowMemory(PRBool* retval)
 {
   *retval = PR_FALSE;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+BackwardsAllocator::SetLowMemory(PRInt32 aLowMemState)
+{
+    return NS_OK;
+}
 
 nsresult TestBackwardsAllocator()
 {
   const PRUint32 SEGMENT_COUNT = 10;
   const PRUint32 SEGMENT_SIZE = 10;
 
   nsRefPtr<BackwardsAllocator> allocator = new BackwardsAllocator();
   if (!allocator)
