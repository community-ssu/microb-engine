--- mozilla/xpcom/base/nsMemoryImpl.cpp.orig	2006-11-22 19:51:59.000000000 +0200
+++ mozilla/xpcom/base/nsMemoryImpl.cpp	2008-02-26 09:07:15.000000000 +0200
@@ -49,10 +49,19 @@
 
 #include "nsAlgorithm.h"
 #include "nsAutoLock.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
+#include <fcntl.h>
+#include <unistd.h>
+
+#ifdef __arm__
+const char *kHighMark = "/sys/kernel/high_watermark";
+//const char *kHighMark = "/sys/kernel/low_watermark";
+#else
+const char *kHighMark = "/tmp/high_mem.link";
+#endif
 
 #if defined(XP_WIN)
 #include <windows.h>
 #define NS_MEMORY_FLUSHER
 #else
@@ -179,24 +187,42 @@ nsMemoryImpl::HeapMinimize(PRBool aImmed
 }
 
 NS_IMETHODIMP
 nsMemoryImpl::IsLowMemory(PRBool *result)
 {
+    if (sLowMemState >= 0) {
+        *result = sLowMemState == 1;
+        return NS_OK;
+    }
 #if defined(WINCE)
     MEMORYSTATUS stat;
     GlobalMemoryStatus(&stat);
     *result = ((float)stat.dwAvailPhys / stat.dwTotalPhys) < 0.1;
 #elif defined(XP_WIN)
     MEMORYSTATUS stat;
     GlobalMemoryStatus(&stat);
     *result = ((float)stat.dwAvailPageFile / stat.dwTotalPageFile) < 0.1;
 #else
-    *result = PR_FALSE;
+    int fd = open (kHighMark, O_RDONLY);
+    if (fd == -1) {
+        *result = PR_FALSE;
+        return NS_OK;
+    }
+    int c = 0;
+    read (fd, &c, 1);
+    close (fd);
+    *result = (c == '1');
 #endif
     return NS_OK;
 }
 
+NS_IMETHODIMP
+nsMemoryImpl::SetLowMemory(PRInt32 aLowMemState)
+{
+    sLowMemState = aLowMemState;
+    return NS_OK;
+}
 
 /*static*/ nsresult 
 nsMemoryImpl::InitFlusher()
 {
 #ifdef NS_MEMORY_FLUSHER
@@ -269,10 +295,13 @@ nsMemoryImpl::FlushEvent::Run()
     return NS_OK;
 }
 
 PRInt32
 nsMemoryImpl::sIsFlushing = 0;
+PRInt32
+nsMemoryImpl::sLowMemState = -1;
+
 
 nsMemoryImpl::FlushEvent
 nsMemoryImpl::sFlushEvent;
 
 XPCOM_API(void*)
--- mozilla/xpcom/base/nsIMemory.idl.orig	2006-11-22 19:51:59.000000000 +0200
+++ mozilla/xpcom/base/nsIMemory.idl	2008-02-26 08:53:34.000000000 +0200
@@ -124,7 +124,14 @@ interface nsIMemory : nsISupports
      * This predicate can be used to determine if we're in a low-memory
      * situation (what constitutes low-memory is platform dependent). This
      * can be used to trigger the memory pressure observers.
      */
     boolean isLowMemory();
+
+    /**
+     * This can setup lowmemory situation from third party instance
+     * @param isLowMem - enable or disable internal lowmem flag
+     */
+    void setLowMemory(in long lowMemState);
+
 };
 
--- mozilla/xpcom/base/nsMemoryImpl.h.orig	2006-11-22 19:51:59.000000000 +0200
+++ mozilla/xpcom/base/nsMemoryImpl.h	2008-02-26 09:05:16.000000000 +0200
@@ -69,8 +69,10 @@ protected:
         const PRUnichar* mReason;
     };
 
     static PRInt32    sIsFlushing;
     static FlushEvent sFlushEvent;
+private:
+    static PRInt32    sLowMemState;
 };
 
 #endif // nsMemoryImpl_h__
--- mozilla/xpcom/ds/nsRecyclingAllocator.cpp.orig	2006-05-10 20:30:09.000000000 +0300
+++ mozilla/xpcom/ds/nsRecyclingAllocator.cpp	2008-02-26 10:36:58.000000000 +0200
@@ -321,16 +321,23 @@ nsRecyclingAllocatorImpl::Init(size_t nb
 }
 
 NS_IMETHODIMP
 nsRecyclingAllocatorImpl::HeapMinimize(PRBool immediate)
 {
     // XXX Not yet implemented
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+nsRecyclingAllocatorImpl::SetLowMemory(PRInt32 aLowMemState)
+{
+    // XXX Not yet implemented
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 nsRecyclingAllocatorImpl::IsLowMemory(PRBool *lowmemoryb_ptr)
 {
     // XXX Not yet implemented
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
