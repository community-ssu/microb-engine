diff -ruN -p -U5 mozilla/modules/libpr0n.orig/decoders/png/nsPNGDecoder.cpp mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
--- mozilla/modules/libpr0n.orig/decoders/png/nsPNGDecoder.cpp	2008-02-21 10:22:24.000000000 +0200
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	2008-02-26 09:32:58.000000000 +0200
@@ -115,10 +115,12 @@ NS_IMETHODIMP nsPNGDecoder::Init(imgILoa
         116,  69,  88, 116, '\0',   /* tEXt */
         116,  73,  77,  69, '\0',   /* tIME */
         122,  84,  88, 116, '\0'};  /* zTXt */
 #endif
 
+  NS_GetMemoryManager(getter_AddRefs(mMem));
+
   mImageLoad = aLoad;
   mObserver = do_QueryInterface(aLoad);  // we're holding 2 strong refs to the request.
 
   /* do png init stuff */
 
@@ -411,10 +413,15 @@ row_callback(png_structp png_ptr, png_by
    * the first pass (and only for interlaced images), you will have
    * to pass the current row, and the function will combine the
    * old row and the new row.
    */
   nsPNGDecoder *decoder = NS_STATIC_CAST(nsPNGDecoder*, png_get_progressive_ptr(png_ptr));
+  PRBool lowMem = PR_FALSE;
+  if (decoder->mMem && NS_SUCCEEDED(decoder->mMem->IsLowMemory(&lowMem)) && lowMem) {
+    decoder->mError = PR_TRUE; end_callback(png_ptr, nsnull);
+    return;
+  }
 
   png_bytep line;
   if (decoder->interlacebuf) {
     line = decoder->interlacebuf+(row_num*decoder->ibpr);
     png_progressive_combine_row(png_ptr, line, new_row);
diff -ruN -p -U5 mozilla/modules/libpr0n.orig/decoders/png/nsPNGDecoder.h mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h
--- mozilla/modules/libpr0n.orig/decoders/png/nsPNGDecoder.h	2008-02-21 10:22:24.000000000 +0200
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h	2008-02-26 09:29:33.000000000 +0200
@@ -81,8 +81,9 @@ public:
   PRUint8 *colorLine, *alphaLine;
 #endif
   PRUint8 *interlacebuf;
   PRUint32 ibpr;
   PRPackedBool mError;
+  nsCOMPtr<nsIMemory> mMem;
 };
 
 #endif // nsPNGDecoder_h__
