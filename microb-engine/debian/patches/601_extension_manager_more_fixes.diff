# Fixes to the extension manager functionality.
Index: mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
===================================================================
--- mozilla.orig/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
+++ mozilla/toolkit/mozapps/extensions/src/nsExtensionManager.js.in
@@ -351,18 +351,16 @@
  *          true if the directory hierarchy specified in |pathArray|
  *          should be created if it does not exist,
  *          false otherwise.
  * @return  nsIFile object for the location specified. 
  */
 function getDirInternal(key, pathArray, shouldCreate) {
   var fileLocator = Components.classes["@mozilla.org/file/directory_service;1"]
                               .getService(Components.interfaces.nsIProperties);
-  if (key == "ProfDS")
-    key = "ProfD";
   var dir = fileLocator.get(key, nsILocalFile);
   for (var i = 0; i < pathArray.length; ++i) {
     dir.append(pathArray[i]);
     if (shouldCreate && !dir.exists())
       dir.create(nsILocalFile.DIRECTORY_TYPE, PERMS_DIRECTORY);
   }
   dir.followLinks = false;
   return dir;
Index: mozilla/toolkit/xre/nsEmbedFunctions.cpp
===================================================================
--- mozilla.orig/toolkit/xre/nsEmbedFunctions.cpp
+++ mozilla/toolkit/xre/nsEmbedFunctions.cpp
@@ -61,21 +61,36 @@
 }
 
 nsresult
 XRE_LockProfileDirectory(nsILocalFile* aDirectory,
                          nsISupports* *aLockObject)
 {
   nsCOMPtr<nsIProfileLock> lock;
 
-  nsresult rv = NS_LockProfilePath(aDirectory, nsnull, nsnull,
+  nsresult rv = NS_LockProfilePath(aDirectory, aDirectory, nsnull,
                                    getter_AddRefs(lock));
-  if (NS_SUCCEEDED(rv))
-    NS_ADDREF(*aLockObject = lock);
 
+  NS_ENSURE_SUCCESS(rv, NS_ERROR_OUT_OF_MEMORY);
+  NS_ADDREF(*aLockObject = lock);
+
+  nsCOMPtr<nsILocalFile> profD;
+  rv = lock->GetDirectory(getter_AddRefs(profD));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsILocalFile> profLD;
+  rv = lock->GetLocalDirectory(getter_AddRefs(profLD));
+  if (NS_FAILED(rv))
+    return rv;
+
+  if (!gDirServiceProvider)
+   new nsXREDirProvider;
+
+  rv = gDirServiceProvider->SetProfile(profD, profLD);
   return rv;
 }
 
 static nsStaticModuleInfo *sCombined;
 static PRInt32 sInitCounter;
 
 nsresult
 XRE_InitEmbedding(nsILocalFile *aLibXULDirectory,
@@ -94,17 +109,18 @@
   if (++sInitCounter > 1) // XXXbsmedberg is this really the right solution?
     return NS_OK;
 
   if (!aAppDirectory)
     aAppDirectory = aLibXULDirectory;
 
   nsresult rv;
 
-  new nsXREDirProvider; // This sets gDirServiceProvider
+  if (!gDirServiceProvider)
+    new nsXREDirProvider; // This sets gDirServiceProvider
   if (!gDirServiceProvider)
     return NS_ERROR_OUT_OF_MEMORY;
 
   rv = gDirServiceProvider->Initialize(aAppDirectory, aLibXULDirectory,
                                        aAppDirProvider);
   if (NS_FAILED(rv))
     return rv;
 
Index: mozilla/xpcom/threads/nsThreadManager.cpp
===================================================================
--- mozilla.orig/xpcom/threads/nsThreadManager.cpp
+++ mozilla/xpcom/threads/nsThreadManager.cpp
@@ -75,17 +75,18 @@
 
 nsresult
 nsThreadManager::Init()
 {
   mLock = PR_NewLock();
   if (!mLock)
     return NS_ERROR_OUT_OF_MEMORY;
 
-  if (!mThreadsByPRThread.Init())
+  if (!mThreadsByPRThread.IsInitialized() &&
+      !mThreadsByPRThread.Init())
     return NS_ERROR_OUT_OF_MEMORY;
 
   if (PR_NewThreadPrivateIndex(&mCurThreadIndex, ReleaseObject) == PR_FAILURE)
     return NS_ERROR_FAILURE;
 
   // Setup "main" thread
   mMainThread = new nsThread();
   if (!mMainThread)
