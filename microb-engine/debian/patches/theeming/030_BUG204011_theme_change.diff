# Added timeout for changing theme
# Listener for style_set signal from GTK widgets, allow to change theme when GTK theme changed
# Bug 393976 -  GTK2 Gecko should support theme change on fly
Index: mozilla/widget/src/gtk2/nsWindow.h
===================================================================
--- mozilla.orig/widget/src/gtk2/nsWindow.h
+++ mozilla/widget/src/gtk2/nsWindow.h
@@ -437,16 +437,18 @@
     gfxASurface       *GetThebesSurface();
 
     static already_AddRefed<gfxASurface> GetSurfaceForGdkDrawable(GdkDrawable* aDrawable,
                                                                   const nsIntSize& aSize);
 
 #ifdef ACCESSIBILITY
     static PRBool      sAccessibilityEnabled;
 #endif
+    guint              mThemeTimeoutSource;
+
 protected:
     nsCOMPtr<nsIWidget> mParent;
     // Is this a toplevel window?
     PRPackedBool        mIsTopLevel;
     // Has this widget been destroyed yet?
     PRPackedBool        mIsDestroyed;
 
     // This is a flag that tracks if we need to resize a widget or
@@ -591,17 +593,16 @@
         *flag |= mask;
     }
 
     void ClearKeyDownFlag(PRUint32 aKeyCode) {
         PRUint32 mask;
         PRUint32* flag = GetFlagWord32(aKeyCode, &mask);
         *flag &= ~mask;
     }
-
 };
 
 class nsChildWindow : public nsWindow {
 public:
     nsChildWindow();
     ~nsChildWindow();
 };
 
Index: mozilla/widget/src/gtk2/nsWindow.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsWindow.cpp
+++ mozilla/widget/src/gtk2/nsWindow.cpp
@@ -270,16 +270,17 @@
 static nsWindow         *gPluginFocusWindow    = NULL;
 
 static nsCOMPtr<nsIRollupListener> gRollupListener;
 static nsWeakPtr                   gRollupWindow;
 static PRBool                      gConsumeRollupEvent;
 
 
 #define NS_WINDOW_TITLE_MAX_LENGTH 4095
+#define GTK_THEME_CHANGE_TIMEOUT 1500
 
 #ifdef USE_XIM
 
 static nsWindow    *gIMEFocusWindow = NULL;
 static GdkEventKey *gKeyEvent = NULL;
 static PRBool       gKeyEventCommitted = PR_FALSE;
 static PRBool       gKeyEventChanged = PR_FALSE;
 static PRBool       gIMESuppressCommit = PR_FALSE;
@@ -374,16 +375,17 @@
     mActivatePending     = PR_FALSE;
     mTransientParent     = nsnull;
     mWindowType          = eWindowType_child;
     mSizeState           = nsSizeMode_Normal;
 #ifdef MOZ_X11
     mOldFocusWindow      = 0;
 #endif /* MOZ_X11 */
     mPluginType          = PluginType_NONE;
+    mThemeTimeoutSource  = 0;
 
     if (!gGlobalsInitialized) {
         gGlobalsInitialized = PR_TRUE;
 
         // It's OK if either of these fail, but it may not be one day.
         initialize_prefs();
     }
 
@@ -657,16 +659,26 @@
         gBufferPixmapSize.width = 0;
         gBufferPixmapSize.height = 0;
     }
 
     g_signal_handlers_disconnect_by_func(gtk_settings_get_default(),
                                          (gpointer)G_CALLBACK(theme_changed_cb),
                                          this);
 
+    if (mContainer)
+        g_signal_handlers_disconnect_by_func(G_OBJECT(mContainer),
+                                             (gpointer)G_CALLBACK(theme_changed_cb),
+                                             this);
+
+    if (mThemeTimeoutSource) {
+        g_source_remove(mThemeTimeoutSource);
+        mThemeTimeoutSource = 0;
+    }
+
     // ungrab if required
     nsCOMPtr<nsIWidget> rollupWidget = do_QueryReferent(gRollupWindow);
     if (static_cast<nsIWidget *>(this) == rollupWidget.get()) {
         if (gRollupListener)
             gRollupListener->Rollup(nsnull);
         gRollupWindow = nsnull;
         gRollupListener = nsnull;
     }
@@ -3936,16 +3948,18 @@
                                "notify::gtk-theme-name",
                                G_CALLBACK(theme_changed_cb), this);
         g_signal_connect_after(default_settings,
                                "notify::gtk-font-name",
                                G_CALLBACK(theme_changed_cb), this);
     }
 
     if (mContainer) {
+        g_signal_connect(G_OBJECT(mContainer), "style_set",
+                         G_CALLBACK(theme_changed_cb), this);
         g_signal_connect_after(G_OBJECT(mContainer), "size_allocate",
                                G_CALLBACK(size_allocate_cb), NULL);
         g_signal_connect(G_OBJECT(mContainer), "expose_event",
                          G_CALLBACK(expose_event_cb), NULL);
         g_signal_connect_after(G_OBJECT(mContainer), "enter_notify_event",
                          G_CALLBACK(enter_notify_event_cb), NULL);
         g_signal_connect_after(G_OBJECT(mContainer), "leave_notify_event",
                          G_CALLBACK(leave_notify_event_cb), NULL);
@@ -5613,22 +5627,35 @@
     if (!window)
         return FALSE;
 
     window->OnWindowStateEvent(widget, event);
 
     return FALSE;
 }
 
+static gboolean
+timeout_theme_change(void *data)
+{
+    nsRefPtr<nsWindow> window = (nsWindow *)data;
+    window->ThemeChanged();
+    return FALSE;
+}
+
 /* static */
 void
 theme_changed_cb (GtkSettings *settings, GParamSpec *pspec, nsWindow *data)
 {
-    nsRefPtr<nsWindow> window = data;
-    window->ThemeChanged();
+    nsRefPtr<nsWindow> window = (nsWindow *)data;
+    if (window->mThemeTimeoutSource) {
+      g_source_remove(window->mThemeTimeoutSource);
+      window->mThemeTimeoutSource = 0;
+    }
+    window->mThemeTimeoutSource =
+        g_timeout_add(GTK_THEME_CHANGE_TIMEOUT, timeout_theme_change, (void*)data);
 }
 
 //////////////////////////////////////////////////////////////////////
 // These are all of our drag and drop operations
 
 void
 nsWindow::InitDragEvent(nsDragEvent &aEvent)
 {
