Index: mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.cpp
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
@@ -70,20 +70,19 @@
 #define NSRECT_TO_GDKRECT(ns,gdk) \
   PR_BEGIN_MACRO \
   gdk.x = ns.x; \
   gdk.y = ns.y; \
   gdk.width = ns.width; \
   gdk.height = ns.height; \
   PR_END_MACRO
 
-#define FROM_TWIPS_INT(_x)  (NSToIntRound((float)((_x)/(mContext->AppUnitsPerDevPixel()))))
-#define FROM_TWIPS_INT2(_x)  (NSToIntRound((float)((_x)/(mContext->AppUnitsPerDevPixel()))+0.5))
-#define FROM_TWIPS(_x)  ((float)((_x)/(mContext->AppUnitsPerDevPixel())))
-#define NS_RECT_FROM_TWIPS_RECT(_r)   (nsRect(FROM_TWIPS_INT((_r).x), FROM_TWIPS_INT((_r).y), FROM_TWIPS_INT2((_r).width), FROM_TWIPS_INT2((_r).height)))
+#define FROM_TWIPS_INT(_x)  (NSAppUnitsToIntPixels((_x), (mContext->AppUnitsPerDevPixel())))
+#define FROM_TWIPS(_x)  (NSAppUnitsToFloatPixels((_x),(mContext->AppUnitsPerDevPixel())))
+#define NS_RECT_FROM_TWIPS_RECT(_r)   (nsRect(FROM_TWIPS_INT((_r).x), FROM_TWIPS_INT((_r).y), FROM_TWIPS_INT((_r).width), FROM_TWIPS_INT((_r).height)))
 
 static nsGCCache *gcCache = nsnull;
 static nsFixedSizeAllocator *gStatePool = nsnull;
 
 nsRenderingContextGTK::nsRenderingContextGTK()
 {
   mFontMetrics = nsnull;
   mContext = nsnull;
@@ -1527,19 +1526,48 @@
                                                    PRUint32 &aWidth)
 {
   return mFontMetrics->GetRangeWidth(aText, aLength, aStart, aEnd, aWidth);
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawImage(imgIContainer *aImage, const nsRect & twSrcRect, const nsRect & twDestRect)
 {
   UpdateGC();
+
+  float scale = 1.0f;
+  nsCOMPtr<nsIDeviceContext> theDeviceContext;
+  GetDeviceContext(*getter_AddRefs(theDeviceContext));
+  if (theDeviceContext)
+    scale = theDeviceContext->GetPixelScale();
+
+  double p2a = nsIDeviceContext::AppUnitsPerCSSPixel();
+  nsIntRect pxDr;
+  pxDr.x = NSAppUnitsToIntPixels(twDestRect.x, p2a/scale);
+  pxDr.y = NSAppUnitsToIntPixels(twDestRect.y, p2a/scale);
+  pxDr.width = NSAppUnitsToIntPixels(twDestRect.XMost(), p2a/scale) - pxDr.x;
+  pxDr.height = NSAppUnitsToIntPixels(twDestRect.YMost(), p2a/scale) - pxDr.y;
+
   nsRect aDestRect = NS_RECT_FROM_TWIPS_RECT(twDestRect);
-  #define NS_RECT_FROM_TWIPS_RECT2(_r)   (nsRect(FROM_TWIPS_INT2((_r).x), FROM_TWIPS_INT2((_r).y), FROM_TWIPS_INT2((_r).width), FROM_TWIPS_INT2((_r).height)))
-  nsRect aSrcRect = NS_RECT_FROM_TWIPS_RECT2(twSrcRect);
+  nsRect aSrcRect = NS_RECT_FROM_TWIPS_RECT(twSrcRect);
+
+  // Due to rounding errors with certain scale factors
+  // we need to check the width and height values. With
+  // certain scale factor values NSAppUnitsToIntPixels and
+  // and NS_RECT_FROM_TWIPS_RECT give different values, in
+  // those cases the NSAppUnitsToIntPixels ones are the
+  // correct ones.
+  if ( aDestRect.width != pxDr.width ) {
+    aDestRect.width = pxDr.width;
+    aSrcRect.width = pxDr.width;
+    }
+  if ( aDestRect.height != pxDr.height ) {
+    aDestRect.height = pxDr.height;
+    aSrcRect.height = pxDr.height;
+    }
+
   //1,2,3... Some problems with images... stipes....;
   nsRect dr = aDestRect;
   mTranMatrix->TransformCoord(&dr.x, &dr.y, &dr.width, &dr.height);
 
   // We should NOT be transforming the source rect (which is based on the image
   // origin) using the rendering context's translation!
   // However, given that we are, remember that the transformation of a
   // height depends on the position, since what we are really doing is
Index: mozilla/gfx/src/gtk/nsImageGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsImageGTK.cpp
+++ mozilla/gfx/src/gtk/nsImageGTK.cpp
@@ -609,17 +609,17 @@
   if (!skipHorizontal)
     XlibStretchHorizontal(xd1, xd2, xs1, xs2, scaleStartY, scaleEndY,
                           startColumn, endColumn,
                           skipVertical?dstOrigX:-startColumn, skipVertical?dstOrigY:-scaleStartY,
                           aSrcImage, aTmpImage, (skipVertical?gc:copygc));
   
   if (!skipVertical) {
     for (d=0; d<=dx; d++) {
-      if ((yd1 >= startRow) && (yd1 <= endRow)) {
+      if ((yd1 >= startRow) && (yd1 < endRow)) {
         gdk_draw_pixmap(aDstImage, gc, aTmpImage,
                         (skipHorizontal?startColumn:0), ys1-scaleStartY,
                         aDX, dstOrigY+yd1,
                         endColumn-startColumn, 1);
       }
       while (e>=0) {
 	      ys1 += sy;
 	      e -= dx2;
@@ -658,17 +658,17 @@
   dy = abs((int)(y2-y1));
   sx = sign(x2-x1);
   sy = sign(y2-y1);
   e = dy-dx;
   dx2 = dx;
   dy += 1;
   if (!dx2) dx2=1;
   for (d=0; d<=dx; d++) {
-    if ((x1 >= startColumn) && (x1 <= endColumn)) {
+    if ((x1 >= startColumn) && (x1 < endColumn)) {
       gdk_draw_pixmap(aDstImage, gc, aSrcImage,
                       y1, ymin, x1+offsetX, ymin+offsetY,
                       1, ymax-ymin);
     }
     while (e>=0) {
       y1 += sy;
       e -= dx2;
     }
@@ -699,35 +699,51 @@
     return NS_OK;
 
   float scale = 1.0f;
   nsCOMPtr<nsIDeviceContext> theDeviceContext;
   aContext.GetDeviceContext(*getter_AddRefs(theDeviceContext));
   if (theDeviceContext)
     scale = theDeviceContext->GetPixelScale();
 
+  PRInt32 appUnitsPerDevPixel = 60;
+  if (theDeviceContext)
+    appUnitsPerDevPixel = theDeviceContext->AppUnitsPerDevPixel();
+
+  float p2a = nsIDeviceContext::AppUnitsPerCSSPixel();
+
+
   PRInt32 origDX = aDX, origDY = aDY, origDWidth = aDWidth, origDHeight = aDHeight;
-  PRBool hack = ((aDWidth != aSWidth || aDHeight != aSHeight) && mWidth != aSWidth && aSHeight != mHeight);
   PRInt32 ssW = aSWidth-aSX, ssH = aSHeight - aSY;
   if (scale != 1.0) {
-    aSWidth = mWidth - 1;
-    aDWidth = NSToIntRound((float)(mWidth) * scale);
-    aDWidth = origDWidth>aDWidth?origDWidth + 1:aDWidth + 1;
+    aSWidth = mWidth;
+    aDWidth = NSToIntRound(((float)(mWidth) * p2a)/appUnitsPerDevPixel);
+
+    // Fix for rounding errors when drawing
+    // scaled images
+    if ( abs( aDWidth - origDWidth ) == 1 ) {
+      aDWidth > origDWidth ? aDWidth -= 1 : aDWidth += 1;
+      }
+
+    aDWidth = origDWidth>aDWidth?origDWidth:aDWidth;
     aDX -= aSX;
     aSX = 0;
-    aSHeight = mHeight - 1;
-    aDHeight = NSToIntRound((float)(mHeight) * scale);
-    aDHeight = origDHeight>aDHeight?origDHeight + 1:aDHeight + 1;
+    aSHeight = mHeight;
+    aDHeight = NSToIntRound(((float)(mHeight) * p2a )/ appUnitsPerDevPixel);
+
+    // Fix for rounding errors when drawing
+    // scaled images
+    if ( abs( aDHeight - origDHeight ) == 1 ) {
+      aDHeight > origDHeight ? aDHeight -= 1 : aDHeight += 1;
+      }
+
+    aDHeight = origDHeight>aDHeight?origDHeight:aDHeight;
     aDY -= aSY;
     aSY = 0;
   }
-  else {
-    if (aSX > 0) aSX -= !hack;
-    if (aSY > 0) aSY -= !hack;
-  }
 
 
 #ifdef TRACE_IMAGE_ALLOCATION
   fprintf(stderr, "nsImageGTK::Draw(%p) s=(%4d %4d %4d %4d) d=(%4d %4d %4d %4d)\n",
          this,
          aSX, aSY, aSWidth, aSHeight,
          aDX, aDY, aDWidth, aDHeight);
 #endif
@@ -736,18 +752,18 @@
     return NS_OK;
   }
 
   // store some values we'll need for scaling...
 
   PRInt32 srcWidth, srcHeight, dstWidth, dstHeight;
   PRInt32 dstOrigX, dstOrigY;
 
-  srcWidth = mWidth<ssW?mWidth - 1:aSWidth;
-  srcHeight = mHeight<ssH?mHeight - 1:aSHeight;
+  srcWidth = mWidth<ssW?mWidth:aSWidth;
+  srcHeight = mHeight<ssH?mHeight:aSHeight;
   if (!srcWidth) srcWidth = 1;
   if (!srcHeight) srcHeight = 1;
   dstWidth = aDWidth;
   dstHeight = aDHeight;
   dstOrigX = aDX;
   dstOrigY = aDY;
 
   // clip to decode region
