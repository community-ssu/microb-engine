# I hope it will be possible to integrate this feature in Gecko...
# It will allow to know about some events which was handled by JS handlers (Allow to make more better stylus/panning/ajax iteractions handling)
Index: mozilla/content/events/src/nsEventListenerManager.cpp
===================================================================
--- mozilla.orig/content/events/src/nsEventListenerManager.cpp
+++ mozilla/content/events/src/nsEventListenerManager.cpp
@@ -1212,18 +1212,18 @@
             nsEventDispatcher::CreateEvent(aPresContext, aEvent,
                                            EmptyString(), aDOMEvent);
           }
           if (*aDOMEvent) {
             if (useTypeInterface) {
               DispatchToInterface(*aDOMEvent, ls->mListener,
                                   dispData->method, *typeData->iid);
             } else if (useGenericInterface) {
-              HandleEventSubType(ls, ls->mListener, *aDOMEvent,
-                                 aCurrentTarget, aFlags);
+              if (NS_SUCCEEDED(HandleEventSubType(ls, ls->mListener, *aDOMEvent, aCurrentTarget, aFlags)))
+                aEvent->jsflags = (ls->mFlags & NS_PRIV_EVENT_FLAG_SCRIPT)?1:2;
             }
           }
         }
       }
     }
   }
 
   if (!hasListener) {
Index: mozilla/content/events/src/nsDOMEvent.cpp
===================================================================
--- mozilla.orig/content/events/src/nsDOMEvent.cpp
+++ mozilla/content/events/src/nsDOMEvent.cpp
@@ -289,16 +289,23 @@
     *aEventPhase = nsIDOMEvent::BUBBLING_PHASE;
   } else {
     *aEventPhase = 0;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsDOMEvent::GetPrivateFlags(PRUint32* aEventFlags)
+{
+  *aEventFlags = mEvent->jsflags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsDOMEvent::GetBubbles(PRBool* aBubbles)
 {
   *aBubbles = !(mEvent->flags & NS_EVENT_FLAG_CANT_BUBBLE);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMEvent::GetCancelable(PRBool* aCancelable)
Index: mozilla/widget/public/nsGUIEvent.h
===================================================================
--- mozilla.orig/widget/public/nsGUIEvent.h
+++ mozilla/widget/public/nsGUIEvent.h
@@ -366,28 +366,30 @@
 {
 protected:
   nsEvent(PRBool isTrusted, PRUint32 msg, PRUint8 structType)
     : eventStructType(structType),
       message(msg),
       refPoint(0, 0),
       time(0),
       flags(isTrusted ? NS_EVENT_FLAG_TRUSTED : NS_EVENT_FLAG_NONE),
-      userType(0)
+      userType(0),
+      jsflags(0)
   {
   }
 
 public:
   nsEvent(PRBool isTrusted, PRUint32 msg)
     : eventStructType(NS_EVENT),
       message(msg),
       refPoint(0, 0),
       time(0),
       flags(isTrusted ? NS_EVENT_FLAG_TRUSTED : NS_EVENT_FLAG_NONE),
-      userType(0)
+      userType(0),
+      jsflags(0)
   {
   }
 
   // See event struct types
   PRUint8     eventStructType;
   // See GUI MESSAGES,
   PRUint32    message;
   // In widget relative coordinates, not modified by layout code.
@@ -395,16 +397,18 @@
   // Elapsed time, in milliseconds, from a platform-specific zero time
   // to the time the message was created
   PRUint32    time;
   // Flags to hold event flow stage and capture/bubble cancellation
   // status. This is used also to indicate whether the event is trusted.
   PRUint32    flags;
   // Additional type info for user defined events
   nsCOMPtr<nsIAtom>     userType;
+  // Flags for storing info about handling events inside JS listeners...
+  PRUint32    jsflags;
   // Event targets, needed by DOM Events
   // Using nsISupports, not nsIDOMEventTarget because in some cases
   // nsIDOMEventTarget is implemented as a tearoff.
   nsCOMPtr<nsISupports> target;
   nsCOMPtr<nsISupports> currentTarget;
   nsCOMPtr<nsISupports> originalTarget;
 };
 
Index: mozilla/dom/public/idl/events/nsIDOMEvent.idl
===================================================================
--- mozilla.orig/dom/public/idl/events/nsIDOMEvent.idl
+++ mozilla/dom/public/idl/events/nsIDOMEvent.idl
@@ -166,9 +166,15 @@
    *                       conflicts with other new events.
    * @param   canBubbleArg Specifies whether or not the event can bubble.
    * @param   cancelableArg Specifies whether or not the event's default 
    *                        action can be prevented.
    */
   void                      initEvent(in DOMString eventTypeArg,
                                       in boolean canBubbleArg,
                                       in boolean cancelableArg);
+
+  /**
+   * Used to indicate which phase of event flow is currently being
+   * evaluated.
+   */
+  readonly attribute PRUint32           privateFlags;
 };
Index: mozilla/security/manager/ssl/src/nsSmartCardEvent.cpp
===================================================================
--- mozilla.orig/security/manager/ssl/src/nsSmartCardEvent.cpp
+++ mozilla/security/manager/ssl/src/nsSmartCardEvent.cpp
@@ -225,16 +225,22 @@
 }
 
 NS_IMETHODIMP nsSmartCardEvent::StopPropagation()
 {
   NS_ASSERTION(mInner, "SmartCardEvent called without Init");
   return mInner->StopPropagation();
 }
 
+NS_IMETHODIMP nsSmartCardEvent::GetPrivateFlags(PRUint32* aEventFlags)
+{
+  NS_ASSERTION(mInner, "SmartCardEvent called without Init");
+  return mInner->GetPrivateFlags(aEventFlags);
+}
+
 NS_IMETHODIMP nsSmartCardEvent::PreventDefault()
 {
   NS_ASSERTION(mInner, "SmartCardEvent called without Init");
   return mInner->PreventDefault();
 }
 
 NS_IMETHODIMP nsSmartCardEvent::InitEvent(const nsAString & eventTypeArg, PRBool canBubbleArg, PRBool cancelableArg)
 {
