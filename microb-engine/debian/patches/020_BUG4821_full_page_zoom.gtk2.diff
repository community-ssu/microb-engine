# Bug 4821 (pagezoom)  Full zooming not functional (images, objects as well as text) (page zoom like opera)
#
Index: mozilla/docshell/base/nsDocShell.cpp
===================================================================
--- mozilla.orig/docshell/base/nsDocShell.cpp
+++ mozilla/docshell/base/nsDocShell.cpp
@@ -5403,18 +5403,28 @@
         if (doc)
             request = doc->GetChannel();
         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
     }
 
     nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV(do_QueryInterface(mContentViewer));
     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV(do_QueryInterface(viewer));
     float zoom = 1.0;
-    if (oldMUDV && newMUDV)
+    float fullZoom = 1.0;
+    if (oldMUDV && newMUDV) {
         oldMUDV->GetTextZoom(&zoom);
+        newMUDV->GetFullZoom(&fullZoom);
+        //newMUDV->SetFullZoom(fullZoom);
+/*Ups not xulrunner build can't link with presContext....
+        Let see newMUDV->Set or oldMUDV->Set*/
+        nsCOMPtr<nsPresContext> presContext;
+        GetEldestPresContext(getter_AddRefs(presContext));
+        if (presContext)
+            presContext->SetFullZoom(fullZoom, PR_TRUE);
+    }
 
     // Protect against mLSHE going away via a load triggered from
     // pagehide or unload.
     nsCOMPtr<nsISHEntry> origLSHE = mLSHE;
 
     // Notify the old content viewer that it's being hidden.
     FirePageHideNotification(!mSavingOldViewer);
 
Index: mozilla/gfx/public/nsIDeviceContext.h
===================================================================
--- mozilla.orig/gfx/public/nsIDeviceContext.h
+++ mozilla/gfx/public/nsIDeviceContext.h
@@ -467,16 +467,21 @@
 
   /**
    * Check to see if the DPI has changed
    * @return whether there was actually a change in the DPI
    *         (whether AppUnitsPerDevPixel() or AppUnitsPerInch() changed)
   */
   virtual PRBool CheckDPIChange() = 0;
 
+  virtual PRBool SetPixelScale(float aScale) = 0;
+  float GetPixelScale() const { return mPixelScale; }
+
 protected:
   PRInt32 mAppUnitsPerDevPixel;
   PRInt32 mAppUnitsPerInch;
+  PRInt32 mAppUnitsPerDevNotScaledPixel;
+  float   mPixelScale;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIDeviceContext, NS_IDEVICE_CONTEXT_IID)
 
 #endif /* nsIDeviceContext_h___ */
Index: mozilla/gfx/src/nsDeviceContext.cpp
===================================================================
--- mozilla.orig/gfx/src/nsDeviceContext.cpp
+++ mozilla/gfx/src/nsDeviceContext.cpp
@@ -51,16 +51,17 @@
 #include "nsCRT.h"
 #include "nsIRenderingContext.h"
 
 NS_IMPL_ISUPPORTS3(DeviceContextImpl, nsIDeviceContext, nsIObserver, nsISupportsWeakReference)
 
 DeviceContextImpl::DeviceContextImpl()
 {
   mAppUnitsPerDevPixel = -1;
+  mAppUnitsPerDevNotScaledPixel = -1;
   mAppUnitsPerInch = -1;
   mFontCache = nsnull;
   mWidget = nsnull;
   mFontAliasTable = nsnull;
 
 #ifdef NS_DEBUG
   mInitialized = PR_FALSE;
 #endif
@@ -494,27 +495,29 @@
   // First check our cache
   // start from the end, which is where we put the most-recent-used element
 
   nsIFontMetrics* fm;
   PRInt32 n = mFontMetrics.Count() - 1;
   for (PRInt32 i = n; i >= 0; --i) {
     fm = NS_STATIC_CAST(nsIFontMetrics*, mFontMetrics[i]);
     if (fm->Font().Equals(aFont)) {
+    if (mContext->AppUnitsPerDevPixel() == fm->mP2A) {
       nsCOMPtr<nsIAtom> langGroup;
       fm->GetLangGroup(getter_AddRefs(langGroup));
       if (aLangGroup == langGroup.get()) {
         if (i != n) {
           // promote it to the end of the cache
           mFontMetrics.MoveElement(i, n);
         }
         NS_ADDREF(aMetrics = fm);
         return NS_OK;
       }
     }
+    }
   }
 
   // It's not in the cache. Get font metrics and then cache them.
 
   aMetrics = nsnull;
   nsresult rv = CreateFontMetricsInstance(&fm);
   if (NS_FAILED(rv)) return rv;
   rv = fm->Init(aFont, aLangGroup, mContext);
Index: mozilla/gfx/src/thebes/nsThebesDeviceContext.cpp
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesDeviceContext.cpp
+++ mozilla/gfx/src/thebes/nsThebesDeviceContext.cpp
@@ -235,18 +235,20 @@
 
     } else {
         /* set mAppUnitsPerDevPixel so we're using exactly 72 dpi, even
          * though that means we have a non-integer number of device "pixels"
          * per CSS pixel
          */
         mAppUnitsPerDevPixel = (AppUnitsPerCSSPixel() * 96) / dpi;
     }
+    mAppUnitsPerDevNotScaledPixel = mAppUnitsPerDevPixel;
 
     mAppUnitsPerInch = NSIntPixelsToAppUnits(dpi, mAppUnitsPerDevPixel);
+    mPixelScale = (float)nsIDeviceContext::AppUnitsPerCSSPixel()/(float)mAppUnitsPerDevPixel;
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsThebesDeviceContext::Init(nsNativeWidget aWidget)
 {
     mWidget = aWidget;
@@ -415,17 +417,17 @@
 
     aFont->name = fontName;
     aFont->style = fontStyle.style;
     aFont->systemFont = fontStyle.systemFont;
     aFont->variant = NS_FONT_VARIANT_NORMAL;
     aFont->familyNameQuirks = fontStyle.familyNameQuirks;
     aFont->weight = fontStyle.weight;
     aFont->decorations = NS_FONT_DECORATION_NONE;
-    aFont->size = NSFloatPixelsToAppUnits(fontStyle.size, AppUnitsPerDevPixel());
+    aFont->size = NSFloatPixelsToAppUnits(fontStyle.size, AppUnitsPerCSSPixel() * 96);
     //aFont->langGroup = fontStyle.langGroup;
     aFont->sizeAdjust = fontStyle.sizeAdjust;
 
     return rv;
 }
 
 NS_IMETHODIMP
 nsThebesDeviceContext::CheckFontExistence(const nsString& aFaceName)
@@ -750,8 +752,20 @@
     PRInt32 oldDevPixels = mAppUnitsPerDevPixel;
     PRInt32 oldInches = mAppUnitsPerInch;
 
     SetDPI();
 
     return oldDevPixels != mAppUnitsPerDevPixel ||
            oldInches != mAppUnitsPerInch;
 }
+
+PRBool
+nsThebesDeviceContext::SetPixelScale(float aScale)
+{
+    if (aScale != 0.0 && mPixelScale == aScale)
+        return PR_FALSE;
+    if (mPixelScale == 1.0)
+        mAppUnitsPerDevNotScaledPixel = mAppUnitsPerDevPixel;
+    mAppUnitsPerDevPixel = (PRInt32)((float)mAppUnitsPerDevNotScaledPixel / aScale);
+    mPixelScale = aScale;
+    return PR_TRUE;
+}
Index: mozilla/gfx/src/thebes/nsThebesDeviceContext.h
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesDeviceContext.h
+++ mozilla/gfx/src/thebes/nsThebesDeviceContext.h
@@ -111,16 +111,17 @@
     NS_IMETHOD AbortDocument(void);
     NS_IMETHOD BeginPage(void);
     NS_IMETHOD EndPage(void);
     /* end printing goop */
 
     static void DebugShowCairoSurface (const char *aName, cairo_surface_t *aSurface);
 
     virtual PRBool CheckDPIChange();
+    virtual PRBool SetPixelScale(float aScale);
 
     nsNativeWidget GetWidget() { return mWidget; }
 #ifdef XP_WIN
     HDC GetPrintHDC() {
         if (mPrintingSurface) {
             NS_ASSERTION(mPrintingSurface->GetType() == gfxASurface::SurfaceTypeWin32, "invalid surface type");
             return reinterpret_cast<gfxWindowsSurface*>(mPrintingSurface.get())->GetDC();
         }
Index: mozilla/layout/base/nsDocumentViewer.cpp
===================================================================
--- mozilla.orig/layout/base/nsDocumentViewer.cpp
+++ mozilla/layout/base/nsDocumentViewer.cpp
@@ -405,16 +405,17 @@
   nsCOMPtr<nsIDOMFocusListener> mFocusListener;
 
   nsCOMPtr<nsIContentViewer> mPreviousViewer;
   nsCOMPtr<nsISHEntry> mSHEntry;
 
   nsIWidget* mParentWidget;          // purposely won't be ref counted
 
   float mTextZoom;      // Text zoom, defaults to 1.0
+  float mFullZoom;      // Full layout zoom, defaults to 1.0
 
   PRInt16 mNumURLStarts;
   PRInt16 mDestroyRefCount;    // a second "refcount" for the document viewer's "destroy"
 
   unsigned      mEnableRendering : 1;
   unsigned      mStopped : 1;
   unsigned      mLoaded : 1;
   unsigned      mDeferredWindowClose : 1;
@@ -502,17 +503,17 @@
 
 #endif // NS_PRINTING
 }
 
 // Note: operator new zeros our memory, so no need to init things to null.
 DocumentViewerImpl::DocumentViewerImpl()
   : mTextZoom(1.0),
     mIsSticky(PR_TRUE),
-    mHintCharsetSource(kCharsetUninitialized)
+    mHintCharsetSource(kCharsetUninitialized), mFullZoom(1.0)
 {
   PrepareToStartLoad();
 }
 
 NS_IMPL_ADDREF(DocumentViewerImpl)
 NS_IMPL_RELEASE(DocumentViewerImpl)
 
 NS_INTERFACE_MAP_BEGIN(DocumentViewerImpl)
@@ -681,16 +682,17 @@
   mWindow->GetBounds(bounds);
 
   nscoord width = mPresContext->DevPixelsToAppUnits(bounds.width);
   nscoord height = mPresContext->DevPixelsToAppUnits(bounds.height);
 
   mViewManager->DisableRefresh();
   mViewManager->SetWindowDimensions(width, height);
   mPresContext->SetTextZoom(mTextZoom);
+  mFullZoom = mPresContext->FullZoom();
 
   // Setup default view manager background color
 
   // This may be overridden by the docshell with the background color
   // for the last document loaded into the docshell
   mViewManager->SetDefaultBackgroundColor(mPresContext->DefaultBackgroundColor());
 
   if (aDoInitialReflow) {
@@ -2630,43 +2632,50 @@
             (*aFunc)(markupCV, aClosure);
           }
         }
       }
     }
   }
 }
 
-struct TextZoomInfo
+struct ZoomInfo
 {
-  float mTextZoom;
+  float mZoom;
 };
 
 static void
 SetChildTextZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
 {
-  struct TextZoomInfo* textZoomInfo = (struct TextZoomInfo*) aClosure;
-  aChild->SetTextZoom(textZoomInfo->mTextZoom);
+  struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
+  aChild->SetTextZoom(ZoomInfo->mZoom);
+}
+
+static void
+SetChildFullZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
+{
+  struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
+  aChild->SetFullZoom(ZoomInfo->mZoom);
 }
 
 NS_IMETHODIMP
 DocumentViewerImpl::SetTextZoom(float aTextZoom)
 {
   mTextZoom = aTextZoom;
 
   if (mViewManager) {
     mViewManager->BeginUpdateViewBatch();
   }
       
   // Set the text zoom on all children of mContainer (even if our zoom didn't
   // change, our children's zoom may be different, though it would be unusual).
   // Do this first, in case kids are auto-sizing and post reflow commands on
   // our presshell (which should be subsumed into our own style change reflow).
-  struct TextZoomInfo textZoomInfo = { aTextZoom };
-  CallChildren(SetChildTextZoom, &textZoomInfo);
+  struct ZoomInfo ZoomInfo = { aTextZoom };
+  CallChildren(SetChildTextZoom, &ZoomInfo);
 
   // Now change our own zoom
   if (mPresContext && aTextZoom != mPresContext->TextZoom()) {
       mPresContext->SetTextZoom(aTextZoom);
   }
 
   if (mViewManager) {
     mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
@@ -2681,16 +2690,56 @@
   NS_ENSURE_ARG_POINTER(aTextZoom);
   NS_ASSERTION(!mPresContext || mPresContext->TextZoom() == mTextZoom, 
                "mPresContext->TextZoom() != mTextZoom");
 
   *aTextZoom = mTextZoom;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+DocumentViewerImpl::SetFullZoom(float aFullZoom)
+{
+  mFullZoom = aFullZoom;
+
+  if (mViewManager) {
+    mViewManager->BeginUpdateViewBatch();
+  }
+
+  // Set the full zoom on all children of mContainer (even if our zoom didn't
+  // change, our children's zoom may be different, though it would be unusual).
+  // Do this first, in case kids are auto-sizing and post reflow commands on
+  // our presshell (which should be subsumed into our own style change reflow).
+  struct ZoomInfo ZoomInfo = { aFullZoom };
+  CallChildren(SetChildFullZoom, &ZoomInfo);
+
+  // Now change our own zoom
+
+  if (mPresContext && aFullZoom != mPresContext->FullZoom()) {
+      mPresContext->SetFullZoom(aFullZoom);
+  }
+
+  if (mViewManager) {
+    mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+DocumentViewerImpl::GetFullZoom(float* aFullZoom)
+{
+  NS_ENSURE_ARG_POINTER(aFullZoom);
+  if (mPresContext->FullZoom() != mFullZoom)
+     printf("DocumentViewerImpl:WARNING: mPresContext->FullZoom() != mFullZoom\n");
+  *aFullZoom = mFullZoom;
+  return NS_OK;
+}
+
+
 static void
 SetChildAuthorStyleDisabled(nsIMarkupDocumentViewer* aChild, void* aClosure)
 {
   PRBool styleDisabled  = *NS_STATIC_CAST(PRBool*, aClosure);
   aChild->SetAuthorStyleDisabled(styleDisabled);
 }
 
 
Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -174,17 +174,18 @@
                           NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultMonospaceFont("monospace", NS_FONT_STYLE_NORMAL,
                           NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultCursiveFont("cursive", NS_FONT_STYLE_NORMAL,
                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultFantasyFont("fantasy", NS_FONT_STYLE_NORMAL,
                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mCanPaginatedScroll(PR_FALSE),
-    mIsRootPaginatedDocument(PR_FALSE)
+    mIsRootPaginatedDocument(PR_FALSE),
+    mFullZoom(1.0f), mTrueZoomMode(PR_FALSE)
 {
   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
   // bother initializing members to 0.
 
   mDoScaledTwips = PR_TRUE;
 
   SetBackgroundImageDraw(PR_TRUE);		// always draw the background
   SetBackgroundColorDraw(PR_TRUE);
@@ -271,16 +272,19 @@
 #ifdef IBMBIDI
   nsContentUtils::UnregisterPrefCallback("bidi.", PrefChangedCallback, this);
 
   delete mBidiUtils;
 #endif // IBMBIDI
   nsContentUtils::UnregisterPrefCallback("layout.css.dpi",
                                          nsPresContext::PrefChangedCallback,
                                          this);
+  nsContentUtils::UnregisterPrefCallback("layout.full.true.zoom.mode",
+                                         nsPresContext::PrefChangedCallback,
+                                         this);
 
   NS_IF_RELEASE(mDeviceContext);
   NS_IF_RELEASE(mLookAndFeel);
   NS_IF_RELEASE(mLangGroup);
 }
 
 NS_IMPL_ISUPPORTS1(nsPresContext, nsIObserver)
 
@@ -524,16 +528,20 @@
 
   // * document colors
   GetDocumentColorPreferences();
 
   // * link colors
   mUnderlineLinks =
     nsContentUtils::GetBoolPref("browser.underline_anchors", mUnderlineLinks);
 
+  // True Zoom Mode
+  mTrueZoomMode =
+    nsContentUtils::GetBoolPref("layout.full.true.zoom.mode", mTrueZoomMode);
+
   nsAdoptingCString colorStr =
     nsContentUtils::GetCharPref("browser.anchor_color");
 
   if (!colorStr.IsEmpty()) {
     mLinkColor = MakeColorPref(colorStr);
   }
 
   colorStr =
@@ -656,38 +664,69 @@
 
 void
 nsPresContext::PreferenceChanged(const char* aPrefName)
 {
   if (!nsCRT::strcmp(aPrefName, "layout.css.dpi")) {
     nsRect bounds(mVisibleArea);
     bounds *= 1.0f / AppUnitsPerDevPixel();
     if (mDeviceContext->CheckDPIChange() && mShell) {
-      mDeviceContext->FlushFontCache();
+      //ROMAXA mDeviceContext->FlushFontCache();
 
-      nsIViewManager* vm = GetViewManager();
       nscoord width = DevPixelsToAppUnits(bounds.width);
       nscoord height = DevPixelsToAppUnits(bounds.height);
-      vm->SetWindowDimensions(width, height);
-
-      ClearStyleDataAndReflow();
+      if (nsContentUtils::GetBoolPref("layout.full.zoom.mode.fast", PR_FALSE)) {
+        /* XXX this way of reflow works 3x faster, but buggy
+          Internal scrolbars also resized (Iframe, textarea...)
+        */
+        mShell->FrameNeedsReflow(mShell->GetRootFrame(), nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+        mShell->ResizeReflow(width, height);
+      } else {
+        nsIViewManager* vm = GetViewManager();
+        vm->SetWindowDimensions(width, height);
+        ClearStyleDataAndReflow();
+      }
     }
     return;
   }
   // we use a zero-delay timer to coalesce multiple pref updates
   if (!mPrefChangedTimer)
   {
     mPrefChangedTimer = do_CreateInstance("@mozilla.org/timer;1");
     if (!mPrefChangedTimer)
       return;
     mPrefChangedTimer->InitWithFuncCallback(nsPresContext::PrefChangedUpdateTimerCallback, (void*)this, 0, nsITimer::TYPE_ONE_SHOT);
   }
 }
 
 void
+nsPresContext::SetFullZoom(float aZoom, PRBool onlyDevice)
+{
+  nsRect bounds(mVisibleArea);
+  bounds *= 1.0f / AppUnitsPerDevPixel();
+  if (!mShell || !mDeviceContext->SetPixelScale(aZoom) || onlyDevice)
+    return;
+  mFullZoom = aZoom;
+//  mDeviceContext->FlushFontCache();
+  nscoord width = DevPixelsToAppUnits(bounds.width);
+  nscoord height = DevPixelsToAppUnits(bounds.height);
+  if (nsContentUtils::GetBoolPref("layout.full.zoom.mode.fast", PR_FALSE)) {
+    /* XXX this way of reflow works 3x faster, but buggy
+       Internal scrolbars also resized (Iframe, textarea...)
+    */
+    mShell->FrameNeedsReflow(mShell->GetRootFrame(), nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+    mShell->ResizeReflow(width, height);
+    return;
+  }
+  nsIViewManager* vm = GetViewManager();
+  vm->SetWindowDimensions(width, height);
+  ClearStyleDataAndReflow();
+}
+
+void
 nsPresContext::UpdateAfterPreferencesChanged()
 {
   mPrefChangedTimer = nsnull;
 
   nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryReferent(mContainer));
   if (docShell) {
     PRInt32 docShellType;
     docShell->GetItemType(&docShellType);
@@ -711,16 +750,18 @@
 nsPresContext::Init(nsIDeviceContext* aDeviceContext)
 {
   NS_ASSERTION(!(mInitialized == PR_TRUE), "attempt to reinit pres context");
   NS_ENSURE_ARG(aDeviceContext);
 
   mDeviceContext = aDeviceContext;
   NS_ADDREF(mDeviceContext);
 
+  mFullZoom = mDeviceContext->GetPixelScale();
+
   if (!mImageLoaders.Init())
     return NS_ERROR_OUT_OF_MEMORY;
   
   // Get the look and feel service here; default colors will be initialized
   // from calling GetUserPreferences() when we get a presshell.
   nsresult rv = CallGetService(kLookAndFeelCID, &mLookAndFeel);
   if (NS_FAILED(rv)) {
     NS_ERROR("LookAndFeel service must be implemented for this toolkit");
@@ -759,16 +800,19 @@
                                        this);
 #ifdef IBMBIDI
   nsContentUtils::RegisterPrefCallback("bidi.", PrefChangedCallback,
                                        this);
 #endif
   nsContentUtils::RegisterPrefCallback("layout.css.dpi",
                                        nsPresContext::PrefChangedCallback,
                                        this);
+  nsContentUtils::RegisterPrefCallback("layout.full.true.zoom.mode",
+                                       nsPresContext::PrefChangedCallback,
+                                       this);
 
   rv = mEventManager->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   mEventManager->SetPresContext(this);
 
 #ifdef DEBUG
   mInitialized = PR_TRUE;
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -445,27 +445,31 @@
   float GetPrintPreviewScale() { return mPPScale; }
   void SetPrintPreviewScale(float aScale) { mPPScale = aScale; }
 
   nsIDeviceContext* DeviceContext() { return mDeviceContext; }
   nsIEventStateManager* EventStateManager() { return mEventManager; }
   nsIAtom* GetLangGroup() { return mLangGroup; }
 
   float TextZoom() { return mTextZoom; }
+  float FullZoom() { return mFullZoom; }
+  PRBool TrueZoomMode() { return mTrueZoomMode; }
   void SetTextZoomInternal(float aZoom) {
     mTextZoom = aZoom;
     ClearStyleDataAndReflow();
   }
   virtual NS_HIDDEN_(void) SetTextZoomExternal(float aZoom);
 #ifdef _IMPL_NS_LAYOUT
   void SetTextZoom(float aZoom) { SetTextZoomInternal(aZoom); }
 #else
   void SetTextZoom(float aZoom) { SetTextZoomExternal(aZoom); }
 #endif
 
+  void SetFullZoom(float aZoom, PRBool onlyDevice = PR_FALSE);
+
   static PRInt32 AppUnitsPerCSSPixel() { return nsIDeviceContext::AppUnitsPerCSSPixel(); }
   PRInt32 AppUnitsPerDevPixel() const  { return mDeviceContext->AppUnitsPerDevPixel(); }
   PRInt32 AppUnitsPerInch() const      { return mDeviceContext->AppUnitsPerInch(); }
 
   static nscoord CSSPixelsToAppUnits(PRInt32 aPixels)
   { return NSIntPixelsToAppUnits(aPixels,
                                  nsIDeviceContext::AppUnitsPerCSSPixel()); }
 
@@ -763,16 +767,17 @@
   nsWeakPtr             mContainer;
 
   // Only used in the root prescontext (this->RootPresContext() == this)
   // This is a list of all active popups from bottom to top in z-order
   // (usually empty, of course)
   nsTArray<nsIFrame*>   mActivePopups;
 
   float                 mTextZoom;      // Text zoom, defaults to 1.0
+  float                 mFullZoom;      // Text zoom, defaults to 1.0
 
 #ifdef IBMBIDI
   nsBidiPresUtils*      mBidiUtils;
 #endif
 
   nsCOMPtr<nsITheme> mTheme;
   nsCOMPtr<nsILanguageAtomService> mLangService;
   nsCOMPtr<nsIPrintSettings> mPrintSettings;
@@ -839,16 +844,17 @@
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
   unsigned              mIsBidiSystem : 1;
 
 #endif
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
+  PRPackedBool          mTrueZoomMode : 1;
 
 
 protected:
 
   ~nsPresContext() NS_HIDDEN;
 
   // these are private, use the list in nsFont.h if you want a public list
   enum {
Index: mozilla/docshell/base/nsIMarkupDocumentViewer.idl
===================================================================
--- mozilla.orig/docshell/base/nsIMarkupDocumentViewer.idl
+++ mozilla/docshell/base/nsIMarkupDocumentViewer.idl
@@ -59,16 +59,19 @@
 	/*
 	Scrolls to a given DOM content node. 
 	*/
 	void scrollToNode(in nsIDOMNode node);
 
 	/** The amount by which to scale all text. Default is 1.0. */
 	attribute float textZoom;
 
+	/** The amount by which to scale all layout. Default is 1.0. */
+	attribute float fullZoom;
+
 	/** Disable entire author style level (including HTML presentation hints) */
 	attribute boolean authorStyleDisabled;
 
 	/*
 	XXX Comment here!
 	*/
 	attribute ACString defaultCharacterSet;
 
Index: mozilla/gfx/src/thebes/nsSystemFontsGTK2.cpp
===================================================================
--- mozilla.orig/gfx/src/thebes/nsSystemFontsGTK2.cpp
+++ mozilla/gfx/src/thebes/nsSystemFontsGTK2.cpp
@@ -225,17 +225,17 @@
     aFontStyle->weight = pango_font_description_get_weight(desc);
 
     float size = float(pango_font_description_get_size(desc) / PANGO_SCALE);
 
     // |size| is now either pixels or pango-points (not Mozilla-points!)
 
     if (!MOZ_pango_font_description_get_size_is_absolute(desc)) {
         // |size| is in pango-points, so convert to pixels.
-        size *= float(gfxPlatformGtk::DPI()) / 72.0f;
+        size *= 1.0f / 72.0f;
     }
 
     // |size| is now pixels
 
     aFontStyle->size = size;
   
     pango_font_description_free(desc);
 
Index: mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsDeviceContextGTK.cpp
+++ mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp
@@ -130,16 +130,17 @@
 
 nsDeviceContextGTK::nsDeviceContextGTK()
   : DeviceContextImpl()
 {
   mAppUnitsPerDevPixel = -1;
   mAppUnitsPerInch = -1;
   mDepth = 0 ;
   mNumCells = 0;
+  mPixelScale = 1.0;
 
   mDeviceWindow = nsnull;
 }
 
 nsDeviceContextGTK::~nsDeviceContextGTK()
 {
   nsresult rv;
   nsCOMPtr<nsIPref> prefs = do_GetService(NS_PREF_CONTRACTID, &rv);
@@ -669,16 +670,28 @@
       }
     }
     SetDPI(prefDPI);
 
     return oldDevPixels != mAppUnitsPerDevPixel ||
            oldInches != mAppUnitsPerInch;
 }
 
+PRBool
+nsDeviceContextGTK::SetPixelScale(float aScale)
+{
+    if (aScale != 0.0 && mPixelScale == aScale)
+        return PR_FALSE;
+    if (mPixelScale == 1.0)
+        mAppUnitsPerDevNotScaledPixel = mAppUnitsPerDevPixel;
+    mAppUnitsPerDevPixel = (PRInt32)((float)mAppUnitsPerDevNotScaledPixel / aScale);
+    mPixelScale = aScale;
+    return PR_TRUE;
+}
+
 #define DEFAULT_TWIP_FONT_SIZE 240
 
 nsSystemFontsGTK::nsSystemFontsGTK(float aPixelsToTwips)
   : mDefaultFont("sans-serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                  NS_FONT_WEIGHT_NORMAL, NS_FONT_DECORATION_NONE,
                  DEFAULT_TWIP_FONT_SIZE),
     mButtonFont("sans-serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                 NS_FONT_WEIGHT_NORMAL, NS_FONT_DECORATION_NONE,
Index: mozilla/gfx/src/gtk/nsImageGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsImageGTK.cpp
+++ mozilla/gfx/src/gtk/nsImageGTK.cpp
@@ -693,20 +693,42 @@
     UpdateCachedImage();
 
   if ((mAlphaDepth==1) && mIsSpacer)
     return NS_OK;
 
   if (mDecodedX2 < mDecodedX1 || mDecodedY2 < mDecodedY1)
     return NS_OK;
 
+  float scale = 1.0f;
+  nsCOMPtr<nsIDeviceContext> theDeviceContext;
+  aContext.GetDeviceContext(*getter_AddRefs(theDeviceContext));
+  if (theDeviceContext)
+    scale = theDeviceContext->GetPixelScale();
+
+  PRInt32 origDX = aDX, origDY = aDY, origDWidth = aDWidth, origDHeight = aDHeight;
   PRBool hack = ((aDWidth != aSWidth || aDHeight != aSHeight) && mWidth != aSWidth && aSHeight != mHeight);
   PRInt32 ssW = aSWidth-aSX, ssH = aSHeight - aSY;
-  if (aSX > 0) aSX -= !hack;
-  if (aSY > 0) aSY -= !hack;
+  if (scale != 1.0) {
+    aSWidth = mWidth - 1;
+    aDWidth = NSToIntRound((float)(mWidth) * scale);
+    aDWidth = origDWidth>aDWidth?origDWidth + 1:aDWidth + 1;
+    aDX -= aSX;
+    aSX = 0;
+    aSHeight = mHeight - 1;
+    aDHeight = NSToIntRound((float)(mHeight) * scale);
+    aDHeight = origDHeight>aDHeight?origDHeight + 1:aDHeight + 1;
+    aDY -= aSY;
+    aSY = 0;
+  }
+  else {
+    if (aSX > 0) aSX -= !hack;
+    if (aSY > 0) aSY -= !hack;
+  }
+
 
 #ifdef TRACE_IMAGE_ALLOCATION
   fprintf(stderr, "nsImageGTK::Draw(%p) s=(%4d %4d %4d %4d) d=(%4d %4d %4d %4d)\n",
          this,
          aSX, aSY, aSWidth, aSHeight,
          aDX, aDY, aDWidth, aDHeight);
 #endif
 
@@ -749,45 +771,88 @@
     aDY += (mDecodedY1 - aSY)*dstHeight/srcHeight;
     aSY = mDecodedY1;
   }
 
   if (aDWidth <= 0 || aDHeight <= 0 || aSWidth <= 0 || aSHeight <= 0) {
     return NS_OK;
   }
 
+  // clip to drawing rect
+  float widthScale = srcWidth/dstWidth;
+  float heightScale = srcHeight/dstHeight;
+  if (scale != 1.0f) {
+    if (aDX + aDWidth > (PRInt32)origDWidth) {
+      z = aDX + aDWidth - origDWidth - origDX;
+      aDWidth -= z;
+      aSWidth -= z*widthScale;
+    }
+
+    if (aDX < origDX) {
+      z = aDX - origDX;
+      aDWidth += z;
+      aSWidth += z*widthScale;
+      aSX -= z*widthScale;
+      aDX = origDX;
+    }
+
+    if (aDY + aDHeight > (PRInt32)origDHeight) {
+      z = aDY + aDHeight - origDHeight - origDY;
+      aDHeight -= z;
+      aSHeight -= z*heightScale;
+    }
+
+    if (aDY < origDY) {
+      z = aDY - origDY;
+      aDHeight += z;
+      aSHeight += z*heightScale;
+      aSY -= z*heightScale;
+      aDY = origDY;
+    }
+  }
+
+  if (aDWidth <= 0 || aDHeight <= 0 || aSWidth <= 0 || aSHeight <= 0) {
+    return NS_OK;
+  }
+
   // clip to drawing surface
   nsDrawingSurfaceGTK *drawing = (nsDrawingSurfaceGTK*)aSurface;
   PRUint32 surfaceWidth, surfaceHeight;
   drawing->GetDimensions(&surfaceWidth, &surfaceHeight);
+  origDWidth = surfaceWidth;
+  origDHeight = surfaceHeight;
+  origDX = 0;
+  origDY = 0;
 
-  if (aDX + aDWidth > (PRInt32)surfaceWidth) {
-    z = aDX + aDWidth - surfaceWidth;
+  if (aDX + aDWidth > (PRInt32)origDWidth) {
+    z = aDX + aDWidth - origDWidth - origDX;
     aDWidth -= z;
-    aSWidth -= z*srcWidth/dstWidth;
+    aSWidth -= z*widthScale;
   }
 
-  if (aDX < 0) {
-    aDWidth += aDX;
-    aSWidth += aDX*srcWidth/dstWidth;
-    aSX -= aDX*srcWidth/dstWidth;
-    aDX = 0;
+  if (aDX < origDX) {
+    z = aDX - origDX;
+    aDWidth += z;
+    aSWidth += z*widthScale;
+    aSX -= z*widthScale;
+    aDX = origDX;
   }
 
-  if (aDY + aDHeight > (PRInt32)surfaceHeight) {
-    z = aDY + aDHeight - surfaceHeight;
+  if (aDY + aDHeight > (PRInt32)origDHeight) {
+    z = aDY + aDHeight - origDHeight - origDY;
     aDHeight -= z;
-    aSHeight -= z*srcHeight/dstHeight;
+    aSHeight -= z*heightScale;
   }
 
-  if (aDY < 0) {
-    aDHeight += aDY;
-    aSHeight += aDY*srcHeight/dstHeight;
-    aSY -= aDY*srcHeight/dstHeight;
-    aDY = 0;
+  if (aDY < origDY) {
+    z = aDY - origDY;
+    aDHeight += z;
+    aSHeight += z*heightScale;
+    aSY -= z*heightScale;
+    aDY = origDY;
   }
 
   if (aDWidth <= 0 || aDHeight <= 0 || aSWidth <= 0 || aSHeight <= 0) {
     return NS_OK;
   }
 
   if ((srcWidth != dstWidth) || (srcHeight != dstHeight)) {
     GdkPixmap *pixmap = 0;
Index: mozilla/gfx/src/ps/nsDeviceContextPS.h
===================================================================
--- mozilla.orig/gfx/src/ps/nsDeviceContextPS.h
+++ mozilla/gfx/src/ps/nsDeviceContextPS.h
@@ -97,16 +97,17 @@
   NS_IMETHOD  SetSpec(nsIDeviceContextSpec *aSpec);
 
   nsPostScriptObj*    GetPrintContext() { return mPSObj; }
   nsHashtable*        GetPSFontGeneratorList() { return mPSFontGeneratorList; }
   PRBool               mFTPEnable;
 
   PRBool      CheckDPIChange();
   NS_IMETHOD  InitForPrinting(nsIDeviceContextSpec *aSpec);
+  PRBool      SetPixelScale(float scale);
 
 protected:
   virtual     ~nsDeviceContextPS();
   
   nsIDrawingSurface*       mSurface;
   PRUint32               mDepth;
   nsCOMPtr<nsIDeviceContextSpec>  mSpec;
   nsCOMPtr<nsIDeviceContext>      mParentDeviceContext;
Index: mozilla/gfx/public/nsIFontMetrics.h
===================================================================
--- mozilla.orig/gfx/public/nsIFontMetrics.h
+++ mozilla/gfx/public/nsIFontMetrics.h
@@ -228,16 +228,21 @@
    */
   NS_IMETHOD  GetAveCharWidth(nscoord& aAveCharWidth) = 0;
 
   /**
    * Returns the often needed width of the space character
    */
   NS_IMETHOD  GetSpaceWidth(nscoord& aSpaceCharWidth) = 0;
 
+  /**
+   * DPI Value
+   */
+  PRInt32 mP2A;
+
 protected:
 
   nsFont mFont;		// The font for this metrics object.
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIFontMetrics, NS_IFONT_METRICS_IID)
 
 #endif /* nsIFontMetrics_h___ */
Index: mozilla/gfx/src/thebes/nsThebesFontMetrics.h
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesFontMetrics.h
+++ mozilla/gfx/src/thebes/nsThebesFontMetrics.h
@@ -197,14 +197,13 @@
     friend class AutoTextRun;
 
     nsRefPtr<gfxFontGroup> mFontGroup;
     gfxFontStyle *mFontStyle;
 
 private:
     nsThebesDeviceContext *mDeviceContext;
     nsCOMPtr<nsIAtom> mLangGroup;
-    PRInt32 mP2A;
     PRPackedBool mIsRightToLeft;
     PRPackedBool mTextRunRTL;
 };
 
 #endif /* NSTHEBESFONTMETRICS__H__ */
Index: mozilla/gfx/src/ps/nsDeviceContextPS.cpp
===================================================================
--- mozilla.orig/gfx/src/ps/nsDeviceContextPS.cpp
+++ mozilla/gfx/src/ps/nsDeviceContextPS.cpp
@@ -570,8 +570,18 @@
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsDeviceContextPS::InitForPrinting(nsIDeviceContextSpec* spec)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+PRBool nsDeviceContextPS::SetPixelScale(float aScale)
+{
+  if (aScale != 0.0 && mPixelScale == aScale)
+    return PR_FALSE;
+  if (mPixelScale == 1.0)
+    mAppUnitsPerDevNotScaledPixel = mAppUnitsPerDevPixel;
+  mAppUnitsPerDevPixel = (PRInt32)((float)mAppUnitsPerDevNotScaledPixel / aScale);
+  mPixelScale = aScale;
+  return PR_TRUE;
+}
Index: mozilla/gfx/src/gtk/nsDeviceContextGTK.h
===================================================================
--- mozilla.orig/gfx/src/gtk/nsDeviceContextGTK.h
+++ mozilla/gfx/src/gtk/nsDeviceContextGTK.h
@@ -85,16 +85,17 @@
 
   NS_IMETHOD GetDepth(PRUint32& aDepth);
 
   NS_IMETHOD ClearCachedSystemFonts();
 
   static int prefChanged(const char *aPref, void *aClosure);
 
   virtual PRBool CheckDPIChange();
+  virtual PRBool SetPixelScale(float aScale);
 
 protected:
   nsresult   SetDPI(PRInt32 aPrefDPI = 96);
   
 private:
   PRUint32      mDepth;
   PRBool        mWriteable;
   PRUint32      mNumCells;
Index: mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.cpp
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
@@ -1527,19 +1527,18 @@
                                                    PRUint32 &aWidth)
 {
   return mFontMetrics->GetRangeWidth(aText, aLength, aStart, aEnd, aWidth);
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawImage(imgIContainer *aImage, const nsRect & twSrcRect, const nsRect & twDestRect)
 {
   UpdateGC();
-#define NS_RECT_FROM_TWIPS_RECT2(_r)   (nsRect(FROM_TWIPS_INT2((_r).x), FROM_TWIPS_INT2((_r).y), FROM_TWIPS_INT2((_r).width), FROM_TWIPS_INT2((_r).height)))
-#define NS_RECT_FROM_TWIPS_RECT3(_r)   (nsRect(FROM_TWIPS_INT((_r).x), FROM_TWIPS_INT((_r).y), FROM_TWIPS_INT((_r).width), FROM_TWIPS_INT((_r).height)))
   nsRect aDestRect = NS_RECT_FROM_TWIPS_RECT(twDestRect);
+  #define NS_RECT_FROM_TWIPS_RECT2(_r)   (nsRect(FROM_TWIPS_INT2((_r).x), FROM_TWIPS_INT2((_r).y), FROM_TWIPS_INT2((_r).width), FROM_TWIPS_INT2((_r).height)))
   nsRect aSrcRect = NS_RECT_FROM_TWIPS_RECT2(twSrcRect);
   //1,2,3... Some problems with images... stipes....;
   nsRect dr = aDestRect;
   mTranMatrix->TransformCoord(&dr.x, &dr.y, &dr.width, &dr.height);
 
   // We should NOT be transforming the source rect (which is based on the image
   // origin) using the rendering context's translation!
   // However, given that we are, remember that the transformation of a
Index: mozilla/layout/generic/nsGfxScrollFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsGfxScrollFrame.cpp
+++ mozilla/layout/generic/nsGfxScrollFrame.cpp
@@ -423,16 +423,19 @@
   if (aAssumeVScroll) {
     nsSize vScrollbarPrefSize = 
       mInner.mVScrollbarBox->GetPrefSize(NS_CONST_CAST(nsBoxLayoutState&, 
                                                        aState.mBoxState));
     availWidth = PR_MAX(0, availWidth - vScrollbarPrefSize.width);
   }
   // pixel align the content
   nsPresContext* presContext = PresContext();
+  if (presContext->TrueZoomMode() && aFirstPass) {
+    availWidth = availWidth * presContext->FullZoom();
+  }
   nscoord twp = nsPresContext::CSSPixelsToAppUnits(1);
   availWidth -=  availWidth % twp;
 
   if (!aFirstPass)
     mInner.mScrolledFrame->AddStateBits(NS_FRAME_IS_DIRTY);
 
   // We're forcing the padding on our scrolled frame, so let it know what that
   // padding is.
@@ -1419,20 +1422,25 @@
   }
 
   if (mIsRoot) {
     result = presContext->GetViewportOverflowOverride();
 
     nsCOMPtr<nsISupports> container = presContext->GetContainer();
     nsCOMPtr<nsIScrollable> scrollable = do_QueryInterface(container);
     if (scrollable) {
+      if (presContext->TrueZoomMode()) {
+        result.mHorizontal = NS_STYLE_OVERFLOW_AUTO;
+        result.mVertical = NS_STYLE_OVERFLOW_AUTO;
+      } else {
       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_X,
                        result.mHorizontal);
       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_Y,
                        result.mVertical);
+      }
     }
   } else {
     const nsStyleDisplay *disp = mOuter->GetStyleDisplay();
     result.mHorizontal = disp->mOverflowX;
     result.mVertical = disp->mOverflowY;
   }
 
   NS_ASSERTION(result.mHorizontal != NS_STYLE_OVERFLOW_VISIBLE &&
