# Bug 4821 (pagezoom)  Full zooming not functional (images, objects as well as text) (page zoom like opera)
#
Index: mozilla/docshell/base/nsDocShell.cpp
===================================================================
--- mozilla.orig/docshell/base/nsDocShell.cpp
+++ mozilla/docshell/base/nsDocShell.cpp
@@ -5424,18 +5424,28 @@
         if (doc)
             request = doc->GetChannel();
         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
     }
 
     nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV(do_QueryInterface(mContentViewer));
     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV(do_QueryInterface(viewer));
     float zoom = 1.0;
-    if (oldMUDV && newMUDV)
+    float fullZoom = 1.0;
+    if (oldMUDV && newMUDV) {
         oldMUDV->GetTextZoom(&zoom);
+        newMUDV->GetFullZoom(&fullZoom);
+        //newMUDV->SetFullZoom(fullZoom);
+/*Ups not xulrunner build can't link with presContext....
+        Let see newMUDV->Set or oldMUDV->Set*/
+        nsCOMPtr<nsPresContext> presContext;
+        GetEldestPresContext(getter_AddRefs(presContext));
+        if (presContext)
+            presContext->SetFullZoom(fullZoom, PR_TRUE);
+    }
 
     // Protect against mLSHE going away via a load triggered from
     // pagehide or unload.
     nsCOMPtr<nsISHEntry> origLSHE = mLSHE;
 
     // Notify the old content viewer that it's being hidden.
     FirePageHideNotification(!mSavingOldViewer);
 
Index: mozilla/gfx/src/thebes/nsThebesDeviceContext.cpp
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesDeviceContext.cpp
+++ mozilla/gfx/src/thebes/nsThebesDeviceContext.cpp
@@ -397,17 +397,17 @@
 
     aFont->name = fontName;
     aFont->style = fontStyle.style;
     aFont->systemFont = fontStyle.systemFont;
     aFont->variant = NS_FONT_VARIANT_NORMAL;
     aFont->familyNameQuirks = fontStyle.familyNameQuirks;
     aFont->weight = fontStyle.weight;
     aFont->decorations = NS_FONT_DECORATION_NONE;
-    aFont->size = NSFloatPixelsToAppUnits(fontStyle.size, AppUnitsPerDevPixel());
+    aFont->size = NSFloatPixelsToAppUnits(fontStyle.size, AppUnitsPerCSSPixel() * 96);
     //aFont->langGroup = fontStyle.langGroup;
     aFont->sizeAdjust = fontStyle.sizeAdjust;
 
     return rv;
 }
 
 NS_IMETHODIMP
 nsThebesDeviceContext::CheckFontExistence(const nsString& aFaceName)
@@ -744,15 +744,24 @@
     if (aScale <= 0) {
         NS_NOTREACHED("Invalid pixel scale value");
         return PR_FALSE;
     }
     PRInt32 oldAppUnitsPerDevPixel = mAppUnitsPerDevPixel;
     mPixelScale = aScale;
     UpdateScaledAppUnits();
     return oldAppUnitsPerDevPixel != mAppUnitsPerDevPixel;
+/*
+    if (aScale != 0.0 && mPixelScale == aScale)
+        return PR_FALSE;
+    if (mPixelScale == 1.0)
+        mAppUnitsPerDevNotScaledPixel = mAppUnitsPerDevPixel;
+    mAppUnitsPerDevPixel = (PRInt32)((float)mAppUnitsPerDevNotScaledPixel / aScale);
+    mPixelScale = aScale;
+    return PR_TRUE;
+*/
 }
 
 void
 nsThebesDeviceContext::UpdateScaledAppUnits()
 {
     mAppUnitsPerDevPixel = PR_MAX(1, PRInt32(float(mAppUnitsPerDevNotScaledPixel) / mPixelScale));
 }
Index: mozilla/layout/base/nsDocumentViewer.cpp
===================================================================
--- mozilla.orig/layout/base/nsDocumentViewer.cpp
+++ mozilla/layout/base/nsDocumentViewer.cpp
@@ -407,16 +407,17 @@
   nsCOMPtr<nsIDOMFocusListener> mFocusListener;
 
   nsCOMPtr<nsIContentViewer> mPreviousViewer;
   nsCOMPtr<nsISHEntry> mSHEntry;
 
   nsIWidget* mParentWidget;          // purposely won't be ref counted
 
   float mTextZoom;      // Text zoom, defaults to 1.0
+  float mFullZoom;      // Full layout zoom, defaults to 1.0
 
   PRInt16 mNumURLStarts;
   PRInt16 mDestroyRefCount;    // a second "refcount" for the document viewer's "destroy"
 
   unsigned      mEnableRendering : 1;
   unsigned      mStopped : 1;
   unsigned      mLoaded : 1;
   unsigned      mDeferredWindowClose : 1;
@@ -504,17 +505,17 @@
 
 #endif // NS_PRINTING
 }
 
 // Note: operator new zeros our memory, so no need to init things to null.
 DocumentViewerImpl::DocumentViewerImpl()
   : mTextZoom(1.0),
     mIsSticky(PR_TRUE),
-    mHintCharsetSource(kCharsetUninitialized)
+    mHintCharsetSource(kCharsetUninitialized), mFullZoom(1.0)
 {
   PrepareToStartLoad();
 }
 
 NS_IMPL_ADDREF(DocumentViewerImpl)
 NS_IMPL_RELEASE(DocumentViewerImpl)
 
 NS_INTERFACE_MAP_BEGIN(DocumentViewerImpl)
@@ -683,16 +684,17 @@
   mWindow->GetBounds(bounds);
 
   nscoord width = mPresContext->DevPixelsToAppUnits(bounds.width);
   nscoord height = mPresContext->DevPixelsToAppUnits(bounds.height);
 
   mViewManager->DisableRefresh();
   mViewManager->SetWindowDimensions(width, height);
   mPresContext->SetTextZoom(mTextZoom);
+  mFullZoom = mPresContext->FullZoom();
 
   // Setup default view manager background color
 
   // This may be overridden by the docshell with the background color
   // for the last document loaded into the docshell
   mViewManager->SetDefaultBackgroundColor(mPresContext->DefaultBackgroundColor());
 
   if (aDoInitialReflow) {
@@ -2649,43 +2651,50 @@
             (*aFunc)(markupCV, aClosure);
           }
         }
       }
     }
   }
 }
 
-struct TextZoomInfo
+struct ZoomInfo
 {
-  float mTextZoom;
+  float mZoom;
 };
 
 static void
 SetChildTextZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
 {
-  struct TextZoomInfo* textZoomInfo = (struct TextZoomInfo*) aClosure;
-  aChild->SetTextZoom(textZoomInfo->mTextZoom);
+  struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
+  aChild->SetTextZoom(ZoomInfo->mZoom);
+}
+
+static void
+SetChildFullZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
+{
+  struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
+  aChild->SetFullZoom(ZoomInfo->mZoom);
 }
 
 NS_IMETHODIMP
 DocumentViewerImpl::SetTextZoom(float aTextZoom)
 {
   mTextZoom = aTextZoom;
 
   if (mViewManager) {
     mViewManager->BeginUpdateViewBatch();
   }
       
   // Set the text zoom on all children of mContainer (even if our zoom didn't
   // change, our children's zoom may be different, though it would be unusual).
   // Do this first, in case kids are auto-sizing and post reflow commands on
   // our presshell (which should be subsumed into our own style change reflow).
-  struct TextZoomInfo textZoomInfo = { aTextZoom };
-  CallChildren(SetChildTextZoom, &textZoomInfo);
+  struct ZoomInfo ZoomInfo = { aTextZoom };
+  CallChildren(SetChildTextZoom, &ZoomInfo);
 
   // Now change our own zoom
   if (mPresContext && aTextZoom != mPresContext->TextZoom()) {
       mPresContext->SetTextZoom(aTextZoom);
   }
 
   if (mViewManager) {
     mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
@@ -2703,28 +2712,47 @@
 
   *aTextZoom = mTextZoom;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DocumentViewerImpl::SetFullZoom(float aFullZoom)
 {
-  if (mPresContext) {
+  mFullZoom = aFullZoom;
+
+  if (mViewManager) {
+    mViewManager->BeginUpdateViewBatch();
+  }
+
+  // Set the full zoom on all children of mContainer (even if our zoom didn't
+  // change, our children's zoom may be different, though it would be unusual).
+  // Do this first, in case kids are auto-sizing and post reflow commands on
+  // our presshell (which should be subsumed into our own style change reflow).
+  struct ZoomInfo ZoomInfo = { aFullZoom };
+  CallChildren(SetChildFullZoom, &ZoomInfo);
+
+  // Now change our own zoom
+
+  if (mPresContext && aFullZoom != mPresContext->FullZoom()) {
       mPresContext->SetFullZoom(aFullZoom);
   }
 
+  if (mViewManager) {
+    mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DocumentViewerImpl::GetFullZoom(float* aFullZoom)
 {
   NS_ENSURE_ARG_POINTER(aFullZoom);
-  *aFullZoom = mPresContext ? mPresContext->GetFullZoom() : 1.0;
+  *aFullZoom = mPresContext ? mFullZoom : 1.0;
   return NS_OK;
 }
 
 static void
 SetChildAuthorStyleDisabled(nsIMarkupDocumentViewer* aChild, void* aClosure)
 {
   PRBool styleDisabled  = *static_cast<PRBool*>(aClosure);
   aChild->SetAuthorStyleDisabled(styleDisabled);
Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -176,17 +176,18 @@
                           NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultMonospaceFont("monospace", NS_FONT_STYLE_NORMAL,
                           NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultCursiveFont("cursive", NS_FONT_STYLE_NORMAL,
                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultFantasyFont("fantasy", NS_FONT_STYLE_NORMAL,
                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
     mCanPaginatedScroll(PR_FALSE),
-    mIsRootPaginatedDocument(PR_FALSE)
+    mIsRootPaginatedDocument(PR_FALSE),
+    mFullZoom(1.0f), mTrueZoomMode(PR_FALSE)
 {
   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
   // bother initializing members to 0.
 
   mDoScaledTwips = PR_TRUE;
 
   SetBackgroundImageDraw(PR_TRUE);		// always draw the background
   SetBackgroundColorDraw(PR_TRUE);
@@ -273,16 +274,19 @@
 #ifdef IBMBIDI
   nsContentUtils::UnregisterPrefCallback("bidi.", PrefChangedCallback, this);
 
   delete mBidiUtils;
 #endif // IBMBIDI
   nsContentUtils::UnregisterPrefCallback("layout.css.dpi",
                                          nsPresContext::PrefChangedCallback,
                                          this);
+  nsContentUtils::UnregisterPrefCallback("layout.full.true.zoom.mode",
+                                         nsPresContext::PrefChangedCallback,
+                                         this);
 
   NS_IF_RELEASE(mDeviceContext);
   NS_IF_RELEASE(mLookAndFeel);
   NS_IF_RELEASE(mLangGroup);
 }
 
 NS_IMPL_ISUPPORTS1(nsPresContext, nsIObserver)
 
@@ -526,16 +530,20 @@
 
   // * document colors
   GetDocumentColorPreferences();
 
   // * link colors
   mUnderlineLinks =
     nsContentUtils::GetBoolPref("browser.underline_anchors", mUnderlineLinks);
 
+  // True Zoom Mode
+  mTrueZoomMode =
+    nsContentUtils::GetBoolPref("layout.full.true.zoom.mode", mTrueZoomMode);
+
   nsAdoptingCString colorStr =
     nsContentUtils::GetCharPref("browser.anchor_color");
 
   if (!colorStr.IsEmpty()) {
     mLinkColor = MakeColorPref(colorStr);
   }
 
   colorStr =
@@ -673,24 +681,31 @@
 
 void
 nsPresContext::PreferenceChanged(const char* aPrefName)
 {
   if (!nsCRT::strcmp(aPrefName, "layout.css.dpi")) {
     nsRect bounds(mVisibleArea);
     bounds *= 1.0f / AppUnitsPerDevPixel();
     if (mDeviceContext->CheckDPIChange() && mShell) {
-      mDeviceContext->FlushFontCache();
+      // ROMAXA mDeviceContext->FlushFontCache();
 
-      nsIViewManager* vm = GetViewManager();
       nscoord width = DevPixelsToAppUnits(bounds.width);
       nscoord height = DevPixelsToAppUnits(bounds.height);
-      vm->SetWindowDimensions(width, height);
-
-      ClearStyleDataAndReflow();
+      if (nsContentUtils::GetBoolPref("layout.full.zoom.mode.fast", PR_FALSE)) {
+        /* XXX this way of reflow works 3x faster, but buggy
+          Internal scrolbars also resized (Iframe, textarea...)
+        */
+        mShell->FrameNeedsReflow(mShell->GetRootFrame(), nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+        mShell->ResizeReflow(width, height);
+      } else {
+        nsIViewManager* vm = GetViewManager();
+        vm->SetWindowDimensions(width, height);
+        ClearStyleDataAndReflow();
+      }
     }
     return;
   }
   if (!nsCRT::strcmp(aPrefName, sMinFontSizePref)) {
     mAutoQualityMinFontSizePixelsPref = nsContentUtils::GetIntPref(sMinFontSizePref);
     ClearStyleDataAndReflow();
     return;
   }
@@ -733,16 +748,18 @@
 nsPresContext::Init(nsIDeviceContext* aDeviceContext)
 {
   NS_ASSERTION(!(mInitialized == PR_TRUE), "attempt to reinit pres context");
   NS_ENSURE_ARG(aDeviceContext);
 
   mDeviceContext = aDeviceContext;
   NS_ADDREF(mDeviceContext);
 
+  mFullZoom = mDeviceContext->GetPixelScale();
+
   if (!mImageLoaders.Init())
     return NS_ERROR_OUT_OF_MEMORY;
   
   // Get the look and feel service here; default colors will be initialized
   // from calling GetUserPreferences() when we get a presshell.
   nsresult rv = CallGetService(kLookAndFeelCID, &mLookAndFeel);
   if (NS_FAILED(rv)) {
     NS_ERROR("LookAndFeel service must be implemented for this toolkit");
@@ -781,16 +798,19 @@
                                        this);
 #ifdef IBMBIDI
   nsContentUtils::RegisterPrefCallback("bidi.", PrefChangedCallback,
                                        this);
 #endif
   nsContentUtils::RegisterPrefCallback("layout.css.dpi",
                                        nsPresContext::PrefChangedCallback,
                                        this);
+  nsContentUtils::RegisterPrefCallback("layout.full.true.zoom.mode",
+                                       nsPresContext::PrefChangedCallback,
+                                       this);
 
   // This is observed thanks to the browser.display. observer above.
   mAutoQualityMinFontSizePixelsPref = nsContentUtils::GetIntPref(sMinFontSizePref);
 
   rv = mEventManager->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   mEventManager->SetPresContext(this);
@@ -1078,31 +1098,40 @@
 
 const nsFont*
 nsPresContext::GetDefaultFontExternal(PRUint8 aFontID) const
 {
   return GetDefaultFontInternal(aFontID);
 }
 
 void
-nsPresContext::SetFullZoom(float aZoom)
+nsPresContext::SetFullZoom(float aZoom, PRBool onlyDevice)
 {
   nsPresContext* rootPresContext = RootPresContext();
   if (rootPresContext != this) {
     NS_WARNING("Zoom set on non-root prescontext");
     rootPresContext->SetFullZoom(aZoom);
     return;
   }
   nsRect bounds(mVisibleArea);
   bounds.ScaleRoundPreservingCentersInverse(AppUnitsPerDevPixel());
-  if (!mShell || !mDeviceContext->SetPixelScale(aZoom))
+  if (!mShell || !mDeviceContext->SetPixelScale(aZoom) || onlyDevice)
     return;
-  mDeviceContext->FlushFontCache();
+  mFullZoom = aZoom;
+  // mDeviceContext->FlushFontCache();
   nscoord width = DevPixelsToAppUnits(bounds.width);
   nscoord height = DevPixelsToAppUnits(bounds.height);
+  if (nsContentUtils::GetBoolPref("layout.full.zoom.mode.fast", PR_FALSE)) {
+    /* XXX this way of reflow works 3x faster, but buggy
+       Internal scrolbars also resized (Iframe, textarea...)
+    */
+    mShell->FrameNeedsReflow(mShell->GetRootFrame(), nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+    mShell->ResizeReflow(width, height);
+    return;
+  }
   GetViewManager()->SetWindowDimensions(width, height);
   ClearStyleDataAndReflow();
 }
 
 imgIRequest*
 nsPresContext::LoadImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
 {
   // look and see if we have a loader for the target frame.
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -457,28 +457,32 @@
   float GetPrintPreviewScale() { return mPPScale; }
   void SetPrintPreviewScale(float aScale) { mPPScale = aScale; }
 
   nsIDeviceContext* DeviceContext() { return mDeviceContext; }
   nsIEventStateManager* EventStateManager() { return mEventManager; }
   nsIAtom* GetLangGroup() { return mLangGroup; }
 
   float TextZoom() { return mTextZoom; }
+  float FullZoom() { return mFullZoom; }
+  PRBool TrueZoomMode() { return mTrueZoomMode; }
   void SetTextZoom(float aZoom) {
     mTextZoom = aZoom;
     ClearStyleDataAndReflow();
   }
 
   float GetFullZoom() {return mDeviceContext->GetPixelScale();}
   void SetFullZoom(float aZoom);
 
   nscoord GetAutoQualityMinFontSize() {
     return DevPixelsToAppUnits(mAutoQualityMinFontSizePixelsPref);
   }
   
+  void SetFullZoom(float aZoom, PRBool onlyDevice = PR_FALSE);
+
   static PRInt32 AppUnitsPerCSSPixel() { return nsIDeviceContext::AppUnitsPerCSSPixel(); }
   PRInt32 AppUnitsPerDevPixel() const  { return mDeviceContext->AppUnitsPerDevPixel(); }
   PRInt32 AppUnitsPerInch() const      { return mDeviceContext->AppUnitsPerInch(); }
 
   static nscoord CSSPixelsToAppUnits(PRInt32 aPixels)
   { return NSIntPixelsToAppUnits(aPixels,
                                  nsIDeviceContext::AppUnitsPerCSSPixel()); }
 
@@ -754,16 +758,17 @@
 
   nsILinkHandler*       mLinkHandler;   // [WEAK]
   nsIAtom*              mLangGroup;     // [STRONG]
 
   nsInterfaceHashtable<nsVoidPtrHashKey, nsImageLoader> mImageLoaders;
   nsWeakPtr             mContainer;
 
   float                 mTextZoom;      // Text zoom, defaults to 1.0
+  float                 mFullZoom;      // Text zoom, defaults to 1.0
   PRInt32               mAutoQualityMinFontSizePixelsPref;
 
 #ifdef IBMBIDI
   nsBidiPresUtils*      mBidiUtils;
 #endif
 
   nsCOMPtr<nsITheme> mTheme;
   nsCOMPtr<nsILanguageAtomService> mLangService;
@@ -831,16 +836,17 @@
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
   unsigned              mIsBidiSystem : 1;
 
 #endif
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
+  PRPackedBool          mTrueZoomMode : 1;
 
 
 protected:
 
   ~nsPresContext() NS_HIDDEN;
 
   // these are private, use the list in nsFont.h if you want a public list
   enum {
Index: mozilla/gfx/src/thebes/nsSystemFontsGTK2.cpp
===================================================================
--- mozilla.orig/gfx/src/thebes/nsSystemFontsGTK2.cpp
+++ mozilla/gfx/src/thebes/nsSystemFontsGTK2.cpp
@@ -225,17 +225,17 @@
     aFontStyle->weight = pango_font_description_get_weight(desc);
 
     float size = float(pango_font_description_get_size(desc) / PANGO_SCALE);
 
     // |size| is now either pixels or pango-points (not Mozilla-points!)
 
     if (!MOZ_pango_font_description_get_size_is_absolute(desc)) {
         // |size| is in pango-points, so convert to pixels.
-        size *= float(gfxPlatformGtk::DPI()) / 72.0f;
+        size *= 1.0f / 72.0f;
     }
 
     // |size| is now pixels
 
     aFontStyle->size = size;
   
     pango_font_description_free(desc);
 
Index: mozilla/gfx/public/nsIFontMetrics.h
===================================================================
--- mozilla.orig/gfx/public/nsIFontMetrics.h
+++ mozilla/gfx/public/nsIFontMetrics.h
@@ -228,16 +228,21 @@
    */
   NS_IMETHOD  GetAveCharWidth(nscoord& aAveCharWidth) = 0;
 
   /**
    * Returns the often needed width of the space character
    */
   NS_IMETHOD  GetSpaceWidth(nscoord& aSpaceCharWidth) = 0;
 
+  /**
+   * DPI Value
+   */
+  PRInt32 mP2A;
+
 protected:
 
   nsFont mFont;		// The font for this metrics object.
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIFontMetrics, NS_IFONT_METRICS_IID)
 
 #endif /* nsIFontMetrics_h___ */
Index: mozilla/gfx/src/thebes/nsThebesFontMetrics.h
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesFontMetrics.h
+++ mozilla/gfx/src/thebes/nsThebesFontMetrics.h
@@ -197,14 +197,13 @@
     friend class AutoTextRun;
 
     nsRefPtr<gfxFontGroup> mFontGroup;
     gfxFontStyle *mFontStyle;
 
 private:
     nsThebesDeviceContext *mDeviceContext;
     nsCOMPtr<nsIAtom> mLangGroup;
-    PRInt32 mP2A;
     PRPackedBool mIsRightToLeft;
     PRPackedBool mTextRunRTL;
 };
 
 #endif /* NSTHEBESFONTMETRICS__H__ */
Index: mozilla/layout/generic/nsGfxScrollFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsGfxScrollFrame.cpp
+++ mozilla/layout/generic/nsGfxScrollFrame.cpp
@@ -422,16 +422,18 @@
 
   if (aAssumeVScroll) {
     nsSize vScrollbarPrefSize = 
       mInner.mVScrollbarBox->GetPrefSize(const_cast<nsBoxLayoutState&>(aState.mBoxState));
     availWidth = PR_MAX(0, availWidth - vScrollbarPrefSize.width);
   }
   // pixel align the content
   nsPresContext* presContext = PresContext();
+  if (presContext->TrueZoomMode() && aFirstPass)
+    availWidth = availWidth * presContext->FullZoom();
   nscoord twp = nsPresContext::CSSPixelsToAppUnits(1);
   availWidth -=  availWidth % twp;
 
   if (!aFirstPass)
     mInner.mScrolledFrame->AddStateBits(NS_FRAME_IS_DIRTY);
 
   // We're forcing the padding on our scrolled frame, so let it know what that
   // padding is.
@@ -1416,20 +1418,25 @@
   }
 
   if (mIsRoot) {
     result = presContext->GetViewportOverflowOverride();
 
     nsCOMPtr<nsISupports> container = presContext->GetContainer();
     nsCOMPtr<nsIScrollable> scrollable = do_QueryInterface(container);
     if (scrollable) {
+      if (presContext->TrueZoomMode()) {
+        result.mHorizontal = NS_STYLE_OVERFLOW_AUTO;
+        result.mVertical = NS_STYLE_OVERFLOW_AUTO;
+      } else {
       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_X,
                        result.mHorizontal);
       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_Y,
                        result.mVertical);
+      }
     }
   } else {
     const nsStyleDisplay *disp = mOuter->GetStyleDisplay();
     result.mHorizontal = disp->mOverflowX;
     result.mVertical = disp->mOverflowY;
   }
 
   NS_ASSERTION(result.mHorizontal != NS_STYLE_OVERFLOW_VISIBLE &&
--- mozilla/layout/base/nsPresContext.h.orig	2007-08-02 11:11:19.000000000 +0300
+++ mozilla/layout/base/nsPresContext.h	2007-08-02 14:27:02.000000000 +0300
@@ -463,28 +463,26 @@ public:
 
   float TextZoom() { return mTextZoom; }
   float FullZoom() { return mFullZoom; }
   PRBool TrueZoomMode() { return mTrueZoomMode; }
   void SetTextZoom(float aZoom) {
     mTextZoom = aZoom;
     ClearStyleDataAndReflow();
   }
 
   float GetFullZoom() {return mDeviceContext->GetPixelScale();}
-  void SetFullZoom(float aZoom);
+  void SetFullZoom(float aZoom, PRBool onlyDevice = PR_FALSE);
 
   nscoord GetAutoQualityMinFontSize() {
     return DevPixelsToAppUnits(mAutoQualityMinFontSizePixelsPref);
   }
   
-  void SetFullZoom(float aZoom, PRBool onlyDevice = PR_FALSE);
-
   static PRInt32 AppUnitsPerCSSPixel() { return nsIDeviceContext::AppUnitsPerCSSPixel(); }
   PRInt32 AppUnitsPerDevPixel() const  { return mDeviceContext->AppUnitsPerDevPixel(); }
   PRInt32 AppUnitsPerInch() const      { return mDeviceContext->AppUnitsPerInch(); }
 
   static nscoord CSSPixelsToAppUnits(PRInt32 aPixels)
   { return NSIntPixelsToAppUnits(aPixels,
                                  nsIDeviceContext::AppUnitsPerCSSPixel()); }
 
   static nscoord CSSPixelsToAppUnits(float aPixels)
   { return NSFloatPixelsToAppUnits(aPixels,
