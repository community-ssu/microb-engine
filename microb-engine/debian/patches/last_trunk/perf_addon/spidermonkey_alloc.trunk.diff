# http://celtickane.com/projects/jsspeed.php 
Index: mozilla/js/src/jsstr.c
===================================================================
--- mozilla.orig/js/src/jsstr.c
+++ mozilla/js/src/jsstr.c
@@ -47,16 +47,17 @@
  * conversions at their index (argv[0], argv[1]).  This is a legitimate method
  * of rooting things that might lose their newborn root due to subsequent GC
  * allocations in the same native method.
  */
 #include "jsstddef.h"
 #include <stdlib.h>
 #include <string.h>
 #include "jstypes.h"
+#include "jsbit.h"
 #include "jsutil.h" /* Added by JSIFY */
 #include "jshash.h" /* Added by JSIFY */
 #include "jsprf.h"
 #include "jsapi.h"
 #include "jsarray.h"
 #include "jsatom.h"
 #include "jsbool.h"
 #include "jscntxt.h"
@@ -67,16 +68,27 @@
 #include "jsnum.h"
 #include "jsobj.h"
 #include "jsopcode.h"
 #include "jsregexp.h"
 #include "jsstr.h"
 
 #define JSSTRDEP_RECURSION_LIMIT        100
 
+/* This function is used to compute string allocation size            */
+/* Implemented from Dennis Forbes's blog idea with slight improvement */
+static inline
+size_t js_allocSize(size_t desired_size)
+{
+    JSIntn size;
+
+    JS_CEILING_LOG2(size, desired_size);
+    return JS_BIT(size + 1); /* sizeof(jschar) = 2 */
+} /* js_allocSize */
+
 size_t
 js_MinimizeDependentStrings(JSString *str, int level, JSString **basep)
 {
     JSString *base;
     size_t start, length;
 
     JS_ASSERT(JSSTRING_IS_DEPENDENT(str));
     base = JSSTRDEP_BASE(str);
@@ -136,25 +148,25 @@
         return left;
 
     JSSTRING_CHARS_AND_LENGTH(left, ls, ln);
     if (ln == 0)
         return right;
 
     if (!JSSTRING_IS_MUTABLE(left)) {
         /* We must copy if left does not own a buffer to realloc. */
-        s = (jschar *) JS_malloc(cx, (ln + rn + 1) * sizeof(jschar));
+        s = (jschar *) JS_malloc(cx, js_allocSize(ln + rn + 1));
         if (!s)
             return NULL;
         js_strncpy(s, ls, ln);
         ldep = NULL;
     } else {
         /* We can realloc left's space and make it depend on our result. */
         JS_ASSERT(!JSSTRING_IS_DEPENDENT(left));
-        s = (jschar *) JS_realloc(cx, ls, (ln + rn + 1) * sizeof(jschar));
+        s = (jschar *) JS_realloc(cx, ls, js_allocSize(ln + rn + 1));
         if (!s)
             return NULL;
 
         /* Take care: right could depend on left! */
         lrdist = (size_t)(rs - ls);
         if (lrdist < ln)
             rs = s + lrdist;
         left->u.chars = ls = s;
@@ -165,17 +177,17 @@
     n = ln + rn;
     s[n] = 0;
     str = js_NewString(cx, s, n);
     if (!str) {
         /* Out of memory: clean up any space we (re-)allocated. */
         if (!ldep) {
             JS_free(cx, s);
         } else {
-            s = (jschar *) JS_realloc(cx, ls, (ln + 1) * sizeof(jschar));
+            s = (jschar *) JS_realloc(cx, ls, js_allocSize(ln + 1));
             if (s)
                 left->u.chars = s;
         }
     } else {
         JSSTRING_SET_MUTABLE(str);
 
         /* Morph left into a dependent prefix if we realloc'd its buffer. */
         if (ldep) {
@@ -1566,18 +1578,17 @@
     leftlen = cx->regExpStatics.lastMatch.chars - left;
     rdata->leftIndex = cx->regExpStatics.lastMatch.chars - JSSTRING_CHARS(str);
     rdata->leftIndex += cx->regExpStatics.lastMatch.length;
     if (!find_replen(cx, rdata, &replen))
         return JS_FALSE;
     growth = leftlen + replen;
     chars = (jschar *)
         (rdata->chars
-         ? JS_realloc(cx, rdata->chars, (rdata->length + growth + 1)
-                                        * sizeof(jschar))
+         ? JS_realloc(cx, rdata->chars, js_allocSize(rdata->length + growth + 1))
          : JS_malloc(cx, (growth + 1) * sizeof(jschar)));
     if (!chars)
         return JS_FALSE;
     rdata->chars = chars;
     rdata->length += growth;
     chars += rdata->index;
     rdata->index += growth;
     js_strncpy(chars, left, leftlen);
@@ -1653,17 +1664,17 @@
         do_replace(cx, &rdata, chars + leftlen);
         rdata.chars = chars;
         rdata.length = length;
     }
 
     rightlen = cx->regExpStatics.rightContext.length;
     length = rdata.length + rightlen;
     chars = (jschar *)
-        JS_realloc(cx, rdata.chars, (length + 1) * sizeof(jschar));
+        JS_realloc(cx, rdata.chars, js_allocSize(length + 1));
     if (!chars) {
         JS_free(cx, rdata.chars);
         ok = JS_FALSE;
         goto out;
     }
     js_strncpy(chars + rdata.length, cx->regExpStatics.rightContext.chars,
                rightlen);
     chars[length] = 0;
@@ -4605,17 +4616,17 @@
     size_t total;
     jschar *newchars;
 
     total = buf->length + length + 1;
     if (!buf->chars ||
         JS_HOWMANY(total, URI_CHUNK) > JS_HOWMANY(buf->length + 1, URI_CHUNK)) {
         total = JS_ROUNDUP(total, URI_CHUNK);
         newchars = (jschar *) JS_realloc(cx, buf->chars,
-                                         total * sizeof(jschar));
+                                         js_allocSize(total));
         if (!newchars)
             return JS_FALSE;
         buf->chars = newchars;
     }
     js_strncpy(buf->chars + buf->length, chars, length);
     buf->length += length;
     buf->chars[buf->length] = 0;
     return JS_TRUE;
@@ -4628,17 +4639,17 @@
     size_t n;
     JSString *str;
 
     /*
      * Shrinking realloc can fail (e.g., with a BSD-style allocator), but we
      * don't worry about that case here.
      */
     n = cb->length;
-    chars = (jschar *) JS_realloc(cx, cb->chars, (n + 1) * sizeof(jschar));
+    chars = (jschar *) JS_realloc(cx, cb->chars, js_allocSize(n + 1));
     if (!chars)
         chars = cb->chars;
     str = js_NewString(cx, chars, n);
     if (!str)
         return JS_FALSE;
 
     /* Successful allocation transfer ownership of cb->chars to the string. */
 #ifdef DEBUG
