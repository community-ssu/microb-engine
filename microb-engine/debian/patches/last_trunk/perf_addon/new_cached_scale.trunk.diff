Index: mozilla/gfx/src/thebes/nsThebesImage.h
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesImage.h
+++ mozilla/gfx/src/thebes/nsThebesImage.h
@@ -87,26 +87,29 @@
 
     virtual PRInt8 GetAlphaDepth();
     virtual void* GetBitInfo();
     NS_IMETHOD LockImagePixels(PRBool aMaskPixels);
     NS_IMETHOD UnlockImagePixels(PRBool aMaskPixels);
 
     NS_IMETHOD GetSurface(gfxASurface **aSurface) {
         *aSurface = ThebesSurface();
+        if (!*aSurface)
+            return NS_ERROR_FAILURE;
         NS_ADDREF(*aSurface);
         return NS_OK;
     }
 
     gfxASurface* ThebesSurface() {
         if (mOptSurface)
             return mOptSurface;
 
         return mImageSurface;
     }
+    nsresult DelayedOptimize(nsIDeviceContext* aContext, gfxFloat aScaleX = 1.0, gfxFloat aScaleY = 1.0);
 
 protected:
     static PRBool AllowedImageSize(PRInt32 aWidth, PRInt32 aHeight) {
         NS_ASSERTION(aWidth > 0, "invalid image width");
         NS_ASSERTION(aHeight > 0, "invalid image height");
 
         // reject over-wide or over-tall images
         const PRInt32 k64KLimit = 0x0000FFFF;
@@ -135,16 +138,20 @@
         return PR_TRUE;
     }
 
     gfxImageSurface::gfxImageFormat mFormat;
     PRInt32 mWidth;
     PRInt32 mHeight;
     PRInt32 mStride;
     nsRect mDecoded;
+    PRPackedBool mNeedOptimize;
+    PRPackedBool mScaleOptimized;
+    gfxFloat mScaleX;
+    gfxFloat mScaleY;
     PRPackedBool mImageComplete;
     PRPackedBool mSinglePixel;
 
     gfxRGBA mSinglePixelColor;
 
     nsRefPtr<gfxImageSurface> mImageSurface;
     nsRefPtr<gfxASurface> mOptSurface;
 #ifdef XP_WIN
Index: mozilla/gfx/src/thebes/nsThebesImage.cpp
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesImage.cpp
+++ mozilla/gfx/src/thebes/nsThebesImage.cpp
@@ -52,17 +52,21 @@
 
 nsThebesImage::nsThebesImage()
     : mFormat(gfxImageSurface::ImageFormatRGB24),
       mWidth(0),
       mHeight(0),
       mDecoded(0,0,0,0),
       mImageComplete(PR_FALSE),
       mSinglePixel(PR_FALSE),
-      mAlphaDepth(0)
+      mAlphaDepth(0),
+      mNeedOptimize(PR_FALSE),
+      mScaleX(1.0),
+      mScaleY(1.0),
+      mScaleOptimized(PR_FALSE)
 {
     static PRBool hasCheckedOptimize = PR_FALSE;
     if (!hasCheckedOptimize) {
         if (PR_GetEnv("MOZ_DISABLE_IMAGE_OPTIMIZE")) {
             gDisableOptimize = PR_TRUE;
         }
         hasCheckedOptimize = PR_TRUE;
     }
@@ -197,16 +201,22 @@
     if (!mImageComplete)
         mImageComplete = (mDecoded == nsRect(0, 0, mWidth, mHeight));
     return mImageComplete;
 }
 
 nsresult
 nsThebesImage::Optimize(nsIDeviceContext* aContext)
 {
+    mNeedOptimize = PR_TRUE;
+}
+
+nsresult
+nsThebesImage::DelayedOptimize(nsIDeviceContext* aContext, gfxFloat aScaleX, gfxFloat aScaleY)
+{
     if (gDisableOptimize)
         return NS_OK;
 
     if (mOptSurface || mSinglePixel)
         return NS_OK;
 
     if (mWidth == 1 && mHeight == 1) {
         // yeah, let's optimize this.
@@ -256,21 +266,26 @@
             mOptSurface = mWinSurface;
         }
     } else {
         mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface);
     }
 
     mWinSurface = nsnull;
 #else
-    mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface);
+    if (mImageSurface)
+        mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface, aScaleX, aScaleY);
+    mScaleX = aScaleX;
+    mScaleY = aScaleY;
+    if (mOptSurface && (mScaleX != 1.0 || mScaleY != 1.0))
+        mScaleOptimized = PR_TRUE;
+    else
+        mScaleOptimized = PR_FALSE;
 #endif
 
-    mImageSurface = nsnull;
-
     return NS_OK;
 }
 
 nsColorMap *
 nsThebesImage::GetColorMap()
 {
     return NULL;
 }
@@ -308,16 +323,18 @@
             context->SetColor(mSinglePixelColor);
         else
             context->SetSource(mOptSurface);
         context->Paint();
     }
     return NS_OK;
 }
 
+#include <math.h>
+
 NS_IMETHODIMP
 nsThebesImage::UnlockImagePixels(PRBool aMaskPixels)
 {
     if (aMaskPixels)
         return NS_ERROR_NOT_IMPLEMENTED;
     if (mImageSurface && mOptSurface) {
         // Don't need the pixel data anymore
         mImageSurface = nsnull;
@@ -361,16 +378,34 @@
     }
 
     gfxFloat xscale = aDestRect.size.width / aSourceRect.size.width;
     gfxFloat yscale = aDestRect.size.height / aSourceRect.size.height;
 
     gfxRect srcRect(aSourceRect);
     gfxRect destRect(aDestRect);
 
+    if (mNeedOptimize) {
+        DelayedOptimize(nsnull, xscale, yscale);
+        mNeedOptimize = PR_FALSE;
+    } else {
+        if (mOptSurface &&
+                (mScaleX != xscale && fabs(fabs(mScaleX) - fabs(xscale)) > 0.12) ||
+                (mScaleY != yscale && fabs(fabs(mScaleY) - fabs(yscale)) > 0.12)
+           ) {
+            mNeedOptimize = PR_TRUE;
+            mOptSurface = nsnull;
+            mScaleOptimized = PR_FALSE;
+            DelayedOptimize(nsnull, xscale, yscale);
+            mNeedOptimize = PR_FALSE;
+            if (mOptSurface)
+                mScaleOptimized = PR_TRUE;
+        }
+    }
+
     if (!GetIsImageComplete()) {
       srcRect = srcRect.Intersect(gfxRect(mDecoded.x, mDecoded.y,
                                           mDecoded.width, mDecoded.height));
 
       // This happens when mDecoded.width or height is zero. bug 368427.
       if (NS_UNLIKELY(srcRect.size.width == 0 || srcRect.size.height == 0))
           return NS_OK;
 
@@ -419,29 +454,34 @@
         srcRect.pos.y = 0.0;
         srcRect.size.width = dim.width;
         srcRect.size.height = dim.height;
 
         xscale = 1.0;
         yscale = 1.0;
     }
 
-    if (!pat) {
-        pat = new gfxPattern(ThebesSurface());
-    }
-
     gfxMatrix mat;
-    mat.Translate(srcRect.pos);
-    mat.Scale(1.0/xscale, 1.0/yscale);
+    if (mScaleOptimized) {
+        mat.Translate(gfxPoint(srcRect.pos.x * mScaleX, srcRect.pos.y * mScaleY));
+		} else {
+        mat.Translate(srcRect.pos);
+        mat.Scale(1.0/xscale, 1.0/yscale);
+		}
 
     /* Translate the start point of the image (srcRect.pos)
      * to coincide with the destination rectangle origin
      */
     mat.Translate(-destRect.pos);
 
+    gfxASurface* surface = ThebesSurface();
+    if (!surface)
+        return NS_ERROR_FAILURE;
+    if (!pat)
+      pat = new gfxPattern(surface);
     pat->SetMatrix(mat);
 
     // XXX bug 324698
 #ifndef XP_MACOSX
     if (xscale > 1.0 || yscale > 1.0) {
         // See bug 324698.  This is a workaround.
         //
         // Set the filter to CAIRO_FILTER_FAST if we're scaling up -- otherwise,
@@ -488,16 +528,36 @@
     nsRefPtr<gfxASurface> tmpSurfaceGrip;
 
     if (mSinglePixel && !hasPadding) {
         thebesContext->SetColor(mSinglePixelColor);
     } else {
         nsRefPtr<gfxASurface> surface;
         PRInt32 width, height;
 
+        gfxFloat scale = gfxFloat(dx->AppUnitsPerDevPixel()) /
+                         gfxFloat(nsIDeviceContext::AppUnitsPerCSSPixel());
+
+        if (mNeedOptimize) {
+            DelayedOptimize(nsnull, scale, scale);
+            mNeedOptimize = PR_FALSE;
+        } else {
+            if (mOptSurface &&
+               (mScaleX != scale && fabs(fabs(mScaleX) - fabs(scale)) > 0.12)
+            ) {
+                mNeedOptimize = PR_TRUE;
+                mOptSurface = nsnull;
+                mScaleOptimized = PR_FALSE;
+                DelayedOptimize(nsnull, scale, scale);
+                mNeedOptimize = PR_FALSE;
+                if (mOptSurface)
+                    mScaleOptimized = PR_TRUE;
+            }
+        }
+
         if (hasPadding) {
             /* Ugh we have padding; create a temporary surface that's the size of the surface + pad area,
              * and render the image into it first.  Then we'll tile that surface. */
             width = mWidth + xPadding;
             height = mHeight + yPadding;
 
             // Reject over-wide or over-tall images.
             if (!AllowedImageSize(width, height))
@@ -529,19 +589,18 @@
         gfxMatrix patMat;
         gfxPoint p0;
 
         p0.x = - floor(offset.x + 0.5);
         p0.y = - floor(offset.y + 0.5);
         // Scale factor to account for CSS pixels; note that the offset (and 
         // therefore p0) is in device pixels, while the width and height are in
         // CSS pixels.
-        gfxFloat scale = gfxFloat(dx->AppUnitsPerDevPixel()) /
-                         gfxFloat(nsIDeviceContext::AppUnitsPerCSSPixel());
-        patMat.Scale(scale, scale);
+        if (!mScaleOptimized)
+        patMat.Scale(1.0 / scale, 1.0 / scale);
         patMat.Translate(p0);
 
         pat = new gfxPattern(surface);
         pat->SetExtend(gfxPattern::EXTEND_REPEAT);
         pat->SetMatrix(patMat);
 
 #ifndef XP_MACOSX
         if (scale > 1.0) {
@@ -562,19 +621,24 @@
 
     return NS_OK;
 }
 
 /* This is only used by the GIF decoder, via gfxImageFrame::DrawTo */
 NS_IMETHODIMP
 nsThebesImage::DrawToImage(nsIImage* aDstImage, PRInt32 aDX, PRInt32 aDY, PRInt32 aDWidth, PRInt32 aDHeight)
 {
+    if (aDWidth <= 0.0 || aDHeight <= 0.0)
+        return NS_OK;
     nsThebesImage *dstThebesImage = static_cast<nsThebesImage*>(aDstImage);
 
-    nsRefPtr<gfxContext> dst = new gfxContext(dstThebesImage->ThebesSurface());
+    gfxASurface* surface = dstThebesImage->ThebesSurface();
+    if (!surface)
+        return NS_ERROR_FAILURE;
+    nsRefPtr<gfxContext> dst = new gfxContext(surface);
 
     dst->NewPath();
     // We don't use PixelSnappedRectangleAndSetPattern because if
     // these coords aren't already pixel aligned, we've lost
     // before we've even begun.
     dst->Translate(gfxPoint(aDX, aDY));
     dst->Rectangle(gfxRect(0, 0, aDWidth, aDHeight), PR_TRUE);
     dst->Scale(double(aDWidth)/mWidth, double(aDHeight)/mHeight);
Index: mozilla/gfx/thebes/src/gfxPlatform.cpp
===================================================================
--- mozilla.orig/gfx/thebes/src/gfxPlatform.cpp
+++ mozilla/gfx/thebes/src/gfxPlatform.cpp
@@ -59,16 +59,17 @@
 #include "nsServiceManagerUtils.h"
 
 #ifdef MOZ_ENABLE_GLITZ
 #include <stdlib.h>
 #endif
 
 #include "cairo.h"
 #include "lcms.h"
+#include "prenv.h"
 
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 
 gfxPlatform *gPlatform = nsnull;
 int gGlitzState = -1;
 static cmsHPROFILE gCMSOutputProfile = nsnull;
 static cmsHTRANSFORM gCMSRGBTransform = nsnull;
@@ -197,40 +198,58 @@
             }
         }
     }
 
     return PR_FALSE;    
 }
 
 already_AddRefed<gfxASurface>
-gfxPlatform::OptimizeImage(gfxImageSurface *aSurface)
+gfxPlatform::OptimizeImage(gfxImageSurface *aSurface, gfxFloat aScaleX, gfxFloat aScaleY)
 {
     const gfxIntSize& surfaceSize = aSurface->GetSize();
 
     gfxASurface::gfxImageFormat realFormat = aSurface->Format();
 
     if (realFormat == gfxASurface::ImageFormatARGB32) {
         // this might not really need alpha; figure that out
         if (!DoesARGBImageDataHaveAlpha(aSurface->Data(),
                                         surfaceSize.width,
                                         surfaceSize.height,
                                         aSurface->Stride()))
         {
             realFormat = gfxASurface::ImageFormatRGB24;
         }
     }
+#if 0
+	if (PR_GetEnv("MOZ_DISABLE_ALPHA_RENDER"))
+        realFormat = gfxASurface::ImageFormatRGB24;
+#endif
 
-    nsRefPtr<gfxASurface> optSurface = CreateOffscreenSurface(surfaceSize, realFormat);
+    gfxIntSize nsurfaceSize((gfxFloat)surfaceSize.width * aScaleX, (gfxFloat)surfaceSize.height * aScaleY);
+	if (nsurfaceSize.width == 0 && surfaceSize.width)
+	  nsurfaceSize.width = 1;
+	if (nsurfaceSize.height == 0 && surfaceSize.height)
+	  nsurfaceSize.height = 1;
+    nsRefPtr<gfxASurface> optSurface = CreateOffscreenSurface(nsurfaceSize, realFormat);
 
     if (!optSurface)
         return nsnull;
 
     nsRefPtr<gfxContext> tmpCtx(new gfxContext(optSurface));
-    tmpCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
+
+    if (aScaleX != 1.0 || aScaleY != 1.0) {
+        tmpCtx->SetOperator(gfxContext::OPERATOR_CLEAR);
+		tmpCtx->Paint();
+        tmpCtx->SetOperator(gfxContext::OPERATOR_OVER);
+        tmpCtx->Scale(aScaleX, aScaleY);
+    }
+    else
+        tmpCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
+
     tmpCtx->SetSource(aSurface);
     tmpCtx->Paint();
 
     gfxASurface *ret = optSurface;
     NS_ADDREF(ret);
     return ret;
 }
 
Index: mozilla/gfx/thebes/public/gfxPlatform.h
===================================================================
--- mozilla.orig/gfx/thebes/public/gfxPlatform.h
+++ mozilla/gfx/thebes/public/gfxPlatform.h
@@ -86,17 +86,17 @@
      * and image format.  If fastPixelAccess is TRUE,
      * create a surface that is optimized for rapid pixel
      * changing.
      */
     virtual already_AddRefed<gfxASurface> CreateOffscreenSurface(const gfxIntSize& size,
                                                                  gfxASurface::gfxImageFormat imageFormat) = 0;
 
 
-    virtual already_AddRefed<gfxASurface> OptimizeImage(gfxImageSurface *aSurface);
+    virtual already_AddRefed<gfxASurface> OptimizeImage(gfxImageSurface *aSurface, gfxFloat aScaleX = 1.0, gfxFloat aScaleY = 1.0);
 
     /*
      * Font bits
      */
 
     /**
      * Fill aListOfFonts with the results of querying the list of font names
      * that correspond to the given language group or generic font family
Index: mozilla/gfx/thebes/src/gfxPlatformGtk.cpp
===================================================================
--- mozilla.orig/gfx/thebes/src/gfxPlatformGtk.cpp
+++ mozilla/gfx/thebes/src/gfxPlatformGtk.cpp
@@ -141,18 +141,20 @@
     }
 
     // XXX we really need a different interface here, something that passes
     // in more context, including the display and/or target surface type that
     // we should try to match
     Display* display = GDK_DISPLAY();
     if (!UseGlitz()) {
         GdkPixmap* pixmap = nsnull;
-        XRenderPictFormat* xrenderFormat =
-            XRenderFindStandardFormat(display, xrenderFormatID);
+        XRenderPictFormat* xrenderFormat = nsnull;
+//#ifndef __arm__
+//        xrenderFormat = XRenderFindStandardFormat(display, xrenderFormatID);
+//#endif
         if (!xrenderFormat) {
             // We don't have Render; see if we can just create a pixmap
             // of the requested depth.  Otherwise, create an Image surface.
             GdkVisual* vis;
 
             if (imageFormat == gfxASurface::ImageFormatRGB24) {
                 vis = gdk_rgb_get_visual();
                 if (vis->type == GDK_VISUAL_TRUE_COLOR)
