# It adds support to restart a download if disk gets full (out of space) while downloading.
# NOTE: It does not recover download across browser sessions. Once browser is closed, 
# downloads are gone.
Index: mozilla/uriloader/exthandler/nsExternalHelperAppService.h
===================================================================
--- mozilla.orig/uriloader/exthandler/nsExternalHelperAppService.h
+++ mozilla/uriloader/exthandler/nsExternalHelperAppService.h
@@ -472,16 +472,25 @@
    */
   nsCOMPtr<nsIFile> mFinalFileDestination;
 
   nsCOMPtr<nsIURI> mFinalUriDestination;
 
   char mDataBuffer[DATA_BUFFER_SIZE];
 
   /**
+   * XXX: Download recover stuff
+   */
+  PRBool mWriteError;
+  PRUint32 mReadButNotWrittenBytes;
+  PRUint32 mNotWrittenCount;
+  PRUint32 mOutputOffsetTemp;
+  const char *bufPtr;
+
+  /**
    * Creates the temporary file for the download and an output stream for it.
    * Upon successful return, both mTempFile and mOutStream will be valid.
    */
   nsresult SetUpTempFile(nsIChannel * aChannel);
   /**
    * When we download a helper app, we are going to retarget all load
    * notifications into our own docloader and load group instead of
    * using the window which initiated the load....RetargetLoadNotifications
Index: mozilla/uriloader/exthandler/nsExternalHelperAppService.cpp
===================================================================
--- mozilla.orig/uriloader/exthandler/nsExternalHelperAppService.cpp
+++ mozilla/uriloader/exthandler/nsExternalHelperAppService.cpp
@@ -117,16 +117,18 @@
 
 #include "nsIGlobalHistory.h" // to mark downloads as visited
 #include "nsIGlobalHistory2.h" // to mark downloads as visited
 
 #include "nsIDOMWindow.h"
 #include "nsIDOMWindowInternal.h"
 #include "nsIDocShell.h"
 
+#include "nsISeekableStream.h"
+
 #include "nsCRT.h"
 
 #include "nsMIMEInfoImpl.h"
 #include "nsLocalHandlerApp.h"
 
 #ifdef PR_LOGGING
 PRLogModuleInfo* nsExternalHelperAppService::mLog = nsnull;
 #endif
@@ -1486,16 +1488,18 @@
 , mShouldCloseWindow(PR_FALSE)
 , mReceivedDispositionInfo(PR_FALSE)
 , mStopRequestIssued(PR_FALSE)
 , mProgressListenerInitialized(PR_FALSE)
 , mReason(aReason)
 , mContentLength(-1)
 , mProgress(0)
 , mRequest(nsnull)
+, mWriteError(PR_FALSE)
+, mOutputOffsetTemp(0)
 {
 
   // make sure the extention includes the '.'
   if (!aTempFileExtension.IsEmpty() && aTempFileExtension.First() != '.')
     mTempFileExtension = PRUnichar('.');
   AppendUTF8toUTF16(aTempFileExtension, mTempFileExtension);
 
   // replace platform specific path separator and illegal characters to avoid any confusion
@@ -2076,59 +2080,134 @@
         }
     }
 }
 
 NS_IMETHODIMP nsExternalAppHandler::OnDataAvailable(nsIRequest *request, nsISupports * aCtxt,
                                                   nsIInputStream * inStr, PRUint32 sourceOffset, PRUint32 count)
 {
   nsresult rv = NS_OK;
+  PRBool readError = PR_FALSE;
   // first, check to see if we've been canceled....
   if (mCanceled) // then go cancel our underlying channel too
     return request->Cancel(NS_BINDING_ABORTED);
 
   // read the data out of the stream and write it to the temp file.
   if (mOutStream && count > 0)
   {
-    PRUint32 numBytesRead = 0; 
+    PRUint32 numBytesRead = 0;
     PRUint32 numBytesWritten = 0;
+
+    // XXX check if we had not written data in previous interaction,
+    // if so, write them before next interaction.
+    if (mWriteError) {
+
+      // seek to mOutputOffsetTemp
+      nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mOutStream);
+      if (seekable)
+        seekable->Seek(nsISeekableStream::NS_SEEK_SET, mOutputOffsetTemp);
+
+      rv = NS_ERROR_FAILURE;
+      do {
+        if(NS_SUCCEEDED (rv)) {
+          rv = inStr->Read(mDataBuffer, PR_MIN(mNotWrittenCount, DATA_BUFFER_SIZE - 1), &numBytesRead);
+          bufPtr = mDataBuffer;
+        } else {
+             rv = NS_OK;
+             numBytesRead = mReadButNotWrittenBytes;
+        }
+
+        while (NS_SUCCEEDED(rv) && numBytesRead) {
+
+          rv = mOutStream->Write(bufPtr, numBytesRead, &numBytesWritten);
+          if (!numBytesWritten || NS_FAILED (rv))
+            mWriteError = PR_TRUE;
+          else {
+            numBytesRead -= numBytesWritten;
+            mNotWrittenCount -= numBytesWritten;
+            mOutputOffsetTemp += numBytesWritten;
+            mProgress += numBytesWritten;
+            bufPtr += numBytesWritten;
+          }
+        }
+      } while(NS_SUCCEEDED(rv) && mNotWrittenCount > 0);
+    }
+
+    if (mWriteError) {
+      if (!mNotWrittenCount) {
+        mWriteError = PR_FALSE;
+        rv = NS_OK;
+      }
+    }
+
     mProgress += count;
-    PRBool readError = PR_TRUE;
+    readError = PR_FALSE;
     while (NS_SUCCEEDED(rv) && count > 0) // while we still have bytes to copy...
     {
+      PRUint32 numBytesRead = 0;
+
       readError = PR_TRUE;
       rv = inStr->Read(mDataBuffer, PR_MIN(count, DATA_BUFFER_SIZE - 1), &numBytesRead);
+
+      // XXX: now setting proper value to nNotWrittenCount
+      mNotWrittenCount = count;
+
       if (NS_SUCCEEDED(rv))
       {
         if (count >= numBytesRead)
           count -= numBytesRead; // subtract off the number of bytes we just read
         else
           count = 0;
+
         readError = PR_FALSE;
         // Write out the data until something goes wrong, or, it is
         // all written.  We loop because for some errors (e.g., disk
         // full), we get NS_OK with some bytes written, then an error.
         // So, we want to write again in that case to get the actual
         // error code.
-        const char *bufPtr = mDataBuffer; // Where to write from.
+        bufPtr = mDataBuffer; // Where to write from.
         while (NS_SUCCEEDED(rv) && numBytesRead)
         {
           numBytesWritten = 0;
+          // XXX: there is no such error yet
+          mWriteError = PR_FALSE;
           rv = mOutStream->Write(bufPtr, numBytesRead, &numBytesWritten);
           if (NS_SUCCEEDED(rv))
           {
             numBytesRead -= numBytesWritten;
             bufPtr += numBytesWritten;
+            // XXX
+            mOutputOffsetTemp += numBytesWritten;
+            mNotWrittenCount = count;
+
             // Force an error if (for some reason) we get NS_OK but
             // no bytes written.
             if (!numBytesWritten)
             {
               rv = NS_ERROR_FAILURE;
             }
           }
+          else
+          {
+             // XXX: how many bytes got written still ?
+            mWriteError = PR_TRUE;
+
+            nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mOutStream);
+            if (seekable) {
+              PRInt64 offsetAfter;
+              seekable->Tell(&offsetAfter);
+
+              PRUint32 diff = (offsetAfter - mOutputOffsetTemp);
+
+              mReadButNotWrittenBytes = numBytesRead - diff;
+              bufPtr += diff;
+              mOutputOffsetTemp += diff;
+              mNotWrittenCount -= diff;
+            }
+          }
         }
       }
     }
     if (NS_SUCCEEDED(rv))
     {
       // Send progress notification.
       if (mWebProgressListener)
       {
@@ -2138,20 +2217,25 @@
     else
     {
       // An error occurred, notify listener.
       nsAutoString tempFilePath;
       if (mTempFile)
         mTempFile->GetPath(tempFilePath);
       SendStatusChange(readError ? kReadError : kWriteError, rv, request, tempFilePath);
 
-      // Cancel the download.
-      Cancel(rv);
+      // Cancel the download if error is different from write error.
+      // Cancel(rv);
+
     }
   }
+
+  if ((mWriteError || readError) && NS_FAILED (rv))
+    return NS_OK;
+
   return rv;
 }
 
 NS_IMETHODIMP nsExternalAppHandler::OnStopRequest(nsIRequest *request, nsISupports *aCtxt, 
                                                   nsresult aStatus)
 {
   mStopRequestIssued = PR_TRUE;
   mRequest = nsnull;
