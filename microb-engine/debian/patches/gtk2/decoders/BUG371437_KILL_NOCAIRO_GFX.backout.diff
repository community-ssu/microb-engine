#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/bmp nsBMPDecoder.cpp,v
#retrieving revision 1.32
#retrieving revision 1.33
Index: mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp
+++ mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp
@@ -150,36 +150,42 @@ nsresult nsBMPDecoder::WriteRLERows(PRUi
     PRUint32 cnt, line;
 
     PRUint32 abpr;
     PRUint8 bit;
     PRUint8* pos = mAlpha;
     // First pack the alpha data
     nsresult rv = mFrame->GetAlphaBytesPerRow(&abpr);
     NS_ENSURE_SUCCESS(rv, rv);
-
+#ifdef MOZ_CAIRO_GFX
     gfx_format format;
     mFrame->GetFormat(&format);
     if (format == RLE_GFXFORMAT_ALPHA)
         abpr >>= 2;
-
+#endif
     for (cnt = 0; cnt < abpr; cnt++) {
         PRUint8 byte = 0;
         for (bit = 128; bit; bit >>= 1)
             byte |= *pos++ & bit;
         mAlpha[cnt] = byte;
+#ifdef MOZ_CAIRO_GFX
 #ifdef IS_LITTLE_ENDIAN
         mDecoded[(cnt << 2) + 3] = byte ? 0 : 255;
 #else
         mDecoded[(cnt << 2)] = byte ? 0 : 255;
 #endif
+#endif
     }
 
     for (cnt = 0; cnt < rows; cnt++) {
         line = (mBIH.height < 0) ? (-mBIH.height - mCurLine--) : --mCurLine;
+#ifndef MOZ_CAIRO_GFX
+        rv = mFrame->SetAlphaData(mAlpha, abpr, line * abpr);
+        NS_ENSURE_SUCCESS(rv, rv);
+#endif
         rv = mFrame->SetImageData(mDecoded, mBpr, line * mBpr);
         NS_ENSURE_SUCCESS(rv, rv);
         if (cnt == 0) {
             memset(mAlpha, 0, mBIH.width);
             memset(mDecoded, 0, mBpr);
         }
     }
 
Index: mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/bmp/nsBMPDecoder.h
+++ mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.h
@@ -111,20 +111,30 @@ struct bitFields {
                                (((((PRUint32) x) >> 8) & 0xFF) << 16) | \
                                (((((PRUint32) x) >> 16) & 0xFF) << 8) | \
                                (((PRUint32) x) >> 24))
 #else
 #define LITTLE_TO_NATIVE16(x) x
 #define LITTLE_TO_NATIVE32(x) x
 #endif
 
+#if !defined(MOZ_CAIRO_GFX) && (defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON))
+#define BMP_GFXFORMAT gfxIFormats::BGR
+#define RLE_GFXFORMAT_ALPHA gfxIFormats::BGR_A1
+#else
 #define USE_RGB
 #define BMP_GFXFORMAT gfxIFormats::RGB
 #define RLE_GFXFORMAT_ALPHA gfxIFormats::RGB_A1
+#endif
+
+#if defined(MOZ_CAIRO_GFX) || defined(XP_MAC) || defined(XP_MACOSX)
 #define GFXBYTESPERPIXEL 4
+#else
+#define GFXBYTESPERPIXEL 3
+#endif
 
 // BMPINFOHEADER.compression defines
 #define BI_RLE8 1
 #define BI_RLE4 2
 #define BI_BITFIELDS 3
 
 // RLE Escape codes
 #define RLE_ESCAPE       0
@@ -217,18 +227,34 @@ private:
      * data to native data as necessary */
     void ProcessInfoHeader();
 };
 
 /** Sets the pixel data in aDecoded to the given values.
  * The variable passed in as aDecoded will be moved on 3 or 4 bytes! */
 inline void SetPixel(PRUint8*& aDecoded, PRUint8 aRed, PRUint8 aGreen, PRUint8 aBlue, PRUint8 aAlpha = 0xFF)
 {
+#if defined(MOZ_CAIRO_GFX)
     *(PRUint32*)aDecoded = (aAlpha << 24) | (aRed << 16) | (aGreen << 8) | aBlue;
     aDecoded += 4;
+#else // MOZ_CAIRO_GFX
+
+#if defined(XP_MAC) || defined(XP_MACOSX)
+    *aDecoded++ = 0; // Mac needs this padding byte
+#endif
+#ifdef USE_RGB
+    *aDecoded++ = aRed;
+    *aDecoded++ = aGreen;
+    *aDecoded++ = aBlue;
+#else
+    *aDecoded++ = aBlue;
+    *aDecoded++ = aGreen;
+    *aDecoded++ = aRed;
+#endif
+#endif // MOZ_CAIRO_GFX
 }
 
 inline void SetPixel(PRUint8*& aDecoded, PRUint8 idx, colorTable* aColors)
 {
     SetPixel(aDecoded, aColors[idx].red, aColors[idx].green, aColors[idx].blue);
 }
 
 /** Sets two (or one if aCount = 1) pixels
Index: mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/bmp/nsICODecoder.cpp
+++ mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.cpp
@@ -61,52 +61,114 @@ NS_IMPL_ISUPPORTS1(nsICODecoder, imgIDec
 #define DIRENTRYOFFSET 6
 #define BITMAPINFOSIZE 40
 #define PREFICONSIZE 16
 
 // ----------------------------------------
 // Actual Data Processing
 // ----------------------------------------
 
+#ifdef MOZ_CAIRO_GFX
 static PRUint32 premultiply(PRUint32 x)
 {
     PRUint32 a = x >> 24;
     PRUint32 t = (x & 0xff00ff) * a + 0x800080;
     t = (t + ((t >> 8) & 0xff00ff)) >> 8;
     t &= 0xff00ff;
 
     x = ((x >> 8) & 0xff) * a + 0x80;
     x = (x + ((x >> 8) & 0xff));
     x &= 0xff00;
     x |= t | (a << 24);
     return x;
 }
+#endif
 
 nsresult nsICODecoder::SetImageData()
 {
+#ifdef MOZ_CAIRO_GFX
   if (mHaveAlphaData) {
     // We have premultiply the pixels when we have alpha transparency
     PRUint32* p = (PRUint32*)mDecodedBuffer;
     for (PRUint32 c = mDirEntry.mWidth * mDirEntry.mHeight; c > 0; --c) {
       *p = premultiply(*p);
       p++;
     }
   }
   // In Cairo we can set the whole image in one go
   PRUint32 dataLen = mDirEntry.mHeight * mDirEntry.mWidth * 4;
   mFrame->SetImageData(mDecodedBuffer, dataLen, 0);
+#else
+  PRUint32 bpr;
+  mFrame->GetImageBytesPerRow(&bpr);
+
+  // Since the ICO is decoded into an exact sized array, the frame may use
+  // more bytes per row of pixels than the decoding array.
+#if defined(XP_MAC) || defined(XP_MACOSX)
+  PRUint32 decodedLineLen = mDirEntry.mWidth * 4;
+#else
+  PRUint32 decodedLineLen = mDirEntry.mWidth * 3;
+#endif
+
+  PRUint8* decodeBufferPos = mDecodedBuffer;
+  PRUint32 frameOffset = 0;
+
+  for (PRUint32 i = 0;
+       i < mDirEntry.mHeight;
+       ++i, frameOffset += bpr, decodeBufferPos += decodedLineLen) {
+    mFrame->SetImageData(decodeBufferPos, decodedLineLen, frameOffset);
+  }
+#endif
 
   nsIntRect r(0, 0, 0, 0);
   mFrame->GetWidth(&r.width);
   mFrame->GetHeight(&r.height);
   mObserver->OnDataAvailable(nsnull, mFrame, &r);
 
   return NS_OK;
 }
 
+#ifndef MOZ_CAIRO_GFX
+nsresult nsICODecoder::SetAlphaData()
+{
+  // Alpha data was already set if bpp == 32
+  if (mHaveAlphaData)
+    return NS_OK;
+
+  PRUint32 bpr;
+  mFrame->GetAlphaBytesPerRow(&bpr);
+  // In case the decoder and frame have different sized alpha buffers, we
+  // take the smaller of the two row length values as the row length to copy.
+  PRUint32 rowCopyLen = PR_MIN(bpr, mDirEntry.mWidth);
+  PRUint8* alphaRow = (PRUint8*)malloc(rowCopyLen);
+  if (!alphaRow)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  PRUint32 decoderRowSize = CalcAlphaRowSize();
+  PRUint8* alphaBufferPos = mAlphaBuffer;
+  PRUint32 frameOffset = 0;
+
+  for (PRUint32 i = 0; i < mDirEntry.mHeight; i++) {
+    PRInt8 byte = 0;
+    PRUint32 k = 0;
+    for (PRUint32 j = 0; j < rowCopyLen; ++j) {
+      if ((j % 8) == 0)
+        byte = alphaBufferPos[k++];
+      alphaRow[j] = byte >> 7;
+      byte <<= 1;
+    }
+    mFrame->SetAlphaData(alphaRow, rowCopyLen, frameOffset);
+    frameOffset += bpr;
+    alphaBufferPos += decoderRowSize;
+  }
+  free(alphaRow);
+  return NS_OK;
+}
+#endif
+
 PRUint32 nsICODecoder::CalcAlphaRowSize()
 {
   PRUint32 rowSize = (mDirEntry.mWidth + 7) / 8; // +7 to round up
   if (rowSize % 4)
     rowSize += (4 - (rowSize % 4)); // Pad to DWORD Boundary
   return rowSize;
 }
 
@@ -115,16 +177,19 @@ nsICODecoder::nsICODecoder()
   mPos = mNumColors = mRowBytes = mImageOffset = mCurrIcon = mNumIcons = 0;
   mCurLine = 1; // Otherwise decoder will never start
   mStatus = NS_OK;
   mColors = nsnull;
   mRow = nsnull;
   mHaveAlphaData = 0;
   mDecodingAndMask = PR_FALSE;
   mDecodedBuffer = nsnull;
+#ifndef MOZ_CAIRO_GFX
+  mAlphaBuffer = nsnull;
+#endif
 }
 
 nsICODecoder::~nsICODecoder()
 {
 }
 
 NS_IMETHODIMP nsICODecoder::Init(imgILoad *aLoad)
 { 
@@ -163,25 +228,31 @@ NS_IMETHODIMP nsICODecoder::Close()
   mCurrIcon = 0;
   mNumIcons = 0;
 
   free(mRow);
   mRow = nsnull;
 
   mDecodingAndMask = PR_FALSE;
   free(mDecodedBuffer);
+#ifndef MOZ_CAIRO_GFX
+  free(mAlphaBuffer);
+#endif
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsICODecoder::Flush()
 {
   // Set Data here because some ICOs don't have a complete AND Mask
   // see bug 115357
   if (mDecodingAndMask) {
+#ifndef MOZ_CAIRO_GFX
+    SetAlphaData();
+#endif
     SetImageData();
     mObserver->OnStopFrame(nsnull, mFrame);
   }
   return NS_OK;
 }
 
 
 NS_METHOD nsICODecoder::ReadSegCb(nsIInputStream* aIn, void* aClosure,
@@ -364,20 +435,34 @@ nsresult nsICODecoder::ProcessData(const
       at = (at + 1) % 4;
     }
   }
 
   if (!mDecodingAndMask && (mPos >= (mImageOffset + BITMAPINFOSIZE + mNumColors*4))) {
     if (mPos == (mImageOffset + BITMAPINFOSIZE + mNumColors*4)) {
       // Increment mPos to avoid reprocessing the info header.
       mPos++;
+#if defined(MOZ_CAIRO_GFX) || defined(XP_MAC) || defined(XP_MACOSX)
       mDecodedBuffer = (PRUint8*)malloc(mDirEntry.mHeight*mDirEntry.mWidth*4);
+#else
+      mDecodedBuffer = (PRUint8*)malloc(mDirEntry.mHeight*mDirEntry.mWidth*3);
+#endif
       if (!mDecodedBuffer)
         return NS_ERROR_OUT_OF_MEMORY;
     }
+#ifndef MOZ_CAIRO_GFX
+    PRUint32 alphaRowSize;
+    mFrame->GetAlphaBytesPerRow(&alphaRowSize);
+    nsAutoArrayPtr<PRUint8> alphaRow; // Will only be used if bpp == 32
+    if (mBIH.bpp == 32) {
+      alphaRow = new PRUint8[alphaRowSize];
+      if (!alphaRow)
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
+#endif
 
     // Ensure memory has been allocated before decoding. If we get this far 
     // without allocated memory, the file is most likely invalid.
     NS_ASSERTION(mRow, "mRow is null");
     NS_ASSERTION(mDecodedBuffer, "mDecodedBuffer is null");
     if (!mRow || !mDecodedBuffer)
       return NS_ERROR_FAILURE;
 
@@ -394,16 +479,19 @@ nsresult nsICODecoder::ProcessData(const
             aCount -= toCopy;
             aBuffer += toCopy;
             mRowBytes += toCopy;
         }
         if (rowSize == mRowBytes) {
             mCurLine--;
             PRUint8* d = mDecodedBuffer + (mCurLine * mDirEntry.mWidth * GFXBYTESPERPIXEL);
             PRUint8* p = mRow;
+#ifndef MOZ_CAIRO_GFX
+            PRUint8* alphaPos = alphaRow; // only used if bpp == 32
+#endif
             PRUint32 lpos = mDirEntry.mWidth;
             switch (mBIH.bpp) {
               case 1:
                 while (lpos > 0) {
                   PRInt8 bit;
                   PRUint8 idx;
                   for (bit = 7; bit >= 0 && lpos > 0; bit--) {
                       idx = (*p >> bit) & 1;
@@ -441,54 +529,78 @@ nsresult nsICODecoder::ProcessData(const
                 while (lpos > 0) {
                   SetPixel(d, p[2], p[1], p[0]);
                   p += 3;
                   --lpos;
                 }
                 break;
               case 32:
                 while (lpos > 0) {
+#ifdef MOZ_CAIRO_GFX
                   SetPixel(d, p[2], p[1], p[0], p[3]);
                   mHaveAlphaData |= p[3]; // Alpha value
+#else
+                  SetPixel(d, p[2], p[1], p[0]);
+                  mHaveAlphaData |= *alphaPos++ = p[3]; // Alpha value
+#endif
                   p += 4;
                   --lpos;
                 }
                 break;
               default:
                 // This is probably the wrong place to check this...
                 return NS_ERROR_FAILURE;
             }
 
             if (mCurLine == 0)
               mDecodingAndMask = PR_TRUE;
               
             mRowBytes = 0;
+
+#ifndef MOZ_CAIRO_GFX
+            // If 32 bit image, gotta set the alpha data here
+            if (mBIH.bpp == 32)
+              mFrame->SetAlphaData(alphaRow, alphaRowSize, mCurLine * alphaRowSize);
+#endif
         }
     } while (!mDecodingAndMask && aCount > 0);
 
   }
 
   if (mDecodingAndMask && !mHaveAlphaData) {
     PRUint32 rowSize = CalcAlphaRowSize();
 
     if (mPos == (1 + mImageOffset + BITMAPINFOSIZE + mNumColors*4)) {
       mPos++;
       mRowBytes = 0;
       mCurLine = mDirEntry.mHeight;
       free(mRow);
       mRow = (PRUint8*)malloc(rowSize);
       if (!mRow)
         return NS_ERROR_OUT_OF_MEMORY;
+#ifndef MOZ_CAIRO_GFX
+      mAlphaBuffer = (PRUint8*)malloc(mDirEntry.mHeight*rowSize);
+      if (!mAlphaBuffer)
+        return NS_ERROR_OUT_OF_MEMORY;
+      memset(mAlphaBuffer, 0xff, mDirEntry.mHeight*rowSize);
+#endif
     }
 
     // Ensure memory has been allocated before decoding.
+#ifdef MOZ_CAIRO_GFX
     NS_ASSERTION(mRow, "mRow is null");
     NS_ASSERTION(mDecodedBuffer, "mDecodedBuffer is null");
     if (!mRow || !mDecodedBuffer)
       return NS_ERROR_FAILURE;
+#else
+    NS_ASSERTION(mRow, "mRow is null");
+    NS_ASSERTION(mAlphaBuffer, "mAlphaBuffer is null");
+    if (!mRow || !mAlphaBuffer)
+      return NS_ERROR_FAILURE;
+#endif
 
     PRUint32 toCopy;
     do {
         if (mCurLine == 0) {
           return NS_OK;
         }
 
         toCopy = rowSize - mRowBytes;
@@ -498,33 +610,47 @@ nsresult nsICODecoder::ProcessData(const
             memcpy(mRow + mRowBytes, aBuffer, toCopy);
             aCount -= toCopy;
             aBuffer += toCopy;
             mRowBytes += toCopy;
         }
         if ((rowSize - mRowBytes) == 0) {
             mCurLine--;
 
+#ifdef MOZ_CAIRO_GFX
             PRUint8* decoded =
               mDecodedBuffer + (mCurLine * mDirEntry.mWidth * GFXBYTESPERPIXEL);
 #ifdef IS_LITTLE_ENDIAN
             decoded += 3;
 #endif
             PRUint8* decoded_end =
               decoded + mDirEntry.mWidth * GFXBYTESPERPIXEL;
             for (PRUint8* p = mRow, *p_end = mRow + rowSize; p < p_end; ++p) {
               PRUint8 idx = *p;
               for (PRUint8 bit = 0x80; bit && decoded<decoded_end; bit >>= 1) {
                 // We complement the value, since our method of storing
                 // transparency is opposite what Win32 uses in its masks.
                 *decoded = (idx & bit) ? 0x00 : 0xff;
                 decoded += GFXBYTESPERPIXEL;
               }
             }
-
+#else
+            PRUint8* decoded = mAlphaBuffer+(mCurLine*rowSize);
+            PRUint8* p = mRow;
+            PRUint32 lpos = 0;
+            while (lpos < rowSize) {
+              PRUint8 idx = *p;
+              idx ^= 255;  // We complement the value, since our method of storing transparency is opposite
+                           // what Win32 uses in its masks.
+              decoded[lpos] = idx;
+              lpos++;
+              p++;
+            }
+#endif
+
             mRowBytes = 0;
         }
     } while (aCount > 0);
   }
 
   return NS_OK;
 }
 
Index: mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/bmp/nsICODecoder.h
+++ mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.h
@@ -92,16 +92,19 @@ private:
                              PRUint32 aCount, PRUint32 *aWriteCount);
 
   // Private helper methods
   nsresult ProcessData(const char* aBuffer, PRUint32 aCount);
   void ProcessDirEntry(IconDirEntry& aTarget);
   void ProcessInfoHeader();
 
   nsresult SetImageData();
+#ifndef MOZ_CAIRO_GFX
+  nsresult SetAlphaData();
+#endif
 
   PRUint32 CalcAlphaRowSize();
 
 private:
   nsCOMPtr<imgIDecoderObserver> mObserver;
   nsCOMPtr<imgIContainer> mImage;
   nsCOMPtr<gfxIImageFrame> mFrame;
   
@@ -121,16 +124,19 @@ private:
 
   PRUint8* mRow; // Holds one raw line of the image
   PRUint32 mRowBytes; // How many bytes of the row were already received
   PRInt32 mCurLine;
 
   nsresult mStatus;
 
   PRUint8* mDecodedBuffer;
+#ifndef MOZ_CAIRO_GFX
+  PRUint8* mAlphaBuffer;
+#endif
 
   PRUint8 mHaveAlphaData;
   PRPackedBool mIsCursor;
   PRPackedBool mDecodingAndMask;
 };
 
 
 #endif
Index: mozilla/modules/libpr0n/decoders/gif/imgContainerGIF.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/gif/imgContainerGIF.cpp
+++ mozilla/modules/libpr0n/decoders/gif/imgContainerGIF.cpp
@@ -42,17 +42,20 @@
 
 #include "imgContainerGIF.h"
 
 #include "nsIServiceManager.h"
 #include "nsIImage.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsMemory.h"
+
+#ifdef MOZ_CAIRO_GFX
 #include "gfxContext.h"
+#endif
 
 NS_IMPL_ISUPPORTS2(imgContainerGIF, imgIContainer, nsITimerCallback)
 
 //******************************************************************************
 imgContainerGIF::imgContainerGIF()
   : mObserver(nsnull)
   , mSize(0,0)
   , mFirstFrameRefreshArea()
@@ -854,16 +857,17 @@ void imgContainerGIF::SetMaskVisibility(
 
   const PRInt32 width  = PR_MIN(aWidth, frameWidth - aX);
   const PRInt32 height = PR_MIN(aHeight, frameHeight - aY);
 
   if (width <= 0 || height <= 0) {
     return;
   }
 
+#ifdef MOZ_CAIRO_GFX
   PRUint8* alphaData;
   PRUint32 alphaDataLength;
   const PRUint8 setMaskTo = aVisible ? 0xFF : 0x00;
 
   aFrame->LockImageData();
   nsresult res = aFrame->GetImageData(&alphaData, &alphaDataLength);
   if (NS_SUCCEEDED(res)) {
 #ifdef IS_LITTLE_ENDIAN
@@ -874,79 +878,214 @@ void imgContainerGIF::SetMaskVisibility(
     for (PRInt32 j = height; j > 0; --j) {
       for (PRInt32 i = (aX+width-1)*4; i >= aX; i -= 4) {
         alphaData[i] = setMaskTo;
       }
       alphaData += frameWidth*4;
     }
   }
   aFrame->UnlockImageData();
+
+#else
+  PRUint8* alphaData;
+  PRUint32 alphaDataLength;
+  aFrame->LockAlphaData();
+  nsresult res = aFrame->GetAlphaData(&alphaData, &alphaDataLength);
+  if (!alphaData || !alphaDataLength || NS_FAILED(res)) {
+    aFrame->UnlockAlphaData();
+    return;
+  }
+
+  gfx_format format;
+  aFrame->GetFormat(&format);
+  if (format != gfxIFormats::RGB_A1 && format != gfxIFormats::BGR_A1) {
+    NS_NOTREACHED("GIFs only support 1 bit alpha");
+    aFrame->UnlockAlphaData();
+    return;
+  }
+
+  PRUint32 abpr;
+  aFrame->GetAlphaBytesPerRow(&abpr);
+
+#ifdef MOZ_PLATFORM_IMAGES_BOTTOM_TO_TOP
+  // Account for bottom-up storage.
+  // Start at the bottom (top in memory), go to the top (bottom in memory)
+  PRUint8* alphaLine = alphaData + ((frameHeight - aY - height) * abpr) +
+                       (aX >> 3);
+#else
+  PRUint8* alphaLine = alphaData + (aY * abpr) + (aX >> 3);
+#endif
+  PRUint8 maskShiftStartBy = aX & 0x7;
+  PRUint8 numReplacingStart = 8U - maskShiftStartBy;
+  PRUint32 rowBytes;
+  PRUint8 maskStart = 0; // Init to shutup compiler; Only used if
+                         // maskShiftStartBy != 0
+  PRUint8 maskEnd;
+
+  if (width <= numReplacingStart) {
+    maskEnd = (0xFF >> (8U - width)) << (numReplacingStart - width);
+    // Don't write start bits, only end bits (which contain both start & end)
+    maskShiftStartBy = 0;
+    rowBytes = 0;
+  } else {
+    if (maskShiftStartBy == 0)
+      numReplacingStart = 0;
+    else
+      maskStart = 0xFF >> maskShiftStartBy;
+
+    PRUint8 maskShiftEndBy = (width - numReplacingStart) & 0x7;
+    maskEnd = ~(0xFF >> maskShiftEndBy);
+    rowBytes = (width - numReplacingStart - maskShiftEndBy) >> 3;
+  }
+
+  if (aVisible) {
+    for (PRInt32 i = 0; i < height; i++) {
+      PRUint8 *localAlpha = alphaLine;
+
+      if (maskShiftStartBy != 0)
+        *localAlpha++ |= maskStart;
+
+      if (rowBytes > 0)
+        memset(localAlpha, 0xFF, rowBytes);
+
+      if (maskEnd != 0)
+        localAlpha[rowBytes] |= maskEnd;
+
+      alphaLine += abpr;
+    }
+  } else {
+    for (PRInt32 i = 0; i < height; i++) {
+      PRUint8 *localAlpha = alphaLine;
+
+      if (maskShiftStartBy != 0)
+        *localAlpha++ &= ~maskStart;
+
+      if (rowBytes > 0)
+        memset(localAlpha, 0x00, rowBytes);
+
+      if (maskEnd != 0)
+        localAlpha[rowBytes] &= ~maskEnd;
+
+      alphaLine += abpr;
+    } // for
+  } // if aVisible
+
+  aFrame->UnlockAlphaData();
+#endif
 }
 
 //******************************************************************************
 void imgContainerGIF::SetMaskVisibility(gfxIImageFrame *aFrame, PRBool aVisible)
 {
   if (!aFrame)
     return;
 
   PRUint8* alphaData;
   PRUint32 alphaDataLength;
   const PRUint8 setMaskTo = aVisible ? 0xFF : 0x00;
 
+#ifdef MOZ_CAIRO_GFX
   aFrame->LockImageData();
   nsresult res = aFrame->GetImageData(&alphaData, &alphaDataLength);
   if (NS_SUCCEEDED(res)) {
     for (PRUint32 i = 0; i < alphaDataLength; i+=4) {
 #ifdef IS_LITTLE_ENDIAN
       alphaData[i+3] = setMaskTo;
 #else
       alphaData[i] = setMaskTo;
 #endif
     }
   }
   aFrame->UnlockImageData();
+
+#else
+
+  aFrame->LockAlphaData();
+  nsresult res = aFrame->GetAlphaData(&alphaData, &alphaDataLength);
+  if (NS_SUCCEEDED(res) && alphaData && alphaDataLength)
+    memset(alphaData, setMaskTo, alphaDataLength);
+  aFrame->UnlockAlphaData();
+#endif
 }
 
 //******************************************************************************
 // Fill aFrame with black. Does not change the mask.
 void imgContainerGIF::BlackenFrame(gfxIImageFrame *aFrame)
 {
   if (!aFrame)
     return;
-
+#ifdef MOZ_CAIRO_GFX
   PRInt32 widthFrame;
   PRInt32 heightFrame;
   aFrame->GetWidth(&widthFrame);
   aFrame->GetHeight(&heightFrame);
 
   BlackenFrame(aFrame, 0, 0, widthFrame, heightFrame);
+
+#else
+  PRUint32 aDataLength;
+
+  aFrame->GetImageDataLength(&aDataLength);
+  aFrame->SetImageData(nsnull, aDataLength, 0);
+#endif
 }
 
 //******************************************************************************
 void imgContainerGIF::BlackenFrame(gfxIImageFrame *aFrame,
                                    PRInt32 aX, PRInt32 aY,
                                    PRInt32 aWidth, PRInt32 aHeight)
 {
   if (!aFrame)
     return;
 
+#ifdef MOZ_CAIRO_GFX
   nsCOMPtr<nsIImage> img(do_GetInterface(aFrame));
   if (!img)
     return;
 
   nsRefPtr<gfxASurface> surf;
   img->GetSurface(getter_AddRefs(surf));
 
   nsRefPtr<gfxContext> ctx = new gfxContext(surf);
   ctx->SetColor(gfxRGBA(0, 0, 0));
   ctx->Rectangle(gfxRect(aX, aY, aWidth, aHeight));
   ctx->Fill();
 
   nsIntRect r(aX, aY, aWidth, aHeight);
   img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+
+#else // MOZ_CAIRO_GFX
+
+  PRInt32 widthFrame;
+  PRInt32 heightFrame;
+  aFrame->GetWidth(&widthFrame);
+  aFrame->GetHeight(&heightFrame);
+
+  const PRInt32 width  = PR_MIN(aWidth, (widthFrame - aX));
+  const PRInt32 height = PR_MIN(aHeight, (heightFrame - aY));
+
+  if (width <= 0 || height <= 0) {
+    return;
+  }
+
+  PRUint32 bpr; // Bytes Per Row
+  aFrame->GetImageBytesPerRow(&bpr);
+
+#if defined(XP_MAC) || defined(XP_MACOSX)
+  const PRUint8 bpp = 4;
+#else
+  const PRUint8 bpp = 3;
+#endif
+  const PRUint32 bprToWrite = width * bpp;
+  const PRUint32 xOffset = aX * bpp; // offset into row to start writing
+
+  for (PRInt32 y = 0; y < height; y++) {
+    aFrame->SetImageData(nsnull, bprToWrite, ((y + aY) * bpr) + xOffset);
+  }
+#endif // MOZ_CAIRO_GFX
 }
 
 
 //******************************************************************************
 // Whether we succeed or fail will not cause a crash, and there's not much
 // we can do about a failure, so there we don't return a nsresult
 PRBool imgContainerGIF::CopyFrameImage(gfxIImageFrame *aSrcFrame,
                                        gfxIImageFrame *aDstFrame)
@@ -967,16 +1106,31 @@ PRBool imgContainerGIF::CopyFrameImage(g
   aDstFrame->GetImageData(&aDataDest, &aDataLengthDest);
   if (!aDataDest || !aDataSrc || aDataLengthDest != aDataLengthSrc) {
     aDstFrame->UnlockImageData();
     return PR_FALSE;
   }
   memcpy(aDataDest, aDataSrc, aDataLengthSrc);
   aDstFrame->UnlockImageData();
 
+#ifndef MOZ_CAIRO_GFX
+  // Copy Alpha/Mask Over
+  // If no mask, lockAlpha will tell us
+  if (NS_SUCCEEDED(aDstFrame->LockAlphaData())) {
+    aSrcFrame->GetAlphaData(&aDataSrc, &aDataLengthSrc);
+    aDstFrame->GetAlphaData(&aDataDest, &aDataLengthDest);
+    if (aDataDest && aDataSrc && aDataLengthDest == aDataLengthSrc)
+      memcpy(aDataDest, aDataSrc, aDataLengthSrc);
+    else
+      memset(aDataDest, 0xFF, aDataLengthDest);
+
+    aDstFrame->UnlockAlphaData();
+  }
+#endif
+
   // Tell the image that it's data has been updated
   nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(aDstFrame));
   if (!ireq)
     return PR_FALSE;
   nsCOMPtr<nsIImage> img(do_GetInterface(ireq));
   if (!img)
     return PR_FALSE;
   nsIntRect r;
Index: mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp
+++ mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp
@@ -487,21 +487,32 @@ int nsGIFDecoder2::HaveDecodedRow(
     }
     if (decoder->mGIFStruct->is_local_colormap_defined) {
       cmapsize = decoder->mGIFStruct->local_colormap_size;
       cmap = decoder->mGIFStruct->local_colormap;
     }
 
     if (!cmap) { // cmap could have null value if the global color table flag is 0
       for (int i = 0; i < aDuplicateCount; ++i) {
+#ifdef MOZ_CAIRO_GFX
         imgContainerGIF::BlackenFrame(decoder->mImageFrame, 0, aRowNumber+i, width, 1);
+#else
+        if (format == gfxIFormats::RGB_A1 ||
+            format == gfxIFormats::BGR_A1) {
+          decoder->mImageFrame->SetAlphaData(nsnull,
+                                             abpr, (aRowNumber+i)*abpr);
+        }
+        decoder->mImageFrame->SetImageData(nsnull,
+                                           bpr, (aRowNumber+i)*bpr);
+#endif
       }
     } else {
       PRUint8* rowBufIndex = aRowBufPtr;
 
+#if defined(MOZ_CAIRO_GFX)
       PRUint32 *rgbRowIndex = (PRUint32*)decoder->mRGBLine;
       while (rowBufIndex != decoder->mGIFStruct->rowend) {
         if (*rowBufIndex >= cmapsize ||
             ((format == gfxIFormats::RGB_A1 || format == gfxIFormats::BGR_A1) &&
              (*rowBufIndex == decoder->mGIFStruct->tpixel))) {
           *rgbRowIndex++ = 0x00000000;
           ++rowBufIndex;
           continue;
@@ -511,16 +522,96 @@ int nsGIFDecoder2::HaveDecodedRow(
         *rgbRowIndex++ = (0xFF << 24) |
           (cmap[colorIndex] << 16) |
           (cmap[colorIndex+1] << 8) |
           (cmap[colorIndex+2]);
         ++rowBufIndex;
       }
       for (int i=0; i<aDuplicateCount; i++)
         decoder->mImageFrame->SetImageData(decoder->mRGBLine, bpr, (aRowNumber+i)*bpr);
+#else
+      PRUint8* rgbRowIndex = decoder->mRGBLine;
+      switch (format) {
+        case gfxIFormats::RGB:
+        case gfxIFormats::BGR:
+        {
+          while (rowBufIndex != decoder->mGIFStruct->rowend) {
+#if defined(XP_MAC) || defined(XP_MACOSX)
+            *rgbRowIndex++ = 0; // Mac is always 32bits per pixel, this is pad
+#endif
+            if (*rowBufIndex < cmapsize) {
+              PRUint32 colorIndex = *rowBufIndex * 3;
+#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON)
+              *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
+              *rgbRowIndex++ = cmap[colorIndex + 1]; // green
+              *rgbRowIndex++ = cmap[colorIndex];     // red
+#else
+              *rgbRowIndex++ = cmap[colorIndex];     // red
+              *rgbRowIndex++ = cmap[colorIndex + 1]; // green
+              *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
+#endif
+            } else {
+              *rgbRowIndex++ = 0;                    // red
+              *rgbRowIndex++ = 0;                    // green
+              *rgbRowIndex++ = 0;                    // blue
+            }
+            ++rowBufIndex;
+          }
+          for (int i=0; i<aDuplicateCount; i++) {
+            decoder->mImageFrame->SetImageData(decoder->mRGBLine,
+                                               bpr, (aRowNumber+i)*bpr);
+          }
+          break;
+        }
+        case gfxIFormats::RGB_A1:
+        case gfxIFormats::BGR_A1:
+        {
+          memset(decoder->mRGBLine, 0, bpr);
+          memset(decoder->mAlphaLine, 0, abpr);
+          for (PRUint32 x = 0; x < (PRUint32)width; ++x) {
+            if (*rowBufIndex != decoder->mGIFStruct->tpixel) {
+#if defined(XP_MAC) || defined(XP_MACOSX)
+              *rgbRowIndex++ = 0; // Mac is always 32bits per pixel, this is pad
+#endif
+              if (*rowBufIndex < cmapsize) {
+                PRUint32 colorIndex = *rowBufIndex * 3;
+#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON)
+                *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
+                *rgbRowIndex++ = cmap[colorIndex + 1]; // green
+                *rgbRowIndex++ = cmap[colorIndex];     // red
+#else
+                *rgbRowIndex++ = cmap[colorIndex];     // red
+                *rgbRowIndex++ = cmap[colorIndex + 1]; // green
+                *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
+#endif
+              } else {
+                *rgbRowIndex++ = 0;                    // red
+                *rgbRowIndex++ = 0;                    // green
+                *rgbRowIndex++ = 0;                    // blue
+              }
+              decoder->mAlphaLine[x>>3] |= 1<<(7-x&0x7);
+            } else {
+#if defined(XP_MAC) || defined(XP_MACOSX)
+              rgbRowIndex+=4;
+#else
+              rgbRowIndex+=3;
+#endif
+            }
+            ++rowBufIndex;
+          }
+          for (int i=0; i<aDuplicateCount; i++) {
+            decoder->mImageFrame->SetAlphaData(decoder->mAlphaLine,
+                                               abpr, (aRowNumber+i)*abpr);
+            decoder->mImageFrame->SetImageData(decoder->mRGBLine,
+                                               bpr, (aRowNumber+i)*bpr);
+          }
+          break;
+        }
+      }
+#endif // else !MOZ_CAIRO_GFX
     }
 
     decoder->mCurrentRow = aRowNumber + aDuplicateCount - 1;
     decoder->mCurrentPass = aInterlacePass;
     if (aInterlacePass == 1)
       decoder->mLastFlushedPass = aInterlacePass;   // interlaced starts at 1
   }
 
Index: mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/icon/nsIconDecoder.cpp
+++ mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.cpp
@@ -102,56 +102,81 @@ NS_IMETHODIMP nsIconDecoder::WriteFrom(n
 
   PRUint8 * const buf = (PRUint8 *)PR_Malloc(count);
   if (!buf) return NS_ERROR_OUT_OF_MEMORY; /* we couldn't allocate the object */
  
   // read the data from the input stram...
   PRUint32 readLen;
   rv = inStr->Read((char*)buf, count, &readLen);
   NS_ENSURE_SUCCESS(rv, rv);
+#ifdef MOZ_CAIRO_GFX
   NS_ENSURE_TRUE(readLen >= 2, NS_ERROR_UNEXPECTED); // w, h
+#else
+  NS_ENSURE_TRUE(readLen >= 3, NS_ERROR_UNEXPECTED); // w, h, alphaBits
+#endif
 
   PRUint8 * const buf_end = buf + readLen;
   PRUint8 *data = buf;
 
   // since WriteFrom is only called once, go ahead and fire the on start notifications..
 
   mObserver->OnStartDecode(nsnull);
   // Read size
   PRInt32 w = *(data++);
   PRInt32 h = *(data++);
+#ifdef MOZ_CAIRO_GFX
   NS_ENSURE_TRUE(w > 0 && h > 0, NS_ERROR_UNEXPECTED);
+#else
+  PRUint8 alphaBits = *(data++);
+  NS_ENSURE_TRUE(w > 0 && h > 0 && (alphaBits == 1 || alphaBits == 8),
+                 NS_ERROR_UNEXPECTED);
+#endif
 
   mImage->Init(w, h, mObserver);
   if (mObserver)
     mObserver->OnStartContainer(nsnull, mImage);
 
+#ifdef MOZ_CAIRO_GFX
   gfx_format format = gfxIFormats::BGRA; // XXX not really
+#else
+  gfx_format format = alphaBits == 1 ? gfx_format(gfxIFormats::RGB_A1)
+                                     : gfx_format(gfxIFormats::RGB_A8);
+#endif
   rv = mFrame->Init(0, 0, w, h, format, 24);
   if (NS_FAILED(rv))
     return rv;
 
   mImage->AppendFrame(mFrame);
   if (mObserver)
     mObserver->OnStartFrame(nsnull, mFrame);
   
   PRUint32 bpr, abpr;
   PRInt32 width, height;
   mFrame->GetImageBytesPerRow(&bpr);
   mFrame->GetAlphaBytesPerRow(&abpr);
   mFrame->GetWidth(&width);
   mFrame->GetHeight(&height);
 
   PRInt32 rownum;
+#if defined(MOZ_CAIRO_GFX)
   NS_ENSURE_TRUE(buf_end - data >= PRInt32(bpr) * height,
                  NS_ERROR_UNEXPECTED);
-
+
+  for (rownum = 0; rownum < height; ++rownum, data += bpr)
+    mFrame->SetImageData(data, bpr, rownum * bpr);
+#else
+  NS_ENSURE_TRUE(buf_end - data >= PRInt32(bpr + abpr) * height,
+                 NS_ERROR_UNEXPECTED);
+
   for (rownum = 0; rownum < height; ++rownum, data += bpr)
     mFrame->SetImageData(data, bpr, rownum * bpr);
 
+  for (rownum = 0; rownum < height; ++rownum, data += abpr)
+    mFrame->SetAlphaData(data, abpr, rownum * abpr);
+#endif
   nsIntRect r(0, 0, width, height);
   mObserver->OnDataAvailable(nsnull, mFrame, &r);
 
   PR_Free(buf);
 
   return NS_OK;
 }
 
Index: mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/icon/nsIconDecoder.h
+++ mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.h
@@ -63,20 +63,33 @@
 // and this decoder takes that format and converts it into 24-bit RGB with alpha channel
 // support. It was modeled a bit off the PPM decoder.
 //
 // Assumptions about the decoder:
 // (1) We receive ALL of the data from the icon channel in one OnDataAvailable call. We don't
 //     support multiple ODA calls yet.
 // (2) the format of the incoming data is as follows:
 //     The first two bytes contain the width and the height of the icon. 
+#ifdef MOZ_CAIRO_GFX
 //     The remaining bytes contain the icon data, 4 bytes per pixel, in
 //       ARGB order (platform endianness, A in highest bits, B in lowest
 //       bits), row-primary, top-to-bottom, left-to-right, with
 //       premultiplied alpha.
+#else
+//     The third byte contains the number of bits per pixel in the alpha
+//       channel (either 1 or 8).
+//     Followed by 3 bytes per pixel for the color bitmap row after row,
+//       from top to bottom, with pixels left to right within rows, and
+//       RGB order within pixels, in platform endianness.  Alpha is
+//       *not* premultiplied.
+//       XXXldb This isn't quite right -- we're just using
+//       platform-native format.
+//     Followed by alpha data (1 or 8 bits per pixel, see above) in the
+//       same order as the RGB data, and also in platform endianness.
+#endif
 //
 //
 //////////////////////////////////////////////////////////////////////////////////////////////
 
 class nsIconDecoder : public imgIDecoder
 {
 public:
   NS_DECL_ISUPPORTS
Index: mozilla/modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp
+++ mozilla/modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp
@@ -309,60 +309,99 @@ nsresult nsIconChannel::MakeInputStream(
   if (!gotBitmap)
     return NS_ERROR_NOT_AVAILABLE;
 
   BScreen mainScreen(B_MAIN_SCREEN_ID);
   if (!mainScreen.IsValid())
     return NS_ERROR_NOT_AVAILABLE;
 
   // Got a bitmap and color space info - convert data to mozilla's icon format
+#ifdef MOZ_CAIRO_GFX
   PRUint32 iconLength = 2 + iconSize * iconSize * 4;
+#else
+  PRUint32 iconLength = 3 + iconSize * (iconSize * 3 + alphaBytesPerRow);
+#endif
   uint8 *buffer = new uint8[iconLength];
   if (!buffer)
     return NS_ERROR_OUT_OF_MEMORY;
 
   uint8* destByte = buffer;
   *(destByte++) = iconSize;
   *(destByte++) = iconSize;
+#ifndef MOZ_CAIRO_GFX
+  *(destByte++) = 1; // alpha bits per pixel
+#endif
 
   // RGB data
   uint8* sourceByte = (uint8*)nativeIcon.Bits();
   for(PRUint32 iconRow = 0; iconRow < iconSize; iconRow++)
   {
     sourceByte = (uint8*)nativeIcon.Bits() + nativeIcon.BytesPerRow() * iconRow;
     for(PRUint32 iconCol = 0; iconCol < iconSize; iconCol++)
     {
       if (*sourceByte != B_TRANSPARENT_MAGIC_CMAP8)
       {
         rgb_color colorVal = mainScreen.ColorForIndex(*sourceByte);
+#ifdef MOZ_CAIRO_GFX
 #ifdef IS_LITTLE_ENDIAN
         *(destByte++) = colorVal.blue;
         *(destByte++) = colorVal.green;
         *(destByte++) = colorVal.red;
         *(destByte++) = uint8(255);
 #else
         *(destByte++) = uint8(255);
         *(destByte++) = colorVal.red;
         *(destByte++) = colorVal.green;
         *(destByte++) = colorVal.blue;
 #endif
+#else
+        *(destByte++) = colorVal.blue;
+        *(destByte++) = colorVal.green;
+        *(destByte++) = colorVal.red;
+#endif
       }
       else
       {
         *destByte++ = 0;
         *destByte++ = 0;
         *destByte++ = 0;
+#ifdef MOZ_CAIRO_GFX
         *destByte++ = 0;
+#endif
       }
       // original code had a conditional here:
       // if (iconCol < iconSize - 1) 
       // Leaving this comment in case complications arise later
       sourceByte++;
     }
   }
+#ifndef MOZ_CAIRO_GFX
+  // Alpha data - bitmask, with rows aligned on 32-bit boundaries
+  for(PRUint32 iconRow = 0; iconRow < iconSize; iconRow++)
+  {
+    destByte = buffer + 3 + iconSize * iconSize * 3 + iconRow * alphaBytesPerRow;
+    sourceByte = (uint8*)nativeIcon.Bits() + nativeIcon.BytesPerRow() * iconRow;
+    int bitNo = 0;
+    for(PRUint32 iconCol = 0; iconCol < iconSize; iconCol++)
+    {
+      if (*sourceByte == B_TRANSPARENT_MAGIC_CMAP8)
+        (*destByte) &= (~(128 >> (bitNo % 8)));
+      else
+        (*destByte) |= (128 >> (bitNo % 8));
+
+      //original code had a conditional here:
+      //if (iconCol < iconSize - 1)
+      //Leaving this comment in case complications arise later
+      bitNo++;
+      sourceByte++;
+      if ((bitNo%8) == 0)
+        destByte++;
+    }
+  }
+#endif
 
   NS_ASSERTION(buffer + iconLength == destByte, "size miscalculation");
   
   // Now, create a pipe and stuff our data into it
   nsCOMPtr<nsIInputStream> inStream;
   nsCOMPtr<nsIOutputStream> outStream;
   rv = NS_NewPipe(getter_AddRefs(inStream), getter_AddRefs(outStream),
                   iconLength, iconLength, nonBlocking);
Index: mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp
+++ mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp
@@ -73,16 +73,19 @@ METHODDEF(void) my_error_exit (j_common_
 
 
 nsJPEGDecoder::nsJPEGDecoder()
 {
   mState = JPEG_HEADER;
   mReading = PR_TRUE;
 
   mSamples = nsnull;
+#ifndef MOZ_CAIRO_GFX
+  mRGBRow = nsnull;
+#endif
 
   mBytesToSkip = 0;
   memset(&mInfo, 0, sizeof(jpeg_decompress_struct));
   memset(&mSourceMgr, 0, sizeof(mSourceMgr));
   mInfo.client_data = (void*)this;
 
   mBuffer = nsnull;
   mBufferLen = mBufferSize = 0;
@@ -90,16 +93,19 @@ nsJPEGDecoder::nsJPEGDecoder()
   mBackBuffer = nsnull;
   mBackBufferLen = mBackBufferSize = mBackBufferUnreadLen = 0;
 }
 
 nsJPEGDecoder::~nsJPEGDecoder()
 {
   PR_FREEIF(mBuffer);
   PR_FREEIF(mBackBuffer);
+#ifndef MOZ_CAIRO_GFX
+  PR_FREEIF(mRGBRow);
+#endif
 }
 
 
 /** imgIDecoder methods **/
 
 /* void init (in imgILoad aLoad); */
 NS_IMETHODIMP nsJPEGDecoder::Init(imgILoad *aLoad)
 {
@@ -324,16 +330,28 @@ NS_IMETHODIMP nsJPEGDecoder::WriteFrom(n
     /* 
      * From: http://apodeline.free.fr/DOC/libjpeg/libjpeg-2.html#ss2.3 :
      * PLEASE NOTE THAT RGB DATA IS THREE SAMPLES PER PIXEL, GRAYSCALE ONLY ONE
      */
     mSamples = (*mInfo.mem->alloc_sarray)((j_common_ptr) &mInfo,
                                           JPOOL_IMAGE,
                                           mInfo.output_width * 3, 1);
 
+#ifndef MOZ_CAIRO_GFX
+#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(XP_MAC) || defined(XP_MACOSX) || defined(MOZ_WIDGET_PHOTON)
+#if defined(XP_MAC) || defined(XP_MACOSX)
+    const int row_stride = mInfo.output_width * 4;
+#else
+    const int row_stride = mInfo.output_width * 3;
+#endif
+    // allocate buffer to do byte flipping / padding
+    mRGBRow = (PRUint8*) PR_MALLOC(row_stride);
+#endif
+#endif
+
     mState = JPEG_START_DECOMPRESS;
   }
 
   case JPEG_START_DECOMPRESS:
   {
     LOG_SCOPE(gJPEGlog, "nsJPEGDecoder::WriteFrom -- entering JPEG_START_DECOMPRESS case");
     /* Step 4: set parameters for decompression */
 
@@ -462,42 +480,95 @@ NS_IMETHODIMP nsJPEGDecoder::WriteFrom(n
 
 
 PRBool
 nsJPEGDecoder::OutputScanlines()
 {
   const PRUint32 top = mInfo.output_scanline;
   PRBool rv = PR_TRUE;
 
+#if defined(MOZ_CAIRO_GFX)
   // we're thebes. we can write stuff directly to the data
   PRUint8 *imageData;
   PRUint32 imageDataLength;
   mFrame->GetImageData(&imageData, &imageDataLength);
+#else
+  // Note! row_stride here must match the row_stride in
+  // nsJPEGDecoder::WriteFrom
+#if defined(XP_MAC) || defined(XP_MACOSX)
+  const int row_stride = mInfo.output_width * 4;
+#else
+  const int row_stride = mInfo.output_width * 3;
+#endif
+  PRUint32 bpr;
+  mFrame->GetImageBytesPerRow(&bpr);
+  JSAMPROW samples;
+#endif
 
   while ((mInfo.output_scanline < mInfo.output_height)) {
+
       /* Request one scanline.  Returns 0 or 1 scanlines. */    
       if (jpeg_read_scanlines(&mInfo, mSamples, 1) != 1) {
         rv = PR_FALSE; /* suspend */
         break;
       }
 
       // offset is in Cairo pixels (PRUint32)
+#if defined(MOZ_CAIRO_GFX)
       PRUint32 offset = (mInfo.output_scanline - 1) * mInfo.output_width;
       PRUint32 *ptrOutputBuf = ((PRUint32*)imageData) + offset;
       JSAMPLE *j1 = mSamples[0];
       for (PRUint32 i=mInfo.output_width; i>0; --i) {
         *ptrOutputBuf++ = GFX_PACKED_PIXEL(0xFF, j1[0], j1[1], j1[2]);
         j1+=3;
       }
+#else
+
+#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON)
+      PRUint8 *ptrOutputBuf = mRGBRow;
+
+      JSAMPLE *j1 = mSamples[0];
+      for (PRUint32 i=0;i<mInfo.output_width;++i) {
+        ptrOutputBuf[2] = *j1++;
+        ptrOutputBuf[1] = *j1++;
+        ptrOutputBuf[0] = *j1++;
+        ptrOutputBuf += 3;
+      }
+
+      samples = mRGBRow;
+#elif defined(XP_MAC) || defined(XP_MACOSX)
+      PRUint8 *ptrOutputBuf = mRGBRow;
+
+      JSAMPLE *j1 = mSamples[0];
+      for (PRUint32 i=0;i<mInfo.output_width;++i) {
+        ptrOutputBuf[0] = 0;
+        ptrOutputBuf[1] = *j1++;
+        ptrOutputBuf[2] = *j1++;
+        ptrOutputBuf[3] = *j1++;
+        ptrOutputBuf += 4;
+      }
+
+      samples = mRGBRow;
+#else
+      samples = mSamples[0];
+#endif
+
+      mFrame->SetImageData(
+        samples,             // data
+        row_stride,          // length
+        (mInfo.output_scanline-1) * bpr); // offset
+#endif
   }
 
   if (top != mInfo.output_scanline) {
       nsIntRect r(0, top, mInfo.output_width, mInfo.output_scanline-top);
       nsCOMPtr<nsIImage> img(do_GetInterface(mFrame));
+#if defined(MOZ_CAIRO_GFX)
       img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+#endif
       mObserver->OnDataAvailable(nsnull, mFrame, &r);
   }
 
   return rv;
 }
 
 
 /* Override the standard error method in the IJG JPEG decoder code. */
Index: mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h
+++ mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h
@@ -101,16 +101,19 @@ public:
   nsCOMPtr<imgIDecoderObserver> mObserver;
 
   struct jpeg_decompress_struct mInfo;
   struct jpeg_source_mgr mSourceMgr;
   decoder_error_mgr mErr;
   jstate mState;
 
   JSAMPARRAY mSamples;
+#ifndef MOZ_CAIRO_GFX
+  PRUint8*   mRGBRow;
+#endif
 
   PRUint32 mBytesToSkip;
 
   JOCTET *mBuffer;
   PRUint32 mBufferLen;  // amount of data currently in mBuffer
   PRUint32 mBufferSize; // size in bytes what mBuffer was created with
 
   JOCTET *mBackBuffer;
Index: mozilla/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp
+++ mozilla/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp
@@ -251,27 +251,41 @@ nsresult nsXBMDecoder::ProcessData(const
                 mPos = endPtr; // go to next value only when done with this one
             if (mIsX10) {
                 // handle X10 flavor short values
                 if (hiByte)
                     pixel >>= 8;
                 hiByte = !hiByte;
             }
 
+#ifdef MOZ_CAIRO_GFX
             PRUint32 *ar = ((PRUint32*)mAlphaRow) + mCurCol;
             const int alphas = PR_MIN(8, mWidth - mCurCol);
             for (int i = 0; i < alphas; i++) {
                 const PRUint8 val = ((pixel & (1 << i)) >> i) ? 255 : 0;
                 *ar++ = (val << 24) | 0;
             }
-
+#else // MOZ_CAIRO_GFX
+            mAlphaRow[mCurCol/8] = 0;
+            for (int i = 0; i < 8; i++) {
+                PRUint8 val = (pixel & (1 << i)) >> i;
+                mAlphaRow[mCurCol/8] |= val << (7 - i);
+            }
+#endif
             mCurCol = PR_MIN(mCurCol + 8, mWidth);
             if (mCurCol == mWidth || mState == RECV_DONE) {
+#ifdef MOZ_CAIRO_GFX
                 mFrame->SetImageData(mAlphaRow, abpr, mCurRow * abpr);
-
+#else
+                // Row finished. Set Data.
+                mFrame->SetAlphaData(mAlphaRow, abpr, mCurRow * abpr);
+                // nsnull gets interpreted as all-zeroes, which is what we
+                // want
+                mFrame->SetImageData(nsnull, bpr, mCurRow * bpr);
+#endif
                 nsIntRect r(0, mCurRow, mWidth, 1);
                 mObserver->OnDataAvailable(nsnull, mFrame, &r);
 
                 if ((mCurRow + 1) == mHeight) {
                     mState = RECV_DONE;
                     return mObserver->OnStopFrame(nsnull, mFrame);
                 }
                 mCurRow++;
Index: mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
@@ -44,17 +44,19 @@
 
 #include "nsIComponentManager.h"
 #include "nsIInputStream.h"
 
 #include "imgIContainerObserver.h"
 #include "nsIImage.h"
 #include "nsIInterfaceRequestorUtils.h"
 
+#ifdef MOZ_CAIRO_GFX
 #include "gfxColor.h"
+#endif
 #include "nsColor.h"
 
 #include "nspr.h"
 #include "png.h"
 
 static void PNGAPI info_callback(png_structp png_ptr, png_infop info_ptr);
 static void PNGAPI row_callback(png_structp png_ptr, png_bytep new_row,
                            png_uint_32 row_num, int pass);
@@ -65,23 +67,33 @@ static void PNGAPI warning_callback(png_
 #ifdef PR_LOGGING
 PRLogModuleInfo *gPNGLog = PR_NewLogModule("PNGDecoder");
 #endif
 
 NS_IMPL_ISUPPORTS1(nsPNGDecoder, imgIDecoder)
 
 nsPNGDecoder::nsPNGDecoder() :
   mPNG(nsnull), mInfo(nsnull),
+#ifndef MOZ_CAIRO_GFX
+  colorLine(nsnull),
+  alphaLine(nsnull),
+#endif
   interlacebuf(nsnull), ibpr(0),
   mError(PR_FALSE)
 {
 }
 
 nsPNGDecoder::~nsPNGDecoder()
 {
+#ifndef MOZ_CAIRO_GFX
+  if (colorLine)
+    nsMemory::Free(colorLine);
+  if (alphaLine)
+    nsMemory::Free(alphaLine);
+#endif
   if (interlacebuf)
     nsMemory::Free(interlacebuf);
 }
 
 
 /** imgIDecoder methods **/
 
 /* void init (in imgILoad aLoad); */
@@ -242,16 +254,22 @@ info_callback(png_structp png_ptr, png_i
 
   if (bit_depth == 16)
     png_set_strip_16(png_ptr);
 
   if (color_type == PNG_COLOR_TYPE_GRAY ||
       color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
       png_set_gray_to_rgb(png_ptr);
 
+
+#if !defined(MOZ_CAIRO_GFX) && (defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON))
+  // windows likes BGR
+  png_set_bgr(png_ptr);
+#endif
+
   if (png_get_gAMA(png_ptr, info_ptr, &aGamma)) {
       if ((aGamma <= 0.0) || (aGamma > 21474.83)) {
           aGamma = 0.45455;
           png_set_gAMA(png_ptr, info_ptr, aGamma);
       }
       png_set_gamma(png_ptr, 2.2, aGamma);
   }
   else
@@ -320,29 +338,40 @@ info_callback(png_structp png_ptr, png_i
   } else if (channels > 3) {
     if (alpha_bits == 8) {
       decoder->mImage->GetPreferredAlphaChannelFormat(&format);
     } else if (alpha_bits == 1) {
       format = gfxIFormats::RGB_A1;
     }
   }
 
+#if !defined(MOZ_CAIRO_GFX) && (defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON))
+  // XXX this works...
+  format += 1; // RGB to BGR
+#endif
+
   // then initialize the frame and append it to the container
   nsresult rv = decoder->mFrame->Init(0, 0, width, height, format, 24);
   if (NS_FAILED(rv))
     longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
 
   decoder->mImage->AppendFrame(decoder->mFrame);
 
   if (decoder->mObserver)
     decoder->mObserver->OnStartFrame(nsnull, decoder->mFrame);
 
   PRUint32 bpr;
   decoder->mFrame->GetImageBytesPerRow(&bpr);
-
+#ifndef MOZ_CAIRO_GFX
+  PRUint32 abpr;
+  decoder->mFrame->GetAlphaBytesPerRow(&abpr);
+  decoder->colorLine = (PRUint8 *)nsMemory::Alloc(bpr);
+  if (channels > 3)
+    decoder->alphaLine = (PRUint8 *)nsMemory::Alloc(abpr);
+#endif
   if (interlace_type == PNG_INTERLACE_ADAM7) {
     if (channels > 3)
       decoder->ibpr = channels*width;
     else
       decoder->ibpr = bpr;
     decoder->interlacebuf = (PRUint8 *)nsMemory::Alloc(decoder->ibpr*height);
     if (!decoder->interlacebuf) {
       longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
@@ -395,56 +424,123 @@ row_callback(png_structp png_ptr, png_by
 
   if (new_row) {
     PRInt32 width;
     decoder->mFrame->GetWidth(&width);
     PRUint32 iwidth = width;
 
     gfx_format format;
     decoder->mFrame->GetFormat(&format);
-
+#if defined(MOZ_CAIRO_GFX)
     // we're thebes. we can write stuff directly to the data
     PRUint8 *imageData;
     PRUint32 imageDataLength, bpr = width * sizeof(PRUint32);
     decoder->mFrame->GetImageData(&imageData, &imageDataLength);
     PRUint32 *cptr32 = (PRUint32*)(imageData + (row_num*bpr));
+#else
+    PRUint8 *aptr, *cptr;
+    PRUint32 bpr, abpr;
+    decoder->mFrame->GetImageBytesPerRow(&bpr);
+    decoder->mFrame->GetAlphaBytesPerRow(&abpr);
+    // The mac specific ifdefs in the code below are there to make sure we
+    // always fill in 4 byte pixels right now, which is what the mac always
+    // allocates for its pixel buffers in true color mode. This will change
+    // when we start storing images with color palettes when they don't need
+    // true color support (GIFs).
+#endif
 
     switch (format) {
     case gfxIFormats::RGB:
     case gfxIFormats::BGR:
       {
+#if defined(MOZ_CAIRO_GFX)
         for (PRUint32 x=iwidth; x>0; --x) {
           *cptr32++ = GFX_PACKED_PIXEL(0xFF, line[0], line[1], line[2]);
           line += 3;
         }
+#elif defined(XP_MAC) || defined(XP_MACOSX)
+        cptr = decoder->colorLine;
+        for (PRUint32 x=0; x<iwidth; x++) {
+          *cptr++ = 0;
+          *cptr++ = *line++;
+          *cptr++ = *line++;
+          *cptr++ = *line++;
+        }
+        decoder->mFrame->SetImageData(decoder->colorLine, bpr, row_num*bpr);
+#else
+        decoder->mFrame->SetImageData((PRUint8*)line, bpr, row_num*bpr);
+#endif
       }
       break;
     case gfxIFormats::RGB_A1:
     case gfxIFormats::BGR_A1:
       {
+#if defined(MOZ_CAIRO_GFX)
         for (PRUint32 x=iwidth; x>0; --x) {
           *cptr32++ = GFX_PACKED_PIXEL(line[3]?0xFF:0x00, line[0], line[1], line[2]);
           line += 4;
         }
+#else
+        cptr = decoder->colorLine;
+        aptr = decoder->alphaLine;
+        memset(aptr, 0, abpr);
+        for (PRUint32 x=0; x<iwidth; x++) {
+#if defined(XP_MAC) || defined(XP_MACOSX)
+          *cptr++ = 0;
+#endif
+          if (line[3]) {
+            *cptr++ = *line++;
+            *cptr++ = *line++;
+            *cptr++ = *line++;
+            aptr[x>>3] |= 1<<(7-x&0x7);
+            line++;
+          } else {
+            *cptr++ = 0;
+            *cptr++ = 0;
+            *cptr++ = 0;
+            line += 4;
+          }
+        }
+        decoder->mFrame->SetAlphaData(decoder->alphaLine, abpr, row_num*abpr);
+        decoder->mFrame->SetImageData(decoder->colorLine, bpr, row_num*bpr);
+#endif
       }
       break;
     case gfxIFormats::RGB_A8:
     case gfxIFormats::BGR_A8:
       {
+#if defined(MOZ_CAIRO_GFX)
         for (PRUint32 x=width; x>0; --x) {
           *cptr32++ = GFX_PACKED_PIXEL(line[3], line[0], line[1], line[2]);
           line += 4;
         }
+#else
+        cptr = decoder->colorLine;
+        aptr = decoder->alphaLine;
+        for (PRUint32 x=0; x<iwidth; x++) {
+#if defined(XP_MAC) || defined(XP_MACOSX)
+          *cptr++ = 0;
+#endif
+          *cptr++ = *line++;
+          *cptr++ = *line++;
+          *cptr++ = *line++;
+          *aptr++ = *line++;
+        }
+        decoder->mFrame->SetAlphaData(decoder->alphaLine, abpr, row_num*abpr);
+        decoder->mFrame->SetImageData(decoder->colorLine, bpr, row_num*bpr);
+#endif
       }
       break;
     }
 
     nsIntRect r(0, row_num, width, 1);
+#if defined(MOZ_CAIRO_GFX)
     nsCOMPtr<nsIImage> img(do_GetInterface(decoder->mFrame));
     img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
+#endif
     decoder->mObserver->OnDataAvailable(nsnull, decoder->mFrame, &r);
   }
 }
 
 
 
 void
 end_callback(png_structp png_ptr, png_infop info_ptr)
Index: mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/png/nsPNGDecoder.h
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h
@@ -72,14 +72,17 @@ public:
 public:
   nsCOMPtr<imgIContainer> mImage;
   nsCOMPtr<gfxIImageFrame> mFrame;
   nsCOMPtr<imgILoad> mImageLoad;
   nsCOMPtr<imgIDecoderObserver> mObserver; // this is just qi'd from mRequest for speed
 
   png_structp mPNG;
   png_infop mInfo;
+#ifndef MOZ_CAIRO_GFX
+  PRUint8 *colorLine, *alphaLine;
+#endif
   PRUint8 *interlacebuf;
   PRUint32 ibpr;
   PRPackedBool mError;
 };
 
 #endif // nsPNGDecoder_h__
Index: mozilla/modules/libpr0n/decoders/icon/gtk/nsIconChannel.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/icon/gtk/nsIconChannel.cpp
+++ mozilla/modules/libpr0n/decoders/icon/gtk/nsIconChannel.cpp
@@ -78,31 +78,45 @@ moz_gdk_pixbuf_to_channel(GdkPixbuf* aPi
   NS_ENSURE_TRUE(height < 256 && width < 256 && height > 0 && width > 0 &&
                  gdk_pixbuf_get_colorspace(aPixbuf) == GDK_COLORSPACE_RGB &&
                  gdk_pixbuf_get_bits_per_sample(aPixbuf) == 8 &&
                  gdk_pixbuf_get_has_alpha(aPixbuf) &&
                  gdk_pixbuf_get_n_channels(aPixbuf) == 4,
                  NS_ERROR_UNEXPECTED);
 
   const int n_channels = 4;
+#ifdef MOZ_CAIRO_GFX
   gsize buf_size = 2 + n_channels * height * width;
+#else
+  gsize buf_size = 3 + n_channels * height * width;
+#endif
   PRUint8 * const buf = (PRUint8*)NS_Alloc(buf_size);
   NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
   PRUint8 *out = buf;
 
   *(out++) = width;
   *(out++) = height;
-
+#ifndef MOZ_CAIRO_GFX
+  *(out++) = 8; // bits of alpha per pixel
+#endif
+
   const guchar * const pixels = gdk_pixbuf_get_pixels(aPixbuf);
   int rowextra = gdk_pixbuf_get_rowstride(aPixbuf) - width * n_channels;
 
   // encode the RGB data and the A data
   const guchar * in = pixels;
+#ifndef MOZ_CAIRO_GFX
+  PRUint8 *alpha_out = out + height * width * 3;
+#ifdef DEBUG
+  PRUint8 * const alpha_start = alpha_out;
+#endif
+#endif
   for (int y = 0; y < height; ++y, in += rowextra) {
     for (int x = 0; x < width; ++x) {
+#ifdef MOZ_CAIRO_GFX
       PRUint8 r = *(in++);
       PRUint8 g = *(in++);
       PRUint8 b = *(in++);
       PRUint8 a = *(in++);
 #define DO_PREMULTIPLY(c_) PRUint8(PRUint16(c_) * PRUint16(a) / PRUint16(255))
 #ifdef IS_LITTLE_ENDIAN
       *(out++) = DO_PREMULTIPLY(b);
       *(out++) = DO_PREMULTIPLY(g);
@@ -110,20 +124,31 @@ moz_gdk_pixbuf_to_channel(GdkPixbuf* aPi
       *(out++) = a;
 #else
       *(out++) = a;
       *(out++) = DO_PREMULTIPLY(r);
       *(out++) = DO_PREMULTIPLY(g);
       *(out++) = DO_PREMULTIPLY(b);
 #endif
 #undef DO_PREMULTIPLY
+#else
+      *(out++) = *(in++); // R
+      *(out++) = *(in++); // G
+      *(out++) = *(in++); // B
+      *(alpha_out++) = *(in++); // A
+#endif
     }
   }
 
+#ifdef MOZ_CAIRO_GFX
   NS_ASSERTION(out == buf + buf_size, "size miscalculation");
+#else
+  NS_ASSERTION(out == alpha_start && alpha_out == buf + buf_size,
+               "size miscalculation");
+#endif
 
   nsresult rv;
   nsCOMPtr<nsIStringInputStream> stream =
     do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = stream->AdoptData((char*)buf, buf_size);
   NS_ENSURE_SUCCESS(rv, rv);
Index: mozilla/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm
+++ mozilla/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm
@@ -307,51 +307,79 @@ nsresult nsIconChannel::MakeInputStream(
                  [bitmapRep samplesPerPixel] == 4 &&
                  [bitmapRep hasAlpha] == YES,
                  NS_ERROR_UNEXPECTED);
   
   // rgba, pre-multiplied data
   PRUint8* bitmapRepData = (PRUint8*)[bitmapRep bitmapData];
   
   // create our buffer
+#ifdef MOZ_CAIRO_GFX
   PRInt32 bufferCapacity = 2 + desiredImageSize * desiredImageSize * 4;
+#else
+  PRInt32 bufferCapacity = 3 + desiredImageSize * desiredImageSize * 5;
+#endif
   nsAutoBuffer<PRUint8, 3 + 16 * 16 * 5> iconBuffer; // initial size is for 16x16
   if (!iconBuffer.EnsureElemCapacity(bufferCapacity))
     return NS_ERROR_OUT_OF_MEMORY;
   
   PRUint8* iconBufferPtr = iconBuffer.get();
   
   // write header data into buffer
   *iconBufferPtr++ = desiredImageSize;
   *iconBufferPtr++ = desiredImageSize;
-
+#ifndef MOZ_CAIRO_GFX
+  *iconBufferPtr++ = 8; // alpha bits per pixel
+#endif
+
   PRUint32 dataCount = (desiredImageSize * desiredImageSize) * 4;
   PRUint32 index = 0;
   while (index < dataCount) {
     // get data from the bitmap
     PRUint8 r = bitmapRepData[index++];
     PRUint8 g = bitmapRepData[index++];
     PRUint8 b = bitmapRepData[index++];
     PRUint8 a = bitmapRepData[index++];
-
+
+#ifndef MOZ_CAIRO_GFX
+    // reverse premultiplication
+    if (a == 0) {
+      r = g = b = 0;
+    }
+    else {
+      r = ((PRUint32) r) * 255 / a;
+      g = ((PRUint32) g) * 255 / a;
+      b = ((PRUint32) b) * 255 / a;
+    }
+#endif
+
     // write data out to our buffer
     // non-cairo uses native image format, but the A channel is ignored.
     // cairo uses ARGB (highest to lowest bits)
-#if defined(IS_LITTLE_ENDIAN)
+#if defined(MOZ_CAIRO_GFX) && defined(IS_LITTLE_ENDIAN)
     *iconBufferPtr++ = b;
     *iconBufferPtr++ = g;
     *iconBufferPtr++ = r;
     *iconBufferPtr++ = a;
 #else
     *iconBufferPtr++ = a;
     *iconBufferPtr++ = r;
     *iconBufferPtr++ = g;
     *iconBufferPtr++ = b;
 #endif
   }
+
+#ifndef MOZ_CAIRO_GFX
+  // add the alpha to the buffer
+  index = 3;
+  while (index < dataCount) {
+    *iconBufferPtr++ = bitmapRepData[index];
+    index += 4;
+  }
+#endif
 
   NS_ASSERTION(iconBufferPtr == iconBuffer.get() + bufferCapacity,
                "buffer size miscalculation");
   
   // Now, create a pipe and stuff our data into it
   nsCOMPtr<nsIInputStream> inStream;
   nsCOMPtr<nsIOutputStream> outStream;
   rv = NS_NewPipe(getter_AddRefs(inStream), getter_AddRefs(outStream), bufferCapacity, bufferCapacity, nonBlocking);  
