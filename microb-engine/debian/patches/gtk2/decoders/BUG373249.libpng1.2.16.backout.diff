diff -ruN -p -U10 mozilla.orig/modules/libimg/png/png.c mozilla/modules/libimg/png/png.c
--- mozilla.orig/modules/libimg/png/png.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/png.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,26 +1,26 @@
 
 /* png.c - location for general purpose libpng functions
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 #define PNG_INTERNAL
 #define PNG_NO_EXTERN
 #include "png.h"
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef version_1_2_16 Your_png_h_is_not_version_1_2_16;
+typedef version_1_2_12 Your_png_h_is_not_version_1_2_12;
 
 /* Version information for C files.  This had better match the version
  * string defined in png.h.  */
 
 #ifdef PNG_USE_GLOBAL_ARRAYS
 /* png_libpng_ver was changed to a function in version 1.0.5c */
 const char png_libpng_ver[18] = PNG_LIBPNG_VER_STRING;
 
 #ifdef PNG_READ_SUPPORTED
 
@@ -93,21 +93,20 @@ const int FARDATA png_pass_dsp_mask[]
 /* Tells libpng that we have already handled the first "num_bytes" bytes
  * of the PNG file signature.  If the PNG data is embedded into another
  * stream we can set num_bytes = 8 so that libpng will not attempt to read
  * or write any of the magic bytes before it starts on the IHDR.
  */
 
 #ifdef PNG_READ_SUPPORTED
 void PNGAPI
 png_set_sig_bytes(png_structp png_ptr, int num_bytes)
 {
-   if(png_ptr == NULL) return;
    png_debug(1, "in png_set_sig_bytes\n");
    if (num_bytes > 8)
       png_error(png_ptr, "Too many bytes for PNG signature.");
 
    png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
 }
 
 /* Checks whether the supplied bytes match the PNG signature.  We allow
  * checking less than the full 8-byte signature so that those apps that
  * already read the first few bytes of a file to determine the file type
@@ -150,28 +149,27 @@ png_check_sig(png_bytep sig, int num)
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 /* Function to allocate memory for zlib and clear it to 0. */
 #ifdef PNG_1_0_X
 voidpf PNGAPI
 #else
 voidpf /* private */
 #endif
 png_zalloc(voidpf png_ptr, uInt items, uInt size)
 {
    png_voidp ptr;
-   png_structp p=(png_structp)png_ptr;
+   png_structp p=png_ptr;
    png_uint_32 save_flags=p->flags;
    png_uint_32 num_bytes;
 
-   if(png_ptr == NULL) return (NULL);
    if (items > PNG_UINT_32_MAX/size)
    {
-     png_warning (p, "Potential overflow in png_zalloc()");
+     png_warning (png_ptr, "Potential overflow in png_zalloc()");
      return (NULL);
    }
    num_bytes = (png_uint_32)items * size;
 
    p->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
    ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);
    p->flags=save_flags;
 
 #if defined(PNG_1_0_X) && !defined(PNG_NO_ZALLOC_ZERO)
    if (ptr == NULL)
@@ -264,21 +262,20 @@ png_create_info_struct(png_structp png_p
 
 /* This function frees the memory associated with a single info struct.
  * Normally, one would use either png_destroy_read_struct() or
  * png_destroy_write_struct() to free an info struct, but this may be
  * useful for some applications.
  */
 void PNGAPI
 png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
 {
    png_infop info_ptr = NULL;
-   if(png_ptr == NULL) return;
 
    png_debug(1, "in png_destroy_info_struct\n");
    if (info_ptr_ptr != NULL)
       info_ptr = *info_ptr_ptr;
 
    if (info_ptr != NULL)
    {
       png_info_destroy(png_ptr, info_ptr);
 
 #ifdef PNG_USER_MEM_SUPPORTED
@@ -303,22 +300,20 @@ png_info_init(png_infop info_ptr)
    /* We only come here via pre-1.0.12-compiled applications */
    png_info_init_3(&info_ptr, 0);
 }
 #endif
 
 void PNGAPI
 png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
 {
    png_infop info_ptr = *ptr_ptr;
 
-   if(info_ptr == NULL) return;
-
    png_debug(1, "in png_info_init_3\n");
 
    if(png_sizeof(png_info) > png_info_struct_size)
      {
        png_destroy_struct(info_ptr);
        info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
        *ptr_ptr = info_ptr;
      }
 
    /* set everything to 0 */
@@ -612,53 +607,50 @@ png_info_destroy(png_structp png_ptr, pn
 }
 #endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
 
 /* This function returns a pointer to the io_ptr associated with the user
  * functions.  The application should free any memory associated with this
  * pointer before png_write_destroy() or png_read_destroy() are called.
  */
 png_voidp PNGAPI
 png_get_io_ptr(png_structp png_ptr)
 {
-   if(png_ptr == NULL) return (NULL);
    return (png_ptr->io_ptr);
 }
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 #if !defined(PNG_NO_STDIO)
 /* Initialize the default input/output functions for the PNG file.  If you
  * use your own read or write routines, you can call either png_set_read_fn()
  * or png_set_write_fn() instead of png_init_io().  If you have defined
  * PNG_NO_STDIO, you must use a function of your own because "FILE *" isn't
  * necessarily available.
  */
 void PNGAPI
 png_init_io(png_structp png_ptr, png_FILE_p fp)
 {
    png_debug(1, "in png_init_io\n");
-   if(png_ptr == NULL) return;
    png_ptr->io_ptr = (png_voidp)fp;
 }
 #endif
 
 #if defined(PNG_TIME_RFC1123_SUPPORTED)
 /* Convert the supplied time into an RFC 1123 string suitable for use in
  * a "Creation Time" or other text-based time string.
  */
 png_charp PNGAPI
 png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)
 {
    static PNG_CONST char short_months[12][4] =
         {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 
-   if(png_ptr == NULL) return (NULL);
    if (png_ptr->time_buffer == NULL)
    {
       png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
          png_sizeof(char)));
    }
 
 #if defined(_WIN32_WCE)
    {
       wchar_t time_buf[29];
       wsprintf(time_buf, TEXT("%d %S %d %02d:%02d:%02d +0000"),
@@ -697,22 +689,22 @@ png_sig_bytes(void)
 {
    return ((png_bytep)"\211\120\116\107\015\012\032\012");
 }
 #endif
 #endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
 
 png_charp PNGAPI
 png_get_copyright(png_structp png_ptr)
 {
    if (&png_ptr != NULL)  /* silence compiler warning about unused png_ptr */
-   return ((png_charp) "\n libpng version 1.2.16 - January 31, 2007\n\
-   Copyright (c) 1998-2007 Glenn Randers-Pehrson\n\
+   return ((png_charp) "\n libpng version 1.2.12 - June 27, 2006\n\
+   Copyright (c) 1998-2006 Glenn Randers-Pehrson\n\
    Copyright (c) 1996-1997 Andreas Dilger\n\
    Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
    return ((png_charp) "");
 }
 
 /* The following return the library version as a short string in the
  * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
  * used with your application, print out PNG_LIBPNG_VER_STRING, which
  * is defined in png.h.
  * Note: now there is no difference between png_get_libpng_ver() and
@@ -761,42 +753,41 @@ png_handle_as_unknown(png_structp png_pt
       if (!png_memcmp(chunk_name, p, 4))
         return ((int)*(p+4));
    return 0;
 }
 #endif
 
 /* This function, added to libpng-1.0.6g, is untested. */
 int PNGAPI
 png_reset_zstream(png_structp png_ptr)
 {
-   if (png_ptr == NULL) return Z_STREAM_ERROR;
    return (inflateReset(&png_ptr->zstream));
 }
 #endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
 
 /* This function was added to libpng-1.0.7 */
 png_uint_32 PNGAPI
 png_access_version_number(void)
 {
    /* Version of *.c files used when building libpng */
    return((png_uint_32) PNG_LIBPNG_VER);
 }
 
 
-#if defined(PNG_READ_SUPPORTED) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_READ_SUPPORTED)
 #if !defined(PNG_1_0_X)
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+    /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
 /* this INTERNAL function was added to libpng 1.2.0 */
 void /* PRIVATE */
 png_init_mmx_flags (png_structp png_ptr)
 {
-    if(png_ptr == NULL) return;
     png_ptr->mmx_rowbytes_threshold = 0;
     png_ptr->mmx_bitdepth_threshold = 0;
 
 #  if (defined(PNG_USE_PNGVCRD) || defined(PNG_USE_PNGGCCRD))
 
     png_ptr->asm_flags |= PNG_ASM_FLAG_MMX_SUPPORT_COMPILED;
 
     if (png_mmx_support() > 0) {
         png_ptr->asm_flags |= PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
 #    ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
@@ -815,40 +806,40 @@ png_init_mmx_flags (png_structp png_ptr)
 
         png_ptr->mmx_rowbytes_threshold = PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT;
         png_ptr->mmx_bitdepth_threshold = PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT;
 #    endif
     } else {
         png_ptr->asm_flags &= ~( PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
                                | PNG_MMX_READ_FLAGS
                                | PNG_MMX_WRITE_FLAGS );
     }
 
-#  else /* !(PNGVCRD || PNGGCCRD) */
+#  else /* !((PNGVCRD || PNGGCCRD) && PNG_ASSEMBLER_CODE_SUPPORTED)) */
 
     /* clear all MMX flags; no support is compiled in */
     png_ptr->asm_flags &= ~( PNG_MMX_FLAGS );
 
 #  endif /* ?(PNGVCRD || PNGGCCRD) */
 }
 
-#endif /* !(PNG_MMX_CODE_SUPPORTED) */
+#endif /* !(PNG_ASSEMBLER_CODE_SUPPORTED) */
 
 /* this function was added to libpng 1.2.0 */
 #if !defined(PNG_USE_PNGGCCRD) && \
-    !(defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
+    !(defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
 int PNGAPI
 png_mmx_support(void)
 {
     return -1;
 }
 #endif
-#endif /* PNG_1_0_X  && PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_1_0_X */
 #endif /* PNG_READ_SUPPORTED */
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 #ifdef PNG_SIZE_T
 /* Added at libpng version 1.2.6 */
    PNG_EXTERN png_size_t PNGAPI png_convert_size PNGARG((size_t size));
 png_size_t PNGAPI
 png_convert_size(size_t size)
 {
   if (size > (png_size_t)-1)
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/png.h mozilla/modules/libimg/png/png.h
--- mozilla.orig/modules/libimg/png/png.h	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/png.h	2007-05-30 07:42:39.000000000 +0300
@@ -1,22 +1,22 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.2.16 - January 31, 2007
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * libpng version 1.2.12 - June 27, 2006
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * Authors and maintainers:
  *  libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *  libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *  libpng versions 0.97, January 1998, through 1.2.16 - January 31, 2007: Glenn
+ *  libpng versions 0.97, January 1998, through 1.2.12 - June 27, 2006: Glenn
  *  See also "Contributing Authors", below.
  *
  * Note about libpng version numbers:
  *
  *    Due to various miscommunications, unforeseen code incompatibilities
  *    and occasional factors outside the authors' control, version numbering
  *    on the library has not always been consistent and straightforward.
  *    The following table summarizes matters since version 0.89c, which was
  *    the first widely used release:
  *
@@ -119,37 +119,20 @@
  *    1.2.10beta1-8           13    10210  12.so.0.10[.0]
  *    1.2.10rc1-3             13    10210  12.so.0.10[.0]
  *    1.2.10                  13    10210  12.so.0.10[.0]
  *    1.2.11beta1-4           13    10211  12.so.0.11[.0]
  *    1.0.19rc1-5             10    10019  10.so.0.19[.0]
  *    1.2.11rc1-5             13    10211  12.so.0.11[.0]
  *    1.0.19                  10    10019  10.so.0.19[.0]
  *    1.2.11                  13    10211  12.so.0.11[.0]
  *    1.0.20                  10    10020  10.so.0.20[.0]
  *    1.2.12                  13    10212  12.so.0.12[.0]
- *    1.2.13beta1             13    10213  12.so.0.13[.0]
- *    1.0.21                  10    10021  10.so.0.21[.0]
- *    1.2.13                  13    10213  12.so.0.13[.0]
- *    1.2.14beta1-2           13    10214  12.so.0.14[.0]
- *    1.0.22rc1               10    10022  10.so.0.22[.0]
- *    1.2.14rc1               13    10214  12.so.0.14[.0]
- *    1.0.22                  10    10022  10.so.0.22[.0]
- *    1.2.14                  13    10214  12.so.0.14[.0]
- *    1.2.15beta1-6           13    10215  12.so.0.15[.0]
- *    1.0.23rc1-5             10    10023  10.so.0.23[.0]
- *    1.2.15rc1-5             13    10215  12.so.0.15[.0]
- *    1.0.23                  10    10023  10.so.0.23[.0]
- *    1.2.15                  13    10215  12.so.0.15[.0]
- *    1.2.16beta1-2           13    10216  12.so.0.16[.0]
- *    1.2.16rc1               13    10216  12.so.0.16[.0]
- *    1.0.24                  10    10024  10.so.0.24[.0]
- *    1.2.16                  13    10216  12.so.0.16[.0]
  *
  *    Henceforth the source version will match the shared-library major
  *    and minor numbers; the shared-library major version number will be
  *    used for changes in backward compatibility, as it is intended.  The
  *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
  *    for applications, is an unsigned integer of the form xyyzz corresponding
  *    to the source version x.y.z (leading zeros in y and z).  Beta versions
  *    were given the previous public release number plus a letter, until
  *    version 1.0.6j; from then on they were given the upcoming public
  *    release number plus "betaNN" or "rcN".
@@ -165,22 +148,22 @@
  * is available as a W3C Recommendation and as an ISO Specification,
  * <http://www.w3.org/TR/2003/REC-PNG-20031110/
  */
 
 /*
  * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
  *
  * If you modify libpng you may insert additional notices immediately following
  * this sentence.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.2.16, January 31, 2007, are
- * Copyright (c) 2004, 2007 Glenn Randers-Pehrson, and are
+ * libpng versions 1.2.6, August 15, 2004, through 1.2.12, June 27, 2006, are
+ * Copyright (c) 2004, 2006 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.2.5
  * with the following individual added to the list of Contributing Authors:
  *
  *    Cosmin Truta
  *
  * libpng versions 1.0.7, July 1, 2000, through 1.2.5, October 3, 2002, are
  * Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.0.6
  * with the following individuals added to the list of Contributing Authors:
  *
@@ -277,27 +260,27 @@
  * with testing, bug fixes, and patience.  This wouldn't have been
  * possible without all of you.
  *
  * Thanks to Frank J. T. Wojcik for helping with the documentation.
  */
 
 /*
  * Y2K compliance in libpng:
  * =========================
  *
- *    January 31, 2007
+ *    June 27, 2006
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.2.16 are Y2K compliant.  It is my belief that earlier
+ *    upward through 1.2.12 are Y2K compliant.  It is my belief that earlier
  *    versions were also Y2K compliant.
  *
  *    Libpng only has three year fields.  One is a 2-byte unsigned integer
  *    that will hold years up to 65535.  The other two hold the date in text
  *    format, and will hold years up to 9999.
  *
  *    The integer is
  *        "png_uint_16 year" in png_time_struct.
  *
  *    The strings are
@@ -339,31 +322,31 @@
 #ifndef PNG_H
 #define PNG_H
 
 /* This is not the place to learn how to use libpng.  The file libpng.txt
  * describes how to use libpng, and the file example.c summarizes it
  * with some code on which to build.  This file is useful for looking
  * at the actual function definitions and structure components.
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.2.16"
+#define PNG_LIBPNG_VER_STRING "1.2.12"
 #define PNG_HEADER_VERSION_STRING \
-   " libpng version 1.2.16 - January 31, 2007 (header)\n"
+   " libpng version 1.2.12 - June 27, 2006 (header)\n"
 
 #define PNG_LIBPNG_VER_SONUM   0
 #define PNG_LIBPNG_VER_DLLNUM  13
 
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   2
-#define PNG_LIBPNG_VER_RELEASE 16
+#define PNG_LIBPNG_VER_RELEASE 12
 /* This should match the numeric part of the final component of
  * PNG_LIBPNG_VER_STRING, omitting any leading zero: */
 
 #define PNG_LIBPNG_VER_BUILD  0
 
 /* Release Status */
 #define PNG_LIBPNG_BUILD_ALPHA    1
 #define PNG_LIBPNG_BUILD_BETA     2
 #define PNG_LIBPNG_BUILD_RC       3
 #define PNG_LIBPNG_BUILD_STABLE   4
@@ -377,21 +360,21 @@
 #define PNG_LIBPNG_BUILD_SPECIAL 32 /* Cannot be OR'ed with
                                        PNG_LIBPNG_BUILD_PRIVATE */
 
 #define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE
 
 /* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
  * We must not include leading zeros.
  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release */
-#define PNG_LIBPNG_VER 10216 /* 1.2.16 */
+#define PNG_LIBPNG_VER 10212 /* 1.2.12 */
 
 #ifndef PNG_VERSION_INFO_ONLY
 /* include the compression library's header */
 #include "zlib.h"
 #endif
 
 /* include all user configurable info, including optional assembler routines */
 #include "pngconf.h"
 
 /*
@@ -1363,28 +1346,24 @@ struct png_struct_def
 #if defined(PNG_MNG_FEATURES_SUPPORTED)
    png_byte filter_type;
 #endif
 
 #if defined(PNG_1_0_X) || (defined(PNG_DEBUG) && defined(PNG_USE_PNGGCCRD))
 /* New member added in libpng-1.0.10, ifdef'ed out in 1.2.0 */
    png_uint_32 row_buf_size;
 #endif
 
 /* New members added in libpng-1.2.0 */
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-#  if !defined(PNG_1_0_X)
-#    if defined(PNG_MMX_CODE_SUPPORTED)
+#if !defined(PNG_1_0_X) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    png_byte     mmx_bitdepth_threshold;
    png_uint_32  mmx_rowbytes_threshold;
-#    endif
    png_uint_32  asm_flags;
-#  endif
 #endif
 
 /* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */
 #ifdef PNG_USER_MEM_SUPPORTED
    png_voidp mem_ptr;                /* user supplied struct for mem functions */
    png_malloc_ptr malloc_fn;         /* function for allocating memory */
    png_free_ptr free_fn;             /* function for freeing memory */
 #endif
 
 /* New member added in libpng-1.0.13 and 1.2.0 */
@@ -1438,21 +1417,21 @@ struct png_struct_def
 #define PNG_DISPOSE_OP_BACKGROUND  0x01
 #define PNG_DISPOSE_OP_PREVIOUS    0x02
 
 /* blend_op flags from inside fcTL */
 #define PNG_BLEND_OP_SOURCE        0x00
 #define PNG_BLEND_OP_OVER          0x01
 
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef png_structp version_1_2_16;
+typedef png_structp version_1_2_12;
 
 typedef png_struct FAR * FAR * png_structpp;
 
 /* Here are the function definitions most commonly used.  This is not
  * the place to find out how to use libpng.  See libpng.txt for the
  * full explanation, see example.c for the summary.  This just provides
  * a simple one line description of the use of each function.
  */
 
 /* Returns the version number of the library */
@@ -2614,21 +2593,20 @@ extern PNG_EXPORT(png_uint_32,png_permit
 #endif
 
 /* For use in png_set_keep_unknown, added to version 1.2.6 */
 #define PNG_HANDLE_CHUNK_AS_DEFAULT   0
 #define PNG_HANDLE_CHUNK_NEVER        1
 #define PNG_HANDLE_CHUNK_IF_SAFE      2
 #define PNG_HANDLE_CHUNK_ALWAYS       3
 
 /* Added to version 1.2.0 */
 #if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-#if defined(PNG_MMX_CODE_SUPPORTED)
 #define PNG_ASM_FLAG_MMX_SUPPORT_COMPILED  0x01  /* not user-settable */
 #define PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU    0x02  /* not user-settable */
 #define PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  0x04
 #define PNG_ASM_FLAG_MMX_READ_INTERLACE    0x08
 #define PNG_ASM_FLAG_MMX_READ_FILTER_SUB   0x10
 #define PNG_ASM_FLAG_MMX_READ_FILTER_UP    0x20
 #define PNG_ASM_FLAG_MMX_READ_FILTER_AVG   0x40
 #define PNG_ASM_FLAG_MMX_READ_FILTER_PAETH 0x80
 #define PNG_ASM_FLAGS_INITIALIZED          0x80000000  /* not user-settable */
 
@@ -2640,21 +2618,20 @@ extern PNG_EXPORT(png_uint_32,png_permit
                            | PNG_ASM_FLAG_MMX_READ_FILTER_PAETH )
 #define PNG_MMX_WRITE_FLAGS ( 0 )
 
 #define PNG_MMX_FLAGS ( PNG_ASM_FLAG_MMX_SUPPORT_COMPILED \
                       | PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU   \
                       | PNG_MMX_READ_FLAGS                \
                       | PNG_MMX_WRITE_FLAGS )
 
 #define PNG_SELECT_READ   1
 #define PNG_SELECT_WRITE  2
-#endif /* PNG_MMX_CODE_SUPPORTED */
 
 #if !defined(PNG_1_0_X)
 /* pngget.c */
 extern PNG_EXPORT(png_uint_32,png_get_mmx_flagmask)
    PNGARG((int flag_select, int *compilerID));
 
 /* pngget.c */
 extern PNG_EXPORT(png_uint_32,png_get_asm_flagmask)
    PNGARG((int flag_select));
 
@@ -2673,25 +2650,25 @@ extern PNG_EXPORT(png_uint_32,png_get_mm
 /* pngset.c */
 extern PNG_EXPORT(void,png_set_asm_flags)
    PNGARG((png_structp png_ptr, png_uint_32 asm_flags));
 
 /* pngset.c */
 extern PNG_EXPORT(void,png_set_mmx_thresholds)
    PNGARG((png_structp png_ptr, png_byte mmx_bitdepth_threshold,
    png_uint_32 mmx_rowbytes_threshold));
 
 #endif /* PNG_1_0_X */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #if !defined(PNG_1_0_X)
 /* png.c, pnggccrd.c, or pngvcrd.c */
 extern PNG_EXPORT(int,png_mmx_support) PNGARG((void));
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 /* Strip the prepended error numbers ("#nnn ") from error and warning
  * messages before passing them to the error or warning handler. */
 #ifdef PNG_ERROR_NUMBERS_SUPPORTED
 extern PNG_EXPORT(void,png_set_strip_error_numbers) PNGARG((png_structp
    png_ptr, png_uint_32 strip_mode));
 #endif
 
 #endif /* PNG_1_0_X */
 
@@ -3624,25 +3601,23 @@ PNG_EXTERN void png_push_read_iTXt PNGAR
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
 PNG_EXTERN void png_do_read_intrapixel PNGARG((png_row_infop row_info,
    png_bytep row));
 PNG_EXTERN void png_do_write_intrapixel PNGARG((png_row_infop row_info,
    png_bytep row));
 #endif
 
 #if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-#if defined(PNG_MMX_CODE_SUPPORTED)
 /* png.c */ /* PRIVATE */
 PNG_EXTERN void png_init_mmx_flags PNGARG((png_structp png_ptr));
 #endif
-#endif
 
 #if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
 PNG_EXTERN png_uint_32 png_get_pixels_per_inch PNGARG((png_structp png_ptr,
 png_infop info_ptr));
 
 PNG_EXTERN png_uint_32 png_get_x_pixels_per_inch PNGARG((png_structp png_ptr,
 png_infop info_ptr));
 
 PNG_EXTERN png_uint_32 png_get_y_pixels_per_inch PNGARG((png_structp png_ptr,
 png_infop info_ptr));
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngconf.h mozilla/modules/libimg/png/pngconf.h
--- mozilla.orig/modules/libimg/png/pngconf.h	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngconf.h	2007-05-30 07:42:39.000000000 +0300
@@ -1,16 +1,16 @@
 
 /* pngconf.h - machine configurable file for libpng
  *
- * libpng version 1.2.16 - January 31, 2007
+ * libpng version 1.2.12 - June 27, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2005 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 /* Any machine specific code is near the front of this file, so if you
  * are configuring libpng for a machine, you may want to read the section
  * starting here down to where it starts to typedef png_color, png_text,
  * and png_info.
  */
 
@@ -716,36 +716,25 @@
  * png_get_x_offset_pixels()
  * png_get_y_offset_pixels()
  * png_get_x_offset_microns()
  * png_get_y_offset_microns()
  */
 #if !defined(PNG_NO_EASY_ACCESS) && !defined(PNG_EASY_ACCESS_SUPPORTED)
 #  define PNG_EASY_ACCESS_SUPPORTED
 #endif
 
 /* PNG_ASSEMBLER_CODE was enabled by default in version 1.2.0 
- * even when PNG_USE_PNGVCRD or PNG_USE_PNGGCCRD is not defined.
- *
- * PNG_NO_ASSEMBLER_CODE disables use of all assembler code and optimized C,
- * and removes or includes several functions in the API.
- *
- * PNG_NO_MMX_CODE disables the use of MMX code without changing the API.
- * When MMX code is off, then optimized C replacement functions are used.
-*/
+   even when PNG_USE_PNGVCRD or PNG_USE_PNGGCCRD is not defined */
 #if defined(PNG_READ_SUPPORTED) && !defined(PNG_NO_ASSEMBLER_CODE)
 #  ifndef PNG_ASSEMBLER_CODE_SUPPORTED
 #    define PNG_ASSEMBLER_CODE_SUPPORTED
 #  endif
-#  if defined(XP_MACOSX) && !defined(PNG_NO_MMX_CODE)
-     /* work around Intel-Mac compiler bug */
-#    define PNG_NO_MMX_CODE
-#  endif
 #  if !defined(PNG_MMX_CODE_SUPPORTED) && !defined(PNG_NO_MMX_CODE) && \
      defined(__MMX__)
 #    define PNG_MMX_CODE_SUPPORTED
 #  endif
 #  if !defined(PNG_USE_PNGGCCRD) && !defined(PNG_NO_MMX_CODE) && \
      !defined(PNG_USE_PNGVCRD) && defined(__MMX__)
 #    define PNG_USE_PNGGCCRD
 #  endif
 #endif
 
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngerror.c mozilla/modules/libimg/png/pngerror.c
--- mozilla.orig/modules/libimg/png/pngerror.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngerror.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,14 +1,14 @@
 
 /* pngerror.c - stub functions for i/o and memory allocation
  *
- * Last changed in libpng 1.2.13 November 13, 2006
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * This file provides a location for all error handling.  Users who
  * need special error handling are expected to write replacement functions
  * and use png_set_error_fn() to use those functions.  See the instructions
  * at each function.
  */
@@ -150,38 +150,32 @@ png_format_buffer(png_structp png_ptr, p
       buffer[iout+63] = 0;
    }
 }
 
 void PNGAPI
 png_chunk_error(png_structp png_ptr, png_const_charp error_message)
 {
    char msg[18+64];
    if (png_ptr == NULL)
      png_error(png_ptr, error_message);
-   else
-   {
-     png_format_buffer(png_ptr, msg, error_message);
-     png_error(png_ptr, msg);
-   }
+   png_format_buffer(png_ptr, msg, error_message);
+   png_error(png_ptr, msg);
 }
 
 void PNGAPI
 png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
 {
    char msg[18+64];
    if (png_ptr == NULL)
      png_warning(png_ptr, warning_message);
-   else
-   {
-     png_format_buffer(png_ptr, msg, warning_message);
-     png_warning(png_ptr, msg);
-   }
+   png_format_buffer(png_ptr, msg, warning_message);
+   png_warning(png_ptr, msg);
 }
 
 /* This is the default error handling function.  Note that replacements for
  * this function MUST NOT RETURN, or the program will likely crash.  This
  * function is used by default, or if the program supplies NULL for the
  * error function pointer in png_set_error_fn().
  */
 static void /* PRIVATE */
 png_default_error(png_structp png_ptr, png_const_charp error_message)
 {
@@ -205,33 +199,32 @@ png_default_error(png_structp png_ptr, p
      }
      else
        fprintf(stderr, "libpng error: %s, offset=%d\n", error_message,offset);
    }
    else
 #endif
    fprintf(stderr, "libpng error: %s\n", error_message);
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
-   if (png_ptr)
-   {
 #  ifdef USE_FAR_KEYWORD
    {
       jmp_buf jmpbuf;
       png_memcpy(jmpbuf,png_ptr->jmpbuf,png_sizeof(jmp_buf));
       longjmp(jmpbuf, 1);
    }
 #  else
    longjmp(png_ptr->jmpbuf, 1);
-#  endif
-   }
+# endif
 #else
+   /* make compiler happy */ ;
+   if (png_ptr)
    PNG_ABORT();
 #endif
 #ifdef PNG_NO_CONSOLE_IO
    /* make compiler happy */ ;
    if (&error_message != NULL)
       return;
 #endif
 }
 
 /* This function is called when there is a warning, but the library thinks
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pnggccrd.c mozilla/modules/libimg/png/pnggccrd.c
--- mozilla.orig/modules/libimg/png/pnggccrd.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pnggccrd.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,22 +1,22 @@
 
 /* pnggccrd.c - mixed C/assembler version of utilities to read a PNG file
  *
  * For Intel x86 CPU (Pentium-MMX or later) and GNU C compiler.
  *
  *     See http://www.intel.com/drg/pentiumII/appnotes/916/916.htm
  *     and http://www.intel.com/drg/pentiumII/appnotes/923/923.htm
  *     for Intel's performance analysis of the MMX vs. non-MMX code.
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * Copyright (c) 1998, Intel Corporation
  *
  * Based on MSVC code contributed by Nirav Chhatrapati, Intel Corp., 1998.
  * Interface to libpng contributed by Gilles Vollant, 1999.
  * GNU C port by Greg Roelofs, 1999-2001.
  *
  * Lines 2350-4300 converted in place with intel2gas 1.3.1:
  *
  *   intel2gas -mdI pnggccrd.c.partially-msvc -o pnggccrd.c
  *
@@ -238,31 +238,31 @@
  *        of the row buffer, not the end (see 19991007 for details)
  *     x pick one version of mmxsupport() and get rid of the other
  *     - add error messages to any remaining bogus default cases
  *     - enable pixel_depth == 8 cases in png_read_filter_row()? (test speed)
  *     x add support for runtime enable/disable/query of various MMX routines
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGGCCRD)
+#if defined(PNG_USE_PNGGCCRD)
 
 int PNGAPI png_mmx_support(void);
 
 #ifdef PNG_USE_LOCAL_ARRAYS
 static const int FARDATA png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 static const int FARDATA png_pass_inc[7]   = {8, 8, 4, 4, 2, 2, 1};
 static const int FARDATA png_pass_width[7] = {8, 4, 4, 2, 2, 1, 1};
 #endif
 
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
 /* djgpp, Win32, Cygwin, and OS2 add their own underscores to global variables,
  * so define them without: */
 #if defined(__DJGPP__) || defined(WIN32) || defined(__CYGWIN__) || \
     defined(__OS2__)
 #  define _mmx_supported  mmx_supported
 #  define _const4         const4
 #  define _const6         const6
 #  define _mask8_0        mask8_0
 #  define _mask16_1       mask16_1
 #  define _mask16_0       mask16_0
@@ -371,32 +371,32 @@ png_squelch_warnings(void)
    _mask32_2 = _mask32_2;
    _mask32_1 = _mask32_1;
    _mask32_0 = _mask32_0;
    _mask48_5 = _mask48_5;
    _mask48_4 = _mask48_4;
    _mask48_3 = _mask48_3;
    _mask48_2 = _mask48_2;
    _mask48_1 = _mask48_1;
    _mask48_0 = _mask48_0;
 }
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 
 static int _mmx_supported = 2;
 
 /*===========================================================================*/
 /*                                                                           */
 /*                       P N G _ C O M B I N E _ R O W                       */
 /*                                                                           */
 /*===========================================================================*/
 
-#if defined(PNG_HAVE_MMX_COMBINE_ROW)
+#if defined(PNG_HAVE_ASSEMBLER_COMBINE_ROW)
 
 #define BPP2  2
 #define BPP3  3 /* bytes per pixel (a.k.a. pixel_bytes) */
 #define BPP4  4
 #define BPP6  6 /* (defined only to help avoid cut-and-paste errors) */
 #define BPP8  8
 
 /* Combines the row recently read in with the previous row.
    This routine takes care of alpha and transparency if requested.
    This routine also handles the two methods of progressive display
@@ -409,21 +409,21 @@ static int _mmx_supported = 2;
    If you want all pixels to be combined, pass 0xff (255) in mask. */
 
 /* Use this routine for the x86 platform - it uses a faster MMX routine
    if the machine supports MMX. */
 
 void /* PRIVATE */
 png_combine_row(png_structp png_ptr, png_bytep row, int mask)
 {
    png_debug(1, "in png_combine_row (pnggccrd.c)\n");
 
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    if (_mmx_supported == 2) {
 #if !defined(PNG_1_0_X)
        /* this should have happened in png_init_mmx_flags() already */
        png_warning(png_ptr, "asm_flags may not have been initialized");
 #endif
        png_mmx_support();
    }
 #endif
 
    if (mask == 0xff)
@@ -600,21 +600,21 @@ png_combine_row(png_structp png_ptr, png
                   m >>= 1;
             }
             break;
          }
 
          case 8:        /* png_ptr->row_info.pixel_depth */
          {
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
 #else
             if (_mmx_supported)
 #endif
             {
                png_uint_32 len;
                int diff;
                int dummy_value_a;   // fix 'forbidden register spilled' error
@@ -693,21 +693,21 @@ png_combine_row(png_structp png_ptr, png
 // was (unmask)     "b"    RESERVED    // ebx       // Global Offset Table idx
                     "2" (len),         // ecx
                     "1" (mask)         // edx
 
 #if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                   : "%mm0", "%mm4", "%mm6", "%mm7"  // clobber list
 #endif
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = png_pass_start[png_ptr->pass];
                  /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
                register int stride = png_pass_inc[png_ptr->pass];
                  /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
                register int rep_bytes = png_pass_width[png_ptr->pass];
                  /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
                png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
                int diff = (int) (png_ptr->width & 7); /* amount lost */
@@ -738,21 +738,21 @@ png_combine_row(png_structp png_ptr, png
             } /* end of else (_mmx_supported) */
 
             break;
          }       /* end 8 bpp */
 
          case 16:       /* png_ptr->row_info.pixel_depth */
          {
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
 #else
             if (_mmx_supported)
 #endif
             {
                png_uint_32 len;
                int diff;
                int dummy_value_a;   // fix 'forbidden register spilled' error
@@ -847,21 +847,21 @@ png_combine_row(png_structp png_ptr, png
                     "3" (srcptr),      // esi
                     "4" (dstptr)       // edi
 
 #if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                   : "%mm0", "%mm1", "%mm4"          // clobber list
                   , "%mm5", "%mm6", "%mm7"
 #endif
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP2 * png_pass_start[png_ptr->pass];
                  /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
                register int stride = BPP2 * png_pass_inc[png_ptr->pass];
                  /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
                register int rep_bytes = BPP2 * png_pass_width[png_ptr->pass];
                  /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
                png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
                int diff = (int) (png_ptr->width & 7); /* amount lost */
@@ -891,21 +891,21 @@ png_combine_row(png_structp png_ptr, png
             } /* end of else (_mmx_supported) */
 
             break;
          }       /* end 16 bpp */
 
          case 24:       /* png_ptr->row_info.pixel_depth */
          {
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
 #else
             if (_mmx_supported)
 #endif
             {
                png_uint_32 len;
                int diff;
                int dummy_value_a;   // fix 'forbidden register spilled' error
@@ -1015,21 +1015,21 @@ png_combine_row(png_structp png_ptr, png
                     "2" (len),         // ecx
                     "1" (mask)         // edx
 
 #if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                   : "%mm0", "%mm1", "%mm2"          // clobber list
                   , "%mm4", "%mm5", "%mm6", "%mm7"
 #endif
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP3 * png_pass_start[png_ptr->pass];
                  /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
                register int stride = BPP3 * png_pass_inc[png_ptr->pass];
                  /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
                register int rep_bytes = BPP3 * png_pass_width[png_ptr->pass];
                  /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
                png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
                int diff = (int) (png_ptr->width & 7); /* amount lost */
@@ -1059,21 +1059,21 @@ png_combine_row(png_structp png_ptr, png
             } /* end of else (_mmx_supported) */
 
             break;
          }       /* end 24 bpp */
 
          case 32:       /* png_ptr->row_info.pixel_depth */
          {
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
 #else
             if (_mmx_supported)
 #endif
             {
                png_uint_32 len;
                int diff;
                int dummy_value_a;   // fix 'forbidden register spilled' error
@@ -1190,21 +1190,21 @@ png_combine_row(png_structp png_ptr, png
                     "2" (len),         // ecx
                     "1" (mask)         // edx
 
 #if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                   : "%mm0", "%mm1", "%mm2", "%mm3"  // clobber list
                   , "%mm4", "%mm5", "%mm6", "%mm7"
 #endif
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP4 * png_pass_start[png_ptr->pass];
                  /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
                register int stride = BPP4 * png_pass_inc[png_ptr->pass];
                  /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
                register int rep_bytes = BPP4 * png_pass_width[png_ptr->pass];
                  /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
                png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
                int diff = (int) (png_ptr->width & 7); /* amount lost */
@@ -1234,21 +1234,21 @@ png_combine_row(png_structp png_ptr, png
             } /* end of else (_mmx_supported) */
 
             break;
          }       /* end 32 bpp */
 
          case 48:       /* png_ptr->row_info.pixel_depth */
          {
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
 #else
             if (_mmx_supported)
 #endif
             {
                png_uint_32 len;
                int diff;
                int dummy_value_a;   // fix 'forbidden register spilled' error
@@ -1382,21 +1382,21 @@ png_combine_row(png_structp png_ptr, png
                     "2" (len),         // ecx
                     "1" (mask)         // edx
 
 #if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
                   : "%mm0", "%mm1", "%mm2", "%mm3"  // clobber list
                   , "%mm4", "%mm5", "%mm6", "%mm7"
 #endif
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP6 * png_pass_start[png_ptr->pass];
                  /* png.c:  png_pass_start[] = {0, 4, 0, 2, 0, 1, 0}; */
                register int stride = BPP6 * png_pass_inc[png_ptr->pass];
                  /* png.c:  png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1}; */
                register int rep_bytes = BPP6 * png_pass_width[png_ptr->pass];
                  /* png.c:  png_pass_width[] = {8, 4, 4, 2, 2, 1, 1}; */
                png_uint_32 len = png_ptr->width &~7;  /* reduce to mult. of 8 */
                int diff = (int) (png_ptr->width & 7); /* amount lost */
@@ -1473,51 +1473,51 @@ png_combine_row(png_structp png_ptr, png
             /* this should never happen */
             png_warning(png_ptr, "Invalid row_info.pixel_depth in pnggccrd");
             break;
          }
       } /* end switch (png_ptr->row_info.pixel_depth) */
 
    } /* end if (non-trivial mask) */
 
 } /* end png_combine_row() */
 
-#endif /* PNG_HAVE_MMX_COMBINE_ROW */
+#endif /* PNG_HAVE_ASSEMBLER_COMBINE_ROW */
 
 
 
 
 /*===========================================================================*/
 /*                                                                           */
 /*                 P N G _ D O _ R E A D _ I N T E R L A C E                 */
 /*                                                                           */
 /*===========================================================================*/
 
 #if defined(PNG_READ_INTERLACING_SUPPORTED)
-#if defined(PNG_HAVE_MMX_READ_INTERLACE)
+#if defined(PNG_HAVE_ASSEMBLER_READ_INTERLACE)
 
 /* png_do_read_interlace() is called after any 16-bit to 8-bit conversion
  * has taken place.  [GRR: what other steps come before and/or after?]
  */
 
 void /* PRIVATE */
 png_do_read_interlace(png_structp png_ptr)
 {
    png_row_infop row_info = &(png_ptr->row_info);
    png_bytep row = png_ptr->row_buf + 1;
    int pass = png_ptr->pass;
 #if defined(PNG_READ_PACKSWAP_SUPPORTED)
    png_uint_32 transformations = png_ptr->transformations;
 #endif
 
    png_debug(1, "in png_do_read_interlace (pnggccrd.c)\n");
 
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
    if (_mmx_supported == 2) {
 #if !defined(PNG_1_0_X)
        /* this should have happened in png_init_mmx_flags() already */
        png_warning(png_ptr, "asm_flags may not have been initialized");
 #endif
        png_mmx_support();
    }
 #endif
 
    if (row != NULL && row_info != NULL)
@@ -1716,21 +1716,21 @@ png_do_read_interlace(png_structp png_pt
             pixel_bytes = (row_info->pixel_depth >> 3);
 
             /* point sptr at the last pixel in the pre-expanded row: */
             sptr = row + (width - 1) * pixel_bytes;
 
             /* point dp at the last pixel position in the expanded row: */
             dp = row + (final_width - 1) * pixel_bytes;
 
             /* New code by Nirav Chhatrapati - Intel Corporation */
 
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_INTERLACE)
                 /* && _mmx_supported */ )
 #else
             if (_mmx_supported)
 #endif
             {
                //--------------------------------------------------------------
                if (pixel_bytes == 3)
                {
@@ -2621,21 +2621,21 @@ png_do_read_interlace(png_structp png_pt
                      sptr-= pixel_bytes;
                   }
                }
             } // end of _mmx_supported ========================================
 
             else /* MMX not supported:  use modified C code - takes advantage
                   *   of inlining of png_memcpy for a constant */
                  /* GRR 19991007:  does it?  or should pixel_bytes in each
                   *   block be replaced with immediate value (e.g., 1)? */
                  /* GRR 19991017:  replaced with constants in each case */
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
             {
                if (pixel_bytes == 1)
                {
                   for (i = width; i; i--)
                   {
                      int j;
                      for (j = 0; j < png_pass_inc[pass]; j++)
                      {
                         *dp-- = *sptr;
                      }
@@ -2746,27 +2746,27 @@ png_do_read_interlace(png_structp png_pt
          }
       } /* end switch (row_info->pixel_depth) */
 
       row_info->width = final_width;
 
       row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,final_width);
    }
 
 } /* end png_do_read_interlace() */
 
-#endif /* PNG_HAVE_MMX_READ_INTERLACE */
+#endif /* PNG_HAVE_ASSEMBLER_READ_INTERLACE */
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 
 
 
-#if defined(PNG_HAVE_MMX_READ_FILTER_ROW)
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_HAVE_ASSEMBLER_READ_FILTER_ROW)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
 
 // These variables are utilized in the functions below.  They are declared
 // globally here to ensure alignment on 8-byte boundaries.
 
 union uAll {
    long long use;
    double  align;
 } _LBCarryMask = {0x0101010101010101LL},
   _HBClearMask = {0x7f7f7f7f7f7f7f7fLL},
   _ActiveMask, _ActiveMask2, _ActiveMaskEnd, _ShiftBpp, _ShiftRem;
@@ -5059,21 +5059,21 @@ png_read_filter_row_mmx_up(png_row_infop
 #endif
 
 #if 0  /* MMX regs (%mm0, etc.) not supported by gcc 2.7.2.3 or egcs 1.1 */
       , "%mm0", "%mm1", "%mm2", "%mm3"
       , "%mm4", "%mm5", "%mm6", "%mm7"
 #endif
    );
 
 } // end of png_read_filter_row_mmx_up()
 
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 
 
 
 /*===========================================================================*/
 /*                                                                           */
 /*                   P N G _ R E A D _ F I L T E R _ R O W                   */
 /*                                                                           */
 /*===========================================================================*/
 
@@ -5081,68 +5081,68 @@ png_read_filter_row_mmx_up(png_row_infop
 /* Optimized png_read_filter_row routines */
 
 void /* PRIVATE */
 png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep
    row, png_bytep prev_row, int filter)
 {
 #ifdef PNG_DEBUG
    char filnm[10];
 #endif
 
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
 /* GRR:  these are superseded by png_ptr->asm_flags: */
 #define UseMMX_sub    1   // GRR:  converted 20000730
 #define UseMMX_up     1   // GRR:  converted 20000729
 #define UseMMX_avg    1   // GRR:  converted 20000828 (+ 16-bit bugfix 20000916)
 #define UseMMX_paeth  1   // GRR:  converted 20000828
 
    if (_mmx_supported == 2) {
        /* this should have happened in png_init_mmx_flags() already */
 #if !defined(PNG_1_0_X)
        png_warning(png_ptr, "asm_flags may not have been initialized");
 #endif
        png_mmx_support();
    }
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #ifdef PNG_DEBUG
    png_debug(1, "in png_read_filter_row (pnggccrd.c)\n");
    switch (filter)
    {
       case 0: sprintf(filnm, "none");
          break;
       case 1: sprintf(filnm, "sub-%s",
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? "MMX" :
 #endif
 #endif
 "x86");
          break;
       case 2: sprintf(filnm, "up-%s",
-#ifdef PNG_MMX_CODE_SUPPORTED
+#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? "MMX" :
 #endif
 #endif
  "x86");
          break;
       case 3: sprintf(filnm, "avg-%s",
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? "MMX" :
 #endif
 #endif
  "x86");
          break;
       case 4: sprintf(filnm, "Paeth-%s",
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? "MMX":
 #endif
 #endif
 "x86");
          break;
       default: sprintf(filnm, "unknw");
          break;
    }
    png_debug2(0, "row_number=%5ld, %5s, ", png_ptr->row_number, filnm);
@@ -5151,90 +5151,90 @@ png_read_filter_row(png_structp png_ptr,
       (int)((row_info->pixel_depth + 7) >> 3));
    png_debug1(0,"rowbytes=%8ld\n", row_info->rowbytes);
 #endif /* PNG_DEBUG */
 
    switch (filter)
    {
       case PNG_FILTER_VALUE_NONE:
          break;
 
       case PNG_FILTER_VALUE_SUB:
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
              (row_info->rowbytes >= png_ptr->mmx_rowbytes_threshold))
 #else
          if (_mmx_supported)
 #endif
          {
             png_read_filter_row_mmx_sub(row_info, row);
          }
          else
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_uint_32 istop = row_info->rowbytes;
             png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
             png_bytep rp = row + bpp;
             png_bytep lp = row;
 
             for (i = bpp; i < istop; i++)
             {
                *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
                rp++;
             }
          }  /* end !UseMMX_sub */
          break;
 
       case PNG_FILTER_VALUE_UP:
-#if defined(PNG_MMX_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
              (row_info->rowbytes >= png_ptr->mmx_rowbytes_threshold))
 #else
          if (_mmx_supported)
 #endif
          {
             png_read_filter_row_mmx_up(row_info, row, prev_row);
          }
           else
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_uint_32 istop = row_info->rowbytes;
             png_bytep rp = row;
             png_bytep pp = prev_row;
 
             for (i = 0; i < istop; ++i)
             {
                *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
                rp++;
             }
          }  /* end !UseMMX_up */
          break;
 
       case PNG_FILTER_VALUE_AVG:
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
              (row_info->rowbytes >= png_ptr->mmx_rowbytes_threshold))
 #else
          if (_mmx_supported)
 #endif
          {
             png_read_filter_row_mmx_avg(row_info, row, prev_row);
          }
          else
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_bytep rp = row;
             png_bytep pp = prev_row;
             png_bytep lp = row;
             png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
             png_uint_32 istop = row_info->rowbytes - bpp;
 
             for (i = 0; i < bpp; i++)
             {
@@ -5246,33 +5246,33 @@ png_read_filter_row(png_structp png_ptr,
             for (i = 0; i < istop; i++)
             {
                *rp = (png_byte)(((int)(*rp) +
                   ((int)(*pp++ + *lp++) >> 1)) & 0xff);
                rp++;
             }
          }  /* end !UseMMX_avg */
          break;
 
       case PNG_FILTER_VALUE_PAETH:
-#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
              (row_info->rowbytes >= png_ptr->mmx_rowbytes_threshold))
 #else
          if (_mmx_supported)
 #endif
          {
             png_read_filter_row_mmx_paeth(row_info, row, prev_row);
          }
          else
-#endif /* PNG_MMX_CODE_SUPPORTED */
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_bytep rp = row;
             png_bytep pp = prev_row;
             png_bytep lp = row;
             png_bytep cp = prev_row;
             png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
             png_uint_32 istop = row_info->rowbytes - bpp;
 
             for (i = 0; i < bpp; i++)
@@ -5319,21 +5319,21 @@ png_read_filter_row(png_structp png_ptr,
          }  /* end !UseMMX_paeth */
          break;
 
       default:
          png_warning(png_ptr, "Ignoring bad row-filter type");
          *row=0;
          break;
    }
 }
 
-#endif /* PNG_HAVE_MMX_READ_FILTER_ROW */
+#endif /* PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */
 
 
 /*===========================================================================*/
 /*                                                                           */
 /*                      P N G _ M M X _ S U P P O R T                        */
 /*                                                                           */
 /*===========================================================================*/
 
 /* GRR NOTES:  (1) the following code assumes 386 or better (pushfl/popfl)
  *             (2) all instructions compile with gcc 2.7.2.3 and later
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngget.c mozilla/modules/libimg/png/pngget.c
--- mozilla.orig/modules/libimg/png/pngget.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngget.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,16 +1,16 @@
 
 /* pngget.c - retrieval of values from info struct
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 
 png_uint_32 PNGAPI
@@ -983,70 +983,63 @@ png_get_user_chunk_ptr(png_structp png_p
 #endif
 
 #ifdef PNG_WRITE_SUPPORTED
 png_uint_32 PNGAPI
 png_get_compression_buffer_size(png_structp png_ptr)
 {
    return (png_uint_32)(png_ptr? png_ptr->zbuf_size : 0L);
 }
 #endif
 
-#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
 #ifndef PNG_1_0_X
+#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
 /* this function was added to libpng 1.2.0 and should exist by default */
 png_uint_32 PNGAPI
 png_get_asm_flags (png_structp png_ptr)
 {
-#ifdef PNG_MMX_CODE_SUPPORTED
     return (png_uint_32)(png_ptr? png_ptr->asm_flags : 0L);
-#else
-    return (png_ptr? 0L: 0L);
-#endif
 }
 
 /* this function was added to libpng 1.2.0 and should exist by default */
 png_uint_32 PNGAPI
 png_get_asm_flagmask (int flag_select)
 {
-#ifdef PNG_MMX_CODE_SUPPORTED
     png_uint_32 settable_asm_flags = 0;
 
     if (flag_select & PNG_SELECT_READ)
         settable_asm_flags |=
           PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
           PNG_ASM_FLAG_MMX_READ_INTERLACE    |
           PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
           PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
           PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
           PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
           /* no non-MMX flags yet */
 
 #if 0
     /* GRR:  no write-flags yet, either, but someday... */
     if (flag_select & PNG_SELECT_WRITE)
         settable_asm_flags |=
           PNG_ASM_FLAG_MMX_WRITE_ [whatever] ;
 #endif /* 0 */
 
     return settable_asm_flags;  /* _theoretically_ settable capabilities only */
-#else
-    return (0L);
-#endif /* PNG_MMX_CODE_SUPPORTED */
 }
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
     /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
 /* this function was added to libpng 1.2.0 */
 png_uint_32 PNGAPI
 png_get_mmx_flagmask (int flag_select, int *compilerID)
 {
-#if defined(PNG_MMX_CODE_SUPPORTED)
     png_uint_32 settable_mmx_flags = 0;
 
     if (flag_select & PNG_SELECT_READ)
         settable_mmx_flags |=
           PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
           PNG_ASM_FLAG_MMX_READ_INTERLACE    |
           PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
           PNG_ASM_FLAG_MMX_READ_FILTER_UP    |
           PNG_ASM_FLAG_MMX_READ_FILTER_AVG   |
           PNG_ASM_FLAG_MMX_READ_FILTER_PAETH ;
@@ -1063,48 +1056,37 @@ png_get_mmx_flagmask (int flag_select, i
 #else
 #ifdef PNG_USE_PNGGCCRD
         *compilerID = 2;    /* gcc/gas */
 #else
         *compilerID = -1;   /* unknown (i.e., no asm/MMX code compiled) */
 #endif
 #endif
     }
 
     return settable_mmx_flags;  /* _theoretically_ settable capabilities only */
-#else
-    return (0L);
-#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
 
 /* this function was added to libpng 1.2.0 */
 png_byte PNGAPI
 png_get_mmx_bitdepth_threshold (png_structp png_ptr)
 {
-#if defined(PNG_MMX_CODE_SUPPORTED)
     return (png_byte)(png_ptr? png_ptr->mmx_bitdepth_threshold : 0);
-#else
-    return (png_ptr? 0: 0);
-#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
 
 /* this function was added to libpng 1.2.0 */
 png_uint_32 PNGAPI
 png_get_mmx_rowbytes_threshold (png_structp png_ptr)
 {
-#if defined(PNG_MMX_CODE_SUPPORTED)
     return (png_uint_32)(png_ptr? png_ptr->mmx_rowbytes_threshold : 0L);
-#else
-    return (png_ptr? 0L: 0L);
-#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
-#endif /* ?PNG_1_0_X */
 #endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* ?PNG_1_0_X */
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
 /* these functions were added to libpng 1.2.6 */
 png_uint_32 PNGAPI
 png_get_user_width_max (png_structp png_ptr)
 {
     return (png_ptr? png_ptr->user_width_max : 0);
 }
 png_uint_32 PNGAPI
 png_get_user_height_max (png_structp png_ptr)
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngmem.c mozilla/modules/libimg/png/pngmem.c
--- mozilla.orig/modules/libimg/png/pngmem.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngmem.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,14 +1,14 @@
 
 /* pngmem.c - stub functions for memory allocation
  *
- * Last changed in libpng 1.2.13 November 13, 2006
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * This file provides a location for all memory allocation.  Users who
  * need special memory handling are expected to supply replacement
  * functions for png_malloc() and png_free(), and to use
  * png_create_read_struct_2() and png_create_write_struct_2() to
  * identify the replacement functions.
@@ -130,23 +130,20 @@ png_malloc(png_structp png_ptr, png_uint
        png_error(png_ptr, "Out of memory!");
    return (ret);
 }
 
 png_voidp PNGAPI
 png_malloc_default(png_structp png_ptr, png_uint_32 size)
 {
    png_voidp ret;
 #endif /* PNG_USER_MEM_SUPPORTED */
 
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
 #ifdef PNG_MAX_MALLOC_64K
    if (size > (png_uint_32)65536L)
    {
       png_warning(png_ptr, "Cannot Allocate > 64K");
       ret = NULL;
    }
    else
 #endif
 
    if (size != (size_t)size)
@@ -286,22 +283,20 @@ png_free(png_structp png_ptr, png_voidp 
       return;
    }
    else png_free_default(png_ptr, ptr);
 }
 
 void PNGAPI
 png_free_default(png_structp png_ptr, png_voidp ptr)
 {
 #endif /* PNG_USER_MEM_SUPPORTED */
 
-   if(png_ptr == NULL) return;
-
    if (png_ptr->offset_table != NULL)
    {
       int i;
 
       for (i = 0; i < png_ptr->offset_table_count; i++)
       {
          if (ptr == png_ptr->offset_table_ptr[i])
          {
             ptr = NULL;
             png_ptr->offset_table_count_free++;
@@ -534,24 +529,22 @@ png_free_default(png_structp png_ptr, pn
 #else
 /* This function was added at libpng version 1.2.3.  The png_malloc_warn()
  * function will set up png_malloc() to issue a png_warning and return NULL
  * instead of issuing a png_error, if it fails to allocate the requested
  * memory.
  */
 png_voidp PNGAPI
 png_malloc_warn(png_structp png_ptr, png_uint_32 size)
 {
    png_voidp ptr;
-   png_uint_32 save_flags;
-   if(png_ptr == NULL) return (NULL);
+   png_uint_32 save_flags=png_ptr->flags;
 
-   save_flags=png_ptr->flags;
    png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
    ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
    png_ptr->flags=save_flags;
    return(ptr);
 }
 #endif
 
 png_voidp PNGAPI
 png_memcpy_check (png_structp png_ptr, png_voidp s1, png_voidp s2,
    png_uint_32 length)
@@ -580,29 +573,26 @@ png_memset_check (png_structp png_ptr, p
 }
 
 #ifdef PNG_USER_MEM_SUPPORTED
 /* This function is called when the application wants to use another method
  * of allocating and freeing memory.
  */
 void PNGAPI
 png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
   malloc_fn, png_free_ptr free_fn)
 {
-   if(png_ptr != NULL) {
    png_ptr->mem_ptr = mem_ptr;
    png_ptr->malloc_fn = malloc_fn;
    png_ptr->free_fn = free_fn;
-   }
 }
 
 /* This function returns a pointer to the mem_ptr associated with the user
  * functions.  The application should free any memory associated with this
  * pointer before png_write_destroy and png_read_destroy are called.
  */
 png_voidp PNGAPI
 png_get_mem_ptr(png_structp png_ptr)
 {
-   if(png_ptr == NULL) return (NULL);
    return ((png_voidp)png_ptr->mem_ptr);
 }
 #endif /* PNG_USER_MEM_SUPPORTED */
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngpread.c mozilla/modules/libimg/png/pngpread.c
--- mozilla.orig/modules/libimg/png/pngpread.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngpread.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,14 +1,14 @@
 
 /* pngpread.c - read a png file in push mode
  *
- * Last changed in libpng 1.2.13 November 13, 2006
+ * Last changed in libpng 1.2.11 - June 7, 2004
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
@@ -21,36 +21,34 @@
 #define PNG_READ_tEXt_MODE  4
 #define PNG_READ_zTXt_MODE  5
 #define PNG_READ_DONE_MODE  6
 #define PNG_READ_iTXt_MODE  7
 #define PNG_ERROR_MODE      8
 
 void PNGAPI
 png_process_data(png_structp png_ptr, png_infop info_ptr,
    png_bytep buffer, png_size_t buffer_size)
 {
-   if(png_ptr == NULL) return;
    png_push_restore_buffer(png_ptr, buffer, buffer_size);
 
    while (png_ptr->buffer_size)
    {
       png_process_some_data(png_ptr, info_ptr);
    }
 }
 
 /* What we do with the incoming data depends on what we were previously
  * doing before we ran out of data...
  */
 void /* PRIVATE */
 png_process_some_data(png_structp png_ptr, png_infop info_ptr)
 {
-   if(png_ptr == NULL) return;
    switch (png_ptr->process_mode)
    {
       case PNG_READ_SIG_MODE:
       {
          png_push_read_sig(png_ptr, info_ptr);
          break;
       }
       case PNG_READ_CHUNK_MODE:
       {
          png_push_read_chunk(png_ptr, info_ptr);
@@ -690,21 +688,20 @@ png_push_crc_finish(png_structp png_ptr)
       png_crc_finish(png_ptr, 0);
       png_ptr->process_mode = PNG_READ_CHUNK_MODE;
    }
 }
 
 void PNGAPI
 png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
 {
    png_bytep ptr;
 
-   if(png_ptr == NULL) return;
    ptr = buffer;
    if (png_ptr->save_buffer_size)
    {
       png_size_t save_size;
 
       if (length < png_ptr->save_buffer_size)
          save_size = length;
       else
          save_size = png_ptr->save_buffer_size;
 
@@ -1732,31 +1729,29 @@ png_push_have_row(png_structp png_ptr, p
 }
 
 void PNGAPI
 png_progressive_combine_row (png_structp png_ptr,
    png_bytep old_row, png_bytep new_row)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    const int FARDATA png_pass_dsp_mask[7] =
       {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
 #endif
-   if(png_ptr == NULL) return;
    if (new_row != NULL)    /* new_row must == png_ptr->row_buf here. */
       png_combine_row(png_ptr, old_row, png_pass_dsp_mask[png_ptr->pass]);
 }
 
 void PNGAPI
 png_set_progressive_read_fn(png_structp png_ptr, png_voidp progressive_ptr,
    png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
    png_progressive_end_ptr end_fn)
 {
-   if(png_ptr == NULL) return;
    png_ptr->info_fn = info_fn;
    png_ptr->row_fn = row_fn;
    png_ptr->end_fn = end_fn;
 
    png_set_read_fn(png_ptr, progressive_ptr, png_push_fill_buffer);
 }
 
 #if defined(PNG_READ_APNG_SUPPORTED)
 void PNGAPI
 png_set_progressive_frame_fn(png_structp png_ptr,
@@ -1764,14 +1759,13 @@ png_set_progressive_frame_fn(png_structp
    png_progressive_frame_ptr frame_end_fn)
 {
    png_ptr->frame_info_fn = frame_info_fn;
    png_ptr->frame_end_fn = frame_end_fn;
 }
 #endif
 
 png_voidp PNGAPI
 png_get_progressive_ptr(png_structp png_ptr)
 {
-   if(png_ptr == NULL) return (NULL);
    return png_ptr->io_ptr;
 }
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngread.c mozilla/modules/libimg/png/pngread.c
--- mozilla.orig/modules/libimg/png/pngread.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngread.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,16 +1,16 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.11 June 7, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * This file contains routines that an application calls directly to
  * read a PNG file or stream.
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 
@@ -49,21 +49,21 @@ png_create_read_struct_2(png_const_charp
 #ifdef PNG_USER_MEM_SUPPORTED
    png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
       (png_malloc_ptr)malloc_fn, (png_voidp)mem_ptr);
 #else
    png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
 #endif
    if (png_ptr == NULL)
       return (NULL);
 
 #if !defined(PNG_1_0_X)
-#ifdef PNG_MMX_CODE_SUPPORTED
+#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
    png_init_mmx_flags(png_ptr);   /* 1.2.0 addition */
 #endif
 #endif /* PNG_1_0_X */
 
    /* added at libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
    png_ptr->user_width_max=PNG_USER_WIDTH_MAX;
    png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;
 #endif
 
@@ -181,21 +181,20 @@ png_read_init(png_structp png_ptr)
 {
    /* We only come here via pre-1.0.7-compiled applications */
    png_read_init_2(png_ptr, "1.0.6 or earlier", 0, 0);
 }
 
 void PNGAPI
 png_read_init_2(png_structp png_ptr, png_const_charp user_png_ver,
    png_size_t png_struct_size, png_size_t png_info_size)
 {
    /* We only come here via pre-1.0.12-compiled applications */
-   if(png_ptr == NULL) return;
 #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
    if(png_sizeof(png_struct) > png_struct_size ||
       png_sizeof(png_info) > png_info_size)
    {
       char msg[80];
       png_ptr->warning_fn=NULL;
       if (user_png_ver)
       {
         sprintf(msg, "Application was compiled with png.h from libpng-%.20s",
            user_png_ver);
@@ -233,22 +232,20 @@ png_read_init_3(png_structpp ptr_ptr, pn
    png_size_t png_struct_size)
 {
 #ifdef PNG_SETJMP_SUPPORTED
    jmp_buf tmp_jmp;  /* to save current jump buffer */
 #endif
 
    int i=0;
 
    png_structp png_ptr=*ptr_ptr;
 
-   if(png_ptr == NULL) return;
-
    do
    {
      if(user_png_ver[i] != png_libpng_ver[i])
      {
 #ifdef PNG_LEGACY_SUPPORTED
        png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
 #else
        png_ptr->warning_fn=NULL;
        png_warning(png_ptr,
         "Application uses deprecated png_read_init() and should be recompiled.");
@@ -313,21 +310,20 @@ png_read_init_3(png_structpp ptr_ptr, pn
  * changed in v0.90 to allow reading a file that already has the magic
  * bytes read from the stream.  You can tell libpng how many bytes have
  * been read from the beginning of the stream (up to the maximum of 8)
  * via png_set_sig_bytes(), and we will only check the remaining bytes
  * here.  The application can then have access to the signature bytes we
  * read if it is determined that this isn't a valid PNG file.
  */
 void PNGAPI
 png_read_info(png_structp png_ptr, png_infop info_ptr)
 {
-   if(png_ptr == NULL) return;
    png_debug(1, "in png_read_info\n");
    /* If we haven't checked all of the PNG signature bytes, do so now. */
    if (png_ptr->sig_bytes < 8)
    {
       png_size_t num_checked = png_ptr->sig_bytes,
                  num_to_check = 8 - num_checked;
 
       png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);
       png_ptr->sig_bytes = 8;
 
@@ -623,60 +619,57 @@ png_read_frame_head(png_structp png_ptr,
         }
     }
 }
 #endif /* PNG_READ_APNG_SUPPORTED */
 
 /* optional call to update the users info_ptr structure */
 void PNGAPI
 png_read_update_info(png_structp png_ptr, png_infop info_ptr)
 {
    png_debug(1, "in png_read_update_info\n");
-   if(png_ptr == NULL) return;
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
    else
       png_warning(png_ptr,
       "Ignoring extra png_read_update_info() call; row buffer not reallocated");
    png_read_transform_info(png_ptr, info_ptr);
 }
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
 /* Initialize palette, background, etc, after transformations
  * are set, but before any reading takes place.  This allows
  * the user to obtain a gamma-corrected palette, for example.
  * If the user doesn't call this, we will do it ourselves.
  */
 void PNGAPI
 png_start_read_image(png_structp png_ptr)
 {
    png_debug(1, "in png_start_read_image\n");
-   if(png_ptr == NULL) return;
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
 }
 #endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
 void PNGAPI
 png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_IDAT;
 #if defined(PNG_READ_APNG_SUPPORTED)
    PNG_fdAT;
    PNG_IEND;
 #endif
    const int png_pass_dsp_mask[7] = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
    const int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
 #endif
    int ret;
-   if(png_ptr == NULL) return;
    png_debug2(1, "in png_read_row (row %lu, pass %d)\n",
       png_ptr->row_number, png_ptr->pass);
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
    if (png_ptr->row_number == 0 && png_ptr->pass == 0)
    {
    /* check for transforms that have been set but were defined out */
 #if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)
    if (png_ptr->transformations & PNG_INVERT_MONO)
       png_warning(png_ptr, "PNG_READ_INVERT_SUPPORTED is not defined.");
@@ -951,21 +944,20 @@ png_read_row(png_structp png_ptr, png_by
 
 void PNGAPI
 png_read_rows(png_structp png_ptr, png_bytepp row,
    png_bytepp display_row, png_uint_32 num_rows)
 {
    png_uint_32 i;
    png_bytepp rp;
    png_bytepp dp;
 
    png_debug(1, "in png_read_rows\n");
-   if(png_ptr == NULL) return;
    rp = row;
    dp = display_row;
    if (rp != NULL && dp != NULL)
       for (i = 0; i < num_rows; i++)
       {
          png_bytep rptr = *rp++;
          png_bytep dptr = *dp++;
 
          png_read_row(png_ptr, rptr, dptr);
       }
@@ -1000,21 +992,20 @@ png_read_rows(png_structp png_ptr, png_b
  * [*] png_handle_alpha() does not exist yet, as of this version of libpng
  */
 void PNGAPI
 png_read_image(png_structp png_ptr, png_bytepp image)
 {
    png_uint_32 i,image_height;
    int pass, j;
    png_bytepp rp;
 
    png_debug(1, "in png_read_image\n");
-   if(png_ptr == NULL) return;
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
    pass = png_set_interlace_handling(png_ptr);
 #else
    if (png_ptr->interlaced)
       png_error(png_ptr,
         "Cannot read interlaced image -- interlace handler disabled.");
    pass = 1;
 #endif
 
@@ -1039,21 +1030,20 @@ png_read_image(png_structp png_ptr, png_
  * file, will verify the end is accurate, and will read any comments
  * or time information at the end of the file, if info is not NULL.
  */
 void PNGAPI
 png_read_end(png_structp png_ptr, png_infop info_ptr)
 {
    png_byte chunk_length[4];
    png_uint_32 length;
 
    png_debug(1, "in png_read_end\n");
-   if(png_ptr == NULL) return;
    png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */
 
    do
    {
 #ifdef PNG_USE_LOCAL_ARRAYS
       PNG_IHDR;
       PNG_IDAT;
       PNG_IEND;
       PNG_PLTE;
 #if defined(PNG_READ_bKGD_SUPPORTED)
@@ -1443,35 +1433,33 @@ png_read_destroy(png_structp png_ptr, pn
 
 #ifdef PNG_SETJMP_SUPPORTED
    png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof (jmp_buf));
 #endif
 
 }
 
 void PNGAPI
 png_set_read_status_fn(png_structp png_ptr, png_read_status_ptr read_row_fn)
 {
-   if(png_ptr == NULL) return;
    png_ptr->read_row_fn = read_row_fn;
 }
 
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
 #if defined(PNG_INFO_IMAGE_SUPPORTED)
 void PNGAPI
 png_read_png(png_structp png_ptr, png_infop info_ptr,
                            int transforms,
                            voidp params)
 {
    int row;
 
-   if(png_ptr == NULL) return;
 #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
    /* invert the alpha channel from opacity to transparency
     */
    if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
        png_set_invert_alpha(png_ptr);
 #endif
 
    /* png_read_info() gives us all of the information from the
     * PNG file before the first IDAT (image data chunk).
     */
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngrio.c mozilla/modules/libimg/png/pngrio.c
--- mozilla.orig/modules/libimg/png/pngrio.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngrio.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,14 +1,14 @@
 
 /* pngrio.c - functions for data input
  *
- * Last changed in libpng 1.2.13 November 13, 2006
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * This file provides a location for all input.  Users who need
  * special handling are expected to write a function that has the same
  * arguments as this and performs a similar function, but that possibly
  * has a different input method.  Note that you shouldn't change this
  * function, but rather write a replacement function and then make
@@ -39,21 +39,20 @@ png_read_data(png_structp png_ptr, png_b
 /* This is the function that does the actual reading of data.  If you are
    not reading from a standard C stream, you should create a replacement
    read_data function and use it at run time with png_set_read_fn(), rather
    than changing the library. */
 #ifndef USE_FAR_KEYWORD
 void PNGAPI
 png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    png_size_t check;
 
-   if(png_ptr == NULL) return;
    /* fread() returns 0 on error, so it is OK to store this in a png_size_t
     * instead of an int, which is what fread() actually returns.
     */
 #if defined(_WIN32_WCE)
    if ( !ReadFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
       check = 0;
 #else
    check = (png_size_t)fread(data, (png_size_t)1, length,
       (png_FILE_p)png_ptr->io_ptr);
 #endif
@@ -70,21 +69,20 @@ png_default_read_data(png_structp png_pt
 #define NEAR_BUF_SIZE 1024
 #define MIN(a,b) (a <= b ? a : b)
 
 static void PNGAPI
 png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    int check;
    png_byte *n_data;
    png_FILE_p io_ptr;
 
-   if(png_ptr == NULL) return;
    /* Check if data really is near. If so, use usual code. */
    n_data = (png_byte *)CVT_PTR_NOCHECK(data);
    io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
    if ((png_bytep)n_data == data)
    {
 #if defined(_WIN32_WCE)
       if ( !ReadFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
          check = 0;
 #else
       check = fread(n_data, 1, length, io_ptr);
@@ -131,21 +129,20 @@ png_default_read_data(png_structp png_pt
    read_data_fn - pointer to a new input function that takes as its
                   arguments a pointer to a png_struct, a pointer to
                   a location where input data can be stored, and a 32-bit
                   unsigned int that is the number of bytes to be read.
                   To exit and output any fatal error messages the new write
                   function should call png_error(png_ptr, "Error msg"). */
 void PNGAPI
 png_set_read_fn(png_structp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn)
 {
-   if(png_ptr == NULL) return;
    png_ptr->io_ptr = io_ptr;
 
 #if !defined(PNG_NO_STDIO)
    if (read_data_fn != NULL)
       png_ptr->read_data_fn = read_data_fn;
    else
       png_ptr->read_data_fn = png_default_read_data;
 #else
    png_ptr->read_data_fn = read_data_fn;
 #endif
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngrtran.c mozilla/modules/libimg/png/pngrtran.c
--- mozilla.orig/modules/libimg/png/pngrtran.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngrtran.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,37 +1,36 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.11 June 15, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * This file contains functions optionally called by an application
  * in order to tell libpng how to handle data when reading a PNG.
  * Transformations that are used in both reading and writing are
  * in pngtrans.c.
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 
 #if defined(PNG_READ_SUPPORTED)
 
 /* Set the action on getting a CRC error for an ancillary or critical chunk. */
 void PNGAPI
 png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
 {
    png_debug(1, "in png_set_crc_action\n");
    /* Tell libpng how we react to CRC errors in critical chunks */
-   if(png_ptr == NULL) return;
    switch (crit_action)
    {
       case PNG_CRC_NO_CHANGE:                        /* leave setting as is */
          break;
       case PNG_CRC_WARN_USE:                               /* warn/use data */
          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
          png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
          break;
       case PNG_CRC_QUIET_USE:                             /* quiet/use data */
          png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
@@ -74,53 +73,61 @@ png_set_crc_action(png_structp png_ptr, 
 
 #if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
     defined(PNG_FLOATING_POINT_SUPPORTED)
 /* handle alpha and tRNS via a background color */
 void PNGAPI
 png_set_background(png_structp png_ptr,
    png_color_16p background_color, int background_gamma_code,
    int need_expand, double background_gamma)
 {
    png_debug(1, "in png_set_background\n");
-   if(png_ptr == NULL) return;
    if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
    {
       png_warning(png_ptr, "Application must supply a known background gamma");
       return;
    }
 
    png_ptr->transformations |= PNG_BACKGROUND;
    png_memcpy(&(png_ptr->background), background_color,
       png_sizeof(png_color_16));
    png_ptr->background_gamma = (float)background_gamma;
    png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
    png_ptr->transformations |= (need_expand ? PNG_BACKGROUND_EXPAND : 0);
+
+   /* Note:  if need_expand is set and color_type is either RGB or RGB_ALPHA
+    * (in which case need_expand is superfluous anyway), the background color
+    * might actually be gray yet not be flagged as such. This is not a problem
+    * for the current code, which uses PNG_BACKGROUND_IS_GRAY only to
+    * decide when to do the png_do_gray_to_rgb() transformation.
+    */
+   if ((need_expand && !(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) ||
+       (!need_expand && background_color->red == background_color->green &&
+        background_color->red == background_color->blue))
+      png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
 }
 #endif
 
 #if defined(PNG_READ_16_TO_8_SUPPORTED)
 /* strip 16 bit depth files to 8 bit depth */
 void PNGAPI
 png_set_strip_16(png_structp png_ptr)
 {
    png_debug(1, "in png_set_strip_16\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_16_TO_8;
 }
 #endif
 
 #if defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
 void PNGAPI
 png_set_strip_alpha(png_structp png_ptr)
 {
    png_debug(1, "in png_set_strip_alpha\n");
-   if(png_ptr == NULL) return;
    png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
 }
 #endif
 
 #if defined(PNG_READ_DITHER_SUPPORTED)
 /* Dither file to 8 bit.  Supply a palette, the current number
  * of elements in the palette, the maximum number of elements
  * allowed, and a histogram if possible.  If the current number
  * of colors is greater then the maximum number, the palette will be
  * modified to fit in the maximum number.  "full_dither" indicates
@@ -136,21 +143,20 @@ typedef struct png_dsort_struct
 } png_dsort;
 typedef png_dsort FAR *       png_dsortp;
 typedef png_dsort FAR * FAR * png_dsortpp;
 
 void PNGAPI
 png_set_dither(png_structp png_ptr, png_colorp palette,
    int num_palette, int maximum_colors, png_uint_16p histogram,
    int full_dither)
 {
    png_debug(1, "in png_set_dither\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_DITHER;
 
    if (!full_dither)
    {
       int i;
 
       png_ptr->dither_index = (png_bytep)png_malloc(png_ptr,
          (png_uint_32)(num_palette * png_sizeof (png_byte)));
       for (i = 0; i < num_palette; i++)
          png_ptr->dither_index[i] = (png_byte)i;
@@ -520,40 +526,38 @@ png_set_dither(png_structp png_ptr, png_
  * also needlessly introduces small errors.
  *
  * We will turn off gamma transformation later if no semitransparent entries
  * are present in the tRNS array for palette images.  We can't do it here
  * because we don't necessarily have the tRNS chunk yet.
  */
 void PNGAPI
 png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
 {
    png_debug(1, "in png_set_gamma\n");
-   if(png_ptr == NULL) return;
    if ((fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD) ||
        (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) ||
        (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
      png_ptr->transformations |= PNG_GAMMA;
    png_ptr->gamma = (float)file_gamma;
    png_ptr->screen_gamma = (float)scrn_gamma;
 }
 #endif
 
 #if defined(PNG_READ_EXPAND_SUPPORTED)
 /* Expand paletted images to RGB, expand grayscale images of
  * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
  * to alpha channels.
  */
 void PNGAPI
 png_set_expand(png_structp png_ptr)
 {
    png_debug(1, "in png_set_expand\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
 }
 
 /* GRR 19990627:  the following three functions currently are identical
  *  to png_set_expand().  However, it is entirely reasonable that someone
  *  might wish to expand an indexed image to RGB but *not* expand a single,
  *  fully transparent palette entry to a full alpha channel--perhaps instead
  *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace
  *  the transparent color with a particular RGB value, or drop tRNS entirely.
  *  IOW, a future version of the library may make the transformations flag
@@ -565,43 +569,40 @@ png_set_expand(png_structp png_ptr)
  *
  *  GRP 20060307: In libpng-1.4.0, png_set_gray_1_2_4_to_8() was modified
  *  to expand only the sample depth but not to expand the tRNS to alpha.
  */
 
 /* Expand paletted images to RGB. */
 void PNGAPI
 png_set_palette_to_rgb(png_structp png_ptr)
 {
    png_debug(1, "in png_set_palette_to_rgb\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
 }
 
 #if !defined(PNG_1_0_X)
 /* Expand grayscale images of less than 8-bit depth to 8 bits. */
 void PNGAPI
 png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
 {
    png_debug(1, "in png_set_expand_gray_1_2_4_to_8\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_EXPAND_tRNS;
 }
 #endif
 
 #if defined(PNG_1_0_X) || defined(PNG_1_2_X)
 /* Expand grayscale images of less than 8-bit depth to 8 bits. */
 /* Deprecated as of libpng-1.2.9 */
 void PNGAPI
 png_set_gray_1_2_4_to_8(png_structp png_ptr)
 {
    png_debug(1, "in png_set_gray_1_2_4_to_8\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
 }
 #endif
 
 
 /* Expand tRNS chunks to alpha channels. */
 void PNGAPI
 png_set_tRNS_to_alpha(png_structp png_ptr)
 {
    png_debug(1, "in png_set_expand\n");
@@ -623,31 +624,29 @@ png_set_gray_to_rgb(png_structp png_ptr)
 /* Convert a RGB image to a grayscale of the same width.  This allows us,
  * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
  */
 
 void PNGAPI
 png_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,
    double green)
 {
       int red_fixed = (int)((float)red*100000.0 + 0.5);
       int green_fixed = (int)((float)green*100000.0 + 0.5);
-      if(png_ptr == NULL) return;
       png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
 }
 #endif
 
 void PNGAPI
 png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
    png_fixed_point red, png_fixed_point green)
 {
    png_debug(1, "in png_set_rgb_to_gray\n");
-   if(png_ptr == NULL) return;
    switch(error_action)
    {
       case 1: png_ptr->transformations |= PNG_RGB_TO_GRAY;
               break;
       case 2: png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
               break;
       case 3: png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
    }
    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
 #if defined(PNG_READ_EXPAND_SUPPORTED)
@@ -684,21 +683,20 @@ png_set_rgb_to_gray_fixed(png_structp pn
 #endif
 
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_LEGACY_SUPPORTED)
 void PNGAPI
 png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
    read_user_transform_fn)
 {
    png_debug(1, "in png_set_read_user_transform_fn\n");
-   if(png_ptr == NULL) return;
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
    png_ptr->transformations |= PNG_USER_TRANSFORM;
    png_ptr->read_user_transform_fn = read_user_transform_fn;
 #endif
 #ifdef PNG_LEGACY_SUPPORTED
    if(read_user_transform_fn)
       png_warning(png_ptr,
         "This version of libpng does not support user transforms");
 #endif
 }
@@ -714,46 +712,20 @@ png_init_read_transformations(png_struct
 #if defined(PNG_USELESS_TESTS_SUPPORTED)
    if(png_ptr != NULL)
 #endif
   {
 #if defined(PNG_READ_BACKGROUND_SUPPORTED) || defined(PNG_READ_SHIFT_SUPPORTED) \
  || defined(PNG_READ_GAMMA_SUPPORTED)
    int color_type = png_ptr->color_type;
 #endif
 
 #if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
-
-#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
-   /* Detect gray background and attempt to enable optimization
-    * for gray --> RGB case */
-   /* Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
-    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
-    * background color might actually be gray yet not be flagged as such.
-    * This is not a problem for the current code, which uses
-    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
-    * png_do_gray_to_rgb() transformation.
-    */
-   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       !(color_type & PNG_COLOR_MASK_COLOR))
-   {
-          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-   } else if ((png_ptr->transformations & PNG_BACKGROUND) &&
-              !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-              (png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-              png_ptr->background.red == png_ptr->background.green &&
-              png_ptr->background.red == png_ptr->background.blue)
-   {
-          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-          png_ptr->background.gray = png_ptr->background.red;
-   }
-#endif
-
    if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
        (png_ptr->transformations & PNG_EXPAND))
    {
       if (!(color_type & PNG_COLOR_MASK_COLOR))  /* i.e., GRAY or GRAY_ALPHA */
       {
          /* expand background and tRNS chunks */
          switch (png_ptr->bit_depth)
          {
             case 1:
                png_ptr->background.gray *= (png_uint_16)0xff;
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngrutil.c mozilla/modules/libimg/png/pngrutil.c
--- mozilla.orig/modules/libimg/png/pngrutil.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngrutil.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,51 +1,49 @@
 
 /* pngrutil.c - utilities to read a PNG file
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.11 June 4, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * This file contains routines that are only called from within
  * libpng itself during the course of reading an image.
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 
 #if defined(PNG_READ_SUPPORTED)
 
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-#  if defined(_WIN32_WCE)
+#if defined(_WIN32_WCE)
 /* strtod() function is not supported on WindowsCE */
-__inline double png_strtod(png_structp png_ptr, const char *nptr, char **endptr)
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+__inline double strtod(const char *nptr, char **endptr)
 {
    double result = 0;
    int len;
    wchar_t *str, *end;
 
    len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
-   str = (wchar_t *)png_malloc(png_ptr, len * sizeof(wchar_t));
+   str = (wchar_t *)malloc(len * sizeof(wchar_t));
    if ( NULL != str )
    {
       MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
       result = wcstod(str, &end);
       len = WideCharToMultiByte(CP_ACP, 0, end, -1, NULL, 0, NULL, NULL);
       *endptr = (char *)nptr + (png_strlen(nptr) - len + 1);
-      png_free(str);
+      free(str);
    }
    return result;
 }
-#  else
-#    define png_strtod(p,a,b) strtod(a,b)
 #  endif
 #endif
 
 png_uint_32 PNGAPI
 png_get_uint_31(png_structp png_ptr, png_bytep buf)
 {
    png_uint_32 i = png_get_uint_32(buf);
    if (i > PNG_UINT_31_MAX)
      png_error(png_ptr, "PNG unsigned integer out of range.");
    return (i);
@@ -85,21 +83,20 @@ png_get_uint_16(png_bytep buf)
       (png_uint_16)(*(buf + 1)));
 
    return (i);
 }
 #endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */
 
 /* Read data, and (optionally) run it through the CRC. */
 void /* PRIVATE */
 png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
 {
-   if(png_ptr == NULL) return;
    png_read_data(png_ptr, buf, length);
    png_calculate_crc(png_ptr, buf, length);
 }
 
 /* Optionally skip data and then check the CRC.  Depending on whether we
    are reading a ancillary or critical chunk, and how the program has set
    things up, we may calculate the CRC on the data and print a message.
    Returns '1' if there was a CRC error, '0' otherwise. */
 int /* PRIVATE */
 png_crc_finish(png_structp png_ptr, png_uint_32 skip)
@@ -1731,21 +1728,21 @@ png_handle_sCAL(png_structp png_ptr, png
    {
       png_free(png_ptr, buffer);
       return;
    }
 
    buffer[slength] = 0x00; /* null terminate the last string */
 
    ep = buffer + 1;        /* skip unit byte */
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   width = png_strtod(png_ptr, ep, &vp);
+   width = strtod(ep, &vp);
    if (*vp)
    {
        png_warning(png_ptr, "malformed width string in sCAL chunk");
        return;
    }
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
    swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
    if (swidth == NULL)
      {
@@ -1754,21 +1751,21 @@ png_handle_sCAL(png_structp png_ptr, png
      }
    png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));
 #endif
 #endif
 
    for (ep = buffer; *ep; ep++)
       /* empty loop */ ;
    ep++;
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   height = png_strtod(png_ptr, ep, &vp);
+   height = strtod(ep, &vp);
    if (*vp)
    {
        png_warning(png_ptr, "malformed height string in sCAL chunk");
        return;
    }
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
    sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
    if (swidth == NULL)
      {
@@ -2409,21 +2406,21 @@ png_check_chunk_name(png_structp png_ptr
 /* Combines the row recently read in with the existing pixels in the
    row.  This routine takes care of alpha and transparency if requested.
    This routine also handles the two methods of progressive display
    of interlaced images, depending on the mask value.
    The mask value describes which pixels are to be combined with
    the row.  The pattern always repeats every 8 pixels, so just 8
    bits are needed.  A one indicates the pixel is to be combined,
    a zero indicates the pixel is to be skipped.  This is in addition
    to any alpha or transparency value associated with the pixel.  If
    you want all pixels to be combined, pass 0xff (255) in mask.  */
-#ifndef PNG_HAVE_MMX_COMBINE_ROW
+#ifndef PNG_HAVE_ASSEMBLER_COMBINE_ROW
 void /* PRIVATE */
 png_combine_row(png_structp png_ptr, png_bytep row, int mask)
 {
    png_debug(1,"in png_combine_row\n");
    if (mask == 0xff)
    {
       png_memcpy(row, png_ptr->row_buf + 1,
          PNG_ROWBYTES(png_ptr->row_info.pixel_depth, png_ptr->width));
    }
    else
@@ -2610,24 +2607,24 @@ png_combine_row(png_structp png_ptr, png
                if (m == 1)
                   m = 0x80;
                else
                   m >>= 1;
             }
             break;
          }
       }
    }
 }
-#endif /* !PNG_HAVE_MMX_COMBINE_ROW */
+#endif /* !PNG_HAVE_ASSEMBLER_COMBINE_ROW */
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
-#ifndef PNG_HAVE_MMX_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
+#ifndef PNG_HAVE_ASSEMBLER_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
 /* OLD pre-1.0.9 interface:
 void png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
    png_uint_32 transformations)
  */
 void /* PRIVATE */
 png_do_read_interlace(png_structp png_ptr)
 {
    png_row_infop row_info = &(png_ptr->row_info);
    png_bytep row = png_ptr->row_buf + 1;
    int pass = png_ptr->pass;
@@ -2839,24 +2836,24 @@ png_do_read_interlace(png_structp png_pt
          }
       }
       row_info->width = final_width;
       row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,final_width);
    }
 #if !defined(PNG_READ_PACKSWAP_SUPPORTED)
    if (&transformations == NULL) /* silence compiler warning */
       return;
 #endif
 }
-#endif /* !PNG_HAVE_MMX_READ_INTERLACE */
+#endif /* !PNG_HAVE_ASSEMBLER_READ_INTERLACE */
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 
-#ifndef PNG_HAVE_MMX_READ_FILTER_ROW
+#ifndef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
 void /* PRIVATE */
 png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
    png_bytep prev_row, int filter)
 {
    png_debug(1, "in png_read_filter_row\n");
    png_debug2(2,"row = %lu, filter = %d\n", png_ptr->row_number, filter);
    switch (filter)
    {
       case PNG_FILTER_VALUE_NONE:
          break;
@@ -2965,21 +2962,21 @@ png_read_filter_row(png_structp png_ptr,
             rp++;
          }
          break;
       }
       default:
          png_warning(png_ptr, "Ignoring bad adaptive filter type");
          *row=0;
          break;
    }
 }
-#endif /* !PNG_HAVE_MMX_READ_FILTER_ROW */
+#endif /* !PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */
 
 void /* PRIVATE */
 png_read_finish_row(png_structp png_ptr)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* start of interlace block */
    const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
@@ -3269,21 +3266,21 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
    if (png_ptr->row_buf == NULL)
       png_ptr->row_buf = png_ptr->big_row_buf+32;
 #if defined(PNG_DEBUG) && defined(PNG_USE_PNGGCCRD)
    png_ptr->row_buf_size = row_bytes;
 #endif
 
 #ifdef PNG_MAX_MALLOC_64K
    if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
       png_error(png_ptr, "This image requires a row greater than 64KB");
 #endif
-   if ((png_uint_32)png_ptr->rowbytes > (png_uint_32)(PNG_SIZE_MAX - 1))
+   if ((png_uint_32)png_ptr->rowbytes > PNG_SIZE_MAX - 1)
       png_error(png_ptr, "Row has too many bytes to allocate in memory.");
    png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
       png_ptr->rowbytes + 1));
 
    png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
 
    png_debug1(3, "width = %lu,\n", png_ptr->width);
    png_debug1(3, "height = %lu,\n", png_ptr->height);
    png_debug1(3, "iwidth = %lu,\n", png_ptr->iwidth);
    png_debug1(3, "num_rows = %lu\n", png_ptr->num_rows);
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngset.c mozilla/modules/libimg/png/pngset.c
--- mozilla.orig/modules/libimg/png/pngset.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngset.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,16 +1,16 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * The functions here are used during reads to store data from the file
  * into the info struct, and during writes to store application data
  * into the info struct for writing into the file.  This abstracts the
  * info struct and allows us to change the structure in the future.
  */
 
 #define PNG_INTERNAL
@@ -974,24 +974,24 @@ png_set_sPLT(png_structp png_ptr,
     for (i = 0; i < nentries; i++)
     {
         png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
         png_sPLT_tp from = entries + i;
 
         to->name = (png_charp)png_malloc(png_ptr,
             png_strlen(from->name) + 1);
         /* TODO: use png_malloc_warn */
         png_strcpy(to->name, from->name);
         to->entries = (png_sPLT_entryp)png_malloc(png_ptr,
-            from->nentries * png_sizeof(png_sPLT_entry));
+            from->nentries * png_sizeof(png_sPLT_t));
         /* TODO: use png_malloc_warn */
         png_memcpy(to->entries, from->entries,
-            from->nentries * png_sizeof(png_sPLT_entry));
+            from->nentries * png_sizeof(png_sPLT_t));
         to->nentries = from->nentries;
         to->depth = from->depth;
     }
 
     info_ptr->splt_palettes = np;
     info_ptr->splt_palettes_num += nentries;
     info_ptr->valid |= PNG_INFO_sPLT;
 #ifdef PNG_FREE_ME_SUPPORTED
     info_ptr->free_me |= PNG_FREE_SPLT;
 #endif
@@ -1324,27 +1324,25 @@ png_set_invalid(png_structp png_ptr, png
       info_ptr->valid &= ~(mask);
 }
 
 
 #ifndef PNG_1_0_X
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
 /* this function was added to libpng 1.2.0 and should always exist by default */
 void PNGAPI
 png_set_asm_flags (png_structp png_ptr, png_uint_32 asm_flags)
 {
-#ifdef PNG_MMX_CODE_SUPPORTED
     png_uint_32 settable_asm_flags;
     png_uint_32 settable_mmx_flags;
-#endif
+
     if (png_ptr == NULL)
        return;
-#ifdef PNG_MMX_CODE_SUPPORTED
 
     settable_mmx_flags =
 #ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
                          PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  |
 #endif
 #ifdef PNG_HAVE_ASSEMBLER_READ_INTERLACE
                          PNG_ASM_FLAG_MMX_READ_INTERLACE    |
 #endif
 #ifdef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
                          PNG_ASM_FLAG_MMX_READ_FILTER_SUB   |
@@ -1359,51 +1357,49 @@ png_set_asm_flags (png_structp png_ptr, 
 
     if (!(png_ptr->asm_flags & PNG_ASM_FLAG_MMX_SUPPORT_COMPILED) ||
         !(png_ptr->asm_flags & PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU))
     {
         /* clear all MMX flags if MMX isn't supported */
         settable_asm_flags &= ~settable_mmx_flags;
         png_ptr->asm_flags &= ~settable_mmx_flags;
     }
 
     /* we're replacing the settable bits with those passed in by the user,
-     * so first zero them out of the master copy, then bitwise-OR in the
+     * so first zero them out of the master copy, then logical-OR in the
      * allowed subset that was requested */
 
     png_ptr->asm_flags &= ~settable_asm_flags;               /* zero them */
     png_ptr->asm_flags |= (asm_flags & settable_asm_flags);  /* set them */
-#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
+#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
+#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
 /* this function was added to libpng 1.2.0 */
 void PNGAPI
 png_set_mmx_thresholds (png_structp png_ptr,
                         png_byte mmx_bitdepth_threshold,
                         png_uint_32 mmx_rowbytes_threshold)
 {
     if (png_ptr == NULL)
        return;
-#ifdef PNG_MMX_CODE_SUPPORTED
     png_ptr->mmx_bitdepth_threshold = mmx_bitdepth_threshold;
     png_ptr->mmx_rowbytes_threshold = mmx_rowbytes_threshold;
-#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
 #endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
 /* this function was added to libpng 1.2.6 */
 void PNGAPI
 png_set_user_limits (png_structp png_ptr, png_uint_32 user_width_max,
     png_uint_32 user_height_max)
 {
     /* Images with dimensions larger than these limits will be
      * rejected by png_set_IHDR().  To accept any PNG datastream
      * regardless of dimensions, set both limits to 0x7ffffffL.
      */
-    if(png_ptr == NULL) return;
     png_ptr->user_width_max = user_width_max;
     png_ptr->user_height_max = user_height_max;
 }
 #endif /* ?PNG_SET_USER_LIMITS_SUPPORTED */
 
 #endif /* ?PNG_1_0_X */
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngtrans.c mozilla/modules/libimg/png/pngtrans.c
--- mozilla.orig/modules/libimg/png/pngtrans.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngtrans.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,112 +1,106 @@
 
 /* pngtrans.c - transforms the data in a row (used by both readers and writers)
  *
- * Last changed in libpng 1.2.13 November 13, 2006
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
 #if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
 /* turn on BGR-to-RGB mapping */
 void PNGAPI
 png_set_bgr(png_structp png_ptr)
 {
    png_debug(1, "in png_set_bgr\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_BGR;
 }
 #endif
 
 #if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
 /* turn on 16 bit byte swapping */
 void PNGAPI
 png_set_swap(png_structp png_ptr)
 {
    png_debug(1, "in png_set_swap\n");
-   if(png_ptr == NULL) return;
    if (png_ptr->bit_depth == 16)
       png_ptr->transformations |= PNG_SWAP_BYTES;
 }
 #endif
 
 #if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
 /* turn on pixel packing */
 void PNGAPI
 png_set_packing(png_structp png_ptr)
 {
    png_debug(1, "in png_set_packing\n");
-   if(png_ptr == NULL) return;
    if (png_ptr->bit_depth < 8)
    {
       png_ptr->transformations |= PNG_PACK;
       png_ptr->usr_bit_depth = 8;
    }
 }
 #endif
 
 #if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
 /* turn on packed pixel swapping */
 void PNGAPI
 png_set_packswap(png_structp png_ptr)
 {
    png_debug(1, "in png_set_packswap\n");
-   if(png_ptr == NULL) return;
    if (png_ptr->bit_depth < 8)
       png_ptr->transformations |= PNG_PACKSWAP;
 }
 #endif
 
 #if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
 void PNGAPI
 png_set_shift(png_structp png_ptr, png_color_8p true_bits)
 {
    png_debug(1, "in png_set_shift\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_SHIFT;
    png_ptr->shift = *true_bits;
 }
 #endif
 
 #if defined(PNG_READ_INTERLACING_SUPPORTED) || \
     defined(PNG_WRITE_INTERLACING_SUPPORTED)
 int PNGAPI
 png_set_interlace_handling(png_structp png_ptr)
 {
    png_debug(1, "in png_set_interlace handling\n");
-   if (png_ptr && png_ptr->interlaced)
+   if (png_ptr->interlaced)
    {
       png_ptr->transformations |= PNG_INTERLACE;
       return (7);
    }
 
    return (1);
 }
 #endif
 
 #if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
 /* Add a filler byte on read, or remove a filler or alpha byte on write.
  * The filler type has changed in v0.95 to allow future 2-byte fillers
  * for 48-bit input data, as well as to avoid problems with some compilers
  * that don't like bytes as parameters.
  */
 void PNGAPI
 png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
 {
    png_debug(1, "in png_set_filler\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_FILLER;
    png_ptr->filler = (png_byte)filler;
    if (filler_loc == PNG_FILLER_AFTER)
       png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
    else
       png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;
 
    /* This should probably go in the "do_read_filler" routine.
     * I attempted to do that in libpng-1.0.1a but that caused problems
     * so I restored it in libpng-1.0.2a
@@ -125,56 +119,52 @@ png_set_filler(png_structp png_ptr, png_
       png_ptr->usr_channels = 2;
    }
 }
 
 #if !defined(PNG_1_0_X)
 /* Added to libpng-1.2.7 */
 void PNGAPI
 png_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)
 {
    png_debug(1, "in png_set_add_alpha\n");
-   if(png_ptr == NULL) return;
    png_set_filler(png_ptr, filler, filler_loc);
    png_ptr->transformations |= PNG_ADD_ALPHA;
 }
 #endif
 
 #endif
 
 #if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
     defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
 void PNGAPI
 png_set_swap_alpha(png_structp png_ptr)
 {
    png_debug(1, "in png_set_swap_alpha\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_SWAP_ALPHA;
 }
 #endif
 
 #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
     defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
 void PNGAPI
 png_set_invert_alpha(png_structp png_ptr)
 {
    png_debug(1, "in png_set_invert_alpha\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_INVERT_ALPHA;
 }
 #endif
 
 #if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
 void PNGAPI
 png_set_invert_mono(png_structp png_ptr)
 {
    png_debug(1, "in png_set_invert_mono\n");
-   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_INVERT_MONO;
 }
 
 /* invert monochrome grayscale data */
 void /* PRIVATE */
 png_do_invert(png_row_infop row_info, png_bytep row)
 {
    png_debug(1, "in png_do_invert\n");
   /* This test removed from libpng version 1.0.13 and 1.2.0:
    *   if (row_info->bit_depth == 1 &&
@@ -624,38 +614,39 @@ png_do_bgr(png_row_infop row_info, png_b
 #endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */
 
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_LEGACY_SUPPORTED)
 void PNGAPI
 png_set_user_transform_info(png_structp png_ptr, png_voidp
    user_transform_ptr, int user_transform_depth, int user_transform_channels)
 {
    png_debug(1, "in png_set_user_transform_info\n");
-   if(png_ptr == NULL) return;
 #if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    png_ptr->user_transform_ptr = user_transform_ptr;
    png_ptr->user_transform_depth = (png_byte)user_transform_depth;
    png_ptr->user_transform_channels = (png_byte)user_transform_channels;
 #else
    if(user_transform_ptr || user_transform_depth || user_transform_channels)
       png_warning(png_ptr,
         "This version of libpng does not support user transform info");
 #endif
 }
 #endif
 
 /* This function returns a pointer to the user_transform_ptr associated with
  * the user transform functions.  The application should free any memory
  * associated with this pointer before png_write_destroy and png_read_destroy
  * are called.
  */
 png_voidp PNGAPI
 png_get_user_transform_ptr(png_structp png_ptr)
 {
-   if (png_ptr == NULL) return (NULL);
 #if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    return ((png_voidp)png_ptr->user_transform_ptr);
-#endif
+#else
+   if(png_ptr)
+     return (NULL);
    return (NULL);
+#endif
 }
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngwio.c mozilla/modules/libimg/png/pngwio.c
--- mozilla.orig/modules/libimg/png/pngwio.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngwio.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,14 +1,14 @@
 
 /* pngwio.c - functions for data output
  *
- * Last changed in libpng 1.2.13 November 13, 2006
+ * Last changed in libpng 1.2.3 - May 21, 2002
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2002 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * This file provides a location for all output.  Users who need
  * special handling are expected to write functions that have the same
  * arguments as these and perform similar functions, but that possibly
  * use different output methods.  Note that you shouldn't change these
  * functions, but rather write replacement functions and then change
@@ -38,21 +38,20 @@ png_write_data(png_structp png_ptr, png_
 /* This is the function that does the actual writing of data.  If you are
    not writing to a standard C stream, you should create a replacement
    write_data function and use it at run time with png_set_write_fn(), rather
    than changing the library. */
 #ifndef USE_FAR_KEYWORD
 void PNGAPI
 png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    png_uint_32 check;
 
-   if(png_ptr == NULL) return;
 #if defined(_WIN32_WCE)
    if ( !WriteFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
       check = 0;
 #else
    check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
 #endif
    if (check != length)
       png_error(png_ptr, "Write Error");
 }
 #else
@@ -64,21 +63,20 @@ png_default_write_data(png_structp png_p
 #define NEAR_BUF_SIZE 1024
 #define MIN(a,b) (a <= b ? a : b)
 
 void PNGAPI
 png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    png_uint_32 check;
    png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
    png_FILE_p io_ptr;
 
-   if(png_ptr == NULL) return;
    /* Check if data really is near. If so, use usual code. */
    near_data = (png_byte *)CVT_PTR_NOCHECK(data);
    io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
    if ((png_bytep)near_data == data)
    {
 #if defined(_WIN32_WCE)
       if ( !WriteFile(io_ptr, near_data, length, &check, NULL) )
          check = 0;
 #else
       check = fwrite(near_data, 1, length, io_ptr);
@@ -126,23 +124,20 @@ png_flush(png_structp png_ptr)
    if (png_ptr->output_flush_fn != NULL)
       (*(png_ptr->output_flush_fn))(png_ptr);
 }
 
 #if !defined(PNG_NO_STDIO)
 void PNGAPI
 png_default_flush(png_structp png_ptr)
 {
 #if !defined(_WIN32_WCE)
    png_FILE_p io_ptr;
-#endif
-   if(png_ptr == NULL) return;
-#if !defined(_WIN32_WCE)
    io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
    if (io_ptr != NULL)
       fflush(io_ptr);
 #endif
 }
 #endif
 #endif
 
 /* This function allows the application to supply new output functions for
    libpng if standard C streams aren't being used.
@@ -163,21 +158,20 @@ png_default_flush(png_structp png_ptr)
                    or pending transmission.  If the output method doesn't do
                    any buffering of ouput, a function prototype must still be
                    supplied although it doesn't have to do anything.  If
                    PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
                    time, output_flush_fn will be ignored, although it must be
                    supplied for compatibility. */
 void PNGAPI
 png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
 {
-   if(png_ptr == NULL) return;
    png_ptr->io_ptr = io_ptr;
 
 #if !defined(PNG_NO_STDIO)
    if (write_data_fn != NULL)
       png_ptr->write_data_fn = write_data_fn;
    else
       png_ptr->write_data_fn = png_default_write_data;
 #else
    png_ptr->write_data_fn = write_data_fn;
 #endif
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngwrite.c mozilla/modules/libimg/png/pngwrite.c
--- mozilla.orig/modules/libimg/png/pngwrite.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngwrite.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,16 +1,16 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.9 April 14, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 /* get internal access to png.h */
 #define PNG_INTERNAL
 #include "png.h"
 #ifdef PNG_WRITE_SUPPORTED
 
 /* Writes all the PNG information.  This is the suggested way to use the
@@ -462,24 +462,22 @@ png_create_write_struct_2(png_const_char
    png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
       (png_malloc_ptr)malloc_fn, (png_voidp)mem_ptr);
 #else
    png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG);
 #endif /* PNG_USER_MEM_SUPPORTED */
    if (png_ptr == NULL)
       return (NULL);
 
 #if !defined(PNG_1_0_X)
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
-#ifdef PNG_MMX_CODE_SUPPORTED
    png_init_mmx_flags(png_ptr);   /* 1.2.0 addition */
 #endif
-#endif
 #endif /* PNG_1_0_X */
 
    /* added at libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
    png_ptr->user_width_max=PNG_USER_WIDTH_MAX;
    png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
 #ifdef USE_FAR_KEYWORD
@@ -579,21 +577,20 @@ png_write_init(png_structp png_ptr)
 {
    /* We only come here via pre-1.0.7-compiled applications */
    png_write_init_2(png_ptr, "1.0.6 or earlier", 0, 0);
 }
 
 void PNGAPI
 png_write_init_2(png_structp png_ptr, png_const_charp user_png_ver,
    png_size_t png_struct_size, png_size_t png_info_size)
 {
    /* We only come here via pre-1.0.12-compiled applications */
-   if(png_ptr == NULL) return;
 #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
    if(png_sizeof(png_struct) > png_struct_size ||
       png_sizeof(png_info) > png_info_size)
    {
       char msg[80];
       png_ptr->warning_fn=NULL;
       if (user_png_ver)
       {
         sprintf(msg, "Application was compiled with png.h from libpng-%.20s",
            user_png_ver);
@@ -674,24 +671,22 @@ png_write_init_3(png_structpp ptr_ptr, p
    png_memset(png_ptr, 0, png_sizeof (png_struct));
 
    /* added at libpng-1.2.6 */
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
    png_ptr->user_width_max=PNG_USER_WIDTH_MAX;
    png_ptr->user_height_max=PNG_USER_HEIGHT_MAX;
 #endif
 
 #if !defined(PNG_1_0_X)
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
-#ifdef PNG_MMX_CODE_SUPPORTED
    png_init_mmx_flags(png_ptr);   /* 1.2.0 addition */
 #endif
-#endif
 #endif /* PNG_1_0_X */
 
 #ifdef PNG_SETJMP_SUPPORTED
    /* restore jump buffer */
    png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof (jmp_buf));
 #endif
 
    png_set_write_fn(png_ptr, png_voidp_NULL, png_rw_ptr_NULL,
       png_flush_ptr_NULL);
 
diff -ruN -p -U10 mozilla.orig/modules/libimg/png/pngwutil.c mozilla/modules/libimg/png/pngwutil.c
--- mozilla.orig/modules/libimg/png/pngwutil.c	2007-05-30 07:42:26.000000000 +0300
+++ mozilla/modules/libimg/png/pngwutil.c	2007-05-30 07:42:39.000000000 +0300
@@ -1,16 +1,16 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.2.15 January 5, 2007
+ * Last changed in libpng 1.2.11 June 4, 2006
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2007 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 #ifdef PNG_WRITE_SUPPORTED
 
 /* Place a 32-bit number into a buffer in PNG byte order.  We work
  * with unsigned numbers for convenience, although one supported
@@ -55,37 +55,35 @@ png_save_uint_16(png_bytep buf, unsigned
  * pre-defined chunk names here, and if you need a new one, define it
  * where the others are defined.  The length is the length of the data.
  * All the data must be present.  If that is not possible, use the
  * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
  * functions instead.
  */
 void PNGAPI
 png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
    png_bytep data, png_size_t length)
 {
-   if(png_ptr == NULL) return;
    png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
    png_write_chunk_data(png_ptr, data, length);
    png_write_chunk_end(png_ptr);
 }
 
 /* Write the start of a PNG chunk.  The type is the chunk type.
  * The total_length is the sum of the lengths of all the data you will be
  * passing in png_write_chunk_data().
  */
 void PNGAPI
 png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
    png_uint_32 length)
 {
    png_byte buf[4];
    png_debug2(0, "Writing %s chunk (%lu bytes)\n", chunk_name, length);
-   if(png_ptr == NULL) return;
 
    /* write the length */
    png_save_uint_32(buf, length);
    png_write_data(png_ptr, buf, (png_size_t)4);
 
    /* write the chunk name */
    png_write_data(png_ptr, chunk_name, (png_size_t)4);
    /* reset the crc and run it over the chunk name */
    png_reset_crc(png_ptr);
    png_calculate_crc(png_ptr, chunk_name, (png_size_t)4);
@@ -93,36 +91,33 @@ png_write_chunk_start(png_structp png_pt
 
 /* Write the data of a PNG chunk started with png_write_chunk_start().
  * Note that multiple calls to this function are allowed, and that the
  * sum of the lengths from these calls *must* add up to the total_length
  * given to png_write_chunk_start().
  */
 void PNGAPI
 png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    /* write the data, and run the CRC over it */
-   if(png_ptr == NULL) return;
    if (data != NULL && length > 0)
    {
       png_calculate_crc(png_ptr, data, length);
       png_write_data(png_ptr, data, length);
    }
 }
 
 /* Finish a chunk started with png_write_chunk_start(). */
 void PNGAPI
 png_write_chunk_end(png_structp png_ptr)
 {
    png_byte buf[4];
 
-   if(png_ptr == NULL) return;
-
    /* write the crc */
    png_save_uint_32(buf, png_ptr->crc);
 
    png_write_data(png_ptr, buf, (png_size_t)4);
 }
 
 /* Simple function to write the signature.  If we have already written
  * the magic bytes of the signature, or more likely, the PNG stream is
  * being embedded into another stream and doesn't need its own signature,
  * we should call png_set_sig_bytes() to tell libpng how many of the
@@ -755,21 +750,20 @@ png_write_sRGB(png_structp png_ptr, int 
 void /* PRIVATE */
 png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,
    png_charp profile, int profile_len)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_iCCP;
 #endif
    png_size_t name_len;
    png_charp new_name;
    compression_state comp;
-   int embedded_profile_len = 0;
 
    png_debug(1, "in png_write_iCCP\n");
 
    comp.num_output_ptr = 0;
    comp.max_output_ptr = 0;
    comp.output_ptr = NULL;
    comp.input = NULL;
    comp.input_len = 0;
 
    if (name == NULL || (name_len = png_check_keyword(png_ptr, name,
@@ -778,41 +772,20 @@ png_write_iCCP(png_structp png_ptr, png_
       png_warning(png_ptr, "Empty keyword in iCCP chunk");
       return;
    }
 
    if (compression_type != PNG_COMPRESSION_TYPE_BASE)
       png_warning(png_ptr, "Unknown compression type in iCCP chunk");
 
    if (profile == NULL)
       profile_len = 0;
 
-   if (profile_len > 3)
-      embedded_profile_len =
-          ((*( (png_bytep)profile  ))<<24) |
-          ((*( (png_bytep)profile+1))<<16) |
-          ((*( (png_bytep)profile+2))<< 8) |
-          ((*( (png_bytep)profile+3))    );
-
-   if (profile_len < embedded_profile_len)
-     {
-        png_warning(png_ptr,
-          "Embedded profile length too large in iCCP chunk");
-        return;
-     }
-
-   if (profile_len > embedded_profile_len)
-     {
-        png_warning(png_ptr,
-          "Truncating profile to actual length in iCCP chunk");
-        profile_len = embedded_profile_len;
-     }
-
    if (profile_len)
        profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,
           PNG_COMPRESSION_TYPE_BASE, &comp);
 
    /* make sure we include the NULL after the name and the compression type */
    png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
           (png_uint_32)name_len+profile_len+2);
    new_name[name_len+1]=0x00;
    png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2);
 
