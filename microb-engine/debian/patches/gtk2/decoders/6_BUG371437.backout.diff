#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/bmp nsBMPDecoder.cpp,v
#retrieving revision 1.32
#retrieving revision 1.33
diff -u -r1.32 -r1.33
--- mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp	2006/09/05 22:28:50	1.32
+++ mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.cpp	2007/02/27 21:13:23	1.33
@@ -155,32 +155,26 @@
     // First pack the alpha data
     nsresult rv = mFrame->GetAlphaBytesPerRow(&abpr);
     NS_ENSURE_SUCCESS(rv, rv);
-#ifdef MOZ_CAIRO_GFX
+
     gfx_format format;
     mFrame->GetFormat(&format);
     if (format == RLE_GFXFORMAT_ALPHA)
         abpr >>= 2;
-#endif
+
     for (cnt = 0; cnt < abpr; cnt++) {
         PRUint8 byte = 0;
         for (bit = 128; bit; bit >>= 1)
             byte |= *pos++ & bit;
         mAlpha[cnt] = byte;
-#ifdef MOZ_CAIRO_GFX
 #ifdef IS_LITTLE_ENDIAN
         mDecoded[(cnt << 2) + 3] = byte ? 0 : 255;
 #else
         mDecoded[(cnt << 2)] = byte ? 0 : 255;
 #endif
-#endif
     }
 
     for (cnt = 0; cnt < rows; cnt++) {
         line = (mBIH.height < 0) ? (-mBIH.height - mCurLine--) : --mCurLine;
-#ifndef MOZ_CAIRO_GFX
-        rv = mFrame->SetAlphaData(mAlpha, abpr, line * abpr);
-        NS_ENSURE_SUCCESS(rv, rv);
-#endif
         rv = mFrame->SetImageData(mDecoded, mBpr, line * mBpr);
         NS_ENSURE_SUCCESS(rv, rv);
         if (cnt == 0) {
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/bmp nsBMPDecoder.h,v
#retrieving revision 1.25
#retrieving revision 1.26
diff -u -r1.25 -r1.26
--- mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.h	2007/01/25 13:14:24	1.25
+++ mozilla/modules/libpr0n/decoders/bmp/nsBMPDecoder.h	2007/02/27 21:13:24	1.26
@@ -116,20 +116,10 @@
 #define LITTLE_TO_NATIVE32(x) x
 #endif
 
-#if !defined(MOZ_CAIRO_GFX) && (defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON))
-#define BMP_GFXFORMAT gfxIFormats::BGR
-#define RLE_GFXFORMAT_ALPHA gfxIFormats::BGR_A1
-#else
 #define USE_RGB
 #define BMP_GFXFORMAT gfxIFormats::RGB
 #define RLE_GFXFORMAT_ALPHA gfxIFormats::RGB_A1
-#endif
-
-#if defined(MOZ_CAIRO_GFX) || defined(XP_MAC) || defined(XP_MACOSX)
 #define GFXBYTESPERPIXEL 4
-#else
-#define GFXBYTESPERPIXEL 3
-#endif
 
 // BMPINFOHEADER.compression defines
 #define BI_RLE8 1
@@ -232,24 +222,8 @@
  * The variable passed in as aDecoded will be moved on 3 or 4 bytes! */
 inline void SetPixel(PRUint8*& aDecoded, PRUint8 aRed, PRUint8 aGreen, PRUint8 aBlue, PRUint8 aAlpha = 0xFF)
 {
-#if defined(MOZ_CAIRO_GFX)
     *(PRUint32*)aDecoded = (aAlpha << 24) | (aRed << 16) | (aGreen << 8) | aBlue;
     aDecoded += 4;
-#else // MOZ_CAIRO_GFX
-
-#if defined(XP_MAC) || defined(XP_MACOSX)
-    *aDecoded++ = 0; // Mac needs this padding byte
-#endif
-#ifdef USE_RGB
-    *aDecoded++ = aRed;
-    *aDecoded++ = aGreen;
-    *aDecoded++ = aBlue;
-#else
-    *aDecoded++ = aBlue;
-    *aDecoded++ = aGreen;
-    *aDecoded++ = aRed;
-#endif
-#endif // MOZ_CAIRO_GFX
 }
 
 inline void SetPixel(PRUint8*& aDecoded, PRUint8 idx, colorTable* aColors)
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/bmp nsICODecoder.cpp,v
#retrieving revision 1.42
#retrieving revision 1.43
diff -u -r1.42 -r1.43
--- mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.cpp	2007/01/25 13:14:24	1.42
+++ mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.cpp	2007/02/27 21:13:24	1.43
@@ -66,7 +66,6 @@
 // Actual Data Processing
 // ----------------------------------------
 
-#ifdef MOZ_CAIRO_GFX
 static PRUint32 premultiply(PRUint32 x)
 {
     PRUint32 a = x >> 24;
@@ -80,11 +79,9 @@
     x |= t | (a << 24);
     return x;
 }
-#endif
 
 nsresult nsICODecoder::SetImageData()
 {
-#ifdef MOZ_CAIRO_GFX
   if (mHaveAlphaData) {
     // We have premultiply the pixels when we have alpha transparency
     PRUint32* p = (PRUint32*)mDecodedBuffer;
@@ -96,27 +93,6 @@
   // In Cairo we can set the whole image in one go
   PRUint32 dataLen = mDirEntry.mHeight * mDirEntry.mWidth * 4;
   mFrame->SetImageData(mDecodedBuffer, dataLen, 0);
-#else
-  PRUint32 bpr;
-  mFrame->GetImageBytesPerRow(&bpr);
- 
-  // Since the ICO is decoded into an exact sized array, the frame may use
-  // more bytes per row of pixels than the decoding array.
-#if defined(XP_MAC) || defined(XP_MACOSX)
-  PRUint32 decodedLineLen = mDirEntry.mWidth * 4;
-#else
-  PRUint32 decodedLineLen = mDirEntry.mWidth * 3;
-#endif
-
-  PRUint8* decodeBufferPos = mDecodedBuffer;
-  PRUint32 frameOffset = 0;
-
-  for (PRUint32 i = 0;
-       i < mDirEntry.mHeight;
-       ++i, frameOffset += bpr, decodeBufferPos += decodedLineLen) {
-    mFrame->SetImageData(decodeBufferPos, decodedLineLen, frameOffset);
-  }
-#endif
 
   nsIntRect r(0, 0, 0, 0);
   mFrame->GetWidth(&r.width);
@@ -126,44 +102,6 @@
   return NS_OK;
 }
 
-#ifndef MOZ_CAIRO_GFX
-nsresult nsICODecoder::SetAlphaData()
-{
-  // Alpha data was already set if bpp == 32
-  if (mHaveAlphaData)
-    return NS_OK;
-
-  PRUint32 bpr;
-  mFrame->GetAlphaBytesPerRow(&bpr);
-  // In case the decoder and frame have different sized alpha buffers, we
-  // take the smaller of the two row length values as the row length to copy.
-  PRUint32 rowCopyLen = PR_MIN(bpr, mDirEntry.mWidth);
-  PRUint8* alphaRow = (PRUint8*)malloc(rowCopyLen);
-  if (!alphaRow)
-    return NS_ERROR_OUT_OF_MEMORY;
-
-  PRUint32 decoderRowSize = CalcAlphaRowSize();
-  PRUint8* alphaBufferPos = mAlphaBuffer;
-  PRUint32 frameOffset = 0;
-
-  for (PRUint32 i = 0; i < mDirEntry.mHeight; i++) {
-    PRInt8 byte = 0;
-    PRUint32 k = 0;
-    for (PRUint32 j = 0; j < rowCopyLen; ++j) {
-      if ((j % 8) == 0)
-        byte = alphaBufferPos[k++];
-      alphaRow[j] = byte >> 7;
-      byte <<= 1;
-    }
-    mFrame->SetAlphaData(alphaRow, rowCopyLen, frameOffset);
-    frameOffset += bpr;
-    alphaBufferPos += decoderRowSize;
-  }
-  free(alphaRow);
-  return NS_OK;
-}
-#endif
-
 PRUint32 nsICODecoder::CalcAlphaRowSize()
 {
   PRUint32 rowSize = (mDirEntry.mWidth + 7) / 8; // +7 to round up
@@ -182,9 +120,6 @@
   mHaveAlphaData = 0;
   mDecodingAndMask = PR_FALSE;
   mDecodedBuffer = nsnull;
-#ifndef MOZ_CAIRO_GFX
-  mAlphaBuffer = nsnull;
-#endif
 }
 
 nsICODecoder::~nsICODecoder()
@@ -233,9 +168,6 @@
 
   mDecodingAndMask = PR_FALSE;
   free(mDecodedBuffer);
-#ifndef MOZ_CAIRO_GFX
-  free(mAlphaBuffer);
-#endif
 
   return NS_OK;
 }
@@ -245,9 +177,6 @@
   // Set Data here because some ICOs don't have a complete AND Mask
   // see bug 115357
   if (mDecodingAndMask) {
-#ifndef MOZ_CAIRO_GFX
-    SetAlphaData();
-#endif
     SetImageData();
     mObserver->OnStopFrame(nsnull, mFrame);
   }
@@ -440,24 +369,10 @@
     if (mPos == (mImageOffset + BITMAPINFOSIZE + mNumColors*4)) {
       // Increment mPos to avoid reprocessing the info header.
       mPos++;
-#if defined(MOZ_CAIRO_GFX) || defined(XP_MAC) || defined(XP_MACOSX)
       mDecodedBuffer = (PRUint8*)malloc(mDirEntry.mHeight*mDirEntry.mWidth*4);
-#else
-      mDecodedBuffer = (PRUint8*)malloc(mDirEntry.mHeight*mDirEntry.mWidth*3);
-#endif
       if (!mDecodedBuffer)
         return NS_ERROR_OUT_OF_MEMORY;
     }
-#ifndef MOZ_CAIRO_GFX
-    PRUint32 alphaRowSize;
-    mFrame->GetAlphaBytesPerRow(&alphaRowSize);
-    nsAutoArrayPtr<PRUint8> alphaRow; // Will only be used if bpp == 32
-    if (mBIH.bpp == 32) {
-      alphaRow = new PRUint8[alphaRowSize];
-      if (!alphaRow)
-        return NS_ERROR_OUT_OF_MEMORY;
-    }
-#endif
 
     // Ensure memory has been allocated before decoding. If we get this far 
     // without allocated memory, the file is most likely invalid.
@@ -484,9 +399,6 @@
             mCurLine--;
             PRUint8* d = mDecodedBuffer + (mCurLine * mDirEntry.mWidth * GFXBYTESPERPIXEL);
             PRUint8* p = mRow;
-#ifndef MOZ_CAIRO_GFX
-            PRUint8* alphaPos = alphaRow; // only used if bpp == 32
-#endif
             PRUint32 lpos = mDirEntry.mWidth;
             switch (mBIH.bpp) {
               case 1:
@@ -534,13 +446,8 @@
                 break;
               case 32:
                 while (lpos > 0) {
-#ifdef MOZ_CAIRO_GFX
                   SetPixel(d, p[2], p[1], p[0], p[3]);
                   mHaveAlphaData |= p[3]; // Alpha value
-#else
-                  SetPixel(d, p[2], p[1], p[0]);
-                  mHaveAlphaData |= *alphaPos++ = p[3]; // Alpha value
-#endif
                   p += 4;
                   --lpos;
                 }
@@ -554,12 +461,6 @@
               mDecodingAndMask = PR_TRUE;
               
             mRowBytes = 0;
-
-#ifndef MOZ_CAIRO_GFX
-            // If 32 bit image, gotta set the alpha data here
-            if (mBIH.bpp == 32)
-              mFrame->SetAlphaData(alphaRow, alphaRowSize, mCurLine * alphaRowSize);
-#endif
         }
     } while (!mDecodingAndMask && aCount > 0);
 
@@ -576,26 +477,13 @@
       mRow = (PRUint8*)malloc(rowSize);
       if (!mRow)
         return NS_ERROR_OUT_OF_MEMORY;
-#ifndef MOZ_CAIRO_GFX
-      mAlphaBuffer = (PRUint8*)malloc(mDirEntry.mHeight*rowSize);
-      if (!mAlphaBuffer)
-        return NS_ERROR_OUT_OF_MEMORY;
-      memset(mAlphaBuffer, 0xff, mDirEntry.mHeight*rowSize);
-#endif
     }
 
     // Ensure memory has been allocated before decoding.
-#ifdef MOZ_CAIRO_GFX
     NS_ASSERTION(mRow, "mRow is null");
     NS_ASSERTION(mDecodedBuffer, "mDecodedBuffer is null");
     if (!mRow || !mDecodedBuffer)
       return NS_ERROR_FAILURE;
-#else
-    NS_ASSERTION(mRow, "mRow is null");
-    NS_ASSERTION(mAlphaBuffer, "mAlphaBuffer is null");
-    if (!mRow || !mAlphaBuffer)
-      return NS_ERROR_FAILURE;
-#endif
 
     PRUint32 toCopy;
     do {
@@ -615,7 +503,6 @@
         if ((rowSize - mRowBytes) == 0) {
             mCurLine--;
 
-#ifdef MOZ_CAIRO_GFX
             PRUint8* decoded =
               mDecodedBuffer + (mCurLine * mDirEntry.mWidth * GFXBYTESPERPIXEL);
 #ifdef IS_LITTLE_ENDIAN
@@ -632,20 +519,7 @@
                 decoded += GFXBYTESPERPIXEL;
               }
             }
-#else
-            PRUint8* decoded = mAlphaBuffer+(mCurLine*rowSize);
-            PRUint8* p = mRow;
-            PRUint32 lpos = 0;
-            while (lpos < rowSize) {
-              PRUint8 idx = *p;
-              idx ^= 255;  // We complement the value, since our method of storing transparency is opposite
-                           // what Win32 uses in its masks.
-              decoded[lpos] = idx;
-              lpos++;
-              p++;
-            }
-#endif
-            
+
             mRowBytes = 0;
         }
     } while (aCount > 0);
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/bmp nsICODecoder.h,v
#retrieving revision 1.14
#retrieving revision 1.15
diff -u -r1.14 -r1.15
--- mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.h	2007/01/17 10:39:10	1.14
+++ mozilla/modules/libpr0n/decoders/bmp/nsICODecoder.h	2007/02/27 21:13:24	1.15
@@ -97,9 +97,6 @@
   void ProcessInfoHeader();
 
   nsresult SetImageData();
-#ifndef MOZ_CAIRO_GFX
-  nsresult SetAlphaData();
-#endif
 
   PRUint32 CalcAlphaRowSize();
 
@@ -129,9 +126,6 @@
   nsresult mStatus;
 
   PRUint8* mDecodedBuffer;
-#ifndef MOZ_CAIRO_GFX
-  PRUint8* mAlphaBuffer;
-#endif
 
   PRUint8 mHaveAlphaData;
   PRPackedBool mIsCursor;
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/gif imgContainerGIF.cpp,v
#retrieving revision 1.28
#retrieving revision 1.29
diff -u -r1.28 -r1.29
--- mozilla/modules/libpr0n/decoders/gif/imgContainerGIF.cpp	2006/08/11 23:48:48	1.28
+++ mozilla/modules/libpr0n/decoders/gif/imgContainerGIF.cpp	2007/02/27 21:13:24	1.29
@@ -47,10 +47,7 @@
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsMemory.h"
-
-#ifdef MOZ_CAIRO_GFX
 #include "gfxContext.h"
-#endif
 
 NS_IMPL_ISUPPORTS2(imgContainerGIF, imgIContainer, nsITimerCallback)
 
@@ -862,7 +859,6 @@
     return;
   }
 
-#ifdef MOZ_CAIRO_GFX
   PRUint8* alphaData;
   PRUint32 alphaDataLength;
   const PRUint8 setMaskTo = aVisible ? 0xFF : 0x00;
@@ -883,93 +879,6 @@
     }
   }
   aFrame->UnlockImageData();
-
-#else
-  PRUint8* alphaData;
-  PRUint32 alphaDataLength;
-  aFrame->LockAlphaData();
-  nsresult res = aFrame->GetAlphaData(&alphaData, &alphaDataLength);
-  if (!alphaData || !alphaDataLength || NS_FAILED(res)) {
-    aFrame->UnlockAlphaData();
-    return;
-  }
-
-  gfx_format format;
-  aFrame->GetFormat(&format);
-  if (format != gfxIFormats::RGB_A1 && format != gfxIFormats::BGR_A1) {
-    NS_NOTREACHED("GIFs only support 1 bit alpha");
-    aFrame->UnlockAlphaData();
-    return;
-  }
-
-  PRUint32 abpr;
-  aFrame->GetAlphaBytesPerRow(&abpr);
-
-#ifdef MOZ_PLATFORM_IMAGES_BOTTOM_TO_TOP
-  // Account for bottom-up storage.
-  // Start at the bottom (top in memory), go to the top (bottom in memory)
-  PRUint8* alphaLine = alphaData + ((frameHeight - aY - height) * abpr) +
-                       (aX >> 3);
-#else
-  PRUint8* alphaLine = alphaData + (aY * abpr) + (aX >> 3);
-#endif
-  PRUint8 maskShiftStartBy = aX & 0x7;
-  PRUint8 numReplacingStart = 8U - maskShiftStartBy;
-  PRUint32 rowBytes;
-  PRUint8 maskStart = 0; // Init to shutup compiler; Only used if
-                         // maskShiftStartBy != 0
-  PRUint8 maskEnd;
-
-  if (width <= numReplacingStart) {
-    maskEnd = (0xFF >> (8U - width)) << (numReplacingStart - width);
-    // Don't write start bits, only end bits (which contain both start & end)
-    maskShiftStartBy = 0;
-    rowBytes = 0;
-  } else {
-    if (maskShiftStartBy == 0)
-      numReplacingStart = 0;
-    else
-      maskStart = 0xFF >> maskShiftStartBy;
-
-    PRUint8 maskShiftEndBy = (width - numReplacingStart) & 0x7;
-    maskEnd = ~(0xFF >> maskShiftEndBy);
-    rowBytes = (width - numReplacingStart - maskShiftEndBy) >> 3;
-  }
-
-  if (aVisible) {
-    for (PRInt32 i = 0; i < height; i++) {
-      PRUint8 *localAlpha = alphaLine;
-
-      if (maskShiftStartBy != 0)
-        *localAlpha++ |= maskStart;
-
-      if (rowBytes > 0)
-        memset(localAlpha, 0xFF, rowBytes);
-
-      if (maskEnd != 0)
-        localAlpha[rowBytes] |= maskEnd;
-
-      alphaLine += abpr;
-    }
-  } else {
-    for (PRInt32 i = 0; i < height; i++) {
-      PRUint8 *localAlpha = alphaLine;
-
-      if (maskShiftStartBy != 0)
-        *localAlpha++ &= ~maskStart;
-
-      if (rowBytes > 0)
-        memset(localAlpha, 0x00, rowBytes);
-
-      if (maskEnd != 0)
-        localAlpha[rowBytes] &= ~maskEnd;
-
-      alphaLine += abpr;
-    } // for
-  } // if aVisible
-
-  aFrame->UnlockAlphaData();
-#endif
 }
 
 //******************************************************************************
@@ -982,7 +891,6 @@
   PRUint32 alphaDataLength;
   const PRUint8 setMaskTo = aVisible ? 0xFF : 0x00;
 
-#ifdef MOZ_CAIRO_GFX
   aFrame->LockImageData();
   nsresult res = aFrame->GetImageData(&alphaData, &alphaDataLength);
   if (NS_SUCCEEDED(res)) {
@@ -995,15 +903,6 @@
     }
   }
   aFrame->UnlockImageData();
-
-#else  
-
-  aFrame->LockAlphaData();
-  nsresult res = aFrame->GetAlphaData(&alphaData, &alphaDataLength);
-  if (NS_SUCCEEDED(res) && alphaData && alphaDataLength)
-    memset(alphaData, setMaskTo, alphaDataLength);
-  aFrame->UnlockAlphaData();
-#endif
 }
 
 //******************************************************************************
@@ -1012,20 +911,13 @@
 {
   if (!aFrame)
     return;
-#ifdef MOZ_CAIRO_GFX
+
   PRInt32 widthFrame;
   PRInt32 heightFrame;
   aFrame->GetWidth(&widthFrame);
   aFrame->GetHeight(&heightFrame);
 
   BlackenFrame(aFrame, 0, 0, widthFrame, heightFrame);
-
-#else
-  PRUint32 aDataLength;
-
-  aFrame->GetImageDataLength(&aDataLength);
-  aFrame->SetImageData(nsnull, aDataLength, 0);
-#endif
 }
 
 //******************************************************************************
@@ -1036,7 +928,6 @@
   if (!aFrame)
     return;
 
-#ifdef MOZ_CAIRO_GFX
   nsCOMPtr<nsIImage> img(do_GetInterface(aFrame));
   if (!img)
     return;
@@ -1051,36 +942,6 @@
 
   nsIntRect r(aX, aY, aWidth, aHeight);
   img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
-
-#else // MOZ_CAIRO_GFX
-
-  PRInt32 widthFrame;
-  PRInt32 heightFrame;
-  aFrame->GetWidth(&widthFrame);
-  aFrame->GetHeight(&heightFrame);
-
-  const PRInt32 width  = PR_MIN(aWidth, (widthFrame - aX));
-  const PRInt32 height = PR_MIN(aHeight, (heightFrame - aY));
-
-  if (width <= 0 || height <= 0) {
-    return;
-  }
-
-  PRUint32 bpr; // Bytes Per Row
-  aFrame->GetImageBytesPerRow(&bpr);
-
-#if defined(XP_MAC) || defined(XP_MACOSX)
-  const PRUint8 bpp = 4;
-#else
-  const PRUint8 bpp = 3;
-#endif
-  const PRUint32 bprToWrite = width * bpp;
-  const PRUint32 xOffset = aX * bpp; // offset into row to start writing
-
-  for (PRInt32 y = 0; y < height; y++) {
-    aFrame->SetImageData(nsnull, bprToWrite, ((y + aY) * bpr) + xOffset);
-  }
-#endif // MOZ_CAIRO_GFX
 }
 
 
@@ -1111,21 +972,6 @@
   memcpy(aDataDest, aDataSrc, aDataLengthSrc);
   aDstFrame->UnlockImageData();
 
-#ifndef MOZ_CAIRO_GFX
-  // Copy Alpha/Mask Over
-  // If no mask, lockAlpha will tell us
-  if (NS_SUCCEEDED(aDstFrame->LockAlphaData())) {
-    aSrcFrame->GetAlphaData(&aDataSrc, &aDataLengthSrc);
-    aDstFrame->GetAlphaData(&aDataDest, &aDataLengthDest);
-    if (aDataDest && aDataSrc && aDataLengthDest == aDataLengthSrc)
-      memcpy(aDataDest, aDataSrc, aDataLengthSrc);
-    else
-      memset(aDataDest, 0xFF, aDataLengthDest);
-
-    aDstFrame->UnlockAlphaData();
-  }
-#endif
-
   // Tell the image that it's data has been updated
   nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(aDstFrame));
   if (!ireq)
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/gif nsGIFDecoder2.cpp,v
#retrieving revision 1.71
#retrieving revision 1.72
diff -u -r1.71 -r1.72
--- mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp	2006/04/01 00:35:58	1.71
+++ mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp	2007/02/27 21:13:24	1.72
@@ -492,22 +492,11 @@
 
     if (!cmap) { // cmap could have null value if the global color table flag is 0
       for (int i = 0; i < aDuplicateCount; ++i) {
-#ifdef MOZ_CAIRO_GFX
         imgContainerGIF::BlackenFrame(decoder->mImageFrame, 0, aRowNumber+i, width, 1);
-#else
-        if (format == gfxIFormats::RGB_A1 ||
-            format == gfxIFormats::BGR_A1) {
-          decoder->mImageFrame->SetAlphaData(nsnull,
-                                             abpr, (aRowNumber+i)*abpr);
-        }
-        decoder->mImageFrame->SetImageData(nsnull,
-                                           bpr, (aRowNumber+i)*bpr);
-#endif
       }
     } else {
       PRUint8* rowBufIndex = aRowBufPtr;
 
-#if defined(MOZ_CAIRO_GFX)
       PRUint32 *rgbRowIndex = (PRUint32*)decoder->mRGBLine;
       while (rowBufIndex != decoder->mGIFStruct->rowend) {
         if (*rowBufIndex >= cmapsize ||
@@ -527,86 +516,6 @@
       }
       for (int i=0; i<aDuplicateCount; i++)
         decoder->mImageFrame->SetImageData(decoder->mRGBLine, bpr, (aRowNumber+i)*bpr);
-#else
-      PRUint8* rgbRowIndex = decoder->mRGBLine;
-      switch (format) {
-        case gfxIFormats::RGB:
-        case gfxIFormats::BGR:
-        {
-          while (rowBufIndex != decoder->mGIFStruct->rowend) {
-#if defined(XP_MAC) || defined(XP_MACOSX)
-            *rgbRowIndex++ = 0; // Mac is always 32bits per pixel, this is pad
-#endif
-            if (*rowBufIndex < cmapsize) {
-              PRUint32 colorIndex = *rowBufIndex * 3;
-#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON)
-              *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
-              *rgbRowIndex++ = cmap[colorIndex + 1]; // green
-              *rgbRowIndex++ = cmap[colorIndex];     // red
-#else
-              *rgbRowIndex++ = cmap[colorIndex];     // red
-              *rgbRowIndex++ = cmap[colorIndex + 1]; // green
-              *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
-#endif
-            } else {
-              *rgbRowIndex++ = 0;                    // red
-              *rgbRowIndex++ = 0;                    // green
-              *rgbRowIndex++ = 0;                    // blue
-            }
-            ++rowBufIndex;
-          }  
-          for (int i=0; i<aDuplicateCount; i++) {
-            decoder->mImageFrame->SetImageData(decoder->mRGBLine,
-                                               bpr, (aRowNumber+i)*bpr);
-          }
-          break;
-        }
-        case gfxIFormats::RGB_A1:
-        case gfxIFormats::BGR_A1:
-        {
-          memset(decoder->mRGBLine, 0, bpr);
-          memset(decoder->mAlphaLine, 0, abpr);
-          for (PRUint32 x = 0; x < (PRUint32)width; ++x) {
-            if (*rowBufIndex != decoder->mGIFStruct->tpixel) {
-#if defined(XP_MAC) || defined(XP_MACOSX)
-              *rgbRowIndex++ = 0; // Mac is always 32bits per pixel, this is pad
-#endif
-              if (*rowBufIndex < cmapsize) {
-                PRUint32 colorIndex = *rowBufIndex * 3;
-#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON)
-                *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
-                *rgbRowIndex++ = cmap[colorIndex + 1]; // green
-                *rgbRowIndex++ = cmap[colorIndex];     // red
-#else
-                *rgbRowIndex++ = cmap[colorIndex];     // red
-                *rgbRowIndex++ = cmap[colorIndex + 1]; // green
-                *rgbRowIndex++ = cmap[colorIndex + 2]; // blue
-#endif
-              } else {
-                *rgbRowIndex++ = 0;                    // red
-                *rgbRowIndex++ = 0;                    // green
-                *rgbRowIndex++ = 0;                    // blue
-              }
-              decoder->mAlphaLine[x>>3] |= 1<<(7-x&0x7);
-            } else {
-#if defined(XP_MAC) || defined(XP_MACOSX)
-              rgbRowIndex+=4;
-#else
-              rgbRowIndex+=3;
-#endif
-            }
-            ++rowBufIndex;
-          }
-          for (int i=0; i<aDuplicateCount; i++) {
-            decoder->mImageFrame->SetAlphaData(decoder->mAlphaLine,
-                                               abpr, (aRowNumber+i)*abpr);
-            decoder->mImageFrame->SetImageData(decoder->mRGBLine,
-                                               bpr, (aRowNumber+i)*bpr);
-          }
-          break;
-        }
-      }
-#endif // else !MOZ_CAIRO_GFX
     }
 
     decoder->mCurrentRow = aRowNumber + aDuplicateCount - 1;
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon nsIconDecoder.cpp,v
#retrieving revision 1.26
#retrieving revision 1.27
diff -u -r1.26 -r1.27
--- mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.cpp	2007/02/06 01:59:19	1.26
+++ mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.cpp	2007/02/27 21:13:24	1.27
@@ -107,11 +107,7 @@
   PRUint32 readLen;
   rv = inStr->Read((char*)buf, count, &readLen);
   NS_ENSURE_SUCCESS(rv, rv);
-#ifdef MOZ_CAIRO_GFX
   NS_ENSURE_TRUE(readLen >= 2, NS_ERROR_UNEXPECTED); // w, h
-#else
-  NS_ENSURE_TRUE(readLen >= 3, NS_ERROR_UNEXPECTED); // w, h, alphaBits
-#endif
 
   PRUint8 * const buf_end = buf + readLen;
   PRUint8 *data = buf;
@@ -122,24 +118,13 @@
   // Read size
   PRInt32 w = *(data++);
   PRInt32 h = *(data++);
-#ifdef MOZ_CAIRO_GFX
   NS_ENSURE_TRUE(w > 0 && h > 0, NS_ERROR_UNEXPECTED);
-#else
-  PRUint8 alphaBits = *(data++);
-  NS_ENSURE_TRUE(w > 0 && h > 0 && (alphaBits == 1 || alphaBits == 8),
-                 NS_ERROR_UNEXPECTED);
-#endif
 
   mImage->Init(w, h, mObserver);
   if (mObserver)
     mObserver->OnStartContainer(nsnull, mImage);
 
-#ifdef MOZ_CAIRO_GFX
   gfx_format format = gfxIFormats::BGRA; // XXX not really
-#else
-  gfx_format format = alphaBits == 1 ? gfx_format(gfxIFormats::RGB_A1)
-                                     : gfx_format(gfxIFormats::RGB_A8);
-#endif
   rv = mFrame->Init(0, 0, w, h, format, 24);
   if (NS_FAILED(rv))
     return rv;
@@ -156,22 +141,12 @@
   mFrame->GetHeight(&height);
 
   PRInt32 rownum;
-#if defined(MOZ_CAIRO_GFX)
   NS_ENSURE_TRUE(buf_end - data >= PRInt32(bpr) * height,
                  NS_ERROR_UNEXPECTED);
-  
-  for (rownum = 0; rownum < height; ++rownum, data += bpr)
-    mFrame->SetImageData(data, bpr, rownum * bpr);
-#else
-  NS_ENSURE_TRUE(buf_end - data >= PRInt32(bpr + abpr) * height,
-                 NS_ERROR_UNEXPECTED);
-  
+
   for (rownum = 0; rownum < height; ++rownum, data += bpr)
     mFrame->SetImageData(data, bpr, rownum * bpr);
 
-  for (rownum = 0; rownum < height; ++rownum, data += abpr)
-    mFrame->SetAlphaData(data, abpr, rownum * abpr);   
-#endif
   nsIntRect r(0, 0, width, height);
   mObserver->OnDataAvailable(nsnull, mFrame, &r);
 
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon nsIconDecoder.h,v
#retrieving revision 1.6
#retrieving revision 1.7
diff -u -r1.6 -r1.7
--- mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.h	2007/01/08 23:58:11	1.6
+++ mozilla/modules/libpr0n/decoders/icon/nsIconDecoder.h	2007/02/27 21:13:24	1.7
@@ -68,23 +68,10 @@
 //     support multiple ODA calls yet.
 // (2) the format of the incoming data is as follows:
 //     The first two bytes contain the width and the height of the icon. 
-#ifdef MOZ_CAIRO_GFX
 //     The remaining bytes contain the icon data, 4 bytes per pixel, in
 //       ARGB order (platform endianness, A in highest bits, B in lowest
 //       bits), row-primary, top-to-bottom, left-to-right, with
 //       premultiplied alpha.
-#else
-//     The third byte contains the number of bits per pixel in the alpha
-//       channel (either 1 or 8).
-//     Followed by 3 bytes per pixel for the color bitmap row after row,
-//       from top to bottom, with pixels left to right within rows, and
-//       RGB order within pixels, in platform endianness.  Alpha is
-//       *not* premultiplied.
-//       XXXldb This isn't quite right -- we're just using
-//       platform-native format.
-//     Followed by alpha data (1 or 8 bits per pixel, see above) in the
-//       same order as the RGB data, and also in platform endianness.
-#endif
 //
 //
 //////////////////////////////////////////////////////////////////////////////////////////////
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/beos nsIconChannel.cpp,v
#retrieving revision 1.4
#retrieving revision 1.5
diff -u -r1.4 -r1.5
--- mozilla/modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp	2007/01/08 23:58:11	1.4
+++ mozilla/modules/libpr0n/decoders/icon/beos/nsIconChannel.cpp	2007/02/27 21:13:24	1.5
@@ -314,11 +314,7 @@
     return NS_ERROR_NOT_AVAILABLE;
 
   // Got a bitmap and color space info - convert data to mozilla's icon format
-#ifdef MOZ_CAIRO_GFX
   PRUint32 iconLength = 2 + iconSize * iconSize * 4;
-#else
-  PRUint32 iconLength = 3 + iconSize * (iconSize * 3 + alphaBytesPerRow);
-#endif
   uint8 *buffer = new uint8[iconLength];
   if (!buffer)
     return NS_ERROR_OUT_OF_MEMORY;
@@ -326,9 +322,6 @@
   uint8* destByte = buffer;
   *(destByte++) = iconSize;
   *(destByte++) = iconSize;
-#ifndef MOZ_CAIRO_GFX
-  *(destByte++) = 1; // alpha bits per pixel
-#endif
 
   // RGB data
   uint8* sourceByte = (uint8*)nativeIcon.Bits();
@@ -340,7 +333,6 @@
       if (*sourceByte != B_TRANSPARENT_MAGIC_CMAP8)
       {
         rgb_color colorVal = mainScreen.ColorForIndex(*sourceByte);
-#ifdef MOZ_CAIRO_GFX
 #ifdef IS_LITTLE_ENDIAN
         *(destByte++) = colorVal.blue;
         *(destByte++) = colorVal.green;
@@ -352,20 +344,13 @@
         *(destByte++) = colorVal.green;
         *(destByte++) = colorVal.blue;
 #endif
-#else
-        *(destByte++) = colorVal.blue;
-        *(destByte++) = colorVal.green;
-        *(destByte++) = colorVal.red;
-#endif
       }
       else
       {
         *destByte++ = 0;
         *destByte++ = 0;
         *destByte++ = 0;
-#ifdef MOZ_CAIRO_GFX
         *destByte++ = 0;
-#endif
       }
       // original code had a conditional here:
       // if (iconCol < iconSize - 1) 
@@ -373,30 +358,6 @@
       sourceByte++;
     }
   }
-#ifndef MOZ_CAIRO_GFX
-  // Alpha data - bitmask, with rows aligned on 32-bit boundaries
-  for(PRUint32 iconRow = 0; iconRow < iconSize; iconRow++)
-  {
-    destByte = buffer + 3 + iconSize * iconSize * 3 + iconRow * alphaBytesPerRow;
-    sourceByte = (uint8*)nativeIcon.Bits() + nativeIcon.BytesPerRow() * iconRow;
-    int bitNo = 0;
-    for(PRUint32 iconCol = 0; iconCol < iconSize; iconCol++)
-    {
-      if (*sourceByte == B_TRANSPARENT_MAGIC_CMAP8)
-        (*destByte) &= (~(128 >> (bitNo % 8)));
-      else
-        (*destByte) |= (128 >> (bitNo % 8));
-      
-      //original code had a conditional here:
-      //if (iconCol < iconSize - 1) 
-      //Leaving this comment in case complications arise later
-      bitNo++;
-      sourceByte++;
-      if ((bitNo%8) == 0)
-        destByte++;
-    }
-  }
-#endif
 
   NS_ASSERTION(buffer + iconLength == destByte, "size miscalculation");
   
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/jpeg nsJPEGDecoder.cpp,v
#retrieving revision 1.69
#retrieving revision 1.70
diff -u -r1.69 -r1.70
--- mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp	2007/01/31 14:53:21	1.69
+++ mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.cpp	2007/02/27 21:13:25	1.70
@@ -77,9 +77,6 @@
   mReading = PR_TRUE;
 
   mSamples = nsnull;
-#ifndef MOZ_CAIRO_GFX
-  mRGBRow = nsnull;
-#endif
 
   mBytesToSkip = 0;
   memset(&mInfo, 0, sizeof(jpeg_decompress_struct));
@@ -97,9 +94,6 @@
 {
   PR_FREEIF(mBuffer);
   PR_FREEIF(mBackBuffer);
-#ifndef MOZ_CAIRO_GFX
-  PR_FREEIF(mRGBRow);
-#endif
 }
 
 
@@ -325,18 +319,6 @@
                                           JPOOL_IMAGE,
                                           mInfo.output_width * 3, 1);
 
-#ifndef MOZ_CAIRO_GFX
-#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(XP_MAC) || defined(XP_MACOSX) || defined(MOZ_WIDGET_PHOTON)
-#if defined(XP_MAC) || defined(XP_MACOSX)
-    const int row_stride = mInfo.output_width * 4;
-#else
-    const int row_stride = mInfo.output_width * 3;
-#endif
-    // allocate buffer to do byte flipping / padding
-    mRGBRow = (PRUint8*) PR_MALLOC(row_stride);
-#endif
-#endif
-
     mState = JPEG_START_DECOMPRESS;
   }
 
@@ -475,34 +457,19 @@
   const PRUint32 top = mInfo.output_scanline;
   PRBool rv = PR_TRUE;
 
-#if defined(MOZ_CAIRO_GFX)
   // we're thebes. we can write stuff directly to the data
   PRUint8 *imageData;
   PRUint32 imageDataLength;
   mFrame->GetImageData(&imageData, &imageDataLength);
   nsCOMPtr<nsIImage> img(do_GetInterface(mFrame));
-#else
-  // Note! row_stride here must match the row_stride in
-  // nsJPEGDecoder::WriteFrom
-#if defined(XP_MAC) || defined(XP_MACOSX)
-  const int row_stride = mInfo.output_width * 4;
-#else
-  const int row_stride = mInfo.output_width * 3;
-#endif
-  PRUint32 bpr;
-  mFrame->GetImageBytesPerRow(&bpr);
-  JSAMPROW samples;
-#endif
 
   while ((mInfo.output_scanline < mInfo.output_height)) {
-
       /* Request one scanline.  Returns 0 or 1 scanlines. */    
       if (jpeg_read_scanlines(&mInfo, mSamples, 1) != 1) {
         rv = PR_FALSE; /* suspend */
         break;
       }
 
-#if defined(MOZ_CAIRO_GFX)
       // offset is in Cairo pixels (PRUint32)
       PRUint32 offset = (mInfo.output_scanline - 1) * mInfo.output_width;
       PRUint32 *ptrOutputBuf = ((PRUint32*)imageData) + offset;
@@ -513,49 +480,11 @@
         PRUint8 b = *j1++;
         *ptrOutputBuf++ = (0xFF << 24) | (r << 16) | (g << 8) | b;
       }
-#else
-
-#if defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON)
-      PRUint8 *ptrOutputBuf = mRGBRow;
-
-      JSAMPLE *j1 = mSamples[0];
-      for (PRUint32 i=0;i<mInfo.output_width;++i) {
-        ptrOutputBuf[2] = *j1++;
-        ptrOutputBuf[1] = *j1++;
-        ptrOutputBuf[0] = *j1++;
-        ptrOutputBuf += 3;
-      }
-
-      samples = mRGBRow;
-#elif defined(XP_MAC) || defined(XP_MACOSX)
-      PRUint8 *ptrOutputBuf = mRGBRow;
-
-      JSAMPLE *j1 = mSamples[0];
-      for (PRUint32 i=0;i<mInfo.output_width;++i) {
-        ptrOutputBuf[0] = 0;
-        ptrOutputBuf[1] = *j1++;
-        ptrOutputBuf[2] = *j1++;
-        ptrOutputBuf[3] = *j1++;
-        ptrOutputBuf += 4;
-      }
-
-      samples = mRGBRow;
-#else
-      samples = mSamples[0];
-#endif
-
-      mFrame->SetImageData(
-        samples,             // data
-        row_stride,          // length
-        (mInfo.output_scanline-1) * bpr); // offset
-#endif
   }
 
   if (top != mInfo.output_scanline) {
       nsIntRect r(0, top, mInfo.output_width, mInfo.output_scanline-top);
-#if defined(MOZ_CAIRO_GFX)
       img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
-#endif
       mObserver->OnDataAvailable(nsnull, mFrame, &r);
   }
 
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/jpeg nsJPEGDecoder.h,v
#retrieving revision 1.24
#retrieving revision 1.25
diff -u -r1.24 -r1.25
--- mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h	2007/01/31 14:53:21	1.24
+++ mozilla/modules/libpr0n/decoders/jpeg/nsJPEGDecoder.h	2007/02/27 21:13:25	1.25
@@ -106,9 +106,6 @@
   jstate mState;
 
   JSAMPARRAY mSamples;
-#ifndef MOZ_CAIRO_GFX
-  PRUint8*   mRGBRow;
-#endif
 
   PRUint32 mBytesToSkip;
 
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/xbm nsXBMDecoder.cpp,v
#retrieving revision 1.19
#retrieving revision 1.20
diff -u -r1.19 -r1.20
--- mozilla/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp	2006/08/24 09:31:46	1.19
+++ mozilla/modules/libpr0n/decoders/xbm/nsXBMDecoder.cpp	2007/02/27 21:13:25	1.20
@@ -256,31 +256,17 @@
                 hiByte = !hiByte;
             }
 
-#ifdef MOZ_CAIRO_GFX
             PRUint32 *ar = ((PRUint32*)mAlphaRow) + mCurCol;
             const int alphas = PR_MIN(8, mWidth - mCurCol);
             for (int i = 0; i < alphas; i++) {
                 const PRUint8 val = ((pixel & (1 << i)) >> i) ? 255 : 0;
                 *ar++ = (val << 24) | 0;
             }
-#else // MOZ_CAIRO_GFX
-            mAlphaRow[mCurCol/8] = 0;
-            for (int i = 0; i < 8; i++) {
-                PRUint8 val = (pixel & (1 << i)) >> i;
-                mAlphaRow[mCurCol/8] |= val << (7 - i);
-            }
-#endif
+
             mCurCol = PR_MIN(mCurCol + 8, mWidth);
             if (mCurCol == mWidth || mState == RECV_DONE) {
-#ifdef MOZ_CAIRO_GFX
                 mFrame->SetImageData(mAlphaRow, abpr, mCurRow * abpr);
-#else
-                // Row finished. Set Data.
-                mFrame->SetAlphaData(mAlphaRow, abpr, mCurRow * abpr);
-                // nsnull gets interpreted as all-zeroes, which is what we
-                // want
-                mFrame->SetImageData(nsnull, bpr, mCurRow * bpr);
-#endif
+
                 nsIntRect r(0, mCurRow, mWidth, 1);
                 mObserver->OnDataAvailable(nsnull, mFrame, &r);
 
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/png nsPNGDecoder.cpp,v
#retrieving revision 1.56
#retrieving revision 1.57
diff -u -r1.56 -r1.57
--- mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	2007/01/31 21:09:20	1.56
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp	2007/02/27 21:13:25	1.57
@@ -49,9 +49,7 @@
 #include "nsIImage.h"
 #include "nsIInterfaceRequestorUtils.h"
 
-#ifdef MOZ_CAIRO_GFX
 #include "gfxColor.h"
-#endif
 #include "nsColor.h"
 
 #include "nspr.h"
@@ -72,10 +70,6 @@
 
 nsPNGDecoder::nsPNGDecoder() :
   mPNG(nsnull), mInfo(nsnull),
-#ifndef MOZ_CAIRO_GFX
-  colorLine(nsnull),
-  alphaLine(nsnull),
-#endif
   interlacebuf(nsnull), ibpr(0),
   mError(PR_FALSE)
 {
@@ -83,12 +77,6 @@
 
 nsPNGDecoder::~nsPNGDecoder()
 {
-#ifndef MOZ_CAIRO_GFX
-  if (colorLine)
-    nsMemory::Free(colorLine);
-  if (alphaLine)
-    nsMemory::Free(alphaLine);
-#endif
   if (interlacebuf)
     nsMemory::Free(interlacebuf);
 }
@@ -259,12 +247,6 @@
       color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
       png_set_gray_to_rgb(png_ptr);
 
-
-#if !defined(MOZ_CAIRO_GFX) && (defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON))
-  // windows likes BGR
-  png_set_bgr(png_ptr);
-#endif
-
   if (png_get_gAMA(png_ptr, info_ptr, &aGamma)) {
       if ((aGamma <= 0.0) || (aGamma > 21474.83)) {
           aGamma = 0.45455;
@@ -343,11 +325,6 @@
     }
   }
 
-#if !defined(MOZ_CAIRO_GFX) && (defined(XP_WIN) || defined(XP_OS2) || defined(XP_BEOS) || defined(MOZ_WIDGET_PHOTON))
-  // XXX this works...
-  format += 1; // RGB to BGR
-#endif
-
   // then initialize the frame and append it to the container
   nsresult rv = decoder->mFrame->Init(0, 0, width, height, format, 24);
   if (NS_FAILED(rv))
@@ -360,13 +337,7 @@
 
   PRUint32 bpr;
   decoder->mFrame->GetImageBytesPerRow(&bpr);
-#ifndef MOZ_CAIRO_GFX
-  PRUint32 abpr;
-  decoder->mFrame->GetAlphaBytesPerRow(&abpr);
-  decoder->colorLine = (PRUint8 *)nsMemory::Alloc(bpr);
-  if (channels > 3)
-    decoder->alphaLine = (PRUint8 *)nsMemory::Alloc(abpr);
-#endif
+
   if (interlace_type == PNG_INTERLACE_ADAM7) {
     if (channels > 3)
       decoder->ibpr = channels*width;
@@ -429,113 +400,46 @@
 
     gfx_format format;
     decoder->mFrame->GetFormat(&format);
-#if defined(MOZ_CAIRO_GFX)
+
     // we're thebes. we can write stuff directly to the data
     PRUint8 *imageData;
     PRUint32 imageDataLength, bpr = width * sizeof(PRUint32);
     decoder->mFrame->GetImageData(&imageData, &imageDataLength);
     PRUint32 *cptr32 = (PRUint32*)(imageData + (row_num*bpr));
-#else
-    PRUint8 *aptr, *cptr;
-    PRUint32 bpr, abpr;
-    decoder->mFrame->GetImageBytesPerRow(&bpr);
-    decoder->mFrame->GetAlphaBytesPerRow(&abpr);
-    // The mac specific ifdefs in the code below are there to make sure we
-    // always fill in 4 byte pixels right now, which is what the mac always
-    // allocates for its pixel buffers in true color mode. This will change
-    // when we start storing images with color palettes when they don't need
-    // true color support (GIFs).
-#endif
 
     switch (format) {
     case gfxIFormats::RGB:
     case gfxIFormats::BGR:
       {
-#if defined(MOZ_CAIRO_GFX)
         for (PRUint32 x=iwidth; x>0; --x) {
           *cptr32++ = GFX_PACKED_PIXEL(0xFF, line[0], line[1], line[2]);
           line += 3;
         }
-#elif defined(XP_MAC) || defined(XP_MACOSX)
-        cptr = decoder->colorLine;
-        for (PRUint32 x=0; x<iwidth; x++) {
-          *cptr++ = 0;
-          *cptr++ = *line++;
-          *cptr++ = *line++;
-          *cptr++ = *line++;
-        }
-        decoder->mFrame->SetImageData(decoder->colorLine, bpr, row_num*bpr);
-#else
-        decoder->mFrame->SetImageData((PRUint8*)line, bpr, row_num*bpr);
-#endif
       }
       break;
     case gfxIFormats::RGB_A1:
     case gfxIFormats::BGR_A1:
       {
-#if defined(MOZ_CAIRO_GFX)
         for (PRUint32 x=iwidth; x>0; --x) {
           *cptr32++ = GFX_PACKED_PIXEL(line[3]?0xFF:0x00, line[0], line[1], line[2]);
           line += 4;
         }
-#else
-        cptr = decoder->colorLine;
-        aptr = decoder->alphaLine;
-        memset(aptr, 0, abpr);
-        for (PRUint32 x=0; x<iwidth; x++) {
-#if defined(XP_MAC) || defined(XP_MACOSX)
-          *cptr++ = 0;
-#endif
-          if (line[3]) {
-            *cptr++ = *line++;
-            *cptr++ = *line++;
-            *cptr++ = *line++;
-            aptr[x>>3] |= 1<<(7-x&0x7);
-            line++;
-          } else {
-            *cptr++ = 0;
-            *cptr++ = 0;
-            *cptr++ = 0;
-            line += 4;
-          }
-        }
-        decoder->mFrame->SetAlphaData(decoder->alphaLine, abpr, row_num*abpr);
-        decoder->mFrame->SetImageData(decoder->colorLine, bpr, row_num*bpr);
-#endif
       }
       break;
     case gfxIFormats::RGB_A8:
     case gfxIFormats::BGR_A8:
       {
-#if defined(MOZ_CAIRO_GFX)
         for (PRUint32 x=width; x>0; --x) {
           *cptr32++ = GFX_PACKED_PIXEL(line[3], line[0], line[1], line[2]);
           line += 4;
         }
-#else
-        cptr = decoder->colorLine;
-        aptr = decoder->alphaLine;
-        for (PRUint32 x=0; x<iwidth; x++) {
-#if defined(XP_MAC) || defined(XP_MACOSX)
-          *cptr++ = 0;
-#endif
-          *cptr++ = *line++;
-          *cptr++ = *line++;
-          *cptr++ = *line++;
-          *aptr++ = *line++;
-        }
-        decoder->mFrame->SetAlphaData(decoder->alphaLine, abpr, row_num*abpr);
-        decoder->mFrame->SetImageData(decoder->colorLine, bpr, row_num*bpr);
-#endif
       }
       break;
     }
 
     nsIntRect r(0, row_num, width, 1);
-#if defined(MOZ_CAIRO_GFX)
     nsCOMPtr<nsIImage> img(do_GetInterface(decoder->mFrame));
     img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
-#endif
     decoder->mObserver->OnDataAvailable(nsnull, decoder->mFrame, &r);
   }
 }
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/png nsPNGDecoder.h,v
#retrieving revision 1.16
#retrieving revision 1.17
diff -u -r1.16 -r1.17
--- mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h	2006/03/27 19:04:51	1.16
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h	2007/02/27 21:13:25	1.17
@@ -77,9 +77,6 @@
 
   png_structp mPNG;
   png_infop mInfo;
-#ifndef MOZ_CAIRO_GFX
-  PRUint8 *colorLine, *alphaLine;
-#endif
   PRUint8 *interlacebuf;
   PRUint32 ibpr;
   PRPackedBool mError;
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/gtk nsIconChannel.cpp,v
#retrieving revision 1.12
#retrieving revision 1.13
diff -u -r1.12 -r1.13
--- mozilla/modules/libpr0n/decoders/icon/gtk/nsIconChannel.cpp	2007/01/08 23:58:11	1.12
+++ mozilla/modules/libpr0n/decoders/icon/gtk/nsIconChannel.cpp	2007/02/27 21:13:24	1.13
@@ -83,35 +83,21 @@
                  NS_ERROR_UNEXPECTED);
 
   const int n_channels = 4;
-#ifdef MOZ_CAIRO_GFX
   gsize buf_size = 2 + n_channels * height * width;
-#else
-  gsize buf_size = 3 + n_channels * height * width;
-#endif
   PRUint8 * const buf = (PRUint8*)NS_Alloc(buf_size);
   NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
   PRUint8 *out = buf;
 
   *(out++) = width;
   *(out++) = height;
-#ifndef MOZ_CAIRO_GFX
-  *(out++) = 8; // bits of alpha per pixel
-#endif
-  
+
   const guchar * const pixels = gdk_pixbuf_get_pixels(aPixbuf);
   int rowextra = gdk_pixbuf_get_rowstride(aPixbuf) - width * n_channels;
 
   // encode the RGB data and the A data
   const guchar * in = pixels;
-#ifndef MOZ_CAIRO_GFX
-  PRUint8 *alpha_out = out + height * width * 3;
-#ifdef DEBUG
-  PRUint8 * const alpha_start = alpha_out;
-#endif
-#endif
   for (int y = 0; y < height; ++y, in += rowextra) {
     for (int x = 0; x < width; ++x) {
-#ifdef MOZ_CAIRO_GFX
       PRUint8 r = *(in++);
       PRUint8 g = *(in++);
       PRUint8 b = *(in++);
@@ -129,21 +115,10 @@
       *(out++) = DO_PREMULTIPLY(b);
 #endif
 #undef DO_PREMULTIPLY
-#else
-      *(out++) = *(in++); // R
-      *(out++) = *(in++); // G
-      *(out++) = *(in++); // B
-      *(alpha_out++) = *(in++); // A
-#endif
     }
   }
 
-#ifdef MOZ_CAIRO_GFX
   NS_ASSERTION(out == buf + buf_size, "size miscalculation");
-#else
-  NS_ASSERTION(out == alpha_start && alpha_out == buf + buf_size,
-               "size miscalculation");
-#endif
 
   nsresult rv;
   nsCOMPtr<nsIStringInputStream> stream =
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libpr0n/decoders/icon/mac nsIconChannelCocoa.mm,v
#retrieving revision 1.2
#retrieving revision 1.3
diff -u -r1.2 -r1.3
--- mozilla/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm	2007/01/08 23:58:12	1.2
+++ mozilla/modules/libpr0n/decoders/icon/mac/nsIconChannelCocoa.mm	2007/02/27 21:13:25	1.3
@@ -312,11 +312,7 @@
   PRUint8* bitmapRepData = (PRUint8*)[bitmapRep bitmapData];
   
   // create our buffer
-#ifdef MOZ_CAIRO_GFX
   PRInt32 bufferCapacity = 2 + desiredImageSize * desiredImageSize * 4;
-#else
-  PRInt32 bufferCapacity = 3 + desiredImageSize * desiredImageSize * 5;
-#endif
   nsAutoBuffer<PRUint8, 3 + 16 * 16 * 5> iconBuffer; // initial size is for 16x16
   if (!iconBuffer.EnsureElemCapacity(bufferCapacity))
     return NS_ERROR_OUT_OF_MEMORY;
@@ -326,10 +322,7 @@
   // write header data into buffer
   *iconBufferPtr++ = desiredImageSize;
   *iconBufferPtr++ = desiredImageSize;
-#ifndef MOZ_CAIRO_GFX
-  *iconBufferPtr++ = 8; // alpha bits per pixel
-#endif
-  
+
   PRUint32 dataCount = (desiredImageSize * desiredImageSize) * 4;
   PRUint32 index = 0;
   while (index < dataCount) {
@@ -338,23 +331,11 @@
     PRUint8 g = bitmapRepData[index++];
     PRUint8 b = bitmapRepData[index++];
     PRUint8 a = bitmapRepData[index++];
-    
-#ifndef MOZ_CAIRO_GFX
-    // reverse premultiplication
-    if (a == 0) {
-      r = g = b = 0;
-    }
-    else {
-      r = ((PRUint32) r) * 255 / a;
-      g = ((PRUint32) g) * 255 / a;
-      b = ((PRUint32) b) * 255 / a;
-    }
-#endif
-    
+
     // write data out to our buffer
     // non-cairo uses native image format, but the A channel is ignored.
     // cairo uses ARGB (highest to lowest bits)
-#if defined(MOZ_CAIRO_GFX) && defined(IS_LITTLE_ENDIAN)
+#if defined(IS_LITTLE_ENDIAN)
     *iconBufferPtr++ = b;
     *iconBufferPtr++ = g;
     *iconBufferPtr++ = r;
@@ -366,15 +347,6 @@
     *iconBufferPtr++ = b;
 #endif
   }
-  
-#ifndef MOZ_CAIRO_GFX
-  // add the alpha to the buffer
-  index = 3;
-  while (index < dataCount) {
-    *iconBufferPtr++ = bitmapRepData[index];
-    index += 4;
-  }
-#endif
 
   NS_ASSERTION(iconBufferPtr == iconBuffer.get() + bufferCapacity,
                "buffer size miscalculation");

