diff -u -r3.14 -r3.15
--- mozilla/modules/libimg/png/png.c	2007/03/21 18:55:05	3.14
+++ mozilla/modules/libimg/png/png.c	2007/04/12 18:34:54	3.15
@@ -1,9 +1,9 @@
 
 /* png.c - location for general purpose libpng functions
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
@@ -13,7 +13,7 @@
 #include "png.h"
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef version_1_2_12 Your_png_h_is_not_version_1_2_12;
+typedef version_1_2_16 Your_png_h_is_not_version_1_2_16;
 
 /* Version information for C files.  This had better match the version
  * string defined in png.h.  */
@@ -100,6 +100,7 @@
 void PNGAPI
 png_set_sig_bytes(png_structp png_ptr, int num_bytes)
 {
+   if(png_ptr == NULL) return;
    png_debug(1, "in png_set_sig_bytes\n");
    if (num_bytes > 8)
       png_error(png_ptr, "Too many bytes for PNG signature.");
@@ -156,13 +157,14 @@
 png_zalloc(voidpf png_ptr, uInt items, uInt size)
 {
    png_voidp ptr;
-   png_structp p=png_ptr;
+   png_structp p=(png_structp)png_ptr;
    png_uint_32 save_flags=p->flags;
    png_uint_32 num_bytes;
 
+   if(png_ptr == NULL) return (NULL);
    if (items > PNG_UINT_32_MAX/size)
    {
-     png_warning (png_ptr, "Potential overflow in png_zalloc()");
+     png_warning (p, "Potential overflow in png_zalloc()");
      return (NULL);
    }
    num_bytes = (png_uint_32)items * size;
@@ -269,6 +271,7 @@
 png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
 {
    png_infop info_ptr = NULL;
+   if(png_ptr == NULL) return;
 
    png_debug(1, "in png_destroy_info_struct\n");
    if (info_ptr_ptr != NULL)
@@ -307,6 +310,8 @@
 {
    png_infop info_ptr = *ptr_ptr;
 
+   if(info_ptr == NULL) return;
+
    png_debug(1, "in png_info_init_3\n");
 
    if(png_sizeof(png_info) > png_info_struct_size)
@@ -614,6 +619,7 @@
 png_voidp PNGAPI
 png_get_io_ptr(png_structp png_ptr)
 {
+   if(png_ptr == NULL) return (NULL);
    return (png_ptr->io_ptr);
 }
 
@@ -629,6 +635,7 @@
 png_init_io(png_structp png_ptr, png_FILE_p fp)
 {
    png_debug(1, "in png_init_io\n");
+   if(png_ptr == NULL) return;
    png_ptr->io_ptr = (png_voidp)fp;
 }
 #endif
@@ -644,6 +651,7 @@
         {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 
+   if(png_ptr == NULL) return (NULL);
    if (png_ptr->time_buffer == NULL)
    {
       png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
@@ -696,8 +704,8 @@
 png_get_copyright(png_structp png_ptr)
 {
    if (&png_ptr != NULL)  /* silence compiler warning about unused png_ptr */
-   return ((png_charp) "\n libpng version 1.2.12 - June 27, 2006\n\
-   Copyright (c) 1998-2006 Glenn Randers-Pehrson\n\
+   return ((png_charp) "\n libpng version 1.2.16 - January 31, 2007\n\
+   Copyright (c) 1998-2007 Glenn Randers-Pehrson\n\
    Copyright (c) 1996-1997 Andreas Dilger\n\
    Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
    return ((png_charp) "");
@@ -760,6 +768,7 @@
 int PNGAPI
 png_reset_zstream(png_structp png_ptr)
 {
+   if (png_ptr == NULL) return Z_STREAM_ERROR;
    return (inflateReset(&png_ptr->zstream));
 }
 #endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
@@ -773,14 +782,14 @@
 }
 
 
-#if defined(PNG_READ_SUPPORTED)
+#if defined(PNG_READ_SUPPORTED) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)
 #if !defined(PNG_1_0_X)
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
-    /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
+#if defined(PNG_MMX_CODE_SUPPORTED)
 /* this INTERNAL function was added to libpng 1.2.0 */
 void /* PRIVATE */
 png_init_mmx_flags (png_structp png_ptr)
 {
+    if(png_ptr == NULL) return;
     png_ptr->mmx_rowbytes_threshold = 0;
     png_ptr->mmx_bitdepth_threshold = 0;
 
@@ -813,7 +822,7 @@
                                | PNG_MMX_WRITE_FLAGS );
     }
 
-#  else /* !((PNGVCRD || PNGGCCRD) && PNG_ASSEMBLER_CODE_SUPPORTED)) */
+#  else /* !(PNGVCRD || PNGGCCRD) */
 
     /* clear all MMX flags; no support is compiled in */
     png_ptr->asm_flags &= ~( PNG_MMX_FLAGS );
@@ -821,18 +830,18 @@
 #  endif /* ?(PNGVCRD || PNGGCCRD) */
 }
 
-#endif /* !(PNG_ASSEMBLER_CODE_SUPPORTED) */
+#endif /* !(PNG_MMX_CODE_SUPPORTED) */
 
 /* this function was added to libpng 1.2.0 */
 #if !defined(PNG_USE_PNGGCCRD) && \
-    !(defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
+    !(defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD))
 int PNGAPI
 png_mmx_support(void)
 {
     return -1;
 }
 #endif
-#endif /* PNG_1_0_X */
+#endif /* PNG_1_0_X  && PNG_ASSEMBLER_CODE_SUPPORTED */
 #endif /* PNG_READ_SUPPORTED */
 
 #if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png png.h,v
#retrieving revision 3.14
#retrieving revision 3.15
diff -u -r3.14 -r3.15
--- mozilla/modules/libimg/png/png.h	2007/03/22 23:35:51	3.14
+++ mozilla/modules/libimg/png/png.h	2007/04/12 18:34:54	3.15
@@ -1,15 +1,15 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.2.12 - June 27, 2006
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * libpng version 1.2.16 - January 31, 2007
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
  * Authors and maintainers:
  *  libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *  libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *  libpng versions 0.97, January 1998, through 1.2.12 - June 27, 2006: Glenn
+ *  libpng versions 0.97, January 1998, through 1.2.16 - January 31, 2007: Glenn
  *  See also "Contributing Authors", below.
  *
  * Note about libpng version numbers:
@@ -126,6 +126,23 @@
  *    1.2.11                  13    10211  12.so.0.11[.0]
  *    1.0.20                  10    10020  10.so.0.20[.0]
  *    1.2.12                  13    10212  12.so.0.12[.0]
+ *    1.2.13beta1             13    10213  12.so.0.13[.0]
+ *    1.0.21                  10    10021  10.so.0.21[.0]
+ *    1.2.13                  13    10213  12.so.0.13[.0]
+ *    1.2.14beta1-2           13    10214  12.so.0.14[.0]
+ *    1.0.22rc1               10    10022  10.so.0.22[.0]
+ *    1.2.14rc1               13    10214  12.so.0.14[.0]
+ *    1.0.22                  10    10022  10.so.0.22[.0]
+ *    1.2.14                  13    10214  12.so.0.14[.0]
+ *    1.2.15beta1-6           13    10215  12.so.0.15[.0]
+ *    1.0.23rc1-5             10    10023  10.so.0.23[.0]
+ *    1.2.15rc1-5             13    10215  12.so.0.15[.0]
+ *    1.0.23                  10    10023  10.so.0.23[.0]
+ *    1.2.15                  13    10215  12.so.0.15[.0]
+ *    1.2.16beta1-2           13    10216  12.so.0.16[.0]
+ *    1.2.16rc1               13    10216  12.so.0.16[.0]
+ *    1.0.24                  10    10024  10.so.0.24[.0]
+ *    1.2.16                  13    10216  12.so.0.16[.0]
  *
  *    Henceforth the source version will match the shared-library major
  *    and minor numbers; the shared-library major version number will be
@@ -155,8 +172,8 @@
  * If you modify libpng you may insert additional notices immediately following
  * this sentence.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.2.12, June 27, 2006, are
- * Copyright (c) 2004, 2006 Glenn Randers-Pehrson, and are
+ * libpng versions 1.2.6, August 15, 2004, through 1.2.16, January 31, 2007, are
+ * Copyright (c) 2004, 2007 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.2.5
  * with the following individual added to the list of Contributing Authors:
  *
@@ -267,13 +284,13 @@
  * Y2K compliance in libpng:
  * =========================
  *
- *    June 27, 2006
+ *    January 31, 2007
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.2.12 are Y2K compliant.  It is my belief that earlier
+ *    upward through 1.2.16 are Y2K compliant.  It is my belief that earlier
  *    versions were also Y2K compliant.
  *
  *    Libpng only has three year fields.  One is a 2-byte unsigned integer
@@ -329,9 +346,9 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.2.12"
+#define PNG_LIBPNG_VER_STRING "1.2.16"
 #define PNG_HEADER_VERSION_STRING \
-   " libpng version 1.2.12 - June 27, 2006 (header)\n"
+   " libpng version 1.2.16 - January 31, 2007 (header)\n"
 
 #define PNG_LIBPNG_VER_SONUM   0
 #define PNG_LIBPNG_VER_DLLNUM  13
@@ -339,7 +356,7 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   2
-#define PNG_LIBPNG_VER_RELEASE 12
+#define PNG_LIBPNG_VER_RELEASE 16
 /* This should match the numeric part of the final component of
  * PNG_LIBPNG_VER_STRING, omitting any leading zero: */
 
@@ -367,7 +384,7 @@
  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release */
-#define PNG_LIBPNG_VER 10212 /* 1.2.12 */
+#define PNG_LIBPNG_VER 10216 /* 1.2.16 */
 
 #ifndef PNG_VERSION_INFO_ONLY
 /* include the compression library's header */
@@ -1353,10 +1370,14 @@
 #endif
 
 /* New members added in libpng-1.2.0 */
-#if !defined(PNG_1_0_X) && defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#  if !defined(PNG_1_0_X)
+#    if defined(PNG_MMX_CODE_SUPPORTED)
    png_byte     mmx_bitdepth_threshold;
    png_uint_32  mmx_rowbytes_threshold;
+#    endif
    png_uint_32  asm_flags;
+#  endif
 #endif
 
 /* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */
@@ -1424,7 +1445,7 @@
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef png_structp version_1_2_12;
+typedef png_structp version_1_2_16;
 
 typedef png_struct FAR * FAR * png_structpp;
 
@@ -2598,6 +2619,7 @@
 
 /* Added to version 1.2.0 */
 #if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
 #define PNG_ASM_FLAG_MMX_SUPPORT_COMPILED  0x01  /* not user-settable */
 #define PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU    0x02  /* not user-settable */
 #define PNG_ASM_FLAG_MMX_READ_COMBINE_ROW  0x04
@@ -2623,6 +2645,7 @@
 
 #define PNG_SELECT_READ   1
 #define PNG_SELECT_WRITE  2
+#endif /* PNG_MMX_CODE_SUPPORTED */
 
 #if !defined(PNG_1_0_X)
 /* pngget.c */
@@ -2655,11 +2678,11 @@
    png_uint_32 mmx_rowbytes_threshold));
 
 #endif /* PNG_1_0_X */
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #if !defined(PNG_1_0_X)
 /* png.c, pnggccrd.c, or pngvcrd.c */
 extern PNG_EXPORT(int,png_mmx_support) PNGARG((void));
+#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 /* Strip the prepended error numbers ("#nnn ") from error and warning
  * messages before passing them to the error or warning handler. */
@@ -3605,9 +3628,11 @@
 #endif
 
 #if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
 /* png.c */ /* PRIVATE */
 PNG_EXTERN void png_init_mmx_flags PNGARG((png_structp png_ptr));
 #endif
+#endif
 
 #if defined(PNG_INCH_CONVERSIONS) && defined(PNG_FLOATING_POINT_SUPPORTED)
 PNG_EXTERN png_uint_32 png_get_pixels_per_inch PNGARG((png_structp png_ptr,
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngconf.h,v
#retrieving revision 3.20
#retrieving revision 3.21
diff -u -r3.20 -r3.21
--- mozilla/modules/libimg/png/pngconf.h	2007/03/20 23:56:48	3.20
+++ mozilla/modules/libimg/png/pngconf.h	2007/04/12 18:34:54	3.21
@@ -1,9 +1,9 @@
 
 /* pngconf.h - machine configurable file for libpng
  *
- * libpng version 1.2.12 - June 27, 2006
+ * libpng version 1.2.16 - January 31, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2005 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
@@ -723,11 +723,22 @@
 #endif
 
 /* PNG_ASSEMBLER_CODE was enabled by default in version 1.2.0 
-   even when PNG_USE_PNGVCRD or PNG_USE_PNGGCCRD is not defined */
+ * even when PNG_USE_PNGVCRD or PNG_USE_PNGGCCRD is not defined.
+ *
+ * PNG_NO_ASSEMBLER_CODE disables use of all assembler code and optimized C,
+ * and removes or includes several functions in the API.
+ *
+ * PNG_NO_MMX_CODE disables the use of MMX code without changing the API.
+ * When MMX code is off, then optimized C replacement functions are used.
+*/
 #if defined(PNG_READ_SUPPORTED) && !defined(PNG_NO_ASSEMBLER_CODE)
 #  ifndef PNG_ASSEMBLER_CODE_SUPPORTED
 #    define PNG_ASSEMBLER_CODE_SUPPORTED
 #  endif
+#  if defined(XP_MACOSX) && !defined(PNG_NO_MMX_CODE)
+     /* work around Intel-Mac compiler bug */
+#    define PNG_NO_MMX_CODE
+#  endif
 #  if !defined(PNG_MMX_CODE_SUPPORTED) && !defined(PNG_NO_MMX_CODE) && \
      defined(__MMX__)
 #    define PNG_MMX_CODE_SUPPORTED
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngerror.c,v
#retrieving revision 3.10
#retrieving revision 3.11
diff -u -r3.10 -r3.11
--- mozilla/modules/libimg/png/pngerror.c	2006/09/29 22:46:58	3.10
+++ mozilla/modules/libimg/png/pngerror.c	2007/04/12 18:34:54	3.11
@@ -1,7 +1,7 @@
 
 /* pngerror.c - stub functions for i/o and memory allocation
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.13 November 13, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
@@ -157,8 +157,11 @@
    char msg[18+64];
    if (png_ptr == NULL)
      png_error(png_ptr, error_message);
-   png_format_buffer(png_ptr, msg, error_message);
-   png_error(png_ptr, msg);
+   else
+   {
+     png_format_buffer(png_ptr, msg, error_message);
+     png_error(png_ptr, msg);
+   }
 }
 
 void PNGAPI
@@ -167,8 +170,11 @@
    char msg[18+64];
    if (png_ptr == NULL)
      png_warning(png_ptr, warning_message);
-   png_format_buffer(png_ptr, msg, warning_message);
-   png_warning(png_ptr, msg);
+   else
+   {
+     png_format_buffer(png_ptr, msg, warning_message);
+     png_warning(png_ptr, msg);
+   }
 }
 
 /* This is the default error handling function.  Note that replacements for
@@ -206,6 +212,8 @@
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
+   if (png_ptr)
+   {
 #  ifdef USE_FAR_KEYWORD
    {
       jmp_buf jmpbuf;
@@ -214,10 +222,9 @@
    }
 #  else
    longjmp(png_ptr->jmpbuf, 1);
-# endif
+#  endif
+   }
 #else
-   /* make compiler happy */ ;
-   if (png_ptr)
    PNG_ABORT();
 #endif
 #ifdef PNG_NO_CONSOLE_IO
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pnggccrd.c,v
#retrieving revision 3.10
#retrieving revision 3.11
diff -u -r3.10 -r3.11
--- mozilla/modules/libimg/png/pnggccrd.c	2006/09/29 22:46:58	3.10
+++ mozilla/modules/libimg/png/pnggccrd.c	2007/04/12 18:34:54	3.11
@@ -7,9 +7,9 @@
  *     and http://www.intel.com/drg/pentiumII/appnotes/923/923.htm
  *     for Intel's performance analysis of the MMX vs. non-MMX code.
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * Copyright (c) 1998, Intel Corporation
  *
  * Based on MSVC code contributed by Nirav Chhatrapati, Intel Corp., 1998.
@@ -245,7 +245,7 @@
 #define PNG_INTERNAL
 #include "png.h"
 
-#if defined(PNG_USE_PNGGCCRD)
+#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGGCCRD)
 
 int PNGAPI png_mmx_support(void);
 
@@ -255,7 +255,7 @@
 static const int FARDATA png_pass_width[7] = {8, 4, 4, 2, 2, 1, 1};
 #endif
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
 /* djgpp, Win32, Cygwin, and OS2 add their own underscores to global variables,
  * so define them without: */
 #if defined(__DJGPP__) || defined(WIN32) || defined(__CYGWIN__) || \
@@ -378,7 +378,7 @@
    _mask48_1 = _mask48_1;
    _mask48_0 = _mask48_0;
 }
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
 
 
 static int _mmx_supported = 2;
@@ -389,7 +389,7 @@
 /*                                                                           */
 /*#===========================================================================*/
 
-#if defined(PNG_HAVE_ASSEMBLER_COMBINE_ROW)
+#if defined(PNG_HAVE_MMX_COMBINE_ROW)
 
 #define BPP2  2
 #define BPP3  3 /* bytes per pixel (a.k.a. pixel_bytes) */
@@ -416,7 +416,7 @@
 {
    png_debug(1, "in png_combine_row (pnggccrd.c)\n");
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
    if (_mmx_supported == 2) {
 #if !defined(PNG_1_0_X)
        /* this should have happened in png_init_mmx_flags() already */
@@ -607,7 +607,7 @@
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
@@ -700,7 +700,7 @@
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = png_pass_start[png_ptr->pass];
@@ -745,7 +745,7 @@
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
@@ -854,7 +854,7 @@
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP2 * png_pass_start[png_ptr->pass];
@@ -898,7 +898,7 @@
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
@@ -1022,7 +1022,7 @@
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP3 * png_pass_start[png_ptr->pass];
@@ -1066,7 +1066,7 @@
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
@@ -1197,7 +1197,7 @@
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP4 * png_pass_start[png_ptr->pass];
@@ -1241,7 +1241,7 @@
             png_bytep srcptr;
             png_bytep dstptr;
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_COMBINE_ROW)
                 /* && _mmx_supported */ )
@@ -1389,7 +1389,7 @@
                );
             }
             else /* mmx _not supported - Use modified C routine */
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
             {
                register png_uint_32 i;
                png_uint_32 initial_val = BPP6 * png_pass_start[png_ptr->pass];
@@ -1480,7 +1480,7 @@
 
 } /* end png_combine_row() */
 
-#endif /* PNG_HAVE_ASSEMBLER_COMBINE_ROW */
+#endif /* PNG_HAVE_MMX_COMBINE_ROW */
 
 
 
@@ -1492,7 +1492,7 @@
 /*#===========================================================================*/
 
 #if defined(PNG_READ_INTERLACING_SUPPORTED)
-#if defined(PNG_HAVE_ASSEMBLER_READ_INTERLACE)
+#if defined(PNG_HAVE_MMX_READ_INTERLACE)
 
 /* png_do_read_interlace() is called after any 16-bit to 8-bit conversion
  * has taken place.  [GRR: what other steps come before and/or after?]
@@ -1510,7 +1510,7 @@
 
    png_debug(1, "in png_do_read_interlace (pnggccrd.c)\n");
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
    if (_mmx_supported == 2) {
 #if !defined(PNG_1_0_X)
        /* this should have happened in png_init_mmx_flags() already */
@@ -1723,7 +1723,7 @@
 
             /* New code by Nirav Chhatrapati - Intel Corporation */
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
 #if !defined(PNG_1_0_X)
             if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_INTERLACE)
                 /* && _mmx_supported */ )
@@ -2628,7 +2628,7 @@
                  /* GRR 19991007:  does it?  or should pixel_bytes in each
                   *   block be replaced with immediate value (e.g., 1)? */
                  /* GRR 19991017:  replaced with constants in each case */
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
             {
                if (pixel_bytes == 1)
                {
@@ -2753,13 +2753,13 @@
 
 } /* end png_do_read_interlace() */
 
-#endif /* PNG_HAVE_ASSEMBLER_READ_INTERLACE */
+#endif /* PNG_HAVE_MMX_READ_INTERLACE */
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 
 
 
-#if defined(PNG_HAVE_ASSEMBLER_READ_FILTER_ROW)
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_HAVE_MMX_READ_FILTER_ROW)
+#if defined(PNG_MMX_CODE_SUPPORTED)
 
 // These variables are utilized in the functions below.  They are declared
 // globally here to ensure alignment on 8-byte boundaries.
@@ -5066,7 +5066,7 @@
 
 } // end of png_read_filter_row_mmx_up()
 
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
 
 
 
@@ -5088,7 +5088,7 @@
    char filnm[10];
 #endif
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
 /* GRR:  these are superseded by png_ptr->asm_flags: */
 #define UseMMX_sub    1   // GRR:  converted 20000730
 #define UseMMX_up     1   // GRR:  converted 20000729
@@ -5102,7 +5102,7 @@
 #endif
        png_mmx_support();
    }
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
 
 #ifdef PNG_DEBUG
    png_debug(1, "in png_read_filter_row (pnggccrd.c)\n");
@@ -5111,7 +5111,7 @@
       case 0: sprintf(filnm, "none");
          break;
       case 1: sprintf(filnm, "sub-%s",
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB)? "MMX" :
 #endif
@@ -5119,7 +5119,7 @@
 "x86");
          break;
       case 2: sprintf(filnm, "up-%s",
-#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#ifdef PNG_MMX_CODE_SUPPORTED
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP)? "MMX" :
 #endif
@@ -5127,7 +5127,7 @@
  "x86");
          break;
       case 3: sprintf(filnm, "avg-%s",
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG)? "MMX" :
 #endif
@@ -5135,7 +5135,7 @@
  "x86");
          break;
       case 4: sprintf(filnm, "Paeth-%s",
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
         (png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH)? "MMX":
 #endif
@@ -5158,7 +5158,7 @@
          break;
 
       case PNG_FILTER_VALUE_SUB:
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_SUB) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
@@ -5170,7 +5170,7 @@
             png_read_filter_row_mmx_sub(row_info, row);
          }
          else
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_uint_32 istop = row_info->rowbytes;
@@ -5187,7 +5187,7 @@
          break;
 
       case PNG_FILTER_VALUE_UP:
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
+#if defined(PNG_MMX_CODE_SUPPORTED)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_UP) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
@@ -5199,7 +5199,7 @@
             png_read_filter_row_mmx_up(row_info, row, prev_row);
          }
           else
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_uint_32 istop = row_info->rowbytes;
@@ -5215,7 +5215,7 @@
          break;
 
       case PNG_FILTER_VALUE_AVG:
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_AVG) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
@@ -5227,7 +5227,7 @@
             png_read_filter_row_mmx_avg(row_info, row, prev_row);
          }
          else
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_bytep rp = row;
@@ -5253,7 +5253,7 @@
          break;
 
       case PNG_FILTER_VALUE_PAETH:
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
+#if defined(PNG_MMX_CODE_SUPPORTED) && defined(PNG_THREAD_UNSAFE_OK)
 #if !defined(PNG_1_0_X)
          if ((png_ptr->asm_flags & PNG_ASM_FLAG_MMX_READ_FILTER_PAETH) &&
              (row_info->pixel_depth >= png_ptr->mmx_bitdepth_threshold) &&
@@ -5265,7 +5265,7 @@
             png_read_filter_row_mmx_paeth(row_info, row, prev_row);
          }
          else
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
+#endif /* PNG_MMX_CODE_SUPPORTED */
          {
             png_uint_32 i;
             png_bytep rp = row;
@@ -5326,7 +5326,7 @@
    }
 }
 
-#endif /* PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */
+#endif /* PNG_HAVE_MMX_READ_FILTER_ROW */
 
 
 /*#===========================================================================*/
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngget.c,v
#retrieving revision 3.13
#retrieving revision 3.14
diff -u -r3.13 -r3.14
--- mozilla/modules/libimg/png/pngget.c	2007/03/22 23:35:51	3.13
+++ mozilla/modules/libimg/png/pngget.c	2007/04/12 18:34:54	3.14
@@ -1,9 +1,9 @@
 
 /* pngget.c - retrieval of values from info struct
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
@@ -992,19 +992,24 @@
 }
 #endif
 
-#ifndef PNG_1_0_X
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#ifndef PNG_1_0_X
 /* this function was added to libpng 1.2.0 and should exist by default */
 png_uint_32 PNGAPI
 png_get_asm_flags (png_structp png_ptr)
 {
+#ifdef PNG_MMX_CODE_SUPPORTED
     return (png_uint_32)(png_ptr? png_ptr->asm_flags : 0L);
+#else
+    return (png_ptr? 0L: 0L);
+#endif
 }
 
 /* this function was added to libpng 1.2.0 and should exist by default */
 png_uint_32 PNGAPI
 png_get_asm_flagmask (int flag_select)
 {
+#ifdef PNG_MMX_CODE_SUPPORTED
     png_uint_32 settable_asm_flags = 0;
 
     if (flag_select & PNG_SELECT_READ)
@@ -1025,16 +1030,18 @@
 #endif /* 0 */
 
     return settable_asm_flags;  /* _theoretically_ settable capabilities only */
+#else
+    return (0L);
+#endif /* PNG_MMX_CODE_SUPPORTED */
 }
-#endif /* PNG_ASSEMBLER_CODE_SUPPORTED */
 
 
-#if defined(PNG_ASSEMBLER_CODE_SUPPORTED)
     /* GRR:  could add this:   && defined(PNG_MMX_CODE_SUPPORTED) */
 /* this function was added to libpng 1.2.0 */
 png_uint_32 PNGAPI
 png_get_mmx_flagmask (int flag_select, int *compilerID)
 {
+#if defined(PNG_MMX_CODE_SUPPORTED)
     png_uint_32 settable_mmx_flags = 0;
 
     if (flag_select & PNG_SELECT_READ)
@@ -1065,23 +1072,34 @@
     }
 
     return settable_mmx_flags;  /* _theoretically_ settable capabilities only */
+#else
+    return (0L);
+#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
 
 /* this function was added to libpng 1.2.0 */
 png_byte PNGAPI
 png_get_mmx_bitdepth_threshold (png_structp png_ptr)
 {
+#if defined(PNG_MMX_CODE_SUPPORTED)
     return (png_byte)(png_ptr? png_ptr->mmx_bitdepth_threshold : 0);
+#else
+    return (png_ptr? 0: 0);
+#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
 
 /* this function was added to libpng 1.2.0 */
 png_uint_32 PNGAPI
 png_get_mmx_rowbytes_threshold (png_structp png_ptr)
 {
+#if defined(PNG_MMX_CODE_SUPPORTED)
     return (png_uint_32)(png_ptr? png_ptr->mmx_rowbytes_threshold : 0L);
+#else
+    return (png_ptr? 0L: 0L);
+#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
-#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 #endif /* ?PNG_1_0_X */
+#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
 /* these functions were added to libpng 1.2.6 */
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngmem.c,v
#retrieving revision 3.10
#retrieving revision 3.11
diff -u -r3.10 -r3.11
--- mozilla/modules/libimg/png/pngmem.c	2006/09/29 22:46:58	3.10
+++ mozilla/modules/libimg/png/pngmem.c	2007/04/12 18:34:54	3.11
@@ -1,7 +1,7 @@
 
 /* pngmem.c - stub functions for memory allocation
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.13 November 13, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
@@ -137,6 +137,9 @@
    png_voidp ret;
 #endif /* PNG_USER_MEM_SUPPORTED */
 
+   if (png_ptr == NULL || size == 0)
+      return (NULL);
+
 #ifdef PNG_MAX_MALLOC_64K
    if (size > (png_uint_32)65536L)
    {
@@ -290,6 +293,8 @@
 {
 #endif /* PNG_USER_MEM_SUPPORTED */
 
+   if(png_ptr == NULL) return;
+
    if (png_ptr->offset_table != NULL)
    {
       int i;
@@ -536,8 +541,10 @@
 png_malloc_warn(png_structp png_ptr, png_uint_32 size)
 {
    png_voidp ptr;
-   png_uint_32 save_flags=png_ptr->flags;
+   png_uint_32 save_flags;
+   if(png_ptr == NULL) return (NULL);
 
+   save_flags=png_ptr->flags;
    png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
    ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
    png_ptr->flags=save_flags;
@@ -580,9 +587,11 @@
 png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
   malloc_fn, png_free_ptr free_fn)
 {
+   if(png_ptr != NULL) {
    png_ptr->mem_ptr = mem_ptr;
    png_ptr->malloc_fn = malloc_fn;
    png_ptr->free_fn = free_fn;
+   }
 }
 
 /* This function returns a pointer to the mem_ptr associated with the user
@@ -592,6 +601,7 @@
 png_voidp PNGAPI
 png_get_mem_ptr(png_structp png_ptr)
 {
+   if(png_ptr == NULL) return (NULL);
    return ((png_voidp)png_ptr->mem_ptr);
 }
 #endif /* PNG_USER_MEM_SUPPORTED */
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngpread.c,v
#retrieving revision 3.13
#retrieving revision 3.14
diff -u -r3.13 -r3.14
--- mozilla/modules/libimg/png/pngpread.c	2007/03/21 18:55:05	3.13
+++ mozilla/modules/libimg/png/pngpread.c	2007/04/12 18:34:54	3.14
@@ -1,7 +1,7 @@
 
 /* pngpread.c - read a png file in push mode
  *
- * Last changed in libpng 1.2.11 - June 7, 2004
+ * Last changed in libpng 1.2.13 November 13, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
@@ -28,6 +28,7 @@
 png_process_data(png_structp png_ptr, png_infop info_ptr,
    png_bytep buffer, png_size_t buffer_size)
 {
+   if(png_ptr == NULL) return;
    png_push_restore_buffer(png_ptr, buffer, buffer_size);
 
    while (png_ptr->buffer_size)
@@ -42,6 +43,7 @@
 void /* PRIVATE */
 png_process_some_data(png_structp png_ptr, png_infop info_ptr)
 {
+   if(png_ptr == NULL) return;
    switch (png_ptr->process_mode)
    {
       case PNG_READ_SIG_MODE:
@@ -692,6 +694,7 @@
 {
    png_bytep ptr;
 
+   if(png_ptr == NULL) return;
    ptr = buffer;
    if (png_ptr->save_buffer_size)
    {
@@ -1729,6 +1732,7 @@
 png_progressive_combine_row (png_structp png_ptr,
    png_bytep old_row, png_bytep new_row)
 {
+   if(png_ptr == NULL) return;
 #ifdef PNG_USE_LOCAL_ARRAYS
    const int FARDATA png_pass_dsp_mask[7] =
       {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
@@ -1742,6 +1746,7 @@
    png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
    png_progressive_end_ptr end_fn)
 {
+   if(png_ptr == NULL) return;
    png_ptr->info_fn = info_fn;
    png_ptr->row_fn = row_fn;
    png_ptr->end_fn = end_fn;
@@ -1763,6 +1768,7 @@
 png_voidp PNGAPI
 png_get_progressive_ptr(png_structp png_ptr)
 {
+   if(png_ptr == NULL) return (NULL);
    return png_ptr->io_ptr;
 }
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngread.c,v
#retrieving revision 3.14
#retrieving revision 3.15
diff -u -r3.14 -r3.15
--- mozilla/modules/libimg/png/pngread.c	2007/03/21 18:55:05	3.14
+++ mozilla/modules/libimg/png/pngread.c	2007/04/12 18:34:54	3.15
@@ -1,9 +1,9 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.2.11 June 7, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -56,7 +56,7 @@
       return (NULL);
 
 #if !defined(PNG_1_0_X)
-#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#ifdef PNG_MMX_CODE_SUPPORTED
    png_init_mmx_flags(png_ptr);   /* 1.2.0 addition */
 #endif
 #endif /* PNG_1_0_X */
@@ -188,6 +188,7 @@
    png_size_t png_struct_size, png_size_t png_info_size)
 {
    /* We only come here via pre-1.0.12-compiled applications */
+   if(png_ptr == NULL) return;
 #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
    if(png_sizeof(png_struct) > png_struct_size ||
       png_sizeof(png_info) > png_info_size)
@@ -239,6 +240,8 @@
 
    png_structp png_ptr=*ptr_ptr;
 
+   if(png_ptr == NULL) return;
+
    do
    {
      if(user_png_ver[i] != png_libpng_ver[i])
@@ -317,6 +320,7 @@
 void PNGAPI
 png_read_info(png_structp png_ptr, png_infop info_ptr)
 {
+   if(png_ptr == NULL) return;
    png_debug(1, "in png_read_info\n");
    /* If we haven't checked all of the PNG signature bytes, do so now. */
    if (png_ptr->sig_bytes < 8)
@@ -623,6 +627,7 @@
 png_read_update_info(png_structp png_ptr, png_infop info_ptr)
 {
    png_debug(1, "in png_read_update_info\n");
+   if(png_ptr == NULL) return;
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
    else
@@ -641,6 +646,7 @@
 png_start_read_image(png_structp png_ptr)
 {
    png_debug(1, "in png_start_read_image\n");
+   if(png_ptr == NULL) return;
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
 }
@@ -660,6 +666,7 @@
    const int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
 #endif
    int ret;
+   if(png_ptr == NULL) return;
    png_debug2(1, "in png_read_row (row %lu, pass %d)\n",
       png_ptr->row_number, png_ptr->pass);
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
@@ -948,6 +955,7 @@
    png_bytepp dp;
 
    png_debug(1, "in png_read_rows\n");
+   if(png_ptr == NULL) return;
    rp = row;
    dp = display_row;
    if (rp != NULL && dp != NULL)
@@ -996,6 +1004,7 @@
    png_bytepp rp;
 
    png_debug(1, "in png_read_image\n");
+   if(png_ptr == NULL) return;
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
    pass = png_set_interlace_handling(png_ptr);
@@ -1034,6 +1043,7 @@
    png_uint_32 length;
 
    png_debug(1, "in png_read_end\n");
+   if(png_ptr == NULL) return;
    png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */
 
    do
@@ -1437,6 +1447,7 @@
 void PNGAPI
 png_set_read_status_fn(png_structp png_ptr, png_read_status_ptr read_row_fn)
 {
+   if(png_ptr == NULL) return;
    png_ptr->read_row_fn = read_row_fn;
 }
 
@@ -1450,6 +1461,7 @@
 {
    int row;
 
+   if(png_ptr == NULL) return;
 #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED)
    /* invert the alpha channel from opacity to transparency
     */
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngrio.c,v
#retrieving revision 3.9
#retrieving revision 3.10
diff -u -r3.9 -r3.10
--- mozilla/modules/libimg/png/pngrio.c	2006/09/29 22:46:58	3.9
+++ mozilla/modules/libimg/png/pngrio.c	2007/04/12 18:34:54	3.10
@@ -1,7 +1,7 @@
 
 /* pngrio.c - functions for data input
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.13 November 13, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
@@ -46,6 +46,7 @@
 {
    png_size_t check;
 
+   if(png_ptr == NULL) return;
    /* fread() returns 0 on error, so it is OK to store this in a png_size_t
     * instead of an int, which is what fread() actually returns.
     */
@@ -76,6 +77,7 @@
    png_byte *n_data;
    png_FILE_p io_ptr;
 
+   if(png_ptr == NULL) return;
    /* Check if data really is near. If so, use usual code. */
    n_data = (png_byte *)CVT_PTR_NOCHECK(data);
    io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
@@ -136,6 +138,7 @@
 png_set_read_fn(png_structp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn)
 {
+   if(png_ptr == NULL) return;
    png_ptr->io_ptr = io_ptr;
 
 #if !defined(PNG_NO_STDIO)
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngrtran.c,v
#retrieving revision 3.10
#retrieving revision 3.11
diff -u -r3.10 -r3.11
--- mozilla/modules/libimg/png/pngrtran.c	2006/09/29 22:46:58	3.10
+++ mozilla/modules/libimg/png/pngrtran.c	2007/04/12 18:34:54	3.11
@@ -1,9 +1,9 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.2.11 June 15, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -24,6 +24,7 @@
 {
    png_debug(1, "in png_set_crc_action\n");
    /* Tell libpng how we react to CRC errors in critical chunks */
+   if(png_ptr == NULL) return;
    switch (crit_action)
    {
       case PNG_CRC_NO_CHANGE:                        /* leave setting as is */
@@ -80,6 +81,7 @@
    int need_expand, double background_gamma)
 {
    png_debug(1, "in png_set_background\n");
+   if(png_ptr == NULL) return;
    if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
    {
       png_warning(png_ptr, "Application must supply a known background gamma");
@@ -92,17 +94,6 @@
    png_ptr->background_gamma = (float)background_gamma;
    png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
    png_ptr->transformations |= (need_expand ? PNG_BACKGROUND_EXPAND : 0);
-
-   /* Note:  if need_expand is set and color_type is either RGB or RGB_ALPHA
-    * (in which case need_expand is superfluous anyway), the background color
-    * might actually be gray yet not be flagged as such. This is not a problem
-    * for the current code, which uses PNG_BACKGROUND_IS_GRAY only to
-    * decide when to do the png_do_gray_to_rgb() transformation.
-    */
-   if ((need_expand && !(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) ||
-       (!need_expand && background_color->red == background_color->green &&
-        background_color->red == background_color->blue))
-      png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
 }
 #endif
 
@@ -112,6 +103,7 @@
 png_set_strip_16(png_structp png_ptr)
 {
    png_debug(1, "in png_set_strip_16\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_16_TO_8;
 }
 #endif
@@ -121,6 +113,7 @@
 png_set_strip_alpha(png_structp png_ptr)
 {
    png_debug(1, "in png_set_strip_alpha\n");
+   if(png_ptr == NULL) return;
    png_ptr->flags |= PNG_FLAG_STRIP_ALPHA;
 }
 #endif
@@ -150,6 +143,7 @@
    int full_dither)
 {
    png_debug(1, "in png_set_dither\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_DITHER;
 
    if (!full_dither)
@@ -533,6 +527,7 @@
 png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
 {
    png_debug(1, "in png_set_gamma\n");
+   if(png_ptr == NULL) return;
    if ((fabs(scrn_gamma * file_gamma - 1.0) > PNG_GAMMA_THRESHOLD) ||
        (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) ||
        (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
@@ -551,6 +546,7 @@
 png_set_expand(png_structp png_ptr)
 {
    png_debug(1, "in png_set_expand\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
 }
 
@@ -576,6 +572,7 @@
 png_set_palette_to_rgb(png_structp png_ptr)
 {
    png_debug(1, "in png_set_palette_to_rgb\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
 }
 
@@ -585,6 +582,7 @@
 png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
 {
    png_debug(1, "in png_set_expand_gray_1_2_4_to_8\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_EXPAND_tRNS;
 }
 #endif
@@ -596,6 +594,7 @@
 png_set_gray_1_2_4_to_8(png_structp png_ptr)
 {
    png_debug(1, "in png_set_gray_1_2_4_to_8\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
 }
 #endif
@@ -631,6 +630,7 @@
 {
       int red_fixed = (int)((float)red*100000.0 + 0.5);
       int green_fixed = (int)((float)green*100000.0 + 0.5);
+      if(png_ptr == NULL) return;
       png_set_rgb_to_gray_fixed(png_ptr, error_action, red_fixed, green_fixed);
 }
 #endif
@@ -640,6 +640,7 @@
    png_fixed_point red, png_fixed_point green)
 {
    png_debug(1, "in png_set_rgb_to_gray\n");
+   if(png_ptr == NULL) return;
    switch(error_action)
    {
       case 1: png_ptr->transformations |= PNG_RGB_TO_GRAY;
@@ -690,6 +691,7 @@
    read_user_transform_fn)
 {
    png_debug(1, "in png_set_read_user_transform_fn\n");
+   if(png_ptr == NULL) return;
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
    png_ptr->transformations |= PNG_USER_TRANSFORM;
    png_ptr->read_user_transform_fn = read_user_transform_fn;
@@ -719,6 +721,32 @@
 #endif
 
 #if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
+
+#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+   /* Detect gray background and attempt to enable optimization
+    * for gray --> RGB case */
+   /* Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
+    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
+    * background color might actually be gray yet not be flagged as such.
+    * This is not a problem for the current code, which uses
+    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
+    * png_do_gray_to_rgb() transformation.
+    */
+   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+       !(color_type & PNG_COLOR_MASK_COLOR))
+   {
+          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
+   } else if ((png_ptr->transformations & PNG_BACKGROUND) &&
+              !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+              (png_ptr->transformations & PNG_GRAY_TO_RGB) &&
+              png_ptr->background.red == png_ptr->background.green &&
+              png_ptr->background.red == png_ptr->background.blue)
+   {
+          png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
+          png_ptr->background.gray = png_ptr->background.red;
+   }
+#endif
+
    if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
        (png_ptr->transformations & PNG_EXPAND))
    {
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngrutil.c,v
#retrieving revision 3.14
#retrieving revision 3.15
diff -u -r3.14 -r3.15
--- mozilla/modules/libimg/png/pngrutil.c	2007/03/22 23:35:51	3.14
+++ mozilla/modules/libimg/png/pngrutil.c	2007/04/12 18:34:54	3.15
@@ -1,9 +1,9 @@
 
 /* pngrutil.c - utilities to read a PNG file
  *
- * Last changed in libpng 1.2.11 June 4, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -16,27 +16,29 @@
 
 #if defined(PNG_READ_SUPPORTED)
 
-#if defined(_WIN32_WCE)
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+#  if defined(_WIN32_WCE)
 /* strtod() function is not supported on WindowsCE */
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-__inline double strtod(const char *nptr, char **endptr)
+__inline double png_strtod(png_structp png_ptr, const char *nptr, char **endptr)
 {
    double result = 0;
    int len;
    wchar_t *str, *end;
 
    len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
-   str = (wchar_t *)malloc(len * sizeof(wchar_t));
+   str = (wchar_t *)png_malloc(png_ptr, len * sizeof(wchar_t));
    if ( NULL != str )
    {
       MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
       result = wcstod(str, &end);
       len = WideCharToMultiByte(CP_ACP, 0, end, -1, NULL, 0, NULL, NULL);
       *endptr = (char *)nptr + (png_strlen(nptr) - len + 1);
-      free(str);
+      png_free(str);
    }
    return result;
 }
+#  else
+#    define png_strtod(p,a,b) strtod(a,b)
 #  endif
 #endif
 
@@ -90,6 +92,7 @@
 void /* PRIVATE */
 png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
 {
+   if(png_ptr == NULL) return;
    png_read_data(png_ptr, buf, length);
    png_calculate_crc(png_ptr, buf, length);
 }
@@ -1735,7 +1738,7 @@
    ep = buffer + 1;        /* skip unit byte */
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   width = strtod(ep, &vp);
+   width = png_strtod(png_ptr, ep, &vp);
    if (*vp)
    {
        png_warning(png_ptr, "malformed width string in sCAL chunk");
@@ -1758,7 +1761,7 @@
    ep++;
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
-   height = strtod(ep, &vp);
+   height = png_strtod(png_ptr, ep, &vp);
    if (*vp)
    {
        png_warning(png_ptr, "malformed height string in sCAL chunk");
@@ -2411,7 +2414,7 @@
    a zero indicates the pixel is to be skipped.  This is in addition
    to any alpha or transparency value associated with the pixel.  If
    you want all pixels to be combined, pass 0xff (255) in mask.  */
-#ifndef PNG_HAVE_ASSEMBLER_COMBINE_ROW
+#ifndef PNG_HAVE_MMX_COMBINE_ROW
 void /* PRIVATE */
 png_combine_row(png_structp png_ptr, png_bytep row, int mask)
 {
@@ -2612,10 +2615,10 @@
       }
    }
 }
-#endif /* !PNG_HAVE_ASSEMBLER_COMBINE_ROW */
+#endif /* !PNG_HAVE_MMX_COMBINE_ROW */
 
 #ifdef PNG_READ_INTERLACING_SUPPORTED
-#ifndef PNG_HAVE_ASSEMBLER_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
+#ifndef PNG_HAVE_MMX_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
 /* OLD pre-1.0.9 interface:
 void png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
    png_uint_32 transformations)
@@ -2841,10 +2844,10 @@
       return;
 #endif
 }
-#endif /* !PNG_HAVE_ASSEMBLER_READ_INTERLACE */
+#endif /* !PNG_HAVE_MMX_READ_INTERLACE */
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 
-#ifndef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
+#ifndef PNG_HAVE_MMX_READ_FILTER_ROW
 void /* PRIVATE */
 png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
    png_bytep prev_row, int filter)
@@ -2967,7 +2970,7 @@
          break;
    }
 }
-#endif /* !PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */
+#endif /* !PNG_HAVE_MMX_READ_FILTER_ROW */
 
 void /* PRIVATE */
 png_read_finish_row(png_structp png_ptr)
@@ -3271,7 +3274,7 @@
    if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
       png_error(png_ptr, "This image requires a row greater than 64KB");
 #endif
-   if ((png_uint_32)png_ptr->rowbytes > PNG_SIZE_MAX - 1)
+   if ((png_uint_32)png_ptr->rowbytes > (png_uint_32)(PNG_SIZE_MAX - 1))
       png_error(png_ptr, "Row has too many bytes to allocate in memory.");
    png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
       png_ptr->rowbytes + 1));
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngset.c,v
#retrieving revision 3.12
#retrieving revision 3.13
diff -u -r3.12 -r3.13
--- mozilla/modules/libimg/png/pngset.c	2007/03/22 23:35:51	3.12
+++ mozilla/modules/libimg/png/pngset.c	2007/04/12 18:34:54	3.13
@@ -1,9 +1,9 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -981,10 +981,10 @@
         /* TODO: use png_malloc_warn */
         png_strcpy(to->name, from->name);
         to->entries = (png_sPLT_entryp)png_malloc(png_ptr,
-            from->nentries * png_sizeof(png_sPLT_t));
+            from->nentries * png_sizeof(png_sPLT_entry));
         /* TODO: use png_malloc_warn */
         png_memcpy(to->entries, from->entries,
-            from->nentries * png_sizeof(png_sPLT_t));
+            from->nentries * png_sizeof(png_sPLT_entry));
         to->nentries = from->nentries;
         to->depth = from->depth;
     }
@@ -1314,11 +1314,13 @@
 void PNGAPI
 png_set_asm_flags (png_structp png_ptr, png_uint_32 asm_flags)
 {
+#ifdef PNG_MMX_CODE_SUPPORTED
     png_uint_32 settable_asm_flags;
     png_uint_32 settable_mmx_flags;
-
+#endif
     if (png_ptr == NULL)
        return;
+#ifdef PNG_MMX_CODE_SUPPORTED
 
     settable_mmx_flags =
 #ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
@@ -1347,15 +1349,14 @@
     }
 
     /* we're replacing the settable bits with those passed in by the user,
-     * so first zero them out of the master copy, then logical-OR in the
+     * so first zero them out of the master copy, then bitwise-OR in the
      * allowed subset that was requested */
 
     png_ptr->asm_flags &= ~settable_asm_flags;               /* zero them */
     png_ptr->asm_flags |= (asm_flags & settable_asm_flags);  /* set them */
+#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
-#endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
-#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
 /* this function was added to libpng 1.2.0 */
 void PNGAPI
 png_set_mmx_thresholds (png_structp png_ptr,
@@ -1364,8 +1365,10 @@
 {
     if (png_ptr == NULL)
        return;
+#ifdef PNG_MMX_CODE_SUPPORTED
     png_ptr->mmx_bitdepth_threshold = mmx_bitdepth_threshold;
     png_ptr->mmx_rowbytes_threshold = mmx_rowbytes_threshold;
+#endif /* ?PNG_MMX_CODE_SUPPORTED */
 }
 #endif /* ?PNG_ASSEMBLER_CODE_SUPPORTED */
 
@@ -1379,6 +1382,7 @@
      * rejected by png_set_IHDR().  To accept any PNG datastream
      * regardless of dimensions, set both limits to 0x7ffffffL.
      */
+    if(png_ptr == NULL) return;
     png_ptr->user_width_max = user_width_max;
     png_ptr->user_height_max = user_height_max;
 }
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngtrans.c,v
#retrieving revision 3.9
#retrieving revision 3.10
diff -u -r3.9 -r3.10
--- mozilla/modules/libimg/png/pngtrans.c	2006/09/29 22:46:58	3.9
+++ mozilla/modules/libimg/png/pngtrans.c	2007/04/12 18:34:54	3.10
@@ -1,7 +1,7 @@
 
 /* pngtrans.c - transforms the data in a row (used by both readers and writers)
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.13 November 13, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2006 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
@@ -18,6 +18,7 @@
 png_set_bgr(png_structp png_ptr)
 {
    png_debug(1, "in png_set_bgr\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_BGR;
 }
 #endif
@@ -28,6 +29,7 @@
 png_set_swap(png_structp png_ptr)
 {
    png_debug(1, "in png_set_swap\n");
+   if(png_ptr == NULL) return;
    if (png_ptr->bit_depth == 16)
       png_ptr->transformations |= PNG_SWAP_BYTES;
 }
@@ -39,6 +41,7 @@
 png_set_packing(png_structp png_ptr)
 {
    png_debug(1, "in png_set_packing\n");
+   if(png_ptr == NULL) return;
    if (png_ptr->bit_depth < 8)
    {
       png_ptr->transformations |= PNG_PACK;
@@ -53,6 +56,7 @@
 png_set_packswap(png_structp png_ptr)
 {
    png_debug(1, "in png_set_packswap\n");
+   if(png_ptr == NULL) return;
    if (png_ptr->bit_depth < 8)
       png_ptr->transformations |= PNG_PACKSWAP;
 }
@@ -63,6 +67,7 @@
 png_set_shift(png_structp png_ptr, png_color_8p true_bits)
 {
    png_debug(1, "in png_set_shift\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_SHIFT;
    png_ptr->shift = *true_bits;
 }
@@ -74,7 +79,7 @@
 png_set_interlace_handling(png_structp png_ptr)
 {
    png_debug(1, "in png_set_interlace handling\n");
-   if (png_ptr->interlaced)
+   if (png_ptr && png_ptr->interlaced)
    {
       png_ptr->transformations |= PNG_INTERLACE;
       return (7);
@@ -94,6 +99,7 @@
 png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
 {
    png_debug(1, "in png_set_filler\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_FILLER;
    png_ptr->filler = (png_byte)filler;
    if (filler_loc == PNG_FILLER_AFTER)
@@ -126,6 +132,7 @@
 png_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)
 {
    png_debug(1, "in png_set_add_alpha\n");
+   if(png_ptr == NULL) return;
    png_set_filler(png_ptr, filler, filler_loc);
    png_ptr->transformations |= PNG_ADD_ALPHA;
 }
@@ -139,6 +146,7 @@
 png_set_swap_alpha(png_structp png_ptr)
 {
    png_debug(1, "in png_set_swap_alpha\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_SWAP_ALPHA;
 }
 #endif
@@ -149,6 +157,7 @@
 png_set_invert_alpha(png_structp png_ptr)
 {
    png_debug(1, "in png_set_invert_alpha\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_INVERT_ALPHA;
 }
 #endif
@@ -158,6 +167,7 @@
 png_set_invert_mono(png_structp png_ptr)
 {
    png_debug(1, "in png_set_invert_mono\n");
+   if(png_ptr == NULL) return;
    png_ptr->transformations |= PNG_INVERT_MONO;
 }
 
@@ -621,6 +631,7 @@
    user_transform_ptr, int user_transform_depth, int user_transform_channels)
 {
    png_debug(1, "in png_set_user_transform_info\n");
+   if(png_ptr == NULL) return;
 #if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    png_ptr->user_transform_ptr = user_transform_ptr;
    png_ptr->user_transform_depth = (png_byte)user_transform_depth;
@@ -641,12 +652,10 @@
 png_voidp PNGAPI
 png_get_user_transform_ptr(png_structp png_ptr)
 {
+   if (png_ptr == NULL) return (NULL);
 #if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    return ((png_voidp)png_ptr->user_transform_ptr);
-#else
-   if(png_ptr)
-     return (NULL);
-   return (NULL);
 #endif
+   return (NULL);
 }
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngwio.c,v
#retrieving revision 3.9
#retrieving revision 3.10
diff -u -r3.9 -r3.10
--- mozilla/modules/libimg/png/pngwio.c	2006/09/29 22:46:58	3.9
+++ mozilla/modules/libimg/png/pngwio.c	2007/04/12 18:34:54	3.10
@@ -1,7 +1,7 @@
 
 /* pngwio.c - functions for data output
  *
- * Last changed in libpng 1.2.3 - May 21, 2002
+ * Last changed in libpng 1.2.13 November 13, 2006
  * For conditions of distribution and use, see copyright notice in png.h
  * Copyright (c) 1998-2002 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
@@ -45,6 +45,7 @@
 {
    png_uint_32 check;
 
+   if(png_ptr == NULL) return;
 #if defined(_WIN32_WCE)
    if ( !WriteFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
       check = 0;
@@ -70,6 +71,7 @@
    png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
    png_FILE_p io_ptr;
 
+   if(png_ptr == NULL) return;
    /* Check if data really is near. If so, use usual code. */
    near_data = (png_byte *)CVT_PTR_NOCHECK(data);
    io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
@@ -131,6 +133,9 @@
 {
 #if !defined(_WIN32_WCE)
    png_FILE_p io_ptr;
+#endif
+   if(png_ptr == NULL) return;
+#if !defined(_WIN32_WCE)
    io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
    if (io_ptr != NULL)
       fflush(io_ptr);
@@ -165,6 +170,7 @@
 png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
 {
+   if(png_ptr == NULL) return;
    png_ptr->io_ptr = io_ptr;
 
 #if !defined(PNG_NO_STDIO)
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngwrite.c,v
#retrieving revision 3.14
#retrieving revision 3.15
diff -u -r3.14 -r3.15
--- mozilla/modules/libimg/png/pngwrite.c	2007/03/22 23:35:51	3.14
+++ mozilla/modules/libimg/png/pngwrite.c	2007/04/12 18:34:54	3.15
@@ -1,9 +1,9 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.2.9 April 14, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
@@ -469,8 +469,10 @@
 
 #if !defined(PNG_1_0_X)
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#ifdef PNG_MMX_CODE_SUPPORTED
    png_init_mmx_flags(png_ptr);   /* 1.2.0 addition */
 #endif
+#endif
 #endif /* PNG_1_0_X */
 
    /* added at libpng-1.2.6 */
@@ -584,6 +586,7 @@
    png_size_t png_struct_size, png_size_t png_info_size)
 {
    /* We only come here via pre-1.0.12-compiled applications */
+   if(png_ptr == NULL) return;
 #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
    if(png_sizeof(png_struct) > png_struct_size ||
       png_sizeof(png_info) > png_info_size)
@@ -678,8 +681,10 @@
 
 #if !defined(PNG_1_0_X)
 #ifdef PNG_ASSEMBLER_CODE_SUPPORTED
+#ifdef PNG_MMX_CODE_SUPPORTED
    png_init_mmx_flags(png_ptr);   /* 1.2.0 addition */
 #endif
+#endif
 #endif /* PNG_1_0_X */
 
 #ifdef PNG_SETJMP_SUPPORTED
#===================================================================
#RCS file: /cvsroot/mozilla/modules/libimg/png pngwutil.c,v
#retrieving revision 3.12
#retrieving revision 3.13
diff -u -r3.12 -r3.13
--- mozilla/modules/libimg/png/pngwutil.c	2007/03/22 23:35:51	3.12
+++ mozilla/modules/libimg/png/pngwutil.c	2007/04/12 18:34:54	3.13
@@ -1,9 +1,9 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.2.11 June 4, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
@@ -62,6 +62,7 @@
 png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
    png_bytep data, png_size_t length)
 {
+   if(png_ptr == NULL) return;
    png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
    png_write_chunk_data(png_ptr, data, length);
    png_write_chunk_end(png_ptr);
@@ -77,6 +78,7 @@
 {
    png_byte buf[4];
    png_debug2(0, "Writing %s chunk (%lu bytes)\n", chunk_name, length);
+   if(png_ptr == NULL) return;
 
    /* write the length */
    png_save_uint_32(buf, length);
@@ -98,6 +100,7 @@
 png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    /* write the data, and run the CRC over it */
+   if(png_ptr == NULL) return;
    if (data != NULL && length > 0)
    {
       png_calculate_crc(png_ptr, data, length);
@@ -111,6 +114,8 @@
 {
    png_byte buf[4];
 
+   if(png_ptr == NULL) return;
+
    /* write the crc */
    png_save_uint_32(buf, png_ptr->crc);
 
@@ -757,6 +762,7 @@
    png_size_t name_len;
    png_charp new_name;
    compression_state comp;
+   int embedded_profile_len = 0;
 
    png_debug(1, "in png_write_iCCP\n");
 
@@ -779,6 +785,27 @@
    if (profile == NULL)
       profile_len = 0;
 
+   if (profile_len > 3)
+      embedded_profile_len =
+          ((*( (png_bytep)profile  ))<<24) |
+          ((*( (png_bytep)profile+1))<<16) |
+          ((*( (png_bytep)profile+2))<< 8) |
+          ((*( (png_bytep)profile+3))    );
+
+   if (profile_len < embedded_profile_len)
+     {
+        png_warning(png_ptr,
+          "Embedded profile length too large in iCCP chunk");
+        return;
+     }
+
+   if (profile_len > embedded_profile_len)
+     {
+        png_warning(png_ptr,
+          "Truncating profile to actual length in iCCP chunk");
+        profile_len = embedded_profile_len;
+     }
+
    if (profile_len)
        profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,
           PNG_COMPRESSION_TYPE_BASE, &comp);
