Index: mozilla/modules/libimg/png/pngwutil.c
===================================================================
--- mozilla.orig/modules/libimg/png/pngwutil.c
+++ mozilla/modules/libimg/png/pngwutil.c
@@ -1,14 +1,14 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.2.11 June 4, 2006
+ * Last changed in libpng 1.2.15 January 5, 2007
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2006 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2007 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  */
 
 #define PNG_INTERNAL
 #include "png.h"
 #ifdef PNG_WRITE_SUPPORTED
 
@@ -57,31 +57,33 @@ png_save_uint_16(png_bytep buf, unsigned
  * All the data must be present.  If that is not possible, use the
  * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
  * functions instead.
  */
 void PNGAPI
 png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
    png_bytep data, png_size_t length)
 {
+   if(png_ptr == NULL) return;
    png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
    png_write_chunk_data(png_ptr, data, length);
    png_write_chunk_end(png_ptr);
 }
 
 /* Write the start of a PNG chunk.  The type is the chunk type.
  * The total_length is the sum of the lengths of all the data you will be
  * passing in png_write_chunk_data().
  */
 void PNGAPI
 png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
    png_uint_32 length)
 {
    png_byte buf[4];
    png_debug2(0, "Writing %s chunk (%lu bytes)\n", chunk_name, length);
+   if(png_ptr == NULL) return;
 
    /* write the length */
    png_save_uint_32(buf, length);
    png_write_data(png_ptr, buf, (png_size_t)4);
 
    /* write the chunk name */
    png_write_data(png_ptr, chunk_name, (png_size_t)4);
    /* reset the crc and run it over the chunk name */
@@ -93,29 +95,32 @@ png_write_chunk_start(png_structp png_pt
  * Note that multiple calls to this function are allowed, and that the
  * sum of the lengths from these calls *must* add up to the total_length
  * given to png_write_chunk_start().
  */
 void PNGAPI
 png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
 {
    /* write the data, and run the CRC over it */
+   if(png_ptr == NULL) return;
    if (data != NULL && length > 0)
    {
       png_calculate_crc(png_ptr, data, length);
       png_write_data(png_ptr, data, length);
    }
 }
 
 /* Finish a chunk started with png_write_chunk_start(). */
 void PNGAPI
 png_write_chunk_end(png_structp png_ptr)
 {
    png_byte buf[4];
 
+   if(png_ptr == NULL) return;
+
    /* write the crc */
    png_save_uint_32(buf, png_ptr->crc);
 
    png_write_data(png_ptr, buf, (png_size_t)4);
 }
 
 /* Simple function to write the signature.  If we have already written
  * the magic bytes of the signature, or more likely, the PNG stream is
@@ -486,21 +491,16 @@ png_write_IHDR(png_structp png_ptr, png_
    buf[9] = (png_byte)color_type;
    buf[10] = (png_byte)compression_type;
    buf[11] = (png_byte)filter_type;
    buf[12] = (png_byte)interlace_type;
 
    /* write the chunk */
    png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);
 
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-   png_ptr->first_frame_width = width;
-   png_ptr->first_frame_height = height;
-#endif
-
    /* initialize zlib with PNG info */
    png_ptr->zstream.zalloc = png_zalloc;
    png_ptr->zstream.zfree = png_zfree;
    png_ptr->zstream.opaque = (voidpf)png_ptr;
    if (!(png_ptr->do_filter))
    {
       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
          png_ptr->bit_depth < 8)
@@ -602,19 +602,16 @@ png_write_PLTE(png_structp png_ptr, png_
 }
 
 /* write an IDAT chunk */
 void /* PRIVATE */
 png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_IDAT;
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-   PNG_fdAT;
-#endif
 #endif
    png_debug(1, "in png_write_IDAT\n");
 
    /* Optimize the CMF field in the zlib stream. */
    /* This hack of the zlib stream is compliant to the stream specification. */
    if (!(png_ptr->mode & PNG_HAVE_IDAT) &&
        png_ptr->compression_type == PNG_COMPRESSION_TYPE_BASE)
    {
@@ -647,38 +644,17 @@ png_write_IDAT(png_structp png_ptr, png_
             }
          }
       }
       else
          png_error(png_ptr,
             "Invalid zlib compression method or flags in IDAT");
    }
 
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-   if(png_ptr->num_frames_written == 0)
-#endif
-      png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-   else
-   {
-      png_byte buf[4];
-      
-      png_write_chunk_start(png_ptr, (png_bytep)png_fdAT, 4 + length);
-      
-      png_save_uint_32(buf, png_ptr->next_seq_num);
-      png_write_chunk_data(png_ptr, buf, 4);
-      
-      png_write_chunk_data(png_ptr, data, length);
-      
-      png_write_chunk_end(png_ptr);
-      
-      png_ptr->next_seq_num++;
-   }
-#endif
-
+   png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
    png_ptr->mode |= PNG_HAVE_IDAT;
 }
 
 /* write an IEND chunk */
 void /* PRIVATE */
 png_write_IEND(png_structp png_ptr)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
@@ -752,16 +728,17 @@ png_write_iCCP(png_structp png_ptr, png_
    png_charp profile, int profile_len)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_iCCP;
 #endif
    png_size_t name_len;
    png_charp new_name;
    compression_state comp;
+   int embedded_profile_len = 0;
 
    png_debug(1, "in png_write_iCCP\n");
 
    comp.num_output_ptr = 0;
    comp.max_output_ptr = 0;
    comp.output_ptr = NULL;
    comp.input = NULL;
    comp.input_len = 0;
@@ -774,16 +751,37 @@ png_write_iCCP(png_structp png_ptr, png_
    }
 
    if (compression_type != PNG_COMPRESSION_TYPE_BASE)
       png_warning(png_ptr, "Unknown compression type in iCCP chunk");
 
    if (profile == NULL)
       profile_len = 0;
 
+   if (profile_len > 3)
+      embedded_profile_len =
+          ((*( (png_bytep)profile  ))<<24) |
+          ((*( (png_bytep)profile+1))<<16) |
+          ((*( (png_bytep)profile+2))<< 8) |
+          ((*( (png_bytep)profile+3))    );
+
+   if (profile_len < embedded_profile_len)
+     {
+        png_warning(png_ptr,
+          "Embedded profile length too large in iCCP chunk");
+        return;
+     }
+
+   if (profile_len > embedded_profile_len)
+     {
+        png_warning(png_ptr,
+          "Truncating profile to actual length in iCCP chunk");
+        profile_len = embedded_profile_len;
+     }
+
    if (profile_len)
        profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,
           PNG_COMPRESSION_TYPE_BASE, &comp);
 
    /* make sure we include the NULL after the name and the compression type */
    png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
           (png_uint_32)name_len+profile_len+2);
    new_name[name_len+1]=0x00;
@@ -1717,84 +1715,16 @@ png_write_tIME(png_structp png_ptr, png_
    buf[4] = mod_time->hour;
    buf[5] = mod_time->minute;
    buf[6] = mod_time->second;
 
    png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
 }
 #endif
 
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-void /* PRIVATE */
-png_write_acTL(png_structp png_ptr,
-   png_uint_32 num_frames, png_uint_32 num_iterations)
-{
-#ifdef PNG_USE_LOCAL_ARRAYS
-    PNG_acTL;
-#endif
-    png_byte data[16];
-    
-    png_debug(1, "in png_write_acTL\n");
-    
-    if (num_frames == 0)
-        png_error(png_ptr, "png_write_acTL: invalid number of frames (0)");
-    if (num_frames > PNG_UINT_31_MAX)
-        png_error(png_ptr, "png_write_acTL: invalid number of frames "
-                           "(> 2^31-1)");
-    if (num_iterations > PNG_UINT_31_MAX)
-        png_error(png_ptr, "png_write_acTL: invalid number of iterations "
-                           "(> 2^31-1)");
-    
-    png_ptr->num_frames_to_write = num_frames;
-    
-    png_save_uint_32(data, num_frames);
-    png_save_uint_32(data + 4, num_iterations);
-    
-    png_write_chunk(png_ptr, (png_bytep)png_acTL, data, (png_size_t)8);
-}
-
-void /* PRIVATE */
-png_write_fcTL(png_structp png_ptr, png_uint_32 width, png_uint_32 height, 
-    png_uint_32 x_offset, png_uint_32 y_offset,
-    png_uint_16 delay_num, png_uint_16 delay_den, png_byte render_op)
-{
-#ifdef PNG_USE_LOCAL_ARRAYS
-    PNG_fcTL;
-#endif
-    png_byte data[25];
-    
-    png_debug(1, "in png_write_fcTL\n");
-    
-    if (png_ptr->num_frames_written == 0 && (x_offset != 0 || y_offset != 0))
-        png_error(png_ptr, "x and/or y offset for the first frame aren't 0\n");
-    if (png_ptr->num_frames_written == 0 && 
-        (width != png_ptr->first_frame_width || 
-         height != png_ptr->first_frame_height))
-        png_error(png_ptr, "width and/or height in the first frame's fcTL "
-                           "don't match the ones in IHDR\n");
-    
-    /* more error checking */
-    png_ensure_fcTL_is_valid(png_ptr, width, height, x_offset, y_offset, 
-                             delay_num, delay_den, render_op);
-    
-    png_save_uint_32(data, png_ptr->next_seq_num);
-    png_save_uint_32(data + 4, width);
-    png_save_uint_32(data + 8, height);
-    png_save_uint_32(data + 12, x_offset);
-    png_save_uint_32(data + 16, y_offset);
-    png_save_uint_16(data + 20, delay_num);
-    png_save_uint_16(data + 22, delay_den);
-    data[24] = render_op;
-    
-    png_write_chunk(png_ptr, (png_bytep)png_fcTL, data, (png_size_t)25);
-    
-    png_ptr->next_seq_num++;
-}
-#endif /* PNG_WRITE_APNG_SUPPORTED */
-
 /* initializes the row writing capability of libpng */
 void /* PRIVATE */
 png_write_start_row(png_structp png_ptr)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* start of interlace block */
@@ -1812,58 +1742,52 @@ png_write_start_row(png_structp png_ptr)
 
    png_size_t buf_size;
 
    png_debug(1, "in png_write_start_row\n");
    buf_size = (png_size_t)(PNG_ROWBYTES(
       png_ptr->usr_channels*png_ptr->usr_bit_depth,png_ptr->width)+1);
 
    /* set up row buffer */
-   if (png_ptr->row_buf == NULL)
-      png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
+   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
    png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;
 
    /* set up filtering buffer, if using this filter */
    if (png_ptr->do_filter & PNG_FILTER_SUB)
    {
-      if (png_ptr->sub_row == NULL)
-         png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
-            (png_ptr->rowbytes + 1));
+      png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
+         (png_ptr->rowbytes + 1));
       png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
    }
 
    /* We only need to keep the previous row if we are using one of these. */
    if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
    {
      /* set up previous row buffer */
-      if (png_ptr->prev_row == NULL)
-         png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
+      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
       png_memset(png_ptr->prev_row, 0, buf_size);
 
       if (png_ptr->do_filter & PNG_FILTER_UP)
       {
-         if (png_ptr->up_row == NULL)
-            png_ptr->up_row = (png_bytep )png_malloc(png_ptr,
-               (png_ptr->rowbytes + 1));
+         png_ptr->up_row = (png_bytep )png_malloc(png_ptr,
+            (png_ptr->rowbytes + 1));
          png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
       }
 
       if (png_ptr->do_filter & PNG_FILTER_AVG)
       {
-         if (png_ptr->avg_row == NULL)
-            png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
-               (png_ptr->rowbytes + 1));
+         png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
+            (png_ptr->rowbytes + 1));
          png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
       }
 
       if (png_ptr->do_filter & PNG_FILTER_PAETH)
       {
-         if (png_ptr->paeth_row == NULL)
-            png_ptr->paeth_row = (png_bytep )png_malloc(png_ptr,
-               (png_ptr->rowbytes + 1));
+         png_ptr->paeth_row = (png_bytep )png_malloc(png_ptr,
+            (png_ptr->rowbytes + 1));
          png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
       }
    }
 
 #ifdef PNG_WRITE_INTERLACING_SUPPORTED
    /* if interlaced, we need to set up width and height of pass */
    if (png_ptr->interlaced)
    {
@@ -2845,44 +2769,9 @@ png_write_filtered_row(png_structp png_p
 
    if (png_ptr->flush_dist > 0 &&
        png_ptr->flush_rows >= png_ptr->flush_dist)
    {
       png_write_flush(png_ptr);
    }
 #endif
 }
-
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-void /* PRIVATE */
-png_write_reset(png_structp png_ptr)
-{
-    png_ptr->row_number = 0;
-    png_ptr->pass = 0;
-    png_ptr->mode &= ~PNG_HAVE_IDAT;
-}
-
-void /* PRIVATE */
-png_write_reinit(png_structp png_ptr, png_infop info_ptr, 
-                 png_uint_32 width, png_uint_32 height)
-{
-    if (png_ptr->num_frames_written == 0 && 
-        (width != png_ptr->first_frame_width || 
-         height != png_ptr->first_frame_height))
-        png_error(png_ptr, "width and/or height in the first frame's fcTL "
-                           "don't match the ones in IHDR\n");
-    if (width > png_ptr->first_frame_width || 
-        height > png_ptr->first_frame_height)
-        png_error(png_ptr, "width and/or height for a frame greater than"
-                           "the ones in IHDR");
-    
-    png_set_IHDR(png_ptr, info_ptr, width, height, 
-                 info_ptr->bit_depth, info_ptr->color_type, 
-                 info_ptr->interlace_type, info_ptr->compression_type,
-                 info_ptr->filter_type);
-   
-    png_ptr->width = width;
-    png_ptr->height = height;
-    png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, width);
-    png_ptr->usr_width = png_ptr->width;
-}
-#endif
 #endif /* PNG_WRITE_SUPPORTED */
Index: mozilla/modules/libimg/png/png.c
===================================================================
--- mozilla.orig/modules/libimg/png/png.c
+++ mozilla/modules/libimg/png/png.c
@@ -46,19 +46,16 @@ PNG_sCAL;
 PNG_pHYs;
 PNG_sBIT;
 PNG_sPLT;
 PNG_sRGB;
 PNG_tEXt;
 PNG_tIME;
 PNG_tRNS;
 PNG_zTXt;
-PNG_acTL;
-PNG_fcTL;
-PNG_fdAT;
 
 #ifdef PNG_READ_SUPPORTED
 /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
 /* start of interlace block */
 const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
 
 /* offset to next interlace block */
Index: mozilla/modules/libimg/png/png.h
===================================================================
--- mozilla.orig/modules/libimg/png/png.h
+++ mozilla/modules/libimg/png/png.h
@@ -895,28 +895,16 @@ defined(PNG_READ_BACKGROUND_SUPPORTED)
    png_fixed_point int_x_red;
    png_fixed_point int_y_red;
    png_fixed_point int_x_green;
    png_fixed_point int_y_green;
    png_fixed_point int_x_blue;
    png_fixed_point int_y_blue;
 #endif
 
-#if defined(PNG_APNG_SUPPORTED)
-   png_uint_32 num_frames;
-   png_uint_32 num_iterations;
-   png_uint_32 next_frame_width;
-   png_uint_32 next_frame_height;
-   png_uint_32 next_frame_x_offset;
-   png_uint_32 next_frame_y_offset;
-   png_uint_16 next_frame_delay_num;
-   png_uint_16 next_frame_delay_den;
-   png_byte next_frame_render_op;
-#endif
-
 } png_info;
 
 typedef png_info FAR * png_infop;
 typedef png_info FAR * FAR * png_infopp;
 
 /* Maximum positive integer used in PNG is (2^31)-1 */
 #define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
 #define PNG_UINT_32_MAX ((png_uint_32)(-1))
@@ -1008,18 +996,16 @@ typedef png_info FAR * FAR * png_infopp;
 #define PNG_INFO_oFFs 0x0100
 #define PNG_INFO_tIME 0x0200
 #define PNG_INFO_pCAL 0x0400
 #define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
 #define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
 #define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
 #define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
 #define PNG_INFO_IDAT 0x8000L  /* ESR, 1.0.6 */
-#define PNG_INFO_acTL 0x10000L
-#define PNG_INFO_fcTL 0x20000L
 
 /* This is used for the transformation routines, as some of them
  * change these values for the row.  It also should enable using
  * the routines for other purposes.
  */
 typedef struct png_row_info_struct
 {
    png_uint_32 width; /* width of row */
@@ -1050,20 +1036,16 @@ typedef void (PNGAPI *png_read_status_pt
 typedef void (PNGAPI *png_write_status_ptr) PNGARG((png_structp, png_uint_32,
    int));
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 typedef void (PNGAPI *png_progressive_info_ptr) PNGARG((png_structp, png_infop));
 typedef void (PNGAPI *png_progressive_end_ptr) PNGARG((png_structp, png_infop));
 typedef void (PNGAPI *png_progressive_row_ptr) PNGARG((png_structp, png_bytep,
    png_uint_32, int));
-#if defined(PNG_APNG_SUPPORTED)
-typedef void (PNGAPI *png_progressive_frame_ptr) PNGARG((png_structp, 
-   png_uint_32));
-#endif
 #endif
 
 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
     defined(PNG_LEGACY_SUPPORTED)
 typedef void (PNGAPI *png_user_transform_ptr) PNGARG((png_structp,
     png_row_infop, png_bytep));
 #endif
@@ -1380,47 +1362,18 @@ struct png_struct_def
 /* New members added in libpng-1.0.16 and 1.2.6 */
    png_byte compression_type;
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
    png_uint_32 user_width_max;
    png_uint_32 user_height_max;
 #endif
 
-#if defined(PNG_APNG_SUPPORTED)
-   png_uint_32 apng_flags;
-   png_uint_32 next_seq_num;         /* next fcTL/fdAT chunk sequence number */
-   png_uint_32 first_frame_width;
-   png_uint_32 first_frame_height;
-#endif
-
-#if defined(PNG_READ_APNG_SUPPORTED)
-   png_uint_32 num_frames_read;      /* incremented after all image data of */
-                                     /* a frame is read */
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-   png_progressive_frame_ptr frame_info_fn; /* frame info read callback */
-   png_progressive_frame_ptr frame_end_fn;  /* frame data read callback */
-#endif
-#endif
-
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-   png_uint_32 num_frames_to_write;  /* copy of info_ptr->num_frames */
-   png_uint_32 num_frames_written;
-#endif
-
 };
 
-/* For png_struct.apng_flags: */
-#define PNG_FIRST_FRAME_HIDDEN       0x0001
-
-/* dispose_op flags from render_op inside fcTL */
-#define PNG_RENDER_OP_DISPOSE_MASK        0x07
-#define PNG_RENDER_OP_DISPOSE_NONE        0x01
-#define PNG_RENDER_OP_DISPOSE_BACKGROUND  0x02
-#define PNG_RENDER_OP_DISPOSE_PREVIOUS    0x04
 
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
 typedef png_structp version_1_2_12;
 
 typedef png_struct FAR * FAR * png_structpp;
 
@@ -1730,28 +1683,16 @@ extern PNG_EXPORT(void,png_write_row) PN
 /* write a few rows of image data */
 extern PNG_EXPORT(void,png_write_rows) PNGARG((png_structp png_ptr,
    png_bytepp row, png_uint_32 num_rows));
 
 /* write the image data */
 extern PNG_EXPORT(void,png_write_image) PNGARG((png_structp png_ptr,
    png_bytepp image));
 
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-extern PNG_EXPORT (void,png_write_frame_head) PNGARG((png_structp png_ptr,
-   png_infop png_info, png_bytepp row_pointers,
-   png_uint_32 width, png_uint_32 height,
-   png_uint_32 x_offset, png_uint_32 y_offset, 
-   png_uint_16 delay_num, png_uint_16 delay_den, png_byte render_op,
-   png_byte first_frame_hidden));
-
-extern PNG_EXPORT (void,png_write_frame_tail) PNGARG((png_structp png_ptr,
-   png_infop png_info));
-#endif
-   
 /* writes the end of the PNG file. */
 extern PNG_EXPORT(void,png_write_end) PNGARG((png_structp png_ptr,
    png_infop info_ptr));
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
 /* read the end of the PNG file. */
 extern PNG_EXPORT(void,png_read_end) PNGARG((png_structp png_ptr,
    png_infop info_ptr));
@@ -1990,21 +1931,16 @@ extern PNG_EXPORT(png_voidp,png_get_user
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 /* Sets the function callbacks for the push reader, and a pointer to a
  * user-defined structure available to the callback functions.
  */
 extern PNG_EXPORT(void,png_set_progressive_read_fn) PNGARG((png_structp png_ptr,
    png_voidp progressive_ptr,
    png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
    png_progressive_end_ptr end_fn));
-#if defined(PNG_READ_APNG_SUPPORTED)
-extern PNG_EXPORT(void,png_set_progressive_frame_fn) PNGARG((png_structp png_ptr,
-   png_progressive_frame_ptr frame_info_fn,
-   png_progressive_frame_ptr frame_end_fn));
-#endif
 
 /* returns the user pointer associated with the push read functions */
 extern PNG_EXPORT(png_voidp,png_get_progressive_ptr)
    PNGARG((png_structp png_ptr));
 
 /* function to be called when data becomes available */
 extern PNG_EXPORT(void,png_process_data) PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_bytep buffer, png_size_t buffer_size));
@@ -2423,63 +2359,16 @@ extern PNG_EXPORT(void,png_set_sCAL) PNG
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
 extern PNG_EXPORT(void,png_set_sCAL_s) PNGARG((png_structp png_ptr,
    png_infop info_ptr, int unit, png_charp swidth, png_charp sheight));
 #endif
 #endif
 #endif /* PNG_sCAL_SUPPORTED || PNG_WRITE_sCAL_SUPPORTED */
 
-#if defined(PNG_APNG_SUPPORTED)
-extern PNG_EXPORT(png_uint_32,png_get_acTL) PNGARG((png_structp png_ptr,
-   png_infop info_ptr, png_uint_32 *num_frames, png_uint_32 *num_iterations));
-extern PNG_EXPORT(png_uint_32,png_set_acTL) PNGARG((png_structp png_ptr, 
-   png_infop info_ptr, png_uint_32 num_frames, png_uint_32 num_iterations));
-extern PNG_EXPORT(png_uint_32,png_get_num_frames) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-extern PNG_EXPORT(png_uint_32,png_get_num_iterations) 
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-
-extern PNG_EXPORT(png_uint_32,png_get_next_frame_fcTL) 
-   PNGARG((png_structp png_ptr, png_infop info_ptr, png_uint_32 *width, 
-   png_uint_32 *height, png_uint_32 *x_offset, png_uint_32 *y_offset, 
-   png_uint_16 *delay_num, png_uint_16 *delay_den, png_byte *render_op));
-extern PNG_EXPORT(png_uint_32,png_set_next_frame_fcTL) 
-   PNGARG((png_structp png_ptr, png_infop info_ptr, png_uint_32 width, 
-   png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset, 
-   png_uint_16 delay_num, png_uint_16 delay_den, png_byte render_op));
-extern PNG_EXPORT(void,png_ensure_fcTL_is_valid)
-   PNGARG((png_structp png_ptr,
-   png_uint_32 width, png_uint_32 height,
-   png_uint_32 x_offset, png_uint_32 y_offset,
-   png_uint_16 delay_num, png_uint_16 delay_den,
-   png_byte render_op));
-extern PNG_EXPORT(png_uint_32,png_get_next_frame_width)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-extern PNG_EXPORT(png_uint_32,png_get_next_frame_height)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-extern PNG_EXPORT(png_uint_32,png_get_next_frame_x_offset)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-extern PNG_EXPORT(png_uint_32,png_get_next_frame_y_offset)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-extern PNG_EXPORT(png_uint_16,png_get_next_frame_delay_num)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-extern PNG_EXPORT(png_uint_16,png_get_next_frame_delay_den)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-extern PNG_EXPORT(png_byte,png_get_next_frame_render_op)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-extern PNG_EXPORT(png_byte,png_first_frame_is_hidden)
-   PNGARG((png_structp png_ptr, png_infop info_ptr));
-#endif /* PNG_APNG_SUPPORTED */
-
-#if defined(PNG_READ_APNG_SUPPORTED)
-extern PNG_EXPORT(void,png_read_frame_head) PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-#endif
-
 #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
 /* provide a list of chunks and how they are to be handled, if the built-in
    handling or default unknown chunk handling is not desired.  Any chunks not
    listed will be handled in the default manner.  The IHDR and IEND chunks
    must not be listed.
       keep = 0: follow default behavour
            = 1: do not keep
            = 2: keep only if safe-to-copy
@@ -2773,18 +2662,16 @@ extern PNG_EXPORT(void,png_save_uint_16)
 #define PNG_HAVE_cHRM               0x40
 #define PNG_HAVE_sRGB               0x80
 #define PNG_HAVE_CHUNK_HEADER      0x100
 #define PNG_WROTE_tIME             0x200
 #define PNG_WROTE_INFO_BEFORE_PLTE 0x400
 #define PNG_BACKGROUND_IS_GRAY     0x800
 #define PNG_HAVE_PNG_SIGNATURE    0x1000
 #define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
-#define PNG_HAVE_acTL             0x4000
-#define PNG_HAVE_fcTL             0x8000L
 
 /* flags for the transformations the PNG library does on the image data */
 #define PNG_BGR                0x0001
 #define PNG_INTERLACE          0x0002
 #define PNG_PACK               0x0004
 #define PNG_SHIFT              0x0008
 #define PNG_SWAP_BYTES         0x0010
 #define PNG_INVERT_MONO        0x0020
@@ -2918,19 +2805,16 @@ extern PNG_EXPORT(void,png_save_uint_16)
 #define PNG_pHYs const png_byte png_pHYs[5] = {112,  72,  89, 115, '\0'}
 #define PNG_sBIT const png_byte png_sBIT[5] = {115,  66,  73,  84, '\0'}
 #define PNG_sPLT const png_byte png_sPLT[5] = {115,  80,  76,  84, '\0'}
 #define PNG_sRGB const png_byte png_sRGB[5] = {115,  82,  71,  66, '\0'}
 #define PNG_tEXt const png_byte png_tEXt[5] = {116,  69,  88, 116, '\0'}
 #define PNG_tIME const png_byte png_tIME[5] = {116,  73,  77,  69, '\0'}
 #define PNG_tRNS const png_byte png_tRNS[5] = {116,  82,  78,  83, '\0'}
 #define PNG_zTXt const png_byte png_zTXt[5] = {122,  84,  88, 116, '\0'}
-#define PNG_acTL const png_byte png_acTL[5] = { 97,  99,  84,  76, '\0'}
-#define PNG_fcTL const png_byte png_fcTL[5] = {102,  99,  84,  76, '\0'}
-#define PNG_fdAT const png_byte png_fdAT[5] = {102, 100,  65,  84, '\0'}
 
 #ifdef PNG_USE_GLOBAL_ARRAYS
 PNG_EXPORT_VAR (const png_byte FARDATA) png_IHDR[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_IDAT[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_IEND[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_PLTE[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_bKGD[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_cHRM[5];
@@ -2944,19 +2828,16 @@ PNG_EXPORT_VAR (const png_byte FARDATA) 
 PNG_EXPORT_VAR (const png_byte FARDATA) png_pHYs[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_sBIT[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_sPLT[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_sRGB[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_tEXt[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_tIME[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_tRNS[5];
 PNG_EXPORT_VAR (const png_byte FARDATA) png_zTXt[5];
-PNG_EXPORT_VAR (const png_byte FARDATA) png_acTL[5];
-PNG_EXPORT_VAR (const png_byte FARDATA) png_fcTL[5];
-PNG_EXPORT_VAR (const png_byte FARDATA) png_fdAT[5];
 #endif /* PNG_USE_GLOBAL_ARRAYS */
 
 #if defined(PNG_1_0_X) || defined (PNG_1_2_X)
 /* Initialize png_ptr struct for reading, and allocate any other memory.
  * (old interface - DEPRECATED - use png_create_read_struct instead).
  */
 extern PNG_EXPORT(void,png_read_init) PNGARG((png_structp png_ptr));
 #undef png_read_init
@@ -3221,26 +3102,16 @@ PNG_EXTERN void png_write_sCAL PNGARG((p
 #else
 #ifdef PNG_FIXED_POINT_SUPPORTED
 PNG_EXTERN void png_write_sCAL_s PNGARG((png_structp png_ptr,
    int unit, png_charp width, png_charp height));
 #endif
 #endif
 #endif
 
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-PNG_EXTERN void png_write_acTL PNGARG((png_structp png_ptr,
-   png_uint_32 num_frames, png_uint_32 num_iterations));
-
-PNG_EXTERN void png_write_fcTL PNGARG((png_structp png_ptr, 
-   png_uint_32 width, png_uint_32 height, 
-   png_uint_32 x_offset, png_uint_32 y_offset, 
-   png_uint_16 delay_num, png_uint_16 delay_den, png_byte render_op));
-#endif
-
 /* Called when finished processing a row of data */
 PNG_EXTERN void png_write_finish_row PNGARG((png_structp png_ptr));
 
 /* Internal use only.   Called before first row of data */
 PNG_EXTERN void png_write_start_row PNGARG((png_structp png_ptr));
 
 #if defined(PNG_READ_GAMMA_SUPPORTED)
 PNG_EXTERN void png_build_gamma_table PNGARG((png_structp png_ptr));
@@ -3282,30 +3153,16 @@ PNG_EXTERN void png_write_filtered_row P
 PNG_EXTERN void png_read_finish_row PNGARG((png_structp png_ptr));
 
 /* initialize the row buffers, etc. */
 PNG_EXTERN void png_read_start_row PNGARG((png_structp png_ptr));
 /* optional call to update the users info structure */
 PNG_EXTERN void png_read_transform_info PNGARG((png_structp png_ptr,
    png_infop info_ptr));
 
-#if defined(PNG_READ_APNG_SUPPORTED)
-/* private, reset some things to become ready for reading next frame */
-PNG_EXTERN void png_read_reset PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_read_reinit PNGARG((png_structp png_ptr,
-   png_infop info_ptr));
-PNG_EXTERN void png_progressive_read_reset PNGARG((png_structp png_ptr));
-#endif
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-/* private, reset some things to become ready for writing next frame */
-PNG_EXTERN void png_write_reset PNGARG((png_structp png_ptr));
-PNG_EXTERN void png_write_reinit PNGARG((png_structp png_ptr, 
-   png_infop info_ptr, png_uint_32 width, png_uint_32 height));
-#endif
-
 /* these are the functions that do the transformations */
 #if defined(PNG_READ_FILLER_SUPPORTED)
 PNG_EXTERN void png_do_read_filler PNGARG((png_row_infop row_info,
    png_bytep row, png_uint_32 filler, png_uint_32 flags));
 #endif
 
 #if defined(PNG_READ_SWAP_ALPHA_SUPPORTED)
 PNG_EXTERN void png_do_read_swap_alpha PNGARG((png_row_infop row_info,
@@ -3511,27 +3368,16 @@ PNG_EXTERN void png_handle_tRNS PNGARG((
    png_uint_32 length));
 #endif
 
 #if defined(PNG_READ_zTXt_SUPPORTED)
 PNG_EXTERN void png_handle_zTXt PNGARG((png_structp png_ptr, png_infop info_ptr,
    png_uint_32 length));
 #endif
 
-#if defined(PNG_READ_APNG_SUPPORTED)
-PNG_EXTERN void png_handle_acTL PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-PNG_EXTERN void png_handle_fcTL PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-PNG_EXTERN void png_handle_fdAT PNGARG((png_structp png_ptr, png_infop info_ptr,
-   png_uint_32 length));
-PNG_EXTERN void png_ensure_sequence_number PNGARG((png_structp png_ptr, 
-   png_uint_32 length));
-#endif
-
 PNG_EXTERN void png_handle_unknown PNGARG((png_structp png_ptr,
    png_infop info_ptr, png_uint_32 length));
 
 PNG_EXTERN void png_check_chunk_name PNGARG((png_structp png_ptr,
    png_bytep chunk_name));
 
 /* handle the transformations for reading and writing */
 PNG_EXTERN void png_do_read_transformations PNGARG((png_structp png_ptr));
Index: mozilla/modules/libimg/png/pngconf.h
===================================================================
--- mozilla.orig/modules/libimg/png/pngconf.h
+++ mozilla/modules/libimg/png/pngconf.h
@@ -891,20 +891,16 @@
 #ifndef PNG_NO_READ_tRNS
 #  define PNG_READ_tRNS_SUPPORTED
 #  define PNG_tRNS_SUPPORTED
 #endif
 #ifndef PNG_NO_READ_zTXt
 #  define PNG_READ_zTXt_SUPPORTED
 #  define PNG_zTXt_SUPPORTED
 #endif
-#ifndef PNG_NO_READ_APNG
-#  define PNG_READ_APNG_SUPPORTED
-#  define PNG_APNG_SUPPORTED
-#endif
 #ifndef PNG_NO_READ_UNKNOWN_CHUNKS
 #  define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
 #  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
 #    define PNG_UNKNOWN_CHUNKS_SUPPORTED
 #  endif
 #  ifndef PNG_NO_HANDLE_AS_UNKNOWN
 #    define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
 #  endif
@@ -1037,22 +1033,16 @@
 #  endif
 #endif
 #ifndef PNG_NO_WRITE_zTXt
 #  define PNG_WRITE_zTXt_SUPPORTED
 #  ifndef PNG_zTXt_SUPPORTED
 #    define PNG_zTXt_SUPPORTED
 #  endif
 #endif
-#ifndef PNG_NO_WRITE_APNG
-#  define PNG_WRITE_APNG_SUPPORTED
-#  ifndef PNG_APNG_SUPPORTED
-#    define PNG_APNG_SUPPORTED
-#  endif
-#endif
 #ifndef PNG_NO_WRITE_UNKNOWN_CHUNKS
 #  define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
 #  ifndef PNG_UNKNOWN_CHUNKS_SUPPORTED
 #    define PNG_UNKNOWN_CHUNKS_SUPPORTED
 #  endif
 #  ifndef PNG_NO_HANDLE_AS_UNKNOWN
 #     ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
 #       define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
Index: mozilla/modules/libimg/png/pngget.c
===================================================================
--- mozilla.orig/modules/libimg/png/pngget.c
+++ mozilla/modules/libimg/png/pngget.c
@@ -789,167 +789,16 @@ png_get_tRNS(png_structp png_ptr, png_in
          *num_trans = info_ptr->num_trans;
          retval |= PNG_INFO_tRNS;
       }
    }
    return (retval);
 }
 #endif
 
-#if defined(PNG_APNG_SUPPORTED)
-png_uint_32 PNGAPI
-png_get_acTL(png_structp png_ptr, png_infop info_ptr,
-             png_uint_32 *num_frames, png_uint_32 *num_iterations)
-{
-    png_debug1(1, "in %s retrieval function\n", "acTL");
-    
-    if (png_ptr != NULL && info_ptr != NULL &&
-        (info_ptr->valid & PNG_INFO_acTL) &&
-        num_frames != NULL && num_iterations != NULL)
-    {
-        *num_frames = info_ptr->num_frames;
-        *num_iterations = info_ptr->num_iterations;
-        return (1);
-    }
-    
-    return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_num_frames(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_num_frames()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->num_frames);
-    return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_num_iterations(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_num_iterations()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->num_iterations);
-    return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_next_frame_fcTL(png_structp png_ptr, png_infop info_ptr,
-             png_uint_32 *width, png_uint_32 *height,
-             png_uint_32 *x_offset, png_uint_32 *y_offset,
-             png_uint_16 *delay_num, png_uint_16 *delay_den,
-             png_byte *render_op)
-{
-    png_debug1(1, "in %s retrieval function\n", "fcTL");
-    
-    if (png_ptr != NULL && info_ptr != NULL &&
-        (info_ptr->valid & PNG_INFO_fcTL) &&
-        width != NULL && height != NULL && 
-        x_offset != NULL && x_offset != NULL && 
-        delay_num != NULL && delay_den != NULL && render_op != NULL)
-    {
-        *width = info_ptr->next_frame_width;
-        *height = info_ptr->next_frame_height;
-        *x_offset = info_ptr->next_frame_x_offset;
-        *y_offset = info_ptr->next_frame_y_offset;
-        *delay_num = info_ptr->next_frame_delay_num;
-        *delay_den = info_ptr->next_frame_delay_den;
-        *render_op = info_ptr->next_frame_render_op;
-        return (1);
-    }
-    
-    return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_next_frame_width(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_next_frame_width()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->next_frame_width);
-    return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_next_frame_height(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_next_frame_height()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->next_frame_height);
-    return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_next_frame_x_offset(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_next_frame_x_offset()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->next_frame_x_offset);
-    return (0);
-}
-
-png_uint_32 PNGAPI
-png_get_next_frame_y_offset(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_next_frame_y_offset()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->next_frame_y_offset);
-    return (0);
-}
-
-png_uint_16 PNGAPI
-png_get_next_frame_delay_num(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_next_frame_delay_num()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->next_frame_delay_num);
-    return (0);
-}
-
-png_uint_16 PNGAPI
-png_get_next_frame_delay_den(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_next_frame_delay_den()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->next_frame_delay_den);
-    return (0);
-}
-
-png_byte PNGAPI
-png_get_next_frame_render_op(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_get_next_frame_render_op()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL)
-        return (info_ptr->next_frame_render_op);
-    return (0);
-}
-
-png_byte PNGAPI
-png_first_frame_is_hidden(png_structp png_ptr, png_infop info_ptr)
-{
-    png_debug(1, "in png_first_frame_is_hidden()\n");
-    
-    if (png_ptr != NULL && info_ptr != NULL && 
-        info_ptr->valid & PNG_INFO_acTL &&
-        !(info_ptr->valid & PNG_INFO_fcTL))
-        return 1;
-    
-    return 0;
-}
-#endif /* PNG_APNG_SUPPORTED */
-
 #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
 png_uint_32 PNGAPI
 png_get_unknown_chunks(png_structp png_ptr, png_infop info_ptr,
              png_unknown_chunkpp unknowns)
 {
    if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
      *unknowns = info_ptr->unknown_chunks;
    return ((png_uint_32)info_ptr->unknown_chunks_num);
Index: mozilla/modules/libimg/png/pngpread.c
===================================================================
--- mozilla.orig/modules/libimg/png/pngpread.c
+++ mozilla/modules/libimg/png/pngpread.c
@@ -185,21 +185,16 @@ png_push_read_chunk(png_structp png_ptr,
       PNG_tIME;
 #endif
 #if defined(PNG_READ_tRNS_SUPPORTED)
       PNG_tRNS;
 #endif
 #if defined(PNG_READ_zTXt_SUPPORTED)
       PNG_zTXt;
 #endif
-#if defined(PNG_READ_APNG_SUPPORTED)
-      PNG_acTL;
-      PNG_fcTL;
-      PNG_fdAT;
-#endif
 #endif /* PNG_USE_LOCAL_ARRAYS */
    /* First we make sure we have enough data for the 4 byte chunk name
     * and the 4 byte chunk length before proceeding with decoding the
     * chunk data.  To fully decode each of these chunks, we also make
     * sure we have enough data in the buffer for the 4 byte CRC at the
     * end of every chunk (except IDAT, which is handled separately).
     */
    if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
@@ -213,114 +208,17 @@ png_push_read_chunk(png_structp png_ptr,
       }
 
       png_push_fill_buffer(png_ptr, chunk_length, 4);
       png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
    }
-   
-#if defined(PNG_READ_APNG_SUPPORTED)
-   if (png_ptr->num_frames_read > 0 && 
-       png_ptr->num_frames_read < info_ptr->num_frames)
-   {
-      if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-      {
-         /* discard trailing IDATs for the first frame */
-         if (png_ptr->mode & PNG_HAVE_fcTL || png_ptr->num_frames_read > 1)
-            png_error(png_ptr, "out of place IDAT");
-         
-         if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-         {
-            png_push_save_buffer(png_ptr);
-            return;
-         }
-         png_push_crc_skip(png_ptr, png_ptr->push_length);
-         png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
-         return;
-      }
-      else if (!png_memcmp(png_ptr->chunk_name, png_fdAT, 4))
-      {
-         if (png_ptr->buffer_size < 4)
-         {
-            png_push_save_buffer(png_ptr);
-            return;
-         }
-         png_ensure_sequence_number(png_ptr, 4);
-         
-         if (!(png_ptr->mode & PNG_HAVE_fcTL))
-         {
-            /* discard trailing fdATs for frames other than the first */
-            if (png_ptr->num_frames_read < 2)
-               png_error(png_ptr, "out of place fdAT");
-            
-            if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-            {
-               png_push_save_buffer(png_ptr);
-               return;
-            }
-            png_push_crc_skip(png_ptr, png_ptr->push_length);
-            png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
-            return;
-         }
-         else
-         {
-            /* frame data follows */
-            png_ptr->idat_size = png_ptr->push_length - 4;
-            png_ptr->mode |= PNG_HAVE_IDAT;
-            png_ptr->process_mode = PNG_READ_IDAT_MODE;
-            
-            return;
-         }
-      }
-      else if(!png_memcmp(png_ptr->chunk_name, png_fcTL, 4))
-      {
-         if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-         {
-            png_push_save_buffer(png_ptr);
-            return;
-         }
-         
-         png_read_reset(png_ptr);
-         png_ptr->mode &= ~PNG_HAVE_fcTL;
-         
-         png_handle_fcTL(png_ptr, info_ptr, png_ptr->push_length);
-         
-         if (!(png_ptr->mode & PNG_HAVE_fcTL))
-            png_error(png_ptr, "missing required fcTL chunk");
-         
-         png_read_reinit(png_ptr, info_ptr);
-         png_progressive_read_reset(png_ptr);
-         
-         if (png_ptr->frame_info_fn != NULL)
-            (*(png_ptr->frame_info_fn))(png_ptr, png_ptr->num_frames_read);
-         
-         png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
-         
-         return;
-      }
-      else
-      {
-         if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-         {
-            png_push_save_buffer(png_ptr);
-            return;
-         }
-         png_warning(png_ptr, "Skipped (ignored) a chunk "
-                              "between APNG chunks");
-         png_push_crc_skip(png_ptr, png_ptr->push_length);
-         png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
-         return;
-      }
-      
-      return;
-   }
-#endif /* PNG_READ_APNG_SUPPORTED */
-   
+
    if (!png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
      if(png_ptr->mode & PNG_AFTER_IDAT)
         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
 
    if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
@@ -585,45 +483,16 @@ png_push_read_chunk(png_structp png_ptr,
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
          png_push_save_buffer(png_ptr);
          return;
       }
       png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
    }
 #endif
-#if defined(PNG_READ_APNG_SUPPORTED)
-   else if (!png_memcmp(png_ptr->chunk_name, png_acTL, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-      png_handle_acTL(png_ptr, info_ptr, png_ptr->push_length);
-   }
-   else if (!png_memcmp(png_ptr->chunk_name, png_fcTL, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-      png_handle_fcTL(png_ptr, info_ptr, png_ptr->push_length);
-   }
-   else if (!png_memcmp(png_ptr->chunk_name, png_fdAT, 4))
-   {
-      if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-      png_handle_fdAT(png_ptr, info_ptr, png_ptr->push_length);
-   }
-#endif /* PNG_READ_APNG_SUPPORTED */
    else
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
       {
          png_push_save_buffer(png_ptr);
          return;
       }
       png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
@@ -784,90 +653,42 @@ png_push_restore_buffer(png_structp png_
    png_ptr->current_buffer_ptr = png_ptr->current_buffer;
 }
 
 void /* PRIVATE */
 png_push_read_IDAT(png_structp png_ptr)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_IDAT;
-#if defined(PNG_READ_APNG_SUPPORTED)
-   PNG_fdAT;
-   PNG_IEND;
-#endif
 #endif
    if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
    {
       png_byte chunk_length[4];
 
-      if (png_ptr->buffer_size < 12)
+      if (png_ptr->buffer_size < 8)
       {
          png_push_save_buffer(png_ptr);
          return;
       }
 
       png_push_fill_buffer(png_ptr, chunk_length, 4);
       png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
 
-#if defined(PNG_READ_APNG_SUPPORTED)
-      if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_fdAT, 4)
-          && png_ptr->num_frames_read > 0)
-      {
-          if (png_ptr->flags & PNG_FLAG_ZLIB_FINISHED)
-          {
-              png_ptr->process_mode = PNG_READ_CHUNK_MODE;
-              if (png_ptr->frame_end_fn != NULL)
-                 (*(png_ptr->frame_end_fn))(png_ptr, png_ptr->num_frames_read);
-              png_ptr->num_frames_read++;
-              return;
-          }
-          else
-          {
-              if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
-                  png_error(png_ptr, "Not enough image data");
-              if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-              {
-                 png_push_save_buffer(png_ptr);
-                 return;
-              }
-              png_warning(png_ptr, "Skipping (ignoring) a chunk between "
-                                   "APNG chunks");
-              png_crc_finish(png_ptr, png_ptr->push_length);
-              png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
-              return;
-          }
-      }
-      else 
-#endif
-      if ( png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4)
-                && (png_ptr->num_frames_read == 0) )
+      if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
       {
          png_ptr->process_mode = PNG_READ_CHUNK_MODE;
          if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
             png_error(png_ptr, "Not enough compressed data");
-#if defined(PNG_READ_APNG_SUPPORTED)
-         if (png_ptr->frame_end_fn != NULL)
-            (*(png_ptr->frame_end_fn))(png_ptr, png_ptr->num_frames_read);
-         png_ptr->num_frames_read++;
-#endif
          return;
       }
 
       png_ptr->idat_size = png_ptr->push_length;
-      
-#if defined(PNG_READ_APNG_SUPPORTED)
-      if(png_ptr->num_frames_read > 0)
-      {
-         png_ensure_sequence_number(png_ptr, 4);
-         png_ptr->idat_size -= 4;
-      }
-#endif
    }
    if (png_ptr->idat_size && png_ptr->save_buffer_size)
    {
       png_size_t save_size;
 
       if (png_ptr->idat_size < (png_uint_32)png_ptr->save_buffer_size)
       {
          save_size = (png_size_t)png_ptr->idat_size;
@@ -1744,25 +1565,14 @@ png_set_progressive_read_fn(png_structp 
 {
    png_ptr->info_fn = info_fn;
    png_ptr->row_fn = row_fn;
    png_ptr->end_fn = end_fn;
 
    png_set_read_fn(png_ptr, progressive_ptr, png_push_fill_buffer);
 }
 
-#if defined(PNG_READ_APNG_SUPPORTED)
-void PNGAPI
-png_set_progressive_frame_fn(png_structp png_ptr,
-   png_progressive_frame_ptr frame_info_fn,
-   png_progressive_frame_ptr frame_end_fn)
-{
-   png_ptr->frame_info_fn = frame_info_fn;
-   png_ptr->frame_end_fn = frame_end_fn;
-}
-#endif
-
 png_voidp PNGAPI
 png_get_progressive_ptr(png_structp png_ptr)
 {
    return png_ptr->io_ptr;
 }
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
Index: mozilla/modules/libimg/png/pngread.c
===================================================================
--- mozilla.orig/modules/libimg/png/pngread.c
+++ mozilla/modules/libimg/png/pngread.c
@@ -392,21 +392,16 @@ png_read_info(png_structp png_ptr, png_i
       PNG_tIME;
 #endif
 #if defined(PNG_READ_tRNS_SUPPORTED)
       PNG_tRNS;
 #endif
 #if defined(PNG_READ_zTXt_SUPPORTED)
       PNG_zTXt;
 #endif
-#if defined(PNG_READ_APNG_SUPPORTED)
-      PNG_acTL;
-      PNG_fcTL;
-      PNG_fdAT;
-#endif
 #endif /* PNG_USE_LOCAL_ARRAYS */
       png_byte chunk_length[4];
       png_uint_32 length;
 
       png_read_data(png_ptr, chunk_length, 4);
       length = png_get_uint_31(png_ptr,chunk_length);
 
       png_reset_crc(png_ptr);
@@ -522,107 +517,22 @@ png_read_info(png_structp png_ptr, png_i
 #if defined(PNG_READ_zTXt_SUPPORTED)
       else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
          png_handle_zTXt(png_ptr, info_ptr, length);
 #endif
 #if defined(PNG_READ_iTXt_SUPPORTED)
       else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_APNG_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_acTL, 4))
-         png_handle_acTL(png_ptr, info_ptr, length);
-      else if (!png_memcmp(png_ptr->chunk_name, png_fcTL, 4))
-         png_handle_fcTL(png_ptr, info_ptr, length);
-      else if (!png_memcmp(png_ptr->chunk_name, png_fdAT, 4))
-         png_handle_fdAT(png_ptr, info_ptr, length);
-#endif
       else
          png_handle_unknown(png_ptr, info_ptr, length);
    }
 }
 #endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
 
-#if defined(PNG_READ_APNG_SUPPORTED)
-void PNGAPI
-png_read_frame_head(png_structp png_ptr, png_infop info_ptr)
-{
-    png_byte have_chunk_after_DAT; /* after IDAT or after fdAT */
-    
-    png_debug(0, "Reading frame head\n");
-    
-    if (!(png_ptr->mode & PNG_HAVE_acTL))
-        png_error(png_ptr, "attempt to png_read_frame_head() but "
-                           "no acTL present");
-    
-    /* do nothing for the main IDAT */
-    if (png_ptr->num_frames_read == 0)
-        return;
-    
-    png_crc_finish(png_ptr, 0); /* CRC from last IDAT or fdAT chunk */
-    
-    png_read_reset(png_ptr);
-    png_ptr->mode &= ~PNG_HAVE_fcTL;
-    
-    have_chunk_after_DAT = 0;
-    for (;;)
-    {
-#ifdef PNG_USE_LOCAL_ARRAYS
-        PNG_IDAT;
-        PNG_fdAT;
-        PNG_fcTL;
-#endif
-        png_byte chunk_length[4];
-        png_uint_32 length;
-        
-        png_read_data(png_ptr, chunk_length, 4);
-        length = png_get_uint_31(png_ptr, chunk_length);
-        
-        png_reset_crc(png_ptr);
-        png_crc_read(png_ptr, png_ptr->chunk_name, 4);
-        
-        if (!png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-        {
-            /* discard trailing IDATs for the first frame */
-            if (have_chunk_after_DAT || png_ptr->num_frames_read > 1)
-                png_error(png_ptr, "png_read_frame_head(): out of place IDAT");
-            png_crc_finish(png_ptr, length);
-        }
-        else if (!png_memcmp(png_ptr->chunk_name, png_fcTL, 4))
-        {
-            png_handle_fcTL(png_ptr, info_ptr, length);
-            have_chunk_after_DAT = 1;
-        }
-        else if (!png_memcmp(png_ptr->chunk_name, png_fdAT, 4))
-        {
-            png_ensure_sequence_number(png_ptr, length);
-            
-            /* discard trailing fdATs for frames other than the first */
-            if (!have_chunk_after_DAT && png_ptr->num_frames_read > 1)
-                png_crc_finish(png_ptr, length - 4);
-            else if(png_ptr->mode & PNG_HAVE_fcTL)
-            {
-                png_ptr->idat_size = length - 4;
-                png_ptr->mode |= PNG_HAVE_IDAT;
-                
-                break;
-            }
-            else
-                png_error(png_ptr, "png_read_frame_head(): out of place fdAT");
-        }
-        else
-        {
-            png_warning(png_ptr, "Skipped (ignored) a chunk "
-                                 "between APNG chunks");
-            png_crc_finish(png_ptr, length);
-        }
-    }
-}
-#endif /* PNG_READ_APNG_SUPPORTED */
-
 /* optional call to update the users info_ptr structure */
 void PNGAPI
 png_read_update_info(png_structp png_ptr, png_infop info_ptr)
 {
    png_debug(1, "in png_read_update_info\n");
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
    else
@@ -647,20 +557,16 @@ png_start_read_image(png_structp png_ptr
 #endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
 
 #ifndef PNG_NO_SEQUENTIAL_READ_SUPPORTED
 void PNGAPI
 png_read_row(png_structp png_ptr, png_bytep row, png_bytep dsp_row)
 {
 #ifdef PNG_USE_LOCAL_ARRAYS
    PNG_IDAT;
-#if defined(PNG_READ_APNG_SUPPORTED)
-   PNG_fdAT;
-   PNG_IEND;
-#endif
    const int png_pass_dsp_mask[7] = {0xff, 0x0f, 0xff, 0x33, 0xff, 0x55, 0xff};
    const int png_pass_mask[7] = {0x80, 0x08, 0x88, 0x22, 0xaa, 0x55, 0xff};
 #endif
    int ret;
    png_debug2(1, "in png_read_row (row %lu, pass %d)\n",
       png_ptr->row_number, png_ptr->pass);
    if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))
       png_read_start_row(png_ptr);
@@ -778,56 +684,29 @@ png_read_row(png_structp png_ptr, png_by
       png_error(png_ptr, "Invalid attempt to read row data");
 
    png_ptr->zstream.next_out = png_ptr->row_buf;
    png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
    do
    {
       if (!(png_ptr->zstream.avail_in))
       {
-         png_uint_32 bytes_to_skip = 0;
-         
-         while (!png_ptr->idat_size || bytes_to_skip != 0)
+         while (!png_ptr->idat_size)
          {
             png_byte chunk_length[4];
 
-            png_crc_finish(png_ptr, bytes_to_skip);
-            bytes_to_skip = 0;
-            
+            png_crc_finish(png_ptr, 0);
+
             png_read_data(png_ptr, chunk_length, 4);
             png_ptr->idat_size = png_get_uint_31(png_ptr,chunk_length);
-            
+
             png_reset_crc(png_ptr);
             png_crc_read(png_ptr, png_ptr->chunk_name, 4);
-            
-#if defined(PNG_READ_APNG_SUPPORTED)
-            if (png_ptr->num_frames_read == 0)
-            {
-#endif
-               if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
-                  png_error(png_ptr, "Not enough image data");
-#if defined(PNG_READ_APNG_SUPPORTED)
-            }
-            else
-            {
-               if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
-                  png_error(png_ptr, "Not enough image data");
-               if (png_memcmp(png_ptr->chunk_name, png_fdAT, 4))
-               {
-                  png_warning(png_ptr, "Skipped (ignored) a chunk "
-                                       "between APNG chunks");
-                  bytes_to_skip = png_ptr->idat_size;
-                  continue;
-               }
-               
-               png_ensure_sequence_number(png_ptr, png_ptr->idat_size);
-               
-               png_ptr->idat_size -= 4;
-            }
-#endif
+            if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
+               png_error(png_ptr, "Not enough image data");
          }
          png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
          png_ptr->zstream.next_in = png_ptr->zbuf;
          if (png_ptr->zbuf_size > png_ptr->idat_size)
             png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
          png_crc_read(png_ptr, png_ptr->zbuf,
             (png_size_t)png_ptr->zstream.avail_in);
          png_ptr->idat_size -= png_ptr->zstream.avail_in;
@@ -835,19 +714,16 @@ png_read_row(png_structp png_ptr, png_by
       ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
       if (ret == Z_STREAM_END)
       {
          if (png_ptr->zstream.avail_out || png_ptr->zstream.avail_in ||
             png_ptr->idat_size)
             png_error(png_ptr, "Extra compressed data");
          png_ptr->mode |= PNG_AFTER_IDAT;
          png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
-#if defined(PNG_READ_APNG_SUPPORTED)
-         png_ptr->num_frames_read++;
-#endif
          break;
       }
       if (ret != Z_OK)
          png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
                    "Decompression error");
 
    } while (png_ptr->zstream.avail_out);
 
@@ -1089,21 +965,16 @@ png_read_end(png_structp png_ptr, png_in
       PNG_tIME;
 #endif
 #if defined(PNG_READ_tRNS_SUPPORTED)
       PNG_tRNS;
 #endif
 #if defined(PNG_READ_zTXt_SUPPORTED)
       PNG_zTXt;
 #endif
-#if defined(PNG_READ_APNG_SUPPORTED)
-      PNG_acTL;
-      PNG_fcTL;
-      PNG_fdAT;
-#endif
 #endif /* PNG_USE_LOCAL_ARRAYS */
 
       png_read_data(png_ptr, chunk_length, 4);
       length = png_get_uint_31(png_ptr,chunk_length);
 
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
 
@@ -1200,24 +1071,16 @@ png_read_end(png_structp png_ptr, png_in
 #if defined(PNG_READ_zTXt_SUPPORTED)
       else if (!png_memcmp(png_ptr->chunk_name, png_zTXt, 4))
          png_handle_zTXt(png_ptr, info_ptr, length);
 #endif
 #if defined(PNG_READ_iTXt_SUPPORTED)
       else if (!png_memcmp(png_ptr->chunk_name, png_iTXt, 4))
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
-#if defined(PNG_READ_APNG_SUPPORTED)
-      else if (!png_memcmp(png_ptr->chunk_name, png_acTL, 4))
-         png_handle_acTL(png_ptr, info_ptr, length);
-      else if (!png_memcmp(png_ptr->chunk_name, png_fcTL, 4))
-         png_handle_fcTL(png_ptr, info_ptr, length);
-      else if (!png_memcmp(png_ptr->chunk_name, png_fdAT, 4))
-         png_handle_fdAT(png_ptr, info_ptr, length);
-#endif
       else
          png_handle_unknown(png_ptr, info_ptr, length);
    } while (!(png_ptr->mode & PNG_HAVE_IEND));
 }
 #endif /* PNG_NO_SEQUENTIAL_READ_SUPPORTED */
 
 /* free all memory used by the read */
 void PNGAPI
Index: mozilla/modules/libimg/png/pngrutil.c
===================================================================
--- mozilla.orig/modules/libimg/png/pngrutil.c
+++ mozilla/modules/libimg/png/pngrutil.c
@@ -358,21 +358,16 @@ png_handle_IHDR(png_structp png_ptr, png
    width = png_get_uint_31(png_ptr, buf);
    height = png_get_uint_31(png_ptr, buf + 4);
    bit_depth = buf[8];
    color_type = buf[9];
    compression_type = buf[10];
    filter_type = buf[11];
    interlace_type = buf[12];
 
-#if defined(PNG_READ_APNG_SUPPORTED)
-   png_ptr->first_frame_width = width;
-   png_ptr->first_frame_height = height;
-#endif
-
    /* set internal variables */
    png_ptr->width = width;
    png_ptr->height = height;
    png_ptr->bit_depth = (png_byte)bit_depth;
    png_ptr->interlaced = (png_byte)interlace_type;
    png_ptr->color_type = (png_byte)color_type;
 #if defined(PNG_MNG_FEATURES_SUPPORTED)
    png_ptr->filter_type = (png_byte)filter_type;
@@ -2130,174 +2125,16 @@ png_handle_iTXt(png_structp png_ptr, png
 
    png_free(png_ptr, text_ptr);
    png_free(png_ptr, chunkdata);
    if (ret)
      png_error(png_ptr, "Insufficient memory to store iTXt chunk.");
 }
 #endif
 
-#if defined(PNG_READ_APNG_SUPPORTED)
-void /* PRIVATE */
-png_handle_acTL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-    png_byte data[8];
-    png_uint_32 num_frames;
-    png_uint_32 num_iterations;
-    png_uint_32 didSet;
-    
-    png_debug(1, "in png_handle_acTL\n");
-
-    if (!(png_ptr->mode & PNG_HAVE_IHDR))
-    {
-        png_error(png_ptr, "Missing IHDR before acTL");
-    }
-    else if (png_ptr->mode & PNG_HAVE_IDAT)
-    {
-        png_warning(png_ptr, "Invalid acTL after IDAT skipped");
-        png_crc_finish(png_ptr, length);
-        return;
-    }
-    else if (png_ptr->mode & PNG_HAVE_acTL)
-    {
-        png_warning(png_ptr, "Duplicate acTL skipped");
-        png_crc_finish(png_ptr, length);
-        return;
-    }
-    else if (length != 8)
-    {
-        png_warning(png_ptr, "acTL with invalid length skipped");
-        png_crc_finish(png_ptr, length);
-        return;
-    }
-    
-    png_crc_read(png_ptr, data, 8);
-    png_crc_finish(png_ptr, 0);
-    
-    num_frames = png_get_uint_31(png_ptr, data);
-    num_iterations = png_get_uint_31(png_ptr, data + 4);
-    
-    /* the set function will do error checking on num_frames */
-    didSet = png_set_acTL(png_ptr, info_ptr, num_frames, num_iterations);
-    if(didSet)
-    {
-        png_ptr->mode |= PNG_HAVE_acTL;
-        
-        /* if there is an fcTL this flag will be unset in png_handle_fcTL() */
-        if (num_frames > 1)
-            png_ptr->apng_flags |= PNG_FIRST_FRAME_HIDDEN;
-    }
-}
-
-void /* PRIVATE */
-png_handle_fcTL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-    png_byte data[21];
-    png_uint_32 width;
-    png_uint_32 height;
-    png_uint_32 x_offset;
-    png_uint_32 y_offset;
-    png_uint_16 delay_num;
-    png_uint_16 delay_den;
-    png_byte render_op;
-    
-    png_debug(1, "in png_handle_fcTL\n");
-    
-    if (!(png_ptr->mode & PNG_HAVE_IHDR))
-    {
-        png_error(png_ptr, "Missing IHDR before fcTL");
-    }
-    else if (png_ptr->mode & PNG_HAVE_IDAT)
-    {
-        /* for any frames other then the first this message may be misleading,
-        * but correct. PNG_HAVE_IDAT is unset before the frame head is read
-        * i can't think of a better message */
-        png_warning(png_ptr, "Invalid fcTL after IDAT skipped");
-        png_crc_finish(png_ptr, length);
-        return;
-    }
-    else if (png_ptr->mode & PNG_HAVE_fcTL)
-    {
-        png_warning(png_ptr, "Duplicate fcTL within one frame skipped");
-        png_crc_finish(png_ptr, length);
-        return;
-    }
-    else if (length != 25)
-    {
-        png_warning(png_ptr, "fcTL with invalid length skipped");
-        png_crc_finish(png_ptr, length);
-        return;
-    }
-    
-    png_ensure_sequence_number(png_ptr, length);
-    
-    png_crc_read(png_ptr, data, 21);
-    png_crc_finish(png_ptr, 0);
-    
-    width = png_get_uint_31(png_ptr, data);
-    height = png_get_uint_31(png_ptr, data + 4);
-    x_offset = png_get_uint_31(png_ptr, data + 8);
-    y_offset = png_get_uint_31(png_ptr, data + 12);
-    delay_num = png_get_uint_16(data + 16);
-    delay_den = png_get_uint_16(data + 18);
-    render_op = data[20];
-    
-    if (png_ptr->num_frames_read == 0 && (x_offset != 0 || y_offset != 0))
-        png_error(png_ptr, "fcTL for the first frame must have zero offset");
-    if (png_ptr->num_frames_read == 0 && 
-        (width != info_ptr->width || height != info_ptr->height))
-        png_error(png_ptr, "size in first frame's fcTL must match "
-                           "the size in IHDR");
-    
-    /* the set function will do more error checking */
-    png_set_next_frame_fcTL(png_ptr, info_ptr, width, height, 
-                            x_offset, y_offset, delay_num, delay_den,
-                            render_op);
-    
-    png_read_reinit(png_ptr, info_ptr);
-    
-    png_ptr->mode |= PNG_HAVE_fcTL;
-    
-    png_ptr->apng_flags &= ~PNG_FIRST_FRAME_HIDDEN;
-}
-
-void /* PRIVATE */
-png_handle_fdAT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-{
-    png_ensure_sequence_number(png_ptr, length);
-    
-    /* This function is only called from png_read_end(), png_read_info(), 
-    * and png_push_read_chunk() which means that:
-    * - the user doesn't want to read this frame
-    * - or this is an out-of-place fdAT
-    * in either case it is safe to ignore the chunk with a warning */
-    png_warning(png_ptr, "ignoring fdAT chunk");
-    png_crc_finish(png_ptr, length - 4);
-}
-
-void /* PRIVATE */
-png_ensure_sequence_number(png_structp png_ptr, png_uint_32 length)
-{
-    png_byte data[4];
-    png_uint_32 sequence_number;
-    
-    if (length < 4)
-        png_error(png_ptr, "invalid fcTL or fdAT chunk found");
-    
-    png_crc_read(png_ptr, data, 4);
-    sequence_number = png_get_uint_31(png_ptr, data);
-    
-    if (sequence_number != png_ptr->next_seq_num)
-        png_error(png_ptr, "fcTL or fdAT chunk with out-of-order sequence "
-                           "number found");
-    
-    png_ptr->next_seq_num++;
-}
-#endif /* PNG_READ_APNG_SUPPORTED */
-
 /* This function is called when we haven't found a handler for a
    chunk.  If there isn't a problem with the chunk itself (ie bad
    chunk name, CRC, or a critical chunk), the chunk is silently ignored
    -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which
    case it will be saved away to be written out later. */
 void /* PRIVATE */
 png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
@@ -3252,20 +3089,18 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
    /* calculate the maximum bytes needed, adding a byte and a pixel
       for safety's sake */
    row_bytes = PNG_ROWBYTES(max_pixel_depth,row_bytes) +
       1 + ((max_pixel_depth + 7) >> 3);
 #ifdef PNG_MAX_MALLOC_64K
    if (row_bytes > (png_uint_32)65536L)
       png_error(png_ptr, "This image requires a row greater than 64KB");
 #endif
-   if (png_ptr->big_row_buf == NULL)
-      png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
-   if (png_ptr->row_buf == NULL)
-      png_ptr->row_buf = png_ptr->big_row_buf+32;
+   png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
+   png_ptr->row_buf = png_ptr->big_row_buf+32;
 #if defined(PNG_DEBUG) && defined(PNG_USE_PNGGCCRD)
    png_ptr->row_buf_size = row_bytes;
 #endif
 
 #ifdef PNG_MAX_MALLOC_64K
    if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
       png_error(png_ptr, "This image requires a row greater than 64KB");
 #endif
@@ -3280,87 +3115,9 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
    png_debug1(3, "height = %lu,\n", png_ptr->height);
    png_debug1(3, "iwidth = %lu,\n", png_ptr->iwidth);
    png_debug1(3, "num_rows = %lu\n", png_ptr->num_rows);
    png_debug1(3, "rowbytes = %lu,\n", png_ptr->rowbytes);
    png_debug1(3, "irowbytes = %lu,\n", png_ptr->irowbytes);
 
    png_ptr->flags |= PNG_FLAG_ROW_INIT;
 }
-
-#if defined(PNG_READ_APNG_SUPPORTED)
-/* This function is to be called after the main IDAT set has been read and
- * before a new IDAT is read. It resets some parts of png_ptr
- * to make them usable by the read functions again */
-void /* PRIVATE */
-png_read_reset(png_structp png_ptr)
-{
-    png_ptr->mode &= ~PNG_HAVE_IDAT;
-    png_ptr->mode &= ~PNG_AFTER_IDAT;
-    png_ptr->row_number = 0;
-    png_ptr->pass = 0;
-    png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-
-void /* PRIVATE */
-png_read_reinit(png_structp png_ptr, png_infop info_ptr)
-{
-    png_ptr->width = info_ptr->next_frame_width;
-    png_ptr->height = info_ptr->next_frame_height;
-    png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->width);
-}
-
-/* same as png_read_reset() but for the progressive reader */
-void /* PRIVATE */
-png_progressive_read_reset(png_structp png_ptr)
-{
-#ifdef PNG_USE_LOCAL_ARRAYS
-    /* start of interlace block */
-    const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
-
-    /* offset to next interlace block */
-    const int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
-
-    /* start of interlace block in the y direction */
-    const int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
-
-    /* offset to next interlace block in the y direction */
-    const int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
-#endif
-    png_uint_32 row_bytes;
-    
-    if (png_ptr->interlaced)
-    {
-        if (!(png_ptr->transformations & PNG_INTERLACE))
-            png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
-                                png_pass_ystart[0]) / png_pass_yinc[0];
-        else
-           png_ptr->num_rows = png_ptr->height;
-
-        png_ptr->iwidth = (png_ptr->width +
-                           png_pass_inc[png_ptr->pass] - 1 -
-                           png_pass_start[png_ptr->pass]) /
-                           png_pass_inc[png_ptr->pass];
-
-        row_bytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->iwidth) + 1;
-
-        png_ptr->irowbytes = (png_size_t)row_bytes;
-        if((png_uint_32)png_ptr->irowbytes != row_bytes)
-            png_error(png_ptr, "png_progressive_read_reset(): Rowbytes "
-                               "overflow");
-    }
-    else
-    {
-        png_ptr->num_rows = png_ptr->height;
-        png_ptr->iwidth = png_ptr->width;
-        png_ptr->irowbytes = png_ptr->rowbytes + 1;
-    }
-    
-    png_ptr->flags &= ~PNG_FLAG_ZLIB_FINISHED;
-    if (inflateReset(&(png_ptr->zstream)) != Z_OK)
-        png_error(png_ptr, "inflateReset failed");
-    png_ptr->zstream.avail_in = 0;
-    png_ptr->zstream.next_in = 0;
-    png_ptr->zstream.next_out = png_ptr->row_buf;
-    png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
-}
-#endif /* PNG_READ_APNG_SUPPORTED */
 #endif /* PNG_READ_SUPPORTED */
Index: mozilla/modules/libimg/png/pngset.c
===================================================================
--- mozilla.orig/modules/libimg/png/pngset.c
+++ mozilla/modules/libimg/png/pngset.c
@@ -357,21 +357,16 @@ png_set_IHDR(png_structp png_ptr, png_in
                  >> 3)      /* 8-byte RGBA pixels */
                  - 64       /* bigrowbuf hack */
                  - 1        /* filter byte */
                  - 7*8      /* rounding of width to multiple of 8 pixels */
                  - 8)       /* extra max_pixel_depth pad */
       info_ptr->rowbytes = (png_size_t)0;
    else
       info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth,width);
-   
-#if defined(PNG_APNG_SUPPORTED)
-   /* for non-animated png. this may be overritten from an acTL chunk later */
-   info_ptr->num_frames = 1;
-#endif
 }
 
 #if defined(PNG_oFFs_SUPPORTED)
 void PNGAPI
 png_set_oFFs(png_structp png_ptr, png_infop info_ptr,
    png_int_32 offset_x, png_int_32 offset_y, int unit_type)
 {
    png_debug1(1, "in %s storage function\n", "oFFs");
@@ -993,131 +988,16 @@ png_set_sPLT(png_structp png_ptr,
     info_ptr->splt_palettes_num += nentries;
     info_ptr->valid |= PNG_INFO_sPLT;
 #ifdef PNG_FREE_ME_SUPPORTED
     info_ptr->free_me |= PNG_FREE_SPLT;
 #endif
 }
 #endif /* PNG_sPLT_SUPPORTED */
 
-#if defined(PNG_APNG_SUPPORTED)
-png_uint_32 PNGAPI
-png_set_acTL(png_structp png_ptr, png_infop info_ptr, 
-    png_uint_32 num_frames, png_uint_32 num_iterations)
-{
-    png_debug1(1, "in %s storage function\n", "acTL");
-
-    if (png_ptr == NULL || info_ptr == NULL)
-    {
-        png_warning(png_ptr, 
-                    "Call to png_set_acTL() with NULL png_ptr "
-                    "or info_ptr ignored");
-        return (0);
-    }
-    if(num_frames == 0)
-    {
-        png_warning(png_ptr, 
-                    "Ignoring attempt to set acTL with num_frames zero");
-        return (0);
-    }
-    if(num_frames > PNG_UINT_31_MAX)
-    {
-        png_warning(png_ptr, 
-                    "Ignoring attempt to set acTL with num_frames > 2^31-1");
-        return (0);
-    }
-    if(num_iterations > PNG_UINT_31_MAX)
-    {
-        png_warning(png_ptr, 
-                    "Ignoring attempt to set acTL with num_iterations "
-                    "> 2^31-1");
-        return (0);
-    }
-    
-    info_ptr->num_frames = num_frames;
-    info_ptr->num_iterations = num_iterations;
-    
-    info_ptr->valid |= PNG_INFO_acTL;
-    
-    return (1);
-}
-
-/* delay_num and delay_den can hold any values including zero */
-png_uint_32 PNGAPI
-png_set_next_frame_fcTL(png_structp png_ptr, png_infop info_ptr, 
-    png_uint_32 width, png_uint_32 height,
-    png_uint_32 x_offset, png_uint_32 y_offset,
-    png_uint_16 delay_num, png_uint_16 delay_den,
-    png_byte render_op)
-{
-    png_debug1(1, "in %s storage function\n", "fcTL");
-
-    if (png_ptr == NULL || info_ptr == NULL)
-    {
-        png_warning(png_ptr, 
-                    "Call to png_set_fcTL() with NULL png_ptr or info_ptr "
-                    "ignored");
-        return (0);
-    }
-    
-    png_ensure_fcTL_is_valid(png_ptr, width, height, x_offset, y_offset, 
-                             delay_num, delay_den, render_op);
-    
-    info_ptr->next_frame_width = width;
-    info_ptr->next_frame_height = height;
-    info_ptr->next_frame_x_offset = x_offset;
-    info_ptr->next_frame_y_offset = y_offset;
-    info_ptr->next_frame_delay_num = delay_num;
-    info_ptr->next_frame_delay_den = delay_den;
-    info_ptr->next_frame_render_op = render_op;
-    
-    info_ptr->valid |= PNG_INFO_fcTL;
-    
-    return (1);
-}
-
-void /* PRIVATE */
-png_ensure_fcTL_is_valid(png_structp png_ptr, 
-    png_uint_32 width, png_uint_32 height,
-    png_uint_32 x_offset, png_uint_32 y_offset,
-    png_uint_16 delay_num, png_uint_16 delay_den,
-    png_byte render_op)
-{
-    if (width > png_ptr->first_frame_width || 
-        height > png_ptr->first_frame_height)
-        png_error(png_ptr, "width and/or height for a frame greater than"
-                           "the ones in IHDR");
-    if (width > PNG_UINT_31_MAX)
-        png_error(png_ptr, "invalid width in fcTL (> 2^31-1)");
-    if (height > PNG_UINT_31_MAX)
-        png_error(png_ptr, "invalid height in fcTL (> 2^31-1)");
-    if (x_offset > PNG_UINT_31_MAX)
-        png_error(png_ptr, "invalid x_offset in fcTL (> 2^31-1)");
-    if (y_offset > PNG_UINT_31_MAX)
-        png_error(png_ptr, "invalid y_offset in fcTL (> 2^31-1)");
-    if (render_op & 0xF0)
-        /* Bits 4 through 7 are reserved and must be set to zero (APNG spec) */
-        png_error(png_ptr, "invalid render_op in fcTL");
-    if (render_op & 0x08 && png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
-        png_error(png_ptr, "APNG_RENDER_OP_BLEND_FLAG is not valid for "
-                           "color type 'greyscale without alpha'");
-    if ((render_op & 0x08) && 
-        (png_ptr->color_type & PNG_COLOR_MASK_COLOR) &&
-        !(png_ptr->color_type & PNG_COLOR_MASK_ALPHA))
-        png_error(png_ptr, "APNG_RENDER_OP_BLEND_FLAG is not valid for "
-                           "color type 'truecolor without alpha'");
-    if (!(render_op & PNG_RENDER_OP_DISPOSE_MASK))
-        png_error(png_ptr, "no DISPOSE_ flag found in fcTL");
-    if ( (render_op & PNG_RENDER_OP_DISPOSE_MASK) != PNG_RENDER_OP_DISPOSE_NONE && 
-         (render_op & PNG_RENDER_OP_DISPOSE_MASK) != PNG_RENDER_OP_DISPOSE_BACKGROUND && 
-         (render_op & PNG_RENDER_OP_DISPOSE_MASK) != PNG_RENDER_OP_DISPOSE_PREVIOUS)
-        png_error(png_ptr, "multiple DISPOSE_ flags set in fcTL");
-}
-#endif /* PNG_APNG_SUPPORTED */
-
 #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
 void PNGAPI
 png_set_unknown_chunks(png_structp png_ptr,
    png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns)
 {
     png_unknown_chunkp np;
     int i;
 
Index: mozilla/modules/libimg/png/pngwrite.c
===================================================================
--- mozilla.orig/modules/libimg/png/pngwrite.c
+++ mozilla/modules/libimg/png/pngwrite.c
@@ -256,20 +256,16 @@ png_write_info(png_structp png_ptr, png_
 #else
          png_warning(png_ptr, "Unable to write uncompressed text");
 #endif
          /* Mark this chunk as written */
          info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
       }
    }
 #endif
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-   if (info_ptr->valid & PNG_INFO_acTL)
-      png_write_acTL(png_ptr, info_ptr->num_frames, info_ptr->num_iterations);
-#endif
 #if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
    if (info_ptr->unknown_chunks_num)
    {
        png_unknown_chunk *up;
 
        png_debug(5, "writing extra chunks\n");
 
        for (up = info_ptr->unknown_chunks;
@@ -298,20 +294,16 @@ png_write_info(png_structp png_ptr, png_
 void PNGAPI
 png_write_end(png_structp png_ptr, png_infop info_ptr)
 {
    png_debug(1, "in png_write_end\n");
    if (png_ptr == NULL)
       return;
    if (!(png_ptr->mode & PNG_HAVE_IDAT))
       png_error(png_ptr, "No IDATs written into file");
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-   if (png_ptr->num_frames_written != png_ptr->num_frames_to_write)
-      png_error(png_ptr, "Not enough frames written");
-#endif
 
    /* see if user wants us to write information chunks */
    if (info_ptr != NULL)
    {
 #if defined(PNG_WRITE_TEXT_SUPPORTED)
       int i; /* local index variable */
 #endif
 #if defined(PNG_WRITE_tIME_SUPPORTED)
@@ -1513,43 +1505,9 @@ png_write_png(png_structp png_ptr, png_i
 
    /* It is REQUIRED to call this to finish writing the rest of the file */
    png_write_end(png_ptr, info_ptr);
 
    if(transforms == 0 || params == NULL)
       /* quiet compiler warnings */ return;
 }
 #endif
-
-#if defined(PNG_WRITE_APNG_SUPPORTED)
-void PNGAPI
-png_write_frame_head(png_structp png_ptr, png_infop info_ptr,
-    png_bytepp row_pointers, png_uint_32 width, png_uint_32 height, 
-    png_uint_32 x_offset, png_uint_32 y_offset, 
-    png_uint_16 delay_num, png_uint_16 delay_den, png_byte render_op,
-    png_byte first_frame_hidden)
-{
-    png_debug(1, "in png_write_frame_head\n");
-    
-    /* there is a chance this has been set after png_write_info was called,
-    * so it would be set but not written. is there a way to be sure? */
-    if (!(info_ptr->valid & PNG_INFO_acTL))
-        png_error(png_ptr, "png_write_frame_head(): acTL not set");
-    
-    png_write_reset(png_ptr);
-    
-    png_write_reinit(png_ptr, info_ptr, width, height);
-    
-    if ( !(png_ptr->num_frames_written == 0 && first_frame_hidden) )
-        png_write_fcTL(png_ptr, width, height, x_offset, y_offset, 
-                       delay_num, delay_den, render_op);
-}
-
-void PNGAPI
-png_write_frame_tail(png_structp png_ptr, png_infop png_info)
-{
-    png_debug(1, "in png_write_frame_tail\n");
-    
-    png_ptr->num_frames_written++;
-}
-#endif /* PNG_WRITE_APNG_SUPPORTED */
-
 #endif /* PNG_WRITE_SUPPORTED */
Index: mozilla/modules/libpr0n/build/nsImageModule.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/build/nsImageModule.cpp
+++ mozilla/modules/libpr0n/build/nsImageModule.cpp
@@ -56,16 +56,17 @@
 #include "imgCache.h"
 #include "imgContainer.h"
 #include "imgLoader.h"
 #include "imgRequest.h"
 #include "imgRequestProxy.h"
 
 #ifdef IMG_BUILD_DECODER_gif
 // gif
+#include "imgContainerGIF.h"
 #include "nsGIFDecoder2.h"
 #endif
 
 #ifdef IMG_BUILD_DECODER_bmp
 // bmp/ico
 #include "nsBMPDecoder.h"
 #include "nsICODecoder.h"
 #endif
@@ -100,16 +101,17 @@
 
 NS_GENERIC_FACTORY_CONSTRUCTOR(imgCache)
 NS_GENERIC_FACTORY_CONSTRUCTOR(imgContainer)
 NS_GENERIC_FACTORY_CONSTRUCTOR(imgLoader)
 NS_GENERIC_FACTORY_CONSTRUCTOR(imgRequestProxy)
 
 #ifdef IMG_BUILD_DECODER_gif
 // gif
+NS_GENERIC_FACTORY_CONSTRUCTOR(imgContainerGIF)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsGIFDecoder2)
 #endif
 
 #ifdef IMG_BUILD_DECODER_jpeg
 // jpeg
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsJPEGDecoder)
 #endif
 #ifdef IMG_BUILD_ENCODER_jpeg
@@ -215,16 +217,20 @@ static const nsModuleComponentInfo compo
     ImageUnregisterProc, },
   { "image request proxy",
     NS_IMGREQUESTPROXY_CID,
     "@mozilla.org/image/request;1",
     imgRequestProxyConstructor, },
 
 #ifdef IMG_BUILD_DECODER_gif
   // gif
+  { "GIF image container",
+    NS_GIFCONTAINER_CID,
+    "@mozilla.org/image/container;1?type=image/gif",
+    imgContainerGIFConstructor, },
   { "GIF Decoder",
      NS_GIFDECODER2_CID,
      "@mozilla.org/image/decoder;2?type=image/gif",
      nsGIFDecoder2Constructor, },
 #endif
 
 #ifdef IMG_BUILD_DECODER_jpeg
   // jpeg
Index: mozilla/modules/libpr0n/decoders/gif/GIF2.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/gif/GIF2.cpp
+++ mozilla/modules/libpr0n/decoders/gif/GIF2.cpp
@@ -629,21 +629,21 @@ PRStatus gif_write(gif_struct *gs, const
     {
       if (*q & 0x1) {
         gs->tpixel = q[3];
         gs->is_transparent = PR_TRUE;
       } else {
         gs->is_transparent = PR_FALSE;
         // ignoring gfx control extension
       }
-      gs->disposal_method = ((*q) >> 2) & 0x7;
+      gs->disposal_method = (gdispose)(((*q) >> 2) & 0x7);
       // Some specs say 3rd bit (value 4), other specs say value 3
       // Let's choose 3 (the more popular)
       if (gs->disposal_method == 4)
-        gs->disposal_method = 3;
+        gs->disposal_method = (gdispose)3;
       gs->delay_time = GETINT16(q + 1) * 10;
       GETN(1, gif_consume_block);
     }
     break;
 
     case gif_comment_extension:
     {
       if (*q)
Index: mozilla/modules/libpr0n/decoders/gif/GIF2.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/gif/GIF2.h
+++ mozilla/modules/libpr0n/decoders/gif/GIF2.h
@@ -67,16 +67,26 @@ typedef enum {
     gif_error,
     gif_comment_extension,
     gif_application_extension,
     gif_netscape_extension_block,
     gif_consume_netscape_extension,
     gif_consume_comment
 } gstate;
 
+/* "Disposal" method indicates how the image should be handled in the
+   framebuffer before the subsequent image is displayed. */
+typedef enum
+{
+    DISPOSE_NOT_SPECIFIED      = 0,
+    DISPOSE_KEEP               = 1, /* Leave it in the framebuffer */
+    DISPOSE_OVERWRITE_BGCOLOR  = 2, /* Overwrite with background color */
+    DISPOSE_OVERWRITE_PREVIOUS = 3  /* Save-under */
+} gdispose;
+
 /* A GIF decoder's state */
 typedef struct gif_struct {
     void* clientptr;
     /* Parsing state machine */
     gstate state;                   /* Curent decoder master state */
     PRUint32 bytes_to_consume;      /* Number of bytes to accumulate */
     PRUint32 bytes_in_hold;         /* bytes accumulated so far*/
 
@@ -100,17 +110,17 @@ typedef struct gif_struct {
     PRUint8 *rowbuf;              /* Single scanline temporary buffer */
     PRUint8 *rowend;              /* Pointer to end of rowbuf */
     PRUint8 *rowp;                /* Current output pointer */
 
     /* Parameters for image frame currently being decoded*/
     PRUintn x_offset, y_offset;    /* With respect to "screen" origin */
     PRUintn height, width;
     int tpixel;                 /* Index of transparent pixel */
-    PRInt32 disposal_method;    /* Restore to background, leave in place, etc.*/
+    gdispose disposal_method;   /* Restore to background, leave in place, etc.*/
     PRUint8 *local_colormap;    /* Per-image colormap */
     int local_colormap_size;    /* Size of local colormap array. */
     PRUint32 delay_time;        /* Display time, in milliseconds,
                                    for this image in a multi-image GIF */
 
     /* Global (multi-image) state */
     int screen_bgcolor;         /* Logical screen background color */
     int version;                /* Either 89 for GIF89 or 87 for GIF87 */
Index: mozilla/modules/libpr0n/decoders/gif/Makefile.in
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/gif/Makefile.in
+++ mozilla/modules/libpr0n/decoders/gif/Makefile.in
@@ -51,16 +51,13 @@ LIBXUL_LIBRARY = 1
 REQUIRES	= xpcom \
 		  string \
 		  gfx \
 		  thebes \
 		  cairo \
 		  imglib2 \
 		  $(NULL)
 
-CPPSRCS		= GIF2.cpp nsGIFDecoder2.cpp
-
-# nsGIFDecoder2.cpp includes imgContainer.h
-LOCAL_INCLUDES += -I$(topsrcdir)/modules/libpr0n/src
+CPPSRCS		= GIF2.cpp nsGIFDecoder2.cpp imgContainerGIF.cpp
 
 include $(topsrcdir)/config/rules.mk
 
 CXXFLAGS += $(MOZ_CAIRO_CFLAGS)
Index: mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp
+++ mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.cpp
@@ -43,17 +43,16 @@
 #include "nsIInputStream.h"
 #include "nsIComponentManager.h"
 #include "nsRecyclingAllocator.h"
 
 #include "imgIContainerObserver.h"
 
 #include "imgILoad.h"
 
-#include "imgContainer.h"
 
 /*******************************************************************************
  * Gif decoder allocator
  *
  * For every image that gets loaded, we allocate a 'gif_struct'
  * This allocator tries to keep one set of these around
  * and reuses them; automatically fails over to use calloc/free when all
  * buckets are full.
@@ -98,17 +97,17 @@ nsGIFDecoder2::~nsGIFDecoder2(void)
 //******************************************************************************
 
 //******************************************************************************
 /* void init (in imgILoad aLoad); */
 NS_IMETHODIMP nsGIFDecoder2::Init(imgILoad *aLoad)
 {
   mObserver = do_QueryInterface(aLoad);
 
-  mImageContainer = do_CreateInstance("@mozilla.org/image/container;1");
+  mImageContainer = do_CreateInstance("@mozilla.org/image/container;1?type=image/gif");
   aLoad->SetImage(mImageContainer);
   
   if (!gGifAllocator) {
     gGifAllocator = new nsRecyclingAllocator(kGifAllocatorNBucket,
                                              NS_DEFAULT_RECYCLE_TIMEOUT, "gif");
     if (!gGifAllocator)
       return NS_ERROR_FAILURE;
   }
@@ -253,17 +252,17 @@ NS_IMETHODIMP nsGIFDecoder2::WriteFrom(n
       return NS_ERROR_FAILURE;
   }
 
   return rv;
 }
 
 
 //******************************************************************************
-// GIF decoder callback methods. Part of public API for GIF2
+// GIF decoder callback methods. Part of pulic API for GIF2
 //******************************************************************************
 
 //******************************************************************************
 int nsGIFDecoder2::BeginGIF(
   void*    aClientData,
   PRUint32 aLogicalScreenWidth, 
   PRUint32 aLogicalScreenHeight,
   PRUint8  aBackgroundRGBIndex)
@@ -471,17 +470,17 @@ int nsGIFDecoder2::HaveDecodedRow(
     }
     if (decoder->mGIFStruct->is_local_colormap_defined) {
       cmapsize = decoder->mGIFStruct->local_colormap_size;
       cmap = decoder->mGIFStruct->local_colormap;
     }
 
     if (!cmap) { // cmap could have null value if the global color table flag is 0
       for (int i = 0; i < aDuplicateCount; ++i) {
-        imgContainer::BlackenFrame(decoder->mImageFrame, 0, aRowNumber+i, width, 1);
+        imgContainerGIF::BlackenFrame(decoder->mImageFrame, 0, aRowNumber+i, width, 1);
       }
     } else {
       PRUint8* rowBufIndex = aRowBufPtr;
       PRUint32 *rgbRowIndex = (PRUint32*)decoder->mRGBLine;
 
       PRInt32 tpixel =
         decoder->mGIFStruct->is_transparent ? decoder->mGIFStruct->tpixel : -1;
 
Index: mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/gif/nsGIFDecoder2.h
+++ mozilla/modules/libpr0n/decoders/gif/nsGIFDecoder2.h
@@ -37,17 +37,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef _nsGIFDecoder2_h
 #define _nsGIFDecoder2_h
 
 #include "nsCOMPtr.h"
 #include "imgIDecoder.h"
-#include "imgIContainer.h"
+#include "imgContainerGIF.h"
 #include "imgIDecoderObserver.h"
 #include "gfxIImageFrame.h"
 
 #include "GIF2.h"
 
 #define NS_GIFDECODER2_CID \
 { /* 797bec5a-1dd2-11b2-a7f8-ca397e0179c4 */         \
      0x797bec5a,                                     \
Index: mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.cpp
@@ -17,17 +17,16 @@
  *
  * The Initial Developer of the Original Code is
  * Netscape Communications Corporation.
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Stuart Parmenter <stuart@mozilla.com>
- *   Andrew Smith
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
@@ -51,104 +50,42 @@
 #include "nsIInterfaceRequestorUtils.h"
 
 #include "gfxColor.h"
 #include "nsColor.h"
 
 #include "nspr.h"
 #include "png.h"
 
-// for nsPNGDecoder.apngFlags
-enum { 
-  FRAME_HIDDEN         = 0x01
-};
-
 static void PNGAPI info_callback(png_structp png_ptr, png_infop info_ptr);
 static void PNGAPI row_callback(png_structp png_ptr, png_bytep new_row,
                            png_uint_32 row_num, int pass);
-static void PNGAPI frame_info_callback(png_structp png_ptr, png_uint_32 frame_num);
 static void PNGAPI end_callback(png_structp png_ptr, png_infop info_ptr);
 static void PNGAPI error_callback(png_structp png_ptr, png_const_charp error_msg);
 static void PNGAPI warning_callback(png_structp png_ptr, png_const_charp warning_msg);
 
 #ifdef PR_LOGGING
 PRLogModuleInfo *gPNGLog = PR_NewLogModule("PNGDecoder");
 #endif
 
 NS_IMPL_ISUPPORTS1(nsPNGDecoder, imgIDecoder)
 
 nsPNGDecoder::nsPNGDecoder() :
   mPNG(nsnull), mInfo(nsnull),
-  apngFlags(0),
   interlacebuf(nsnull), ibpr(0),
   mError(PR_FALSE)
 {
 }
 
 nsPNGDecoder::~nsPNGDecoder()
 {
   if (interlacebuf)
     nsMemory::Free(interlacebuf);
 }
 
-// CreateFrame() is used for both simple and animated images
-void nsPNGDecoder::CreateFrame(png_uint_32 x_offset, png_uint_32 y_offset, 
-                                PRInt32 width, PRInt32 height, gfx_format format)
-{
-  mFrame = do_CreateInstance("@mozilla.org/gfx/image/frame;2");
-  if (!mFrame)
-    longjmp(mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
-
-  nsresult rv = mFrame->Init(x_offset, y_offset, width, height, format, 24);
-  if (NS_FAILED(rv))
-    longjmp(mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
-
-  if (png_get_valid(mPNG, mInfo, PNG_INFO_acTL))
-    SetAnimFrameInfo();
-  
-  mImage->AppendFrame(mFrame);
-  
-  if (mObserver)
-    mObserver->OnStartFrame(nsnull, mFrame);
-}
-
-// set timeout and frame disposal method for the current frame
-void nsPNGDecoder::SetAnimFrameInfo()
-{
-  png_uint_16 delay_num, delay_den; /* in seconds */
-  png_byte dispose_op;
-  PRInt32 timeout; /* in milliseconds */
-  
-  delay_num = png_get_next_frame_delay_num(mPNG, mInfo);
-  delay_den = png_get_next_frame_delay_den(mPNG, mInfo);
-  dispose_op = png_get_next_frame_dispose_op(mPNG, mInfo);
-
-  // XXX need to handle blend_op here!
-
-  if (delay_num == 0) {
-    timeout = 0; // gfxImageFrame::SetTimeout() will set to a minimum
-  } else {
-    if (delay_den == 0)
-      delay_den = 100; // so sais the APNG spec
-    
-    // Need to cast delay_num to float to have a proper division and
-    // the result to int to avoid compiler warning
-    timeout = NS_STATIC_CAST( PRInt32,
-              NS_STATIC_CAST(PRFloat64, delay_num) * 1000 / delay_den );
-  }
-  mFrame->SetTimeout(timeout);
-  
-  if (dispose_op == PNG_DISPOSE_OP_PREVIOUS)
-      mFrame->SetFrameDisposalMethod(imgIContainer::kDisposeRestorePrevious);
-  else if (dispose_op == PNG_DISPOSE_OP_BACKGROUND)
-      mFrame->SetFrameDisposalMethod(imgIContainer::kDisposeClear);
-  else
-      mFrame->SetFrameDisposalMethod(imgIContainer::kDisposeKeep);
-}
-
 
 /** imgIDecoder methods **/
 
 /* void init (in imgILoad aLoad); */
 NS_IMETHODIMP nsPNGDecoder::Init(imgILoad *aLoad)
 {
 #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
   static png_byte unused_chunks[]=
@@ -271,29 +208,30 @@ void
 info_callback(png_structp png_ptr, png_infop info_ptr)
 {
 /*  int number_passes;   NOT USED  */
   png_uint_32 width, height;
   int bit_depth, color_type, interlace_type, compression_type, filter_type;
   int channels;
   double aGamma;
 
-  png_bytep trans = NULL;
-  int num_trans = 0;
-
-  nsPNGDecoder *decoder = NS_STATIC_CAST(nsPNGDecoder*, png_get_progressive_ptr(png_ptr));
+  png_bytep trans=NULL;
+  int num_trans =0;
 
   /* always decode to 24-bit RGB or 32-bit RGBA  */
   png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
                &interlace_type, &compression_type, &filter_type);
-  
+
   /* limit image dimensions (bug #251381) */
 #define MOZ_PNG_MAX_DIMENSION 1000000L
-  if (width > MOZ_PNG_MAX_DIMENSION || height > MOZ_PNG_MAX_DIMENSION)
+  if (width > MOZ_PNG_MAX_DIMENSION || height > MOZ_PNG_MAX_DIMENSION) {
+    nsPNGDecoder *decoder = NS_STATIC_CAST(nsPNGDecoder*,
+                                           png_get_progressive_ptr(png_ptr));
     longjmp(decoder->mPNG->jmpbuf, 1);
+  }
 #undef MOZ_PNG_MAX_DIMENSION
 
   if (color_type == PNG_COLOR_TYPE_PALETTE)
     png_set_expand(png_ptr);
 
   if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
     png_set_expand(png_ptr);
 
@@ -349,74 +287,73 @@ info_callback(png_structp png_ptr, png_i
           }
         }
       }
     } else {
       alpha_bits = 8;
     }
   }
 
+  nsPNGDecoder *decoder = NS_STATIC_CAST(nsPNGDecoder*, png_get_progressive_ptr(png_ptr));
+
   if (decoder->mObserver)
     decoder->mObserver->OnStartDecode(nsnull);
 
   decoder->mImage = do_CreateInstance("@mozilla.org/image/container;1");
   if (!decoder->mImage)
     longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
 
   decoder->mImageLoad->SetImage(decoder->mImage);
 
+  // since the png is only 1 frame, initialize the container to the width and height of the frame
   decoder->mImage->Init(width, height, decoder->mObserver);
 
   if (decoder->mObserver)
     decoder->mObserver->OnStartContainer(nsnull, decoder->mImage);
 
+  decoder->mFrame = do_CreateInstance("@mozilla.org/gfx/image/frame;2");
+  if (!decoder->mFrame)
+    longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
+
+  gfx_format format;
+
   if (channels == 3) {
-    decoder->format = gfxIFormats::RGB;
+    format = gfxIFormats::RGB;
   } else if (channels > 3) {
     if (alpha_bits == 8) {
-      decoder->mImage->GetPreferredAlphaChannelFormat(&(decoder->format));
+      decoder->mImage->GetPreferredAlphaChannelFormat(&format);
     } else if (alpha_bits == 1) {
-      decoder->format = gfxIFormats::RGB_A1;
+      format = gfxIFormats::RGB_A1;
     }
   }
 
-  if (png_get_valid(png_ptr, info_ptr, PNG_INFO_acTL))
-    png_set_progressive_frame_fn(png_ptr, frame_info_callback, NULL);
-  
-  if (png_first_frame_is_hidden(png_ptr, info_ptr)) {
-    decoder->apngFlags |= FRAME_HIDDEN;
-    
-    // create a frame just to get bpr, to allocate interlacebuf
-    decoder->mFrame = do_CreateInstance("@mozilla.org/gfx/image/frame;2");
-    if (!decoder->mFrame)
-      longjmp(png_ptr->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
-    nsresult rv = decoder->mFrame->Init(0, 0, width, height, decoder->format, 24);
-    if (NS_FAILED(rv))
-      longjmp(png_ptr->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
-  } else {
-    decoder->CreateFrame(0, 0, width, height, decoder->format);
-  }
-  
+  // then initialize the frame and append it to the container
+  nsresult rv = decoder->mFrame->Init(0, 0, width, height, format, 24);
+  if (NS_FAILED(rv))
+    longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
+
+  decoder->mImage->AppendFrame(decoder->mFrame);
+
+  if (decoder->mObserver)
+    decoder->mObserver->OnStartFrame(nsnull, decoder->mFrame);
+
   PRUint32 bpr;
   decoder->mFrame->GetImageBytesPerRow(&bpr);
 
   if (interlace_type == PNG_INTERLACE_ADAM7) {
     if (channels > 3)
       decoder->ibpr = channels*width;
     else
       decoder->ibpr = bpr;
     decoder->interlacebuf = (PRUint8 *)nsMemory::Alloc(decoder->ibpr*height);
     if (!decoder->interlacebuf) {
       longjmp(decoder->mPNG->jmpbuf, 5); // NS_ERROR_OUT_OF_MEMORY
-    }
+    }
   }
-  
-  if (png_first_frame_is_hidden(png_ptr, info_ptr))
-    decoder->mFrame = nsnull;
-  
+
   return;
 }
 
 void
 row_callback(png_structp png_ptr, png_bytep new_row,
              png_uint_32 row_num, int pass)
 {
   /* libpng comments:
@@ -442,21 +379,16 @@ row_callback(png_structp png_ptr, png_by
    * where old_row is what was displayed for previous rows.  Note
    * that the first pass (pass == 0 really) will completely cover
    * the old row, so the rows do not have to be initialized.  After
    * the first pass (and only for interlaced images), you will have
    * to pass the current row, and the function will combine the
    * old row and the new row.
    */
   nsPNGDecoder *decoder = NS_STATIC_CAST(nsPNGDecoder*, png_get_progressive_ptr(png_ptr));
-  
-  // do nothing
-  // is it ok that we're not telling the observer there is some data?
-  if (decoder->apngFlags & FRAME_HIDDEN)
-    return;
 
   png_bytep line;
   if (decoder->interlacebuf) {
     line = decoder->interlacebuf+(row_num*decoder->ibpr);
     png_progressive_combine_row(png_ptr, line, new_row);
   }
   else
     line = new_row;
@@ -507,42 +439,17 @@ row_callback(png_structp png_ptr, png_by
 
     nsIntRect r(0, row_num, width, 1);
     nsCOMPtr<nsIImage> img(do_GetInterface(decoder->mFrame));
     img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
     decoder->mObserver->OnDataAvailable(nsnull, decoder->mFrame, &r);
   }
 }
 
-// got the header of a new frame that's coming
-void
-frame_info_callback(png_structp png_ptr, png_uint_32 frame_num)
-{
-  png_uint_32 x_offset, y_offset;
-  PRInt32 width, height;
-  
-  nsPNGDecoder *decoder = NS_STATIC_CAST(nsPNGDecoder*, png_get_progressive_ptr(png_ptr));
-  
-  // old frame is done
-  if (!(decoder->apngFlags & FRAME_HIDDEN)) {
-    PRInt32 timeout;
-    decoder->mFrame->GetTimeout(&timeout);
-    decoder->mImage->EndFrameDecode(frame_num, timeout);
-    decoder->mObserver->OnStopFrame(nsnull, decoder->mFrame);
-  }
-  
-  decoder->apngFlags &= ~FRAME_HIDDEN;
-  
-  x_offset = png_get_next_frame_x_offset(png_ptr, decoder->mInfo);
-  y_offset = png_get_next_frame_y_offset(png_ptr, decoder->mInfo);
-  width = png_get_next_frame_width(png_ptr, decoder->mInfo);
-  height = png_get_next_frame_height(png_ptr, decoder->mInfo);
-  
-  decoder->CreateFrame(x_offset, y_offset, width, height, decoder->format);
-}
+
 
 void
 end_callback(png_structp png_ptr, png_infop info_ptr)
 {
   /* libpng comments:
    *
    * this function is called when the whole image has been read,
    * including any chunks after the image (up to and including
@@ -550,39 +457,26 @@ end_callback(png_structp png_ptr, png_in
    * had in the header, although some data may have been added
    * to the comments and time fields.
    *
    * Most people won't do much here, perhaps setting a flag that
    * marks the image as finished.
    */
 
   nsPNGDecoder *decoder = NS_STATIC_CAST(nsPNGDecoder*, png_get_progressive_ptr(png_ptr));
-  
-  if (png_get_valid(png_ptr, info_ptr, PNG_INFO_acTL)) {
-    PRInt32 num_iterations = png_get_num_iterations(png_ptr, info_ptr);
-    if (num_iterations <= 0) /* forever */
-      num_iterations = -1;
-    
-    decoder->mImage->SetLoopCount(num_iterations);
-  }
-  
-  if (!(decoder->apngFlags & FRAME_HIDDEN)) {
-    PRInt32 timeout;
-    decoder->mFrame->GetTimeout(&timeout);
-    decoder->mImage->EndFrameDecode(decoder->mPNG->num_frames_read, timeout);
-  }
-  
-  decoder->mImage->DecodingComplete();
-  
+
   if (decoder->mObserver) {
-    if (!(decoder->apngFlags & FRAME_HIDDEN))
-      decoder->mObserver->OnStopFrame(nsnull, decoder->mFrame);
+    decoder->mObserver->OnStopFrame(nsnull, decoder->mFrame);
     decoder->mObserver->OnStopContainer(nsnull, decoder->mImage);
     decoder->mObserver->OnStopDecode(nsnull, NS_OK, nsnull);
   }
+
+  // We are never going to change the data of this frame again.  Let the OS
+  // do what it wants with this image.
+  decoder->mFrame->SetMutable(PR_FALSE);
 }
 
 
 void
 error_callback(png_structp png_ptr, png_const_charp error_msg)
 {
   PR_LOG(gPNGLog, PR_LOG_ERROR, ("libpng error: %s\n", error_msg));
   longjmp(png_ptr->jmpbuf, 1);
Index: mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h
===================================================================
--- mozilla.orig/modules/libpr0n/decoders/png/nsPNGDecoder.h
+++ mozilla/modules/libpr0n/decoders/png/nsPNGDecoder.h
@@ -64,28 +64,22 @@ class nsPNGDecoder : public imgIDecoder
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_IMGIDECODER
 
   nsPNGDecoder();
   virtual ~nsPNGDecoder();
 
-  void CreateFrame(png_uint_32 x_offset, png_uint_32 y_offset, 
-                    PRInt32 width, PRInt32 height, gfx_format format);
-  void SetAnimFrameInfo();
-  
 public:
   nsCOMPtr<imgIContainer> mImage;
   nsCOMPtr<gfxIImageFrame> mFrame;
   nsCOMPtr<imgILoad> mImageLoad;
   nsCOMPtr<imgIDecoderObserver> mObserver; // this is just qi'd from mRequest for speed
 
   png_structp mPNG;
   png_infop mInfo;
-  gfx_format format;
-  PRUint8 apngFlags;
   PRUint8 *interlacebuf;
   PRUint32 ibpr;
   PRPackedBool mError;
 };
 
 #endif // nsPNGDecoder_h__
Index: mozilla/modules/libpr0n/public/imgIContainer.idl
===================================================================
--- mozilla.orig/modules/libpr0n/public/imgIContainer.idl
+++ mozilla/modules/libpr0n/public/imgIContainer.idl
@@ -49,29 +49,16 @@ interface imgIContainerObserver;
  *
  * @author Stuart Parmenter <pavlov@netscape.com>
  * @version 0.1
  * @see "gfx2"
  */
 [scriptable, uuid(1a6290e6-8285-4e10-963d-d001f8d327b8)]
 interface imgIContainer : nsISupports
 {
-  /** 
-   * "Disposal" method indicates how the image should be handled before the
-   *  subsequent image is displayed.
-   *  Don't change these without looking at the implementations using them,
-   *  struct gif_struct::disposal_method and gif_write() in particular.
-   */
-  const long kDisposeClearAll         = -1; // Clear the whole image, revealing
-                                            // what was there before the gif displayed
-  const long kDisposeNotSpecified     =  0; // Leave frame, let new frame draw on top
-  const long kDisposeKeep             =  1; // Leave frame, let new frame draw on top
-  const long kDisposeClear            =  2; // Clear the frame's area, revealing bg
-  const long kDisposeRestorePrevious  =  3; // Restore the previous (composited) frame
-  
   /**
    * Create a new \a aWidth x \a aHeight sized image container.
    *
    * @param aWidth The width of the container in which all the
    *               gfxIImageFrame children will fit.
    * @param aHeight The height of the container in which all the
    *                gfxIImageFrame children will fit.
    * @param aObserver Observer to send animation notifications to.
@@ -134,14 +121,16 @@ interface imgIContainer : nsISupports
   void clear();
 
   void startAnimation();
 
   void stopAnimation();
 
   void resetAnimation();
 
+  /* animation stuff */
+
   /**
    * number of times to loop the image.
    * @note -1 means forever.
    */
   attribute long loopCount;
 };
Index: mozilla/modules/libpr0n/public/imgIRequest.idl
===================================================================
--- mozilla.orig/modules/libpr0n/public/imgIRequest.idl
+++ mozilla/modules/libpr0n/public/imgIRequest.idl
@@ -42,17 +42,17 @@
 
 interface imgIContainer;
 interface imgIDecoderObserver;
 interface nsIURI;
 
 /**
  * imgIRequest interface
  *
- * @author Stuart Parmenter <stuart@mozilla.com>
+ * @author Stuart Parmenter <pavlov@netscape.com>
  * @version 0.1
  * @see imagelib2
  */
 [scriptable, uuid(ccf705f6-1dd1-11b2-82ef-e18eccf7f7ec)]
 interface imgIRequest : nsIRequest
 {
   /**
    * the image container...
Index: mozilla/modules/libpr0n/src/Makefile.in
===================================================================
--- mozilla.orig/modules/libpr0n/src/Makefile.in
+++ mozilla/modules/libpr0n/src/Makefile.in
@@ -49,18 +49,16 @@ MODULE_NAME	= nsImageLib2Module
 GRE_MODULE	= 1
 LIBXUL_LIBRARY  = 1
 
 REQUIRES	= xpcom \
 		  string \
 		  necko \
 		  nkcache \
 		  gfx \
-		  thebes \
-		  cairo \
 		  $(NULL)
 
 CPPSRCS		= \
 			imgCache.cpp     \
 			imgContainer.cpp \
 			imgLoader.cpp    \
 			imgRequest.cpp   \
 			imgRequestProxy.cpp
Index: mozilla/modules/libpr0n/src/imgContainer.cpp
===================================================================
--- mozilla.orig/modules/libpr0n/src/imgContainer.cpp
+++ mozilla/modules/libpr0n/src/imgContainer.cpp
@@ -19,89 +19,74 @@
  * Portions created by the Initial Developer are Copyright (C) 2001
  * the Initial Developer. All Rights Reserved.
  *
  * Contributor(s):
  *   Stuart Parmenter <pavlov@netscape.com>
  *   Chris Saari <saari@netscape.com>
  *   Asko Tontti <atontti@cc.hut.fi>
  *   Arron Mogge <paper@animecity.nu>
- *   Andrew Smith
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  * in which case the provisions of the GPL or the LGPL are applicable instead
  * of those above. If you wish to allow use of your version of this file only
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsComponentManagerUtils.h"
-#include "imgIContainerObserver.h"
-#include "nsIImage.h"
-#include "imgContainer.h"
-#include "nsIInterfaceRequestor.h"
-#include "nsIInterfaceRequestorUtils.h"
-#include "nsAutoPtr.h"
 
-#include "gfxContext.h"
+#include "imgContainer.h"
 
-NS_IMPL_ISUPPORTS3(imgContainer, imgIContainer, nsITimerCallback, nsIProperties)
+NS_IMPL_ISUPPORTS2(imgContainer, imgIContainer, nsIProperties)
 
 //******************************************************************************
 imgContainer::imgContainer() :
   mSize(0,0),
-  mAnim(nsnull),
-  mAnimationMode(kNormalAnimMode),
-  mLoopCount(-1),
-  mObserver(nsnull)
+  mFrame(nsnull)
 {
   mProperties = do_CreateInstance("@mozilla.org/properties;1");
 }
 
 //******************************************************************************
 imgContainer::~imgContainer()
 {
-  if (mAnim)
-    delete mAnim;
+  mFrame = nsnull;
 }
 
 //******************************************************************************
-/* void init (in PRInt32 aWidth, in PRInt32 aHeight, 
-              in imgIContainerObserver aObserver); */
-NS_IMETHODIMP imgContainer::Init(PRInt32 aWidth, PRInt32 aHeight,
-                                 imgIContainerObserver *aObserver)
+/* void init (in PRIn32 aWidth, in PRInt32 aHeight, in imgIContainerObserver aObserver); */
+NS_IMETHODIMP imgContainer::Init(PRInt32 aWidth, PRInt32 aHeight, imgIContainerObserver *aObserver)
 {
   if (aWidth <= 0 || aHeight <= 0) {
     NS_WARNING("error - negative image size\n");
     return NS_ERROR_FAILURE;
   }
 
   mSize.SizeTo(aWidth, aHeight);
-  
-  mObserver = do_GetWeakReference(aObserver);
-  
+
   return NS_OK;
 }
 
 //******************************************************************************
 /* readonly attribute gfx_format preferredAlphaChannelFormat; */
 NS_IMETHODIMP imgContainer::GetPreferredAlphaChannelFormat(gfx_format *aFormat)
 {
   NS_ASSERTION(aFormat, "imgContainer::GetPreferredAlphaChannelFormat; Invalid Arg");
   if (!aFormat)
     return NS_ERROR_INVALID_ARG;
 
-  /* default.. platforms should probably overwrite this */
+  /* default.. platform's should probably overwrite this */
   *aFormat = gfxIFormats::RGB_A8;
   return NS_OK;
 }
 
 //******************************************************************************
 /* readonly attribute PRInt32 width; */
 NS_IMETHODIMP imgContainer::GetWidth(PRInt32 *aWidth)
 {
@@ -127,929 +112,147 @@ NS_IMETHODIMP imgContainer::GetHeight(PR
 
 //******************************************************************************
 /* readonly attribute gfxIImageFrame currentFrame; */
 NS_IMETHODIMP imgContainer::GetCurrentFrame(gfxIImageFrame **aCurrentFrame)
 {
   NS_ASSERTION(aCurrentFrame, "imgContainer::GetCurrentFrame; Invalid Arg");
   if (!aCurrentFrame)
     return NS_ERROR_INVALID_POINTER;
-  
-  if (!(*aCurrentFrame = inlinedGetCurrentFrame()))
-    return NS_ERROR_FAILURE;
 
-  NS_ADDREF(*aCurrentFrame);
-  
-  return NS_OK;
+  if (mFrame) {
+    *aCurrentFrame = mFrame;
+    NS_ADDREF(*aCurrentFrame);
+    return NS_OK;
+  } else {
+    *aCurrentFrame = nsnull;
+    return NS_ERROR_FAILURE;
+  }
 }
 
 //******************************************************************************
 /* readonly attribute unsigned long numFrames; */
 NS_IMETHODIMP imgContainer::GetNumFrames(PRUint32 *aNumFrames)
 {
   NS_ASSERTION(aNumFrames, "imgContainer::GetNumFrames; Invalid Arg");
   if (!aNumFrames)
     return NS_ERROR_INVALID_ARG;
 
-  *aNumFrames = mFrames.Count();
-  
+  *aNumFrames = mFrame ? 1 : 0;
   return NS_OK;
 }
 
 //******************************************************************************
 /* gfxIImageFrame getFrameAt (in unsigned long index); */
 NS_IMETHODIMP imgContainer::GetFrameAt(PRUint32 index, gfxIImageFrame **_retval)
 {
-  NS_ENSURE_ARG(index < NS_STATIC_CAST(PRUint32, mFrames.Count()));
-  
   NS_ASSERTION(_retval, "imgContainer::GetFrameAt; Invalid Arg");
   if (!_retval)
     return NS_ERROR_INVALID_POINTER;
 
-  if (!(*_retval = mFrames[index]))
+  if (!mFrame || index != 0)
     return NS_ERROR_FAILURE;
-
+  *_retval = mFrame;
   NS_ADDREF(*_retval);
-  
   return NS_OK;
 }
 
 //******************************************************************************
 /* void appendFrame (in gfxIImageFrame item); */
 NS_IMETHODIMP imgContainer::AppendFrame(gfxIImageFrame *item)
 {
   NS_ASSERTION(item, "imgContainer::AppendFrame; Invalid Arg");
   if (!item)
     return NS_ERROR_INVALID_ARG;
-  
-  PRInt32 numFrames = mFrames.Count();
-  
-  if (numFrames == 0) {
-    // This may not be an animated image, don't do all the animation stuff.
-    mFrames.AppendObject(item);
-    return NS_OK;
-  }
-  
-  if (numFrames == 1) {
-    // Now that we got a second frame, initialize animation stuff.
-    if (!ensureAnimExists())
-      return NS_ERROR_OUT_OF_MEMORY;
-    
-    // If we dispose of the first frame by clearing it, then the
-    // First Frame's refresh area is all of itself.
-    // RESTORE_PREVIOUS is invalid (assumed to be DISPOSE_CLEAR)
-    PRInt32 frameDisposalMethod;
-    mFrames[0]->GetFrameDisposalMethod(&frameDisposalMethod);
-    if (frameDisposalMethod == imgIContainer::kDisposeClear ||
-        frameDisposalMethod == imgIContainer::kDisposeRestorePrevious)
-      mFrames[0]->GetRect(mAnim->firstFrameRefreshArea);
-  }
-  
-  // Calculate firstFrameRefreshArea
-  // Some gifs are huge but only have a small area that they animate
-  // We only need to refresh that small area when Frame 0 comes around again
-  nsIntRect itemRect;
-  item->GetRect(itemRect);
-  mAnim->firstFrameRefreshArea.UnionRect(mAnim->firstFrameRefreshArea, 
-                                         itemRect);
-  
-  mFrames.AppendObject(item);
-  
-  // If this is our second frame, start the animation.
-  // Must be called after AppendObject because StartAnimation checks for > 1
-  // frame
-  if (numFrames == 1)
-    StartAnimation();
-  
+  NS_ASSERTION(!mFrame, "imgContainer::AppendFrame; Tried to add another frame when only 1 is allowed");
+
+  if (mFrame)
+    return NS_ERROR_UNEXPECTED;
+
+  mFrame = item;
   return NS_OK;
 }
 
 //******************************************************************************
 /* void removeFrame (in gfxIImageFrame item); */
 NS_IMETHODIMP imgContainer::RemoveFrame(gfxIImageFrame *item)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 //******************************************************************************
-/* void endFrameDecode (in unsigned long framenumber, in unsigned long timeout); */
+/* void endFrameDecode (in gfxIImageFrame item, in unsigned long timeout); */
 NS_IMETHODIMP imgContainer::EndFrameDecode(PRUint32 aFrameNum, PRUint32 aTimeout)
 {
-  // Assume there's another frame.
-  // currentDecodingFrameIndex is 0 based, aFrameNum is 1 based
-  if (mAnim)
-    mAnim->currentDecodingFrameIndex = aFrameNum;
-  
+  NS_ASSERTION(aFrameNum == 0, "Received an EndFrameDecode call with an invalid frame number");
+
+  if (aFrameNum != 0 || !mFrame)
+    return NS_ERROR_UNEXPECTED;
+
+  mFrame->SetTimeout(aTimeout);
+
   return NS_OK;
 }
 
 //******************************************************************************
 /* void decodingComplete (); */
 NS_IMETHODIMP imgContainer::DecodingComplete(void)
 {
-  if (mAnim)
-    mAnim->doneDecoding = PR_TRUE;
-  // If there's only 1 frame, optimize it.
-  // Optimizing animated images is not supported
-  if (mFrames.Count() == 1)
-    mFrames[0]->SetMutable(PR_FALSE);
   return NS_OK;
 }
 
 //******************************************************************************
 /* void clear (); */
 NS_IMETHODIMP imgContainer::Clear()
 {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  mFrame = nsnull;
+  return NS_OK;
 }
 
 //******************************************************************************
-/* attribute unsigned short animationMode; */
 NS_IMETHODIMP imgContainer::GetAnimationMode(PRUint16 *aAnimationMode)
 {
   NS_ASSERTION(aAnimationMode, "imgContainer::GetAnimationMode; Invalid Arg");
   if (!aAnimationMode)
     return NS_ERROR_INVALID_ARG;
-  
-  *aAnimationMode = mAnimationMode;
+
+  *aAnimationMode = kDontAnimMode;
   return NS_OK;
 }
 
-//******************************************************************************
-/* attribute unsigned short animationMode; */
 NS_IMETHODIMP imgContainer::SetAnimationMode(PRUint16 aAnimationMode)
 {
-  NS_ASSERTION(aAnimationMode == imgIContainer::kNormalAnimMode ||
-               aAnimationMode == imgIContainer::kDontAnimMode ||
-               aAnimationMode == imgIContainer::kLoopOnceAnimMode,
-               "Wrong Animation Mode is being set!");
-  
-  switch (mAnimationMode = aAnimationMode) {
-    case kDontAnimMode:
-      StopAnimation();
-      break;
-    case kNormalAnimMode:
-      if (mLoopCount != 0 || 
-          (mAnim && (mAnim->currentAnimationFrameIndex + 1 < mFrames.Count())))
-        StartAnimation();
-      break;
-    case kLoopOnceAnimMode:
-      if (mAnim && (mAnim->currentAnimationFrameIndex + 1 < mFrames.Count()))
-        StartAnimation();
-      break;
-  }
-  
+  // Ignore setting of animation mode
   return NS_OK;
 }
 
 //******************************************************************************
 /* void startAnimation () */
 NS_IMETHODIMP imgContainer::StartAnimation()
 {
-  if (mAnimationMode == kDontAnimMode || 
-      (mAnim && (mAnim->timer || mAnim->animating)))
-    return NS_OK;
-  
-  if (mFrames.Count() > 1) {
-    if (!ensureAnimExists())
-      return NS_ERROR_OUT_OF_MEMORY;
-    
-    PRInt32 timeout;
-    gfxIImageFrame *currentFrame = inlinedGetCurrentFrame();
-    if (currentFrame) {
-      currentFrame->GetTimeout(&timeout);
-      if (timeout <= 0) // -1 means display this frame forever
-        return NS_OK;
-    } else
-      timeout = 100; // XXX hack.. the timer notify code will do the right
-                     //     thing, so just get that started
-    
-    mAnim->timer = do_CreateInstance("@mozilla.org/timer;1");
-    if (!mAnim->timer)
-      return NS_ERROR_OUT_OF_MEMORY;
-    
-    // The only way animating becomes true is if the timer is created
-    mAnim->animating = PR_TRUE;
-    mAnim->timer->InitWithCallback(NS_STATIC_CAST(nsITimerCallback*, this),
-                                   timeout, nsITimer::TYPE_REPEATING_SLACK);
-  }
-  
   return NS_OK;
 }
 
 //******************************************************************************
 /* void stopAnimation (); */
 NS_IMETHODIMP imgContainer::StopAnimation()
 {
-  if (mAnim) {
-    mAnim->animating = PR_FALSE;
-
-    if (!mAnim->timer)
-      return NS_OK;
-
-    mAnim->timer->Cancel();
-    mAnim->timer = nsnull;
-  }
-
   return NS_OK;
 }
 
 //******************************************************************************
-/* void resetAnimation (); */
-NS_IMETHODIMP imgContainer::ResetAnimation()
-{
-  if (mAnimationMode == kDontAnimMode || 
-      !mAnim || mAnim->currentAnimationFrameIndex)
-    return NS_OK;
-
-  PRBool oldAnimating = mAnim->animating;
-
-  if (mAnim->animating) {
-    nsresult rv = StopAnimation();
-    if (NS_FAILED(rv))
-      return rv;
-  }
-
-  mAnim->lastCompositedFrameIndex = -1;
-  mAnim->currentAnimationFrameIndex = 0;
-  // Update display
-  nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
-  if (observer)
-    observer->FrameChanged(this, mFrames[0], &(mAnim->firstFrameRefreshArea));
-
-  if (oldAnimating)
-    return StartAnimation();
-  else
-    return NS_OK;
-}
-
-//******************************************************************************
 /* attribute long loopCount; */
 NS_IMETHODIMP imgContainer::GetLoopCount(PRInt32 *aLoopCount)
 {
-  NS_ASSERTION(aLoopCount, "imgContainer::GetLoopCount() called with null ptr");
-  if (!aLoopCount)
-    return NS_ERROR_INVALID_ARG;
-  
-  *aLoopCount = mLoopCount;
-  
-  return NS_OK;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-//******************************************************************************
-/* attribute long loopCount; */
 NS_IMETHODIMP imgContainer::SetLoopCount(PRInt32 aLoopCount)
 {
-  // -1  infinite
-  //  0  no looping, one iteration
-  //  1  one loop, two iterations
-  //  ...
-  mLoopCount = aLoopCount;
-
-  return NS_OK;
-}
-
-//******************************************************************************
-/* void notify(in nsITimer timer); */
-NS_IMETHODIMP imgContainer::Notify(nsITimer *timer)
-{
-  // This should never happen since the timer is only set up in StartAnimation()
-  // after mAnim is checked to exist.
-  NS_ASSERTION(mAnim, "imgContainer::Notify() called but mAnim is null");
-  if (!mAnim)
-    return NS_ERROR_UNEXPECTED;
-  NS_ASSERTION(mAnim->timer == timer,
-               "imgContainer::Notify() called with incorrect timer");
-
-  if (!(mAnim->animating) || !(mAnim->timer))
-    return NS_OK;
-
-  nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
-  if (!observer) {
-    // the imgRequest that owns us is dead, we should die now too.
-    StopAnimation();
-    return NS_OK;
-  }
-
-  PRInt32 numFrames = mFrames.Count();
-  if (!numFrames)
-    return NS_OK;
-  
-  gfxIImageFrame *nextFrame = nsnull;
-  PRInt32 previousFrameIndex = mAnim->currentAnimationFrameIndex;
-  PRInt32 nextFrameIndex = mAnim->currentAnimationFrameIndex + 1;
-  PRInt32 timeout = 0;
-
-  // If we're done decoding the next frame, go ahead and display it now and
-  // reinit the timer with the next frame's delay time.
-  // currentDecodingFrameIndex is not set until the second frame has
-  // finished decoding (see EndFrameDecode)
-  if (mAnim->doneDecoding || 
-      (numFrames == 2 && nextFrameIndex < 2) ||
-      (numFrames > 2 && nextFrameIndex < mAnim->currentDecodingFrameIndex)) {
-    if (numFrames == nextFrameIndex) {
-      // End of Animation
-
-      // If animation mode is "loop once", it's time to stop animating
-      if (mAnimationMode == kLoopOnceAnimMode || mLoopCount == 0) {
-        StopAnimation();
-        return NS_OK;
-      } else {
-        // We may have used compositingFrame to build a frame, and then copied
-        // it back into mFrames[..].  If so, delete composite to save memory
-        if (mAnim->compositingFrame && mAnim->lastCompositedFrameIndex == -1)
-          mAnim->compositingFrame = nsnull;
-      }
-
-      nextFrameIndex = 0;
-      if (mLoopCount > 0)
-        mLoopCount--;
-    }
-
-    if (!(nextFrame = mFrames[nextFrameIndex])) {
-      // something wrong with the next frame, skip it
-      mAnim->currentAnimationFrameIndex = nextFrameIndex;
-      mAnim->timer->SetDelay(100);
-      return NS_OK;
-    }
-    nextFrame->GetTimeout(&timeout);
-
-  } else if ((numFrames == 2 && nextFrameIndex == 2) ||
-             (numFrames > 2 && nextFrameIndex == mAnim->currentDecodingFrameIndex)) {
-    // Uh oh, the frame we want to show is currently being decoded (partial)
-    // Wait a bit and try again
-    mAnim->timer->SetDelay(100);
-    return NS_OK;
-  } else { //  (nextFrameIndex > currentDecodingFrameIndex)
-    // We shouldn't get here. However, if we are requesting a frame
-    // that hasn't been decoded yet, go back to the last frame decoded
-    NS_WARNING("imgContainer::Notify()  Frame is passed decoded frame");
-    nextFrameIndex = mAnim->currentDecodingFrameIndex;
-    if (!(nextFrame = mFrames[nextFrameIndex])) {
-      // something wrong with the next frame, skip it
-      mAnim->currentAnimationFrameIndex = nextFrameIndex;
-      mAnim->timer->SetDelay(100);
-      return NS_OK;
-    }
-    nextFrame->GetTimeout(&timeout);
-  }
-
-  if (timeout > 0)
-    mAnim->timer->SetDelay(timeout);
-  else
-    StopAnimation();
-
-  nsIntRect dirtyRect;
-  gfxIImageFrame *frameToUse = nsnull;
-
-  if (nextFrameIndex == 0) {
-    frameToUse = nextFrame;
-    dirtyRect = mAnim->firstFrameRefreshArea;
-  } else {
-    gfxIImageFrame *prevFrame = mFrames[previousFrameIndex];
-    if (!prevFrame)
-      return NS_OK;
-
-    // Change frame and announce it
-    if (NS_FAILED(DoComposite(&frameToUse, &dirtyRect, prevFrame,
-                              nextFrame, nextFrameIndex))) {
-      // something went wrong, move on to next
-      NS_WARNING("imgContainer::Notify(): Composing Frame Failed\n");
-      mAnim->currentAnimationFrameIndex = nextFrameIndex;
-      return NS_OK;
-    }
-  }
-  // Set currentAnimationFrameIndex at the last possible moment
-  mAnim->currentAnimationFrameIndex = nextFrameIndex;
-  // Refreshes the screen
-  observer->FrameChanged(this, frameToUse, &dirtyRect);
-  
-  return NS_OK;
-}
-
-//******************************************************************************
-// DoComposite gets called when the timer for animation get fired and we have to
-// update the composited frame of the animation.
-nsresult imgContainer::DoComposite(gfxIImageFrame** aFrameToUse,
-                                   nsIntRect* aDirtyRect,
-                                   gfxIImageFrame* aPrevFrame,
-                                   gfxIImageFrame* aNextFrame,
-                                   PRInt32 aNextFrameIndex)
-{
-  NS_ASSERTION(aDirtyRect, "imgContainer::DoComposite aDirtyRect is null");
-  NS_ASSERTION(aPrevFrame, "imgContainer::DoComposite aPrevFrame is null");
-  NS_ASSERTION(aNextFrame, "imgContainer::DoComposite aNextFrame is null");
-  NS_ASSERTION(aFrameToUse, "imgContainer::DoComposite aFrameToUse is null");
-  
-  PRInt32 prevFrameDisposalMethod;
-  aPrevFrame->GetFrameDisposalMethod(&prevFrameDisposalMethod);
-
-  if (prevFrameDisposalMethod == imgIContainer::kDisposeRestorePrevious &&
-      !mAnim->compositingPrevFrame)
-    prevFrameDisposalMethod = imgIContainer::kDisposeClear;
-
-  // Optimization: Skip compositing if the previous frame wants to clear the
-  //               whole image
-  if (prevFrameDisposalMethod == imgIContainer::kDisposeClearAll) {
-    aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
-    *aFrameToUse = aNextFrame;
-    return NS_OK;
-  }
-
-  nsIntRect prevFrameRect;
-  aPrevFrame->GetRect(prevFrameRect);
-  PRBool isFullPrevFrame = (prevFrameRect.x == 0 && prevFrameRect.y == 0 &&
-                            prevFrameRect.width == mSize.width &&
-                            prevFrameRect.height == mSize.height);
-
-  // Optimization: Skip compositing if the previous frame is the same size as
-  //               container and it's clearing itself
-  if (isFullPrevFrame && prevFrameDisposalMethod == imgIContainer::kDisposeClear) {
-    aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
-    *aFrameToUse = aNextFrame;
-    return NS_OK;
-  }
-
-  PRInt32 nextFrameDisposalMethod;
-  nsIntRect nextFrameRect;
-  aNextFrame->GetFrameDisposalMethod(&nextFrameDisposalMethod);
-  aNextFrame->GetRect(nextFrameRect);
-  PRBool isFullNextFrame = (nextFrameRect.x == 0 && nextFrameRect.y == 0 &&
-                            nextFrameRect.width == mSize.width &&
-                            nextFrameRect.height == mSize.height);
-
-  PRBool nextFrameHasAlpha;
-  PRUint32 aBPR;
-  nextFrameHasAlpha = NS_SUCCEEDED(aNextFrame->GetAlphaBytesPerRow(&aBPR));
-
-  // Optimization: Skip compositing if this frame is the same size as the
-  //               container and it's fully drawing over prev frame (no alpha)
-  if (isFullNextFrame &&
-      (nextFrameDisposalMethod != imgIContainer::kDisposeRestorePrevious) &&
-      !nextFrameHasAlpha) {
-
-    aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
-    *aFrameToUse = aNextFrame;
-    return NS_OK;
-  }
-
-  // Calculate area that needs updating
-  switch (prevFrameDisposalMethod) {
-    default:
-    case imgIContainer::kDisposeNotSpecified:
-    case imgIContainer::kDisposeKeep:
-      *aDirtyRect = nextFrameRect;
-      break;
-
-    case imgIContainer::kDisposeClear:
-      // Calc area that needs to be redrawn (the combination of previous and
-      // this frame)
-      // XXX - This could be done with multiple framechanged calls
-      //       Having prevFrame way at the top of the image, and nextFrame
-      //       way at the bottom, and both frames being small, we'd be
-      //       telling framechanged to refresh the whole image when only two
-      //       small areas are needed.
-      aDirtyRect->UnionRect(nextFrameRect, prevFrameRect);
-      break;
-
-    case imgIContainer::kDisposeRestorePrevious:
-      aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
-      break;
-  }
-
-  // Optimization:
-  //   Skip compositing if the last composited frame is this frame
-  //   (Only one composited frame was made for this animation.  Example:
-  //    Only Frame 3 of a 10 frame image required us to build a composite frame
-  //    On the second loop, we do not need to rebuild the frame
-  //    since it's still sitting in compositingFrame)
-  if (mAnim->lastCompositedFrameIndex == aNextFrameIndex) {
-    *aFrameToUse = mAnim->compositingFrame;
-    return NS_OK;
-  }
-
-  PRBool needToBlankComposite = PR_FALSE;
-
-  // Create the Compositing Frame
-  if (!mAnim->compositingFrame) {
-    nsresult rv;
-    mAnim->compositingFrame = do_CreateInstance("@mozilla.org/gfx/image/frame;2", &rv);
-    if (NS_FAILED(rv))
-      return rv;
-    rv = mAnim->compositingFrame->Init(0, 0, mSize.width, mSize.height,
-                                       gfxIFormats::RGB_A1, 24);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to init compositingFrame!\n");
-      mAnim->compositingFrame = nsnull;
-      return rv;
-    }
-    needToBlankComposite = PR_TRUE;
-  }
-
-  // Copy previous frame into compositingFrame before we put the new frame on top
-  // Assumes that the previous frame represents a full frame (it could be
-  // smaller in size than the container, as long as the frame before it erased
-  // itself)
-  // Note: Frame 1 never gets into DoComposite(), so (aNextFrameIndex - 1) will
-  // always be a valid frame number.
-  if (mAnim->lastCompositedFrameIndex != aNextFrameIndex - 1 &&
-      prevFrameDisposalMethod != imgIContainer::kDisposeRestorePrevious) {
-
-    // XXX If we had a method of drawing a section of a frame into another, we
-    //     could optimize further:
-    //     if aPrevFrameIndex == 1 && lastCompositedFrameIndex <> -1,
-    //     only firstFrameRefreshArea needs to be drawn back to composite
-    if (isFullPrevFrame) {
-      CopyFrameImage(aPrevFrame, mAnim->compositingFrame);
-    } else {
-      BlackenFrame(mAnim->compositingFrame);
-      SetMaskVisibility(mAnim->compositingFrame, PR_FALSE);
-      aPrevFrame->DrawTo(mAnim->compositingFrame, prevFrameRect.x, prevFrameRect.y,
-                         prevFrameRect.width, prevFrameRect.height);
-
-      BuildCompositeMask(mAnim->compositingFrame, aPrevFrame);
-      needToBlankComposite = PR_FALSE;
-    }
-  }
-
-  // Dispose of previous
-  switch (prevFrameDisposalMethod) {
-    case imgIContainer::kDisposeClear:
-      if (needToBlankComposite) {
-        // If we just created the composite, it could have anything in it's
-        // buffers. Clear them
-        BlackenFrame(mAnim->compositingFrame);
-        SetMaskVisibility(mAnim->compositingFrame, PR_FALSE);
-        needToBlankComposite = PR_FALSE;
-      } else {
-        // Blank out previous frame area (both color & Mask/Alpha)
-        BlackenFrame(mAnim->compositingFrame, prevFrameRect);
-        SetMaskVisibility(mAnim->compositingFrame, prevFrameRect, PR_FALSE);
-      }
-      break;
-
-    case imgIContainer::kDisposeRestorePrevious:
-      // It would be better to copy only the area changed back to
-      // compositingFrame.
-      if (mAnim->compositingPrevFrame) {
-        CopyFrameImage(mAnim->compositingPrevFrame, mAnim->compositingFrame);
-
-        // destroy only if we don't need it for this frame's disposal
-        if (nextFrameDisposalMethod != imgIContainer::kDisposeRestorePrevious)
-          mAnim->compositingPrevFrame = nsnull;
-      } else {
-        BlackenFrame(mAnim->compositingFrame);
-        SetMaskVisibility(mAnim->compositingFrame, PR_FALSE);
-      }
-      break;
-  }
-
-  // Check if the frame we are composing wants the previous image restored afer
-  // it is done. Don't store it (again) if last frame wanted it's image restored
-  // too
-  if ((nextFrameDisposalMethod == imgIContainer::kDisposeRestorePrevious) &&
-      (prevFrameDisposalMethod != imgIContainer::kDisposeRestorePrevious)) {
-    // We are storing the whole image.
-    // It would be better if we just stored the area that nextFrame is going to
-    // overwrite.
-    if (!mAnim->compositingPrevFrame) {
-      nsresult rv;
-      mAnim->compositingPrevFrame = do_CreateInstance("@mozilla.org/gfx/image/frame;2",
-                                                       &rv);
-      if (NS_FAILED(rv))
-        return rv;
-      rv = mAnim->compositingPrevFrame->Init(0, 0, mSize.width, mSize.height,
-                                              gfxIFormats::RGB_A1, 24);
-      if (NS_FAILED(rv))
-        return rv;
-    }
-    CopyFrameImage(mAnim->compositingFrame, mAnim->compositingPrevFrame);
-  }
-
-  // blit next frame into it's correct spot
-  aNextFrame->DrawTo(mAnim->compositingFrame, nextFrameRect.x, nextFrameRect.y,
-                     nextFrameRect.width, nextFrameRect.height);
-  // put the mask in
-  BuildCompositeMask(mAnim->compositingFrame, aNextFrame);
-  // Set timeout of CompositeFrame to timeout of frame we just composed
-  // Bug 177948
-  PRInt32 timeout;
-  aNextFrame->GetTimeout(&timeout);
-  mAnim->compositingFrame->SetTimeout(timeout);
-
-  if (isFullNextFrame && mAnimationMode == kNormalAnimMode && mLoopCount != 0) {
-    // We have a composited full frame
-    // Store the composited frame into the mFrames[..] so we don't have to
-    // continuously re-build it
-    // Then set the previous frame's disposal to CLEAR_ALL so we just draw the
-    // frame next time around
-    if (CopyFrameImage(mAnim->compositingFrame, aNextFrame)) {
-      aPrevFrame->SetFrameDisposalMethod(imgIContainer::kDisposeClearAll);
-      mAnim->lastCompositedFrameIndex = -1;
-      *aFrameToUse = aNextFrame;
-      return NS_OK;
-    }
-  }
-
-  mAnim->lastCompositedFrameIndex = aNextFrameIndex;
-  *aFrameToUse = mAnim->compositingFrame;
-
-  return NS_OK;
-}
-
-//******************************************************************************
-void imgContainer::BuildCompositeMask(gfxIImageFrame *aCompositingFrame,
-                                      gfxIImageFrame *aOverlayFrame)
-{
-  if (!aCompositingFrame || !aOverlayFrame) return;
-
-  nsresult res;
-  PRUint8* compositingAlphaData;
-  PRUint32 compositingAlphaDataLength;
-  aCompositingFrame->LockAlphaData();
-  res = aCompositingFrame->GetAlphaData(&compositingAlphaData,
-                                        &compositingAlphaDataLength);
-  if (!compositingAlphaData || !compositingAlphaDataLength || NS_FAILED(res)) {
-    aCompositingFrame->UnlockAlphaData();
-    return;
-  }
-
-  PRInt32 widthOverlay, heightOverlay;
-  PRInt32 overlayXOffset, overlayYOffset;
-  aOverlayFrame->GetWidth(&widthOverlay);
-  aOverlayFrame->GetHeight(&heightOverlay);
-  aOverlayFrame->GetX(&overlayXOffset);
-  aOverlayFrame->GetY(&overlayYOffset);
-
-  if (NS_FAILED(aOverlayFrame->LockAlphaData())) {
-    // set the region of the overlay frame to visible in compositingFrame
-    SetMaskVisibility(aCompositingFrame, overlayXOffset, overlayYOffset,
-                      widthOverlay, heightOverlay, PR_TRUE);
-    aCompositingFrame->UnlockAlphaData();
-    return;
-  }
-
-  PRUint32 abprComposite;
-  aCompositingFrame->GetAlphaBytesPerRow(&abprComposite);
-
-  PRUint32 abprOverlay;
-  aOverlayFrame->GetAlphaBytesPerRow(&abprOverlay);
-
-  // Only the composite's width & height are needed.  x & y should always be 0.
-  PRInt32 widthComposite, heightComposite;
-  aCompositingFrame->GetWidth(&widthComposite);
-  aCompositingFrame->GetHeight(&heightComposite);
-
-  PRUint8* overlayAlphaData;
-  PRUint32 overlayAlphaDataLength;
-  res = aOverlayFrame->GetAlphaData(&overlayAlphaData, &overlayAlphaDataLength);
-
-  // this check was here when this code was in imgContainerGif
-  // i think it's just a superfluous check but i'm not brave enough to
-  // delete it completely since i haven't traced the entire execution
-  //~ gfx_format format;
-  //~ aCompositingFrame->GetFormat(&format);
-  //~ if (format != gfxIFormats::RGB_A1 && format != gfxIFormats::BGR_A1) {
-    //~ NS_NOTREACHED("GIFs only support 1 bit alpha");
-    //~ aCompositingFrame->UnlockAlphaData();
-    //~ aOverlayFrame->UnlockAlphaData();
-    //~ return;
-  //~ }
-
-  // Exit if overlay is beyond the area of the composite
-  if (widthComposite <= overlayXOffset || heightComposite <= overlayYOffset)
-    return;
-
-  const PRUint32 width  = PR_MIN(widthOverlay,
-                                 widthComposite - overlayXOffset);
-  const PRUint32 height = PR_MIN(heightOverlay,
-                                 heightComposite - overlayYOffset);
-
-#ifdef MOZ_PLATFORM_IMAGES_BOTTOM_TO_TOP
-  // Account for bottom-up storage
-  PRInt32 offset = ((heightComposite - 1) - overlayYOffset) * abprComposite;
-#else
-  PRInt32 offset = overlayYOffset * abprComposite;
-#endif
-  PRUint8* alphaLine = compositingAlphaData + offset + (overlayXOffset >> 3);
-
-#ifdef MOZ_PLATFORM_IMAGES_BOTTOM_TO_TOP
-  offset = (heightOverlay - 1) * abprOverlay;
-#else
-  offset = 0;
-#endif
-  PRUint8* overlayLine = overlayAlphaData + offset;
-
-  /*
-    This is the number of pixels of offset between alpha and overlay
-    (the number of bits at the front of alpha to skip when starting a row).
-    I.e:, for a mask_offset of 3:
-    (these are representations of bits)
-    overlay 'pixels':   76543210 hgfedcba
-    alpha:              xxx76543 210hgfed ...
-    where 'x' is data already in alpha
-    the first 5 pixels of overlay are or'd into the low 5 bits of alpha
-  */
-  PRUint8 mask_offset = (overlayXOffset & 0x7);
-
-  for(PRUint32 i = 0; i < height; i++) {
-    PRUint8 pixels;
-    PRUint32 j;
-    // use locals to avoid keeping track of how much we need to add
-    // at the end of a line.  we don't really need this since we may
-    // be able to calculate the ending offsets, but it's simpler and
-    // cheap.
-    PRUint8 *localOverlay = overlayLine;
-    PRUint8 *localAlpha   = alphaLine;
-
-    for (j = width; j >= 8; j -= 8) {
-      // don't do in for(...) to avoid reference past end of buffer
-      pixels = *localOverlay++;
-
-      if (pixels == 0) // no bits to set - iterate and bump output pointer
-        localAlpha++;
-      else {
-        // for the last few bits of a line, we need to special-case it
-        if (mask_offset == 0) // simple case, no offset
-          *localAlpha++ |= pixels;
-        else {
-          *localAlpha++ |= (pixels >> mask_offset);
-          *localAlpha   |= (pixels << (8U-mask_offset));
-        }
-      }
-    }
-    if (j != 0) {
-      // handle the end of the line, 1 to 7 pixels
-      pixels = *localOverlay++;
-      if (pixels != 0) {
-        // last few bits have to be handled more carefully if
-        // width is not a multiple of 8.
-
-        // set bits we don't want to change to 0
-        pixels = (pixels >> (8U-j)) << (8U-j);
-        *localAlpha++ |= (pixels >> mask_offset);
-        // don't touch this byte unless we have bits for it
-        if (j > (8U - mask_offset))
-          *localAlpha |= (pixels << (8U-mask_offset));
-      }
-    }
-
-#ifdef MOZ_PLATFORM_IMAGES_BOTTOM_TO_TOP
-    alphaLine   -= abprComposite;
-    overlayLine -= abprOverlay;
-#else
-    alphaLine   += abprComposite;
-    overlayLine += abprOverlay;
-#endif
-  }
-
-  aCompositingFrame->UnlockAlphaData();
-  aOverlayFrame->UnlockAlphaData();
-  return;
-}
-
-//******************************************************************************
-void imgContainer::SetMaskVisibility(gfxIImageFrame *aFrame,
-                                     PRInt32 aX, PRInt32 aY,
-                                     PRInt32 aWidth, PRInt32 aHeight,
-                                     PRBool aVisible)
-{
-  if (!aFrame)
-    return;
-
-  PRInt32 frameWidth;
-  PRInt32 frameHeight;
-  aFrame->GetWidth(&frameWidth);
-  aFrame->GetHeight(&frameHeight);
-
-  const PRInt32 width  = PR_MIN(aWidth, frameWidth - aX);
-  const PRInt32 height = PR_MIN(aHeight, frameHeight - aY);
-
-  if (width <= 0 || height <= 0) {
-    return;
-  }
-
-  PRUint8* alphaData;
-  PRUint32 alphaDataLength;
-  const PRUint8 setMaskTo = aVisible ? 0xFF : 0x00;
-
-  aFrame->LockImageData();
-  nsresult res = aFrame->GetImageData(&alphaData, &alphaDataLength);
-  if (NS_SUCCEEDED(res)) {
-#ifdef IS_LITTLE_ENDIAN
-    alphaData += aY*frameWidth*4 + 3;
-#else
-    alphaData += aY*frameWidth*4;
-#endif
-    for (PRInt32 j = height; j > 0; --j) {
-      for (PRInt32 i = (aX+width-1)*4; i >= aX; i -= 4) {
-        alphaData[i] = setMaskTo;
-      }
-      alphaData += frameWidth*4;
-    }
-  }
-  aFrame->UnlockImageData();
-}
-
-//******************************************************************************
-void imgContainer::SetMaskVisibility(gfxIImageFrame *aFrame, PRBool aVisible)
-{
-  if (!aFrame)
-    return;
-
-  PRUint8* alphaData;
-  PRUint32 alphaDataLength;
-  const PRUint8 setMaskTo = aVisible ? 0xFF : 0x00;
-
-  aFrame->LockImageData();
-  nsresult res = aFrame->GetImageData(&alphaData, &alphaDataLength);
-  if (NS_SUCCEEDED(res)) {
-    for (PRUint32 i = 0; i < alphaDataLength; i+=4) {
-#ifdef IS_LITTLE_ENDIAN
-      alphaData[i+3] = setMaskTo;
-#else
-      alphaData[i] = setMaskTo;
-#endif
-    }
-  }
-  aFrame->UnlockImageData();
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 //******************************************************************************
-// Fill aFrame with black. Does not change the mask.
-void imgContainer::BlackenFrame(gfxIImageFrame *aFrame)
+/* void resetAnimation (); */
+NS_IMETHODIMP imgContainer::ResetAnimation()
 {
-  if (!aFrame)
-    return;
-
-  PRInt32 widthFrame;
-  PRInt32 heightFrame;
-  aFrame->GetWidth(&widthFrame);
-  aFrame->GetHeight(&heightFrame);
-
-  BlackenFrame(aFrame, 0, 0, widthFrame, heightFrame);
-}
-
-//******************************************************************************
-void imgContainer::BlackenFrame(gfxIImageFrame *aFrame,
-                                   PRInt32 aX, PRInt32 aY,
-                                   PRInt32 aWidth, PRInt32 aHeight)
-{
-  if (!aFrame)
-    return;
-
-  nsCOMPtr<nsIImage> img(do_GetInterface(aFrame));
-  if (!img)
-    return;
-
-  nsRefPtr<gfxASurface> surf;
-  img->GetSurface(getter_AddRefs(surf));
-
-  nsRefPtr<gfxContext> ctx = new gfxContext(surf);
-  ctx->SetColor(gfxRGBA(0, 0, 0));
-  ctx->Rectangle(gfxRect(aX, aY, aWidth, aHeight));
-  ctx->Fill();
-
-  nsIntRect r(aX, aY, aWidth, aHeight);
-  img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
-}
-
-
-//******************************************************************************
-// Whether we succeed or fail will not cause a crash, and there's not much
-// we can do about a failure, so there we don't return a nsresult
-PRBool imgContainer::CopyFrameImage(gfxIImageFrame *aSrcFrame,
-                                       gfxIImageFrame *aDstFrame)
-{
-  PRUint8* aDataSrc;
-  PRUint8* aDataDest;
-  PRUint32 aDataLengthSrc;
-  PRUint32 aDataLengthDest;
-
-  if (!aSrcFrame || !aDstFrame)
-    return PR_FALSE;
-
-  if (NS_FAILED(aDstFrame->LockImageData()))
-    return PR_FALSE;
-
-  // Copy Image Over
-  aSrcFrame->GetImageData(&aDataSrc, &aDataLengthSrc);
-  aDstFrame->GetImageData(&aDataDest, &aDataLengthDest);
-  if (!aDataDest || !aDataSrc || aDataLengthDest != aDataLengthSrc) {
-    aDstFrame->UnlockImageData();
-    return PR_FALSE;
-  }
-  memcpy(aDataDest, aDataSrc, aDataLengthSrc);
-  aDstFrame->UnlockImageData();
-
-  // Tell the image that it's data has been updated
-  nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(aDstFrame));
-  if (!ireq)
-    return PR_FALSE;
-  nsCOMPtr<nsIImage> img(do_GetInterface(ireq));
-  if (!img)
-    return PR_FALSE;
-  nsIntRect r;
-  aDstFrame->GetRect(r);
-  img->ImageUpdated(nsnull, nsImageUpdateFlags_kBitsChanged, &r);
-
-  return PR_TRUE;
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
Index: mozilla/modules/libpr0n/src/imgContainer.h
===================================================================
--- mozilla.orig/modules/libpr0n/src/imgContainer.h
+++ mozilla/modules/libpr0n/src/imgContainer.h
@@ -33,265 +33,42 @@
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
-/** @file
- * This file declares the imgContainer class, which
- * handles static and animated image containers.
- *
- * @author  Stuart Parmenter <pavlov@netscape.com>
- * @author  Chris Saari <saari@netscape.com>
- * @author  Arron Mogge <paper@animecity.nu>
- * @author  Andrew Smith <asmith15@learn.senecac.on.ca>
- */
-
 #ifndef __imgContainer_h__
 #define __imgContainer_h__
 
-#include "nsCOMArray.h"
 #include "nsCOMPtr.h"
 #include "imgIContainer.h"
 #include "gfxIImageFrame.h"
 #include "nsIProperties.h"
-#include "nsITimer.h"
-#include "nsWeakReference.h"
+
 
 #define NS_IMGCONTAINER_CID \
 { /* 27f0682c-ff64-4dd2-ae7a-668e59f2fd38 */         \
      0x27f0682c,                                     \
      0xff64,                                         \
      0x4dd2,                                         \
     {0xae, 0x7a, 0x66, 0x8e, 0x59, 0xf2, 0xfd, 0x38} \
 }
 
-/**
- * Handles static and animated image containers.
- *
- *
- * @par A Quick Walk Through
- * The decoder initializes this class and calls AppendFrame() to add a frame.
- * Once imgContainer detects more than one frame, it starts the animation
- * with StartAnimation().
- *
- * @par
- * StartAnimation() checks if animating is allowed, and creates a timer.  The
- * timer calls Notify when the specified frame delay time is up.
- *
- * @par
- * Notify() moves on to the next frame, sets up the new timer delay, destroys
- * the old frame, and forces a redraw via observer->FrameChanged().
- *
- * @par
- * Each frame can have a different method of removing itself. These are
- * listed as imgIContainer::cDispose... constants.  Notify() calls 
- * DoComposite() to handle any special frame destruction.
- *
- * @par
- * The basic path through DoComposite() is:
- * 1) Calculate Area that needs updating, which is at least the area of
- *    aNextFrame.
- * 2) Dispose of previous frame.
- * 3) Draw new image onto compositingFrame.
- * See comments in DoComposite() for more information and optimizations.
- *
- * @par
- * The rest of the imgContainer specific functions are used by DoComposite to
- * destroy the old frame and build the new one.
- *
- * @note
- * <li> "Mask", "Alpha", and "Alpha Level" are interchangable phrases in
- * respects to imgContainerGIF.
- *
- * @par
- * <li> GIFs never have more than a 1 bit alpha.
- * <li> APNGs may have a full alpha channel.
- *
- * @par
- * <li> Background color specified in GIF is ignored by web browsers.
- *
- * @par
- * <li> If Frame 3 wants to dispose by restoring previous, what it wants is to
- * restore the composition up to and including Frame 2, as well as Frame 2s
- * disposal.  So, in the middle of DoComposite when composing Frame 3, right
- * after destroying Frame 2's area, we copy compositingFrame to
- * prevCompositingFrame.  When DoComposite gets called to do Frame 4, we
- * copy prevCompositingFrame back, and then draw Frame 4 on top.
- *
- * @par
- * The mAnim structure has members only needed for animated images, so
- * it's not allocated until the second frame is added.
- *
- * @note
- * mAnimationMode, mLoopCount and mObserver are not in the mAnim structure
- * because the first two have public setters and the observer we only get
- * in Init().
- */
-class imgContainer : public imgIContainer, 
-                     public nsITimerCallback, 
-                     public nsIProperties
+class imgContainer : public imgIContainer, public nsIProperties
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_IMGICONTAINER
-  NS_DECL_NSITIMERCALLBACK
   NS_FORWARD_SAFE_NSIPROPERTIES(mProperties)
 
   imgContainer();
   virtual ~imgContainer();
 
 private:
-  friend class nsGIFDecoder2;
-  
-  struct Anim
-  {
-    //! Area of the first frame that needs to be redrawn on subsequent loops.
-    nsIntRect                  firstFrameRefreshArea;
-    // Note this doesn't hold a proper value until frame 2 finished decoding.
-    PRInt32                    currentDecodingFrameIndex; // 0 to numFrames-1
-    PRInt32                    currentAnimationFrameIndex; // 0 to numFrames-1
-    //! Track the last composited frame for Optimizations (See DoComposite code)
-    PRInt32                    lastCompositedFrameIndex;
-    //! Whether we can assume there will be no more frames
-    //! (and thus loop the animation)
-    PRBool                     doneDecoding;
-    //! Are we currently animating the image?
-    PRBool                     animating;
-    /** For managing blending of frames
-     *
-     * Some animations will use the compositingFrame to composite images
-     * and just hand this back to the caller when it is time to draw the frame.
-     * NOTE: When clearing compositingFrame, remember to set
-     *       lastCompositedFrameIndex to -1.  Code assume that if
-     *       lastCompositedFrameIndex >= 0 then compositingFrame exists.
-     */
-    nsCOMPtr<gfxIImageFrame>   compositingFrame;
-    /** the previous composited frame, for DISPOSE_RESTORE_PREVIOUS
-     *
-     * The Previous Frame (all frames composited up to the current) needs to be
-     * stored in cases where the image specifies it wants the last frame back
-     * when it's done with the current frame.
-     */
-    nsCOMPtr<gfxIImageFrame>   compositingPrevFrame;
-    //! Timer to animate multiframed images
-    nsCOMPtr<nsITimer>         timer;
-    
-    Anim() :
-      firstFrameRefreshArea(),
-      currentDecodingFrameIndex(0),
-      currentAnimationFrameIndex(0),
-      lastCompositedFrameIndex(-1),
-      doneDecoding(PR_FALSE),
-      animating(PR_FALSE)
-    {
-      ;
-    }
-    ~Anim()
-    {
-      if (timer)
-        timer->Cancel();
-    }
-  };
-  
-  inline gfxIImageFrame* inlinedGetCurrentFrame() {
-    if (!mAnim)
-      return mFrames.SafeObjectAt(0);
-    if (mAnim->lastCompositedFrameIndex == mAnim->currentAnimationFrameIndex)
-      return mAnim->compositingFrame;
-    return mFrames.SafeObjectAt(mAnim->currentAnimationFrameIndex);
-  }
-  
-  inline Anim* ensureAnimExists() {
-    if (!mAnim)
-      mAnim = new Anim();
-    return mAnim;
-  }
-  
-  /** Function for doing the frame compositing of animations
-   *
-   * @param aFrameToUse Set by DoComposite
-   *                   (aNextFrame, compositingFrame, or compositingPrevFrame)
-   * @param aDirtyRect  Area that the display will need to update
-   * @param aPrevFrame  Last Frame seen/processed
-   * @param aNextFrame  Frame we need to incorperate/display
-   * @param aNextFrameIndex Position of aNextFrame in mFrames list
-   */
-  nsresult DoComposite(gfxIImageFrame** aFrameToUse, nsIntRect* aDirtyRect,
-                       gfxIImageFrame* aPrevFrame,
-                       gfxIImageFrame* aNextFrame,
-                       PRInt32 aNextFrameIndex);
-  
-  /**
-   * Combine aOverlayFrame's mask into aCompositingFrame's mask.
-   *
-   * This takes the mask information from the passed in aOverlayFrame and
-   * inserts that information into the aCompositingFrame's mask at the proper
-   * offsets. It does *not* rebuild the entire mask.
-   *
-   * @param aCompositingFrame Target frame
-   * @param aOverlayFrame     This frame's mask is being copied
-   */
-  void BuildCompositeMask(gfxIImageFrame* aCompositingFrame,
-                          gfxIImageFrame* aOverlayFrame);
-  
-  /** Sets an area of the frame's mask.
-   *
-   * @param aFrame Target Frame
-   * @param aVisible Turn on (PR_TRUE) or off (PR_FALSE) visibility
-   *
-   * @note Invisible area of frame's image will need to be set to 0
-   */
-  void SetMaskVisibility(gfxIImageFrame *aFrame, PRBool aVisible);
-  //! @overload
-  void SetMaskVisibility(gfxIImageFrame *aFrame,
-                         PRInt32 aX, PRInt32 aY,
-                         PRInt32 aWidth, PRInt32 aHeight,
-                         PRBool aVisible);
-  //! @overload
-  void SetMaskVisibility(gfxIImageFrame *aFrame,
-                         nsIntRect &aRect, PRBool aVisible) {
-    SetMaskVisibility(aFrame, aRect.x, aRect.y,
-                      aRect.width, aRect.height, aVisible);
-  }
-  
-  /** Fills an area of <aFrame> with black.
-   *
-   * @param aFrame Target Frame
-   *
-   * @note Does not set the mask
-   */
-  static void BlackenFrame(gfxIImageFrame* aFrame);
-  //! @overload
-  static void BlackenFrame(gfxIImageFrame* aFrame,
-                    PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight);
-  //! @overload
-  static inline void BlackenFrame(gfxIImageFrame* aFrame, nsIntRect &aRect) {
-    BlackenFrame(aFrame, aRect.x, aRect.y, aRect.width, aRect.height);
-  }
-  
-  //! Copy one gfxIImageFrame's image and mask into another
-  static PRBool CopyFrameImage(gfxIImageFrame *aSrcFrame,
-                               gfxIImageFrame *aDstFrame);
-  
-  nsIntSize                  mSize;
-  
-  //! All the <gfxIImageFrame>s of the PNG
-  nsCOMArray<gfxIImageFrame> mFrames;
-  
-  nsCOMPtr<nsIProperties>    mProperties;
-  
-  imgContainer::Anim*        mAnim;
-  
-  //! See imgIContainer for mode constants
-  PRUint16                   mAnimationMode;
-  
-  //! # loops remaining before animation stops (-1 no stop)
-  PRInt32                    mLoopCount;
-  
-  //! imgIContainerObserver
-  nsWeakPtr                  mObserver;
+  nsIntSize mSize;
+  nsCOMPtr<gfxIImageFrame> mFrame;
+  nsCOMPtr<nsIProperties>  mProperties;
 };
 
 #endif /* __imgContainer_h__ */
