Index: mozilla/layout/base/nsLayoutUtils.cpp
===================================================================
--- mozilla.orig/layout/base/nsLayoutUtils.cpp
+++ mozilla/layout/base/nsLayoutUtils.cpp
@@ -57,17 +57,19 @@
 #include "nsGUIEvent.h"
 #include "nsDisplayList.h"
 #include "nsRegion.h"
 #include "nsFrameManager.h"
 #include "nsBlockFrame.h"
 #include "nsBidiPresUtils.h"
 #include "gfxIImageFrame.h"
 #include "imgIContainer.h"
+#ifdef MOZ_CAIRO_GFX
 #include "gfxRect.h"
+#endif
 #include "gfxContext.h"
 #include "nsIImage.h"
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsCSSRendering.h"
 
 #ifdef MOZ_SVG_FOREIGNOBJECT
 #include "nsSVGForeignObjectFrame.h"
 #include "nsSVGUtils.h"
Index: mozilla/layout/base/nsPresShell.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresShell.cpp
+++ mozilla/layout/base/nsPresShell.cpp
@@ -4921,17 +4921,17 @@ PresShell::HandleEvent(nsIView         *
     }
   }
 
   if (dispatchUsingCoordinates) {
     NS_ASSERTION(frame, "Nothing to handle this event!");
     if (!frame)
       return NS_OK;
 
-    nsPresContext* framePresContext = frame->GetPresContext();
+    nsPresContext* framePresContext = frame->PresContext();
     nsPresContext* rootPresContext = framePresContext->RootPresContext();
     NS_ASSERTION(rootPresContext = mPresContext->RootPresContext(),
                  "How did we end up outside the connected prescontext/viewmanager hierarchy?"); 
     // If we aren't starting our event dispatch from the root frame of the root prescontext,
     // then someone must be capturing the mouse. In that case we don't want to search the popup
     // list.
     if (framePresContext == rootPresContext &&
         frame == FrameManager()->GetRootFrame()) {
@@ -4949,17 +4949,17 @@ PresShell::HandleEvent(nsIView         *
       }
     }
 
     nsPoint eventPoint
         = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, frame);
     nsIFrame* targetFrame = nsLayoutUtils::GetFrameForPoint(frame, eventPoint);
     if (targetFrame) {
       PresShell* shell =
-          NS_STATIC_CAST(PresShell*, targetFrame->GetPresContext()->PresShell());
+          NS_STATIC_CAST(PresShell*, targetFrame->PresContext()->PresShell());
       if (shell != this) {
         // Handle the event in the correct shell.
         // Prevent deletion until we're done with event handling (bug 336582).
         nsRefPtr<nsIPresShell> kungFuDeathGrip(shell);
         nsIView* subshellRootView;
         shell->GetViewManager()->GetRootView(subshellRootView);
         // We pass the subshell's root view as the view to start from. This is
         // the only correct alternative; if the event was captured then it
Index: mozilla/layout/base/nsDisplayList.cpp
===================================================================
--- mozilla.orig/layout/base/nsDisplayList.cpp
+++ mozilla/layout/base/nsDisplayList.cpp
@@ -807,17 +807,17 @@ void nsDisplayOpacity::Paint(nsDisplayLi
   ctx->PopGroupToSource();
   ctx->SetOperator(gfxContext::OPERATOR_OVER);
   ctx->Paint(opacity);
 
   ctx->Restore();
 
 #elif !defined(XP_MACOSX)
 
-  nsIViewManager* vm = mFrame->GetPresContext()->GetViewManager();
+  nsIViewManager* vm = mFrame->PresContext()->GetViewManager();
   nsIViewManager::BlendingBuffers* buffers =
       vm->CreateBlendingBuffers(aCtx, PR_FALSE, nsnull, mNeedAlpha, bounds);
   if (!buffers) {
     NS_WARNING("Could not create blending buffers for translucent painting; ignoring opacity");
     nsDisplayWrapList::Paint(aBuilder, aCtx, aDirtyRect);
     return;
   }
   
Index: mozilla/layout/generic/nsContainerFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsContainerFrame.cpp
+++ mozilla/layout/generic/nsContainerFrame.cpp
@@ -433,17 +433,17 @@ SyncFrameViewGeometryDependentProperties
 
 void
 nsContainerFrame::SyncFrameViewAfterReflow(nsPresContext* aPresContext,
                                            nsIFrame*       aFrame,
                                            nsIView*        aView,
                                            const nsRect*   aCombinedArea,
                                            PRUint32        aFlags)
 {
-  if (!aView) {
+  if (!aView || !aCombinedArea) {
     return;
   }
 
   NS_ASSERTION(aCombinedArea, "Combined area must be passed in now");
 
   // Make sure the view is sized and positioned correctly
   if (0 == (aFlags & NS_FRAME_NO_MOVE_VIEW)) {
     PositionFrameView(aFrame);
