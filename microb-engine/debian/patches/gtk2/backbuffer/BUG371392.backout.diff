diff -ruN -p -U10 mozilla.orig/gfx/public/nsIRenderingContext.h mozilla/gfx/public/nsIRenderingContext.h
--- mozilla.orig/gfx/public/nsIRenderingContext.h	2007-03-27 09:21:55.000000000 +0300
+++ mozilla/gfx/public/nsIRenderingContext.h	2007-05-30 07:29:17.000000000 +0300
@@ -747,20 +747,56 @@ public:
     NATIVE_WINDOWS_DC = 3,
     NATIVE_MAC_THING = 4,
     NATIVE_THEBES_CONTEXT = 5
   };
   /**
    * Retrieve the native graphic data given by aType. Return
    * nsnull if not available.
    */
   virtual void* GetNativeGraphicData(GraphicDataType aType) = 0;
 
+  /**
+   * Get a drawing surface used as a backbuffer.
+   * Depending on the platform this will either cause a backbuffer surface to be allocated
+   * or an existing cached backbuffer will be returned. If the backbuffer is being cached
+   * asking for aMaxSize which is different from a previous request may cause the platform
+   * to dump it's cached backbuffer and reallocate a backbuffer of a size which will allow aMaxSize 
+   * buffer to be allocated.
+   *
+   * @param aRequestedSize size of the backbuffer area requested
+   * @param aMaxSize maximum size that may be requested for the backbuffer
+   * @param aForBlending parameter telling if the buffer will be used for blending
+   * @param aBackbuffer drawing surface used as the backbuffer
+   */
+  NS_IMETHOD GetBackbuffer(const nsRect &aRequestedSize, const nsRect &aMaxSize, PRBool aForBlending, nsIDrawingSurface* &aBackbuffer) = 0;
+
+  /**
+   * Release a drawing surface used as the backbuffer
+   * If the platform caches the backbuffer this call will destroy it.
+   */
+  NS_IMETHOD ReleaseBackbuffer(void) = 0;
+
+  /**
+   * Destroy the drawing surface used as the backbuffer. If the platform
+   * does not maintain a cached backbuffer this call will do nothing.
+   */
+  NS_IMETHOD DestroyCachedBackbuffer(void) = 0;
+
+  /**
+   * Some platforms may not want a backbuffer at all. Returning false
+   * here allows them to achieve that
+   *
+   * @param aUseBackbuffer PR_TRUE if we should use a backbuffer, PR_FALSE if not
+   */
+  NS_IMETHOD UseBackbuffer(PRBool* aUseBackbuffer) = 0;
+
+
 #ifdef MOZ_MATHML
   /**
    * Returns bounding metrics (in app units) of an 8-bit character string
    * @param aString string to measure
    * @param aLength number of characters in string
    * @return aBoundingMetrics struct that contains various metrics (see below)
    * @return error status
    */
   NS_IMETHOD
   GetBoundingMetrics(const char*        aString,
diff -ruN -p -U10 mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.cpp mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
--- mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.cpp	2007-03-27 09:21:55.000000000 +0300
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp	2007-05-30 07:29:17.000000000 +0300
@@ -1464,10 +1464,26 @@ NS_IMETHODIMP nsRenderingContextGTK::Get
                                                    PRUint32 &aWidth)
 {
   return mFontMetrics->GetRangeWidth(aText, aLength, aStart, aEnd, aWidth);
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawImage(imgIContainer *aImage, const nsRect & aSrcRect, const nsRect & aDestRect)
 {
   UpdateGC();
   return nsRenderingContextImpl::DrawImage(aImage, aSrcRect, aDestRect);
 }
+
+NS_IMETHODIMP nsRenderingContextGTK::GetBackbuffer(const nsRect &aRequestedSize,
+                                                   const nsRect &aMaxSize,
+                                                   PRBool aForBlending,
+                                                   nsIDrawingSurface* &aBackbuffer)
+{
+  // Do not cache the backbuffer. On GTK it is more efficient to allocate
+  // the backbuffer as needed and it doesn't cause a performance hit. @see bug 95952
+  return AllocateBackbuffer(aRequestedSize, aMaxSize, aBackbuffer, PR_FALSE, 0);
+}
+ 
+NS_IMETHODIMP nsRenderingContextGTK::ReleaseBackbuffer(void) {
+  // Do not cache the backbuffer. On GTK it is more efficient to allocate
+  // the backbuffer as needed and it doesn't cause a performance hit. @see bug 95952
+  return DestroyCachedBackbuffer();
+}
diff -ruN -p -U10 mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.h mozilla/gfx/src/gtk/nsRenderingContextGTK.h
--- mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.h	2007-03-27 09:21:55.000000000 +0300
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.h	2007-05-30 07:29:17.000000000 +0300
@@ -235,20 +235,24 @@ public:
                            PRUint32 aEnd,
                            PRUint32 &aWidth);
   NS_IMETHOD GetRangeWidth(const char *aText,
                            PRUint32 aLength,
                            PRUint32 aStart,
                            PRUint32 aEnd,
                            PRUint32 &aWidth);
 
   NS_IMETHOD DrawImage(imgIContainer *aImage, const nsRect & aSrcRect, const nsRect & aDestRect);
 
+  NS_IMETHOD GetBackbuffer(const nsRect &aRequestedSize, const nsRect &aMaxSize,
+                           PRBool aForBlending, nsIDrawingSurface* &aBackbuffer);
+  NS_IMETHOD ReleaseBackbuffer(void);
+
   //locals
   NS_IMETHOD CommonInit();
 
   void CreateClipRegion();
 
   GdkGC *GetGC() {
     if (!mGC)
       UpdateGC();
     return gdk_gc_ref(mGC);
   }
diff -ruN -p -U10 mozilla.orig/gfx/src/nsRenderingContextImpl.h mozilla/gfx/src/nsRenderingContextImpl.h
--- mozilla.orig/gfx/src/nsRenderingContextImpl.h	2007-03-27 11:53:08.000000000 +0300
+++ mozilla/gfx/src/nsRenderingContextImpl.h	2007-05-30 07:29:17.000000000 +0300
@@ -84,20 +84,25 @@ public:
 
   virtual void* GetNativeGraphicData(nsIRenderingContext::GraphicDataType aType)
   { return nsnull; }
 
   /**
    * Sets the Pen Mode for the RenderingContext 
    * @param aPenMode The Pen Mode
    * @return NS_OK if the Pen Mode is correctly set
    */
   NS_IMETHOD SetPenMode(nsPenMode aPenMode) { return NS_ERROR_FAILURE;}
+
+  NS_IMETHOD GetBackbuffer(const nsRect &aRequestedSize, const nsRect &aMaxSize, PRBool aForBlending, nsIDrawingSurface* &aBackbuffer); 
+  NS_IMETHOD ReleaseBackbuffer(void);
+  NS_IMETHOD DestroyCachedBackbuffer(void);
+  NS_IMETHOD UseBackbuffer(PRBool* aUseBackbuffer);
   
   NS_IMETHOD PushTranslation(PushedTranslation* aState);
   NS_IMETHOD PopTranslation(PushedTranslation* aState);
   NS_IMETHOD SetTranslation(nscoord aX, nscoord aY);
 
   /**
    * Return the maximum length of a string that can be handled by the platform
    * using the current font metrics.
    * The implementation here is just a stub; classes that don't override
    * the safe string methods need to implement this.
@@ -305,21 +310,34 @@ protected:
 
   /**
    * Get the size of the offscreen drawing surface..
    *
    * @param aMaxBackbufferSize Maximum size that may be requested for the backbuffer
    * @param aRequestedSize Desired size for the offscreen.
    * @param aSurfaceSize   Offscreen adjusted to a discrete size which encloses aRequestedSize.
    */
   void GetDrawingSurfaceSize(const nsRect& aMaxBackbufferSize, const nsRect& aRequestedSize, nsRect& aSurfaceSize);
 
+  /**
+   * Utility method used to implement NS_IMETHOD GetBackbuffer
+   *
+   * @param aRequestedSize size of the backbuffer area requested
+   * @param aMaxSize maximum size that may be requested for the backbuffer
+   * @param aBackbuffer drawing surface used as the backbuffer
+   * @param aCacheBackbuffer PR_TRUE then the backbuffer will be cached, if PR_FALSE it is created each time
+   * @param aSurfFlags flags passed to CreateDrawingSurface()
+   */
+  nsresult AllocateBackbuffer(const nsRect &aRequestedSize, const nsRect &aMaxSize, nsIDrawingSurface* &aBackbuffer, PRBool aCacheBackbuffer, PRUint32 aSurfFlags);
+
 public:
 
 protected:
   nsPenMode   mPenMode;
 private:
-  // Largest requested offscreen size if larger than a full screen.
-  static nsSize gLargestRequestedSize;
+  static nsIDrawingSurface*  gBackbuffer;         //singleton backbuffer 
+  static nsRect            gBackbufferBounds;   //backbuffer bounds
+    // Largest requested offscreen size if larger than a full screen.
+  static nsSize            gLargestRequestedSize;
 
 };
 
 #endif /* nsRenderingContextImpl */
diff -ruN -p -U10 mozilla.orig/gfx/src/shared/nsRenderingContextImpl.cpp mozilla/gfx/src/shared/nsRenderingContextImpl.cpp
--- mozilla.orig/gfx/src/shared/nsRenderingContextImpl.cpp	2007-03-27 09:21:56.000000000 +0300
+++ mozilla/gfx/src/shared/nsRenderingContextImpl.cpp	2007-05-30 07:29:17.000000000 +0300
@@ -38,20 +38,22 @@
 #include "nsCOMPtr.h"
 #include "nsRenderingContextImpl.h"
 #include "nsIDeviceContext.h"
 #include "nsIImage.h"
 #include "nsTransform2D.h"
 #include "nsIRegion.h"
 #include "nsIFontMetrics.h"
 #include <stdlib.h>
 
 
+nsIDrawingSurface* nsRenderingContextImpl::gBackbuffer = nsnull;
+nsRect nsRenderingContextImpl::gBackbufferBounds = nsRect(0, 0, 0, 0);
 nsSize nsRenderingContextImpl::gLargestRequestedSize = nsSize(0, 0);
 
 
 /** ---------------------------------------------------
  *  See documentation in nsIRenderingContext.h
  *	@update 3/16/00 dwc
  */
 nsRenderingContextImpl :: nsRenderingContextImpl()
 : mTranMatrix(nsnull)
 , mAct(0)
@@ -63,20 +65,97 @@ nsRenderingContextImpl :: nsRenderingCon
 /** ---------------------------------------------------
  *  See documentation in nsIRenderingContext.h
  *	@update 3/16/00 dwc
  */
 nsRenderingContextImpl :: ~nsRenderingContextImpl()
 {
 
 
 }
 
+
+NS_IMETHODIMP nsRenderingContextImpl::GetBackbuffer(const nsRect &aRequestedSize, const nsRect &aMaxSize, PRBool aForBlending, nsIDrawingSurface* &aBackbuffer)
+{
+  // Default implementation assumes the backbuffer will be cached.
+  // If the platform implementation does not require the backbuffer to
+  // be cached override this method and make the following call instead:
+  // AllocateBackbuffer(aRequestedSize, aMaxSize, aBackbuffer, PR_FALSE);
+  return AllocateBackbuffer(aRequestedSize, aMaxSize, aBackbuffer, PR_TRUE, 0);
+}
+
+nsresult nsRenderingContextImpl::AllocateBackbuffer(const nsRect &aRequestedSize, const nsRect &aMaxSize, nsIDrawingSurface* &aBackbuffer, PRBool aCacheBackbuffer, PRUint32 aSurfFlags)
+{
+  nsRect newBounds;
+  nsresult rv = NS_OK;
+
+   if (! aCacheBackbuffer) {
+    newBounds = aRequestedSize;
+  } else {
+    GetDrawingSurfaceSize(aMaxSize, aRequestedSize, newBounds);
+  }
+
+  if ((nsnull == gBackbuffer)
+      || (gBackbufferBounds.width != newBounds.width)
+      || (gBackbufferBounds.height != newBounds.height))
+    {
+      if (gBackbuffer) {
+        //destroy existing DS
+        DestroyDrawingSurface(gBackbuffer);
+        gBackbuffer = nsnull;
+      }
+
+      rv = CreateDrawingSurface(newBounds, aSurfFlags, gBackbuffer);
+      //   printf("Allocating a new drawing surface %d %d\n", newBounds.width, newBounds.height);
+      if (NS_SUCCEEDED(rv)) {
+        gBackbufferBounds = newBounds;
+        SelectOffScreenDrawingSurface(gBackbuffer);
+      } else {
+        gBackbufferBounds.SetRect(0,0,0,0);
+        gBackbuffer = nsnull;
+      }
+    } else {
+      SelectOffScreenDrawingSurface(gBackbuffer);
+
+      nsCOMPtr<nsIDeviceContext>  dx;
+      GetDeviceContext(*getter_AddRefs(dx));
+      nsRect bounds = aRequestedSize;
+      bounds *= dx->AppUnitsPerDevPixel();
+
+      SetClipRect(bounds, nsClipCombine_kReplace);
+    }
+
+  aBackbuffer = gBackbuffer;
+  return rv;
+}
+
+NS_IMETHODIMP nsRenderingContextImpl::ReleaseBackbuffer(void)
+{
+  // If the platform does not require the backbuffer to be cached
+  // override this method and call DestroyCachedBackbuffer
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsRenderingContextImpl::DestroyCachedBackbuffer(void)
+{
+  if (gBackbuffer) {
+    DestroyDrawingSurface(gBackbuffer);
+    gBackbuffer = nsnull;
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsRenderingContextImpl::UseBackbuffer(PRBool* aUseBackbuffer)
+{
+  *aUseBackbuffer = PR_TRUE;
+  return NS_OK;
+}
+
 NS_IMETHODIMP nsRenderingContextImpl::PushTranslation(PushedTranslation* aState)
 {
   // The transform components are saved and restored instead 
   // of using PushState and PopState because they are too slow
   // because they also save and restore the clip state.
   // Note: Setting a negative translation to restore the 
   // state does not work because the floating point errors can accumulate
   // causing the display of some frames to be off by one pixel. 
   // This happens frequently when running in 120DPI mode where frames are
   // often positioned at 1/2 pixel locations and small floating point errors
diff -ruN -p -U10 mozilla.orig/gfx/src/thebes/nsThebesRenderingContext.cpp mozilla/gfx/src/thebes/nsThebesRenderingContext.cpp
--- mozilla.orig/gfx/src/thebes/nsThebesRenderingContext.cpp	2007-03-27 09:21:56.000000000 +0300
+++ mozilla/gfx/src/thebes/nsThebesRenderingContext.cpp	2007-05-30 07:29:17.000000000 +0300
@@ -863,20 +863,58 @@ nsThebesRenderingContext::DrawNativeWidg
                                                 pat);
     mThebes->Fill();
     mThebes->Restore();
 
     delete tmpSurf;
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
+nsThebesRenderingContext::UseBackbuffer(PRBool* aUseBackbuffer)
+{
+#ifndef XP_MACOSX
+    *aUseBackbuffer = PR_TRUE;
+#else
+    *aUseBackbuffer = PR_FALSE;
+#endif
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsThebesRenderingContext::GetBackbuffer(const nsRect &aRequestedSize,
+                                        const nsRect &aMaxSize,
+                                        PRBool aForBlending,
+                                        nsIDrawingSurface* &aBackbuffer)
+{
+    PR_LOG(gThebesGFXLog, PR_LOG_DEBUG,
+           ("## %p nsTRC::GetBackBuffer req: %d %d %d %d max: %d %d %d %d blending? %d\n",
+            this, aRequestedSize.x, aRequestedSize.y, aRequestedSize.width, aRequestedSize.height,
+            aMaxSize.x, aMaxSize.y, aMaxSize.width, aMaxSize.height, aForBlending));
+
+    return AllocateBackbuffer(aRequestedSize, aMaxSize, aBackbuffer, PR_FALSE,
+                              aForBlending ? NS_CREATEDRAWINGSURFACE_FOR_PIXEL_ACCESS : 0);
+}
+
+NS_IMETHODIMP
+nsThebesRenderingContext::ReleaseBackbuffer(void)
+{
+    return DestroyCachedBackbuffer();
+}
+
+NS_IMETHODIMP
+nsThebesRenderingContext::DestroyCachedBackbuffer(void)
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP
 nsThebesRenderingContext::PushFilter(const nsRect& twRect, PRBool aAreaIsOpaque, float aOpacity)
 {
     PR_LOG(gThebesGFXLog, PR_LOG_DEBUG,
            ("## %p nsTRC::PushFilter [%d,%d,%d,%d] isOpaque: %d opacity: %f\n",
             this, twRect.x, twRect.y, twRect.width, twRect.height,
             aAreaIsOpaque, aOpacity));
 
     mOpacityArray.AppendElement(aOpacity);
 
     mThebes->Save();
diff -ruN -p -U10 mozilla.orig/gfx/src/thebes/nsThebesRenderingContext.h mozilla/gfx/src/thebes/nsThebesRenderingContext.h
--- mozilla.orig/gfx/src/thebes/nsThebesRenderingContext.h	2007-03-27 09:21:56.000000000 +0300
+++ mozilla/gfx/src/thebes/nsThebesRenderingContext.h	2007-05-30 07:29:17.000000000 +0300
@@ -216,20 +216,27 @@ public:
     virtual PRInt32 GetMaxStringLength();
 
     NS_IMETHOD PushFilter(const nsRect& aRect, PRBool aAreaIsOpaque, float aOpacity);
     NS_IMETHOD PopFilter();
 
     NS_IMETHOD CopyOffScreenBits(nsIDrawingSurface *aSrcSurf,
                                  PRInt32 aSrcX, PRInt32 aSrcY,
                                  const nsRect &aDestBounds,
                                  PRUint32 aCopyFlags);
     virtual void* GetNativeGraphicData(GraphicDataType aType);
+    NS_IMETHOD GetBackbuffer(const nsRect &aRequestedSize,
+                             const nsRect &aMaxSize,
+                             PRBool aForBlending,
+                             nsIDrawingSurface* &aBackbuffer);
+    NS_IMETHOD ReleaseBackbuffer(void);
+    NS_IMETHOD DestroyCachedBackbuffer(void);
+    NS_IMETHOD UseBackbuffer(PRBool* aUseBackbuffer);
 
     NS_IMETHOD PushTranslation(PushedTranslation* aState);
     NS_IMETHOD PopTranslation(PushedTranslation* aState);
     NS_IMETHOD SetTranslation(nscoord aX, nscoord aY);
 
     NS_IMETHOD DrawImage(imgIContainer *aImage,
                          const nsRect &aSrcRect,
                          const nsRect &aDestRect);
     NS_IMETHOD DrawTile(imgIContainer *aImage, nscoord aXOffset, nscoord aYOffset,
                         const nsRect * aTargetRect);
diff -ruN -p -U10 mozilla.orig/layout/generic/nsObjectFrame.cpp mozilla/layout/generic/nsObjectFrame.cpp
--- mozilla.orig/layout/generic/nsObjectFrame.cpp	2007-05-14 12:11:53.000000000 +0300
+++ mozilla/layout/generic/nsObjectFrame.cpp	2007-05-30 07:29:17.000000000 +0300
@@ -536,20 +536,29 @@ nsObjectFrame::CreateWidget(nscoord aWid
   NS_ASSERTION(view, "Object frames must have views");  
   if (!view) {
     return NS_OK;       //XXX why OK? MMP
   }
 
   nsIViewManager* viewMan = view->GetViewManager();
   // mark the view as hidden since we don't know the (x,y) until Paint
   // XXX is the above comment correct?
   viewMan->SetViewVisibility(view, nsViewVisibility_kHide);
 
+  // Turn off double buffering on the Mac. This depends on bug 49743 and partially
+  // fixes 32327, 19931 and 51787
+#ifdef XP_MACOSX
+  PRBool doubleBuffer =
+    nsContentUtils::GetBoolPref("plugin.enable_double_buffer");
+  
+  viewMan->AllowDoubleBuffering(doubleBuffer);
+#endif
+  
   //this is ugly. it was ripped off from didreflow(). MMP
   // Position and size view relative to its parent, not relative to our
   // parent frame (our parent frame may not have a view).
   
   nsIView* parentWithView;
   nsPoint origin;
   nsRect r(0, 0, mRect.width, mRect.height);
 
   GetOffsetFromView(origin, &parentWithView);
   viewMan->ResizeView(view, r);
diff -ruN -p -U10 mozilla.orig/view/public/nsIViewManager.h mozilla/view/public/nsIViewManager.h
--- mozilla.orig/view/public/nsIViewManager.h	2007-05-30 07:27:41.000000000 +0300
+++ mozilla/view/public/nsIViewManager.h	2007-05-30 07:29:17.000000000 +0300
@@ -433,20 +433,31 @@ public:
 
   /**
    * Force update of view manager widget
    * Callers should use UpdateView(view, NS_VMREFRESH_IMMEDIATE) in most cases instead
    * @result error status
    */
   // XXXbz Callers seem to be confused about this one... and it doesn't play
   // right with view update batching at all (will miss updates).  Maybe this
   // should call FlushPendingInvalidates()?
   NS_IMETHOD ForceUpdate() = 0;
+  
+  /**
+   * Control double buffering of the display. If double buffering
+   * is enabled the viewmanager is allowed to render to an offscreen
+   * drawing surface before copying to the display in order to prevent
+   * flicker. If it is disabled all rendering will appear directly on the
+   * the display. The display is double buffered by default.
+   * @param aDoubleBuffer PR_TRUE to enable double buffering
+   *                      PR_FALSE to disable double buffering
+   */
+  NS_IMETHOD AllowDoubleBuffering(PRBool aDoubleBuffer)=0;
 
   /**
    * Indicate whether the viewmanager is currently painting
    *
    * @param aPainting PR_TRUE if the viewmanager is painting
    *                  PR_FALSE otherwise
    */
   NS_IMETHOD IsPainting(PRBool& aIsPainting)=0;
 
   /**
diff -ruN -p -U10 mozilla.orig/view/src/nsViewManager.cpp mozilla/view/src/nsViewManager.cpp
--- mozilla.orig/view/src/nsViewManager.cpp	2007-05-30 07:27:41.000000000 +0300
+++ mozilla/view/src/nsViewManager.cpp	2007-05-30 07:29:17.000000000 +0300
@@ -57,21 +57,23 @@
 #include "nsGUIEvent.h"
 #include "nsIPrefBranch.h"
 #include "nsIPrefService.h"
 #include "nsRegion.h"
 #include "nsInt64.h"
 #include "nsScrollPortView.h"
 #include "nsHashtable.h"
 #include "nsCOMArray.h"
 #include "nsThreadUtils.h"
 
+#ifdef MOZ_CAIRO_GFX
 #include "gfxContext.h"
+#endif
 
 static NS_DEFINE_IID(kBlenderCID, NS_BLENDER_CID);
 static NS_DEFINE_IID(kRegionCID, NS_REGION_CID);
 static NS_DEFINE_IID(kRenderingContextCID, NS_RENDERING_CONTEXT_CID);
 
 /**
    XXX TODO XXX
 
    DeCOMify newly private methods
    Optimize view storage
@@ -167,20 +169,21 @@ nsViewManager::nsViewManager()
     NS_ASSERTION(gCleanupContext,
                  "Wasn't able to create a graphics context for cleanup");
   }
 
   gViewManagers->AppendElement(this);
 
   mVMCount++;
   // NOTE:  we use a zeroing operator new, so all data members are
   // assumed to be cleared here.
   mDefaultBackgroundColor = NS_RGBA(0, 0, 0, 0);
+  mAllowDoubleBuffering = PR_TRUE; 
   mHasPendingUpdates = PR_FALSE;
   mRecursiveRefreshPending = PR_FALSE;
   mUpdateBatchFlags = 0;
 }
 
 nsViewManager::~nsViewManager()
 {
   if (mRootView) {
     // Destroy any remaining views
     mRootView->Destroy();
@@ -215,20 +218,28 @@ nsViewManager::~nsViewManager()
     NS_ASSERTION(gViewManagers != nsnull, "About to delete null gViewManagers");
     delete gViewManagers;
     gViewManagers = nsnull;
 
     // Cleanup all of the offscreen drawing surfaces if the last view manager
     // has been destroyed and there is something to cleanup
 
     // Note: A global rendering context is needed because it is not possible 
     // to create a nsIRenderingContext during the shutdown of XPCOM. The last
     // viewmanager is typically destroyed during XPCOM shutdown.
+
+    if (gCleanupContext) {
+
+      gCleanupContext->DestroyCachedBackbuffer();
+    } else {
+      NS_ASSERTION(PR_FALSE, "Cleanup of drawing surfaces + offscreen buffer failed");
+    }
+
     NS_IF_RELEASE(gCleanupContext);
   }
 
   mObserver = nsnull;
   mContext = nsnull;
 
   if (nsnull != mCompositeListeners) {
     mCompositeListeners->Clear();
     NS_RELEASE(mCompositeListeners);
   }
@@ -484,21 +495,41 @@ void nsViewManager::Refresh(nsView *aVie
   MOZ_TIMER_START(mWatch);
 #endif
 
   NS_ASSERTION(!IsPainting(), "recursive painting not permitted");
   if (IsPainting()) {
     RootViewManager()->mRecursiveRefreshPending = PR_TRUE;
     return;
   }  
   SetPainting(PR_TRUE);
 
+  // force double buffering in general
+  aUpdateFlags |= NS_VMREFRESH_DOUBLE_BUFFER;
+
+  if (!DoDoubleBuffering())
+    aUpdateFlags &= ~NS_VMREFRESH_DOUBLE_BUFFER;
+
+  // check if the rendering context wants double-buffering or not
+  if (aContext) {
+    PRBool contextWantsBackBuffer = PR_TRUE;
+    aContext->UseBackbuffer(&contextWantsBackBuffer);
+    if (!contextWantsBackBuffer)
+      aUpdateFlags &= ~NS_VMREFRESH_DOUBLE_BUFFER;
+  }
+  
+  if (PR_FALSE == mAllowDoubleBuffering) {
+    // Turn off double-buffering of the display
+    aUpdateFlags &= ~NS_VMREFRESH_DOUBLE_BUFFER;
+  }
+
   nsCOMPtr<nsIRenderingContext> localcx;
+  nsIDrawingSurface*    ds = nsnull;
 
   if (nsnull == aContext)
     {
       localcx = CreateRenderingContext(*aView);
 
       //couldn't get rendering context. this is ok at init time atleast
       if (nsnull == localcx) {
         SetPainting(PR_FALSE);
         return;
       }
@@ -517,40 +548,130 @@ void nsViewManager::Refresh(nsView *aVie
           listener->WillRefreshRegion(this, aView, aContext, aRegion, aUpdateFlags);
         }
       }
     }
   }
 
   // damageRect is the clipped damage area bounds, in twips-relative-to-view-origin
   nsRect damageRect = damageRegion.GetBounds();
   PRInt32 p2a = mContext->AppUnitsPerDevPixel();
 
+#ifdef MOZ_CAIRO_GFX
   nsRefPtr<gfxContext> ctx =
     (gfxContext*) localcx->GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);
 
   ctx->Save();
 
   nsPoint vtowoffset = aView->ViewToWidgetOffset();
   ctx->Translate(gfxPoint(gfxFloat(vtowoffset.x) / p2a,
                           gfxFloat(vtowoffset.y) / p2a));
 
   NS_ASSERTION(!viewRect.x && !viewRect.y, "When exactly is this supposed to be non-zero?");
   ctx->Translate(gfxPoint(gfxFloat(viewRect.x) / p2a,
                           gfxFloat(viewRect.y) / p2a));
 
   nsRegion opaqueRegion;
   AddCoveringWidgetsToOpaqueRegion(opaqueRegion, mContext, aView);
   damageRegion.Sub(damageRegion, opaqueRegion);
 
-  RenderViews(aView, *localcx, damageRegion);
+  RenderViews(aView, *localcx, damageRegion, ds);
 
   ctx->Restore();
+#else
+  // widgetDamageRectInPixels is the clipped damage area bounds,
+  // in pixels-relative-to-widget-origin
+  nsRect widgetDamageRectInPixels = damageRect;
+  widgetDamageRectInPixels.MoveBy(-viewRect.x, -viewRect.y);
+  widgetDamageRectInPixels.ScaleRoundOut(t2p);
+
+  // On the Mac, we normally turn doublebuffering off because Quartz is
+  // doublebuffering for us. But we need to turn it on anyway if we need
+  // to use our blender, which requires access to the "current pixel values"
+  // when it blends onto the canvas.
+  // XXX disable opacity for now on the Mac because of this ... it'll get
+  // reenabled with cairo
+  if (aUpdateFlags & NS_VMREFRESH_DOUBLE_BUFFER)
+  {
+    nsRect maxWidgetSize;
+    GetMaxWidgetBounds(maxWidgetSize);
+
+    nsRect r(0, 0, widgetDamageRectInPixels.width, widgetDamageRectInPixels.height);
+    if (NS_FAILED(localcx->GetBackbuffer(r, maxWidgetSize, PR_FALSE, ds))) {
+      //Failed to get backbuffer so turn off double buffering
+      aUpdateFlags &= ~NS_VMREFRESH_DOUBLE_BUFFER;
+    }
+  }
+
+  nsIRenderingContext::PushedTranslation trans;
+  nsPoint delta(0,0);
+
+  // painting will be done in aView's coordinates
+  PRBool usingDoubleBuffer = (aUpdateFlags & NS_VMREFRESH_DOUBLE_BUFFER) && ds;
+  if (usingDoubleBuffer) {
+    // Adjust translations because the backbuffer holds just the damaged area,
+    // not the whole widget
+
+    localcx->PushTranslation(&trans);
+
+    // We want (0,0) to be translated to the widget origin. We do it this
+    // way rather than calling Translate because it is *imperative* that
+    // the tx,ty floats in the translation matrix get set to an integer
+    // number of pixels. For example, if they're off by 0.000001 for some
+    // damage rects, then a translated coordinate of NNNN.5 may get rounded
+    // differently depending on what damage rect is used to paint the object,
+    // and we may get inconsistent rendering depending on what area was
+    // damaged.
+    localcx->SetTranslation(-widgetDamageRectInPixels.x, -widgetDamageRectInPixels.y);
+    
+    // We're going to reset the clip region for the backbuffer. We can't
+    // just use damageRegion because nsIRenderingContext::SetClipRegion doesn't
+    // translate/scale the coordinates (grrrrrrrrrr)
+    // So we have to translate the region before we use it. aRegion is in
+    // pixels-relative-to-widget-origin, so:
+    aRegion->Offset(-widgetDamageRectInPixels.x, -widgetDamageRectInPixels.y);
+  }
+  // RenderViews draws in view coordinates. We want (0,0)
+  // to be translated to (viewRect.x,viewRect.y) in the widget. So:
+  localcx->Translate(viewRect.x, viewRect.y);
+
+  // Note that nsIRenderingContext::SetClipRegion always works in pixel coordinates,
+  // and nsIRenderingContext::SetClipRect always works in app coordinates. Stupid huh?
+  // Also, SetClipRegion doesn't subject its argument to the current transform, but
+  // SetClipRect does.
+  localcx->SetClipRegion(*aRegion, nsClipCombine_kReplace);
+  localcx->SetClipRect(damageRect, nsClipCombine_kIntersect);
+
+  nsRegion opaqueRegion;
+  AddCoveringWidgetsToOpaqueRegion(opaqueRegion, mContext, aView);
+  damageRegion.Sub(damageRegion, opaqueRegion);
+
+  RenderViews(aView, *localcx, damageRegion, ds);
+
+  // undo earlier translation
+  localcx->Translate(-viewRect.x, -viewRect.y);
+  if (usingDoubleBuffer) {
+    // Flush bits back to the screen
+
+    // Restore aRegion to pixels-relative-to-widget-origin
+    aRegion->Offset(widgetDamageRectInPixels.x, widgetDamageRectInPixels.y);
+    // Restore translation to its previous state
+    localcx->PopTranslation(&trans);
+    // Make damageRect twips-relative-to-widget-origin
+    damageRect.MoveBy(-viewRect.x, -viewRect.y);
+    // Reset clip region to widget-relative
+    localcx->SetClipRegion(*aRegion, nsClipCombine_kReplace);
+    localcx->SetClipRect(damageRect, nsClipCombine_kIntersect);
+    // neither source nor destination are transformed
+    localcx->CopyOffScreenBits(ds, 0, 0, widgetDamageRectInPixels, NS_COPYBITS_USE_SOURCE_CLIP_REGION);
+    localcx->ReleaseBackbuffer();
+  }
+#endif
 
   SetPainting(PR_FALSE);
 
   // notify the listeners.
   if (nsnull != mCompositeListeners) {
     PRUint32 listenerCount;
     if (NS_SUCCEEDED(mCompositeListeners->Count(&listenerCount))) {
       nsCOMPtr<nsICompositeListener> listener;
       for (PRUint32 i = 0; i < listenerCount; i++) {
         if (NS_SUCCEEDED(mCompositeListeners->QueryElementAt(i, NS_GET_IID(nsICompositeListener), getter_AddRefs(listener)))) {
@@ -647,34 +768,80 @@ void nsViewManager::AddCoveringWidgetsTo
           // view of aRootView?); if so, don't use it
           if (viewParent) {
             aRgn.Or(aRgn, bounds);
           }
         }
       }
     }
   }
 }
 
+/*
+  aRCSurface is the drawing surface being used to double-buffer aRC, or null
+  if no double-buffering is happening. We pass this in here so that we can
+  blend directly into the double-buffer offscreen memory.
+*/
 void nsViewManager::RenderViews(nsView *aView, nsIRenderingContext& aRC,
-                                const nsRegion& aRegion)
+                                const nsRegion& aRegion, nsIDrawingSurface* aRCSurface)
 {
+#ifndef MOZ_CAIRO_GFX
+  BlendingBuffers* buffers = nsnull;
+  nsIWidget* widget = aView->GetWidget();
+  PRBool translucentWindow = PR_FALSE;
+  if (widget) {
+    widget->GetWindowTranslucency(translucentWindow);
+    if (translucentWindow) {
+      NS_WARNING("Transparent window enabled");
+      NS_ASSERTION(aRCSurface, "Cannot support transparent windows with doublebuffering disabled");
+
+      // Create a buffer wrapping aRC (which is usually the double-buffering offscreen buffer).
+      buffers = CreateBlendingBuffers(&aRC, PR_TRUE, aRCSurface, translucentWindow, aRegion.GetBounds());
+      NS_ASSERTION(buffers, "Failed to create rendering buffers");
+      if (!buffers)
+        return;
+    }
+  }
+#endif
+
   if (mObserver) {
     nsView* displayRoot = GetDisplayRootFor(aView);
     nsPoint offsetToRoot = aView->GetOffsetTo(displayRoot); 
     nsRegion damageRegion(aRegion);
     damageRegion.MoveBy(offsetToRoot);
     
     aRC.PushState();
     aRC.Translate(-offsetToRoot.x, -offsetToRoot.y);
     mObserver->Paint(displayRoot, &aRC, damageRegion);
     aRC.PopState();
+#ifndef MOZ_CAIRO_GFX
+    if (translucentWindow)
+      mObserver->Paint(displayRoot, buffers->mWhiteCX, aRegion);
+#endif
+  }
+
+#ifndef MOZ_CAIRO_GFX
+  if (translucentWindow) {
+    // Get the alpha channel into an array so we can send it to the widget
+    nsRect r = aRegion.GetBounds();
+    r *= (1.0f / mContext->AppUnitsPerDevPixel());
+    nsRect bufferRect(0, 0, r.width, r.height);
+    PRUint8* alphas = nsnull;
+    nsresult rv = mBlender->GetAlphas(bufferRect, buffers->mBlack,
+                                      buffers->mWhite, &alphas);
+    
+    if (NS_SUCCEEDED(rv)) {
+      widget->UpdateTranslucentWindowAlpha(r, alphas);
+    }
+    delete[] alphas;
+    delete buffers;
   }
+#endif
 }
 
 static nsresult NewOffscreenContext(nsIDeviceContext* deviceContext, nsIDrawingSurface* surface,
                                     const nsRect& aRect, nsIRenderingContext* *aResult)
 {
   nsresult             rv;
   nsIRenderingContext *context = nsnull;
 
   rv = deviceContext->CreateRenderingContext(surface, context);
   if (NS_FAILED(rv))
@@ -1169,24 +1336,26 @@ NS_IMETHODIMP nsViewManager::DispatchEve
             if (vm->mDelayedResize != nsSize(NSCOORD_NONE, NSCOORD_NONE) &&
                 IsViewVisible(vm->mRootView)) {
               vm->DoSetWindowDimensions(vm->mDelayedResize.width,
                                         vm->mDelayedResize.height);
               vm->mDelayedResize.SizeTo(NSCOORD_NONE, NSCOORD_NONE);
 
               // Paint later.
               vm->UpdateView(vm->mRootView, NS_VMREFRESH_NO_SYNC);
               didResize = PR_TRUE;
 
+#ifdef MOZ_CAIRO_GFX
               // not sure if it's valid for us to claim that we
               // ignored this, but we're going to do so anyway, since
               // we didn't actually paint anything
               *aStatus = nsEventStatus_eIgnore;
+#endif
             }
           }
 
           if (!didResize) {
             //NS_ASSERTION(IsViewVisible(view), "painting an invisible view");
 
             // Just notify our own view observer that we're about to paint
             // XXXbz do we need to notify other view observers for viewmanagers
             // in our tree?
             // Make sure to not send WillPaint notifications while scrolling
@@ -1280,20 +1449,23 @@ NS_IMETHODIMP nsViewManager::DispatchEve
       *aStatus = nsEventStatus_eConsumeNoDefault;
       break;
 
 
     case NS_DISPLAYCHANGED:
 
       //Destroy the cached backbuffer to force a new backbuffer
       //be constructed with the appropriate display depth.
       //@see bugzilla bug 6061
       *aStatus = nsEventStatus_eConsumeDoDefault;
+      if (gCleanupContext) {
+        gCleanupContext->DestroyCachedBackbuffer();
+      }
       break;
 
     case NS_SYSCOLORCHANGED:
       {
         // Hold a refcount to the observer. The continued existence of the observer will
         // delay deletion of this view hierarchy should the event want to cause its
         // destruction in, say, some JavaScript event handler.
         nsView *view = nsView::GetViewFor(aEvent->widget);
         nsCOMPtr<nsIViewObserver> obs = GetViewObserver();
         if (obs) {
@@ -2380,20 +2552,28 @@ NS_IMETHODIMP nsViewManager::GetRectVisi
     *aRectVisibility = nsRectVisibility_kLeftOfViewport;
   else if (absRect.x + absRect.width > visibleRect.x  + visibleRect.width &&
            absRect.x > visibleRect.x + visibleRect.width - aMinTwips)
     *aRectVisibility = nsRectVisibility_kRightOfViewport;
   else
     *aRectVisibility = nsRectVisibility_kVisible;
 
   return NS_OK;
 }
 
+
+NS_IMETHODIMP
+nsViewManager::AllowDoubleBuffering(PRBool aDoubleBuffer)
+{
+  mAllowDoubleBuffering = aDoubleBuffer;
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 nsViewManager::IsPainting(PRBool& aIsPainting)
 {
   aIsPainting = IsPainting();
   return NS_OK;
 }
 
 void
 nsViewManager::FlushPendingInvalidates()
 {
diff -ruN -p -U10 mozilla.orig/view/src/nsViewManager.h mozilla/view/src/nsViewManager.h
--- mozilla.orig/view/src/nsViewManager.h	2007-05-30 07:27:41.000000000 +0300
+++ mozilla/view/src/nsViewManager.h	2007-05-30 07:29:17.000000000 +0300
@@ -227,20 +227,21 @@ public:
                              nscolor aBackgroundColor,
                              nsIRenderingContext** aRenderedContext);
 
   NS_IMETHOD AddCompositeListener(nsICompositeListener *aListener);
   NS_IMETHOD RemoveCompositeListener(nsICompositeListener *aListener);
 
   NS_IMETHOD GetWidget(nsIWidget **aWidget);
   nsIWidget* GetWidget() { return mRootView ? mRootView->GetWidget() : nsnull; }
   NS_IMETHOD ForceUpdate();
  
+  NS_IMETHOD AllowDoubleBuffering(PRBool aDoubleBuffer);
   NS_IMETHOD IsPainting(PRBool& aIsPainting);
   NS_IMETHOD SetDefaultBackgroundColor(nscolor aColor);
   NS_IMETHOD GetDefaultBackgroundColor(nscolor* aColor);
   NS_IMETHOD GetLastUserEventTime(PRUint32& aTime);
   void ProcessInvalidateEvent();
   static PRInt32 GetViewManagerCount();
   static const nsVoidArray* GetViewManagerArray();
   static PRUint32 gLastUserEventTime;
 
   /**
@@ -277,21 +278,21 @@ private:
 
   void UpdateViews(nsView *aView, PRUint32 aUpdateFlags);
 
   void Refresh(nsView *aView, nsIRenderingContext *aContext,
                nsIRegion *region, PRUint32 aUpdateFlags);
   /**
    * Refresh aView (which must be non-null) with our default background color
    */
   void DefaultRefresh(nsView* aView, nsIRenderingContext *aContext, const nsRect* aRect);
   void RenderViews(nsView *aRootView, nsIRenderingContext& aRC,
-                   const nsRegion& aRegion);
+                   const nsRegion& aRegion, nsIDrawingSurface* aRCSurface);
 
   void InvalidateRectDifference(nsView *aView, const nsRect& aRect, const nsRect& aCutOut, PRUint32 aUpdateFlags);
   void InvalidateHorizontalBandDifference(nsView *aView, const nsRect& aRect, const nsRect& aCutOut,
                                           PRUint32 aUpdateFlags, nscoord aY1, nscoord aY2, PRBool aInCutOut);
 
   virtual BlendingBuffers* CreateBlendingBuffers(nsIRenderingContext *aRC, PRBool aBorrowContext,
                                                  nsIDrawingSurface* aBorrowSurface, PRBool aNeedAlpha,
                                                  const nsRect& aArea);
   virtual nsIBlender* GetBlender() { return mBlender; }
 
@@ -478,20 +479,21 @@ private:
   // visible again.
   nsSize            mDelayedResize;
 
   nsCOMPtr<nsIBlender> mBlender;
   nsISupportsArray  *mCompositeListeners;
   nsCOMPtr<nsIFactory> mRegionFactory;
   nsView            *mRootView;
   // mRootViewManager is a strong ref unless it equals |this|.  It's
   // never null (if we have no ancestors, it will be |this|).
   nsViewManager     *mRootViewManager;
+  PRPackedBool      mAllowDoubleBuffering;
 
   nsRevocableEventPtr<nsViewManagerEvent> mSynthMouseMoveEvent;
   nsRevocableEventPtr<nsViewManagerEvent> mInvalidateEvent;
 
   // The following members should not be accessed directly except by
   // the root view manager.  Some have accessor functions to enforce
   // this, as noted.
   
   // Use GrabMouseEvents() and GetMouseEventGrabber() to access mMouseGrabber.
   nsView            *mMouseGrabber;
