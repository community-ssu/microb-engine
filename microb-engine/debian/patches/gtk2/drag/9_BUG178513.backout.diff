Index: mozilla/widget/src/build/Makefile.in
===================================================================
--- mozilla.orig/widget/src/build/Makefile.in
+++ mozilla/widget/src/build/Makefile.in
@@ -57,20 +57,16 @@
 		  necko \
 		  uconv \
 		  gfx \
 		  dom \
 		  timer \
 		  accessibility \
 		  $(NULL)
 
-ifeq ($(MOZ_ENABLE_CAIRO_GFX),1)
-REQUIRES += thebes cairo
-endif
-
 CPPSRCS		= nsWinWidgetFactory.cpp
 
 EXTRA_DSO_LIBS	= gkgfx
 
 ifdef MOZ_ENABLE_CAIRO_GFX
 EXTRA_DSO_LIBS	+= thebes
 endif
 
Index: mozilla/widget/src/xpwidgets/Makefile.in
===================================================================
--- mozilla.orig/widget/src/xpwidgets/Makefile.in
+++ mozilla/widget/src/xpwidgets/Makefile.in
@@ -47,17 +47,16 @@
 LIBXUL_LIBRARY  = 1
 
 REQUIRES	= xpcom \
 		  string \
 		  gfx \
 		  layout \
 		  content \
 		  dom \
-		  imglib2 \
 		  pref \
 		  locale \
 		  necko \
 		  htmlparser \
 		  uconv \
 		  unicharutil \
 		  view \
 		  windowwatcher \
Index: mozilla/widget/src/xpwidgets/nsBaseDragService.cpp
===================================================================
--- mozilla.orig/widget/src/xpwidgets/nsBaseDragService.cpp
+++ mozilla/widget/src/xpwidgets/nsBaseDragService.cpp
@@ -42,62 +42,41 @@
 #include "nsIServiceManager.h"
 #include "nsITransferable.h"
 #include "nsISupportsArray.h"
 #include "nsSize.h"
 #include "nsIRegion.h"
 #include "nsXPCOM.h"
 #include "nsISupportsPrimitives.h"
 #include "nsCOMPtr.h"
-#include "nsIInterfaceRequestorUtils.h"
 #include "nsIFrame.h"
 #include "nsIDocument.h"
 #include "nsIContent.h"
 #include "nsIPresShell.h"
 #include "nsIViewManager.h"
-#include "nsIScrollableView.h"
 #include "nsIDOMNode.h"
-#include "nsIDOMMouseEvent.h"
-#include "nsISelection.h"
-#include "nsISelectionPrivate.h"
 #include "nsPresContext.h"
-#include "nsIEventStateManager.h"
-#include "nsICanvasElement.h"
-#include "nsIImage.h"
-#include "nsIImageLoadingContent.h"
-#include "gfxIImageFrame.h"
-#include "imgIContainer.h"
-#include "imgIRequest.h"
-#include "nsIViewObserver.h"
-#include "nsRegion.h"
-#include "nsGUIEvent.h"
 #include "nsIPrefService.h"
 
-#ifdef MOZ_CAIRO_GFX
-#include "gfxContext.h"
-#include "gfxImageSurface.h"
-
-#endif
 
 #define DRAGIMAGES_PREF "nglayout.enable_drag_images"
 
 NS_IMPL_ADDREF(nsBaseDragService)
 NS_IMPL_RELEASE(nsBaseDragService)
 NS_IMPL_QUERY_INTERFACE2(nsBaseDragService, nsIDragService, nsIDragSession)
 
 
 //-------------------------------------------------------------------------
 //
 // DragService constructor
 //
 //-------------------------------------------------------------------------
 nsBaseDragService::nsBaseDragService()
-  : mCanDrop(PR_FALSE), mDoingDrag(PR_FALSE), mHasImage(PR_FALSE),
-    mDragAction(DRAGDROP_ACTION_NONE), mTargetSize(0,0),
-    mImageX(0), mImageY(0), mScreenX(-1), mScreenY(-1)
+  : mCanDrop(PR_FALSE), mDoingDrag(PR_FALSE),
+    mDragAction(DRAGDROP_ACTION_NONE), mTargetSize(0,0)
 {
 }
 
 //-------------------------------------------------------------------------
 //
 // DragService destructor
 //
 //-------------------------------------------------------------------------
@@ -207,21 +186,22 @@
 //-------------------------------------------------------------------------
 NS_IMETHODIMP
 nsBaseDragService::IsDataFlavorSupported(const char *aDataFlavor,
                                          PRBool *_retval)
 {
   return NS_ERROR_FAILURE;
 }
 
+
 //-------------------------------------------------------------------------
 NS_IMETHODIMP
 nsBaseDragService::InvokeDragSession(nsIDOMNode *aDOMNode,
-                                     nsISupportsArray* aTransferableArray,
-                                     nsIScriptableRegion* aDragRgn,
+                                     nsISupportsArray * anArrayTransferables,
+                                     nsIScriptableRegion * aRegion,
                                      PRUint32 aActionType)
 {
   NS_ENSURE_TRUE(aDOMNode, NS_ERROR_INVALID_ARG);
 
   // stash the document of the dom node
   aDOMNode->GetOwnerDocument(getter_AddRefs(mSourceDocument));
   mSourceNode = aDOMNode;
 
@@ -243,63 +223,16 @@
         }
       }
     }
   }
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
-nsBaseDragService::InvokeDragSessionWithImage(nsIDOMNode* aDOMNode,
-                                              nsISupportsArray* aTransferableArray,
-                                              nsIScriptableRegion* aRegion,
-                                              PRUint32 aActionType,
-                                              nsIDOMNode* aImage,
-                                              PRInt32 aImageX, PRInt32 aImageY,
-                                              nsIDOMMouseEvent* aDragEvent)
-{
-  NS_ENSURE_TRUE(aDragEvent, NS_ERROR_NULL_POINTER);
-
-  mSelection = nsnull;
-  mHasImage = PR_TRUE;
-  mImage = aImage;
-  mImageX = aImageX;
-  mImageY = aImageY;
-
-  aDragEvent->GetScreenX(&mScreenX);
-  aDragEvent->GetScreenY(&mScreenY);
-
-  return InvokeDragSession(aDOMNode, aTransferableArray, aRegion, aActionType);
-}
-
-NS_IMETHODIMP
-nsBaseDragService::InvokeDragSessionWithSelection(nsISelection* aSelection,
-                                                  nsISupportsArray* aTransferableArray,
-                                                  PRUint32 aActionType,
-                                                  nsIDOMMouseEvent* aDragEvent)
-{
-  NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
-  NS_ENSURE_TRUE(aDragEvent, NS_ERROR_NULL_POINTER);
-
-  mSelection = aSelection;
-  mHasImage = PR_TRUE;
-  mImage = nsnull;
-  mImageX = 0;
-  mImageY = 0;
-
-  aDragEvent->GetScreenX(&mScreenX);
-  aDragEvent->GetScreenY(&mScreenY);
-
-  // just get the focused node from the selection
-  nsCOMPtr<nsIDOMNode> node;
-  aSelection->GetFocusNode(getter_AddRefs(node));
-
-  return InvokeDragSession(node, aTransferableArray, nsnull, aActionType);
-}
 
 //-------------------------------------------------------------------------
 NS_IMETHODIMP
 nsBaseDragService::GetCurrentSession(nsIDragSession ** aSession)
 {
   if (!aSession)
     return NS_ERROR_INVALID_ARG;
 
@@ -323,270 +256,23 @@
     return NS_ERROR_FAILURE;
   }
   mDoingDrag = PR_TRUE;
   return NS_OK;
 }
 
 //-------------------------------------------------------------------------
 NS_IMETHODIMP
-nsBaseDragService::EndDragSession(PRBool aDoneDrag)
+nsBaseDragService::EndDragSession(PRBool aDoneDrag)
 {
   if (!mDoingDrag) {
     return NS_ERROR_FAILURE;
   }
 
-  if (aDoneDrag)
-    FireDragEventAtSource(NS_DRAGDROP_END);
 
   mDoingDrag = PR_FALSE;
 
   // release the source we've been holding on to.
   mSourceDocument = nsnull;
   mSourceNode = nsnull;
-  mSelection = nsnull;
-  mHasImage = PR_FALSE;
-  mImage = nsnull;
-  mImageX = 0;
-  mImageY = 0;
-  mScreenX = -1;
-  mScreenY = -1;
 
   return NS_OK;
 }
-
-NS_IMETHODIMP
-nsBaseDragService::FireDragEventAtSource(PRUint32 aMsg)
-{
-  if (mSourceNode) {
-    nsCOMPtr<nsIDocument> doc = do_QueryInterface(mSourceDocument);
-    if (doc) {
-      nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
-      if (presShell) {
-        nsEventStatus status = nsEventStatus_eIgnore;
-        nsMouseEvent event(PR_TRUE, aMsg, nsnull, nsMouseEvent::eReal);
-
-        nsCOMPtr<nsIContent> content = do_QueryInterface(mSourceNode);
-        return presShell->HandleDOMEventWithTarget(content, &event, &status);
-      }
-    }
-  }
-
-  return NS_OK;
-}
-
-#ifdef MOZ_CAIRO_GFX
-
-static nsIPresShell*
-GetPresShellForContent(nsIDOMNode* aDOMNode)
-{
-  nsCOMPtr<nsIContent> content = do_QueryInterface(aDOMNode);
-  nsCOMPtr<nsIDocument> document = content->GetCurrentDoc();
-  if (document) {
-    document->FlushPendingNotifications(Flush_Display);
-
-    return document->GetPrimaryShell();
-  }
-
-  return nsnull;
-}
-
-nsresult
-nsBaseDragService::DrawDrag(nsIDOMNode* aDOMNode,
-                            nsIScriptableRegion* aRegion,
-                            PRInt32 aScreenX, PRInt32 aScreenY,
-                            nsRect* aScreenDragRect,
-                            gfxASurface** aSurface)
-{
-  *aSurface = nsnull;
-
-  // use a default size, in case of an error.
-  aScreenDragRect->x = aScreenX - mImageX;
-  aScreenDragRect->y = aScreenY - mImageY;
-  aScreenDragRect->width = 20;
-  aScreenDragRect->height = 20;
-
-  // if a drag image was specified, use that, otherwise, use the source node
-  nsCOMPtr<nsIDOMNode> dragNode = mImage ? mImage.get() : aDOMNode;
-
-  // get the presshell for the node being dragged. If the drag image is not in
-  // a document or has no frame, get the presshell from the source drag node
-  nsIPresShell* presShell = GetPresShellForContent(dragNode);
-  if (!presShell && mImage)
-    presShell = GetPresShellForContent(aDOMNode);
-  if (!presShell)
-    return NS_ERROR_FAILURE;
-
-  // check if drag images are disabled
-  PRBool enableDragImages = PR_TRUE;
-  nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
-  if (prefs)
-    prefs->GetBoolPref(DRAGIMAGES_PREF, &enableDragImages);
-
-  // didn't want an image, so just set the screen rectangle to the frame size
-  if (!enableDragImages || !mHasImage) {
-    // if a region was specified, set the screen rectangle to the area that
-    // the region occupies
-    if (aRegion) {
-      // the region's coordinates are relative to the root frame
-      nsPresContext* pc = presShell->GetPresContext();
-      nsIFrame* rootFrame = presShell->GetRootFrame();
-      if (rootFrame && pc) {
-        nsRect dragRect;
-        aRegion->GetBoundingBox(&dragRect.x, &dragRect.y, &dragRect.width, &dragRect.height);
-        dragRect.ScaleRoundOut(nsPresContext::AppUnitsPerCSSPixel());
-        dragRect.ScaleRoundOut(1.0 / pc->AppUnitsPerDevPixel());
-
-        nsIntRect screenRect = rootFrame->GetScreenRectExternal();
-        aScreenDragRect->SetRect(screenRect.x + dragRect.x, screenRect.y + dragRect.y,
-                                 dragRect.width, dragRect.height);
-      }
-    }
-    else {
-      // otherwise, there was no region so just set the rectangle to
-      // the size of the primary frame of the content.
-      nsCOMPtr<nsIContent> content = do_QueryInterface(dragNode);
-      nsIFrame* frame = presShell->GetPrimaryFrameFor(content);
-      if (frame) {
-        nsIntRect screenRect = frame->GetScreenRectExternal();
-        aScreenDragRect->SetRect(screenRect.x, screenRect.y,
-                                 screenRect.width, screenRect.height);
-      }
-    }
-
-    return NS_OK;
-  }
-
-  // draw the image for selections
-  if (mSelection) {
-    nsPoint pnt(aScreenDragRect->x, aScreenDragRect->y);
-    nsRefPtr<gfxASurface> surface = presShell->RenderSelection(mSelection, pnt, aScreenDragRect);
-    *aSurface = surface;
-    NS_IF_ADDREF(*aSurface);
-    return NS_OK;
-  }
-
-  // if an custom image was specified, check if it is an image node and draw
-  // using the source rather than the displayed image. But if mImage isn't
-  // an image, fall through to RenderNode below.
-  if (mImage) {
-    nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(dragNode);
-    // for image nodes, create the drag image from the actual image data
-    if (imageLoader) {
-      nsPresContext* pc = presShell->GetPresContext();
-      if (!pc)
-        return NS_ERROR_FAILURE;
-
-      return DrawDragForImage(pc, imageLoader, aScreenX, aScreenY,
-                              aScreenDragRect, aSurface);
-    }
-  }
-
-  // otherwise, just draw the node
-  nsCOMPtr<nsIRegion> clipRegion;
-  if (aRegion)
-    aRegion->GetRegion(getter_AddRefs(clipRegion));
-
-  nsPoint pnt(aScreenDragRect->x, aScreenDragRect->y);
-  nsRefPtr<gfxASurface> surface = presShell->RenderNode(dragNode, clipRegion,
-                                                        pnt, aScreenDragRect);
-
-  // if an image was specified, reposition the drag rectangle to
-  // the supplied offset in mImageX and mImageY.
-  if (mImage) {
-    aScreenDragRect->x = aScreenX - mImageX;
-    aScreenDragRect->y = aScreenY - mImageY;
-  }
-
-  *aSurface = surface;
-  NS_IF_ADDREF(*aSurface);
-
-  return NS_OK;
-}
-
-nsresult
-nsBaseDragService::DrawDragForImage(nsPresContext* aPresContext,
-                                    nsIImageLoadingContent* aImageLoader,
-                                    PRInt32 aScreenX, PRInt32 aScreenY,
-                                    nsRect* aScreenDragRect,
-                                    gfxASurface** aSurface)
-{
-  nsCOMPtr<imgIRequest> imgRequest;
-  nsresult rv = aImageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
-                                        getter_AddRefs(imgRequest));
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!imgRequest)
-    return NS_ERROR_NOT_AVAILABLE;
-
-  nsCOMPtr<imgIContainer> imgContainer;
-  rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!imgContainer)
-    return NS_ERROR_NOT_AVAILABLE;
-
-  nsCOMPtr<gfxIImageFrame> iframe;
-  imgContainer->GetCurrentFrame(getter_AddRefs(iframe));
-  if (!iframe)
-    return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIImage> img(do_GetInterface(iframe));
-  if (!img)
-    return NS_ERROR_FAILURE;
-
-  // use the size of the image as the size of the drag image
-  imgContainer->GetWidth(&aScreenDragRect->width);
-  imgContainer->GetHeight(&aScreenDragRect->height);
-
-  nsRect srcRect = *aScreenDragRect;
-  srcRect.MoveTo(0, 0);
-  nsRect destRect = srcRect;
-
-  if (destRect.width == 0 || destRect.height == 0)
-    return NS_ERROR_FAILURE;
-
-  // if the image is larger than half the screen size, scale it down. This
-  // scaling algorithm is the same as is used in nsPresShell::PaintRangePaintInfo
-  nsIDeviceContext* deviceContext = aPresContext->DeviceContext();
-  nsRect maxSize;
-  deviceContext->GetClientRect(maxSize);
-  nscoord maxWidth = aPresContext->AppUnitsToDevPixels(maxSize.width >> 1);
-  nscoord maxHeight = aPresContext->AppUnitsToDevPixels(maxSize.height >> 1);
-  if (destRect.width > maxWidth || destRect.height > maxHeight) {
-    float scale = 1.0;
-    if (destRect.width > maxWidth)
-      scale = PR_MIN(scale, float(maxWidth) / destRect.width);
-    if (destRect.height > maxHeight)
-      scale = PR_MIN(scale, float(maxHeight) / destRect.height);
-
-    destRect.width = NSToIntFloor(float(destRect.width) * scale);
-    destRect.height = NSToIntFloor(float(destRect.height) * scale);
-
-    aScreenDragRect->x = NSToIntFloor(aScreenX - float(mImageX) * scale);
-    aScreenDragRect->y = NSToIntFloor(aScreenY - float(mImageY) * scale);
-    aScreenDragRect->width = destRect.width;
-    aScreenDragRect->height = destRect.height;
-  }
-
-  nsRefPtr<gfxImageSurface> surface =
-    new gfxImageSurface(gfxIntSize(destRect.width, destRect.height),
-                        gfxImageSurface::ImageFormatARGB32);
-  if (!surface)
-    return NS_ERROR_FAILURE;
-
-  *aSurface = surface;
-  NS_ADDREF(*aSurface);
-
-  nsCOMPtr<nsIRenderingContext> rc;
-  deviceContext->CreateRenderingContextInstance(*getter_AddRefs(rc));
-  rc->Init(deviceContext, surface);
-
-  // clear the image before drawing
-  gfxContext context(surface);
-  context.SetOperator(gfxContext::OPERATOR_CLEAR);
-  context.Rectangle(gfxRect(0, 0, destRect.width, destRect.height));
-  context.Fill();
-
-  gfxRect inRect = gfxRect(srcRect.x, srcRect.y, srcRect.width, srcRect.height);
-  gfxRect outRect = gfxRect(destRect.x, destRect.y, destRect.width, destRect.height);
-  return img->Draw(*rc, inRect, outRect);
-}
-
-#endif
Index: mozilla/widget/src/xpwidgets/nsBaseDragService.h
===================================================================
--- mozilla.orig/widget/src/xpwidgets/nsBaseDragService.h
+++ mozilla/widget/src/xpwidgets/nsBaseDragService.h
@@ -39,29 +39,24 @@
 #define nsBaseDragService_h__
 
 #include "nsIDragService.h"
 #include "nsIDragSession.h"
 #include "nsITransferable.h"
 #include "nsISupportsArray.h"
 #include "nsIDOMDocument.h"
 #include "nsCOMPtr.h"
-#include "nsIRenderingContext.h"
-
-#ifdef MOZ_CAIRO_GFX
-#include "gfxImageSurface.h"
-#endif
 
 // translucency level for drag images
 #define DRAG_TRANSLUCENCY 0.65
 
 class nsIDOMNode;
 class nsIFrame;
 class nsPresContext;
-class nsIImageLoadingContent;
+
 
 /**
  * XP DragService wrapper base class
  */
 
 class nsBaseDragService : public nsIDragService,
                           public nsIDragSession
 {
@@ -74,71 +69,18 @@
   NS_DECL_ISUPPORTS
 
   //nsIDragSession and nsIDragService
   NS_DECL_NSIDRAGSERVICE
   NS_DECL_NSIDRAGSESSION
 
 protected:
 
-#ifdef MOZ_CAIRO_GFX
-  /**
-   * Draw the drag image, if any, to a surface and return it. The drag image
-   * is constructed from mImage if specified, or aDOMNode if mImage is null.
-   *
-   * aRegion may be used to draw only a subset of the element. This region
-   * should be supplied using x and y coordinates measured in css pixels
-   * that are relative to the upper-left corner of the window.
-   *
-   * aScreenX and aScreenY should be the screen coordinates of the mouse click
-   * for the drag.
-   *
-   * On return, aScreenDragRect will contain the screen coordinates of the
-   * area being dragged. This is used by the platform-specific part of the
-   * drag service to determine the drag feedback.
-   *
-   * If there is no drag image, the returned surface will be null, but
-   * aScreenDragRect will still be set to the drag area.
-   */
-  nsresult DrawDrag(nsIDOMNode* aDOMNode,
-                    nsIScriptableRegion* aRegion,
-                    PRInt32 aScreenX, PRInt32 aScreenY,
-                    nsRect* aScreenDragRect,
-                    gfxASurface** aSurface);
-
-  /**
-   * Draw a drag image for an image node. This is called by DrawDrag.
-   */
-  nsresult DrawDragForImage(nsPresContext* aPresContext,
-                            nsIImageLoadingContent* aImageLoader,
-                            PRInt32 aScreenX, PRInt32 aScreenY,
-                            nsRect* aScreenDragRect,
-                            gfxASurface** aSurface);
-#endif
-
   PRPackedBool mCanDrop;
   PRPackedBool mDoingDrag;
-  // true if mImage should be used to set a drag image
-  PRPackedBool mHasImage;
-
   PRUint32 mDragAction;
   nsSize mTargetSize;
   nsCOMPtr<nsIDOMNode> mSourceNode;
   nsCOMPtr<nsIDOMDocument> mSourceDocument;       // the document at the drag source. will be null
                                                   //  if it came from outside the app.
-
-  // used to determine the image to appear on the cursor while dragging
-  nsCOMPtr<nsIDOMNode> mImage;
-  // offset of cursor within the image 
-  PRInt32 mImageX;
-  PRInt32 mImageY;
-
-  // set if a selection is being dragged
-  nsCOMPtr<nsISelection> mSelection;
-
-  // the screen position where drag gesture occured, used for positioning the
-  // drag image when no image is specified. If a value is -1, no event was
-  // supplied so the screen position is not known
-  PRInt32 mScreenX;
-  PRInt32 mScreenY;
 };
 
 #endif // nsBaseDragService_h__
Index: mozilla/content/base/src/nsContentAreaDragDrop.cpp
===================================================================
--- mozilla.orig/content/base/src/nsContentAreaDragDrop.cpp
+++ mozilla/content/base/src/nsContentAreaDragDrop.cpp
@@ -114,19 +114,24 @@
     NS_INTERFACE_MAP_ENTRY(nsIFlavorDataProvider)
     NS_INTERFACE_MAP_ENTRY(nsIDragDropHandler)
 NS_INTERFACE_MAP_END
 
 
 class nsTransferableFactory
 {
 public:
+  static nsresult CreateFromEvent(nsIDOMEvent* inMouseEvent,
+                                  nsIFlavorDataProvider *inFlavorDataProvider,
+                                  nsITransferable** outTrans);
+
+protected:
   nsTransferableFactory(nsIDOMEvent* inMouseEvent,
                         nsIFlavorDataProvider *inFlavorDataProvider);
-  nsresult Produce(PRBool *aDragSelection, nsITransferable** outTrans);
+  nsresult Produce(nsITransferable** outTrans);
 
 private:
   nsresult ConvertStringsToTransferable(nsITransferable** outTrans);
   static nsresult GetDraggableSelectionData(nsISelection* inSelection,
                                             nsIDOMNode* inRealTargetNode,
                                             nsIDOMNode **outImageOrLinkNode,
                                             PRBool* outDragSelectedText);
   static already_AddRefed<nsIDOMNode> FindParentLinkNode(nsIDOMNode* inNode);
@@ -661,16 +666,25 @@
 
     if (window) {
       window->GetDocument(outDocument);
     }
   }
 }
 
 nsresult
+nsContentAreaDragDrop::CreateTransferable(nsIDOMEvent* inMouseEvent,
+                                          nsITransferable** outTrans)
+{
+  return nsTransferableFactory::CreateFromEvent(inMouseEvent,
+                                                NS_STATIC_CAST(nsIFlavorDataProvider*, this),
+                                                outTrans);
+}
+
+nsresult
 nsContentAreaDragDrop::GetHookEnumeratorFromEvent(nsIDOMEvent* inEvent,
                                                   nsISimpleEnumerator **outEnumerator)
 {
   *outEnumerator = nsnull;
 
   nsCOMPtr<nsIDOMDocument> domdoc;
   GetEventDocument(inEvent, getter_AddRefs(domdoc));
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domdoc);
@@ -736,20 +750,20 @@
                      "hook failure in AllowStartDrag");
 
         if (!allow)
           return NS_OK;
       }
     }
   }
 
-  PRBool isSelection = PR_FALSE;
   nsCOMPtr<nsITransferable> trans;
-  nsTransferableFactory factory(inMouseEvent, NS_STATIC_CAST(nsIFlavorDataProvider*, this));
-  factory.Produce(&isSelection, getter_AddRefs(trans));
+  nsresult rv = CreateTransferable(inMouseEvent, getter_AddRefs(trans));
+  if (NS_FAILED(rv))
+    return rv;
 
   if (trans) {
     // if the client has provided an override callback, let them manipulate
     // the flavors or drag data
     nsCOMPtr<nsISimpleEnumerator> enumerator;
     GetHookEnumeratorFromEvent(inMouseEvent, getter_AddRefs(enumerator));
     if (enumerator) {
       PRBool hasMoreHooks = PR_FALSE;
@@ -783,48 +797,28 @@
       return NS_ERROR_FAILURE;
     }
 
     transArray->InsertElementAt(trans, 0);
 
     // kick off the drag
     nsCOMPtr<nsIDOMEventTarget> target;
     inMouseEvent->GetTarget(getter_AddRefs(target));
+    nsCOMPtr<nsIDOMNode> targetNode(do_QueryInterface(target));
     nsCOMPtr<nsIDragService> dragService =
       do_GetService("@mozilla.org/widget/dragservice;1");
 
     if (!dragService) {
       return NS_ERROR_FAILURE;
     }
 
-    PRUint32 action = nsIDragService::DRAGDROP_ACTION_COPY +
-                      nsIDragService::DRAGDROP_ACTION_MOVE +
-                      nsIDragService::DRAGDROP_ACTION_LINK;
-
-    nsCOMPtr<nsIDOMMouseEvent> mouseEvent(do_QueryInterface(inMouseEvent));
-
-    if (isSelection) {
-      nsCOMPtr<nsIContent> targetContent(do_QueryInterface(target));
-      nsIDocument* doc = targetContent->GetCurrentDoc();
-      if (doc) {
-        nsIPresShell* presShell = doc->GetPrimaryShell();
-        if (presShell) {
-          nsISelection* selection =
-            presShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
-          return dragService->InvokeDragSessionWithSelection(selection,
-                                                             transArray,
-                                                             action,
-                                                             mouseEvent);
-        }
-      }
-    }
-
-    nsCOMPtr<nsIDOMNode> targetNode(do_QueryInterface(target));
-    dragService->InvokeDragSessionWithImage(targetNode, transArray, nsnull,
-                                            action, nsnull, 0, 0, mouseEvent);
+    dragService->InvokeDragSession(targetNode, transArray, nsnull,
+                                   nsIDragService::DRAGDROP_ACTION_COPY +
+                                   nsIDragService::DRAGDROP_ACTION_MOVE +
+                                   nsIDragService::DRAGDROP_ACTION_LINK);
   }
 
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 nsContentAreaDragDrop::HandleEvent(nsIDOMEvent *event)
@@ -945,16 +939,26 @@
       CallQueryInterface(file, aData);
       *aDataLen = sizeof(nsIFile*);
     }
   }
 
   return rv;
 }
 
+
+nsresult
+nsTransferableFactory::CreateFromEvent(nsIDOMEvent* inMouseEvent,
+                                       nsIFlavorDataProvider *dataProvider,
+                                       nsITransferable** outTrans)
+{
+  nsTransferableFactory factory(inMouseEvent, dataProvider);
+  return factory.Produce(outTrans);
+}
+
 nsTransferableFactory::nsTransferableFactory(nsIDOMEvent* inMouseEvent,
                                              nsIFlavorDataProvider *dataProvider)
   : mInstanceAlreadyUsed(PR_FALSE),
     mMouseEvent(inMouseEvent),
     mFlavorDataProvider(dataProvider)
 {
 }
 
@@ -1053,18 +1057,17 @@
       range->SelectNode(inNode);
       range->ToString(outNodeString);
     }
   }
 }
 
 
 nsresult
-nsTransferableFactory::Produce(PRBool* aDragSelection,
-                               nsITransferable** outTrans)
+nsTransferableFactory::Produce(nsITransferable** outTrans)
 {
   if (mInstanceAlreadyUsed) {
     return NS_ERROR_FAILURE;
   }
 
   if (!outTrans || !mMouseEvent || !mFlavorDataProvider) {
     return NS_ERROR_FAILURE;
   }
@@ -1103,17 +1106,16 @@
   window->GetSelection(getter_AddRefs(selection));
   if (!selection) {
     return NS_OK;
   }
 
   // if set, serialize the content under this node
   nsCOMPtr<nsIDOMNode> nodeToSerialize;
   PRBool useSelectedText = PR_FALSE;
-  *aDragSelection = PR_FALSE;
 
   {
     PRBool haveSelectedContent = PR_FALSE;
 
     // possible parent link node
     nsCOMPtr<nsIDOMNode> parentLink;
     nsCOMPtr<nsIDOMNode> draggedNode;
 
@@ -1160,17 +1162,16 @@
         // either plain text or anchor text is selected
         if (haveSelectedContent) {
           link = do_QueryInterface(selectedImageOrLinkNode);
           if (link && isAltKeyDown) {
             return NS_OK;
           }
 
           useSelectedText = PR_TRUE;
-          *aDragSelection = PR_TRUE;
         } else if (selectedImageOrLinkNode) {
           // an image is selected
           image = do_QueryInterface(selectedImageOrLinkNode);
         } else {
           // nothing is selected -
           //
           // look for draggable elements under the mouse
           //
Index: mozilla/content/base/src/nsContentAreaDragDrop.h
===================================================================
--- mozilla.orig/content/base/src/nsContentAreaDragDrop.h
+++ mozilla/content/base/src/nsContentAreaDragDrop.h
@@ -107,16 +107,18 @@
   static void NormalizeSelection(nsIDOMNode* inBaseNode,
                                  nsISelection* inSelection);
   static void GetEventDocument(nsIDOMEvent* inEvent,
                                nsIDOMDocument** outDocument);
 
   static nsresult SaveURIToFile(nsAString& inSourceURIString,
                                 nsIFile* inDestFile);
 
+  nsresult CreateTransferable(nsIDOMEvent* inMouseEvent,
+                              nsITransferable** outTrans);
   void ExtractURLFromData(const nsACString & inFlavor,
                           nsISupports* inDataWrapper, PRUint32 inDataLen,
                           nsAString & outURL);
   nsresult GetHookEnumeratorFromEvent(nsIDOMEvent* inEvent,
                                       nsISimpleEnumerator** outEnumerator);
 
   PRPackedBool mListenerInstalled;
 
Index: mozilla/widget/src/gtk2/nsDragService.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsDragService.cpp
+++ mozilla/widget/src/gtk2/nsDragService.cpp
@@ -53,20 +53,16 @@
 #include "nsXPIDLString.h"
 #include "nsPrimitiveHelpers.h"
 #include "prtime.h"
 #include "prthread.h"
 #include <gtk/gtkinvisible.h>
 #include <gdk/gdkx.h>
 #include "nsCRT.h"
 
-#ifdef MOZ_CAIRO_GFX
-#include "gfxASurface.h"
-#include "nsImageToPixbuf.h"
-#endif
 
 static PRLogModuleInfo *sDragLm = NULL;
 
 static const char gMimeListType[] = "application/x-moz-internal-item-list";
 static const char gMozUrlType[] = "_NETSCAPE_URL";
 static const char gTextUriListType[] = "text/uri-list";
 
 NS_IMPL_ADDREF_INHERITED(nsDragService, nsBaseDragService)
@@ -197,40 +193,18 @@
         event.button.time = nsWindow::mLastButtonPressTime;
 
         // start our drag.
         GdkDragContext *context = gtk_drag_begin(mHiddenWidget,
                                                  sourceList,
                                                  action,
                                                  1,
                                                  &event);
-
-#ifdef MOZ_CAIRO_GFX
-        GdkPixbuf* dragPixbuf = nsnull;
-        nsRect dragRect;
-        if (mHasImage || mSelection) {
-          nsRefPtr<gfxASurface> surface;
-          DrawDrag(aDOMNode, aRegion, mScreenX, mScreenY,
-                   &dragRect, getter_AddRefs(surface));
-          if (surface) {
-            dragPixbuf =
-              nsImageToPixbuf::SurfaceToPixbuf(surface, dragRect.width, dragRect.height);
-          }
-        }
-
-        if (dragPixbuf)
-          gtk_drag_set_icon_pixbuf(context, dragPixbuf,
-                                   mScreenX - NSToIntRound(dragRect.x),
-                                   mScreenY - NSToIntRound(dragRect.y));
-        else
-          gtk_drag_set_icon_default(context);
-#else
-        // use a default icon
+        // make sure to set our default icon
         gtk_drag_set_icon_default(context);
-#endif
         gtk_target_list_unref(sourceList);
     }
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDragService::StartDragSession()
Index: mozilla/widget/public/nsIDragService.idl
===================================================================
--- mozilla.orig/widget/public/nsIDragService.idl
+++ mozilla/widget/public/nsIDragService.idl
@@ -39,20 +39,18 @@
 
 #include "nsISupports.idl"
 #include "nsISupportsArray.idl"
 #include "nsIDragSession.idl"
 #include "nsIScriptableRegion.idl"
 
 
 interface nsIDOMNode;
-interface nsIDOMMouseEvent;
-interface nsISelection;
 
-[scriptable, uuid(E8CD74A6-8BB6-4D27-9C65-4ED1B4398F8C)]
+[scriptable, uuid(8B5314BB-DB01-11d2-96CE-0060B0FB9956)]
 interface nsIDragService : nsISupports
 {
   const long DRAGDROP_ACTION_NONE = 0;
   const long DRAGDROP_ACTION_COPY = 1;
   const long DRAGDROP_ACTION_MOVE = 2;
   const long DRAGDROP_ACTION_LINK = 4;
 
   /**
@@ -62,60 +60,16 @@
     * @param  aRegion - a region containing rectangles for cursor feedback, 
     *            in window coordinates.
     * @param  aActionType - specified which of copy/move/link are allowed
     */
   void invokeDragSession ( in nsIDOMNode aDOMNode, in nsISupportsArray aTransferables, 
                              in nsIScriptableRegion aRegion, in unsigned long aActionType );
 
   /**
-   * Starts a modal drag session using an image. The first four arguments are
-   * the same as invokeDragSession.
-   *
-   * A custom image may be specified using the aImage argument. If this is
-   * supplied, the aImageX and aImageY arguments specify the offset within
-   * the image where the cursor would be positioned. That is, when the image
-   * is drawn, it is offset up and left the amount so that the cursor appears
-   * at that location within the image.
-   *
-   * If aImage is null, aImageX and aImageY are not used and the image is instead
-   * determined from the source node aDOMNode, and the offset calculated so that
-   * the initial location for the image appears in the same screen position as
-   * where the element is located. The node must be within a document.
-   *
-   * Currently, supported images are all DOM nodes. If this is an HTML <image> or
-   * <canvas>, the drag image is taken from the image data. If the element is in
-   * a document, it will be rendered at its displayed size, othewise, it will be
-   * rendered at its real size. For other types of elements, the element is
-   * rendered into an offscreen buffer in the same manner as it is currently
-   * displayed. The document selection is hidden while drawing.
-   *
-   * The aDragEvent must be supplied as the current screen coordinates of the
-   * event are needed to calculate the image location.
-   */
-  void invokeDragSessionWithImage(in nsIDOMNode aDOMNode,
-                                  in nsISupportsArray aTransferableArray,
-                                  in nsIScriptableRegion aRegion,
-                                  in unsigned long aActionType,
-                                  in nsIDOMNode aImage,
-                                  in long aImageX,
-                                  in long aImageY,
-                                  in nsIDOMMouseEvent aDragEvent);
-
-  /**
-   * Start a modal drag session using the selection as the drag image.
-   * The aDragEvent must be supplied as the current screen coordinates of the
-   * event are needed to calculate the image location.
-   */
-  void invokeDragSessionWithSelection(in nsISelection aSelection,
-                                      in nsISupportsArray aTransferableArray,
-                                      in unsigned long aActionType,
-                                      in nsIDOMMouseEvent aDragEvent);
-
-  /**
     * Returns the current Drag Session  
     */
   nsIDragSession getCurrentSession ( ) ;
 
   /**
     * Tells the Drag Service to start a drag session. This is called when
     * an external drag occurs
     */
Index: mozilla/layout/base/nsIPresShell.h
===================================================================
--- mozilla.orig/layout/base/nsIPresShell.h
+++ mozilla/layout/base/nsIPresShell.h
@@ -83,25 +83,23 @@
 class nsICaret;
 class nsStyleContext;
 class nsFrameSelection;
 class nsFrameManager;
 class nsILayoutHistoryState;
 class nsIReflowCallback;
 class nsISupportsArray;
 class nsIDOMNode;
-class nsIRegion;
 class nsIStyleFrameConstruction;
 class nsIStyleSheet;
 class nsCSSFrameConstructor;
 class nsISelection;
 template<class E> class nsCOMArray;
 class nsWeakFrame;
 class nsIScrollableFrame;
-class gfxASurface;
 
 typedef short SelectionType;
 typedef PRUint32 nsFrameState;
 
 // DC543B71-6F1A-4B9F-B4CF-693AEC4BA24A
 #define NS_IPRESSHELL_IID \
 { 0xdc543b71, 0x6f1a, 0x4b9f, \
   { 0xb4, 0xcf, 0x69, 0x3a, 0xec, 0x4b, 0xa2, 0x4a } }
@@ -689,46 +687,16 @@
    * In all cases the caller must clean it up by calling
    * cx->DestroyDrawingSurface(cx->GetDrawingSurface()).
    */
   NS_IMETHOD RenderOffscreen(nsRect aRect, PRBool aUntrusted,
                              PRBool aIgnoreViewportScrolling,
                              nscolor aBackgroundColor,
                              nsIRenderingContext** aRenderedContext) = 0;
 
-  /**
-   * Renders a node aNode to a surface and returns it. The aRegion may be used
-   * to clip the rendering. This region is measured in device pixels from the
-   * edge of the presshell area. The aPoint, aScreenRect and aSurface
-   * arguments function in a similar manner as RenderSelection.
-   */
-  virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
-                                                   nsIRegion* aRegion,
-                                                   nsPoint& aPoint,
-                                                   nsRect* aScreenRect) = 0;
-
-  /*
-   * Renders a selection to a surface and returns it. This method is primarily
-   * intended to create the drag feedback when dragging a selection.
-   *
-   * aScreenRect will be filled in with the bounding rectangle of the
-   * selection area on screen.
-   *
-   * If the area of the selection is large, the image will be scaled down.
-   * The argument aPoint is used in this case as a reference point when
-   * determining the new screen rectangle after scaling. Typically, this
-   * will be the mouse position, so that the screen rectangle is positioned
-   * such that the mouse is over the same point in the scaled image as in
-   * the original. When scaling does not occur, the mouse point isn't used
-   * as the position can be determined from the displayed frames.
-   */
-  virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
-                                                        nsPoint& aPoint,
-                                                        nsRect* aScreenRect) = 0;
-
   virtual void HidePopups() = 0;
 
   void AddWeakFrame(nsWeakFrame* aWeakFrame);
   void RemoveWeakFrame(nsWeakFrame* aWeakFrame);
 
 #ifdef NS_DEBUG
   nsIFrame* GetDrawEventTargetFrame() { return mDrawEventTargetFrame; }
 #endif
Index: mozilla/widget/src/gtk2/nsImageToPixbuf.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsImageToPixbuf.cpp
+++ mozilla/widget/src/gtk2/nsImageToPixbuf.cpp
@@ -72,69 +72,56 @@
 {
 #ifdef MOZ_CAIRO_GFX
     PRInt32 width = aImage->GetWidth(),
             height = aImage->GetHeight();
 
     nsRefPtr<gfxASurface> surface;
     aImage->GetSurface(getter_AddRefs(surface));
 
-    return SurfaceToPixbuf(surface, width, height);
-#else
-    nsCOMPtr<nsIGdkPixbufImage> img(do_QueryInterface(aImage));
-    if (img)
-        return img->GetGdkPixbuf();
-    return NULL;
-#endif
-}
-
-#ifdef MOZ_CAIRO_GFX
-GdkPixbuf*
-nsImageToPixbuf::SurfaceToPixbuf(gfxASurface* aSurface, PRInt32 aWidth, PRInt32 aHeight)
-{
     if (aSurface->CairoStatus()) {
         NS_ERROR("invalid surface");
         return nsnull;
     }
 
     nsRefPtr<gfxImageSurface> imgSurface;
-    if (aSurface->GetType() == gfxASurface::SurfaceTypeImage) {
+    if (surface->GetType() == gfxASurface::SurfaceTypeImage) {
         imgSurface = NS_STATIC_CAST(gfxImageSurface*,
-                                    NS_STATIC_CAST(gfxASurface*, aSurface));
+                                    NS_STATIC_CAST(gfxASurface*, surface.get()));
     } else {
-        imgSurface = new gfxImageSurface(gfxIntSize(aWidth, aHeight),
+        imgSurface = new gfxImageSurface(gfxIntSize(width, height),
 					 gfxImageSurface::ImageFormatARGB32);
                                        
         if (!imgSurface)
             return nsnull;
 
         nsRefPtr<gfxContext> context = new gfxContext(imgSurface);
         if (!context)
             return nsnull;
 
         context->SetOperator(gfxContext::OPERATOR_SOURCE);
-        context->SetSource(aSurface);
+        context->SetSource(surface);
         context->Paint();
     }
 
     GdkPixbuf* pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, PR_TRUE, 8,
-                                       aWidth, aHeight);
+                                       width, height);
     if (!pixbuf)
         return nsnull;
 
     PRUint32 rowstride = gdk_pixbuf_get_rowstride (pixbuf);
     guchar* pixels = gdk_pixbuf_get_pixels (pixbuf);
 
     long cairoStride = imgSurface->Stride();
     unsigned char* cairoData = imgSurface->Data();
 
     gfxASurface::gfxImageFormat format = imgSurface->Format();
 
-    for (PRInt32 row = 0; row < aHeight; ++row) {
-        for (PRInt32 col = 0; col < aWidth; ++col) {
+    for (PRInt32 row = 0; row < height; ++row) {
+        for (PRInt32 col = 0; col < width; ++col) {
             guchar* pixel = pixels + row * rowstride + 4 * col;
 
             PRUint32* cairoPixel = NS_REINTERPRET_CAST(PRUint32*,
                                    (cairoData + row * cairoStride + 4 * col));
 
             if (format == gfxASurface::ImageFormatARGB32) {
                 const PRUint8 a = (*cairoPixel >> 24) & 0xFF;
                 const PRUint8 r = unpremultiply((*cairoPixel >> 16) & 0xFF, a);
@@ -156,10 +143,16 @@
                 *pixel++ = g;
                 *pixel++ = b;
                 *pixel++ = 0xFF; // A
             }
         }
     }
 
     return pixbuf;
-}
+#else
+    nsCOMPtr<nsIGdkPixbufImage> img(do_QueryInterface(aImage));
+    if (img)
+        return img->GetGdkPixbuf();
+    return NULL;
 #endif
+}
+
Index: mozilla/widget/src/gtk2/nsImageToPixbuf.h
===================================================================
--- mozilla.orig/widget/src/gtk2/nsImageToPixbuf.h
+++ mozilla/widget/src/gtk2/nsImageToPixbuf.h
@@ -35,30 +35,24 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef NSIMAGETOPIXBUF_H_
 #define NSIMAGETOPIXBUF_H_
 
 #include "nsIImageToPixbuf.h"
 
-class gfxASurface;
-
 class nsImageToPixbuf : public nsIImageToPixbuf {
     public:
         NS_DECL_ISUPPORTS
         NS_IMETHOD_(GdkPixbuf*) ConvertImageToPixbuf(nsIImage* aImage);
 
         // Friendlier version of ConvertImageToPixbuf for callers inside of
         // widget
         static GdkPixbuf* ImageToPixbuf(nsIImage* aImage);
-#ifdef MOZ_CAIRO_GFX
-        static GdkPixbuf* SurfaceToPixbuf(gfxASurface* aSurface,
-                                          PRInt32 aWidth, PRInt32 aHeight);
-#endif
     private:
         ~nsImageToPixbuf() {}
 };
 
 
 // fc2389b8-c650-4093-9e42-b05e5f0685b7
 #define NS_IMAGE_TO_PIXBUF_CID \
 { 0xfc2389b8, 0xc650, 0x4093, \
Index: mozilla/layout/generic/nsObjectFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsObjectFrame.cpp
+++ mozilla/layout/generic/nsObjectFrame.cpp
@@ -538,25 +538,16 @@
     return NS_OK;       //XXX why OK? MMP
   }
 
   nsIViewManager* viewMan = view->GetViewManager();
   // mark the view as hidden since we don't know the (x,y) until Paint
   // XXX is the above comment correct?
   viewMan->SetViewVisibility(view, nsViewVisibility_kHide);
 
-  // Turn off double buffering on the Mac. This depends on bug 49743 and partially
-  // fixes 32327, 19931 and 51787
-#ifdef XP_MACOSX
-  PRBool doubleBuffer =
-    nsContentUtils::GetBoolPref("plugin.enable_double_buffer");
-  
-  viewMan->AllowDoubleBuffering(doubleBuffer);
-#endif
-  
   //this is ugly. it was ripped off from didreflow(). MMP
   // Position and size view relative to its parent, not relative to our
   // parent frame (our parent frame may not have a view).
   
   nsIView* parentWithView;
   nsPoint origin;
   nsRect r(0, 0, mRect.width, mRect.height);
 
Index: mozilla/editor/libeditor/text/nsPlaintextDataTransfer.cpp
===================================================================
--- mozilla.orig/editor/libeditor/text/nsPlaintextDataTransfer.cpp
+++ mozilla/editor/libeditor/text/nsPlaintextDataTransfer.cpp
@@ -59,18 +59,16 @@
 #include "nsIClipboard.h"
 #include "nsITransferable.h"
 #include "nsIDragService.h"
 #include "nsIDOMNSUIEvent.h"
 
 // Misc
 #include "nsEditorUtils.h"
 #include "nsContentCID.h"
-#include "nsISelectionPrivate.h"
-#include "nsFrameSelection.h"
 
 NS_IMETHODIMP nsPlaintextEditor::PrepareTransferable(nsITransferable **transferable)
 {
   // Create generic Transferable for getting the data
   nsresult rv = CallCreateInstance("@mozilla.org/widget/transferable;1", transferable);
   if (NS_FAILED(rv))
     return rv;
 
@@ -398,28 +396,21 @@
     return NS_OK;
 
   /* invoke drag */
   nsCOMPtr<nsIDOMEventTarget> eventTarget;
   rv = aDragEvent->GetTarget(getter_AddRefs(eventTarget));
   if (NS_FAILED(rv)) return rv;
   nsCOMPtr<nsIDOMNode> domnode = do_QueryInterface(eventTarget);
 
-  nsCOMPtr<nsIScriptableRegion> selRegion;
-  nsCOMPtr<nsISelection> selection;
-  rv = GetSelection(getter_AddRefs(selection));
-  if (NS_FAILED(rv)) return rv;
-
   unsigned int flags;
   // in some cases we'll want to cut rather than copy... hmmmmm...
   flags = nsIDragService::DRAGDROP_ACTION_COPY + nsIDragService::DRAGDROP_ACTION_MOVE;
 
-  nsCOMPtr<nsIDOMMouseEvent> mouseEvent(do_QueryInterface(aDragEvent));
-  rv = dragService->InvokeDragSessionWithSelection(selection, transferableArray,
-                                                   flags, mouseEvent);
+  rv = dragService->InvokeDragSession(domnode, transferableArray, nsnull, flags);
   if (NS_FAILED(rv)) return rv;
 
   aDragEvent->StopPropagation();
 
   return rv;
 }
 
 NS_IMETHODIMP nsPlaintextEditor::Paste(PRInt32 aSelectionType)
Index: mozilla/layout/base/nsPresShell.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresShell.cpp
+++ mozilla/layout/base/nsPresShell.cpp
@@ -84,26 +84,24 @@
 #include "nsIDeviceContext.h"
 #include "nsEventStateManager.h"
 #include "nsDOMEvent.h"
 #include "nsGUIEvent.h"
 #include "nsHTMLParts.h"
 #include "nsContentUtils.h"
 #include "nsISelection.h"
 #include "nsISelectionController.h"
-#include "nsISelectionPrivate.h"
 #include "nsLayoutCID.h"
 #include "nsGkAtoms.h"
 #include "nsIDOMRange.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMNode.h"
 #include "nsIDOM3Node.h"
 #include "nsIDOMNodeList.h"
 #include "nsIDOMElement.h"
-#include "nsRange.h"
 #include "nsCSSPseudoElements.h"
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 #include "nsReadableUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsWeakReference.h"
 #include "nsIPageSequenceFrame.h"
 #include "nsICaret.h"
@@ -139,17 +137,16 @@
 #include "nsIFrameDebug.h"
 #endif
   // for |#ifdef DEBUG| code
 #include "nsSpaceManager.h"
 #include "prenv.h"
 #include "nsIAttribute.h"
 #include "nsIGlobalHistory2.h"
 #include "nsDisplayList.h"
-#include "nsIRegion.h"
 #include "nsRegion.h"
 
 #ifdef MOZ_REFLOW_PERF_DSP
 #include "nsIRenderingContext.h"
 #include "nsIFontMetrics.h"
 #endif
 
 #include "nsIReflowCallback.h"
@@ -158,18 +155,16 @@
 #include "nsIFocusController.h"
 #include "nsIPluginInstance.h"
 #include "nsIObjectFrame.h"
 #include "nsIObjectLoadingContent.h"
 #include "nsNetUtil.h"
 #include "nsEventDispatcher.h"
 #include "nsThreadUtils.h"
 #include "nsStyleSheetService.h"
-#include "gfxImageSurface.h"
-#include "gfxContext.h"
 
 // Drag & Drop, Clipboard
 #include "nsWidgetsCID.h"
 #include "nsIClipboard.h"
 #include "nsIClipboardHelper.h"
 #include "nsIDocShellTreeItem.h"
 #include "nsIURI.h"
 #include "nsIScrollableFrame.h"
@@ -208,36 +203,16 @@
 
 // convert a color value to a string, in the CSS format #RRGGBB
 // *  - initially created for bugs 31816, 20760, 22963
 static void ColorToString(nscolor aColor, nsAutoString &aString);
 
 // Class ID's
 static NS_DEFINE_CID(kFrameSelectionCID, NS_FRAMESELECTION_CID);
 
-// RangePaintInfo is used to paint ranges to offscreen buffers
-struct RangePaintInfo {
-  nsCOMPtr<nsIRange> mRange;
-  nsDisplayListBuilder mBuilder;
-  nsDisplayList mList;
-
-  // offset of builder's reference frame to the root frame
-  nsPoint mRootOffset;
-
-  RangePaintInfo(nsIRange* aRange, nsIFrame* aFrame)
-    : mRange(aRange), mBuilder(aFrame, PR_FALSE, PR_FALSE)
-  {
-  }
-
-  ~RangePaintInfo()
-  {
-    mList.DeleteAll();
-  }
-};
-
 #undef NOISY
 
 // ----------------------------------------------------------------------
 
 #ifdef NS_DEBUG
 // Set the environment variable GECKO_VERIFY_REFLOW_FLAGS to one or
 // more of the following flags (comma separated) for handy debug
 // output.
@@ -923,25 +898,16 @@
   virtual void Freeze();
   virtual void Thaw();
   
   NS_IMETHOD RenderOffscreen(nsRect aRect, PRBool aUntrusted,
                              PRBool aIgnoreViewportScrolling,
                              nscolor aBackgroundColor,
                              nsIRenderingContext** aRenderedContext);
 
-  virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
-                                                   nsIRegion* aRegion,
-                                                   nsPoint& aPoint,
-                                                   nsRect* aScreenRect);
-
-  virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
-                                                        nsPoint& aPoint,
-                                                        nsRect* aScreenRect);
-
   virtual void HidePopups();
 
   //nsIViewObserver interface
 
   NS_IMETHOD Paint(nsIView *aView,
                    nsIRenderingContext* aRenderingContext,
                    const nsRegion& aDirtyRegion);
   NS_IMETHOD ComputeRepaintRegionForCopy(nsIView*      aRootView,
@@ -1105,49 +1071,16 @@
     */
   nsresult ClearPreferenceStyleRules(void);
   nsresult CreatePreferenceStyleSheet(void);
   nsresult SetPrefLinkRules(void);
   nsresult SetPrefFocusRules(void);
   nsresult SetPrefNoScriptRule();
   nsresult SetPrefNoFramesRule(void);
 
-  // methods for painting a range to an offscreen buffer
-
-  // given a display list, clip the items within the list to
-  // the range
-  nsRect ClipListToRange(nsDisplayListBuilder *aBuilder,
-                         nsDisplayList* aList,
-                         nsIRange* aRange,
-                         nsIRenderingContext* aRenderingContext);
-
-  // create a RangePaintInfo for the range aRange containing the
-  // display list needed to paint the range to a surface
-  RangePaintInfo* CreateRangePaintInfo(nsIDOMRange* aRange,
-                                       nsIRenderingContext* aRenderingContext,
-                                       nsRect& aSurfaceRect);
-
-  /*
-   * Paint the items to a new surface and return it.
-   *
-   * aSelection - selection being painted, if any
-   * aRegion - clip region, if any
-   * aArea - area that the surface occupies, relative to the root frame
-   * aPoint - reference point, typically the mouse position
-   * aScreenRect - [out] set to the area of the screen the painted area should
-   *               be displayed at
-   */
-  already_AddRefed<gfxASurface>
-  PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
-                      nsISelection* aSelection,
-                      nsIRegion* aRegion,
-                      nsRect aArea,
-                      nsPoint& aPoint,
-                      nsRect* aScreenRect);
-
   /**
    * Methods to handle changes to user and UA sheet lists that we get
    * notified about.
    */
   void AddUserSheet(nsISupports* aSheet);
   void AddAgentSheet(nsISupports* aSheet);
   void RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet);
 
@@ -1212,18 +1145,16 @@
 
   MOZ_TIMER_DECLARE(mReflowWatch)  // Used for measuring time spent in reflow
   MOZ_TIMER_DECLARE(mFrameCreationWatch)  // Used for measuring time spent in frame creation 
 
 #ifdef MOZ_REFLOW_PERF
   ReflowCountMgr * mReflowCountMgr;
 #endif
 
-  nsresult CompleteMoveInner(PRBool aForward, PRBool aExtend, PRBool sScrollIntoView);
-  
 private:
 
   PRBool InZombieDocument(nsIContent *aContent);
   nsresult RetargetEventToParent(nsGUIEvent* aEvent,
                                  nsEventStatus*  aEventStatus);
 
   //helper funcs for event handling
 protected:
@@ -2870,22 +2801,16 @@
     scrollView->ScrollByWhole(!aForward);//TRUE = top, aForward TRUE=bottom
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 PresShell::CompleteMove(PRBool aForward, PRBool aExtend)
 {
-  return CompleteMoveInner(aForward, aExtend, PR_TRUE);
-}
-
-nsresult
-PresShell::CompleteMoveInner(PRBool aForward, PRBool aExtend, PRBool aScrollIntoView)
-{
   nsIScrollableView *scrollableView;
   if (!mViewManager) 
     return NS_ERROR_UNEXPECTED;
   nsresult result = mViewManager->GetRootScrollableView(&scrollableView);
   if (NS_FAILED(result)) 
     return result;
   if (!scrollableView) 
     return NS_ERROR_UNEXPECTED;
@@ -2909,24 +2834,17 @@
   }while(frameType != nsGkAtoms::areaFrame);
   
   if (!frame)
     return NS_ERROR_FAILURE; //could not find an area frame.
 
   nsPeekOffsetStruct pos = frame->GetExtremeCaretPosition(!aForward);
 
   mSelection->HandleClick(pos.mResultContent ,pos.mContentOffset ,pos.mContentOffset/*End*/ ,aExtend, PR_FALSE, aForward);
-
-  if (aScrollIntoView) {
-    result = ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, 
-                                     nsISelectionController::SELECTION_FOCUS_REGION, PR_TRUE);
-    if (NS_FAILED(result)) 
-      return result;
-  }
-  return NS_OK;
+  return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, nsISelectionController::SELECTION_FOCUS_REGION, PR_TRUE);
 }
 
 NS_IMETHODIMP 
 PresShell::SelectAll()
 {
   return mSelection->SelectAll();
 }
 
@@ -4192,28 +4110,16 @@
   if (ourWindow)
     CheckForFocus(ourWindow, focusController, mDocument);
 
   if (focusController) // Unsuppress now that we've shown the new window and focused it.
     focusController->SetSuppressFocus(PR_FALSE, "PresShell suppression on Web page loads");
 
   if (mViewManager)
     mViewManager->SynthesizeMouseMove(PR_FALSE);
-  
-  // If there is no selection, create a collapsed selection at the top of the document. 
-  if (mSelection) {
-    nsISelection* domSelection = mSelection->
-      GetSelection(nsISelectionController::SELECTION_NORMAL);
-    if (domSelection) {
-      PRInt32 rangeCount;
-      domSelection->GetRangeCount(&rangeCount);
-      if (rangeCount == 0)
-        CompleteMoveInner(PR_FALSE, PR_FALSE, PR_FALSE);
-    }
-  }
 }
 
 NS_IMETHODIMP
 PresShell::UnsuppressPainting()
 {
   if (mPaintSuppressionTimer) {
     mPaintSuppressionTimer->Cancel();
     mPaintSuppressionTimer = nsnull;
@@ -4785,389 +4691,16 @@
   // Flush the list so we don't trigger the IsEmpty-on-destruction assertion
   list.DeleteAll();
   
   localcx.swap(*aRenderedContext);
 
   return NS_OK;
 }
 
-/*
- * Clip the display list aList to a range. Returns the clipped
- * rectangle surrounding the range.
- */
-nsRect
-PresShell::ClipListToRange(nsDisplayListBuilder *aBuilder,
-                           nsDisplayList* aList,
-                           nsIRange* aRange,
-                           nsIRenderingContext* aRenderingContext)
-{
-  // iterate though the display items and add up the bounding boxes of each.
-  // This will allow the total area of the frames within the range to be
-  // determined. To do this, remove an item from the bottom of the list, check
-  // whether it should be part of the range, and if so, append it to the top
-  // of the temporary list tmpList. If the item is a text frame at the end of
-  // the selection range, wrap it in an nsDisplayClip to clip the display to
-  // the portion of the text frame that is part of the selection. Then, append
-  // the wrapper to the top of the list. Otherwise, just delete the item and
-  // don't append it.
-  nsRect surfaceRect;
-  nsDisplayList tmpList;
-
-  nsDisplayItem* i;
-  while ((i = aList->RemoveBottom())) {
-    // itemToInsert indiciates the item that should be inserted into the
-    // temporary list. If null, no item should be inserted.
-    nsDisplayItem* itemToInsert = nsnull;
-    nsIFrame* frame = i->GetUnderlyingFrame();
-    if (frame) {
-      nsIContent* content = frame->GetContent();
-      if (content) {
-        PRBool atStart = (content == aRange->GetStartParent());
-        PRBool atEnd = (content == aRange->GetEndParent());
-        if ((atStart || atEnd) && frame->GetType() == nsGkAtoms::textFrame) {
-          PRInt32 frameStartOffset, frameEndOffset;
-          frame->GetOffsets(frameStartOffset, frameEndOffset);
-
-          PRInt32 hilightStart =
-            atStart ? PR_MAX(aRange->StartOffset(), frameStartOffset) : frameStartOffset;
-          PRInt32 hilightEnd =
-            atEnd ? PR_MIN(aRange->EndOffset(), frameEndOffset) : frameEndOffset;
-          if (hilightStart < hilightEnd) {
-            // determine the location of the start and end edges of the range.
-            nsPoint startPoint, endPoint;
-            nsPresContext* presContext = GetPresContext();
-            frame->GetPointFromOffset(presContext, aRenderingContext,
-                                      hilightStart, &startPoint);
-            frame->GetPointFromOffset(presContext, aRenderingContext,
-                                      hilightEnd, &endPoint);
-
-            // the clip rectangle is determined by taking the the start and
-            // end points of the range, offset from the reference frame.
-            // Because of rtl, the end point may be to the left of the
-            // start point, so x is set to the lowest value
-            nsRect textRect(aBuilder->ToReferenceFrame(frame), frame->GetSize());
-            nscoord x = PR_MIN(startPoint.x, endPoint.x);
-            textRect.x += x;
-            textRect.width = PR_MAX(startPoint.x, endPoint.x) - x;
-            surfaceRect.UnionRect(surfaceRect, textRect);
-
-            // wrap the item in an nsDisplayClip so that it can be clipped to
-            // the selection. If the allocation fails, fall through and delete
-            // the item below.
-            itemToInsert = new (aBuilder)nsDisplayClip(frame, i, textRect);
-          }
-        }
-        else {
-          // if the node is within the range, append it to the temporary list
-          PRBool before, after;
-          nsRange::CompareNodeToRange(content, aRange, &before, &after);
-          if (!before && !after) {
-            itemToInsert = i;
-            surfaceRect.UnionRect(surfaceRect, i->GetBounds(aBuilder));
-          }
-        }
-      }
-    }
-
-    // insert the item into the list if necessary. If the item has a child
-    // list, insert that as well
-    nsDisplayList* sublist = i->GetList();
-    if (itemToInsert || sublist) {
-      tmpList.AppendToTop(itemToInsert ? itemToInsert : i);
-      // if the item is a list, iterate over it as well
-      if (sublist)
-        surfaceRect.UnionRect(surfaceRect,
-          ClipListToRange(aBuilder, sublist, aRange, aRenderingContext));
-    }
-    else {
-      // otherwise, just delete the item and don't readd it to the list
-      i->~nsDisplayItem();
-    }
-  }
-
-  // now add all the items back onto the original list again
-  aList->AppendToTop(&tmpList);
-
-  return surfaceRect;
-}
-
-RangePaintInfo*
-PresShell::CreateRangePaintInfo(nsIDOMRange* aRange,
-                                nsIRenderingContext* aRenderingContext,
-                                nsRect& aSurfaceRect)
-{
-  RangePaintInfo* info = nsnull;
-
-  nsCOMPtr<nsIRange> range = do_QueryInterface(aRange);
-  if (!range)
-    return nsnull;
-
-  nsIFrame* ancestorFrame;
-  nsIFrame* rootFrame = GetRootFrame();
-
-  // If the start or end of the range is the document, just use the root
-  // frame, otherwise get the common ancestor of the two endpoints of the
-  // range.
-  nsINode* startParent = range->GetStartParent();
-  nsINode* endParent = range->GetEndParent();
-  nsIDocument* doc = startParent->GetCurrentDoc();
-  if (startParent == doc || endParent == doc) {
-    ancestorFrame = rootFrame;
-  }
-  else {
-    nsINode* ancestor = nsContentUtils::GetCommonAncestor(startParent, endParent);
-    NS_ASSERTION(!ancestor || ancestor->IsNodeOfType(nsINode::eCONTENT),
-                 "common ancestor is not content");
-    if (!ancestor || !ancestor->IsNodeOfType(nsINode::eCONTENT))
-      return nsnull;
-
-    nsIContent* ancestorContent = NS_STATIC_CAST(nsIContent*, ancestor);
-    ancestorFrame = GetPrimaryFrameFor(ancestorContent);
-
-    // use the nearest ancestor frame that includes all continuations as the
-    // root for building the display list
-    while (ancestorFrame &&
-           nsLayoutUtils::GetNextContinuationOrSpecialSibling(ancestorFrame))
-      ancestorFrame = ancestorFrame->GetParent();
-  }
-
-  if (!ancestorFrame)
-    return nsnull;
-
-  info = new RangePaintInfo(range, ancestorFrame);
-  if (!info)
-    return nsnull;
-
-  nsRect ancestorRect = ancestorFrame->GetOverflowRect();
-
-  // get a display list containing the range
-  info->mBuilder.SetPaintAllFrames();
-  info->mBuilder.EnterPresShell(ancestorFrame, ancestorRect);
-  ancestorFrame->BuildDisplayListForStackingContext(&info->mBuilder,
-                                                    ancestorRect, &info->mList);
-  info->mBuilder.LeavePresShell(ancestorFrame, ancestorRect);
-
-  nsRect rangeRect = ClipListToRange(&info->mBuilder, &info->mList,
-                                     range, aRenderingContext);
-
-  // determine the offset of the reference frame for the display list
-  // to the root frame. This will allow the coordinates used when painting
-  // to all be offset from the same point
-  info->mRootOffset = ancestorFrame->GetOffsetTo(rootFrame);
-  rangeRect.MoveBy(info->mRootOffset);
-  aSurfaceRect.UnionRect(aSurfaceRect, rangeRect);
-
-  return info;
-}
-
-already_AddRefed<gfxASurface>
-PresShell::PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
-                               nsISelection* aSelection,
-                               nsIRegion* aRegion,
-                               nsRect aArea,
-                               nsPoint& aPoint,
-                               nsRect* aScreenRect)
-{
-  nsPresContext* pc = GetPresContext();
-  if (!pc || aArea.width == 0 || aArea.height == 0)
-    return nsnull;
-
-  nsIDeviceContext* deviceContext = pc->DeviceContext();
-
-  // use the rectangle to create the surface
-  nsRect pixelArea = aArea;
-  pixelArea.ScaleRoundOut(1.0 / pc->AppUnitsPerDevPixel());
-
-  // if the area of the image is larger than the maximum area, scale it down
-  float scale = 0.0;
-  nsIntRect rootScreenRect = GetRootFrame()->GetScreenRect();
-
-  // if the image is larger in one or both directions than half the size of
-  // the available screen area, scale the image down to that size.
-  nsRect maxSize;
-  deviceContext->GetClientRect(maxSize);
-  nscoord maxWidth = pc->AppUnitsToDevPixels(maxSize.width >> 1);
-  nscoord maxHeight = pc->AppUnitsToDevPixels(maxSize.height >> 1);
-  PRBool resize = (pixelArea.width > maxWidth || pixelArea.height > maxHeight);
-  if (resize) {
-    scale = 1.0;
-    // divide the maximum size by the image size in both directions. Whichever
-    // direction produces the smallest result determines how much should be
-    // scaled.
-    if (pixelArea.width > maxWidth)
-      scale = PR_MIN(scale, float(maxWidth) / pixelArea.width);
-    if (pixelArea.height > maxHeight)
-      scale = PR_MIN(scale, float(maxHeight) / pixelArea.height);
-
-    pixelArea.width = NSToIntFloor(float(pixelArea.width) * scale);
-    pixelArea.height = NSToIntFloor(float(pixelArea.height) * scale);
-
-    // adjust the screen position based on the rescaled size
-    nscoord left = rootScreenRect.x + pixelArea.x;
-    nscoord top = rootScreenRect.y + pixelArea.y;
-    aScreenRect->x = NSToIntFloor(aPoint.x - float(aPoint.x - left) * scale);
-    aScreenRect->y = NSToIntFloor(aPoint.y - float(aPoint.y - top) * scale);
-  }
-  else {
-    // move aScreenRect to the position of the surface in screen coordinates
-    aScreenRect->MoveTo(rootScreenRect.x + pixelArea.x, rootScreenRect.y + pixelArea.y);
-  }
-  aScreenRect->width = pixelArea.width;
-  aScreenRect->height = pixelArea.height;
-
-  gfxImageSurface* surface =
-    new gfxImageSurface(gfxIntSize(pixelArea.width, pixelArea.height),
-                        gfxImageSurface::ImageFormatARGB32);
-  if (!surface || surface->CairoStatus()) {
-    delete surface;
-    return nsnull;
-  }
-
-  // clear the image
-  gfxContext context(surface);
-  context.SetOperator(gfxContext::OPERATOR_CLEAR);
-  context.Rectangle(gfxRect(0, 0, pixelArea.width, pixelArea.height));
-  context.Fill();
-
-  nsCOMPtr<nsIRenderingContext> rc;
-  deviceContext->CreateRenderingContextInstance(*getter_AddRefs(rc));
-  rc->Init(deviceContext, surface);
-
-  if (aRegion)
-    rc->SetClipRegion(*aRegion, nsClipCombine_kReplace);
-
-  if (resize)
-    rc->Scale(scale, scale);
-
-  // translate so that points are relative to the surface area
-  rc->Translate(-aArea.x, -aArea.y);
-
-  // temporarily hide the selection so that text is drawn normally. If a
-  // selection is being rendered, use that, otherwise use the presshell's
-  // selection.
-  nsCOMPtr<nsFrameSelection> frameSelection;
-  if (aSelection) {
-    nsCOMPtr<nsISelectionPrivate> selpriv = do_QueryInterface(aSelection);
-    selpriv->GetFrameSelection(getter_AddRefs(frameSelection));
-  }
-  else {
-    frameSelection = FrameSelection();
-  }
-  PRInt16 oldDisplaySelection = frameSelection->GetDisplaySelection();
-  frameSelection->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
-
-  // next, paint each range in the selection
-  PRInt32 count = aItems->Length();
-  for (PRInt32 i = 0; i < count; i++) {
-    RangePaintInfo* rangeInfo = (*aItems)[i];
-    // the display lists paint relative to the offset from the reference
-    // frame, so translate the rendering context
-    nsIRenderingContext::AutoPushTranslation
-      translate(rc, rangeInfo->mRootOffset.x, rangeInfo->mRootOffset.y);
-
-    aArea.MoveBy(-rangeInfo->mRootOffset.x, -rangeInfo->mRootOffset.y);
-    rangeInfo->mList.Paint(&rangeInfo->mBuilder, rc, aArea);
-    aArea.MoveBy(rangeInfo->mRootOffset.x, rangeInfo->mRootOffset.y);
-  }
-
-  // restore the old selection display state
-  frameSelection->SetDisplaySelection(oldDisplaySelection);
-
-  NS_ADDREF(surface);
-  return surface;
-}
-
-already_AddRefed<gfxASurface>
-PresShell::RenderNode(nsIDOMNode* aNode,
-                      nsIRegion* aRegion,
-                      nsPoint& aPoint,
-                      nsRect* aScreenRect)
-{
-  // create a temporary rendering context for text measuring
-  nsCOMPtr<nsIRenderingContext> tmprc;
-  nsresult rv = CreateRenderingContext(GetRootFrame(), getter_AddRefs(tmprc));
-  NS_ENSURE_SUCCESS(rv, nsnull);
-
-  // area will hold the size of the surface needed to draw the node, measured
-  // from the root frame.
-  nsRect area;
-  nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
-
-  nsCOMPtr<nsIDOMRange> range;
-  NS_NewRange(getter_AddRefs(range));
-  range->SelectNode(aNode);
-
-  RangePaintInfo* info = CreateRangePaintInfo(range, tmprc, area);
-  if (info && !rangeItems.AppendElement(info)) {
-    delete info;
-    return nsnull;
-  }
-
-  if (aRegion) {
-    // combine the area with the supplied region
-    nsRect rrectPixels;
-    aRegion->GetBoundingBox(&rrectPixels.x, &rrectPixels.y,
-                            &rrectPixels.width, &rrectPixels.height);
-
-    nsRect rrect = rrectPixels;
-    rrect.ScaleRoundOut(nsPresContext::AppUnitsPerCSSPixel());
-    area.IntersectRect(area, rrect);
-    
-    nsPresContext* pc = GetPresContext();
-    if (!pc)
-      return nsnull;
-
-    // move the region so that it is offset from the topleft corner of the surface
-    aRegion->Offset(-rrectPixels.x + (rrectPixels.x - pc->AppUnitsToDevPixels(area.x)),
-                    -rrectPixels.y + (rrectPixels.y - pc->AppUnitsToDevPixels(area.y)));
-  }
-
-  return PaintRangePaintInfo(&rangeItems, nsnull, aRegion, area, aPoint,
-                             aScreenRect);
-}
-
-already_AddRefed<gfxASurface>
-PresShell::RenderSelection(nsISelection* aSelection,
-                           nsPoint& aPoint,
-                           nsRect* aScreenRect)
-{
-  // create a temporary rendering context for text measuring
-  nsCOMPtr<nsIRenderingContext> tmprc;
-  nsresult rv = CreateRenderingContext(GetRootFrame(), getter_AddRefs(tmprc));
-  NS_ENSURE_SUCCESS(rv, nsnull);
-
-  // area will hold the size of the surface needed to draw the selection,
-  // measured from the root frame.
-  nsRect area;
-  nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
-
-  // iterate over each range and collect them into the rangeItems array.
-  // This is done so that the size of selection can be determined so as
-  // to allocate a surface area
-  PRInt32 numRanges;
-  aSelection->GetRangeCount(&numRanges);
-  NS_ASSERTION(numRanges > 0, "RenderSelection called with no selection");
-
-  for (PRInt32 r = 0; r < numRanges; r++)
-  {
-    nsCOMPtr<nsIDOMRange> range;
-    aSelection->GetRangeAt(r, getter_AddRefs(range));
-
-    RangePaintInfo* info = CreateRangePaintInfo(range, tmprc, area);
-    if (info && !rangeItems.AppendElement(info)) {
-      delete info;
-      return nsnull;
-    }
-  }
-
-  return PaintRangePaintInfo(&rangeItems, aSelection, nsnull, area, aPoint,
-                             aScreenRect);
-}
-
 NS_IMETHODIMP
 PresShell::Paint(nsIView*             aView,
                  nsIRenderingContext* aRenderingContext,
                  const nsRegion&      aDirtyRegion)
 {
   AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Paint);
   nsIFrame* frame;
   nsresult  rv = NS_OK;
@@ -5390,17 +4923,17 @@
     }
   }
 
   if (dispatchUsingCoordinates) {
     NS_ASSERTION(frame, "Nothing to handle this event!");
     if (!frame)
       return NS_OK;
 
-    nsPresContext* framePresContext = frame->PresContext();
+    nsPresContext* framePresContext = frame->GetPresContext();
     nsPresContext* rootPresContext = framePresContext->RootPresContext();
     NS_ASSERTION(rootPresContext = mPresContext->RootPresContext(),
                  "How did we end up outside the connected prescontext/viewmanager hierarchy?"); 
     // If we aren't starting our event dispatch from the root frame of the root prescontext,
     // then someone must be capturing the mouse. In that case we don't want to search the popup
     // list.
     if (framePresContext == rootPresContext &&
         frame == FrameManager()->GetRootFrame()) {
@@ -5418,17 +4951,17 @@
       }
     }
 
     nsPoint eventPoint
         = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, frame);
     nsIFrame* targetFrame = nsLayoutUtils::GetFrameForPoint(frame, eventPoint);
     if (targetFrame) {
       PresShell* shell =
-          NS_STATIC_CAST(PresShell*, targetFrame->PresContext()->PresShell());
+          NS_STATIC_CAST(PresShell*, targetFrame->GetPresContext()->PresShell());
       if (shell != this) {
         // Handle the event in the correct shell.
         // Prevent deletion until we're done with event handling (bug 336582).
         nsRefPtr<nsIPresShell> kungFuDeathGrip(shell);
         nsIView* subshellRootView;
         shell->GetViewManager()->GetRootView(subshellRootView);
         // We pass the subshell's root view as the view to start from. This is
         // the only correct alternative; if the event was captured then it
@@ -6091,17 +5624,17 @@
                "reflow roots must not have visible overflow");
   NS_ASSERTION(status == NS_FRAME_COMPLETE,
                "reflow roots should never split");
 
   target->SetSize(nsSize(desiredSize.width, desiredSize.height));
 
   nsContainerFrame::SyncFrameViewAfterReflow(mPresContext, target,
                                              target->GetView(),
-                                             &desiredSize.mOverflowArea);
+                                             nsnull);
 
   target->DidReflow(mPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
   if (target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) {
     mPresContext->SetVisibleArea(nsRect(0, 0, desiredSize.width,
                                         desiredSize.height));
   }
 }
 
Index: mozilla/content/base/src/nsRange.cpp
===================================================================
--- mozilla.orig/content/base/src/nsRange.cpp
+++ mozilla/content/base/src/nsRange.cpp
@@ -86,28 +86,16 @@
 // If neither are true, the node is contained inside of the range.
 // XXX - callers responsibility to ensure node in same doc as range! 
 
 // static
 nsresult
 nsRange::CompareNodeToRange(nsIContent* aNode, nsIDOMRange* aRange,
                             PRBool *outNodeBefore, PRBool *outNodeAfter)
 {
-  nsresult rv;
-  nsCOMPtr<nsIRange> range = do_QueryInterface(aRange, &rv);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  return CompareNodeToRange(aNode, range, outNodeBefore, outNodeAfter);
-}
-
-// static
-nsresult
-nsRange::CompareNodeToRange(nsIContent* aNode, nsIRange* aRange,
-                            PRBool *outNodeBefore, PRBool *outNodeAfter)
-{
   // create a pair of dom points that expresses location of node:
   //     NODE(start), NODE(end)
   // Let incoming range be:
   //    {RANGE(start), RANGE(end)}
   // if (RANGE(start) <= NODE(start))  and (RANGE(end) => NODE(end))
   // then the Node is contained (completely) by the Range.
   
   nsresult rv;
Index: mozilla/content/base/src/nsRange.h
===================================================================
--- mozilla.orig/content/base/src/nsRange.h
+++ mozilla/content/base/src/nsRange.h
@@ -122,19 +122,16 @@
  *  ends after a range.  If neither it is contained inside the range.
  *  
  *  XXX - callers responsibility to ensure node in same doc as range!
  *
  *****************************************************************************/
   static nsresult CompareNodeToRange(nsIContent* aNode, nsIDOMRange* aRange,
                                      PRBool *outNodeBefore,
                                      PRBool *outNodeAfter);
-  static nsresult CompareNodeToRange(nsIContent* aNode, nsIRange* aRange,
-                                     PRBool *outNodeBefore,
-                                     PRBool *outNodeAfter);
 
 protected:
   void DoSetRange(nsINode* aStartN, PRInt32 aStartOffset,
                   nsINode* aEndN, PRInt32 aEndOffset,
                   nsINode* aRoot);
 };
 
 // Make a new nsIDOMRange object
Index: mozilla/widget/src/gtk2/nsImageToPixbuf.cpp
===================================================================
--- mozilla.orig/widget/src/gtk2/nsImageToPixbuf.cpp
+++ mozilla/widget/src/gtk2/nsImageToPixbuf.cpp
@@ -72,17 +72,17 @@
 {
 #ifdef MOZ_CAIRO_GFX
     PRInt32 width = aImage->GetWidth(),
             height = aImage->GetHeight();
 
     nsRefPtr<gfxASurface> surface;
     aImage->GetSurface(getter_AddRefs(surface));
 
-    if (aSurface->CairoStatus()) {
+    if (surface->CairoStatus()) {
         NS_ERROR("invalid surface");
         return nsnull;
     }
 
     nsRefPtr<gfxImageSurface> imgSurface;
     if (surface->GetType() == gfxASurface::SurfaceTypeImage) {
         imgSurface = NS_STATIC_CAST(gfxImageSurface*,
                                     NS_STATIC_CAST(gfxASurface*, surface.get()));
--- mozilla/widget/src/xpwidgets/nsBaseDragService.cpp.orig	2007-05-30 08:17:42.000000000 +0300
+++ mozilla/widget/src/xpwidgets/nsBaseDragService.cpp	2007-05-30 08:35:36.000000000 +0300
@@ -47,20 +47,21 @@
 #include "nsXPCOM.h"
 #include "nsISupportsPrimitives.h"
 #include "nsCOMPtr.h"
 #include "nsIFrame.h"
 #include "nsIDocument.h"
 #include "nsIContent.h"
 #include "nsIPresShell.h"
 #include "nsIViewManager.h"
 #include "nsIDOMNode.h"
 #include "nsPresContext.h"
+#include "nsGUIEvent.h"
 #include "nsIPrefService.h"
 
 
 #define DRAGIMAGES_PREF "nglayout.enable_drag_images"
 
 NS_IMPL_ADDREF(nsBaseDragService)
 NS_IMPL_RELEASE(nsBaseDragService)
 NS_IMPL_QUERY_INTERFACE2(nsBaseDragService, nsIDragService, nsIDragSession)
 
 
@@ -259,20 +260,41 @@ nsBaseDragService::StartDragSession()
   return NS_OK;
 }
 
 //-------------------------------------------------------------------------
 NS_IMETHODIMP
 nsBaseDragService::EndDragSession(PRBool aDoneDrag)
 {
   if (!mDoingDrag) {
     return NS_ERROR_FAILURE;
   }
-
+  
+  if (aDoneDrag)
+    FireDragEventAtSource(NS_DRAGDROP_END); 
 
   mDoingDrag = PR_FALSE;
 
   // release the source we've been holding on to.
   mSourceDocument = nsnull;
   mSourceNode = nsnull;
 
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsBaseDragService::FireDragEventAtSource(PRUint32 aMsg)
+{
+  if (mSourceNode) {
+    nsCOMPtr<nsIDocument> doc = do_QueryInterface(mSourceDocument);
+    if (doc) {
+      nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
+      if (presShell) {
+        nsEventStatus status = nsEventStatus_eIgnore;
+        nsMouseEvent event(PR_TRUE, aMsg, nsnull, nsMouseEvent::eReal);
+
+        nsCOMPtr<nsIContent> content = do_QueryInterface(mSourceNode);
+        return presShell->HandleDOMEventWithTarget(content, &event, &status);
+      }
+    }
+  }
+  return NS_OK;
+}
