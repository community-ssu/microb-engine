# Get rid of PresShellViewEventListener 
Index: layout/base/nsPresShell.cpp
===================================================================
--- layout/base/nsPresShell.cpp.orig
+++ layout/base/nsPresShell.cpp
@@ -748,16 +748,66 @@
     fprintf(stderr,
             "WARNING: FrameArena::FreeFrame leaking chunk of %d bytes.\n",
             aSize);
   }
 #endif
 #endif
 }
 
+class PresShellViewEventListener : public nsIScrollPositionListener,
+                                   public nsICompositeListener
+{
+public:
+  PresShellViewEventListener();
+  virtual ~PresShellViewEventListener();
+
+  NS_DECL_ISUPPORTS
+
+  // nsIScrollPositionListener methods
+  NS_IMETHOD ScrollPositionWillChange(nsIScrollableView *aView, nscoord aX, nscoord aY);
+  NS_IMETHOD ScrollPositionDidChange(nsIScrollableView *aView, nscoord aX, nscoord aY);
+
+  // nsICompositeListener methods
+  NS_IMETHOD WillRefreshRegion(nsIViewManager *aViewManager,
+                               nsIView *aView,
+                               nsIRenderingContext *aContext,
+                               nsIRegion *aRegion,
+                               PRUint32 aUpdateFlags);
+
+  NS_IMETHOD DidRefreshRegion(nsIViewManager *aViewManager,
+                              nsIView *aView,
+                              nsIRenderingContext *aContext,
+                              nsIRegion *aRegion,
+                              PRUint32 aUpdateFlags);
+
+  NS_IMETHOD WillRefreshRect(nsIViewManager *aViewManager,
+                             nsIView *aView,
+                             nsIRenderingContext *aContext,
+                             const nsRect *aRect,
+                             PRUint32 aUpdateFlags);
+
+  NS_IMETHOD DidRefreshRect(nsIViewManager *aViewManager,
+                            nsIView *aView,
+                            nsIRenderingContext *aContext,
+                            const nsRect *aRect,
+                            PRUint32 aUpdateFlags);
+
+  nsresult SetPresShell(nsIPresShell *aPresShell);
+
+private:
+
+  nsresult HideCaret();
+  nsresult RestoreCaretVisibility();
+
+  nsIPresShell *mPresShell;
+  PRBool        mWasVisible;
+  PRInt32       mCallCount;
+};
+
 struct nsCallbackEventRequest
 {
   nsIReflowCallback* callback;
   nsCallbackEventRequest* next;
 };
 
 // ----------------------------------------------------------------------------
 class nsPresShellEventCB;
@@ -1129,16 +1179,17 @@
   
   nsIFrame*   mCurrentEventFrame;
   nsCOMPtr<nsIContent> mCurrentEventContent;
   nsVoidArray mCurrentEventFrameStack;
   nsCOMArray<nsIContent> mCurrentEventContentStack;
 
   nsCOMPtr<nsICaret>            mCaret;
   PRInt16                       mSelectionFlags;
+  PresShellViewEventListener    *mViewEventListener;
   FrameArena                    mFrameArena;
   StackArena                    mStackArena;
   nsCOMPtr<nsIDragService>      mDragService;
   
   nsRevocableEventPtr<ReflowEvent> mReflowEvent;
 
   nsCallbackEventRequest* mFirstCallbackEventRequest;
   nsCallbackEventRequest* mLastCallbackEventRequest;
@@ -1678,16 +1729,21 @@
     // to us. To avoid the pres context having a dangling reference, set its 
     // pres shell to NULL
     mPresContext->SetShell(nsnull);
 
     // Clear the link handler (weak reference) as well
     mPresContext->SetLinkHandler(nsnull);
   }
 
+  if (mViewEventListener) {
+    mViewEventListener->SetPresShell((nsIPresShell*)nsnull);
+    NS_RELEASE(mViewEventListener);
+  }
+
   KillResizeEventTimer();
 
   mHaveShutDown = PR_TRUE;
 
   return NS_OK;
 }
 
                   // Dynamic stack memory allocation
@@ -2423,16 +2479,33 @@
   // Restore our root scroll position now if we're getting here after EndLoad
   // got called, since this is our one chance to do it.  Note that we need not
   // have reflowed for this to work; when the scrollframe is finally reflowed
   // it'll puick up the position we store in it here.
   if (!mDocumentLoading) {
     RestoreRootScrollPosition();
   }
 
+  if (mViewManager && mCaret && !mViewEventListener) {
+    nsIScrollableView* scrollingView = nsnull;
+    mViewManager->GetRootScrollableView(&scrollingView);
+
+    if (scrollingView) {
+      mViewEventListener = new PresShellViewEventListener;
+
+      if (!mViewEventListener)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+      NS_ADDREF(mViewEventListener);
+      mViewEventListener->SetPresShell(this);
+      scrollingView->AddScrollPositionListener((nsIScrollPositionListener *)mViewEventListener);
+      mViewManager->AddCompositeListener((nsICompositeListener *)mViewEventListener);
+    }
+  }
+
   // For printing, we just immediately unsuppress.
   if (!mPresContext->IsPaginated()) {
     // Kick off a one-shot timer based off our pref value.  When this timer
     // fires, if painting is still locked down, then we will go ahead and
     // trigger a full invalidate and allow painting to proceed normally.
     mPaintingSuppressed = PR_TRUE;
     mPaintSuppressionTimer = do_CreateInstance("@mozilla.org/timer;1");
     if (!mPaintSuppressionTimer)
@@ -6936,16 +7009,135 @@
 
 void
 PresShell::VerifyStyleTree()
 {
   VERIFY_STYLE_TREE;
 }
 #endif
 
+// PresShellViewEventListener
+
+NS_IMPL_ISUPPORTS2(PresShellViewEventListener, nsIScrollPositionListener, nsICompositeListener)
+
+PresShellViewEventListener::PresShellViewEventListener()
+{
+  mPresShell  = 0;
+  mWasVisible = PR_FALSE;
+  mCallCount  = 0;
+}
+
+PresShellViewEventListener::~PresShellViewEventListener()
+{
+  mPresShell  = 0;
+}
+
+nsresult
+PresShellViewEventListener::SetPresShell(nsIPresShell *aPresShell)
+{
+  mPresShell = aPresShell;
+  return NS_OK;
+}
+
+nsresult
+PresShellViewEventListener::HideCaret()
+{
+  nsresult result = NS_OK;
+
+  if (mPresShell && 0 == mCallCount)
+  {
+    nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(mPresShell);
+    if (selCon)
+    {
+      result = selCon->GetCaretEnabled(&mWasVisible);
+
+      if (NS_SUCCEEDED(result) && mWasVisible)
+        result = selCon->SetCaretEnabled(PR_FALSE);
+    }
+  }
+
+  ++mCallCount;
+
+  return result;
+}
+
+nsresult
+PresShellViewEventListener::RestoreCaretVisibility()
+{
+  nsresult result = NS_OK;
+
+  --mCallCount;
+
+  if (mPresShell && 0 == mCallCount && mWasVisible)
+  {
+    nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(mPresShell);
+    if (selCon)
+      result = selCon->SetCaretEnabled(PR_TRUE);
+  }
+
+  return result;
+}
+
+NS_IMETHODIMP
+PresShellViewEventListener::ScrollPositionWillChange(nsIScrollableView *aView, nscoord aX, nscoord aY)
+{
+  return HideCaret();
+}
+
+NS_IMETHODIMP
+PresShellViewEventListener::ScrollPositionDidChange(nsIScrollableView *aView, nscoord aX, nscoord aY)
+{
+  return RestoreCaretVisibility();
+}
+
+NS_IMETHODIMP
+PresShellViewEventListener::WillRefreshRegion(nsIViewManager *aViewManager,
+                                     nsIView *aView,
+                                     nsIRenderingContext *aContext,
+                                     nsIRegion *aRegion,
+                                     PRUint32 aUpdateFlags)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+PresShellViewEventListener::DidRefreshRegion(nsIViewManager *aViewManager,
+                                    nsIView *aView,
+                                    nsIRenderingContext *aContext,
+                                    nsIRegion *aRegion,
+                                    PRUint32 aUpdateFlags)
+{
+  nsCSSRendering::DidPaint();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+PresShellViewEventListener::WillRefreshRect(nsIViewManager *aViewManager,
+                                   nsIView *aView,
+                                   nsIRenderingContext *aContext,
+                                   const nsRect *aRect,
+                                   PRUint32 aUpdateFlags)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+PresShellViewEventListener::DidRefreshRect(nsIViewManager *aViewManager,
+                                  nsIView *aView,
+                                  nsIRenderingContext *aContext,
+                                  const nsRect *aRect,
+                                  PRUint32 aUpdateFlags)
+{
+  nsCSSRendering::DidPaint();
+
+  return NS_OK;
+}
+
+
 //=============================================================
 //=============================================================
 //-- Debug Reflow Counts
 //=============================================================
 //=============================================================
 #ifdef MOZ_REFLOW_PERF
 //-------------------------------------------------------------
 NS_IMETHODIMP
Index: layout/base/nsDisplayList.cpp
===================================================================
--- layout/base/nsDisplayList.cpp.orig
+++ layout/base/nsDisplayList.cpp
@@ -293,17 +293,16 @@
   }
 }
 
 void nsDisplayList::Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
                           const nsRect& aDirtyRect) const {
   for (nsDisplayItem* i = GetBottom(); i != nsnull; i = i->GetAbove()) {
     i->Paint(aBuilder, aCtx, aDirtyRect);
   }
-  nsCSSRendering::DidPaint();
 }
 
 PRUint32 nsDisplayList::Count() const {
   PRUint32 count = 0;
   for (nsDisplayItem* i = GetBottom(); i; i = i->GetAbove()) {
     ++count;
   }
   return count;
Index: view/public/nsIViewManager.h
===================================================================
--- view/public/nsIViewManager.h.orig
+++ view/public/nsIViewManager.h
@@ -385,16 +385,51 @@
    * get the view that is is considered to be the root scrollable
    * view for the document.
    * @param aScrollable out parameter for root scrollable view
    * @return error status
    */
   NS_IMETHOD GetRootScrollableView(nsIScrollableView **aScrollable) = 0;
 
   /**
+   * Dump the specified view into a new offscreen rendering context.
+   * @param aRect is the region to capture into the offscreen buffer, in the view's
+   * coordinate system
+   * @param aUntrusted set to PR_TRUE if the contents may be passed to malicious
+   * agents. E.g. we might choose not to paint the contents of sensitive widgets
+   * such as the file name in a file upload widget, and we might choose not
+   * to paint themes.
+   * @param aIgnoreViewportScrolling ignore clipping/scrolling/scrollbar painting
+   * due to scrolling in the viewport
+   * @param aBackgroundColor a background color to render onto
+   * @param aRenderedContext gets set to a rendering context whose offscreen
+   * buffer can be locked to get the data. The buffer's size will be aRect's size.
+   * In all cases the caller must clean it up by calling
+   * cx->DestroyDrawingSurface(cx->GetDrawingSurface()).
+   */
+  NS_IMETHOD RenderOffscreen(nsIView* aView, nsRect aRect, PRBool aUntrusted,
+                             PRBool aIgnoreViewportScrolling,
+                             nscolor aBackgroundColor,
+                             nsIRenderingContext** aRenderedContext) = 0;
+
+  /**
+   * Add a listener to the view manager's composite listener list.
+   * @param aListener - new listener
+   * @result error status
+   */
+  NS_IMETHOD AddCompositeListener(nsICompositeListener *aListener) = 0;
+
+  /**
+   * Remove a listener from the view manager's composite listener list.
+   * @param aListener - listener to remove
+   * @result error status
+   */
+  NS_IMETHOD RemoveCompositeListener(nsICompositeListener *aListener) = 0;
+
+  /**
    * Retrieve the widget at the root of the view manager. This is the
    * widget associated with the root view, if the root view exists and has
    * a widget.
    */
   NS_IMETHOD GetWidget(nsIWidget **aWidget) = 0;
 
   /**
    * Force update of view manager widget
@@ -454,16 +489,55 @@
                                nsRectVisibility *aRectVisibility)=0;
 
   /**
    * Dispatch a mouse move event based on the most recent mouse
    * position.  This is used when the contents of the page moved
    * (aFromScroll is false) or scrolled (aFromScroll is true).
    */
   NS_IMETHOD SynthesizeMouseMove(PRBool aFromScroll)=0;
+
+  /**
+   TEMPORARY. Expose BlendingBuffers to layout so layout can
+   paint with opacity. This will go away with cairo/thebes, or be moved
+   to layout, depending on what happens first.
+
+    This class represents an offscreen buffer which may have an alpha channel.
+    Currently, if an alpha channel is required, we implement it by rendering into
+    two buffers: one with a black background, one with a white background. We can
+    recover the alpha values by comparing corresponding final values for each pixel.
+  */
+  class BlendingBuffers {
+  public:
+    BlendingBuffers(nsIRenderingContext* aCleanupContext);
+    ~BlendingBuffers();
+
+    // used by the destructor to cleanup resources
+    nsCOMPtr<nsIRenderingContext> mCleanupContext;
+    // The primary rendering context. When an alpha channel is in use, this
+    // holds the black background.
+    nsCOMPtr<nsIRenderingContext> mBlackCX;
+    // Only used when an alpha channel is required; holds the white background.
+    nsCOMPtr<nsIRenderingContext> mWhiteCX;
+
+    PRBool mOwnBlackSurface;
+    // drawing surface for mBlackCX
+    nsIDrawingSurface*  mBlack;
+    // drawing surface for mWhiteCX
+    nsIDrawingSurface*  mWhite;
+
+    // The offset within the current widget at which this buffer will
+    // eventually be composited
+    nsPoint mOffset;
+  };
+
+  virtual BlendingBuffers* CreateBlendingBuffers(nsIRenderingContext *aRC, PRBool aBorrowContext,
+                                                 nsIDrawingSurface* aBorrowSurface, PRBool aNeedAlpha,
+                                                 const nsRect& aArea) = 0;
+  virtual nsIBlender* GetBlender() = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIViewManager, NS_IVIEWMANAGER_IID)
 
 // Paint timing mode flags
 
 // intermediate: do no special timing processing; repaint when the
 // toolkit issues an expose event (which will happen *before* PLEvent
Index: view/src/nsViewManager.cpp
===================================================================
--- view/src/nsViewManager.cpp.orig
+++ view/src/nsViewManager.cpp
@@ -222,16 +222,21 @@
     // Note: A global rendering context is needed because it is not possible 
     // to create a nsIRenderingContext during the shutdown of XPCOM. The last
     // viewmanager is typically destroyed during XPCOM shutdown.
     NS_IF_RELEASE(gCleanupContext);
   }
 
   mObserver = nsnull;
   mContext = nsnull;
+
+  if (nsnull != mCompositeListeners) {
+    mCompositeListeners->Clear();
+    NS_RELEASE(mCompositeListeners);
+  }
 }
 
 NS_IMPL_ISUPPORTS1(nsViewManager, nsIViewManager)
 
 nsresult
 nsViewManager::CreateRegion(nsIRegion* *result)
 {
   nsresult rv;
@@ -367,16 +372,44 @@
     } else {
       mDelayedResize.SizeTo(aWidth, aHeight);
     }
   }
 
   return NS_OK;
 }
 
+/* Check the prefs to see whether we should do double buffering or not... */
+static
+PRBool DoDoubleBuffering(void)
+{
+  static PRBool gotDoublebufferPrefs = PR_FALSE;
+  static PRBool doDoublebuffering    = PR_TRUE;  /* Double-buffering is ON by default */
+
+  if (!gotDoublebufferPrefs) {
+    nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
+    if (prefBranch) {
+      PRBool val;
+      if (NS_SUCCEEDED(prefBranch->GetBoolPref("viewmanager.do_doublebuffering", &val))) {
+        doDoublebuffering = val;
+      }
+    }
+
+#ifdef DEBUG
+    if (!doDoublebuffering) {
+      printf("nsViewManager: Note: Double-buffering disabled via prefs.\n");
+    }
+#endif /* DEBUG */
+
+    gotDoublebufferPrefs = PR_TRUE;
+  }
+
+  return doDoublebuffering;
+}
+
 static void ConvertNativeRegionToAppRegion(nsIRegion* aIn, nsRegion* aOut,
                                            nsIDeviceContext* context)
 {
   nsRegionRectSet* rects = nsnull;
   aIn->GetRects(&rects);
   if (!rects)
     return;
 
@@ -469,16 +502,29 @@
         SetPainting(PR_FALSE);
         return;
       }
     } else {
       // plain assignment grabs another reference.
       localcx = aContext;
     }
 
+  // notify the listeners.
+  if (nsnull != mCompositeListeners) {
+    PRUint32 listenerCount;
+    if (NS_SUCCEEDED(mCompositeListeners->Count(&listenerCount))) {
+      nsCOMPtr<nsICompositeListener> listener;
+      for (PRUint32 i = 0; i < listenerCount; i++) {
+        if (NS_SUCCEEDED(mCompositeListeners->QueryElementAt(i, NS_GET_IID(nsICompositeListener), getter_AddRefs(listener)))) {
+          listener->WillRefreshRegion(this, aView, aContext, aRegion, aUpdateFlags);
+        }
+      }
+    }
+  }
+
   // damageRect is the clipped damage area bounds, in twips-relative-to-view-origin
   nsRect damageRect = damageRegion.GetBounds();
   PRInt32 p2a = mContext->AppUnitsPerDevPixel();
 
   nsRefPtr<gfxContext> ctx =
     (gfxContext*) localcx->GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);
 
   ctx->Save();
@@ -496,16 +542,29 @@
   damageRegion.Sub(damageRegion, opaqueRegion);
 
   RenderViews(aView, *localcx, damageRegion);
 
   ctx->Restore();
 
   SetPainting(PR_FALSE);
 
+  // notify the listeners.
+  if (nsnull != mCompositeListeners) {
+    PRUint32 listenerCount;
+    if (NS_SUCCEEDED(mCompositeListeners->Count(&listenerCount))) {
+      nsCOMPtr<nsICompositeListener> listener;
+      for (PRUint32 i = 0; i < listenerCount; i++) {
+        if (NS_SUCCEEDED(mCompositeListeners->QueryElementAt(i, NS_GET_IID(nsICompositeListener), getter_AddRefs(listener)))) {
+          listener->DidRefreshRegion(this, aView, aContext, aRegion, aUpdateFlags);
+        }
+      }
+    }
+  }
+
   if (RootViewManager()->mRecursiveRefreshPending) {
     // Unset this flag first, since if aUpdateFlags includes NS_VMREFRESH_IMMEDIATE
     // we'll reenter this code from the UpdateAllViews call.
     RootViewManager()->mRecursiveRefreshPending = PR_FALSE;
     UpdateAllViews(aUpdateFlags);
   }
 
 #ifdef NS_VM_PERF_METRICS
@@ -606,16 +665,135 @@
     
     aRC.PushState();
     aRC.Translate(-offsetToRoot.x, -offsetToRoot.y);
     mObserver->Paint(displayRoot, &aRC, damageRegion);
     aRC.PopState();
   }
 }
 
+static nsresult NewOffscreenContext(nsIDeviceContext* deviceContext, nsIDrawingSurface* surface,
+                                    const nsRect& aRect, nsIRenderingContext* *aResult)
+{
+  nsresult             rv;
+  nsIRenderingContext *context = nsnull;
+
+  rv = deviceContext->CreateRenderingContext(surface, context);
+  if (NS_FAILED(rv))
+    return rv;
+
+  // always initialize clipping, linux won't draw images otherwise.
+  nsRect clip(0, 0, aRect.width, aRect.height);
+  context->SetClipRect(clip, nsClipCombine_kReplace);
+
+  context->Translate(-aRect.x, -aRect.y);
+
+  *aResult = context;
+  return NS_OK;
+}
+
+nsIViewManager::BlendingBuffers::BlendingBuffers(nsIRenderingContext* aCleanupContext) {
+  mCleanupContext = aCleanupContext;
+
+  mOwnBlackSurface = PR_FALSE;
+  mWhite = nsnull;
+  mBlack = nsnull;
+}
+
+nsIViewManager::BlendingBuffers::~BlendingBuffers() {
+  if (mWhite)
+    mCleanupContext->DestroyDrawingSurface(mWhite);
+
+  if (mBlack && mOwnBlackSurface)
+    mCleanupContext->DestroyDrawingSurface(mBlack);
+}
+
+/*
+@param aBorrowContext set to PR_TRUE if the BlendingBuffers' "black" context
+  should be just aRC; set to PR_FALSE if we should create a new offscreen context
+@param aBorrowSurface if aBorrowContext is PR_TRUE, then this is the offscreen surface
+  corresponding to aRC, or nsnull if aRC doesn't have one; if aBorrowContext is PR_FALSE,
+  this parameter is ignored
+@param aNeedAlpha set to PR_FALSE if the caller guarantees that every pixel of the
+  BlendingBuffers will be drawn with opacity 1.0, PR_TRUE otherwise
+@param aRect the screen rectangle covered by the new BlendingBuffers, in app units, and
+  relative to the origin of aRC
+*/
+nsIViewManager::BlendingBuffers*
+nsViewManager::CreateBlendingBuffers(nsIRenderingContext *aRC,
+                                     PRBool aBorrowContext,
+                                     nsIDrawingSurface* aBorrowSurface,
+                                     PRBool aNeedAlpha,
+                                     const nsRect& aRect)
+{
+  nsresult rv;
+
+  // create a blender, if none exists already.
+  if (!mBlender) {
+    mBlender = do_CreateInstance(kBlenderCID, &rv);
+    if (NS_FAILED(rv))
+      return nsnull;
+    rv = mBlender->Init(mContext);
+    if (NS_FAILED(rv)) {
+      mBlender = nsnull;
+      return nsnull;
+    }
+  }
+
+  BlendingBuffers* buffers = new BlendingBuffers(aRC);
+  if (!buffers)
+    return nsnull;
+
+  buffers->mOffset = nsPoint(aRect.x, aRect.y);
+
+  nsRect offscreenBounds(0, 0, aRect.width, aRect.height);
+  offscreenBounds.ScaleRoundOut(1.0f / mContext->AppUnitsPerDevPixel());
+
+  if (aBorrowContext) {
+    buffers->mBlackCX = aRC;
+    buffers->mBlack = aBorrowSurface;
+  } else {
+    rv = aRC->CreateDrawingSurface(offscreenBounds, NS_CREATEDRAWINGSURFACE_FOR_PIXEL_ACCESS, buffers->mBlack);
+    if (NS_FAILED(rv)) {
+      delete buffers;
+      return nsnull;
+    }
+    buffers->mOwnBlackSurface = PR_TRUE;
+
+    rv = NewOffscreenContext(mContext, buffers->mBlack, aRect, getter_AddRefs(buffers->mBlackCX));
+    if (NS_FAILED(rv)) {
+      delete buffers;
+      return nsnull;
+    }
+  }
+
+  if (aNeedAlpha) {
+    rv = aRC->CreateDrawingSurface(offscreenBounds, NS_CREATEDRAWINGSURFACE_FOR_PIXEL_ACCESS, buffers->mWhite);
+    if (NS_FAILED(rv)) {
+      delete buffers;
+      return nsnull;
+    }
+
+    rv = NewOffscreenContext(mContext, buffers->mWhite, aRect, getter_AddRefs(buffers->mWhiteCX));
+    if (NS_FAILED(rv)) {
+      delete buffers;
+      return nsnull;
+    }
+
+    // Note that we only need to fill mBlackCX with black when some pixels are going
+    // to be transparent.
+    buffers->mBlackCX->SetColor(NS_RGB(0, 0, 0));
+    buffers->mBlackCX->FillRect(aRect);
+    buffers->mWhiteCX->SetColor(NS_RGB(255, 255, 255));
+    buffers->mWhiteCX->FillRect(aRect);
+  }
+
+  return buffers;
+}
+
 void nsViewManager::ProcessPendingUpdates(nsView* aView, PRBool aDoInvalidate)
 {
   NS_ASSERTION(IsRootVM(), "Updates will be missed");
 
   // Protect against a null-view.
   if (!aView) {
     return;
   }
@@ -1778,16 +1956,50 @@
 
 NS_IMETHODIMP nsViewManager::GetDeviceContext(nsIDeviceContext *&aContext)
 {
   NS_IF_ADDREF(mContext);
   aContext = mContext;
   return NS_OK;
 }
 
+void nsViewManager::GetMaxWidgetBounds(nsRect& aMaxWidgetBounds) const
+{
+  // Go through the list of viewmanagers and get the maximum width and
+  // height of their widgets
+  aMaxWidgetBounds.width = 0;
+  aMaxWidgetBounds.height = 0;
+  PRInt32 index = 0;
+  for (index = 0; index < mVMCount; index++) {
+
+    nsViewManager* vm = (nsViewManager*)gViewManagers->ElementAt(index);
+    nsCOMPtr<nsIWidget> rootWidget;
+
+    if(NS_SUCCEEDED(vm->GetWidget(getter_AddRefs(rootWidget))) && rootWidget)
+      {
+        nsRect widgetBounds;
+        rootWidget->GetBounds(widgetBounds);
+        aMaxWidgetBounds.width = PR_MAX(aMaxWidgetBounds.width, widgetBounds.width);
+        aMaxWidgetBounds.height = PR_MAX(aMaxWidgetBounds.height, widgetBounds.height);
+      }
+  }
+
+  //   printf("WIDGET BOUNDS %d %d\n", aMaxWidgetBounds.width, aMaxWidgetBounds.height);
+}
+
+PRInt32 nsViewManager::GetViewManagerCount()
+{
+  return mVMCount;
+}
+
+const nsVoidArray* nsViewManager::GetViewManagerArray()
+{
+  return gViewManagers;
+}
+
 already_AddRefed<nsIRenderingContext>
 nsViewManager::CreateRenderingContext(nsView &aView)
 {
   nsView              *par = &aView;
   nsIWidget*          win;
   nsIRenderingContext *cx = nsnull;
   nscoord             ax = 0, ay = 0;
 
@@ -1918,16 +2130,64 @@
 }
 
 NS_IMETHODIMP nsViewManager::GetRootScrollableView(nsIScrollableView **aScrollable)
 {
   *aScrollable = mRootScrollable;
   return NS_OK;
 }
 
+NS_IMETHODIMP nsViewManager::RenderOffscreen(nsIView* aView, nsRect aRect,
+                                             PRBool aUntrusted,
+                                             PRBool aIgnoreViewportScrolling,
+                                             nscolor aBackgroundColor,
+                                             nsIRenderingContext** aRenderedContext)
+{
+  // This is just a wrapper now. We keep it for compatibility until nsIViewManager
+  // goes away.
+  *aRenderedContext = nsnull;
+  if (!mObserver || !IsRefreshEnabled())
+    return NS_ERROR_FAILURE;
+
+  nsIScrollableView* scrollableView = nsnull;
+  GetRootScrollableView(&scrollableView);
+  nsIView* view;
+  if (scrollableView) {
+    scrollableView->GetScrolledView(view);
+  } else {
+    GetRootView(view);
+  }
+
+  NS_ASSERTION(view == aView,
+               "Only support offscreen rendering of the root (scrolled) view");
+  if (view != aView)
+    return NS_ERROR_FAILURE;
+
+  return mObserver->RenderOffscreen(aRect, aUntrusted, aIgnoreViewportScrolling,
+                                    aBackgroundColor, aRenderedContext);
+}
+
+NS_IMETHODIMP nsViewManager::AddCompositeListener(nsICompositeListener* aListener)
+{
+  if (nsnull == mCompositeListeners) {
+    nsresult rv = NS_NewISupportsArray(&mCompositeListeners);
+    if (NS_FAILED(rv))
+      return rv;
+  }
+  return mCompositeListeners->AppendElement(aListener);
+}
+
+NS_IMETHODIMP nsViewManager::RemoveCompositeListener(nsICompositeListener* aListener)
+{
+  if (nsnull != mCompositeListeners) {
+    return mCompositeListeners->RemoveElement(aListener);
+  }
+  return NS_ERROR_FAILURE;
+}
+
 NS_IMETHODIMP nsViewManager::GetWidget(nsIWidget **aWidget)
 {
   *aWidget = GetWidget();
   NS_IF_ADDREF(*aWidget);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsViewManager::ForceUpdate()
@@ -1959,16 +2219,34 @@
     aView = aView->GetParent();
   }
   NS_ASSERTION(rootView ==
                origView->GetViewManager()->RootViewManager()->GetRootView(),
                "Unexpected root view");
   return origin;
 }
 
+PRBool nsViewManager::DoesViewHaveNativeWidget(nsView* aView)
+{
+  if (aView->HasWidget())
+    return (nsnull != aView->GetWidget()->GetNativeData(NS_NATIVE_WIDGET));
+  return PR_FALSE;
+}
+
+/* static */
+nsView* nsViewManager::GetWidgetView(nsView *aView)
+{
+  while (aView) {
+    if (aView->HasWidget())
+      return aView;
+    aView = aView->GetParent();
+  }
+  return nsnull;
+}
+
 void nsViewManager::ViewToWidget(nsView *aView, nsView* aWidgetView, nsRect &aRect) const
 {
   while (aView != aWidgetView) {
     aView->ConvertToParentCoords(&aRect.x, &aRect.y);
     aView = aView->GetParent();
   }
   
   // intersect aRect with bounds of aWidgetView, to prevent generating any illegal rectangles.
Index: view/src/nsViewManager.h
===================================================================
--- view/src/nsViewManager.h.orig
+++ view/src/nsViewManager.h
@@ -217,25 +217,35 @@
   NS_IMETHOD  EnableRefresh(PRUint32 aUpdateFlags);
 
   NS_IMETHOD  BeginUpdateViewBatch(void);
   NS_IMETHOD  EndUpdateViewBatch(PRUint32 aUpdateFlags);
 
   NS_IMETHOD  SetRootScrollableView(nsIScrollableView *aScrollable);
   NS_IMETHOD  GetRootScrollableView(nsIScrollableView **aScrollable);
 
+  NS_IMETHOD RenderOffscreen(nsIView* aView, nsRect aRect, PRBool aUntrusted,
+                             PRBool aIgnoreViewportScrolling,
+                             nscolor aBackgroundColor,
+                             nsIRenderingContext** aRenderedContext);
+
+  NS_IMETHOD AddCompositeListener(nsICompositeListener *aListener);
+  NS_IMETHOD RemoveCompositeListener(nsICompositeListener *aListener);
+
   NS_IMETHOD GetWidget(nsIWidget **aWidget);
   nsIWidget* GetWidget() { return mRootView ? mRootView->GetWidget() : nsnull; }
   NS_IMETHOD ForceUpdate();
  
   NS_IMETHOD IsPainting(PRBool& aIsPainting);
   NS_IMETHOD SetDefaultBackgroundColor(nscolor aColor);
   NS_IMETHOD GetDefaultBackgroundColor(nscolor* aColor);
   NS_IMETHOD GetLastUserEventTime(PRUint32& aTime);
   void ProcessInvalidateEvent();
+  static PRInt32 GetViewManagerCount();
+  static const nsVoidArray* GetViewManagerArray();
   static PRUint32 gLastUserEventTime;
 
   /**
    * Determine if a rectangle specified in the view's coordinate system 
    * is completely, or partially visible.
    * @param aView view that aRect coordinates are specified relative to
    * @param aRect rectangle in twips to test for visibility 
    * @param aMinTwips is the min. pixel rows or cols at edge of screen 
@@ -275,30 +285,44 @@
   void DefaultRefresh(nsView* aView, nsIRenderingContext *aContext, const nsRect* aRect);
   void RenderViews(nsView *aRootView, nsIRenderingContext& aRC,
                    const nsRegion& aRegion);
 
   void InvalidateRectDifference(nsView *aView, const nsRect& aRect, const nsRect& aCutOut, PRUint32 aUpdateFlags);
   void InvalidateHorizontalBandDifference(nsView *aView, const nsRect& aRect, const nsRect& aCutOut,
                                           PRUint32 aUpdateFlags, nscoord aY1, nscoord aY2, PRBool aInCutOut);
 
+  virtual BlendingBuffers* CreateBlendingBuffers(nsIRenderingContext *aRC, PRBool aBorrowContext,
+                                                 nsIDrawingSurface* aBorrowSurface, PRBool aNeedAlpha,
+                                                 const nsRect& aArea);
+  virtual nsIBlender* GetBlender() { return mBlender; }
+
   void AddCoveringWidgetsToOpaqueRegion(nsRegion &aRgn, nsIDeviceContext* aContext,
                                         nsView* aRootView);
 
+  // Predicates
+  PRBool DoesViewHaveNativeWidget(nsView* aView);
+
   // Utilities
 
   PRBool IsViewInserted(nsView *aView);
 
   /**
    * Function to recursively call Update() on all widgets belonging to
    * a view or its kids.
    */
   void UpdateWidgetsForView(nsView* aView);
 
   /**
+   * Returns the nearest parent view with an attached widget. Can be the
+   * same view as passed-in.
+   */
+  static nsView* GetWidgetView(nsView *aView);
+
+  /**
    * Transforms a rectangle from specified view's coordinate system to
    * the first parent that has an attached widget.
    */
   void ViewToWidget(nsView *aView, nsView* aWidgetView, nsRect &aRect) const;
 
   /**
    * Transforms a rectangle from specified view's coordinate system to
    * an absolute coordinate rectangle which can be compared against the
@@ -314,16 +338,27 @@
   /**
    * Determine the visible rect 
    * @param aVisibleRect visible rectangle in twips
    * @returns NS_OK if successful, otherwise NS_ERROR_FAILURE.
    */
 
   nsresult GetVisibleRect(nsRect& aVisibleRect);
 
+  // Utilities used to size the offscreen drawing surface
+
+  /**
+   * Determine the maximum and width and height of all of the
+   * view manager's widgets.
+   *
+   * @param aMaxWidgetBounds the maximum width and height of all view managers
+   * widgets on exit.
+   */
+  void GetMaxWidgetBounds(nsRect& aMaxWidgetBounds) const;
+
   void DoSetWindowDimensions(nscoord aWidth, nscoord aHeight)
   {
     nsRect oldDim;
     nsRect newDim(0, 0, aWidth, aHeight);
     mRootView->GetDimensions(oldDim);
     if (oldDim != newDim) {
       // Don't resize the widget. It is already being set elsewhere.
       mRootView->SetDimensions(newDim, PR_TRUE, PR_FALSE);
@@ -438,16 +473,17 @@
   nsIScrollableView *mRootScrollable;
   nscolor           mDefaultBackgroundColor;
   nsPoint           mMouseLocation; // device units, relative to mRootView
 
   // The size for a resize that we delayed until the root view becomes
   // visible again.
   nsSize            mDelayedResize;
 
+  nsCOMPtr<nsIBlender> mBlender;
   nsISupportsArray  *mCompositeListeners;
   nsCOMPtr<nsIFactory> mRegionFactory;
   nsView            *mRootView;
   // mRootViewManager is a strong ref unless it equals |this|.  It's
   // never null (if we have no ancestors, it will be |this|).
   nsViewManager     *mRootViewManager;
 
   nsRevocableEventPtr<nsViewManagerEvent> mSynthMouseMoveEvent;
