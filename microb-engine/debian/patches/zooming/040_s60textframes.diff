Index: mozilla/layout/generic/nsTextFrameThebes.cpp
===================================================================
--- mozilla.orig/layout/generic/nsTextFrameThebes.cpp
+++ mozilla/layout/generic/nsTextFrameThebes.cpp
@@ -5929,29 +5929,36 @@
     gfxSkipCharsIterator iter(provider.GetStart());
     iter.SetOriginalOffset(offset + limitLength);
     transformedLength = iter.GetSkippedOffset() - transformedOffset;
   }
   PRUint32 transformedLastBreak = 0;
   PRBool usedHyphenation;
   gfxFloat trimmedWidth = 0;
   gfxFloat availWidth = aReflowState.availableWidth;
+  PRBool wrapTextToWidth = aPresContext->FitTextToWidth() &&
+                           availWidth / aPresContext->AppUnitsPerDevPixel() > aPresContext->ScreenWidth();
+  if (wrapTextToWidth)
+    availWidth = aPresContext->ScreenWidth() * aPresContext->AppUnitsPerDevPixel();
   PRBool canTrimTrailingWhitespace = !textStyle->WhiteSpaceIsSignificant();
   PRInt32 unusedOffset;  
   gfxBreakPriority breakPriority;
   lineLayout.GetLastOptionalBreakPosition(&unusedOffset, &breakPriority);
+  if (wrapTextToWidth)
+    breakPriority = eWordWrapBreak;
   PRUint32 transformedCharsFit =
     mTextRun->BreakAndMeasureText(transformedOffset, transformedLength,
                                   (GetStateBits() & TEXT_START_OF_LINE) != 0,
                                   availWidth,
                                   &provider, !lineLayout.LineIsBreakable(),
                                   canTrimTrailingWhitespace ? &trimmedWidth : nsnull,
                                   &textMetrics, needTightBoundingBox, ctx,
                                   &usedHyphenation, &transformedLastBreak,
-                                  textStyle->WordCanWrap(), &breakPriority);
+                                  wrapTextToWidth?wrapTextToWidth:textStyle->WordCanWrap(),
+                                  &breakPriority);
   // The "end" iterator points to the first character after the string mapped
   // by this frame. Basically, its original-string offset is offset+charsFit
   // after we've computed charsFit.
   gfxSkipCharsIterator end(provider.GetEndHint());
   end.SetSkippedOffset(transformedOffset + transformedCharsFit);
   PRInt32 charsFit = end.GetOriginalOffset() - offset;
   if (offset + charsFit == newLineOffset) {
     // We broke before a trailing preformatted '\n'. The newline should
@@ -6128,17 +6135,18 @@
   }
   if (completedFirstLetter) {
     lineLayout.SetFirstLetterStyleOK(PR_FALSE);
     aStatus |= NS_INLINE_BREAK_FIRST_LETTER_COMPLETE;
   }
 
   // Compute space and letter counts for justification, if required
   if (!textStyle->WhiteSpaceIsSignificant() &&
-      lineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY) {
+      lineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY &&
+      !wrapTextToWidth) {
     AddStateBits(TEXT_JUSTIFICATION_ENABLED);    // This will include a space for trailing whitespace, if any is present.
     // This is corrected for in nsLineLayout::TrimWhiteSpaceIn.
     PRInt32 numJustifiableCharacters =
       provider.ComputeJustifiableCharacters(offset, charsFit);
 
     NS_ASSERTION(numJustifiableCharacters <= charsFit,
                  "Bad justifiable character count");
     lineLayout.SetTextJustificationWeights(numJustifiableCharacters,
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -768,16 +768,18 @@
   virtual PRBool HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const;
 
   // Is it OK to let the page specify colors and backgrounds?
   PRBool UseDocumentColors() const {
     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
   }
 
   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
+  PRBool           FitTextToWidth() const { return mFitTextToWidth; }
+  PRInt32          ScreenWidth() const { return mScreenWidth; }
   
   virtual NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetExternal();
   NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetInternal();
 #ifdef _IMPL_NS_LAYOUT
   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetInternal(); }
 #else
   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetExternal(); }
 #endif
@@ -851,16 +853,17 @@
   ImageLoaderTable      mBorderImageLoaders;
   nsWeakPtr             mContainer;
 
   float                 mTextZoom;      // Text zoom, defaults to 1.0
   float                 mFullZoom;      // Page zoom, defaults to 1.0
 
   PRInt32               mCurAppUnitsPerDevPixel;
   PRInt32               mAutoQualityMinFontSizePixelsPref;
+  PRInt32               mScreenWidth;
 
 #ifdef IBMBIDI
   nsBidiPresUtils*      mBidiUtils;
 #endif
 
   nsCOMPtr<nsITheme> mTheme;
   nsCOMPtr<nsILanguageAtomService> mLangService;
   nsCOMPtr<nsIPrintSettings> mPrintSettings;
@@ -939,16 +942,17 @@
   // Has GetUserFontSet() been called?
   unsigned              mGetUserFontSetCalled : 1;
   // Do we currently have an event posted to call FlushUserFontSet?
   unsigned              mPostedFlushUserFontSet : 1;
 
   // resize reflow is supressed when the only change has been to zoom
   // the document rather than to change the document's dimensions
   unsigned              mSupressResizeReflow : 1;
+  unsigned              mFitTextToWidth : 1;
 
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
 #endif
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -192,17 +192,18 @@
                           NS_FONT_STRETCH_NORMAL, 0, 0),
     mDefaultCursiveFont("cursive", NS_FONT_STYLE_NORMAL,
                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL,
                         NS_FONT_STRETCH_NORMAL, 0, 0),
     mDefaultFantasyFont("fantasy", NS_FONT_STYLE_NORMAL,
                         NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL,
                         NS_FONT_STRETCH_NORMAL, 0, 0),
     mCanPaginatedScroll(PR_FALSE),
-    mIsRootPaginatedDocument(PR_FALSE), mSupressResizeReflow(PR_FALSE)
+    mIsRootPaginatedDocument(PR_FALSE), mSupressResizeReflow(PR_FALSE),
+    mFitTextToWidth(PR_FALSE), mScreenWidth(660)
 {
   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
   // bother initializing members to 0.
 
   mDoScaledTwips = PR_TRUE;
 
   SetBackgroundImageDraw(PR_TRUE);		// always draw the background
   SetBackgroundColorDraw(PR_TRUE);
@@ -291,16 +292,22 @@
 #ifdef IBMBIDI
   nsContentUtils::UnregisterPrefCallback("bidi.", PrefChangedCallback, this);
 
   delete mBidiUtils;
 #endif // IBMBIDI
   nsContentUtils::UnregisterPrefCallback("layout.css.dpi",
                                          nsPresContext::PrefChangedCallback,
                                          this);
+  nsContentUtils::UnregisterPrefCallback("fit.text.to.screen",
+                                         nsPresContext::PrefChangedCallback,
+                                         this);
+  nsContentUtils::UnregisterPrefCallback("fit.screen.width",
+                                         nsPresContext::PrefChangedCallback,
+                                         this);
 
   NS_IF_RELEASE(mDeviceContext);
   NS_IF_RELEASE(mLookAndFeel);
   NS_IF_RELEASE(mLangGroup);
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsPresContext)
 
@@ -607,16 +614,23 @@
     // get a presshell.
     return;
   }
     
   mFontScaler =
     nsContentUtils::GetIntPref("browser.display.base_font_scaler",
                                mFontScaler);
 
+  mFitTextToWidth =
+    nsContentUtils::GetBoolPref("fit.text.to.screen",
+                                mFitTextToWidth);
+
+  mScreenWidth =
+    nsContentUtils::GetIntPref("fit.screen.width",
+                                mScreenWidth);
 
   mAutoQualityMinFontSizePixelsPref =
     nsContentUtils::GetIntPref("browser.display.auto_quality_min_font_size");
 
   // * document colors
   GetDocumentColorPreferences();
 
   // * link colors
@@ -759,16 +773,24 @@
       nscoord height = NSToCoordRound(oldHeightDevPixels*AppUnitsPerDevPixel());
       vm->SetWindowDimensions(width, height);
 
       MediaFeatureValuesChanged(PR_TRUE);
       RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
     }
     return;
   }
+  if (prefName.EqualsLiteral("fit.text.to.screen")) {
+    mFitTextToWidth = nsContentUtils::GetBoolPref("fit.text.to.screen", mFitTextToWidth);
+    return;
+  }
+  if (prefName.EqualsLiteral("fit.screen.width")) {
+    mScreenWidth = nsContentUtils::GetIntPref("fit.screen.width", mScreenWidth);
+    return;
+  }
   if (StringBeginsWith(prefName, NS_LITERAL_CSTRING("font."))) {
     // Changes to font family preferences don't change anything in the
     // computed style data, so the style system won't generate a reflow
     // hint for us.  We need to do that manually.
 
     // FIXME We could probably also handle changes to
     // browser.display.auto_quality_min_font_size here, but that
     // probably also requires clearing the text run cache, so don't
@@ -883,16 +905,22 @@
                                        this);
 #ifdef IBMBIDI
   nsContentUtils::RegisterPrefCallback("bidi.", PrefChangedCallback,
                                        this);
 #endif
   nsContentUtils::RegisterPrefCallback("layout.css.dpi",
                                        nsPresContext::PrefChangedCallback,
                                        this);
+  nsContentUtils::RegisterPrefCallback("fit.text.to.screen",
+                                       nsPresContext::PrefChangedCallback,
+                                       this);
+  nsContentUtils::RegisterPrefCallback("fit.screen.width",
+                                       nsPresContext::PrefChangedCallback,
+                                       this);
 
   rv = mEventManager->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   mEventManager->SetPresContext(this);
 
 #ifdef DEBUG
   mInitialized = PR_TRUE;
