# Try to manage by plugins supending/resuming before and after page load
# 235_Plugin_Notification.diff in gtkmozembed
Index: mozilla/modules/plugin/base/public/nsplugindefs.h
===================================================================
--- mozilla.orig/modules/plugin/base/public/nsplugindefs.h
+++ mozilla/modules/plugin/base/public/nsplugindefs.h
@@ -330,17 +330,17 @@
     uint32      wParam;
     uint32      lParam;
 
 #elif defined(XP_WIN)
     uint16      event;
     uint32      wParam;
     uint32      lParam;
 
-#elif defined(XP_UNIX) && defined(MOZ_X11)
+#elif defined(XP_UNIX)
     XEvent      event;
 #else
     void        *event;
 #endif
 };
 
 /*
  *  Non-standard event types that can be passed to HandleEvent
Index: mozilla/modules/plugin/base/src/ns4xPluginInstance.cpp
===================================================================
--- mozilla.orig/modules/plugin/base/src/ns4xPluginInstance.cpp
+++ mozilla/modules/plugin/base/src/ns4xPluginInstance.cpp
@@ -1062,16 +1062,30 @@
   if(error != NPERR_NO_ERROR) {
     // since the plugin returned failure, these should not be set
     mPeer = nsnull;
     mStarted = PR_FALSE;
 
     return NS_ERROR_FAILURE;
   }
   
+ 	// check the pref
+ 	nsCOMPtr<nsIPref> pref = do_GetService(NS_PREF_CONTRACTID);
+ 	PRBool suspend = PR_TRUE;
+  rv = pref->GetBoolPref("plugins.flashhack", &suspend);
+  if (NS_FAILED(rv) || !suspend)
+	  return NS_OK;
+ 	rv = pref->GetBoolPref("plugins.enableSuspending", &suspend);
+  if (NS_FAILED(rv) || !suspend)
+		return NS_OK;
+
+	PRBool handled;
+	nsPluginEvent event;
+	event.event.type = PLUGIN_EVENT_SUSPEND;
+	this->HandleEvent(&event, &handled);
   return NS_OK;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP ns4xPluginInstance::Destroy(void)
 {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Destroy this=%p\n",this));
