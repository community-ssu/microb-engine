diff -U 8 -prN mozilla-orig/toolkit/components/Makefile.in mozilla/toolkit/components/Makefile.in
--- mozilla-orig/toolkit/components/Makefile.in	2008-01-21 14:41:16.000000000 -0400
+++ mozilla/toolkit/components/Makefile.in	2008-01-21 14:55:45.000000000 -0400
@@ -62,17 +62,17 @@ DIRS += \
 
 ifneq (,$(filter cocoa, $(MOZ_WIDGET_TOOLKIT)))
 TOOL_DIRS += alerts
 else
 DIRS += alerts
 endif
 
 ifdef MOZ_FEEDS
-DIRS += feeds browser-feeds
+DIRS += feeds browser-feeds shell
 endif
 
 ifdef MOZ_PLACES
 ifdef MOZ_STORAGE
 DIRS += places
 endif
 endif
 
diff -U 8 -prN mozilla-orig/toolkit/components/browser-feeds/content/subscribe.xhtml mozilla/toolkit/components/browser-feeds/content/subscribe.xhtml
--- mozilla-orig/toolkit/components/browser-feeds/content/subscribe.xhtml	2008-01-21 14:41:16.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/content/subscribe.xhtml	2008-01-21 15:01:50.000000000 -0400
@@ -39,26 +39,27 @@
         </div>
 
 <!-- XXXmano this can't have any whitespace in it.  Otherwise you would see
      how much XUL-in-XHTML sucks, see bug 348830 -->
         <div id="feedSubscribeLine">
           <form>
             Subscribe to this feed using
             <select id="handlersMenuList">
-              <option webhandlerurl="http://fusion.google.com/add?feedurl=%s">  Google  </option>
-              <option webhandlerurl="http://add.my.yahoo.com/rss?url=%s">  Yahoo  </option>
-              <option webhandlerurl="http://www.bloglines.com/login?r=/sub/%s"> Bloglines  </option>
+              <option id="selectedAppMenuItem">_RSS Feed Reader_</option>
+              <option webhandlerurl="http://fusion.google.com/add?feedurl=%s">Google  </option>
+              <option webhandlerurl="http://add.my.yahoo.com/rss?url=%s">Yahoo  </option>
+              <option webhandlerurl="http://www.bloglines.com/login?r=/sub/%s">Bloglines  </option>
             </select>
             <br/>
             <br/>
             <input type="checkbox" name="alwaysUse" id="alwaysUse"/> Always use this reader
             <br/>
             <br/>
-            <input type="button" value="Subscribe" id="subscribeButton"/>
+            <input type="button" value="Subscribe Now" id="subscribeButton"/>
           </form>
 	</div
       ></div>
     </div>
 
 	  <!--
 	  <xul:vbox>
             <xul:hbox align="center">
diff -U 8 -prN mozilla-orig/toolkit/components/browser-feeds/src/FeedConverter.js mozilla/toolkit/components/browser-feeds/src/FeedConverter.js
--- mozilla-orig/toolkit/components/browser-feeds/src/FeedConverter.js	2008-01-21 14:41:16.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/FeedConverter.js	2008-01-21 14:54:29.000000000 -0400
@@ -348,17 +348,22 @@ var FeedResultService = {
         getService(Ci.nsIPrefBranch);
 
     var handler = safeGetCharPref(PREF_SELECTED_ACTION, "bookmarks");
     if (handler == "ask" || handler == "reader")
       handler = safeGetCharPref(PREF_SELECTED_READER, "bookmarks");
 
     switch (handler) {
     case "client":
-      var clientApp = prefs.getComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile);
+      //var clientApp = prefs.getComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile);
+      var clientAppPath = prefs.getCharPref(PREF_SELECTED_APP);
+      var clientApp = Components.classes["@mozilla.org/file/local;1"]
+        .createInstance(Components.interfaces.nsILocalFile);
+      clientApp.initWithPath(clientAppPath);
+
 #ifdef XP_MACOSX
       // On OS X, the built in feed dispatcher (Safari) sends feeds to other
       // applications (When Default Reader is adjusted) in the following format:
       //
       // http urls: replace scheme with feed, e.g.
       // http://foo.com/index.rdf -> feed://foo.com/index.rdf
       // other urils: prepend feed: scheme, e.g.
       // https://foo.com/index.rdf -> feed:https://foo.com/index.rdf
diff -U 8 -prN mozilla-orig/toolkit/components/browser-feeds/src/FeedWriter.js mozilla/toolkit/components/browser-feeds/src/FeedWriter.js
--- mozilla-orig/toolkit/components/browser-feeds/src/FeedWriter.js	2008-01-21 14:41:16.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/FeedWriter.js	2008-01-21 14:54:37.000000000 -0400
@@ -192,17 +192,17 @@ FeedWriter.prototype = {
 
       node = node.nextSibling;
     }
 
     return null;
   },
 
   _setCheckboxCheckedState: function FW__setCheckboxCheckedState(aCheckbox, aValue) {
-dump ("_setCheckboxCheckedState\n");
+    LOG ("_setCheckboxCheckedState");
     // see checkbox.xml
     var change = (aValue != (aCheckbox.getAttribute('checked') == 'true'));
     if (aValue)
       aCheckbox.setAttribute('checked', 'true');
     else
       aCheckbox.removeAttribute('checked');
 
     if (change) {
@@ -523,17 +523,17 @@ dump ("_setCheckboxCheckedState\n");
       }
     }
     catch(ex) { }
 
     return false;
   },
 
   _setAlwaysUseCheckedState: function FW__setAlwaysUseCheckedState() {
-dump ("_setAlwaysUseCheckedState\n");
+    LOG ("_setAlwaysUseCheckedState");
     var checkbox = this._document.getElementById("alwaysUse");
     if (checkbox) {
       var alwaysUse = false;
       try {
         var prefs = Cc["@mozilla.org/preferences-service;1"].
                     getService(Ci.nsIPrefBranch);
         if (prefs.getCharPref(PREF_SELECTED_ACTION) != "ask")
           alwaysUse = true;
@@ -554,17 +554,17 @@ dump ("_setAlwaysUseCheckedState\n");
       }
     }
   },
 
   /**
    * See nsIDOMEventListener
    */
   handleEvent: function(event) {
-    dump ("handleEvent\n\n");
+    LOG  ("handleEvent\n");
     // see comments in the write method
     event = new XPCNativeWrapper(event);
     if (event.target.ownerDocument != this._document) {
       LOG("FeedWriter.handleEvent: Someone passed the feed writer as a listener to the events of another document!");
       return;
     }
 
     if (event.type == "click") {
@@ -671,17 +671,17 @@ dump ("_setAlwaysUseCheckedState\n");
         if (liveBookmarksMenuItem)
           liveBookmarksMenuItem.doCommand();
       } 
     }
   },
 
   _initSubscriptionUI: function FW__initSubscriptionUI() {
 
-    dump ("_initSubscriptionUI\n" );
+    LOG ("_initSubscriptionUI\n" );
     // Set up the "Subscribe Now" button
     this._document
         .getElementById("subscribeButton")
         .addEventListener("click", this, false);
 
     this._document
         .getElementById("alwaysUse")
         .addEventListener("change", this, false);
@@ -967,43 +967,45 @@ dump ("_setAlwaysUseCheckedState\n");
       if (handler) {
         if (useAsDefault)
           wccr.setAutoHandler(TYPE_MAYBE_FEED, handler);
 
         this._window.location.href =
           handler.getHandlerURI(this._window.location.href);
       }
     }
-    //else {
-    //  switch (selectedItem.id) {
-    //    case "selectedAppMenuItem":
-    //      prefs.setCharPref(PREF_SELECTED_READER, "client");
-    //      prefs.setComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile, 
-    //                            this.selectedApplicationItemWrapped.file);
-    //      break;
+    else {
+      switch (selectedItem.id) {
+        case "selectedAppMenuItem":
+          prefs.setCharPref(PREF_SELECTED_READER, "client");
+          //prefs.setComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile, 
+                                //this.selectedApplicationItemWrapped.file);
+          prefs.setCharPref(PREF_SELECTED_APP, "/usr/bin/osso_rss_feed_reader");
+
+          break;
     //    case "defaultHandlerMenuItem":
     //      prefs.setCharPref(PREF_SELECTED_READER, "client");
     //      prefs.setComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile, 
     //                            this.defaultSystemReaderItemWrapped.file);
     //      break;
     //    case "liveBookmarksMenuItem":
     //      defaultHandler = "bookmarks";
     //      prefs.setCharPref(PREF_SELECTED_READER, "bookmarks");
     //      break;
-    //  }
-    //  var feedService = Cc["@mozilla.org/browser/feeds/result-service;1"].
-    //                    getService(Ci.nsIFeedResultService);
+      }
+      var feedService = Cc["@mozilla.org/browser/feeds/result-service;1"].
+                       getService(Ci.nsIFeedResultService);
 
       // Pull the title and subtitle out of the document
-    //  var feedTitle = this._document.getElementById(TITLE_ID).textContent;
-    //  var feedSubtitle =
-    //    this._document.getElementById(SUBTITLE_ID).textContent;
-    //  feedService.addToClientReader(this._window.location.href,
-    //                                feedTitle, feedSubtitle);
-    //}
+      var feedTitle = this._document.getElementById(TITLE_ID).textContent;
+      var feedSubtitle =
+          this._document.getElementById(SUBTITLE_ID).textContent;
+      feedService.addToClientReader(this._window.location.href,
+                                  feedTitle, feedSubtitle);
+    }
 
     // If "Always use..." is checked, we should set PREF_SELECTED_ACTION
     // to either "reader" (If a web reader or if an application is selected),
     // or to "bookmarks" (if the live bookmarks option is selected).
     // Otherwise, we should set it to "ask"
     if (useAsDefault)
       prefs.setCharPref(PREF_SELECTED_ACTION, defaultHandler);
     else
@@ -1020,17 +1022,17 @@ dump ("_setAlwaysUseCheckedState\n");
       return;
     }
 
     if (topic == "nsPref:changed") {
       switch (data) {
         case PREF_SELECTED_READER:
         case PREF_SELECTED_WEB:
         case PREF_SELECTED_APP:
-        dump ("**********observer*********\n\n");
+          LOG ("**********observer*********");
           this._setSelectedHandler();
           break;
         case PREF_SELECTED_ACTION:
           this._setAlwaysUseCheckedState();
       }
     } 
   },
 
diff -U 8 -prN mozilla-orig/toolkit/components/build/Makefile.in mozilla/toolkit/components/build/Makefile.in
--- mozilla-orig/toolkit/components/build/Makefile.in	2008-01-21 14:41:16.000000000 -0400
+++ mozilla/toolkit/components/build/Makefile.in	2008-01-21 14:56:13.000000000 -0400
@@ -83,30 +83,32 @@ REQUIRES = 	\
 		gfx \
 		locale \
 		unicharutil \
 		xuldoc \
 		alerts \
 		url-classifier \
 		feeds \
 		browser-feeds \
+		shellservice \
 		storage \
 		$(NULL)
 
 EXPORTS = nsToolkitCompsCID.h
 
 CPPSRCS = nsToolkitCompsModule.cpp
 
 LOCAL_INCLUDES = \
 	-I$(srcdir)/../downloads/src \
 	-I$(srcdir)/../startup/src \
 	-I$(srcdir)/../typeaheadfind/src \
 	-I$(srcdir)/../url-classifier/src \
 	-I$(srcdir)/../feeds/src \
 	-I$(srcdir)/../browser-feeds/src \
+	-I$(srcdir)/../shell/src \
 	$(NULL)
 
 ifdef ALERTS_SERVICE
 LOCAL_INCLUDES += \
 	-I$(srcdir)/../alerts/src \
 	$(NULL)
 endif
 
@@ -137,16 +139,21 @@ ifdef MOZ_URL_CLASSIFIER
 SHARED_LIBRARY_LIBS += ../url-classifier/src/$(LIB_PREFIX)urlclassifier_s.$(LIB_SUFFIX)
 endif
 
 ifdef MOZ_FEEDS
 SHARED_LIBRARY_LIBS += ../feeds/src/$(LIB_PREFIX)feed_s.$(LIB_SUFFIX)
 SHARED_LIBRARY_LIBS += ../browser-feeds/src/$(LIB_PREFIX)browser_feeds_s.$(LIB_SUFFIX)
 endif
 
+ifneq (,$(filter windows mac cocoa gtk2, $(MOZ_WIDGET_TOOLKIT)))
+SHARED_LIBRARY_LIBS += ../shell/src/$(LIB_PREFIX)shellservice_s.$(LIB_SUFFIX) \
+	$(NULL)
+endif
+
 SHARED_LIBRARY_LIBS += ../typeaheadfind/src/$(LIB_PREFIX)fastfind_s.$(LIB_SUFFIX)
 EXTRA_DSO_LIBS = gkgfx
 
 EXTRA_DSO_LDOPTS += \
 	$(LIBS_DIR) \
 	$(EXTRA_DSO_LIBS) \
 	$(MOZ_UNICHARUTIL_LIBS) \
 	$(MOZ_COMPONENT_LIBS) \
@@ -156,9 +163,17 @@ EXTRA_DSO_LDOPTS += \
 ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
 ifeq ($(OS_ARCH),WINNT)
 OS_LIBS	+= $(call EXPAND_LIBNAME,shell32 ole32)
 endif
 
+# Mac: Need to link with CoreFoundation for Mac Migrators (PList reading code)
+# GTK2: Need to link with glib for GNOME shell service
+ifneq (,$(filter mac cocoa gtk2,$(MOZ_WIDGET_TOOLKIT)))
+EXTRA_DSO_LDOPTS += \
+  $(TK_LIBS) \
+  $(NULL)
+endif
+
 include $(topsrcdir)/config/rules.mk
diff -U 8 -prN mozilla-orig/toolkit/components/build/nsToolkitCompsCID.h mozilla/toolkit/components/build/nsToolkitCompsCID.h
--- mozilla-orig/toolkit/components/build/nsToolkitCompsCID.h	2008-01-21 14:41:16.000000000 -0400
+++ mozilla/toolkit/components/build/nsToolkitCompsCID.h	2008-01-21 14:56:31.000000000 -0400
@@ -182,8 +182,13 @@
 { 0x6893e69, 0x71d8, 0x4b23, { 0x81, 0xeb, 0x80, 0x31, 0x4d, 0xaf, 0x3e, 0x66 } }
 
 #define NS_FEEDSNIFFER_CONTRACTID \
 "@mozilla.org/browser/feeds/sniffer;1"
 
 #define NS_ABOUTFEEDS_CID \
 { 0x12ff56ec, 0x58be, 0x402c, { 0xb0, 0x57, 0x1, 0xf9, 0x61, 0xde, 0x96, 0x9b } }
 
+#define NS_SHELLSERVICE_CID \
+{ 0x63c7b9f4, 0xcc8, 0x43f8, { 0xb6, 0x66, 0xa, 0x66, 0x16, 0x55, 0xcb, 0x73 } }
+
+#define NS_SHELLSERVICE_CONTRACTID \
+  "@mozilla.org/browser/shell-service;1"
diff -U 8 -prN mozilla-orig/toolkit/components/build/nsToolkitCompsModule.cpp mozilla/toolkit/components/build/nsToolkitCompsModule.cpp
--- mozilla-orig/toolkit/components/build/nsToolkitCompsModule.cpp	2008-01-21 14:41:16.000000000 -0400
+++ mozilla/toolkit/components/build/nsToolkitCompsModule.cpp	2008-01-21 14:56:40.000000000 -0400
@@ -65,16 +65,20 @@
 #endif
 
 #ifdef MOZ_FEEDS
 #include "nsScriptableUnescapeHTML.h"
 #include "nsFeedSniffer.h"
 #include "nsAboutFeeds.h"
 #endif
 
+#ifdef MOZ_WIDGET_GTK2
+#include "nsGNOMEShellService.h"
+#endif
+
 /////////////////////////////////////////////////////////////////////////////
 
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsAppStartup, Init)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsUserInfo)
 
 #ifdef ALERTS_SERVICE
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsAlertsService)
 #endif
@@ -100,16 +104,20 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsUrlClas
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsUrlClassifierUtils, Init)
 #endif
 
 #ifdef MOZ_FEEDS
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsScriptableUnescapeHTML)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsFeedSniffer)
 #endif
 
+#ifdef MOZ_WIDGET_GTK2
+NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsGNOMEShellService, Init)
+#endif
+
 /////////////////////////////////////////////////////////////////////////////
 
 static const nsModuleComponentInfo components[] =
 {
   { "App Startup Service",
     NS_TOOLKIT_APPSTARTUP_CID,
     NS_APPSTARTUP_CONTRACTID,
     nsAppStartupConstructor },
@@ -171,11 +179,17 @@ static const nsModuleComponentInfo compo
     nsFeedSnifferConstructor,
    nsFeedSniffer::Register },
   { "about:feeds Page",
     NS_ABOUTFEEDS_CID,
     NS_ABOUT_MODULE_CONTRACTID_PREFIX "feeds",
     nsAboutFeeds::Create
   },
 #endif
+#ifdef MOZ_WIDGET_GTK2
+  { "Browser Shell Service",
+    NS_SHELLSERVICE_CID,
+    NS_SHELLSERVICE_CONTRACTID,
+    nsGNOMEShellServiceConstructor },
+#endif
 };
 
 NS_IMPL_NSGETMODULE(nsToolkitCompsModule, components)
diff -U 8 -prN mozilla-orig/toolkit/components/shell/Makefile.in mozilla/toolkit/components/shell/Makefile.in
--- mozilla-orig/toolkit/components/shell/Makefile.in	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/Makefile.in	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,47 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla Browser code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2002
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Brian Ryner <bryner@brianryner.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+DIRS = public src
+
+include $(topsrcdir)/config/rules.mk
diff -U 8 -prN mozilla-orig/toolkit/components/shell/content/dummyWindow.xul mozilla/toolkit/components/shell/content/dummyWindow.xul
--- mozilla-orig/toolkit/components/shell/content/dummyWindow.xul	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/content/dummyWindow.xul	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,46 @@
+<?xml version="1.0"?>
+
+<!-- ***** BEGIN LICENSE BLOCK *****
+   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
+   -
+   - The contents of this file are subject to the Mozilla Public License Version
+   - 1.1 (the "License"); you may not use this file except in compliance with
+   - the License. You may obtain a copy of the License at
+   - http://www.mozilla.org/MPL/
+   -
+   - Software distributed under the License is distributed on an "AS IS" basis,
+   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+   - for the specific language governing rights and limitations under the
+   - License.
+   -
+   - The Original Code is Mozilla WinXP SP1 Support.
+   -
+   - The Initial Developer of the Original Code is
+   - Netscape Communications Corporation.
+   - Portions created by the Initial Developer are Copyright (C) 2002
+   - the Initial Developer. All Rights Reserved.
+   -
+   - Contributor(s):
+   -   Bill Law  <law@netscape.com>
+   -
+   - Alternatively, the contents of this file may be used under the terms of
+   - either the GNU General Public License Version 2 or later (the "GPL"), or
+   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+   - in which case the provisions of the GPL or the LGPL are applicable instead
+   - of those above. If you wish to allow use of your version of this file only
+   - under the terms of either the GPL or the LGPL, and not to allow others to
+   - use your version of this file under the terms of the MPL, indicate your
+   - decision by deleting the provisions above and replace them with the notice
+   - and other provisions required by the LGPL or the GPL. If you do not delete
+   - the provisions above, a recipient may use your version of this file under
+   - the terms of any one of the MPL, the GPL or the LGPL.
+   -
+   - ***** END LICENSE BLOCK ***** -->
+
+<!-- This is a dummy window that autocloses.  See nsDefaultBrowser.js. -->
+
+<!DOCTYPE window>
+
+<window id="dummyWindow" onload="window.close()"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+</window>
diff -U 8 -prN mozilla-orig/toolkit/components/shell/content/setDesktopBackground.js mozilla/toolkit/components/shell/content/setDesktopBackground.js
--- mozilla-orig/toolkit/components/shell/content/setDesktopBackground.js	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/content/setDesktopBackground.js	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,253 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Firebird about dialog.
+#
+# The Initial Developer of the Original Code is
+# Blake Ross (blake@blakeross.com).
+# Portions created by the Initial Developer are Copyright (C) 2002
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Blake Ross <blake@blakeross.com>
+#   Ben Goodger <ben@mozilla.org>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the LGPL or the GPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+const kXUL_NS            = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const kIShellService    = Components.interfaces.nsIShellService;
+#ifdef XP_MACOSX
+const kIMacShellService = Components.interfaces.nsIMacShellService;
+#endif
+
+var gSetBackground = {
+  _position         : kIShellService.BACKGROUND_STRETCH,
+  _monitor          : null,
+  _image            : null,
+  _backgroundColor  : 0,
+
+#ifndef XP_MACOSX
+  // Converts a color string in the format "#RRGGBB" to an integer.
+  _hexStringToLong: function (aString)
+  {
+    return parseInt(aString.substring(1,3), 16) << 16 | 
+           parseInt(aString.substring(3,5), 16) << 8 |
+           parseInt(aString.substring(5,7), 16);
+  },
+
+  _rgbToHex: function(aR, aG, aB) 
+  {
+    var rHex = aR.toString(16).toUpperCase();
+    var gHex = aG.toString(16).toUpperCase();
+    var bHex = aB.toString(16).toUpperCase();
+
+    if (rHex.length == 1) rHex ='0' + rHex;
+    if (gHex.length == 1) gHex ='0' + gHex;
+    if (bHex.length == 1) bHex ='0' + bHex;
+
+    return '#' + rHex + gHex + bHex;
+  },
+#endif
+
+  get _shell()
+  {
+    return Components.classes["@mozilla.org/browser/shell-service;1"]
+                     .getService(Components.interfaces.nsIShellService);
+  },
+
+  load: function ()
+  {
+    this._monitor = document.getElementById("monitor");
+#ifdef XP_MACOSX
+    document.documentElement.getButton("accept").hidden = true;
+#endif
+    this.init(window.arguments[0]);
+  },
+
+  init: function (aImage)
+  {
+    this._image = aImage;
+
+#ifndef XP_MACOSX
+    this._initColor();
+    var position = parseInt(document.getElementById("menuPosition").value);
+#else
+    // Make sure to reset the button state in case the user has already
+    // set an image as their desktop background. 
+    var setDesktopBackground = document.getElementById("setDesktopBackground");
+    setDesktopBackground.hidden = false;
+    var bundle = document.getElementById("backgroundBundle");
+    setDesktopBackground.label = bundle.getString("DesktopBackgroundSet");
+    setDesktopBackground.disabled = false;
+
+    var showDesktopPreferences = document.getElementById("showDesktopPreferences");
+    showDesktopPreferences.hidden = true;
+
+    var position = kIShellService.BACKGROUND_STRETCH;
+#endif
+    this.updatePosition(position);
+  },
+
+#ifndef XP_MACOSX
+  _initColor: function ()
+  {
+    var color = this._shell.desktopBackgroundColor;
+
+    const rMask = 4294901760;
+    const gMask = 65280;
+    const bMask = 255;
+    var r = (color & rMask) >> 16;
+    var g = (color & gMask) >> 8;
+    var b = (color & bMask);
+    this._backgroundColor = this._rgbToHex(r, g, b);
+
+    var colorpicker = document.getElementById("desktopColor");
+    colorpicker.color = this._backgroundColor;
+  },
+#endif
+
+  observe: function (aSubject, aTopic, aData)
+  {
+    if (aTopic == "shell:desktop-background-changed") {
+      var setDesktopBackground = document.getElementById("setDesktopBackground");
+      setDesktopBackground.hidden = true;
+
+      var showDesktopPreferences = document.getElementById("showDesktopPreferences");
+      showDesktopPreferences.hidden = false;
+
+      var os = Components.classes["@mozilla.org/observer-service;1"]
+                         .getService(Components.interfaces.nsIObserverService);
+      os.removeObserver(this, "shell:desktop-background-changed");
+    }
+  },
+
+#ifdef XP_MACOSX
+  setDesktopBackground: function()
+  {
+    var os = Components.classes["@mozilla.org/observer-service;1"]
+                       .getService(Components.interfaces.nsIObserverService);
+    os.addObserver(this, "shell:desktop-background-changed", false);
+
+    var bundle = document.getElementById("backgroundBundle");
+    var setDesktopBackground = document.getElementById("setDesktopBackground");
+    setDesktopBackground.disabled = true;
+    setDesktopBackground.label = bundle.getString("DesktopBackgroundDownloading");
+
+    this._shell.setDesktopBackground(this._image, this._position);
+  },
+  
+  showDesktopPrefs: function()
+  {
+    this._shell.openApplication(kIMacShellService.APPLICATION_DESKTOP);
+  },
+#else
+  setDesktopBackground: function () 
+  {
+    this._shell.setDesktopBackground(this._image, this._position);
+    this._shell.desktopBackgroundColor = this._hexStringToLong(this._backgroundColor);
+    document.persist("menuPosition", "value");
+  },
+#endif
+
+  updateColor: function (color)
+  {
+#ifndef XP_MACOSX
+    this._backgroundColor = color;
+    
+    if (this._position != kIShellService.BACKGROUND_TILE)
+      this._monitor.style.backgroundColor = color;
+#endif
+  },
+  
+  updatePosition: function (aPosition)
+  {
+    if (this._monitor.hasChildNodes())
+      this._monitor.removeChild(this._monitor.firstChild);
+      
+    this._position = aPosition;
+    if (this._position == kIShellService.BACKGROUND_TILE)
+      this._tileImage();
+    else if (this._position == kIShellService.BACKGROUND_STRETCH)
+      this._stretchImage();
+    else
+      this._centerImage();
+  },
+
+  _createImage: function ()
+  {
+    const nsIImageLoadingContent = Components.interfaces.nsIImageLoadingContent;
+    if (!(this._image instanceof nsIImageLoadingContent))
+        return false;
+
+    var request = this._image.QueryInterface(nsIImageLoadingContent)
+                             .getRequest(nsIImageLoadingContent.CURRENT_REQUEST);
+    if (!request)
+      return false;
+
+    var imgURI = this._image.currentURI;
+    if (imgURI.schemeIs("javascript"))
+      return false;
+
+    var img = document.createElementNS(kXUL_NS, "image");
+    img.setAttribute("src", imgURI.spec);
+    return img;
+  },
+
+  _stretchImage: function ()
+  {
+    this.updateColor(this._backgroundColor);
+
+    var img = this._createImage();
+    img.width = this._monitor.boxObject.width;
+    img.height = this._monitor.boxObject.height;
+    this._monitor.appendChild(img);
+  },
+
+  _tileImage: function ()
+  {
+    var bundle = document.getElementById("backgroundBundle");
+
+    this._monitor.style.backgroundColor = "white";
+
+    var text = document.createElementNS(kXUL_NS, "label");
+    text.setAttribute("id", "noPreviewAvailable");
+    text.setAttribute("value", bundle.getString("DesktopBackgroundNoPreview"));
+    this._monitor.appendChild(text);
+  },
+
+  _centerImage: function ()
+  {
+    this.updateColor(this._backgroundColor);
+
+    var img = this._createImage();
+    // Use naturalHeight/Width here so we don't scale an image improperly in
+    // the preview window if the image is resized in the browser window.
+    var width = this._image.naturalWidth * this._monitor.boxObject.width / screen.width;
+    var height = this._image.naturalHeight * this._monitor.boxObject.height / screen.height;
+    img.width = Math.floor(width);
+    img.height = Math.floor(height);
+    this._monitor.appendChild(img);
+  }
+};
diff -U 8 -prN mozilla-orig/toolkit/components/shell/content/setDesktopBackground.xul mozilla/toolkit/components/shell/content/setDesktopBackground.xul
--- mozilla-orig/toolkit/components/shell/content/setDesktopBackground.xul	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/content/setDesktopBackground.xul	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,119 @@
+<?xml version="1.0"?> <!-- -*- Mode: HTML -*- --> 
+
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla Firebird about dialog.
+#
+# The Initial Developer of the Original Code is
+# Blake Ross (blake@blakeross.com).
+# Portions created by the Initial Developer are Copyright (C) 2002
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Blake Ross <blake@blakeross.com>
+#   Ben Goodger <ben@mozilla.org>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the LGPL or the GPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** -->
+
+<?xml-stylesheet href="chrome://global/skin/" type="text/css"?> 
+<?xml-stylesheet href="chrome://browser/skin/setDesktopBackground.css" type="text/css"?>
+
+<!DOCTYPE dialog SYSTEM "chrome://browser/locale/setDesktopBackground.dtd">
+
+#ifdef XP_MACOSX
+<?xul-overlay href="chrome://browser/content/macBrowserOverlay.xul"?>
+#endif
+
+<dialog xmlns:html="http://www.w3.org/1999/xhtml"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        id="aboutDialog"
+        windowtype="Shell:SetDesktopBackground"
+#ifndef XP_MACOSX
+        buttons="accept,cancel"
+#else
+        buttons="accept"
+#endif
+        buttonlabelaccept="&setDesktopBackground.title;"
+        onload="gSetBackground.load();"
+        ondialogaccept="gSetBackground.setDesktopBackground();"
+        title="&setDesktopBackground.title;"
+        style="width: 30em;"> 
+    
+    <stringbundle id="backgroundBundle"
+                  src="chrome://browser/locale/shellservice.properties"/>
+    <script type="application/x-javascript"
+            src="chrome://browser/content/utilityOverlay.js"/>
+    <script type="application/x-javascript"
+            src="chrome://browser/content/setDesktopBackground.js"/>
+    <script type="application/x-javascript"
+            src="chrome://global/content/contentAreaUtils.js"/>
+
+#ifndef XP_MACOSX
+    <hbox align="center" id="foo">
+      <label value="&position.label;"/>
+      <menulist id="menuPosition"
+                label="&position.label;" 
+                oncommand="gSetBackground.updatePosition(parseInt(this.value));">
+        <menupopup>
+          <menuitem label="&center.label;"  value="3"/>
+          <menuitem label="&tile.label;"    value="1"/>
+          <menuitem label="&stretch.label;" value="2"/>
+        </menupopup>
+      </menulist>
+      <spacer flex="1"/>
+      <label value="&color.label;"/>
+      <colorpicker id="desktopColor"
+                   type="button" 
+                   onchange="gSetBackground.updateColor(this.color);"/> 
+    </hbox>
+#endif
+    <groupbox align="center">
+      <caption label="&preview.label;"/>
+      <stack>
+        <vbox id="monitor" align="center" pack="center"/>
+        <image id="monitorImage"/>
+      </stack>
+    </groupbox>
+    
+#ifdef XP_MACOSX
+    <separator/>
+    
+    <hbox align="right">
+      <button id="setDesktopBackground"
+              label="&setDesktopBackground.title;" 
+              oncommand="gSetBackground.setDesktopBackground();"/>
+      <button id="showDesktopPreferences"
+              label="&openDesktopPrefs.label;"
+              oncommand="gSetBackground.showDesktopPrefs();"
+              hidden="true"/>
+    </hbox>
+#endif
+
+#ifdef XP_MACOSX
+#include ../../../base/content/browserMountPoints.inc
+#endif
+
+</dialog>
diff -U 8 -prN mozilla-orig/toolkit/components/shell/jar.mn mozilla/toolkit/components/shell/jar.mn
--- mozilla-orig/toolkit/components/shell/jar.mn	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/jar.mn	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,7 @@
+toolkit.jar:
+    content/global/dummyWindow.xul (content/dummyWindow.xul)
+
+browser.jar:
+*       content/browser/setDesktopBackground.xul              (content/setDesktopBackground.xul)
+*       content/browser/setDesktopBackground.js               (content/setDesktopBackground.js)
+
diff -U 8 -prN mozilla-orig/toolkit/components/shell/public/Makefile.in mozilla/toolkit/components/shell/public/Makefile.in
--- mozilla-orig/toolkit/components/shell/public/Makefile.in	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/public/Makefile.in	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,58 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2001
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH   = ../../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH   = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = shellservice
+XPIDL_MODULE  = shellservice
+
+XPIDLSRCS = nsIShellService.idl
+
+ifeq ($(OS_ARCH),WINNT)
+XPIDLSRCS += nsIWindowsShellService.idl
+endif
+
+ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+XPIDLSRCS += nsIMacShellService.idl
+endif
+
+include $(topsrcdir)/config/rules.mk
diff -U 8 -prN mozilla-orig/toolkit/components/shell/public/nsIMacShellService.idl mozilla/toolkit/components/shell/public/nsIMacShellService.idl
--- mozilla-orig/toolkit/components/shell/public/nsIMacShellService.idl	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/public/nsIMacShellService.idl	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,47 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ben Goodger <ben@mozilla.org> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIShellService.idl"
+
+[scriptable, uuid(7f8ca08e-1df4-4735-86e9-50dedb48e5e8)]
+interface nsIMacShellService : nsIShellService
+{
+  const long APPLICATION_KEYCHAIN_ACCESS  = 2;
+  const long APPLICATION_NETWORK          = 3;
+  const long APPLICATION_DESKTOP          = 4;
+};
+
diff -U 8 -prN mozilla-orig/toolkit/components/shell/public/nsIShellService.idl mozilla/toolkit/components/shell/public/nsIShellService.idl
--- mozilla-orig/toolkit/components/shell/public/nsIShellService.idl	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/public/nsIShellService.idl	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,130 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ben Goodger <ben@mozilla.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIDOMElement;
+interface nsILocalFile;
+
+[scriptable, uuid(bb477da4-dddf-4106-a562-f06c85c7f9a8)]
+interface nsIShellService : nsISupports
+{
+  /**
+   * Determines whether or not Firefox is the "Default Browser."
+   * This is simply whether or not Firefox is registered to handle 
+   * http links. 
+   * 
+   * @param aStartupCheck true if this is the check being performed
+   *                      by the first browser window at startup, 
+   *                      false otherwise. 
+   */
+  boolean isDefaultBrowser(in boolean aStartupCheck);
+
+  /**
+   * Registers Firefox as the "Default Browser."
+   *
+   * @param aClaimAllTypes Register Firefox as the handler for 
+   *                       additional protocols (ftp, chrome etc)
+   *                       and web documents (.html, .xhtml etc).
+   * @param aForAllUsers   Whether or not Firefox should attempt
+   *                       to become the default browser for all
+   *                       users on a multi-user system. 
+   */
+  void setDefaultBrowser(in boolean aClaimAllTypes, in boolean aForAllUsers);
+
+  /** 
+   * Used to determine whether or not to show a "Set Default Browser"
+   * query dialog. This attribute is true if the application is starting
+   * up and "browser.shell.checkDefaultBrowser" is true, otherwise it
+   * is false.
+   */
+  attribute boolean shouldCheckDefaultBrowser;
+
+  /** 
+   * Flags for positioning/sizing of the Desktop Background image.
+   */
+  const long BACKGROUND_TILE      = 1;
+  const long BACKGROUND_STRETCH   = 2;
+  const long BACKGROUND_CENTER    = 3;
+  const long BACKGROUND_FILL      = 4;
+
+    /**
+     * Sets the desktop background image using either the HTML <IMG> 
+     * element supplied or the background image of the element supplied.
+     *
+     * @param aImageElement Either a HTML <IMG> element or an element with
+     *                      a background image from which to source the
+     *                      background image. 
+     * @param aPosition     How to place the image on the desktop
+     */
+  void setDesktopBackground(in nsIDOMElement aElement, in long aPosition);
+
+  /**
+   * Constants identifying applications that can be opened with
+   * openApplication.
+   */
+  const long APPLICATION_MAIL        = 0;
+  const long APPLICATION_NEWS        = 1;
+
+  /**
+   * Opens the application specified. If more than one application of the
+   * given type is available on the system, the default or "preferred"
+   * application is used. 
+   */
+  void openApplication(in long aApplication);
+
+  /** 
+   * The desktop background color, visible when no background image is 
+   * used, or if the background image is centered and does not fill the 
+   * entire screen. A rgb value, where (r << 16 | g << 8 | b)
+   */
+  attribute unsigned long desktopBackgroundColor;
+
+  /**
+   * Opens an application with a specific URI to load.
+   * @param   application
+   *          The application file (or bundle directory, on OS X)
+   * @param   uri
+   *          The uri to be loaded by the application
+   */
+  void openApplicationWithURI(in nsILocalFile aApplication, in ACString aURI);
+
+  /**
+   * The default system handler for web feeds
+   */
+  readonly attribute nsILocalFile defaultFeedReader;
+};
diff -U 8 -prN mozilla-orig/toolkit/components/shell/public/nsIWindowsShellService.idl mozilla/toolkit/components/shell/public/nsIWindowsShellService.idl
--- mozilla-orig/toolkit/components/shell/public/nsIWindowsShellService.idl	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/public/nsIWindowsShellService.idl	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ben Goodger <ben@mozilla.org> (Original Author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsIShellService.idl"
+
+[scriptable, uuid(3ee25e62-ad0f-464e-8225-c3b774137387)]
+interface nsIWindowsShellService : nsIShellService
+{
+    /** 
+     * The number of unread mail messages for the current user.
+     * 
+     * @return The number of unread (new) mail messages for the current user.
+     */
+    readonly attribute unsigned long unreadMailCount;
+};
+
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/Makefile.in mozilla/toolkit/components/shell/src/Makefile.in
--- mozilla-orig/toolkit/components/shell/src/Makefile.in	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/Makefile.in	2008-01-21 15:59:00.000000000 -0400
@@ -0,0 +1,102 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 1998
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH   = ../../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH   = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = shellservice
+FORCE_STATIC_LIB = 1
+FORCE_USE_PIC = 1
+USE_STATIC_LIBS = 1
+LIBXUL_LIBRARY = 1
+
+REQUIRES	= \
+		  xpcom \
+		  string \
+		  uriloader \
+		  webbrowserpersist \
+		  dom \
+		  intl \
+		  necko \
+		  content \
+		  imglib2 \
+		  browsercomps \
+		  gfx \
+                  widget \
+		  pref \
+		  layout \
+		  $(NULL)
+
+ifeq ($(OS_ARCH),WINNT)
+CPPSRCS = nsWindowsShellService.cpp
+else
+ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+CPPSRCS = nsMacShellService.cpp
+else
+ifeq ($(MOZ_WIDGET_TOOLKIT), gtk2)
+CPPSRCS = nsGNOMEShellService.cpp
+REQUIRES += mozgnome
+endif
+endif
+endif
+
+ifdef CPPSRCS
+LIBRARY_NAME = shellservice_s
+endif
+
+include $(topsrcdir)/config/rules.mk
+
+DEFINES += -DMOZ_APP_NAME=\"$(MOZ_APP_NAME)\"
+
+JS_SET_BROWSER_COMPONENT = nsSetDefaultBrowser.js
+EXTRA_COMPONENTS = nsSetDefaultBrowser.js
+
+CXXFLAGS += $(TK_CFLAGS)
+
+libs::
+	$(INSTALL) $(srcdir)/$(JS_SET_BROWSER_COMPONENT) $(DIST)/bin/components
+
+install::
+	$(SYSINSTALL) $(IFLAGS1) $(srcdir)/$(JS_SET_BROWSER_COMPONENT) $(DESTDIR)$(mozappdir)/components
+
+clobber::
+	rm -f $(DIST)/lib/$(LIBRARY_NAME).lib
+# 	rm -f $(DIST)/bin/components/$(JS_SET_BROWSER_COMPONENT)
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsGNOMEShellService.cpp mozilla/toolkit/components/shell/src/nsGNOMEShellService.cpp
--- mozilla-orig/toolkit/components/shell/src/nsGNOMEShellService.cpp	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsGNOMEShellService.cpp	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,633 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsCOMPtr.h"
+#include "nsGNOMEShellService.h"
+#include "nsShellService.h"
+#include "nsIServiceManager.h"
+#include "nsILocalFile.h"
+#include "nsIProperties.h"
+#include "nsDirectoryServiceDefs.h"
+#include "nsIPrefService.h"
+#include "prenv.h"
+
+#include "nsIGConfService.h"
+#include "nsIGnomeVFSService.h"
+#include "nsIStringBundle.h"
+#include "gfxIImageFrame.h"
+#include "nsIOutputStream.h"
+#include "nsIProcess.h"
+#include "nsNetUtil.h"
+#include "nsIDOMHTMLImageElement.h"
+#include "nsIImageLoadingContent.h"
+#include "imgIRequest.h"
+#include "imgIContainer.h"
+#include "nsIImage.h"
+#include "prprf.h"
+#ifdef MOZ_WIDGET_GTK2
+#include "nsIImageToPixbuf.h"
+#endif
+
+#include <glib.h>
+#include <glib-object.h>
+#include <gdk-pixbuf/gdk-pixbuf.h>
+#include <limits.h>
+#include <stdlib.h>
+
+struct ProtocolAssociation
+{
+  const char *name;
+  PRBool essential;
+};
+
+struct MimeTypeAssociation
+{
+  const char *mimeType;
+  const char *extensions;
+};
+
+static const ProtocolAssociation appProtocols[] = {
+  { "http",   PR_TRUE  },
+  { "https",  PR_TRUE  },
+  { "ftp",    PR_FALSE },
+  { "gopher", PR_FALSE },
+  { "chrome", PR_FALSE }
+};
+
+static const MimeTypeAssociation appTypes[] = {
+  { "text/html",             "htm html shtml" },
+  { "application/xhtml+xml", "xhtml xht"      }
+};
+
+static const char kDocumentIconPath[] = "firefox-document.png";
+
+// GConf registry key constants
+#define DG_BACKGROUND "/desktop/gnome/background"
+
+static const char kDesktopImageKey[] = DG_BACKGROUND "/picture_filename";
+static const char kDesktopOptionsKey[] = DG_BACKGROUND "/picture_options";
+static const char kDesktopDrawBGKey[] = DG_BACKGROUND "/draw_background";
+static const char kDesktopColorKey[] = DG_BACKGROUND "/primary_color";
+
+nsresult
+nsGNOMEShellService::Init()
+{
+  nsresult rv;
+
+  // GConf and GnomeVFS _must_ be available, or we do not allow
+  // CreateInstance to succeed.
+
+  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+  nsCOMPtr<nsIGnomeVFSService> vfs =
+    do_GetService(NS_GNOMEVFSSERVICE_CONTRACTID);
+
+  if (!gconf || !vfs)
+    return NS_ERROR_NOT_AVAILABLE;
+
+  // Check G_BROKEN_FILENAMES.  If it's set, then filenames in glib use
+  // the locale encoding.  If it's not set, they use UTF-8.
+  mUseLocaleFilenames = PR_GetEnv("G_BROKEN_FILENAMES") != nsnull;
+
+  nsCOMPtr<nsIProperties> dirSvc
+    (do_GetService("@mozilla.org/file/directory_service;1"));
+  NS_ENSURE_TRUE(dirSvc, NS_ERROR_NOT_AVAILABLE);
+
+  nsCOMPtr<nsILocalFile> appPath;
+  rv = dirSvc->Get(NS_XPCOM_CURRENT_PROCESS_DIR, NS_GET_IID(nsILocalFile),
+                   getter_AddRefs(appPath));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = appPath->AppendNative(NS_LITERAL_CSTRING(MOZ_APP_NAME));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return appPath->GetNativePath(mAppPath);
+}
+
+NS_IMPL_ISUPPORTS1(nsGNOMEShellService, nsIShellService)
+
+PRBool
+nsGNOMEShellService::KeyMatchesAppName(const char *aKeyValue) const
+{
+
+  gchar *commandPath;
+  if (mUseLocaleFilenames) {
+    gchar *nativePath = g_filename_from_utf8(aKeyValue, -1, NULL, NULL, NULL);
+    if (!nativePath) {
+      NS_ERROR("Error converting path to filesystem encoding");
+      return PR_FALSE;
+    }
+
+    commandPath = g_find_program_in_path(nativePath);
+    g_free(nativePath);
+  } else {
+    commandPath = g_find_program_in_path(aKeyValue);
+  }
+
+  if (!commandPath)
+    return PR_FALSE;
+
+  PRBool matches = mAppPath.Equals(commandPath);
+  g_free(commandPath);
+  return matches;
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::IsDefaultBrowser(PRBool aStartupCheck,
+                                      PRBool* aIsDefaultBrowser)
+{
+  *aIsDefaultBrowser = PR_FALSE;
+  if (aStartupCheck)
+    mCheckedThisSession = PR_TRUE;
+
+  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+
+  PRBool enabled;
+  nsCAutoString handler;
+
+  for (unsigned int i = 0; i < NS_ARRAY_LENGTH(appProtocols); ++i) {
+    if (!appProtocols[i].essential)
+      continue;
+
+    handler.Truncate();
+    gconf->GetAppForProtocol(nsDependentCString(appProtocols[i].name),
+                             &enabled, handler);
+
+    // The string will be something of the form: [/path/to/]browser "%s"
+    // We want to remove all of the parameters and get just the binary name.
+
+    gint argc;
+    gchar **argv;
+
+    if (g_shell_parse_argv(handler.get(), &argc, &argv, NULL) && argc > 0) {
+      handler.Assign(argv[0]);
+      g_strfreev(argv);
+    }
+
+    if (!KeyMatchesAppName(handler.get()) || !enabled)
+      return NS_OK; // the handler is disabled or set to another app
+  }
+
+  *aIsDefaultBrowser = PR_TRUE;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::SetDefaultBrowser(PRBool aClaimAllTypes,
+                                       PRBool aForAllUsers)
+{
+#ifdef DEBUG
+  if (aForAllUsers)
+    NS_WARNING("Setting the default browser for all users is not yet supported");
+#endif
+
+  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+
+  nsCAutoString schemeList;
+  nsCAutoString appKeyValue(mAppPath);
+  appKeyValue.Append(" \"%s\"");
+  unsigned int i;
+
+  for (i = 0; i < NS_ARRAY_LENGTH(appProtocols); ++i) {
+    schemeList.Append(nsDependentCString(appProtocols[i].name));
+    schemeList.Append(',');
+
+    if (appProtocols[i].essential || aClaimAllTypes) {
+      gconf->SetAppForProtocol(nsDependentCString(appProtocols[i].name),
+                               appKeyValue);
+    }
+  }
+
+  if (aClaimAllTypes) {
+    nsCOMPtr<nsIGnomeVFSService> vfs =
+      do_GetService(NS_GNOMEVFSSERVICE_CONTRACTID);
+
+    nsCOMPtr<nsIStringBundleService> bundleService =
+      do_GetService(NS_STRINGBUNDLE_CONTRACTID);
+    NS_ENSURE_TRUE(bundleService, NS_ERROR_OUT_OF_MEMORY);
+
+    nsCOMPtr<nsIStringBundle> brandBundle;
+    bundleService->CreateBundle(BRAND_PROPERTIES, getter_AddRefs(brandBundle));
+    NS_ENSURE_TRUE(brandBundle, NS_ERROR_FAILURE);
+
+    nsString brandShortName, brandFullName;
+    brandBundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
+                                   getter_Copies(brandShortName));
+    brandBundle->GetStringFromName(NS_LITERAL_STRING("brandFullName").get(),
+                                   getter_Copies(brandFullName));
+
+    // use brandShortName as the application id.
+    NS_ConvertUTF16toUTF8 id(brandShortName);
+
+    vfs->SetAppStringKey(id, nsIGnomeVFSService::APP_KEY_COMMAND, mAppPath);
+    vfs->SetAppStringKey(id, nsIGnomeVFSService::APP_KEY_NAME,
+                         NS_ConvertUTF16toUTF8(brandFullName));
+
+    // We don't want to be the default handler for "file:", but we do
+    // want Nautilus to know that we support file: if the MIME type is
+    // one that we can handle.
+
+    schemeList.Append("file");
+
+    vfs->SetAppStringKey(id, nsIGnomeVFSService::APP_KEY_SUPPORTED_URI_SCHEMES,
+                         schemeList);
+
+    vfs->SetAppStringKey(id, nsIGnomeVFSService::APP_KEY_EXPECTS_URIS,
+                         NS_LITERAL_CSTRING("true"));
+
+    vfs->SetAppBoolKey(id, nsIGnomeVFSService::APP_KEY_CAN_OPEN_MULTIPLE,
+                       PR_FALSE);
+
+    vfs->SetAppBoolKey(id, nsIGnomeVFSService::APP_KEY_REQUIRES_TERMINAL,
+                       PR_FALSE);
+
+    // Copy icons/document.png to ~/.icons/firefox-document.png
+    nsCAutoString iconFilePath(mAppPath);
+    PRInt32 lastSlash = iconFilePath.RFindChar(PRUnichar('/'));
+    if (lastSlash == -1) {
+      NS_ERROR("no slash in executable path?");
+    } else {
+      iconFilePath.SetLength(lastSlash);
+      nsCOMPtr<nsILocalFile> iconFile;
+      NS_NewNativeLocalFile(iconFilePath, PR_FALSE, getter_AddRefs(iconFile));
+      if (iconFile) {
+        iconFile->AppendRelativeNativePath(NS_LITERAL_CSTRING("icons/document.png"));
+
+        nsCOMPtr<nsILocalFile> userIconPath;
+        NS_NewNativeLocalFile(nsDependentCString(PR_GetEnv("HOME")), PR_FALSE,
+                              getter_AddRefs(userIconPath));
+        if (userIconPath) {
+          userIconPath->AppendNative(NS_LITERAL_CSTRING(".icons"));
+          iconFile->CopyToNative(userIconPath,
+                                 nsDependentCString(kDocumentIconPath));
+        }
+      }
+    }
+
+    for (i = 0; i < NS_ARRAY_LENGTH(appTypes); ++i) {
+      vfs->AddMimeType(id, nsDependentCString(appTypes[i].mimeType));
+      vfs->SetMimeExtensions(nsDependentCString(appTypes[i].mimeType),
+                             nsDependentCString(appTypes[i].extensions));
+      vfs->SetAppForMimeType(nsDependentCString(appTypes[i].mimeType), id);
+      vfs->SetIconForMimeType(nsDependentCString(appTypes[i].mimeType),
+                              NS_LITERAL_CSTRING(kDocumentIconPath));
+    }
+
+    vfs->SyncAppRegistry();
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::GetShouldCheckDefaultBrowser(PRBool* aResult)
+{
+  // If we've already checked, the browser has been started and this is a 
+  // new window open, and we don't want to check again.
+  if (mCheckedThisSession) {
+    *aResult = PR_FALSE;
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIPrefBranch> prefs;
+  nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
+  if (pserve)
+    pserve->GetBranch("", getter_AddRefs(prefs));
+
+  prefs->GetBoolPref(PREF_CHECKDEFAULTBROWSER, aResult);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::SetShouldCheckDefaultBrowser(PRBool aShouldCheck)
+{
+  nsCOMPtr<nsIPrefBranch> prefs;
+  nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
+  if (pserve)
+    pserve->GetBranch("", getter_AddRefs(prefs));
+
+  prefs->SetBoolPref(PREF_CHECKDEFAULTBROWSER, aShouldCheck);
+
+  return NS_OK;
+}
+
+static nsresult
+WriteImage(const nsCString& aPath, gfxIImageFrame* aImage)
+{
+  nsCOMPtr<nsIImage> img(do_GetInterface(aImage));
+  if (!img)
+      return NS_ERROR_NOT_AVAILABLE;
+
+#ifndef MOZ_WIDGET_GTK2
+  return NS_ERROR_NOT_AVAILABLE;
+#else
+  nsCOMPtr<nsIImageToPixbuf> imgToPixbuf =
+    do_GetService("@mozilla.org/widget/image-to-gdk-pixbuf;1");
+  if (!imgToPixbuf)
+      return NS_ERROR_NOT_AVAILABLE;
+
+  GdkPixbuf* pixbuf = imgToPixbuf->ConvertImageToPixbuf(img);
+  if (!pixbuf)
+      return NS_ERROR_NOT_AVAILABLE;
+
+  gboolean res = gdk_pixbuf_save(pixbuf, aPath.get(), "png", NULL, NULL);
+
+  aImage->UnlockImageData();
+  g_object_unref(pixbuf);
+  return res ? NS_OK : NS_ERROR_FAILURE;
+#endif
+}
+                 
+NS_IMETHODIMP
+nsGNOMEShellService::SetDesktopBackground(nsIDOMElement* aElement, 
+                                          PRInt32 aPosition)
+{
+  nsresult rv;
+  nsCOMPtr<gfxIImageFrame> gfxFrame;
+
+  nsCOMPtr<nsIImageLoadingContent> imageContent = do_QueryInterface(aElement, &rv);
+  if (!imageContent) return rv;
+
+  // get the image container
+  nsCOMPtr<imgIRequest> request;
+  rv = imageContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
+                                getter_AddRefs(request));
+  if (!request) return rv;
+  nsCOMPtr<imgIContainer> container;
+  rv = request->GetImage(getter_AddRefs(container));
+  if (!container) return rv;
+
+  // get the current frame, which holds the image data
+  container->GetCurrentFrame(getter_AddRefs(gfxFrame));
+
+  if (!gfxFrame)
+    return NS_ERROR_FAILURE;
+
+  // Write the background file to the home directory.
+  nsCAutoString filePath(PR_GetEnv("HOME"));
+
+  // get the product brand name from localized strings
+  nsString brandName;
+  nsCID bundleCID = NS_STRINGBUNDLESERVICE_CID;
+  nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(bundleCID));
+  if (bundleService) {
+    nsCOMPtr<nsIStringBundle> brandBundle;
+    rv = bundleService->CreateBundle(BRAND_PROPERTIES,
+                                     getter_AddRefs(brandBundle));
+    if (NS_SUCCEEDED(rv) && brandBundle) {
+      rv = brandBundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
+                                          getter_Copies(brandName));
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+  }
+
+  // build the file name
+  filePath.Append('/');
+  filePath.Append(NS_ConvertUTF16toUTF8(brandName));
+  filePath.Append("_wallpaper.png");
+
+  // write the image to a file in the home dir
+  rv = WriteImage(filePath, gfxFrame);
+
+  // if the file was written successfully, set it as the system wallpaper
+  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+
+  nsCAutoString options;
+  if (aPosition == BACKGROUND_TILE)
+    options.Assign("wallpaper");
+  else if (aPosition == BACKGROUND_STRETCH)
+    options.Assign("stretched");
+  else
+    options.Assign("centered");
+
+  gconf->SetString(NS_LITERAL_CSTRING(kDesktopOptionsKey), options);
+
+  // Set the image to an empty string first to force a refresh
+  // (since we could be writing a new image on top of an existing
+  // Firefox_wallpaper.png and nautilus doesn't monitor the file for changes)
+  gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey),
+                   EmptyCString());
+
+  gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey), filePath);
+  gconf->SetBool(NS_LITERAL_CSTRING(kDesktopDrawBGKey), PR_TRUE);
+
+  return rv;
+}
+
+// In: pointer to two characters CC
+// Out: parsed color number
+static PRUint8
+HexToNum(char ch)
+{
+  if ('0' <= ch && '9' >= ch)
+    return ch - '0';
+
+  if ('A' <= ch && 'F' >= ch)
+    return ch - 'A';
+
+  if ('a' <= ch && 'f' >= ch)
+    return ch - 'a';
+
+  return 0;
+}
+  
+
+// In: 3 or 6-character RRGGBB hex string
+// Out: component colors
+static PRBool
+HexToRGB(const nsCString& aColorSpec,
+         PRUint8 &aRed,
+         PRUint8 &aGreen,
+         PRUint8 &aBlue)
+{
+  const char *buf = aColorSpec.get();
+
+  if (aColorSpec.Length() == 6) {
+    aRed =    HexToNum(buf[0]) >> 4 |
+              HexToNum(buf[1]);
+    aGreen =  HexToNum(buf[2]) >> 4 |
+              HexToNum(buf[3]);
+    aBlue =   HexToNum(buf[4]) >> 4 |
+              HexToNum(buf[5]);
+    return PR_TRUE;
+  }
+
+  if (aColorSpec.Length() == 3) {
+    aRed = HexToNum(buf[0]);
+    aGreen = HexToNum(buf[1]);
+    aBlue = HexToNum(buf[2]);
+
+    aRed |= aRed >> 4;
+    aGreen |= aGreen >> 4;
+    aBlue |= aBlue >> 4;
+
+    return PR_TRUE;
+  }
+
+  return PR_FALSE;
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::GetDesktopBackgroundColor(PRUint32 *aColor)
+{
+  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+
+  nsCAutoString background;
+  gconf->GetString(NS_LITERAL_CSTRING(kDesktopColorKey), background);
+
+  if (background.IsEmpty()) {
+    *aColor = 0;
+    return NS_OK;
+  }
+
+  // Chop off the leading '#' character
+  background.Cut(0, 1);
+
+  PRUint8 red, green, blue;
+  if (!HexToRGB(background, red, green, blue))
+      return NS_ERROR_FAILURE;
+
+  // The result must be in RGB order with the high 8 bits zero.
+  *aColor = (red << 16 | green << 8  | blue);
+  return NS_OK;
+}
+
+static void
+ColorToHex(PRUint32 aColor, nsCString& aResult)
+{
+//   char *buf = aResult.BeginWriting(7);
+//   if (!buf)
+//     return;
+// 
+//   PRUint8 red = (aColor >> 16);
+//   PRUint8 green = (aColor >> 8) & 0xff;
+//   PRUint8 blue = aColor & 0xff;
+// 
+//   PR_snprintf(buf, 8, "#%02x%02x%02x", red, green, blue);
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::SetDesktopBackgroundColor(PRUint32 aColor)
+{
+  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+
+  nsCString colorString;
+  ColorToHex(aColor, colorString);
+
+  gconf->SetString(NS_LITERAL_CSTRING(kDesktopColorKey), colorString);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::OpenApplication(PRInt32 aApplication)
+{
+  nsCAutoString scheme;
+  if (aApplication == APPLICATION_MAIL)
+    scheme.Assign("mailto");
+  else if (aApplication == APPLICATION_NEWS)
+    scheme.Assign("news");
+  else
+    return NS_ERROR_NOT_AVAILABLE;
+
+  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
+
+  PRBool enabled;
+  nsCAutoString appCommand;
+  gconf->GetAppForProtocol(scheme, &enabled, appCommand);
+
+  if (!enabled)
+    return NS_ERROR_FAILURE;
+
+  // XXX we don't currently handle launching a terminal window.
+  // If the handler requires a terminal, bail.
+  PRBool requiresTerminal;
+  gconf->HandlerRequiresTerminal(scheme, &requiresTerminal);
+  if (requiresTerminal)
+    return NS_ERROR_FAILURE;
+
+  // Perform shell argument expansion
+  int argc;
+  char **argv;
+  if (!g_shell_parse_argv(appCommand.get(), &argc, &argv, NULL))
+    return NS_ERROR_FAILURE;
+
+  char **newArgv = new char*[argc + 1];
+  int newArgc = 0;
+
+  // Run through the list of arguments.  Copy all of them to the new
+  // argv except for %s, which we skip.
+  for (int i = 0; i < argc; ++i) {
+    if (strcmp(argv[i], "%s") != 0)
+      newArgv[newArgc++] = argv[i];
+  }
+
+  newArgv[newArgc] = nsnull;
+
+  gboolean err = g_spawn_async(NULL, newArgv, NULL, G_SPAWN_SEARCH_PATH,
+                               NULL, NULL, NULL, NULL);
+
+  g_strfreev(argv);
+  delete[] newArgv;
+
+  return err ? NS_OK : NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::OpenApplicationWithURI(nsILocalFile* aApplication, const nsACString& aURI)
+{
+  nsresult rv;
+  nsCOMPtr<nsIProcess> process = 
+    do_CreateInstance("@mozilla.org/process/util;1", &rv);
+  if (NS_FAILED(rv))
+    return rv;
+  
+  rv = process->Init(aApplication);
+  if (NS_FAILED(rv))
+    return rv;
+
+  const nsCString spec(aURI);
+  const char* specStr = spec.get();
+  PRUint32 pid;
+  return process->Run(PR_FALSE, &specStr, 1, &pid);
+}
+
+NS_IMETHODIMP
+nsGNOMEShellService::GetDefaultFeedReader(nsILocalFile** _retval)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsGNOMEShellService.h mozilla/toolkit/components/shell/src/nsGNOMEShellService.h
--- mozilla-orig/toolkit/components/shell/src/nsGNOMEShellService.h	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsGNOMEShellService.h	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsgnomeshellservice_h____
+#define nsgnomeshellservice_h____
+
+#include "nsIShellService.h"
+#ifdef MOZILLA_INTERNAL_API
+#include "nsString.h"
+#include "nsXPIDLString.h"
+#include "nsReadableUtils.h"
+#else
+#include "nsStringAPI.h"
+#endif
+
+class nsGNOMEShellService : public nsIShellService
+{
+public:
+  nsGNOMEShellService() : mCheckedThisSession(PR_FALSE) { }
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISHELLSERVICE
+
+  nsresult Init() NS_HIDDEN;
+
+private:
+  ~nsGNOMEShellService() {}
+
+  NS_HIDDEN_(PRBool) KeyMatchesAppName(const char *aKeyValue) const;
+
+  PRPackedBool mCheckedThisSession;
+  PRPackedBool mUseLocaleFilenames;
+  nsCString    mAppPath;
+};
+
+#endif // nsgnomeshellservice_h____
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsMacShellService.cpp mozilla/toolkit/components/shell/src/nsMacShellService.cpp
--- mozilla-orig/toolkit/components/shell/src/nsMacShellService.cpp	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsMacShellService.cpp	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,534 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is Ben Goodger.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <ben@mozilla.org> (Original Author)
+ *   Asaf Romano <mozilla.mano@sent.com>
+ *   Benjamin Smedberg <benjamin@smedbergs.us>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsDirectoryServiceDefs.h"
+#include "nsIDOMElement.h"
+#include "nsIDOMHTMLImageElement.h"
+#include "nsIImageLoadingContent.h"
+#include "nsIDocument.h"
+#include "nsIContent.h"
+#include "nsILocalFileMac.h"
+#include "nsIObserverService.h"
+#include "nsIPrefService.h"
+#include "nsIServiceManager.h"
+#include "nsIStringBundle.h"
+#include "nsIURL.h"
+#include "nsIWebBrowserPersist.h"
+#include "nsMacShellService.h"
+#include "nsNetUtil.h"
+#include "nsShellService.h"
+#include "nsStringAPI.h"
+
+#include <CoreFoundation/CoreFoundation.h>
+#include <Carbon/Carbon.h>
+
+#define NETWORK_PREFPANE NS_LITERAL_CSTRING("/System/Library/PreferencePanes/Network.prefPane")
+#define DESKTOP_PREFPANE NS_LITERAL_CSTRING("/System/Library/PreferencePanes/DesktopScreenEffectsPref.prefPane")
+
+#define SAFARI_BUNDLE_IDENTIFIER NS_LITERAL_CSTRING("com.apple.Safari")
+
+// These Launch Services functions are undocumented. We're using them since they're
+// the only way to set the default opener for URLs / file extensions.
+extern "C" {
+  // Returns the CFURL for application currently set as the default opener for the
+  // given URL scheme. appURL must be released by the caller.
+  extern OSStatus _LSCopyDefaultSchemeHandlerURL(CFStringRef scheme, CFURLRef *appURL);
+  extern OSStatus _LSSetDefaultSchemeHandlerURL(CFStringRef scheme, CFURLRef appURL);
+  extern OSStatus _LSSaveAndRefresh(void);
+  // Callers should pass 0 as both inType and inCreator in order to set the default opener
+  // without modifing those.
+  extern OSStatus _LSSetWeakBindingForType(OSType inType,
+                                           OSType inCreator,
+                                           CFStringRef inExtension,
+                                           LSRolesMask inRoleMask,
+                                           const FSRef* inBindingRef);
+}
+
+NS_IMPL_ISUPPORTS3(nsMacShellService, nsIMacShellService, nsIShellService, nsIWebProgressListener)
+
+NS_IMETHODIMP
+nsMacShellService::IsDefaultBrowser(PRBool aStartupCheck, PRBool* aIsDefaultBrowser)
+{
+  *aIsDefaultBrowser = PR_TRUE;
+
+  // Since neither Launch Services nor Internet Config actually differ between 
+  // bundles which have the same bundle identifier (That is, if we set our
+  // bundle's URL as the default handler, Launch Service might return the
+  // URL of another firefox bundle as the defualt http handler), we are
+  // comparing the bundles' identifiers rather than their URLs.
+
+  CFStringRef firefoxID = ::CFBundleGetIdentifier(CFBundleGetMainBundle());
+  if (!firefoxID) {
+    // CFBundleGetIdentifier is expected to return NULL only if the specified
+    // bundle doesn't have a bundle identifier in its plist. In this case, that
+    // means a failure, since our bundle does have an identifier.
+    return NS_ERROR_FAILURE;
+  }
+
+  ::CFRetain(firefoxID);
+
+  // Get the default http handler URL
+  CFURLRef defaultBrowserURL;
+  OSStatus err = ::_LSCopyDefaultSchemeHandlerURL(CFSTR("http"),
+                                                  &defaultBrowserURL);
+
+  nsresult rv = NS_ERROR_FAILURE;
+  if (err == noErr) {
+    // Get a reference to the bundle (based on its URL)
+    CFBundleRef defaultBrowserBundle = ::CFBundleCreate(NULL, 
+                                                        defaultBrowserURL);
+    if (defaultBrowserBundle) {
+      CFStringRef defaultBrowserID = ::CFBundleGetIdentifier(defaultBrowserBundle);
+      if (defaultBrowserID) {
+        ::CFRetain(defaultBrowserID);
+        // and compare it to our bundle identifier
+        *aIsDefaultBrowser = ::CFStringCompare(firefoxID, defaultBrowserID, 0)
+                             == kCFCompareEqualTo;
+        ::CFRelease(defaultBrowserID);
+      }
+      else {
+        // If the default browser bundle doesn't have an identifier in its plist,
+        // it's not our bundle
+        *aIsDefaultBrowser = PR_FALSE;
+      }
+
+      ::CFRelease(defaultBrowserBundle);
+      rv = NS_OK;
+    }
+
+    ::CFRelease(defaultBrowserURL);
+  }
+
+  // release the idetifiers strings
+  ::CFRelease(firefoxID);
+
+  // If this is the first browser window, maintain internal state that we've
+  // checked this session (so that subsequent window opens don't show the 
+  // default browser dialog).
+  if (aStartupCheck)
+    mCheckedThisSession = PR_TRUE;
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsMacShellService::SetDefaultBrowser(PRBool aClaimAllTypes, PRBool aForAllUsers)
+{
+  // Note: We don't support aForAllUsers on Mac OS X.
+
+  CFURLRef firefoxURL = ::CFBundleCopyBundleURL(CFBundleGetMainBundle());
+
+  ::_LSSetDefaultSchemeHandlerURL(CFSTR("http"), firefoxURL);
+  ::_LSSetDefaultSchemeHandlerURL(CFSTR("https"), firefoxURL);
+
+  if (aClaimAllTypes) {
+    ::_LSSetDefaultSchemeHandlerURL(CFSTR("ftp"), firefoxURL);
+
+    FSRef firefoxFSRef;
+    // CFURLGetFSRef returns true if the conversion was successful 
+    if (::CFURLGetFSRef(firefoxURL, &firefoxFSRef)); {
+      // Set the default opener for html/htm files
+      ::_LSSetWeakBindingForType(0, 0, CFSTR("html"), kLSRolesAll, &firefoxFSRef);
+      ::_LSSetWeakBindingForType(0, 0, CFSTR("htm"), kLSRolesAll, &firefoxFSRef);
+    }
+  }
+  ::_LSSaveAndRefresh();
+
+  ::CFRelease(firefoxURL);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::GetShouldCheckDefaultBrowser(PRBool* aResult)
+{
+  // If we've already checked, the browser has been started and this is a 
+  // new window open, and we don't want to check again.
+  if (mCheckedThisSession) {
+    *aResult = PR_FALSE;
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIPrefBranch> prefs;
+  nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
+  if (pserve)
+    pserve->GetBranch("", getter_AddRefs(prefs));
+
+  prefs->GetBoolPref(PREF_CHECKDEFAULTBROWSER, aResult);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::SetShouldCheckDefaultBrowser(PRBool aShouldCheck)
+{
+  nsCOMPtr<nsIPrefBranch> prefs;
+  nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
+  if (pserve)
+    pserve->GetBranch("", getter_AddRefs(prefs));
+
+  prefs->SetBoolPref(PREF_CHECKDEFAULTBROWSER, aShouldCheck);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::SetDesktopBackground(nsIDOMElement* aElement, 
+                                        PRInt32 aPosition)
+{
+  // Note: We don't support aPosition on OS X.
+
+  // Get the image URI:
+  nsresult rv;
+  nsCOMPtr<nsIImageLoadingContent> imageContent = do_QueryInterface(aElement,
+                                                                    &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIURI> imageURI;
+  rv = imageContent->GetCurrentURI(getter_AddRefs(imageURI));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // We need the referer URI for nsIWebBrowserPersist::saveURI
+  nsCOMPtr<nsIContent> content = do_QueryInterface(aElement, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIDocument> doc;
+  doc = content->GetOwnerDoc();
+  if (!doc)
+    return NS_ERROR_FAILURE;
+
+  nsIURI *docURI = doc->GetDocumentURI();
+  if (!docURI)
+    return NS_ERROR_FAILURE;
+
+  // Get the desired image file name
+  nsCOMPtr<nsIURL> imageURL(do_QueryInterface(imageURI));
+  if (!imageURL) {
+    // XXXmano (bug 300293): Non-URL images (e.g. the data: protocol) are not
+    // yet supported. What filename should we take here?
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  nsCAutoString fileName;
+  imageURL->GetFileName(fileName);
+  nsCOMPtr<nsIProperties> fileLocator
+    (do_GetService("@mozilla.org/file/directory_service;1", &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Get the current user's "Pictures" folder (That's ~/Pictures):
+  fileLocator->Get(NS_OSX_PICTURE_DOCUMENTS_DIR, NS_GET_IID(nsILocalFile),
+                   getter_AddRefs(mBackgroundFile));
+  if (!mBackgroundFile)
+    return NS_ERROR_OUT_OF_MEMORY;
+
+  nsAutoString fileNameUnicode;
+  CopyUTF8toUTF16(fileName, fileNameUnicode);
+
+  // and add the imgage file name itself:
+  mBackgroundFile->Append(fileNameUnicode);
+
+  // Download the image; the desktop background will be set in OnStateChange()
+  nsCOMPtr<nsIWebBrowserPersist> wbp
+    (do_CreateInstance("@mozilla.org/embedding/browser/nsWebBrowserPersist;1", &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRUint32 flags = nsIWebBrowserPersist::PERSIST_FLAGS_NO_CONVERSION | 
+                   nsIWebBrowserPersist::PERSIST_FLAGS_REPLACE_EXISTING_FILES |
+                   nsIWebBrowserPersist::PERSIST_FLAGS_FROM_CACHE;
+
+  wbp->SetPersistFlags(flags);
+  wbp->SetProgressListener(this);
+
+  return wbp->SaveURI(imageURI, nsnull, docURI, nsnull, nsnull,
+                      mBackgroundFile);
+}
+
+NS_IMETHODIMP
+nsMacShellService::OnProgressChange(nsIWebProgress* aWebProgress,
+                                    nsIRequest* aRequest,
+                                    PRInt32 aCurSelfProgress,
+                                    PRInt32 aMaxSelfProgress,
+                                    PRInt32 aCurTotalProgress,
+                                    PRInt32 aMaxTotalProgress)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::OnLocationChange(nsIWebProgress* aWebProgress,
+                                    nsIRequest* aRequest,
+                                    nsIURI* aLocation)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::OnStatusChange(nsIWebProgress* aWebProgress,
+                                  nsIRequest* aRequest,
+                                  nsresult aStatus,
+                                  const PRUnichar* aMessage)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::OnSecurityChange(nsIWebProgress* aWebProgress,
+                                    nsIRequest* aRequest,
+                                    PRUint32 aState)
+{
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::OnStateChange(nsIWebProgress* aWebProgress,
+                                 nsIRequest* aRequest,
+                                 PRUint32 aStateFlags,
+                                 nsresult aStatus)
+{
+  if (aStateFlags & STATE_STOP) {
+    nsCOMPtr<nsIObserverService> os(do_GetService("@mozilla.org/observer-service;1"));
+    if (os)
+      os->NotifyObservers(nsnull, "shell:desktop-background-changed", nsnull);
+
+    PRBool exists = PR_FALSE;
+    mBackgroundFile->Exists(&exists);
+    if (!exists)
+      return NS_OK;
+
+    nsCAutoString nativePath;
+    mBackgroundFile->GetNativePath(nativePath);
+
+    AEDesc tAEDesc = { typeNull, nil };
+    OSErr err = noErr;
+    AliasHandle aliasHandle = nil;
+    FSRef pictureRef;
+    OSStatus status;
+
+    // Convert the path into a FSRef
+    status = ::FSPathMakeRef((const UInt8*)nativePath.get(), &pictureRef, NULL);
+    if (status == noErr) {
+      err = ::FSNewAlias(nil, &pictureRef, &aliasHandle);
+      if (err == noErr && aliasHandle == nil)
+        err = paramErr;
+
+      if (err == noErr) {
+        // We need the descriptor (based on the picture file reference)
+        // for the 'Set Desktop Picture' apple event.
+        char handleState = ::HGetState((Handle)aliasHandle);
+        ::HLock((Handle)aliasHandle);
+        err = ::AECreateDesc(typeAlias, *aliasHandle,
+                             GetHandleSize((Handle)aliasHandle), &tAEDesc);
+        // unlock the alias handler
+        ::HSetState((Handle)aliasHandle, handleState);
+        ::DisposeHandle((Handle)aliasHandle);
+      }
+      if (err == noErr) {
+        AppleEvent tAppleEvent;
+        OSType sig = 'MACS';
+        AEBuildError tAEBuildError;
+        // Create a 'Set Desktop Pictue' Apple Event
+        err = ::AEBuildAppleEvent(kAECoreSuite, kAESetData, typeApplSignature,
+                                  &sig, sizeof(OSType), kAutoGenerateReturnID,
+                                  kAnyTransactionID, &tAppleEvent, &tAEBuildError,
+                                  "'----':'obj '{want:type (prop),form:prop" \
+                                  ",seld:type('dpic'),from:'null'()},data:(@)",
+                                  &tAEDesc);
+        if (err == noErr) {
+          AppleEvent reply = { typeNull, nil };
+          // Sent the event we built, the reply event isn't necessary
+          err = ::AESend(&tAppleEvent, &reply, kAENoReply, kAENormalPriority,
+                         kNoTimeOut, nil, nil);
+          ::AEDisposeDesc(&tAppleEvent);
+        }
+      }
+    }
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::OpenApplication(PRInt32 aApplication)
+{
+  nsresult rv = NS_OK;
+  CFURLRef appURL = nil;
+  OSStatus err = noErr;
+
+  switch (aApplication) {
+  case nsIShellService::APPLICATION_MAIL:
+    {
+      CFURLRef tempURL = ::CFURLCreateWithString(kCFAllocatorDefault,
+                                                 CFSTR("mailto:"), NULL);
+      err = ::LSGetApplicationForURL(tempURL, kLSRolesAll, NULL, &appURL);
+      ::CFRelease(tempURL);
+    }
+    break;
+  case nsIShellService::APPLICATION_NEWS:
+    {
+      CFURLRef tempURL = ::CFURLCreateWithString(kCFAllocatorDefault,
+                                                 CFSTR("news:"), NULL);
+      err = ::LSGetApplicationForURL(tempURL, kLSRolesAll, NULL, &appURL);
+      ::CFRelease(tempURL);
+    }
+    break;
+  case nsIMacShellService::APPLICATION_KEYCHAIN_ACCESS:
+    err = ::LSGetApplicationForInfo('APPL', 'kcmr', NULL, kLSRolesAll, NULL,
+                                    &appURL);
+    break;
+  case nsIMacShellService::APPLICATION_NETWORK:
+    {
+      nsCOMPtr<nsILocalFile> lf;
+      rv = NS_NewNativeLocalFile(NETWORK_PREFPANE, PR_TRUE, getter_AddRefs(lf));
+      NS_ENSURE_SUCCESS(rv, rv);
+      PRBool exists;
+      lf->Exists(&exists);
+      if (!exists)
+        return NS_ERROR_FILE_NOT_FOUND;
+      return lf->Launch();
+    }  
+    break;
+  case nsIMacShellService::APPLICATION_DESKTOP:
+    {
+      nsCOMPtr<nsILocalFile> lf;
+      rv = NS_NewNativeLocalFile(DESKTOP_PREFPANE, PR_TRUE, getter_AddRefs(lf));
+      NS_ENSURE_SUCCESS(rv, rv);
+      PRBool exists;
+      lf->Exists(&exists);
+      if (!exists)
+        return NS_ERROR_FILE_NOT_FOUND;
+      return lf->Launch();
+    }  
+    break;
+  }
+
+  if (appURL && err == noErr) {
+    err = ::LSOpenCFURLRef(appURL, NULL);
+    rv = err != noErr ? NS_ERROR_FAILURE : NS_OK;
+
+    ::CFRelease(appURL);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsMacShellService::GetDesktopBackgroundColor(PRUint32 *aColor)
+{
+  // This method and |SetDesktopBackgroundColor| has no meaning on Mac OS X.
+  // The mac desktop preferences UI uses pictures for the few solid colors it
+  // supports.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMacShellService::SetDesktopBackgroundColor(PRUint32 aColor)
+{
+  // This method and |GetDesktopBackgroundColor| has no meaning on Mac OS X.
+  // The mac desktop preferences UI uses pictures for the few solid colors it
+  // supports.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMacShellService::OpenApplicationWithURI(nsILocalFile* aApplication, const nsACString& aURI)
+{
+  nsCOMPtr<nsILocalFileMac> lfm(do_QueryInterface(aApplication));
+  CFURLRef appURL;
+  nsresult rv = lfm->GetCFURL(&appURL);
+  if (NS_FAILED(rv))
+    return rv;
+  
+  const nsCString spec(aURI);
+  const UInt8* uriString = (const UInt8*)spec.get();
+  CFURLRef uri = ::CFURLCreateWithBytes(NULL, uriString, aURI.Length(),
+                                        kCFStringEncodingUTF8, NULL);
+  if (!uri) 
+    return NS_ERROR_OUT_OF_MEMORY;
+  
+  CFArrayRef uris = ::CFArrayCreate(NULL, (const void**)&uri, 1, NULL);
+  if (!uris) {
+    ::CFRelease(uri);
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+  
+  LSLaunchURLSpec launchSpec;
+  launchSpec.appURL = appURL;
+  launchSpec.itemURLs = uris;
+  launchSpec.passThruParams = NULL;
+  launchSpec.launchFlags = kLSLaunchDefaults;
+  launchSpec.asyncRefCon = NULL;
+  
+  OSErr err = ::LSOpenFromURLSpec(&launchSpec, NULL);
+  
+  ::CFRelease(uris);
+  ::CFRelease(uri);
+  
+  return err != noErr ? NS_ERROR_FAILURE : NS_OK;
+}
+
+NS_IMETHODIMP
+nsMacShellService::GetDefaultFeedReader(nsILocalFile** _retval)
+{
+  nsresult rv = NS_ERROR_FAILURE;
+  *_retval = nsnull;
+
+  CFURLRef defaultHandlerURL;
+  OSStatus err = ::_LSCopyDefaultSchemeHandlerURL(CFSTR("feed"),
+                                                  &defaultHandlerURL);
+  if (defaultHandlerURL) {
+    nsCOMPtr<nsILocalFileMac> defaultReader =
+      do_CreateInstance("@mozilla.org/file/local;1", &rv);
+    if (NS_SUCCEEDED(rv)) {
+      rv = defaultReader->InitWithCFURL(defaultHandlerURL);
+      if (NS_SUCCEEDED(rv)) {
+        // ASSERT("Safari Is Not a Feed Reader");
+        nsCAutoString bundleIdentifier;
+
+        // don't throw if the bundle has no identifier
+        rv = NS_ERROR_FAILURE;
+        if (NS_FAILED(defaultReader->GetBundleIdentifier(bundleIdentifier)) ||
+            !bundleIdentifier.Equals(SAFARI_BUNDLE_IDENTIFIER)) {
+          NS_ADDREF(*_retval = defaultReader);
+          rv = NS_OK;
+        }
+      }
+    }
+
+    ::CFRelease(defaultHandlerURL);
+  }
+
+  return rv;
+}
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsMacShellService.h mozilla/toolkit/components/shell/src/nsMacShellService.h
--- mozilla-orig/toolkit/components/shell/src/nsMacShellService.h	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsMacShellService.h	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ben Goodger    <ben@mozilla.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsmacshellservice_h____
+#define nsmacshellservice_h____
+
+#include "nsIMacShellService.h"
+#include "nsIWebProgressListener.h"
+#include "nsILocalFile.h"
+#include "nsCOMPtr.h"
+
+class nsMacShellService : public nsIMacShellService,
+                          public nsIWebProgressListener
+{
+public:
+  nsMacShellService() : mCheckedThisSession(PR_FALSE) {};
+  virtual ~nsMacShellService() {};
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISHELLSERVICE
+  NS_DECL_NSIMACSHELLSERVICE
+  NS_DECL_NSIWEBPROGRESSLISTENER
+
+protected:
+
+private:
+  nsCOMPtr<nsILocalFile> mBackgroundFile;
+
+  PRBool    mCheckedThisSession;
+};
+
+#endif // nsmacshellservice_h____
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsSetDefaultBrowser.js mozilla/toolkit/components/shell/src/nsSetDefaultBrowser.js
--- mozilla-orig/toolkit/components/shell/src/nsSetDefaultBrowser.js	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsSetDefaultBrowser.js	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,141 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Default Browser.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corp.
+ * Portions created by the Initial Developer are Copyright (C) 2002
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Bill Law  <law@netscape.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* This file implements the nsICommandLineHandler interface.
+ *
+ * This component handles the startup command line argument of the form:
+ *   -setDefaultBrowser
+ * by making the current executable the "default browser."
+ */
+
+function nsSetDefaultBrowser() {
+}
+
+nsSetDefaultBrowser.prototype = {
+  /* nsISupports */
+  QueryInterface: function nsSetDefault_QI(iid) {
+    if (!iid.equals(Components.interfaces.nsICommandLineHandler) &&
+        !iid.equals(Components.interfaces.nsISupports))
+      throw Components.results.NS_ERROR_NO_INTERFACE;
+
+    return this;
+  },
+
+  /* nsICommandLineHandler */
+  handle : function nsSetDefault_handle(cmdline) {
+    if (cmdline.handleFlag("setDefaultBrowser", false)) {
+      var shell = Components.classes["@mozilla.org/browser/shell-service;1"]
+                            .getService(Components.interfaces.nsIShellService);
+      shell.setDefaultBrowser(true, true);
+    }
+  },
+
+  helpInfo : "  -setDefaultBrowser   Set this app as the default browser.\n"
+}
+
+// This Component's module and factory implementation.
+
+const contractID = "@mozilla.org/browser/default-browser-clh;1";
+const CID = Components.ID("{F57899D0-4E2C-4ac6-9E29-50C736103B0C}");
+
+var ModuleAndFactory = {
+  /* nsISupports */
+  QueryInterface: function nsSetDefault_QI(iid) {
+    if (!iid.equals(Components.interfaces.nsIModule) &&
+        !iid.equals(Components.interfaces.nsIFactory) &&
+        !iid.equals(Components.interfaces.nsISupports))
+      throw Components.results.NS_ERROR_NO_INTERFACE;
+
+    return this;
+  },
+
+  /* nsIModule */
+  getClassObject: function (compMgr, cid, iid) {
+    if (!cid.equals(CID))
+      throw Components.results.NS_ERROR_NO_INTERFACE;
+    
+    return this.QueryInterface(iid);
+  },
+    
+  registerSelf: function mod_regself(compMgr, fileSpec, location, type) {
+    var compReg =
+      compMgr.QueryInterface( Components.interfaces.nsIComponentRegistrar );
+
+    compReg.registerFactoryLocation( CID,
+                                     "Default Browser Cmdline Handler",
+                                     contractID,
+                                     fileSpec,
+                                     location,
+                                     type );
+
+    var catMan = Components.classes["@mozilla.org/categorymanager;1"]
+                           .getService(Components.interfaces.nsICategoryManager);
+
+    catMan.addCategoryEntry("command-line-handler",
+                            "m-setdefaultbrowser",
+                            contractID, true, true);
+  },
+    
+  unregisterSelf : function mod_unregself(compMgr, location, type) {
+    var catMan = Components.classes["@mozilla.org/categorymanager;1"]
+                           .getService(Components.interfaces.nsICategoryManager);
+
+    catMan.deleteCategoryEntry("command-line-handler",
+                               "m-setdefaultbrowser", true);
+  },
+
+  canUnload: function(compMgr) {
+    return true;
+  },
+
+  /* nsIFactory */
+  createInstance: function mod_CI(outer, iid) {
+    if (outer != null)
+      throw Components.results.NS_ERROR_NO_AGGREGATION;
+  
+    return new nsSetDefaultBrowser().QueryInterface(iid);
+  },
+    
+  lockFactory : function mod_lock(lock) {
+    /* no-op */
+  }
+}
+
+// NSGetModule: Return the nsIModule object.
+function NSGetModule(compMgr, fileSpec) {
+  return ModuleAndFactory;
+}
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsShellService.h mozilla/toolkit/components/shell/src/nsShellService.h
--- mozilla-orig/toolkit/components/shell/src/nsShellService.h	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsShellService.h	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#define PREF_CHECKDEFAULTBROWSER "browser.shell.checkDefaultBrowser"
+
+#define SHELLSERVICE_PROPERTIES "chrome://browser/locale/shellservice.properties"
+#define BRAND_PROPERTIES "chrome://branding/locale/brand.properties"
+
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsWindowsShellService.cpp mozilla/toolkit/components/shell/src/nsWindowsShellService.cpp
--- mozilla-orig/toolkit/components/shell/src/nsWindowsShellService.cpp	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsWindowsShellService.cpp	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,1236 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ben Goodger    <ben@mozilla.org>       (Clients, Mail, New Default Browser)
+ *  Joe Hewitt     <hewitt@netscape.com>   (Set Background)
+ *  Blake Ross     <blake@cs.stanford.edu  (Desktop Color, DDE support)
+ *  Jungshik Shin  <jshin@mailaps.org>     (I18N)
+ *  Robert Strong  <robert.bugzilla@gmail.com>  (Long paths, DDE)
+ *  Asaf Romano    <mano@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "gfxIImageFrame.h"
+#include "imgIContainer.h"
+#include "imgIRequest.h"
+#include "nsIDOMDocument.h"
+#include "nsIDOMElement.h"
+#include "nsIDOMHTMLImageElement.h"
+#include "nsIImageLoadingContent.h"
+#include "nsIPrefService.h"
+#include "nsIPrefLocalizedString.h"
+#include "nsIServiceManager.h"
+#include "nsIStringBundle.h"
+#include "nsNetUtil.h"
+#include "nsShellService.h"
+#include "nsWindowsShellService.h"
+#include "nsIProcess.h"
+#include "nsICategoryManager.h"
+#include "nsBrowserCompsCID.h"
+#include "nsDirectoryServiceUtils.h"
+#include "nsAppDirectoryServiceDefs.h"
+#include "shlobj.h"
+#include "nsIWindowsRegKey.h"
+
+#include "windows.h"
+#include "shellapi.h"
+
+#include <mbstring.h>
+
+#ifndef MAX_BUF
+#define MAX_BUF 4096
+#endif
+
+#define REG_SUCCEEDED(val) \
+  (val == ERROR_SUCCESS)
+
+#define REG_FAILED(val) \
+  (val != ERROR_SUCCESS)
+
+NS_IMPL_ISUPPORTS2(nsWindowsShellService, nsIWindowsShellService, nsIShellService)
+
+static nsresult
+OpenUserKeyForReading(HKEY aStartKey, const char* aKeyName, HKEY* aKey)
+{
+  DWORD result = ::RegOpenKeyEx(aStartKey, aKeyName, 0, KEY_READ, aKey);
+
+  switch (result) {
+  case ERROR_SUCCESS:
+    break;
+  case ERROR_ACCESS_DENIED:
+    return NS_ERROR_FILE_ACCESS_DENIED;
+  case ERROR_FILE_NOT_FOUND:
+    if (aStartKey == HKEY_LOCAL_MACHINE) {
+      // prevent infinite recursion on the second pass through here if 
+      // ::RegOpenKeyEx fails in the all-users case. 
+      return NS_ERROR_NOT_AVAILABLE;
+    }
+    return OpenUserKeyForReading(HKEY_LOCAL_MACHINE, aKeyName, aKey);
+  }
+  return NS_OK;
+}
+
+// Sets the default browser registry keys for Windows versions prior to Vista.
+// Try to open / create the key in HKLM and if that fails try to do the same
+// in HKCU. Though this is not strictly the behavior I would expect it is the
+// same behavior that IE has when setting the default browser previous to Vista.
+static nsresult
+OpenKeyForWriting(HKEY aStartKey, const char* aKeyName, HKEY* aKey,
+                  PRBool aHKLMOnly)
+{
+  DWORD dwDisp = 0;
+  DWORD rv = ::RegCreateKeyEx(aStartKey, aKeyName, 0, NULL, 0,
+                              KEY_READ | KEY_WRITE, NULL, aKey, &dwDisp);
+
+  switch (rv) {
+  case ERROR_SUCCESS:
+    break;
+  case ERROR_ACCESS_DENIED:
+    if (aHKLMOnly || aStartKey == HKEY_CURRENT_USER)
+      return NS_ERROR_FILE_ACCESS_DENIED;
+    // fallback to HKCU immediately on access denied since we won't be able
+    // to create the key.
+    return OpenKeyForWriting(HKEY_CURRENT_USER, aKeyName, aKey, aHKLMOnly);
+  case ERROR_FILE_NOT_FOUND:
+    rv = ::RegCreateKey(aStartKey, aKeyName, aKey);
+    if (rv != ERROR_SUCCESS) {
+      if (aHKLMOnly || aStartKey == HKEY_CURRENT_USER) {
+        // prevent infinite recursion on the second pass through here if 
+        // ::RegCreateKey fails in the current user case.
+        return NS_ERROR_FILE_ACCESS_DENIED;
+      }
+      return OpenKeyForWriting(HKEY_CURRENT_USER, aKeyName, aKey, aHKLMOnly);
+    }
+  }
+
+  return NS_OK;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// Default Browser Registry Settings
+//
+// - File Extension Mappings
+//   -----------------------
+//   The following file extensions:
+//    .htm .html .shtml .xht .xhtml 
+//   are mapped like so:
+//
+//   HKCU\SOFTWARE\Classes\.<ext>\      (default)         REG_SZ     FirefoxHTML
+//
+//   as aliases to the class:
+//
+//   HKCU\SOFTWARE\Classes\FirefoxHTML\
+//     DefaultIcon                      (default)         REG_SZ     <apppath>,1
+//     shell\open\command               (default)         REG_SZ     <apppath> -url "%1" -requestPending
+//     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
+//     shell\open\ddeexec               NoActivateHandler REG_SZ
+//                       \Application   (default)         REG_SZ     Firefox
+//                       \Topic         (default)         REG_SZ     WWW_OpenURL
+//
+// - Windows Vista Protocol Handler
+//
+//   HKCU\SOFTWARE\Classes\FirefoxURL\  (default)         REG_SZ     <appname> URL
+//                                      EditFlags         REG_DWORD  2
+//                                      FriendlyTypeName  REG_SZ     <appname> URL
+//     DefaultIcon                      (default)         REG_SZ     <apppath>,1
+//     shell\open\command               (default)         REG_SZ     <apppath> -url "%1" -requestPending
+//     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
+//     shell\open\ddeexec               NoActivateHandler REG_SZ
+//                       \Application   (default)         REG_SZ     Firefox
+//                       \Topic         (default)         REG_SZ     WWW_OpenURL
+//
+// - Protocol Mappings
+//   -----------------
+//   The following protocols:
+//    HTTP, HTTPS, FTP, GOPHER
+//   are mapped like so:
+//
+//   HKCU\SOFTWARE\Classes\<protocol>\
+//     DefaultIcon                      (default)         REG_SZ     <apppath>,1
+//     shell\open\command               (default)         REG_SZ     <apppath> -url "%1" -requestPending
+//     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
+//     shell\open\ddeexec               NoActivateHandler REG_SZ
+//                       \Application   (default)         REG_SZ     Firefox
+//                       \Topic         (default)         REG_SZ     WWW_OpenURL
+//
+// - Windows Start Menu (Win2K SP2, XP SP1, and newer)
+//   -------------------------------------------------
+//   The following keys are set to make Firefox appear in the Start Menu as the
+//   browser:
+//   
+//   HKCU\SOFTWARE\Clients\StartMenuInternet\FIREFOX.EXE\
+//                                      (default)         REG_SZ     <appname>
+//     DefaultIcon                      (default)         REG_SZ     <apppath>,0
+//     InstallInfo                      HideIconsCommand  REG_SZ     <uninstpath> /HideShortcuts
+//     InstallInfo                      IconsVisible      REG_DWORD  1
+//     InstallInfo                      ReinstallCommand  REG_SZ     <uninstpath> /SetAsDefaultAppGlobal
+//     InstallInfo                      ShowIconsCommand  REG_SZ     <uninstpath> /ShowShortcuts
+//     shell\open\command               (default)         REG_SZ     <apppath>
+//     shell\properties                 (default)         REG_SZ     <appname> &Options
+//     shell\properties\command         (default)         REG_SZ     <apppath> -preferences
+//     shell\safemode                   (default)         REG_SZ     <appname> &Safe Mode
+//     shell\safemode\command           (default)         REG_SZ     <apppath> -safe-mode
+//
+
+typedef enum { NO_SUBSTITUTION           = 0x00,
+               APP_PATH_SUBSTITUTION     = 0x01,
+               EXE_NAME_SUBSTITUTION     = 0x02,
+               UNINST_PATH_SUBSTITUTION  = 0x04,
+               HKLM_ONLY                 = 0x08,
+               NON_ESSENTIAL             = 0x10 } SettingFlags;
+typedef struct {
+  char* keyName;
+  char* valueName;
+  char* valueData;
+
+  PRInt32 flags;
+} SETTING;
+
+#define APP_REG_NAME L"Firefox"
+#define SMI "SOFTWARE\\Clients\\StartMenuInternet\\"
+#define CLS "SOFTWARE\\Classes\\"
+#define DI "\\DefaultIcon"
+#define II "\\InstallInfo"
+#define SOP "\\shell\\open\\command"
+#define DDE "\\shell\\open\\ddeexec\\"
+#define DDE_NAME "Firefox" // This must be kept in sync with ID_DDE_APPLICATION_NAME as defined in splash.rc
+#define DDE_COMMAND "\"%1\",,0,0,,,,"
+// For the InstallInfo HideIconsCommand, ShowIconsCommand, and ReinstallCommand
+// registry keys. This must be kept in sync with the uninstaller.
+#define UNINSTALL_EXE "\\uninstall\\helper.exe"
+
+#define CLS_HTML "FirefoxHTML"
+#define CLS_URL "FirefoxURL"
+#define VAL_FILE_ICON "%APPPATH%,1"
+#define VAL_OPEN "\"%APPPATH%\" -url \"%1\" -requestPending"
+
+#define MAKE_KEY_NAME1(PREFIX, MID) \
+  PREFIX MID
+
+#define MAKE_KEY_NAME2(PREFIX, MID, SUFFIX) \
+  PREFIX MID SUFFIX
+
+#define MAKE_KEY_NAME3(PREFIX, MID, MID2, SUFFIX) \
+  PREFIX MID MID2 SUFFIX
+
+// The DefaultIcon registry key value should never be used (e.g. NON_ESSENTIAL)
+// when checking if Firefox is the default browser since other applications
+// (e.g. MS Office) may modify the DefaultIcon registry key value to add Icon
+// Handlers.
+// see http://msdn2.microsoft.com/en-us/library/aa969357.aspx for more info.
+static SETTING gSettings[] = {
+  // File Extension Aliases
+  { MAKE_KEY_NAME1(CLS, ".htm"),    "", CLS_HTML, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME1(CLS, ".html"),   "", CLS_HTML, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME1(CLS, ".shtml"),  "", CLS_HTML, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME1(CLS, ".xht"),    "", CLS_HTML, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME1(CLS, ".xhtml"),  "", CLS_HTML, NO_SUBSTITUTION | NON_ESSENTIAL },
+
+  // File Extension Class - as of 1.8.1.2 the value for VAL_OPEN is also checked
+  // for CLS_HTML since Firefox should also own opeing local files when set as
+  // the default browser.
+  { MAKE_KEY_NAME2(CLS, CLS_HTML, DI),  "", VAL_FILE_ICON, APP_PATH_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, CLS_HTML, SOP), "", VAL_OPEN, APP_PATH_SUBSTITUTION },
+
+  // Protocol Handler Class - for Vista and above
+  { MAKE_KEY_NAME2(CLS, CLS_URL, DI),  "", VAL_FILE_ICON, APP_PATH_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, CLS_URL, SOP), "", VAL_OPEN, APP_PATH_SUBSTITUTION },
+
+  // Protocol Handlers
+  { MAKE_KEY_NAME2(CLS, "HTTP", DI),    "", VAL_FILE_ICON, APP_PATH_SUBSTITUTION },
+  { MAKE_KEY_NAME2(CLS, "HTTP", SOP),   "", VAL_OPEN, APP_PATH_SUBSTITUTION },
+  { MAKE_KEY_NAME2(CLS, "HTTPS", DI),   "", VAL_FILE_ICON, APP_PATH_SUBSTITUTION },
+  { MAKE_KEY_NAME2(CLS, "HTTPS", SOP),  "", VAL_OPEN, APP_PATH_SUBSTITUTION },
+  { MAKE_KEY_NAME2(CLS, "FTP", DI),     "", VAL_FILE_ICON, APP_PATH_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, "FTP", SOP),    "", VAL_OPEN, APP_PATH_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, "GOPHER", DI),  "", VAL_FILE_ICON, APP_PATH_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, "GOPHER", SOP), "", VAL_OPEN, APP_PATH_SUBSTITUTION | NON_ESSENTIAL },
+
+  // DDE settings
+  { MAKE_KEY_NAME2(CLS, CLS_HTML, DDE), "", DDE_COMMAND, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, CLS_HTML, DDE, "Application"), "", DDE_NAME, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, CLS_HTML, DDE, "Topic"), "", "WWW_OpenURL", NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, CLS_URL, DDE), "", DDE_COMMAND, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, CLS_URL, DDE, "Application"), "", DDE_NAME, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, CLS_URL, DDE, "Topic"), "", "WWW_OpenURL", NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, "HTTP", DDE), "", DDE_COMMAND, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "HTTP", DDE, "Application"), "", DDE_NAME, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "HTTP", DDE, "Topic"), "", "WWW_OpenURL", NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, "HTTPS", DDE), "", DDE_COMMAND, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "HTTPS", DDE, "Application"), "", DDE_NAME, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "HTTPS", DDE, "Topic"), "", "WWW_OpenURL", NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, "FTP", DDE), "", DDE_COMMAND, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "FTP", DDE, "Application"), "", DDE_NAME, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "FTP", DDE, "Topic"), "", "WWW_OpenURL", NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(CLS, "GOPHER", DDE), "", DDE_COMMAND, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "GOPHER", DDE, "Application"), "", DDE_NAME, NO_SUBSTITUTION | NON_ESSENTIAL },
+  { MAKE_KEY_NAME3(CLS, "GOPHER", DDE, "Topic"), "", "WWW_OpenURL", NO_SUBSTITUTION | NON_ESSENTIAL },
+
+  // Windows XP Start Menu
+  { MAKE_KEY_NAME2(SMI, "%APPEXE%", DI),  
+    "", 
+    "%APPPATH%,0", 
+    APP_PATH_SUBSTITUTION | EXE_NAME_SUBSTITUTION | HKLM_ONLY | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(SMI, "%APPEXE%", II),
+    "HideIconsCommand",
+    "\"%UNINSTPATH%\" /HideShortcuts",
+    UNINST_PATH_SUBSTITUTION | EXE_NAME_SUBSTITUTION | HKLM_ONLY | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(SMI, "%APPEXE%", II),
+    "ReinstallCommand",
+    "\"%UNINSTPATH%\" /SetAsDefaultAppGlobal",
+    UNINST_PATH_SUBSTITUTION | EXE_NAME_SUBSTITUTION | HKLM_ONLY | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(SMI, "%APPEXE%", II),
+    "ShowIconsCommand",
+    "\"%UNINSTPATH%\" /ShowShortcuts",
+    UNINST_PATH_SUBSTITUTION | EXE_NAME_SUBSTITUTION | HKLM_ONLY | NON_ESSENTIAL },
+  { MAKE_KEY_NAME2(SMI, "%APPEXE%", SOP), 
+    "", 
+    "%APPPATH%",   
+    APP_PATH_SUBSTITUTION | EXE_NAME_SUBSTITUTION | HKLM_ONLY | NON_ESSENTIAL },
+  { MAKE_KEY_NAME1(SMI, "%APPEXE%\\shell\\properties\\command"),
+    "", 
+    "\"%APPPATH%\" -preferences",
+    APP_PATH_SUBSTITUTION | EXE_NAME_SUBSTITUTION | HKLM_ONLY | NON_ESSENTIAL },
+  { MAKE_KEY_NAME1(SMI, "%APPEXE%\\shell\\safemode\\command"),
+    "", 
+    "\"%APPPATH%\" -safe-mode",
+    APP_PATH_SUBSTITUTION | EXE_NAME_SUBSTITUTION | HKLM_ONLY | NON_ESSENTIAL }
+
+  // These values must be set by hand, since they contain localized strings.
+  //     firefox.exe\shell\properties        (default)   REG_SZ  Firefox &Options
+  //     firefox.exe\shell\safemode          (default)   REG_SZ  Firefox &Safe Mode
+};
+
+
+// Support for versions of shlobj.h that don't include the Vista API's
+#if !defined(IApplicationAssociationRegistration)
+
+typedef enum tagASSOCIATIONLEVEL
+{
+  AL_MACHINE,
+  AL_EFFECTIVE,
+  AL_USER
+} ASSOCIATIONLEVEL;
+
+typedef enum tagASSOCIATIONTYPE
+{
+  AT_FILEEXTENSION,
+  AT_URLPROTOCOL,
+  AT_STARTMENUCLIENT,
+  AT_MIMETYPE
+} ASSOCIATIONTYPE;
+
+MIDL_INTERFACE("4e530b0a-e611-4c77-a3ac-9031d022281b")
+IApplicationAssociationRegistration : public IUnknown
+{
+ public:
+  virtual HRESULT STDMETHODCALLTYPE QueryCurrentDefault(LPCWSTR pszQuery,
+                                                        ASSOCIATIONTYPE atQueryType,
+                                                        ASSOCIATIONLEVEL alQueryLevel,
+                                                        LPWSTR *ppszAssociation) = 0;
+  virtual HRESULT STDMETHODCALLTYPE QueryAppIsDefault(LPCWSTR pszQuery,
+                                                      ASSOCIATIONTYPE atQueryType,
+                                                      ASSOCIATIONLEVEL alQueryLevel,
+                                                      LPCWSTR pszAppRegistryName,
+                                                      BOOL *pfDefault) = 0;
+  virtual HRESULT STDMETHODCALLTYPE QueryAppIsDefaultAll(ASSOCIATIONLEVEL alQueryLevel,
+                                                         LPCWSTR pszAppRegistryName,
+                                                         BOOL *pfDefault) = 0;
+  virtual HRESULT STDMETHODCALLTYPE SetAppAsDefault(LPCWSTR pszAppRegistryName,
+                                                    LPCWSTR pszSet,
+                                                    ASSOCIATIONTYPE atSetType) = 0;
+  virtual HRESULT STDMETHODCALLTYPE SetAppAsDefaultAll(LPCWSTR pszAppRegistryName) = 0;
+  virtual HRESULT STDMETHODCALLTYPE ClearUserAssociations( void) = 0;
+};
+#endif
+
+static const CLSID CLSID_ApplicationAssociationReg = {0x591209C7,0x767B,0x42B2,{0x9F,0xBA,0x44,0xEE,0x46,0x15,0xF2,0xC7}};
+static const IID   IID_IApplicationAssociationReg  = {0x4e530b0a,0xe611,0x4c77,{0xa3,0xac,0x90,0x31,0xd0,0x22,0x28,0x1b}};
+
+
+PRBool
+nsWindowsShellService::IsDefaultBrowserVista(PRBool aStartupCheck, PRBool* aIsDefaultBrowser)
+{
+  IApplicationAssociationRegistration* pAAR;
+  
+  HRESULT hr = CoCreateInstance (CLSID_ApplicationAssociationReg,
+                                 NULL,
+                                 CLSCTX_INPROC,
+                                 IID_IApplicationAssociationReg,
+                                 (void**)&pAAR);
+  
+  if (SUCCEEDED(hr))
+  {
+    hr = pAAR->QueryAppIsDefaultAll(AL_EFFECTIVE,
+                                    APP_REG_NAME,
+                                    aIsDefaultBrowser);
+    
+    // If this is the first browser window, maintain internal state that we've
+    // checked this session (so that subsequent window opens don't show the 
+    // default browser dialog).
+    if (aStartupCheck)
+      mCheckedThisSession = PR_TRUE;
+    
+    pAAR->Release();
+    return PR_TRUE;
+  }
+  
+  return PR_FALSE;
+}
+
+PRBool
+nsWindowsShellService::SetDefaultBrowserVista()
+{
+  IApplicationAssociationRegistration* pAAR;
+  
+  HRESULT hr = CoCreateInstance (CLSID_ApplicationAssociationReg,
+                                 NULL,
+                                 CLSCTX_INPROC,
+                                 IID_IApplicationAssociationReg,
+                                 (void**)&pAAR);
+  
+  if (SUCCEEDED(hr))
+  {
+    hr = pAAR->SetAppAsDefaultAll(APP_REG_NAME);
+    
+    pAAR->Release();
+    return PR_TRUE;
+  }
+  
+  return PR_FALSE;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::IsDefaultBrowser(PRBool aStartupCheck, PRBool* aIsDefaultBrowser)
+{
+  // To support side by side installs on Vista we also need to check if the
+  // FirefoxHTML and FirefoxURL registry keys in HKLM / HKCU point to our
+  // install location. If the HKLM keys point to this install location we have
+  // to verify that the keys don't exist in HKCU and remove them if the app is
+  // then set as default. If the HKLM keys don't point to this install location
+  // then we have to add these keys in HKCU to over-ride the HKLM keys.
+  if (IsDefaultBrowserVista(aStartupCheck, aIsDefaultBrowser))
+    return NS_OK;
+
+  SETTING* settings;
+  SETTING* end = gSettings + sizeof(gSettings)/sizeof(SETTING);
+
+  *aIsDefaultBrowser = PR_TRUE;
+
+  char exePath[MAX_BUF];
+  if (!::GetModuleFileName(0, exePath, MAX_BUF))
+    return NS_ERROR_FAILURE;
+
+  nsCAutoString appLongPath(exePath);
+
+  // Support short path to the exe so if it is already set the user is not
+  // prompted to set the default browser again.
+  if (!::GetShortPathName(exePath, exePath, sizeof(exePath)))
+    return NS_ERROR_FAILURE;
+
+  nsCAutoString appShortPath;
+  ToUpperCase(appShortPath = exePath);
+
+  nsCOMPtr<nsILocalFile> lf;
+  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(exePath), PR_TRUE,
+                                      getter_AddRefs(lf));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCAutoString exeName;
+  rv = lf->GetNativeLeafName(exeName);
+  if (NS_FAILED(rv))
+    return rv;
+  ToUpperCase(exeName);
+
+  char currValue[MAX_BUF];
+  for (settings = gSettings; settings < end; ++settings) {
+    if (settings->flags & NON_ESSENTIAL)
+      continue; // This is not a registry key that determines whether
+                // or not we consider Firefox the "Default Browser."
+
+    nsCAutoString dataLongPath(settings->valueData);
+    nsCAutoString dataShortPath(settings->valueData);
+    nsCAutoString key(settings->keyName);
+    if (settings->flags & APP_PATH_SUBSTITUTION) {
+      PRInt32 offset = dataLongPath.Find("%APPPATH%");
+      dataLongPath.Replace(offset, 9, appLongPath);
+      // Remove the quotes around %APPPATH% in VAL_OPEN for short paths
+      PRInt32 offsetQuoted = dataShortPath.Find("\"%APPPATH%\"");
+      if (offsetQuoted != -1)
+        dataShortPath.Replace(offsetQuoted, 11, appShortPath);
+      else
+        dataShortPath.Replace(offset, 9, appShortPath);
+    }
+    if (settings->flags & EXE_NAME_SUBSTITUTION) {
+      PRInt32 offset = key.Find("%APPEXE%");
+      key.Replace(offset, 8, exeName);
+    }
+
+    ::ZeroMemory(currValue, sizeof(currValue));
+    HKEY theKey;
+    nsresult rv = OpenUserKeyForReading(HKEY_CURRENT_USER, key.get(), &theKey);
+    if (NS_SUCCEEDED(rv)) {
+      DWORD len = sizeof currValue;
+      DWORD result = ::RegQueryValueEx(theKey, settings->valueName, NULL, NULL, (LPBYTE)currValue, &len);
+      // Close the key we opened.
+      ::RegCloseKey(theKey);
+      if (REG_FAILED(result) ||
+          !dataLongPath.Equals(currValue, CaseInsensitiveCompare) &&
+          !dataShortPath.Equals(currValue, CaseInsensitiveCompare)) {
+        // Key wasn't set, or was set to something else (something else became the default browser)
+        *aIsDefaultBrowser = PR_FALSE;
+        break;
+      }
+    }
+  }
+
+  // If this is the first browser window, maintain internal state that we've
+  // checked this session (so that subsequent window opens don't show the 
+  // default browser dialog).
+  if (aStartupCheck)
+    mCheckedThisSession = PR_TRUE;
+
+  return NS_OK;
+}
+
+DWORD
+nsWindowsShellService::DeleteRegKeyDefaultValue(HKEY baseKey, const char *keyName)
+{
+  HKEY key;
+  DWORD rc = ::RegOpenKeyEx(baseKey, keyName, 0, KEY_WRITE, &key);
+  if (rc == ERROR_SUCCESS) {
+    rc = ::RegDeleteValue(key, "");
+    ::RegCloseKey(key);
+  }
+  return rc;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::SetDefaultBrowser(PRBool aClaimAllTypes, PRBool aForAllUsers)
+{
+  // Delete the protocol and file handlers under HKCU if they exist. This way
+  // the HKCU registry is cleaned up when HKLM is writeable or if it isn't
+  // the values will then be added under HKCU.
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\http\\shell\\open");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\http\\DefaultIcon");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\https\\shell\\open");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\https\\DefaultIcon");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\ftp\\shell\\open");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\ftp\\DefaultIcon");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\gopher\\shell\\open");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\gopher\\DefaultIcon");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\FirefoxURL");
+  (void)DeleteRegKey(HKEY_CURRENT_USER, "Software\\Classes\\FirefoxHTML");
+
+  (void)DeleteRegKeyDefaultValue(HKEY_CURRENT_USER, "Software\\Classes\\.htm");
+  (void)DeleteRegKeyDefaultValue(HKEY_CURRENT_USER, "Software\\Classes\\.html");
+  (void)DeleteRegKeyDefaultValue(HKEY_CURRENT_USER, "Software\\Classes\\.shtml");
+  (void)DeleteRegKeyDefaultValue(HKEY_CURRENT_USER, "Software\\Classes\\.xht");
+  (void)DeleteRegKeyDefaultValue(HKEY_CURRENT_USER, "Software\\Classes\\.xhtml");
+
+  if (!aForAllUsers && SetDefaultBrowserVista())
+    return NS_OK;
+
+  SETTING* settings;
+  SETTING* end = gSettings + sizeof(gSettings)/sizeof(SETTING);
+
+  char exePath[MAX_BUF];
+  if (!::GetModuleFileName(0, exePath, MAX_BUF))
+    return NS_ERROR_FAILURE;
+
+  nsCAutoString appLongPath(exePath);
+
+  nsCOMPtr<nsILocalFile> lf;
+  nsresult rv = NS_NewNativeLocalFile(nsDependentCString(exePath), PR_TRUE,
+                                      getter_AddRefs(lf));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCAutoString exeName;
+  rv = lf->GetNativeLeafName(exeName);
+  if (NS_FAILED(rv))
+    return rv;
+  ToUpperCase(exeName);
+
+  nsCOMPtr<nsIFile> appDir;
+  rv = lf->GetParent(getter_AddRefs(appDir));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCAutoString parentPath;
+  appDir->GetNativePath(parentPath);
+
+  nsCAutoString uninstLongPath(parentPath.get());
+  uninstLongPath.Append(UNINSTALL_EXE);
+
+  for (settings = gSettings; settings < end; ++settings) {
+    nsCAutoString dataLongPath(settings->valueData);
+    nsCAutoString key(settings->keyName);
+    if (settings->flags & APP_PATH_SUBSTITUTION) {
+      PRInt32 offset = dataLongPath.Find("%APPPATH%");
+      dataLongPath.Replace(offset, 9, appLongPath);
+    }
+    if (settings->flags & UNINST_PATH_SUBSTITUTION) {
+      PRInt32 offset = dataLongPath.Find("%UNINSTPATH%");
+      dataLongPath.Replace(offset, 12, uninstLongPath);
+    }
+    if (settings->flags & EXE_NAME_SUBSTITUTION) {
+      PRInt32 offset = key.Find("%APPEXE%");
+      key.Replace(offset, 8, exeName);
+    }
+
+    SetRegKey(key.get(), settings->valueName, dataLongPath.get(),
+              (settings->flags & HKLM_ONLY));
+  }
+
+  // Select the Default Browser for the Windows XP Start Menu
+  SetRegKey(NS_LITERAL_CSTRING(SMI).get(), "", exeName.get(), PR_TRUE);
+
+  nsCOMPtr<nsIStringBundleService> bundleService(do_GetService("@mozilla.org/intl/stringbundle;1"));
+  if (!bundleService)
+    return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsIStringBundle> bundle, brandBundle;
+  rv = bundleService->CreateBundle(SHELLSERVICE_PROPERTIES, getter_AddRefs(bundle));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = bundleService->CreateBundle(BRAND_PROPERTIES, getter_AddRefs(brandBundle));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Create the Start Menu item if it doesn't exist
+  nsString brandFullName;
+  brandBundle->GetStringFromName(NS_LITERAL_STRING("brandFullName").get(),
+                                 getter_Copies(brandFullName));
+  nsCAutoString nativeFullName;
+  // For the now, we use 'A' APIs (see bug 240272, 239279)
+  NS_UTF16ToCString(brandFullName, NS_CSTRING_ENCODING_NATIVE_FILESYSTEM,
+                    nativeFullName);
+
+  nsCAutoString key1(NS_LITERAL_CSTRING(SMI));
+  key1.Append(exeName);
+  key1.Append("\\");
+  SetRegKey(key1.get(), "", nativeFullName.get(), PR_TRUE);
+
+  // Set the Options and Safe Mode start menu context menu item labels
+  nsCAutoString optionsKey(SMI);
+  optionsKey.Append(exeName);
+  optionsKey.Append("\\shell\\properties");
+
+  nsCAutoString safeModeKey(SMI);
+  safeModeKey.Append(exeName);
+  safeModeKey.Append("\\shell\\safemode");
+
+  nsString brandShortName;
+  brandBundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
+                                 getter_Copies(brandShortName));
+
+  const PRUnichar* brandNameStrings[] = { brandShortName.get() };
+
+  // Set the Options menu item
+  nsString optionsTitle;
+  bundle->FormatStringFromName(NS_LITERAL_STRING("optionsLabel").get(),
+                               brandNameStrings, 1, getter_Copies(optionsTitle));
+  // Set the Safe Mode menu item
+  nsString safeModeTitle;
+  bundle->FormatStringFromName(NS_LITERAL_STRING("safeModeLabel").get(),
+                               brandNameStrings, 1, getter_Copies(safeModeTitle));
+
+  // Set the registry keys
+  nsCAutoString nativeTitle;
+  // For the now, we use 'A' APIs (see bug 240272,  239279)
+  NS_UTF16ToCString(optionsTitle, NS_CSTRING_ENCODING_NATIVE_FILESYSTEM,
+                    nativeTitle);
+  SetRegKey(optionsKey.get(), "", nativeTitle.get(), PR_TRUE);
+  // For the now, we use 'A' APIs (see bug 240272,  239279)
+  NS_UTF16ToCString(safeModeTitle, NS_CSTRING_ENCODING_NATIVE_FILESYSTEM,
+                    nativeTitle);
+  SetRegKey(safeModeKey.get(), "", nativeTitle.get(), PR_TRUE);
+
+  // Refresh the Shell
+  SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, 0, 0);
+  return NS_OK;
+}
+
+// Utility function to delete a registry subkey.
+DWORD
+nsWindowsShellService::DeleteRegKey(HKEY baseKey, const char *keyName)
+{
+ // Make sure input subkey isn't null. 
+ if (!keyName || !::strlen(keyName))
+   return ERROR_BADKEY;
+
+ DWORD rc;
+ // Open subkey.
+ HKEY key;
+ rc = ::RegOpenKeyEx(baseKey, keyName, 0, KEY_ENUMERATE_SUB_KEYS | DELETE, &key);
+ 
+ // Continue till we get an error or are done.
+ while (rc == ERROR_SUCCESS) {
+   char subkeyName[_MAX_PATH];
+   DWORD len = sizeof subkeyName;
+   // Get first subkey name.  Note that we always get the
+   // first one, then delete it.  So we need to get
+   // the first one next time, also.
+   rc = ::RegEnumKeyEx(key, 0, subkeyName, &len, 0, 0, 0, 0);
+   if (rc == ERROR_NO_MORE_ITEMS) {
+     // No more subkeys.  Delete the main one.
+     rc = ::RegDeleteKey(baseKey, keyName);
+     break;
+   } 
+   if (rc == ERROR_SUCCESS) {
+     // Another subkey, delete it, recursively.
+     rc = DeleteRegKey(key, subkeyName);
+   }
+ }
+ 
+ // Close the key we opened.
+ ::RegCloseKey(key);
+ return rc;
+}
+
+void
+nsWindowsShellService::SetRegKey(const char* aKeyName, const char* aValueName, 
+                                 const char* aValue, PRBool aHKLMOnly)
+{
+  char buf[MAX_BUF];
+  DWORD len = sizeof buf;
+
+  HKEY theKey;
+  nsresult rv = OpenKeyForWriting(HKEY_LOCAL_MACHINE, aKeyName, &theKey, aHKLMOnly);
+  if (NS_FAILED(rv))
+    return;
+
+  // Get the old value
+  DWORD result = ::RegQueryValueEx(theKey, aValueName, NULL, NULL, (LPBYTE)buf, &len);
+
+  // Set the new value
+  if (REG_FAILED(result) || strcmp(buf, aValue) != 0)
+    ::RegSetValueEx(theKey, aValueName, 0, REG_SZ, 
+                    (LPBYTE)aValue, nsDependentCString(aValue).Length());
+  
+  // Close the key we opened.
+  ::RegCloseKey(theKey);
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::GetShouldCheckDefaultBrowser(PRBool* aResult)
+{
+  // If we've already checked, the browser has been started and this is a 
+  // new window open, and we don't want to check again.
+  if (mCheckedThisSession) {
+    *aResult = PR_FALSE;
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIPrefBranch> prefs;
+  nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
+  if (pserve)
+    pserve->GetBranch("", getter_AddRefs(prefs));
+
+  prefs->GetBoolPref(PREF_CHECKDEFAULTBROWSER, aResult);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::SetShouldCheckDefaultBrowser(PRBool aShouldCheck)
+{
+  nsCOMPtr<nsIPrefBranch> prefs;
+  nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
+  if (pserve)
+    pserve->GetBranch("", getter_AddRefs(prefs));
+
+  prefs->SetBoolPref(PREF_CHECKDEFAULTBROWSER, aShouldCheck);
+
+  return NS_OK;
+}
+
+static nsresult
+WriteBitmap(nsIFile* aFile, gfxIImageFrame* aImage)
+{
+  PRInt32 width, height;
+  aImage->GetWidth(&width);
+  aImage->GetHeight(&height);
+
+  PRUint8* bits;
+  PRUint32 length;
+  aImage->LockImageData();
+  aImage->GetImageData(&bits, &length);
+  if (!bits) {
+      aImage->UnlockImageData();
+      return NS_ERROR_FAILURE;
+  }
+
+  PRUint32 bpr;
+  aImage->GetImageBytesPerRow(&bpr);
+  PRInt32 bitCount = bpr/width;
+
+  // initialize these bitmap structs which we will later
+  // serialize directly to the head of the bitmap file
+  BITMAPINFOHEADER bmi;
+  bmi.biSize = sizeof(BITMAPINFOHEADER);
+  bmi.biWidth = width;
+  bmi.biHeight = height;
+  bmi.biPlanes = 1;
+  bmi.biBitCount = (WORD)bitCount*8;
+  bmi.biCompression = BI_RGB;
+  bmi.biSizeImage = length;
+  bmi.biXPelsPerMeter = 0;
+  bmi.biYPelsPerMeter = 0;
+  bmi.biClrUsed = 0;
+  bmi.biClrImportant = 0;
+
+  BITMAPFILEHEADER bf;
+  bf.bfType = 0x4D42; // 'BM'
+  bf.bfReserved1 = 0;
+  bf.bfReserved2 = 0;
+  bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
+  bf.bfSize = bf.bfOffBits + bmi.biSizeImage;
+
+  // get a file output stream
+  nsresult rv;
+
+  nsCOMPtr<nsIOutputStream> stream;
+  rv = NS_NewLocalFileOutputStream(getter_AddRefs(stream), aFile);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // write the bitmap headers and rgb pixel data to the file
+  rv = NS_ERROR_FAILURE;
+  if (stream) {
+    PRUint32 written;
+    stream->Write((const char*)&bf, sizeof(BITMAPFILEHEADER), &written);
+    if (written == sizeof(BITMAPFILEHEADER)) {
+      stream->Write((const char*)&bmi, sizeof(BITMAPINFOHEADER), &written);
+      if (written == sizeof(BITMAPINFOHEADER)) {
+#ifndef MOZ_CAIRO_GFX
+        stream->Write((const char*)bits, length, &written);
+        if (written == length)
+          rv = NS_OK;
+#else
+        // write out the image data backwards because the desktop won't
+        // show bitmaps with negative heights for top-to-bottom
+        PRUint32 i = length;
+        do {
+          i -= bpr;
+
+          stream->Write(((const char*)bits) + i, bpr, &written);
+          if (written == bpr) {
+            rv = NS_OK;
+          } else {
+            rv = NS_ERROR_FAILURE;
+            break;
+          }
+        } while (i != 0);
+#endif
+      }
+    }
+
+    stream->Close();
+  }
+
+  aImage->UnlockImageData();
+  return rv;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::SetDesktopBackground(nsIDOMElement* aElement, 
+                                            PRInt32 aPosition)
+{
+  nsresult rv;
+
+  nsCOMPtr<gfxIImageFrame> gfxFrame;
+
+  nsCOMPtr<nsIDOMHTMLImageElement> imgElement(do_QueryInterface(aElement));
+  if (!imgElement) {
+    // XXX write background loading stuff!
+  } 
+  else {
+    nsCOMPtr<nsIImageLoadingContent> imageContent = do_QueryInterface(aElement, &rv);
+    if (!imageContent) return rv;
+
+    // get the image container
+    nsCOMPtr<imgIRequest> request;
+    rv = imageContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
+                                  getter_AddRefs(request));
+    if (!request) return rv;
+    nsCOMPtr<imgIContainer> container;
+    rv = request->GetImage(getter_AddRefs(container));
+    if (!container)
+      return NS_ERROR_FAILURE;
+
+    // get the current frame, which holds the image data
+    container->GetCurrentFrame(getter_AddRefs(gfxFrame));
+  }
+
+  if (!gfxFrame)
+    return NS_ERROR_FAILURE;
+
+  // get the file name from localized strings
+  nsCOMPtr<nsIStringBundleService>
+    bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIStringBundle> shellBundle;
+  rv = bundleService->CreateBundle(SHELLSERVICE_PROPERTIES,
+                                   getter_AddRefs(shellBundle));
+  NS_ENSURE_SUCCESS(rv, rv);
+ 
+  // e.g. "Desktop Background.bmp"
+  nsString fileLeafName;
+  rv = shellBundle->GetStringFromName
+                      (NS_LITERAL_STRING("desktopBackgroundLeafNameWin").get(),
+                       getter_Copies(fileLeafName));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // get the profile root directory
+  nsCOMPtr<nsIFile> file;
+  rv = NS_GetSpecialDirectory(NS_APP_APPLICATION_REGISTRY_DIR,
+                              getter_AddRefs(file));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // eventually, the path is "%APPDATA%\Mozilla\Firefox\Desktop Background.bmp"
+  rv = file->Append(fileLeafName);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCAutoString nativePath;
+  rv = file->GetNativePath(nativePath);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // write the bitmap to a file in the profile directory
+  rv = WriteBitmap(file, gfxFrame);
+
+  // if the file was written successfully, set it as the system wallpaper
+  if (NS_SUCCEEDED(rv)) {
+     char   subKey[] = "Control Panel\\Desktop";
+     PRBool result = PR_FALSE;
+     DWORD  dwDisp = 0;
+     HKEY   key;
+     // Try to create/open a subkey under HKLM.
+     DWORD rc = ::RegCreateKeyEx( HKEY_CURRENT_USER,
+                                  subKey,
+                                  0,
+                                  NULL,
+                                  REG_OPTION_NON_VOLATILE,
+                                  KEY_WRITE,
+                                  NULL,
+                                  &key,
+                                  &dwDisp );
+    if (REG_SUCCEEDED(rc)) {
+      unsigned char tile[2];
+      unsigned char style[2];
+      if (aPosition == BACKGROUND_TILE) {
+        tile[0] = '1';
+        style[0] = '1';
+      }
+      else if (aPosition == BACKGROUND_CENTER) {
+        tile[0] = '0';
+        style[0] = '0';
+      }
+      else if (aPosition == BACKGROUND_STRETCH) {
+        tile[0] = '0';
+        style[0] = '2';
+      }
+      tile[1] = '\0';
+      style[1] = '\0';
+      ::RegSetValueEx(key, "TileWallpaper", 0, REG_SZ, tile, sizeof(tile));
+      ::RegSetValueEx(key, "WallpaperStyle", 0, REG_SZ, style, sizeof(style));
+      ::SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, (PVOID) nativePath.get(),
+                             SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
+      // Close the key we opened.
+      ::RegCloseKey(key);
+    }
+  }
+  return rv;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::OpenApplication(PRInt32 aApplication)
+{
+  nsCAutoString application;
+  switch (aApplication) {
+  case nsIShellService::APPLICATION_MAIL:
+    application = NS_LITERAL_CSTRING("Mail");
+    break;
+  case nsIShellService::APPLICATION_NEWS:
+    application = NS_LITERAL_CSTRING("News");
+    break;
+  }
+
+  // The Default Client section of the Windows Registry looks like this:
+  // 
+  // Clients\aClient\
+  //  e.g. aClient = "Mail"...
+  //        \Mail\(default) = Client Subkey Name
+  //             \Client Subkey Name
+  //             \Client Subkey Name\shell\open\command\ 
+  //             \Client Subkey Name\shell\open\command\(default) = path to exe
+  //
+  nsCAutoString clientKey(NS_LITERAL_CSTRING("SOFTWARE\\Clients\\"));
+  clientKey += application;
+
+  // Find the default application for this class.
+  HKEY theKey;
+  nsresult rv = OpenUserKeyForReading(HKEY_CURRENT_USER, clientKey.get(), &theKey);
+  if (NS_FAILED(rv)) return rv;
+
+  char buf[MAX_BUF];
+  DWORD type, len = sizeof buf;
+  DWORD result = ::RegQueryValueEx(theKey, "", 0, &type, (LPBYTE)&buf, &len);
+  if (REG_FAILED(result) || nsDependentCString(buf).IsEmpty()) 
+    return NS_OK;
+
+  // Close the key we opened.
+  ::RegCloseKey(theKey);
+
+  // Find the "open" command
+  clientKey.Append("\\");
+  clientKey.Append(buf);
+  clientKey.Append("\\shell\\open\\command");
+
+  rv = OpenUserKeyForReading(HKEY_CURRENT_USER, clientKey.get(), &theKey);
+  if (NS_FAILED(rv)) return rv;
+
+  ::ZeroMemory(buf, sizeof(buf));
+  len = sizeof buf;
+  result = ::RegQueryValueEx(theKey, "", 0, &type, (LPBYTE)&buf, &len);
+  if (REG_FAILED(result) || nsDependentCString(buf).IsEmpty()) 
+    return NS_ERROR_FAILURE;
+
+  // Close the key we opened.
+  ::RegCloseKey(theKey);
+
+  nsCAutoString path(buf);
+
+  // Look for any embedded environment variables and substitute their 
+  // values, as |::CreateProcess| is unable to do this. 
+  PRInt32 end = path.Length();
+  PRInt32 cursor = 0, temp = 0;
+  ::ZeroMemory(buf, sizeof(buf));
+  do {
+    // XXX : This would not work with multibyte strings. 
+    cursor = path.FindChar('%', cursor);
+    if (cursor < 0) 
+      break;
+
+    temp = path.FindChar('%', cursor + 1);
+
+    ++cursor;
+
+    ::ZeroMemory(&buf, sizeof(buf));
+    ::GetEnvironmentVariable(nsCAutoString(Substring(path, cursor, temp - cursor)).get(), 
+                             buf, sizeof(buf));
+    
+    // "+ 2" is to subtract the extra characters used to delimit the environment
+    // variable ('%').
+    path.Replace((cursor - 1), temp - cursor + 2, nsDependentCString(buf));
+
+    ++cursor;
+  }
+  while (cursor < end);
+
+  STARTUPINFO si;
+  PROCESS_INFORMATION pi;
+
+  ::ZeroMemory(&si, sizeof(STARTUPINFO));
+  ::ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
+
+  char *pathCStr = ToNewCString(path);
+  BOOL success = ::CreateProcess(NULL, pathCStr, NULL, NULL, FALSE, 0, NULL, 
+                                 NULL, &si, &pi);
+  nsMemory::Free(pathCStr);
+  if (!success)
+    return NS_ERROR_FAILURE;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::GetDesktopBackgroundColor(PRUint32* aColor)
+{
+  PRUint32 color = ::GetSysColor(COLOR_DESKTOP);
+  *aColor = (GetRValue(color) << 16) | (GetGValue(color) << 8) | GetBValue(color);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::SetDesktopBackgroundColor(PRUint32 aColor)
+{
+  int aParameters[2] = { COLOR_BACKGROUND, COLOR_DESKTOP };
+  BYTE r = (aColor >> 16);
+  BYTE g = (aColor << 16) >> 24;
+  BYTE b = (aColor << 24) >> 24;
+  COLORREF colors[2] = { RGB(r,g,b), RGB(r,g,b) };
+
+  ::SetSysColors(sizeof(aParameters) / sizeof(int), aParameters, colors);
+
+  char   subKey[] = "Control Panel\\Colors";
+  PRBool result = PR_FALSE;
+  DWORD  dwDisp = 0;
+  HKEY   key;
+  // Try to create/open a subkey under HKLM.
+  DWORD rc = ::RegCreateKeyEx(HKEY_CURRENT_USER, subKey, 0, NULL, 
+                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &key,
+                              &dwDisp);
+  if (REG_SUCCEEDED(rc)) {
+    unsigned char rgb[12];
+    sprintf((char*)rgb, "%u %u %u\0", r, g, b);
+    ::RegSetValueEx(key, "Background", 0, REG_SZ, (const unsigned char*)rgb, strlen((char*)rgb));
+  }
+  
+  // Close the key we opened.
+  ::RegCloseKey(key);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::GetUnreadMailCount(PRUint32* aCount)
+{
+  *aCount = 0;
+
+  HKEY accountKey;
+  if (GetMailAccountKey(&accountKey)) {
+    DWORD type, unreadCount;
+    DWORD len = sizeof unreadCount;
+    DWORD result = ::RegQueryValueEx(accountKey, "MessageCount", 0, &type, 
+                                     (LPBYTE)&unreadCount, &len);
+    if (REG_SUCCEEDED(result)) {
+      *aCount = unreadCount;
+    }
+
+  // Close the key we opened.
+  ::RegCloseKey(accountKey);
+  }
+
+  return NS_OK;
+}
+
+PRBool
+nsWindowsShellService::GetMailAccountKey(HKEY* aResult)
+{
+  HKEY mailKey;
+  DWORD result = ::RegOpenKeyEx(HKEY_CURRENT_USER, 
+                                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UnreadMail\\",
+                                0, KEY_ENUMERATE_SUB_KEYS, &mailKey);
+
+  PRInt32 i = 0;
+  do {
+    char subkeyName[MAX_BUF];
+    DWORD len = sizeof subkeyName;
+    result = ::RegEnumKeyEx(mailKey, i++, subkeyName, &len, 0, 0, 0, 0);
+    if (REG_SUCCEEDED(result)) {
+      HKEY accountKey;
+      result = ::RegOpenKeyEx(mailKey, subkeyName, 0, KEY_READ, &accountKey);
+      if (REG_SUCCEEDED(result)) {
+        *aResult = accountKey;
+    
+        // Close the key we opened.
+        ::RegCloseKey(mailKey);
+	 
+        return PR_TRUE;
+      }
+    }
+    else
+      break;
+  }
+  while (1);
+
+  // Close the key we opened.
+  ::RegCloseKey(mailKey);
+  return PR_FALSE;
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::OpenApplicationWithURI(nsILocalFile* aApplication, const nsACString& aURI)
+{
+  nsresult rv;
+  nsCOMPtr<nsIProcess> process = 
+    do_CreateInstance("@mozilla.org/process/util;1", &rv);
+  if (NS_FAILED(rv))
+    return rv;
+  
+  rv = process->Init(aApplication);
+  if (NS_FAILED(rv))
+    return rv;
+  
+  const nsCString spec(aURI);
+  const char* specStr = spec.get();
+  PRUint32 pid;
+  return process->Run(PR_FALSE, &specStr, 1, &pid);
+}
+
+NS_IMETHODIMP
+nsWindowsShellService::GetDefaultFeedReader(nsILocalFile** _retval)
+{
+  *_retval = nsnull;
+
+  nsresult rv;
+  nsCOMPtr<nsIWindowsRegKey> regKey =
+    do_CreateInstance("@mozilla.org/windows-registry-key;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
+                    NS_LITERAL_STRING("feed\\shell\\open\\command"),
+                    nsIWindowsRegKey::ACCESS_READ);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsAutoString path;
+  rv = regKey->ReadStringValue(EmptyString(), path);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (path.IsEmpty())
+    return NS_ERROR_FAILURE;
+
+  if (path.First() == '"') {
+    // Everything inside the quotes
+    path = Substring(path, 1, path.FindChar('"', 1) - 1);
+  }
+  else {
+    // Everything up to the first space
+    path = Substring(path, 0, path.FindChar(' '));
+  }
+
+  nsCOMPtr<nsILocalFile> defaultReader =
+    do_CreateInstance("@mozilla.org/file/local;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = defaultReader->InitWithPath(path);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRBool exists;
+  rv = defaultReader->Exists(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!exists)
+    return NS_ERROR_FAILURE;
+
+  NS_ADDREF(*_retval = defaultReader);
+  return NS_OK;
+}
diff -U 8 -prN mozilla-orig/toolkit/components/shell/src/nsWindowsShellService.h mozilla/toolkit/components/shell/src/nsWindowsShellService.h
--- mozilla-orig/toolkit/components/shell/src/nsWindowsShellService.h	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/shell/src/nsWindowsShellService.h	2008-01-21 14:52:25.000000000 -0400
@@ -0,0 +1,72 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Shell Service.
+ *
+ * The Initial Developer of the Original Code is mozilla.org.
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Ben Goodger    <ben@mozilla.org>
+ *  Aaron Kaluszka <ask@swva.net>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nswindowsshellservice_h____
+#define nswindowsshellservice_h____
+
+#include "nscore.h"
+#include "nsIWindowsShellService.h"
+
+#include <windows.h>
+#include <ole2.h>
+
+class nsWindowsShellService : public nsIWindowsShellService
+{
+public:
+  nsWindowsShellService() : mCheckedThisSession(PR_FALSE) {}; 
+  virtual ~nsWindowsShellService() {};
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISHELLSERVICE
+  NS_DECL_NSIWINDOWSSHELLSERVICE
+
+protected:
+  PRBool    IsDefaultBrowserVista(PRBool aStartupCheck, PRBool* aIsDefaultBrowser);
+  PRBool    SetDefaultBrowserVista();
+
+  PRBool    GetMailAccountKey(HKEY* aResult);
+  void      SetRegKey(const char* aKeyName, const char* aValueName, 
+                      const char* aValue, PRBool aHKLMOnly);
+  DWORD     DeleteRegKey(HKEY baseKey, const char *keyName);
+  DWORD     DeleteRegKeyDefaultValue(HKEY baseKey, const char *keyName);
+
+private:
+  PRBool    mCheckedThisSession;
+};
+
+#endif // nswindowsshellservice_h____
diff -U 8 -prN mozilla-orig/toolkit/system/gnome/nsGnomeVFSService.cpp mozilla/toolkit/system/gnome/nsGnomeVFSService.cpp
--- mozilla-orig/toolkit/system/gnome/nsGnomeVFSService.cpp	2008-01-21 14:41:18.000000000 -0400
+++ mozilla/toolkit/system/gnome/nsGnomeVFSService.cpp	2008-01-21 14:57:17.000000000 -0400
@@ -45,17 +45,17 @@
 #include "nsAutoPtr.h"
 
 extern "C" {
 #include <libgnomevfs/gnome-vfs-application-registry.h>
 #include <libgnomevfs/gnome-vfs-init.h>
 #include <libgnomevfs/gnome-vfs-mime.h>
 #include <libgnomevfs/gnome-vfs-mime-handlers.h>
 #include <libgnomevfs/gnome-vfs-mime-info.h>
-#include <libgnome/gnome-url.h>
+//#include <libgnome/gnome-url.h>
 }
 
 class nsGnomeVFSMimeApp : public nsIGnomeVFSMimeApp
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIGNOMEVFSMIMEAPP
 
@@ -234,18 +234,18 @@ nsGnomeVFSService::GetDescriptionForMime
 }
 
 NS_IMETHODIMP
 nsGnomeVFSService::ShowURI(nsIURI *aURI)
 {
   nsCAutoString spec;
   aURI->GetSpec(spec);
 
-  if (gnome_url_show(spec.get(), NULL))
-    return NS_OK;
+  //if (gnome_url_show(spec.get(), NULL))
+  //  return NS_OK;
 
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
 nsGnomeVFSService::SetAppStringKey(const nsACString &aID,
                                    PRInt32           aKey,
                                    const nsACString &aValue)
diff -U 8 -prN mozilla-orig/toolkit/toolkit-tiers.mk mozilla/toolkit/toolkit-tiers.mk
--- mozilla-orig/toolkit/toolkit-tiers.mk	2008-01-21 14:41:18.000000000 -0400
+++ mozilla/toolkit/toolkit-tiers.mk	2008-01-21 14:59:14.000000000 -0400
@@ -260,19 +260,19 @@ ifdef NS_TRACE_MALLOC
 tier_toolkit_dirs += tools/trace-malloc
 endif
 
 ifdef MOZ_LDAP_XPCOM
 tier_toolkit_staticdirs += directory/c-sdk
 tier_toolkit_dirs	+= directory/xpcom
 endif
 
-ifdef MOZ_ENABLE_GNOME_COMPONENT
+#ifdef MOZ_ENABLE_GNOME_COMPONENT
 tier_toolkit_dirs    += toolkit/system/gnome
-endif
+#endif
 
 ifdef MOZ_ENABLE_DBUS
 tier_toolkit_dirs    += toolkit/system/dbus
 endif
 
 ifdef MOZ_LEAKY
 tier_toolkit_dirs        += tools/leaky
 endif
