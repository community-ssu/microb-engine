#Bug 380668  Extra newlines added after a meta element that already has them before and after (line breaks, LF)
Index: content/base/src/nsHTMLContentSerializer.cpp
===================================================================
--- content/base/src/nsHTMLContentSerializer.cpp.orig
+++ content/base/src/nsHTMLContentSerializer.cpp
@@ -629,19 +629,19 @@
   // The _moz_dirty attribute is emitted by the editor to
   // indicate that this element should be pretty printed
   // even if we're not in pretty printing mode
   PRBool hasDirtyAttr = content->HasAttr(kNameSpaceID_None,
                                          nsGkAtoms::mozdirty);
 
   nsIAtom *name = content->Tag();
 
+  // We need too skip any meta tags that set the content type
+  // becase we set our own later.
   if (name == nsGkAtoms::meta) {
-    // We need too skip any meta tags that set the content type
-    // becase we set our own later.
     nsAutoString header;
     content->GetAttr(kNameSpaceID_None, nsGkAtoms::httpEquiv, header);
     if (header.LowerCaseEqualsLiteral("content-type")) {
       return NS_OK;
     }
   }
 
   if (name == nsGkAtoms::br && mPreLevel > 0
@@ -734,18 +734,16 @@
   if (name == nsGkAtoms::script ||
       name == nsGkAtoms::style ||
       name == nsGkAtoms::noscript ||
       name == nsGkAtoms::noframes) {
     mInCDATA = PR_TRUE;
   }
 
   if (name == nsGkAtoms::head) {
-    // We should also obey the line break rules set for a normal meta tag here.
-    // We add a line break before and after the tag's opening.
     AppendToString(mLineBreak, aStr);
     AppendToString(NS_LITERAL_STRING("<meta http-equiv=\"content-type\""),
                    aStr);
     AppendToString(NS_LITERAL_STRING(" content=\"text/html; charset="), aStr);
     AppendToString(NS_ConvertASCIItoUTF16(mCharset), aStr);
     AppendToString(NS_LITERAL_STRING("\">"), aStr);
     AppendToString(mLineBreak, aStr);
   }  
@@ -762,16 +760,25 @@
   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
   if (!content) return NS_ERROR_FAILURE;
 
   PRBool hasDirtyAttr = content->HasAttr(kNameSpaceID_None,
                                          nsGkAtoms::mozdirty);
 
   nsIAtom *name = content->Tag();
 
+  // So that we don't mess up the line breaks.
+  if (name == nsGkAtoms::meta) {
+    nsAutoString header;
+    content->GetAttr(kNameSpaceID_None, nsGkAtoms::httpEquiv, header);
+    if (header.LowerCaseEqualsLiteral("content-type")) {
+      return NS_OK;
+    }
+  }
+
   if (name == nsGkAtoms::script) {
     nsCOMPtr<nsIScriptElement> script = do_QueryInterface(aElement);
     NS_ASSERTION(script, "What kind of weird script element is this?");
 
     if (script->IsMalformed()) {
       // We're looking at a malformed script tag. This means that the end tag
       // was missing in the source. Imitate that here by not serializing the end
       // tag.
