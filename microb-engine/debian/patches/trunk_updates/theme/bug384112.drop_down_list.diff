--- mozilla/widget/src/gtk2/nsNativeThemeGTK.cpp.orig	2007-09-24 12:19:14.000000000 +0300
+++ mozilla/widget/src/gtk2/nsNativeThemeGTK.cpp	2007-09-24 18:41:49.000000000 +0300
@@ -181,24 +181,20 @@ nsNativeThemeGTK::GetGtkWidgetAndState(P
                                        GtkThemeWidgetType& aGtkWidgetType,
                                        GtkWidgetState* aState,
                                        gint* aWidgetFlags)
 {
   if (aState) {
     if (!aFrame) {
       // reset the entire struct to zero
       memset(aState, 0, sizeof(GtkWidgetState));
     } else {
 
-      // for dropdown textfields, look at the parent frame (textbox or menulist)
-      if (aWidgetType == NS_THEME_DROPDOWN_TEXTFIELD)
-        aFrame = aFrame->GetParent();
-
       // For XUL checkboxes and radio buttons, the state of the parent
       // determines our state.
       nsIFrame *stateFrame = aFrame;
       if (aFrame && ((aWidgetFlags && (IsCheckboxWidgetType(aWidgetType) ||
                                        IsRadioWidgetType(aWidgetType))) ||
                      aWidgetType == NS_THEME_CHECKBOX_LABEL ||
                      aWidgetType == NS_THEME_RADIO_LABEL)) {
 
         nsIAtom* atom = nsnull;
         nsIContent *content = aFrame->GetContent();
--- mozilla/widget/src/gtk2/gtk2drawing.c.orig	2007-09-24 12:19:14.000000000 +0300
+++ mozilla/widget/src/gtk2/gtk2drawing.c	2007-09-24 18:59:10.000000000 +0300
@@ -195,30 +195,30 @@ ensure_entry_widget()
         setup_widget_prototype(gEntryWidget);
     }
     return MOZ_GTK_SUCCESS;
 }
 
 static gint
 ensure_option_menu_widget()
 {
     if (!gOptionMenuWidget) {
         gOptionMenuWidget = gtk_option_menu_new();
-        setup_widget_prototype(gOptionMenuWidget);        
+        setup_widget_prototype(gOptionMenuWidget);
     }
     return MOZ_GTK_SUCCESS;
 }
 
 static gint
 ensure_arrow_widget()
 {
     if (!gArrowWidget) {
-        gDropdownButtonWidget = gtk_button_new();
+        gDropdownButtonWidget = gtk_combo_box_entry_new();
         setup_widget_prototype(gDropdownButtonWidget);
         gArrowWidget = gtk_arrow_new(GTK_ARROW_DOWN, GTK_SHADOW_OUT);
         gtk_container_add(GTK_CONTAINER(gDropdownButtonWidget), gArrowWidget);
         gtk_widget_realize(gArrowWidget);
     }
     return MOZ_GTK_SUCCESS;
 }
 
 static gint
 ensure_handlebox_widget()
@@ -627,24 +627,21 @@ moz_gtk_toggle_paint(GdkDrawable* drawab
   
     style = w->style;
     TSOffsetStyleGCs(style, x, y);
 
     /* Some themes check the widget state themselves. */
     /*if (state->focused)
         GTK_WIDGET_SET_FLAGS(w, GTK_HAS_FOCUS);
     else
         GTK_WIDGET_UNSET_FLAGS(w, GTK_HAS_FOCUS);
     */
-    if (state_type != GTK_STATE_INSENSITIVE)
-         GTK_WIDGET_SET_FLAGS(w, GTK_SENSITIVE);
-    else
-         GTK_WIDGET_UNSET_FLAGS(w, GTK_SENSITIVE);
+    gtk_widget_set_sensitive(w, !state->disabled);
 
     GTK_TOGGLE_BUTTON(w)->active = selected;
 
     if (isradio) {
         gtk_paint_option(style, drawable, state_type, shadow_type, cliprect,
                          gRadiobuttonWidget, "radiobutton", x, y,
                          width, height);
     }
     else {
         gtk_paint_check(style, drawable, state_type, shadow_type, cliprect, 
@@ -1110,42 +1107,42 @@ moz_gtk_option_menu_paint(GdkDrawable* d
 static gint
 moz_gtk_dropdown_arrow_paint(GdkDrawable* drawable, GdkRectangle* rect,
                              GdkRectangle* cliprect, GtkWidgetState* state)
 {
     GdkRectangle arrow_rect, real_arrow_rect;
     GtkStateType state_type = ConvertGtkState(state);
     GtkShadowType shadow_type = state->active ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
     GtkStyle* style;
 
     ensure_arrow_widget();
-    moz_gtk_button_paint(drawable, rect, cliprect, state, GTK_RELIEF_NORMAL,
-                         gDropdownButtonWidget);
+    style = gDropdownButtonWidget->style;
+    gtk_paint_box(style, drawable, state_type, shadow_type, cliprect, gDropdownButtonWidget,
+                  "combo_entry_button", rect->x, rect->y, rect->width, rect->height);
 
     /* This mirrors gtkbutton's child positioning */
-    style = gDropdownButtonWidget->style;
-    arrow_rect.x = rect->x + 1 + XTHICKNESS(gDropdownButtonWidget->style);
-    arrow_rect.y = rect->y + 1 + YTHICKNESS(gDropdownButtonWidget->style);
+    arrow_rect.x = rect->x + 1 + XTHICKNESS(style);
+    arrow_rect.y = rect->y + 1 + YTHICKNESS(style);
     arrow_rect.width = MAX(1, rect->width - (arrow_rect.x - rect->x) * 2);
     arrow_rect.height = MAX(1, rect->height - (arrow_rect.y - rect->y) * 2);
 
     calculate_arrow_dimensions(&arrow_rect, &real_arrow_rect);
     style = gArrowWidget->style;
     TSOffsetStyleGCs(style, real_arrow_rect.x, real_arrow_rect.y);
 
     real_arrow_rect.width = real_arrow_rect.height =
         MIN (real_arrow_rect.width, real_arrow_rect.height) * 0.9; 
 
     real_arrow_rect.x = floor (arrow_rect.x + ((arrow_rect.width - real_arrow_rect.width) / 2) + 0.5);
     real_arrow_rect.y = floor (arrow_rect.y + ((arrow_rect.height - real_arrow_rect.height) / 2) + 0.5);
 
     gtk_paint_arrow(style, drawable, state_type, shadow_type, cliprect,
-                    gHorizScrollbarWidget, "arrow",  GTK_ARROW_DOWN, TRUE,
+                    gDropdownButtonWidget, "arrow",  GTK_ARROW_DOWN, TRUE,
                     real_arrow_rect.x, real_arrow_rect.y,
                     real_arrow_rect.width, real_arrow_rect.height);
 
     return MOZ_GTK_SUCCESS;
 }
 
 static gint
 moz_gtk_container_paint(GdkDrawable* drawable, GdkRectangle* rect,
                         GdkRectangle* cliprect, GtkWidgetState* state, 
                         gboolean isradio)
