Index: layout/generic/nsFrameFrame.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/generic/nsFrameFrame.cpp,v
retrieving revision 3.313
diff -u -p -d -w -8 -r3.313 nsFrameFrame.cpp
--- mozilla/layout/generic/nsFrameFrame.cpp	8 Jul 2007 07:08:31 -0000	3.313
+++ mozilla/layout/generic/nsFrameFrame.cpp	19 Sep 2007 06:13:21 -0000
@@ -84,30 +84,32 @@
 #include "nsIDOMWindow.h"
 #include "nsIDOMDocument.h"
 #include "nsIRenderingContext.h"
 #include "nsIFrameFrame.h"
 #include "nsAutoPtr.h"
 #include "nsIDOMNSHTMLDocument.h"
 #include "nsDisplayList.h"
 #include "nsUnicharUtils.h"
+#include "nsIReflowCallback.h"
 
 // For Accessibility
 #ifdef ACCESSIBILITY
 #include "nsIAccessibilityService.h"
 #endif
 #include "nsIServiceManager.h"
 
 static NS_DEFINE_CID(kCChildCID, NS_CHILD_CID);
 
 /******************************************************************************
  * nsSubDocumentFrame
  *****************************************************************************/
 class nsSubDocumentFrame : public nsLeafFrame,
-                           public nsIFrameFrame
+                           public nsIFrameFrame,
+                           public nsIReflowCallback
 {
 public:
   nsSubDocumentFrame(nsStyleContext* aContext);
 
 #ifdef DEBUG
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
 
@@ -154,37 +156,41 @@ public:
   NS_IMETHOD GetAccessible(nsIAccessible** aAccessible);
 #endif
 
   // nsIFrameFrame
   NS_IMETHOD GetDocShell(nsIDocShell **aDocShell);
 
   NS_IMETHOD  VerifyTree() const;
 
+  // nsIReflowCallback
+  virtual PRBool ReflowFinished();
+
 protected:
   nsSize GetMargin();
   PRBool IsInline() { return mIsInline; }
   nsresult ShowDocShell();
   nsresult CreateViewAndWidget(nsContentType aContentType);
 
   virtual nscoord GetIntrinsicWidth();
   virtual nscoord GetIntrinsicHeight();
 
   virtual PRIntn GetSkipSides() const;
 
   nsCOMPtr<nsIFrameLoader> mFrameLoader;
   nsIView* mInnerView;
   PRPackedBool mDidCreateDoc;
   PRPackedBool mOwnsFrameLoader;
   PRPackedBool mIsInline;
+  PRPackedBool mPostedReflowCallback;
 };
 
 nsSubDocumentFrame::nsSubDocumentFrame(nsStyleContext* aContext)
   : nsLeafFrame(aContext), mDidCreateDoc(PR_FALSE), mOwnsFrameLoader(PR_FALSE),
-    mIsInline(PR_FALSE)
+    mIsInline(PR_FALSE), mPostedReflowCallback(PR_FALSE)
 {
 }
 
 #ifdef ACCESSIBILITY
 NS_IMETHODIMP nsSubDocumentFrame::GetAccessible(nsIAccessible** aAccessible)
 {
   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
 
@@ -367,16 +373,19 @@ nsSubDocumentFrame::Reflow(nsPresContext
   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   // printf("OuterFrame::Reflow %X (%d,%d) \n", this, aReflowState.availableWidth, aReflowState.availableHeight);
   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
      ("enter nsSubDocumentFrame::Reflow: maxSize=%d,%d",
       aReflowState.availableWidth, aReflowState.availableHeight));
 
   aStatus = NS_FRAME_COMPLETE;
 
+  NS_ASSERTION(aPresContext->GetPresShell()->GetPrimaryFrameFor(mContent) == this,
+               "Shouldn't happen");
+
   // "offset" is the offset of our content area from our frame's
   // top-left corner.
   nsPoint offset(0, 0);
   
   if (IsInline()) {
     // IFRAME
     nsresult rv = nsLeafFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
                                       aStatus);
@@ -404,45 +413,65 @@ nsSubDocumentFrame::Reflow(nsPresContext
 
   FinishAndStoreOverflow(&aDesiredSize);
 
   // Invalidate the frame contents
   // XXX is this really needed?
   nsRect rect(nsPoint(0, 0), GetSize());
   Invalidate(rect, PR_FALSE);
 
-  if (!aPresContext->IsPaginated()) {
+  if (!aPresContext->IsPaginated() && !mPostedReflowCallback) {
+    PresContext()->PresShell()->PostReflowCallback(this);
+    mPostedReflowCallback = PR_TRUE;
+  }
+
+  // printf("OuterFrame::Reflow DONE %X (%d,%d)\n", this,
+  //        aDesiredSize.width, aDesiredSize.height);
+
+  NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
+     ("exit nsSubDocumentFrame::Reflow: size=%d,%d status=%x",
+      aDesiredSize.width, aDesiredSize.height, aStatus));
+
+  NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
+  return NS_OK;
+}
+
+PRBool
+nsSubDocumentFrame::ReflowFinished()
+{
+  mPostedReflowCallback = PR_FALSE;
+  
+  nsSize innerSize(GetSize());
+  if (IsInline()) {
+    nsMargin usedBorderPadding = GetUsedBorderAndPadding();
+    innerSize.width  -= usedBorderPadding.LeftRight();
+    innerSize.height -= usedBorderPadding.TopBottom();
+  }
+  
     nsCOMPtr<nsIDocShell> docShell;
     GetDocShell(getter_AddRefs(docShell));
 
     nsCOMPtr<nsIBaseWindow> baseWindow(do_QueryInterface(docShell));
 
     // resize the sub document
     if (baseWindow) {
       PRInt32 x = 0;
       PRInt32 y = 0;
       
+    nsPresContext* presContext = PresContext();
       baseWindow->GetPositionAndSize(&x, &y, nsnull, nsnull);
-      PRInt32 cx = aPresContext->AppUnitsToDevPixels(innerSize.width);
-      PRInt32 cy = aPresContext->AppUnitsToDevPixels(innerSize.height);
+    PRInt32 cx = presContext->AppUnitsToDevPixels(innerSize.width);
+    PRInt32 cy = presContext->AppUnitsToDevPixels(innerSize.height);
       baseWindow->SetPositionAndSize(x, y, cx, cy, PR_FALSE);
     }
-  }
 
-  // printf("OuterFrame::Reflow DONE %X (%d,%d)\n", this,
-  //        aDesiredSize.width, aDesiredSize.height);
-
-  NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
-     ("exit nsSubDocumentFrame::Reflow: size=%d,%d status=%x",
-      aDesiredSize.width, aDesiredSize.height, aStatus));
-
-  NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
-  return NS_OK;
+  return PR_FALSE;
 }
 
+
 NS_IMETHODIMP
 nsSubDocumentFrame::VerifyTree() const
 {
   // XXX Completely disabled for now; once pseud-frames are reworked
   // then we can turn it back on.
   return NS_OK;
 }
 
@@ -551,16 +580,21 @@ nsIFrame*
 NS_NewSubDocumentFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 {
   return new (aPresShell) nsSubDocumentFrame(aContext);
 }
 
 void
 nsSubDocumentFrame::Destroy()
 {
+  if (mPostedReflowCallback) {
+    PresContext()->PresShell()->CancelReflowCallback(this);
+    mPostedReflowCallback = PR_FALSE;
+  }
+  
   if (mFrameLoader && mDidCreateDoc) {
     // Get the content viewer through the docshell, but don't call
     // GetDocShell() since we don't want to create one if we don't
     // have one.
 
     nsCOMPtr<nsIDocShell> docShell;
     mFrameLoader->GetDocShell(getter_AddRefs(docShell));
 
@@ -679,17 +713,17 @@ nsSubDocumentFrame::ShowDocShell()
   nsresult rv = GetDocShell(getter_AddRefs(docShell));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIPresShell> presShell;
   docShell->GetPresShell(getter_AddRefs(presShell));
 
   if (presShell) {
     // The docshell is already showing, nothing left to do...
-
+    NS_ASSERTION(mInnerView, "What's going on?");
     return NS_OK;
   }
 
   // pass along marginwidth, marginheight, scrolling so sub document
   // can use it
   nsSize margin = GetMargin();
   docShell->SetMarginWidth(margin.width);
   docShell->SetMarginHeight(margin.height);
Index: docshell/base/nsDocShell.cpp
===================================================================
RCS file: /cvsroot/mozilla/docshell/base/nsDocShell.cpp,v
retrieving revision 1.855
diff -u -p -d -w -8 -r1.855 nsDocShell.cpp
--- mozilla/docshell/base/nsDocShell.cpp	14 Sep 2007 19:21:45 -0000	1.855
+++ mozilla/docshell/base/nsDocShell.cpp	19 Sep 2007 06:12:45 -0000
@@ -3619,19 +3619,21 @@ NS_IMETHODIMP
 nsDocShell::SetPositionAndSize(PRInt32 x, PRInt32 y, PRInt32 cx,
                                PRInt32 cy, PRBool fRepaint)
 {
     mBounds.x = x;
     mBounds.y = y;
     mBounds.width = cx;
     mBounds.height = cy;
 
-    if (mContentViewer) {
+    // Hold strong ref, since SetBounds can make us null out mContentViewer
+    nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
+    if (viewer) {
         //XXX Border figured in here or is that handled elsewhere?
-        NS_ENSURE_SUCCESS(mContentViewer->SetBounds(mBounds), NS_ERROR_FAILURE);
+        NS_ENSURE_SUCCESS(viewer->SetBounds(mBounds), NS_ERROR_FAILURE);
     }
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDocShell::GetPositionAndSize(PRInt32 * x, PRInt32 * y, PRInt32 * cx,
                                PRInt32 * cy)
Index: layout/base/nsPresShell.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/base/nsPresShell.cpp,v
retrieving revision 3.1058
diff -u -p -d -w -8 -r3.1058 nsPresShell.cpp
--- mozilla/layout/base/nsPresShell.cpp	18 Sep 2007 01:16:40 -0000	3.1058
+++ mozilla/layout/base/nsPresShell.cpp	19 Sep 2007 06:12:16 -0000
@@ -2475,18 +2475,25 @@ PresShell::ResizeReflow(nscoord aWidth, 
 
   mPresContext->SetVisibleArea(nsRect(0, 0, aWidth, aHeight));
 
   // There isn't anything useful we can do if the initial reflow hasn't happened
   if (!rootFrame)
     return NS_OK;
 
   NS_ASSERTION(mViewManager, "Must have view manager");
-  mViewManager->BeginUpdateViewBatch();
+  nsCOMPtr<nsIViewManager> viewManager = mViewManager;
+  viewManager->BeginUpdateViewBatch();
 
+  // Take this ref after viewManager so it'll make sure to go away first
+  nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
+
+  // Make sure style is up to date
+  mFrameConstructor->ProcessPendingRestyles();
+  if (!mIsDestroying) {
   // XXX Do a full invalidate at the beginning so that invalidates along
   // the way don't have region accumulation issues?
 
   WillCauseReflow();
   WillDoReflow();
 
   {
     // Kick off a top-down reflow
@@ -2495,19 +2502,23 @@ PresShell::ResizeReflow(nscoord aWidth, 
 
     mDirtyRoots.RemoveElement(rootFrame);
     DoReflow(rootFrame);
     mIsReflowing = PR_FALSE;
   }
 
   DidCauseReflow();
   DidDoReflow();
-  mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
+  }
 
+  viewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
+
+  if (!mIsDestroying) {
   CreateResizeEventTimer();
+  }
 
   return NS_OK; //XXX this needs to be real. MMP
 }
 
 #define RESIZE_EVENT_DELAY 200
 
 void
 PresShell::CreateResizeEventTimer ()
@@ -6218,36 +6229,41 @@ PresShell::ProcessReflowCommands(PRBool 
       // XXXwaterson for interruptible reflow, examine the tree and
       // re-enqueue any unflowed reflow targets.
 
       mIsReflowing = PR_FALSE;
     }
 
     DidDoReflow();
 
+    // DidDoReflow might have killed us
+    if (!mIsDestroying) {
 #ifdef DEBUG
     if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
-      printf("\nPresShell::ProcessReflowCommands() finished: this=%p\n", (void*)this);
+        printf("\nPresShell::ProcessReflowCommands() finished: this=%p\n",
+               (void*)this);
     }
     DoVerifyReflow();
 #endif
 
     // If any new reflow commands were enqueued during the reflow, schedule
     // another reflow event to process them.  Note that we want to do this
     // after DidDoReflow(), since that method can change whether there are
-    // dirty roots around by flushing, and there's no point in posting a reflow
-    // event just to have the flush revoke it.
+      // dirty roots around by flushing, and there's no point in posting a
+      // reflow event just to have the flush revoke it.
     if (mDirtyRoots.Count())
       PostReflowEvent();
   }
+  }
   
   MOZ_TIMER_DEBUGLOG(("Stop: Reflow: PresShell::ProcessReflowCommands(), this=%p\n", this));
   MOZ_TIMER_STOP(mReflowWatch);  
 
-  if (mShouldUnsuppressPainting && mDirtyRoots.Count() == 0) {
+  if (!mIsDestroying && mShouldUnsuppressPainting &&
+      mDirtyRoots.Count() == 0) {
     // We only unlock if we're out of reflows.  It's pointless
     // to unlock if reflows are still pending, since reflows
     // are just going to thrash the frames around some more.  By
     // waiting we avoid an overeager "jitter" effect.
     mShouldUnsuppressPainting = PR_FALSE;
     UnsuppressAndInvalidate();
   }
 
