Index: mozilla/layout/generic/nsObjectFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsObjectFrame.cpp
+++ mozilla/layout/generic/nsObjectFrame.cpp
@@ -802,16 +802,81 @@
   window->clipRect.bottom = 0;
   window->clipRect.right = 0;
 #else
   window->clipRect.bottom = presContext->AppUnitsToDevPixels(aSize.height);
   window->clipRect.right = presContext->AppUnitsToDevPixels(aSize.width);
 #endif
 }
 
+void
+nsObjectFrame::CallSetWindow()
+{
+  nsPluginWindow *win = nsnull;
+
+  nsresult rv;
+  nsCOMPtr<nsIPluginInstance> pi;
+  if (!mInstanceOwner ||
+      NS_FAILED(rv = mInstanceOwner->GetInstance(*getter_AddRefs(pi))) ||
+      !pi ||
+      NS_FAILED(rv = mInstanceOwner->GetWindow(win)) ||
+      !win)
+    return;
+
+  nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
+
+#ifdef XP_MACOSX
+  mInstanceOwner->FixUpPluginWindow(ePluginPaintDisable);
+#endif
+
+  if (IsHidden())
+    return;
+
+  PRBool windowless = (window->type == nsPluginWindowType_Drawable);
+
+  nsPoint origin = GetWindowOriginInPixels(windowless);
+
+  window->x = origin.x;
+  window->y = origin.y;
+
+  // refresh the plugin port as well
+#ifdef MOZ_X11
+  if(windowless) {
+    // There is no plugin port window but there are some extra fields to
+    // fill in.
+    nsIWidget* widget = GetWindow();
+    if (widget) {
+      NPSetWindowCallbackStruct* ws_info =
+        static_cast<NPSetWindowCallbackStruct*>(window->ws_info);
+      ws_info->display =
+        static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY));
+#ifdef MOZ_WIDGET_GTK2
+      GdkWindow* gdkWindow =
+        static_cast<GdkWindow*>(widget->GetNativeData(NS_NATIVE_WINDOW));
+      GdkColormap* gdkColormap = gdk_drawable_get_colormap(gdkWindow);
+      ws_info->colormap = gdk_x11_colormap_get_xcolormap(gdkColormap);
+      GdkVisual* gdkVisual = gdk_colormap_get_visual(gdkColormap);
+      ws_info->visual = gdk_x11_visual_get_xvisual(gdkVisual);
+      ws_info->depth = gdkVisual->depth;
+#endif
+    }
+  }
+  else
+#endif
+  {
+    window->window = mInstanceOwner->GetPluginPort();
+  }
+
+  // this will call pi->SetWindow and take care of window subclassing
+  // if needed, see bug 132759.
+  window->CallSetWindow(pi);
+
+  mInstanceOwner->ReleasePluginPort((nsPluginPort *)window->window);
+}
+
 PRBool
 nsObjectFrame::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
 {
   if (aTabIndex)
     *aTabIndex = -1;
   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
 }
 
@@ -892,62 +957,24 @@
 
   nsresult rv = nsObjectFrameSuper::DidReflow(aPresContext, aReflowState, aStatus);
 
   // The view is created hidden; once we have reflowed it and it has been
   // positioned then we show it.
   if (aStatus != NS_FRAME_REFLOW_FINISHED) 
     return rv;
 
-  PRBool bHidden = IsHidden();
-
   if (HasView()) {
     nsIView* view = GetView();
     nsIViewManager* vm = view->GetViewManager();
     if (vm)
-      vm->SetViewVisibility(view, bHidden ? nsViewVisibility_kHide : nsViewVisibility_kShow);
+      vm->SetViewVisibility(view, IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow);
   }
 
-  nsPluginWindow *win = nsnull;
- 
-  nsCOMPtr<nsIPluginInstance> pi; 
-  if (!mInstanceOwner ||
-      NS_FAILED(rv = mInstanceOwner->GetInstance(*getter_AddRefs(pi))) ||
-      !pi ||
-      NS_FAILED(rv = mInstanceOwner->GetWindow(win)) || 
-      !win)
-    return rv;
-
-  nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
-
-#ifdef XP_MACOSX
-  mInstanceOwner->FixUpPluginWindow(ePluginPaintDisable);
-#endif
-
-  if (bHidden)
-    return rv;
-
-  PRBool windowless = (window->type == nsPluginWindowType_Drawable);
-
-  nsPoint origin = GetWindowOriginInPixels(windowless);
-
-  window->x = origin.x;
-  window->y = origin.y;
-
-  // refresh the plugin port as well
-  window->window = mInstanceOwner->GetPluginPort();
-
-  // this will call pi->SetWindow and take care of window subclassing
-  // if needed, see bug 132759.
-  // XXXbz when this code moves out of reflow, see whether the layout
-  // flushes in nsPluginStreamListener::OnStartRequest and
-  // nsObjectLoadingContent::OnStartRequest() can be removed.
-  window->CallSetWindow(pi);
-
-  mInstanceOwner->ReleasePluginPort((nsPluginPort *)window->window);
+  CallSetWindow();
 
   return rv;
 }
 
 static void PaintPrintPlugin(nsIFrame* aFrame, nsIRenderingContext* aCtx,
                              const nsRect& aDirtyRect, nsPoint aPt)
 {
   nsIRenderingContext::AutoPushTranslation translate(aCtx, aPt.x, aPt.y);
@@ -1360,16 +1387,17 @@
     return rv;
   mInstanceOwner->SetPluginHost(pluginHost);
 
   rv = InstantiatePlugin(pluginHost, aMimeType, aURI);
 
   // finish up
   if (NS_SUCCEEDED(rv)) {
     TryNotifyContentObjectWrapper();
+    CallSetWindow();
   }
 
   return rv;
 }
 
 class nsStopPluginRunnable : public nsRunnable
 {
 public:
Index: mozilla/layout/generic/nsObjectFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsObjectFrame.h
+++ mozilla/layout/generic/nsObjectFrame.h
@@ -161,16 +161,21 @@
                              nsIURI* aURL);
 
   /**
    * Adjust the plugin's idea of its size, using aSize as its new size.
    * (aSize must be in twips)
    */
   void FixupWindow(const nsSize& aSize);
 
+  /**
+   * Sets up the plugin window and calls SetWindow on the plugin.
+   */
+  void CallSetWindow();
+
   PRBool IsFocusable(PRInt32 *aTabIndex = nsnull, PRBool aWithMouse = PR_FALSE);
 
   // check attributes and optionally CSS to see if we should display anything
   PRBool IsHidden(PRBool aCheckVisibilityStyle = PR_TRUE) const;
 
   void NotifyContentObjectWrapper();
 
   nsPoint GetWindowOriginInPixels(PRBool aWindowless);
