Index: mozilla/content/base/src/nsObjectLoadingContent.cpp
===================================================================
--- mozilla.orig/content/base/src/nsObjectLoadingContent.cpp
+++ mozilla/content/base/src/nsObjectLoadingContent.cpp
@@ -475,16 +475,24 @@
 
   if (mFinalListener) {
     mType = newType;
     rv = mFinalListener->OnStartRequest(aRequest, aContext);
     if (NS_FAILED(rv)) {
       LOG(("OBJLC [%p]: mFinalListener->OnStartRequest failed (%08x), falling back\n",
            this, rv));
       Fallback(PR_FALSE);
+    } else if (mType == eType_Plugin) {
+      nsIObjectFrame* frame = GetFrame(PR_FALSE);
+      if (frame) {
+        // We have to notify the wrapper here instead of right after
+        // Instantiate because the plugin only gets instantiated by
+        // OnStartRequest, not by Instantiate.
+        frame->TryNotifyContentObjectWrapper();
+      }
     }
     return rv;
   }
 
   LOG(("OBJLC [%p]: Found no listener, falling back\n", this));
   Fallback(PR_FALSE);
   return NS_BINDING_ABORTED;
 }
Index: mozilla/layout/generic/nsIObjectFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsIObjectFrame.h
+++ mozilla/layout/generic/nsIObjectFrame.h
@@ -42,32 +42,34 @@
 
 #ifndef nsIObjectFrame_h___
 #define nsIObjectFrame_h___
 
 #include "nsIFrame.h"
 
 class nsIPluginInstance;
 
-// {F455B51F-7A1F-4bbe-B55D-679F033AD3FE}
+// {3e2df1fe-a898-4e2e-8763-4ca904fa338e}
 #define NS_IOBJECTFRAME_IID \
-{ 0xf455b51f, 0x7a1f, 0x4bbe, { 0xb5, 0x5d, 0x67, 0x9f, 0x3, 0x3a, 0xd3, 0xfe } }
+{ 0x3e2df1fe, 0xa898, 0x4e2e, { 0x87, 0x63, 0x4c, 0xa9, 0x4, 0xfa, 0x33, 0x8e } }
 
 class nsIObjectFrame : public nsISupports {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IOBJECTFRAME_IID)
 
   NS_IMETHOD GetPluginInstance(nsIPluginInstance*& aPluginInstance) = 0;
 
   /**
    * Instantiate a plugin for a channel, returning a stream listener for the
    * data.
    */
   virtual nsresult Instantiate(nsIChannel* aChannel, nsIStreamListener** aStreamListener) = 0;
 
+  virtual void TryNotifyContentObjectWrapper() = 0;
+
   /**
    * Instantiate a plugin that loads the data itself.
    * @param aMimeType Type of the plugin to instantiate. May be null.
    * @param aURI      URI of the plugin data. May be null.
    * @note            Only one of aURI and aMimeType may be null.
    *                  If aURI is null, aMimeType must not be the empty string.
    * @note XXX this method is here only temporarily, until plugins are loaded
    *       from content.
Index: mozilla/layout/generic/nsObjectFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsObjectFrame.cpp
+++ mozilla/layout/generic/nsObjectFrame.cpp
@@ -1334,16 +1334,17 @@
   FixupWindow(mRect.Size());
 
   rv = pluginHost->InstantiatePluginForChannel(aChannel, mInstanceOwner, aStreamListener);
 
   // XXX having to do this sucks. it'd be better to move the code from DidReflow
   // to FixupWindow.
   PresContext()->GetPresShell()->
     FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+
   return rv;
 }
 
 nsresult
 nsObjectFrame::Instantiate(const char* aMimeType, nsIURI* aURI)
 {
   NS_ASSERTION(aMimeType || aURI, "Need a type or a URI!");
   nsresult rv = PrepareInstanceOwner();
@@ -1357,25 +1358,17 @@
   if (NS_FAILED(rv))
     return rv;
   mInstanceOwner->SetPluginHost(pluginHost);
 
   rv = InstantiatePlugin(pluginHost, aMimeType, aURI);
 
   // finish up
   if (NS_SUCCEEDED(rv)) {
-    nsCOMPtr<nsIPluginInstance> inst;
-    mInstanceOwner->GetInstance(*getter_AddRefs(inst));
-    if (inst) {
-      // The plugin may have set up new interfaces; we need to mess with our JS
-      // wrapper.  Note that we DO NOT want to call this if there is no plugin
-      // instance!  That would just reenter Instantiate(), trying to create
-      // said plugin instance.
-      NotifyContentObjectWrapper();
-    }
+    TryNotifyContentObjectWrapper();
   }
 
   return rv;
 }
 
 class nsStopPluginRunnable : public nsRunnable
 {
 public:
@@ -1456,16 +1449,30 @@
 nsStopPluginRunnable::Run()
 {
   DoStopPlugin(mInstanceOwner);
 
   return NS_OK;
 }
 
 void
+nsObjectFrame::TryNotifyContentObjectWrapper()
+{
+  nsCOMPtr<nsIPluginInstance> inst;
+  mInstanceOwner->GetInstance(*getter_AddRefs(inst));
+  if (inst) {
+    // The plugin may have set up new interfaces; we need to mess with our JS
+    // wrapper.  Note that we DO NOT want to call this if there is no plugin
+    // instance!  That would just reenter Instantiate(), trying to create
+    // said plugin instance.
+    NotifyContentObjectWrapper();
+  }
+}
+
+void
 nsObjectFrame::StopPlugin()
 {
   StopPluginInternal(PR_FALSE);
 }
 
 void
 nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)
 {
Index: mozilla/layout/generic/nsObjectFrame.h
===================================================================
--- mozilla.orig/layout/generic/nsObjectFrame.h
+++ mozilla/layout/generic/nsObjectFrame.h
@@ -105,16 +105,17 @@
   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 #endif
 
   virtual void Destroy();
 
   NS_IMETHOD GetPluginInstance(nsIPluginInstance*& aPluginInstance);
   virtual nsresult Instantiate(nsIChannel* aChannel, nsIStreamListener** aStreamListener);
   virtual nsresult Instantiate(const char* aMimeType, nsIURI* aURI);
+  virtual void TryNotifyContentObjectWrapper();
   virtual void StopPlugin();
 
   /*
    * Stop a plugin instance. If aDelayedStop is true, the plugin will
    * be stopped at a later point when it's safe to do so (i.e. not
    * while destroying the frame tree). Delayed stopping is only
    * implemented on Win32 for now.
    */
