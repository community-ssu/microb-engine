Index: mozilla/modules/plugin/base/src/ns4xPlugin.h
===================================================================
RCS file: /cvsroot/mozilla/modules/plugin/base/src/ns4xPlugin.h,v
retrieving revision 1.41
diff -u -p -U 8 -r1.41 ns4xPlugin.h
--- mozilla/modules/plugin/base/src/ns4xPlugin.h	17 Feb 2007 18:44:42 -0000	1.41
+++ mozilla/modules/plugin/base/src/ns4xPlugin.h	22 Jun 2007 01:28:20 -0000
@@ -50,20 +50,22 @@
 
 /*
  * Use this macro before each exported function
  * (between the return address and the function
  * itself), to ensure that the function has the
  * right calling conventions on Win16.
  */
 
+/* XXX NP_CALLBACK should be the same as NP_LOADDS in npapi.h which differs
+   for WIN16 and maybe WIN64? */
 #ifdef XP_OS2
-#define NP_EXPORT _System
+#define NP_CALLBACK _System
 #else
-#define NP_EXPORT
+#define NP_CALLBACK
 #endif
 
 #if defined(XP_WIN)
 #define NS_4XPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
 #elif defined(XP_OS2)
 #define NS_4XPLUGIN_CALLBACK(_type, _name) _type (_System * _name)
 #else
 #define NS_4XPLUGIN_CALLBACK(_type, _name) _type (* _name)
@@ -166,86 +168,86 @@ protected:
   /**
    * The browser-side callbacks that a 4.x-style plugin calls.
    */
   static NPNetscapeFuncs CALLBACKS;
 };
 
 
 PR_BEGIN_EXTERN_C
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getwindowobject(NPP npp);
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getpluginelement(NPP npp);
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getstringidentifier(const NPUTF8* name);
 
-void NP_EXPORT
+void NP_CALLBACK
 _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
                       NPIdentifier *identifiers);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _identifierisstring(NPIdentifier identifiers);
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getintidentifier(int32_t intid);
 
-NPUTF8* NP_EXPORT
+NPUTF8* NP_CALLBACK
 _utf8fromidentifier(NPIdentifier identifier);
 
-int32_t NP_EXPORT
+int32_t NP_CALLBACK
 _intfromidentifier(NPIdentifier identifier);
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _createobject(NPP npp, NPClass* aClass);
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _retainobject(NPObject* npobj);
 
-void NP_EXPORT
+void NP_CALLBACK
 _releaseobject(NPObject* npobj);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
         uint32_t argCount, NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
                uint32_t argCount, NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              const NPVariant *value);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
            uint32_t *count);
 
-void NP_EXPORT
+void NP_CALLBACK
 _releasevariantvalue(NPVariant *variant);
 
-void NP_EXPORT
+void NP_CALLBACK
 _setexception(NPObject* npobj, const NPUTF8 *message);
 
 PR_END_EXTERN_C
 
 const char *
 PeekException();
 
 void
Index: mozilla/modules/plugin/base/src/ns4xPlugin.cpp
===================================================================
RCS file: /cvsroot/mozilla/modules/plugin/base/src/ns4xPlugin.cpp,v
retrieving revision 1.148
diff -u -p -U 8 -r1.148 ns4xPlugin.cpp
--- mozilla/modules/plugin/base/src/ns4xPlugin.cpp	30 Apr 2007 23:52:39 -0000	1.148
+++ mozilla/modules/plugin/base/src/ns4xPlugin.cpp	22 Jun 2007 01:28:20 -0000
@@ -95,89 +95,89 @@ static NS_DEFINE_IID(kPluginManagerCID, 
 static NS_DEFINE_IID(kMemoryCID, NS_MEMORY_CID);
 
 PR_BEGIN_EXTERN_C
 
   ////////////////////////////////////////////////////////////////////////
   // Static stub functions that are exported to the 4.x plugin as entry
   // points via the CALLBACKS variable.
   //
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _requestread(NPStream *pstream, NPByteRange *rangeList);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _geturlnotify(NPP npp, const char* relativeURL, const char* target,
                 void* notifyData);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _getvalue(NPP npp, NPNVariable variable, void *r_value);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _setvalue(NPP npp, NPPVariable variable, void *r_value);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _geturl(NPP npp, const char* relativeURL, const char* target);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _posturlnotify(NPP npp, const char* relativeURL, const char *target,
                  uint32 len, const char *buf, NPBool file, void* notifyData);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _posturl(NPP npp, const char* relativeURL, const char *target, uint32 len,
               const char *buf, NPBool file);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _newstream(NPP npp, NPMIMEType type, const char* window, NPStream** pstream);
 
-  static int32 NP_EXPORT
+  static int32 NP_CALLBACK
   _write(NPP npp, NPStream *pstream, int32 len, void *buffer);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _destroystream(NPP npp, NPStream *pstream, NPError reason);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _status(NPP npp, const char *message);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _memfree (void *ptr);
 
-  static uint32 NP_EXPORT
+  static uint32 NP_CALLBACK
   _memflush(uint32 size);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _reloadplugins(NPBool reloadPages);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _invalidaterect(NPP npp, NPRect *invalidRect);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _invalidateregion(NPP npp, NPRegion invalidRegion);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _forceredraw(NPP npp);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _pushpopupsenabledstate(NPP npp, NPBool enabled);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _poppopupsenabledstate(NPP npp);
 
-  static const char* NP_EXPORT
+  static const char* NP_CALLBACK
   _useragent(NPP npp);
 
-  static void* NP_EXPORT
+  static void* NP_CALLBACK
   _memalloc (uint32 size);
 
 #ifdef OJI
-  static JRIEnv* NP_EXPORT
+  static JRIEnv* NP_CALLBACK
   _getJavaEnv(void);
 
 #if 1
 
-  static jref NP_EXPORT
+  static jref NP_CALLBACK
   _getJavaPeer(NPP npp);
 
 #endif
 #endif /* OJI */
 
 PR_END_EXTERN_C
 
 #if defined(XP_MACOSX) && defined(__POWERPC__)
@@ -958,17 +958,17 @@ MakeNew4xStreamInternal(NPP npp, const c
   return NPERR_NO_ERROR;
 }
 
 ////////////////////////////////////////////////////////////////////////
 //
 // Static callbacks that get routed back through the new C++ API
 //
 
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _geturl(NPP npp, const char* relativeURL, const char* target)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
    relativeURL));
 
   // Block Adobe Acrobat from loading URLs that are not http:, https:,
   // or ftp: URLs if the given target is null.
@@ -986,49 +986,49 @@ _geturl(NPP npp, const char* relativeURL
   }
 
   return MakeNew4xStreamInternal (npp, relativeURL, target,
                                   eNPPStreamTypeInternal_Get);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _geturlnotify(NPP npp, const char* relativeURL, const char* target,
               void* notifyData)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
     ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
      target, notifyData, relativeURL));
 
   return MakeNew4xStreamInternal (npp, relativeURL, target,
                                   eNPPStreamTypeInternal_Get, PR_TRUE,
                                   notifyData);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _posturlnotify(NPP npp, const char *relativeURL, const char *target,
                uint32 len, const char *buf, NPBool file, void *notifyData)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
                   "notify=%p, url=%s, buf=%s\n",
                   (void*)npp, target, len, file, notifyData, relativeURL,
                   buf));
 
   return MakeNew4xStreamInternal(npp, relativeURL, target,
                                  eNPPStreamTypeInternal_Post, PR_TRUE,
                                  notifyData, len, buf, file);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _posturl(NPP npp, const char *relativeURL, const char *target,
          uint32 len, const char *buf, NPBool file)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
                   "buf=%s\n",
                   (void*)npp, target, file, len, relativeURL, buf));
 
@@ -1083,17 +1083,17 @@ void
 ns4xStreamWrapper::GetStream(nsIOutputStream* &result)
 {
   result = fStream;
   NS_IF_ADDREF(fStream);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
    (const char *)type, target));
 
   NPError err = NPERR_INVALID_INSTANCE_ERROR;
   if (npp && npp->ndata) {
@@ -1115,17 +1115,17 @@ _newstream(NPP npp, NPMIMEType type, con
       err = NPERR_GENERIC_ERROR;
     }
   }
   return err;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-int32 NP_EXPORT
+int32 NP_CALLBACK
 _write(NPP npp, NPStream *pstream, int32 len, void *buffer)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
                   pstream->url, len, (char*)buffer));
 
   // negative return indicates failure to the plugin
   if (!npp)
@@ -1147,17 +1147,17 @@ _write(NPP npp, NPStream *pstream, int32
   if (rv != NS_OK)
     return -1;
 
   return (int32)count;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _destroystream(NPP npp, NPStream *pstream, NPError reason)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
                   pstream->url, (int)reason));
 
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
@@ -1188,17 +1188,17 @@ _destroystream(NPP npp, NPStream *pstrea
     pstream->ndata = nsnull;
   }
 
   return NPERR_NO_ERROR;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _status(NPP npp, const char *message)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_Status: npp=%p, message=%s\n",
                                      (void*)npp, message));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_status: npp or npp->ndata == 0");
     return;
@@ -1209,52 +1209,52 @@ _status(NPP npp, const char *message)
   nsCOMPtr<nsIPluginInstancePeer> peer;
   if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
     peer->ShowStatus(message);
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _memfree (void *ptr)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
 
   if (ptr)
     nsMemory::Free(ptr);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-uint32 NP_EXPORT
+uint32 NP_CALLBACK
 _memflush(uint32 size)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
 
   nsMemory::HeapMinimize(PR_TRUE);
   return 0;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _reloadplugins(NPBool reloadPages)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
 
   nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
 
   pm->ReloadPlugins(reloadPages);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _invalidaterect(NPP npp, NPRect *invalidRect)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
                   "right=%d\n", (void *)npp, invalidRect->top,
                   invalidRect->left, invalidRect->bottom, invalidRect->right));
 
   if (!npp || !npp->ndata) {
@@ -1271,17 +1271,17 @@ _invalidaterect(NPP npp, NPRect *invalid
       // XXX nsRect & NPRect are structurally equivalent
       wpeer->InvalidateRect((nsPluginRect *)invalidRect);
     }
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _invalidateregion(NPP npp, NPRegion invalidRegion)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
                   (void*)invalidRegion));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
@@ -1297,17 +1297,17 @@ _invalidateregion(NPP npp, NPRegion inva
       // nsPluginRegion & NPRegion are typedef'd to the same thing
       wpeer->InvalidateRegion((nsPluginRegion)invalidRegion);
     }
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _forceredraw(NPP npp)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_ForceDraw: npp=%p\n", (void*)npp));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_forceredraw: npp or npp->ndata == 0");
     return;
   }
@@ -1348,29 +1348,29 @@ GetJSContextFromNPP(NPP npp)
   NS_ENSURE_TRUE(sgo, nsnull);
 
   nsIScriptContext *scx = sgo->GetContext();
   NS_ENSURE_TRUE(scx, nsnull);
 
   return (JSContext *)scx->GetNativeContext();
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getwindowobject(NPP npp)
 {
   JSContext *cx = GetJSContextFromNPP(npp);
   NS_ENSURE_TRUE(cx, nsnull);
 
   // Using ::JS_GetGlobalObject(cx) is ok here since the window we
   // want to return here is the outer window, *not* the inner (since
   // we don't know what the plugin will do with it).
   return nsJSObjWrapper::GetNewOrUsed(npp, cx, ::JS_GetGlobalObject(cx));
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getpluginelement(NPP npp)
 {
   nsIDOMElement *elementp = nsnull;
   NPError nperr = _getvalue(npp, NPNVDOMElement, &elementp);
 
   if (nperr != NPERR_NO_ERROR) {
     return nsnull;
   }
@@ -1407,34 +1407,34 @@ doGetIdentifier(JSContext *cx, const NPU
                                        utf16name.Length());
 
   if (!str)
     return nsnull;
 
   return (NPIdentifier)STRING_TO_JSVAL(str);
 }
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getstringidentifier(const NPUTF8* name)
 {
   nsCOMPtr<nsIThreadJSContextStack> stack =
     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
   if (!stack)
     return NULL;
 
   JSContext *cx = nsnull;
   stack->GetSafeJSContext(&cx);
   if (!cx)
     return NULL;
 
   JSAutoRequest ar(cx);
   return doGetIdentifier(cx, name);
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
                       NPIdentifier *identifiers)
 {
   nsCOMPtr<nsIThreadJSContextStack> stack =
     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
   if (!stack)
     return;
 
@@ -1445,23 +1445,23 @@ _getstringidentifiers(const NPUTF8** nam
 
   JSAutoRequest ar(cx);
 
   for (int32_t i = 0; i < nameCount; ++i) {
     identifiers[i] = doGetIdentifier(cx, names[i]);
   }
 }
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getintidentifier(int32_t intid)
 {
   return (NPIdentifier)INT_TO_JSVAL(intid);
 }
 
-NPUTF8* NP_EXPORT
+NPUTF8* NP_CALLBACK
 _utf8fromidentifier(NPIdentifier identifier)
 {
   if (!identifier)
     return NULL;
 
   jsval v = (jsval)identifier;
 
   if (!JSVAL_IS_STRING(v)) {
@@ -1470,37 +1470,37 @@ _utf8fromidentifier(NPIdentifier identif
 
   JSString *str = JSVAL_TO_STRING(v);
 
   return
     ToNewUTF8String(nsDependentString((PRUnichar *)::JS_GetStringChars(str),
                                       ::JS_GetStringLength(str)));
 }
 
-int32_t NP_EXPORT
+int32_t NP_CALLBACK
 _intfromidentifier(NPIdentifier identifier)
 {
   jsval v = (jsval)identifier;
 
   if (!JSVAL_IS_INT(v)) {
     return PR_INT32_MIN;
   }
 
   return JSVAL_TO_INT(v);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _identifierisstring(NPIdentifier identifier)
 {
   jsval v = (jsval)identifier;
 
   return JSVAL_IS_STRING(v);
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _createobject(NPP npp, NPClass* aClass)
 {
   if (!npp) {
     NS_ERROR("Null npp passed to _createobject()!");
 
     return nsnull;
   }
 
@@ -1523,70 +1523,70 @@ _createobject(NPP npp, NPClass* aClass)
   if (npobj) {
     npobj->_class = aClass;
     npobj->referenceCount = 1;
   }
 
   return npobj;
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _retainobject(NPObject* npobj)
 {
   if (npobj) {
     PR_AtomicIncrement((PRInt32*)&npobj->referenceCount);
   }
 
   return npobj;
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _releaseobject(NPObject* npobj)
 {
   if (!npobj)
     return;
 
   int32_t refCnt = PR_AtomicDecrement((PRInt32*)&npobj->referenceCount);
 
   if (refCnt == 0) {
     if (npobj->_class && npobj->_class->deallocate) {
       npobj->_class->deallocate(npobj);
     } else {
       PR_Free(npobj);
     }
   }
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
         uint32_t argCount, NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->invoke(npobj, method, args, argCount, result);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
                uint32_t argCount, NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->invokeDefault(npobj, args, argCount, result);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
 {
   if (!npp)
     return false;
 
   NPPAutoPusher nppPusher(npp);
 
   JSContext *cx = GetJSContextFromNPP(npp);
@@ -1626,79 +1626,79 @@ _evaluate(NPP npp, NPObject* npobj, NPSt
 
   nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
                                              nsnull, 0, nsnull, rval, nsnull);
 
   return NS_SUCCEEDED(rv) &&
          (!result || JSValToNPVariant(npp, cx, *rval, result));
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->getProperty(npobj, property, result);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              const NPVariant *value)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->setProperty(npobj, property, value);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->removeProperty(npobj, property);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->hasProperty(npobj, propertyName);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->hasProperty(npobj, methodName);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
            uint32_t *count)
 {
   if (!npp || !npobj || !npobj->_class)
     return false;
 
   if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
       !npobj->_class->enumerate) {
@@ -1708,17 +1708,17 @@ _enumerate(NPP npp, NPObject *npobj, NPI
   }
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->enumerate(npobj, identifier, count);
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _releasevariantvalue(NPVariant* variant)
 {
   switch (variant->type) {
   case NPVariantType_Void :
   case NPVariantType_Null :
   case NPVariantType_Bool :
   case NPVariantType_Int32 :
   case NPVariantType_Double :
@@ -1743,27 +1743,27 @@ _releasevariantvalue(NPVariant* variant)
     }
   default:
     NS_ERROR("Unknown NPVariant type!");
   }
 
   VOID_TO_NPVARIANT(*variant);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _tostring(NPObject* npobj, NPVariant *result)
 {
   NS_ERROR("Write me!");
 
   return PR_FALSE;
 }
 
 static char *gNPPException;
 
-void NP_EXPORT
+void NP_CALLBACK
 _setexception(NPObject* npobj, const NPUTF8 *message)
 {
   if (gNPPException) {
     // If a plugin throws multiple exceptions, we'll only report the
     // last one for now.
     free(gNPPException);
   }
 
@@ -1797,15 +1797,15 @@ NPPExceptionAutoHolder::NPPExceptionAuto
 NPPExceptionAutoHolder::~NPPExceptionAutoHolder()
 {
   NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
 
   gNPPException = mOldException;
 }
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _getvalue(NPP npp, NPNVariable variable, void *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
                                      (void*)npp, (int)variable));
 
   nsresult res;
@@ -1994,17 +1994,17 @@ _getvalue(NPP npp, NPNVariable variable,
 #endif
 
   default : return NPERR_GENERIC_ERROR;
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _setvalue(NPP npp, NPPVariable variable, void *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
                                      (void*)npp, (int)variable));
 
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
 
@@ -2081,17 +2081,17 @@ _setvalue(NPP npp, NPPVariable variable,
 #endif
 
     default:
       return NPERR_NO_ERROR;
   }
 }
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _requestread(NPStream *pstream, NPByteRange *rangeList)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_RequestRead: stream=%p\n",
                                      (void*)pstream));
 
 #ifdef PLUGIN_LOGGING
   for(NPByteRange * range = rangeList; range != nsnull; range = range->next)
     PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY,
@@ -2117,70 +2117,70 @@ _requestread(NPStream *pstream, NPByteRa
   if (streamlistener->mStreamInfo)
     streamlistener->mStreamInfo->RequestRead((nsByteRange *)rangeList);
 
   return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////
 #ifdef OJI
-JRIEnv* NP_EXPORT
+JRIEnv* NP_CALLBACK
 _getJavaEnv(void)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
   return NULL;
 }
 #endif
 
 ////////////////////////////////////////////////////////////////////////
-const char * NP_EXPORT
+const char * NP_CALLBACK
 _useragent(NPP npp)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
 
   char *retstr;
 
   nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
 
   pm->UserAgent((const char **)&retstr);
 
   return retstr;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void * NP_EXPORT
+void * NP_CALLBACK
 _memalloc (uint32 size)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
   return nsMemory::Alloc(size);
 }
 
 #ifdef OJI
 ////////////////////////////////////////////////////////////////////////
-jref NP_EXPORT
+jref NP_CALLBACK
 _getJavaPeer(NPP npp)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
   return NULL;
 }
 
 #endif /* OJI */
 
-void NP_EXPORT
+void NP_CALLBACK
 _pushpopupsenabledstate(NPP npp, NPBool enabled)
 {
   ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
   if (!inst)
     return;
 
   inst->PushPopupsEnabledState(enabled);
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _poppopupsenabledstate(NPP npp)
 {
   ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
   if (!inst)
     return;
 
   inst->PopPopupsEnabledState();
 }
