Index: mozilla/xpcom/threads/TimerThread.cpp
===================================================================
--- mozilla.orig/xpcom/threads/TimerThread.cpp
+++ mozilla/xpcom/threads/TimerThread.cpp
@@ -70,18 +70,20 @@
   if (mCondVar)
     PR_DestroyCondVar(mCondVar);
   if (mLock)
     PR_DestroyLock(mLock);
 
   mThread = nsnull;
 
   PRInt32 n = mTimers.Count();
+  NS_ASSERTION(n == 0, "Timers remain in TimerThread::~TimerThread");
   while (--n >= 0) {
     nsTimerImpl *timer = NS_STATIC_CAST(nsTimerImpl *, mTimers[n]);
+    timer->mArmed = PR_FALSE;
     NS_RELEASE(timer);
   }
 }
 
 nsresult
 TimerThread::InitLocks()
 {
   NS_ASSERTION(!mLock, "InitLocks called twice?");
@@ -327,17 +329,17 @@
 
 nsresult TimerThread::AddTimer(nsTimerImpl *aTimer)
 {
   nsAutoLock lock(mLock);
 
   // Add the timer to our list.
   PRInt32 i = AddTimerInternal(aTimer);
   if (i < 0)
-    return NS_ERROR_OUT_OF_MEMORY;
+    return NS_ERROR_FAILURE;
 
   // Awaken the timer thread.
   if (mCondVar && mWaiting && i == 0)
     PR_NotifyCondVar(mCondVar);
 
   return NS_OK;
 }
 
@@ -379,16 +381,19 @@
     PR_NotifyCondVar(mCondVar);
 
   return NS_OK;
 }
 
 // This function must be called from within a lock
 PRInt32 TimerThread::AddTimerInternal(nsTimerImpl *aTimer)
 {
+  if (mShutdown)
+    return -1;
+
   PRIntervalTime now = PR_IntervalNow();
   PRInt32 count = mTimers.Count();
   PRInt32 i = 0;
   for (; i < count; i++) {
     nsTimerImpl *timer = NS_STATIC_CAST(nsTimerImpl *, mTimers[i]);
 
     // Don't break till we have skipped any overdue timers.  Do not include
     // mTimeoutAdjustment here, because we are really trying to avoid calling
Index: mozilla/xpcom/threads/nsTimerImpl.cpp
===================================================================
--- mozilla.orig/xpcom/threads/nsTimerImpl.cpp
+++ mozilla/xpcom/threads/nsTimerImpl.cpp
@@ -123,16 +123,17 @@
   // Note that both approaches preclude a timer creator, and everyone else
   // except the TimerThread who might have a strong ref, from dropping all
   // their strong refs without implicitly canceling the timer.  Timers need
   // non-mTimers-element strong refs to stay alive.
 
   if (count == 1 && mArmed) {
     mCanceled = PR_TRUE;
 
+    NS_ASSERTION(gThread, "An armed timer exists after the thread timer stopped.");
     if (NS_SUCCEEDED(gThread->RemoveTimer(this)))
       return 0;
   }
 
   return count;
 }
 
 nsTimerImpl::nsTimerImpl() :
