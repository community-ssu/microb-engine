diff -ruN -p -U5 mozilla/modules/plugin.orig/base/public/npapi.h mozilla/modules/plugin/base/public/npapi.h
--- mozilla/modules/plugin.orig/base/public/npapi.h	2008-02-21 10:22:24.000000000 +0200
+++ mozilla/modules/plugin/base/public/npapi.h	2008-02-21 10:27:24.000000000 +0200
@@ -118,11 +118,11 @@
 /*----------------------------------------------------------------------*/
 /*                        Plugin Version Constants                      */
 /*----------------------------------------------------------------------*/
 
 #define NP_VERSION_MAJOR 0
-#define NP_VERSION_MINOR 18
+#define NP_VERSION_MINOR 19
 
 
 /* The OS/2 version of Netscape uses RC_DATA to define the
    mime types, file extensions, etc that are required.
    Use a vertical bar to separate types, end types with \0.
@@ -639,22 +639,23 @@ enum NPEventType {
 #define NP_EABORT NP_EABORT_is_obsolete_use_NPRES_USER_BREAK
 
 /*
  * Version feature information
  */
-#define NPVERS_HAS_STREAMOUTPUT           8
-#define NPVERS_HAS_NOTIFICATION           9
-#define NPVERS_HAS_LIVECONNECT            9
-#define NPVERS_WIN16_HAS_LIVECONNECT      9
-#define NPVERS_68K_HAS_LIVECONNECT        11
-#define NPVERS_HAS_WINDOWLESS             11
-#define NPVERS_HAS_XPCONNECT_SCRIPTING    13
-#define NPVERS_HAS_NPRUNTIME_SCRIPTING    14
-#define NPVERS_HAS_FORM_VALUES            15
-#define NPVERS_HAS_POPUPS_ENABLED_STATE   16
-#define NPVERS_HAS_RESPONSE_HEADERS       17
-#define NPVERS_HAS_NPOBJECT_ENUM          18
+#define NPVERS_HAS_STREAMOUTPUT             8
+#define NPVERS_HAS_NOTIFICATION             9
+#define NPVERS_HAS_LIVECONNECT              9
+#define NPVERS_WIN16_HAS_LIVECONNECT        9
+#define NPVERS_68K_HAS_LIVECONNECT          11
+#define NPVERS_HAS_WINDOWLESS               11
+#define NPVERS_HAS_XPCONNECT_SCRIPTING      13
+#define NPVERS_HAS_NPRUNTIME_SCRIPTING      14
+#define NPVERS_HAS_FORM_VALUES              15
+#define NPVERS_HAS_POPUPS_ENABLED_STATE     16
+#define NPVERS_HAS_RESPONSE_HEADERS         17
+#define NPVERS_HAS_NPOBJECT_ENUM            18
+#define NPVERS_HAS_PLUGIN_THREAD_ASYNC_CALL 19
 
 /*----------------------------------------------------------------------*/
 /*                        Function Prototypes                           */
 /*----------------------------------------------------------------------*/
 
@@ -743,10 +744,13 @@ NPError NP_LOADDS NPN_SetValue(NPP insta
 void    NP_LOADDS NPN_InvalidateRect(NPP instance, NPRect *invalidRect);
 void    NP_LOADDS NPN_InvalidateRegion(NPP instance, NPRegion invalidRegion);
 void    NP_LOADDS NPN_ForceRedraw(NPP instance);
 void    NP_LOADDS NPN_PushPopupsEnabledState(NPP instance, NPBool enabled);
 void    NP_LOADDS NPN_PopPopupsEnabledState(NPP instance);
+void    NP_LOADDS NPN_PluginThreadAsyncCall(NPP instance,
+                                            void (*func) (void *),
+                                            void *userData);
 
 #ifdef __cplusplus
 }  /* end extern "C" */
 #endif
 
diff -ruN -p -U5 mozilla/modules/plugin.orig/base/public/npupp.h mozilla/modules/plugin/base/public/npupp.h
--- mozilla/modules/plugin.orig/base/public/npupp.h	2008-02-21 10:22:24.000000000 +0200
+++ mozilla/modules/plugin/base/public/npupp.h	2008-02-21 10:27:24.000000000 +0200
@@ -482,10 +482,17 @@ typedef bool (* NP_LOADDS NPN_EnumerateU
 #define NewNPN_EnumerateProc(FUNC)		\
 		((NPN_EnumerateUPP) (FUNC))
 #define CallNPN_EnumerateProc(FUNC, ARG1, ARG2, ARG3, ARG4)		\
 		(*(FUNC))((ARG1), (ARG2), (ARG3), (ARG4))
 
+/* NPN_Enumerate */
+typedef void (* NP_LOADDS NPN_PluginThreadAsyncCallUPP)(NPP instance, void (*func)(void *), void *userData);
+#define NewNPN_PluginThreadAsyncCallProc(FUNC) \
+		((NPN_PluginThreadAsyncCallUPP) (FUNC))
+#define CallNPN_PluginThreadAsyncCallProc(FUNC, ARG1, ARG2, ARG3) \
+		(*(FUNC))((ARG1), (ARG2), (ARG3))
+
 
 /******************************************************************************************
  * The actual plugin function table definitions
  *******************************************************************************************/
 
@@ -552,10 +559,11 @@ typedef struct _NPNetscapeFuncs {
     NPN_ReleaseVariantValueUPP releasevariantvalue;
     NPN_SetExceptionUPP setexception;
     NPN_PushPopupsEnabledStateUPP pushpopupsenabledstate;
     NPN_PopPopupsEnabledStateUPP poppopupsenabledstate;
     NPN_EnumerateUPP enumerate;
+    NPN_PluginThreadAsyncCallUPP pluginthreadasynccall;
 } NPNetscapeFuncs;
 
 
 #ifdef XP_MACOSX
 /******************************************************************************************
diff -ruN -p -U5 mozilla/modules/plugin.orig/base/src/ns4xPlugin.cpp mozilla/modules/plugin/base/src/ns4xPlugin.cpp
--- mozilla/modules/plugin.orig/base/src/ns4xPlugin.cpp	2008-02-21 10:22:24.000000000 +0200
+++ mozilla/modules/plugin/base/src/ns4xPlugin.cpp	2008-02-21 10:28:13.000000000 +0200
@@ -38,14 +38,17 @@
 
 // TODO: Implement Java callbacks
 
 #include "prtypes.h"
 #include "prmem.h"
+#include "prclist.h"
+#include "nsAutoLock.h"
 #include "ns4xPlugin.h"
 #include "ns4xPluginInstance.h"
 #include "ns4xPluginStreamListener.h"
 #include "nsIServiceManager.h"
+#include "nsThreadUtils.h"
 
 #include "nsIMemory.h"
 #include "nsIPluginStreamListener.h"
 #include "nsPluginsDir.h"
 #include "nsPluginSafety.h"
@@ -80,10 +83,13 @@
 #include "gtk2xtbin.h"
 #endif
 
 #include "nsJSNPRuntime.h"
 
+static PRLock *sPluginThreadAsyncCallLock = nsnull;
+static PRCList sPendingAsyncCalls = PR_INIT_STATIC_CLIST(&sPendingAsyncCalls);
+
 // POST/GET stream type
 enum eNPPStreamTypeInternal {
   eNPPStreamTypeInternal_Get,
   eNPPStreamTypeInternal_Post
 };
@@ -158,10 +164,14 @@ PR_BEGIN_EXTERN_C
   _pushpopupsenabledstate(NPP npp, NPBool enabled);
 
   static void NP_CALLBACK
   _poppopupsenabledstate(NPP npp);
 
+  typedef void(*ptrtofunc)(void *);
+  static void NP_CALLBACK
+  _pluginthreadasynccall(NPP instance, ptrtofunc func, void *userData);
+
   static const char* NP_CALLBACK
   _useragent(NPP npp);
 
   static void* NP_CALLBACK
   _memalloc (uint32 size);
@@ -373,10 +383,18 @@ ns4xPlugin::CheckClassInitialized(void)
     NewNPN_PushPopupsEnabledStateProc(FP2TV(_pushpopupsenabledstate));
 
   CALLBACKS.poppopupsenabledstate =
     NewNPN_PopPopupsEnabledStateProc(FP2TV(_poppopupsenabledstate));
 
+  CALLBACKS.pluginthreadasynccall =
+    NewNPN_PluginThreadAsyncCallProc(FP2TV(_pluginthreadasynccall));
+
+  if (!sPluginThreadAsyncCallLock) {
+    sPluginThreadAsyncCallLock =
+      nsAutoLock::NewLock("sPluginThreadAsyncCallLock");
+  }
+
   initialized = TRUE;
 
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN callbacks initialized\n"));
 }
 
@@ -2192,6 +2210,153 @@ _poppopupsenabledstate(NPP npp)
     return;
 
   inst->PopPopupsEnabledState();
 }
 
+class nsPluginThreadRunnable : public nsRunnable,
+                               public PRCList
+{
+public:
+  nsPluginThreadRunnable(NPP instance, ptrtofunc func, void *userData);
+  virtual ~nsPluginThreadRunnable();
+
+  NS_IMETHOD Run();
+
+  PRBool IsForInstance(NPP instance)
+  {
+    return (mInstance == instance);
+  }
+
+  void Invalidate()
+  {
+    mFunc = nsnull;
+  }
+
+  PRBool IsValid()
+  {
+    return (mFunc != nsnull);
+  }
+
+private:  
+  NPP mInstance;
+  ptrtofunc mFunc;
+  void *mUserData;
+};
+
+nsPluginThreadRunnable::nsPluginThreadRunnable(NPP instance,
+                                               ptrtofunc func,
+                                               void *userData)
+  : mInstance(instance), mFunc(func), mUserData(userData)
+{
+  if (!sPluginThreadAsyncCallLock) {
+    // Failed to create lock, not much we can do here then...
+    mFunc = nsnull;
+
+    return;
+  }
+
+  PR_INIT_CLIST(this);
+
+  {
+    nsAutoLock lock(sPluginThreadAsyncCallLock);
+
+    ns4xPluginInstance *inst = (ns4xPluginInstance *)instance->ndata;
+    if (!inst || !inst->IsStarted()) {
+      // The plugin was stopped, ignore this async call.
+      mFunc = nsnull;
+
+      return;
+    }
+
+    PR_APPEND_LINK(this, &sPendingAsyncCalls);
+  }
+}
+
+nsPluginThreadRunnable::~nsPluginThreadRunnable()
+{
+  if (!sPluginThreadAsyncCallLock) {
+    return;
+  }
+
+  {
+    nsAutoLock lock(sPluginThreadAsyncCallLock);
+
+    PR_REMOVE_LINK(this);
+  }
+}
+
+NS_IMETHODIMP
+nsPluginThreadRunnable::Run()
+{
+  if (mFunc) {
+    NS_TRY_SAFE_CALL_VOID(mFunc(mUserData), nsnull, nsnull);
+  }
+
+  return NS_OK;
+}
+
+void NP_CALLBACK
+_pluginthreadasynccall(NPP instance, ptrtofunc func, void *userData)
+{
+  nsRefPtr<nsPluginThreadRunnable> evt =
+    new nsPluginThreadRunnable(instance, func, userData);
+
+  if (evt && evt->IsValid()) {
+    NS_DispatchToMainThread(evt);
+  }
+}
+
+void
+OnPluginDestroy(NPP instance)
+{
+  if (!sPluginThreadAsyncCallLock) {
+    return;
+  }
+
+  {
+    nsAutoLock lock(sPluginThreadAsyncCallLock);
+
+    if (PR_CLIST_IS_EMPTY(&sPendingAsyncCalls)) {
+      return;
+    }
+
+    nsPluginThreadRunnable *r =
+      (nsPluginThreadRunnable *)PR_LIST_HEAD(&sPendingAsyncCalls);
+
+    do {
+      if (r->IsForInstance(instance)) {
+        r->Invalidate();
+      }
+
+      r = (nsPluginThreadRunnable *)PR_NEXT_LINK(r);
+    } while (r != &sPendingAsyncCalls);
+  }
+}
+
+void
+OnShutdown()
+{
+  NS_ASSERTION(PR_CLIST_IS_EMPTY(&sPendingAsyncCalls),
+               "Pending async plugin call list not cleaned up!");
+
+  if (sPluginThreadAsyncCallLock) {
+    nsAutoLock::DestroyLock(sPluginThreadAsyncCallLock);
+  }
+}
+
+void
+EnterAsyncPluginThreadCallLock()
+{
+  if (sPluginThreadAsyncCallLock) {
+    PR_Lock(sPluginThreadAsyncCallLock);
+  }
+}
+
+void
+ExitAsyncPluginThreadCallLock()
+{
+  if (sPluginThreadAsyncCallLock) {
+    PR_Unlock(sPluginThreadAsyncCallLock);
+  }
+}
+
 NPP NPPStack::sCurrentNPP = nsnull;
diff -ruN -p -U5 mozilla/modules/plugin.orig/base/src/ns4xPlugin.h mozilla/modules/plugin/base/src/ns4xPlugin.h
--- mozilla/modules/plugin.orig/base/src/ns4xPlugin.h	2008-02-21 10:22:24.000000000 +0200
+++ mozilla/modules/plugin/base/src/ns4xPlugin.h	2008-02-21 10:27:24.000000000 +0200
@@ -251,10 +251,21 @@ const char *
 PeekException();
 
 void
 PopException();
 
+void
+OnPluginDestroy(NPP instance);
+
+void
+OnShutdown();
+
+void
+EnterAsyncPluginThreadCallLock();
+void
+ExitAsyncPluginThreadCallLock();
+
 class NPPStack
 {
 public:
   static NPP Peek()
   {
diff -ruN -p -U5 mozilla/modules/plugin.orig/base/src/ns4xPluginInstance.cpp mozilla/modules/plugin/base/src/ns4xPluginInstance.cpp
--- mozilla/modules/plugin.orig/base/src/ns4xPluginInstance.cpp	2008-02-21 10:22:24.000000000 +0200
+++ mozilla/modules/plugin/base/src/ns4xPluginInstance.cpp	2008-02-21 10:27:24.000000000 +0200
@@ -853,12 +853,12 @@ NS_IMETHODIMP ns4xPluginInstance::Start(
 {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Start this=%p\n",this));
 
   if(mStarted)
     return NS_OK;
-  else
-    return InitializePlugin(mPeer); 
+
+  return InitializePlugin(mPeer); 
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP ns4xPluginInstance::Stop(void)
@@ -877,10 +877,18 @@ NS_IMETHODIMP ns4xPluginInstance::Stop(v
   }
 
   if(!mStarted)
     return NS_OK;
 
+  // Make sure we lock while we're writing to mStarted after we've
+  // started as other threads might be checking that inside a lock.
+  EnterAsyncPluginThreadCallLock();
+  mStarted = PR_FALSE;
+  ExitAsyncPluginThreadCallLock();
+
+  OnPluginDestroy(&fNPP);
+
   if (fCallbacks->destroy == NULL)
     return NS_ERROR_FAILURE; // XXX right error?
 
   NPSavedData *sdata = 0;
 
@@ -902,12 +910,10 @@ NS_IMETHODIMP ns4xPluginInstance::Stop(v
   NS_TRY_SAFE_CALL_RETURN(error, CallNPP_DestroyProc(fCallbacks->destroy, &fNPP, &sdata), fLibrary, this);
 
   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPP Destroy called: this=%p, npp=%p, return=%d\n", this, &fNPP, error));
 
-  mStarted = PR_FALSE;
-
   nsJSNPRuntime::OnPluginDestroy(&fNPP);
 
   if(error != NPERR_NO_ERROR)
     return NS_ERROR_FAILURE;
   else
diff -ruN -p -U5 mozilla/modules/plugin.orig/base/src/nsPluginHostImpl.cpp mozilla/modules/plugin/base/src/nsPluginHostImpl.cpp
--- mozilla/modules/plugin.orig/base/src/nsPluginHostImpl.cpp	2008-02-21 10:22:27.000000000 +0200
+++ mozilla/modules/plugin/base/src/nsPluginHostImpl.cpp	2008-02-21 10:27:24.000000000 +0200
@@ -6257,10 +6257,11 @@ NS_IMETHODIMP nsPluginHostImpl::Observe(
 #ifdef NS_DEBUG
   printf("nsPluginHostImpl::Observe \"%s\"\n", aTopic ? aTopic : "");
 #endif
   if (!nsCRT::strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, aTopic))
   {
+    OnShutdown();
     Destroy();
     UnloadUnusedLibraries();
     sInst->Release();
   }
   if (!nsCRT::strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, aTopic)) {
