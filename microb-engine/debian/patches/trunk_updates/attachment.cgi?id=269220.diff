# Bug 385286  "WARNING: not supported for frames" trying to scroll over textarea
#
Index: content/events/src/nsEventStateManager.cpp
===================================================================
RCS file: /cvsroot/mozilla/content/events/src/nsEventStateManager.cpp,v
retrieving revision 1.693
diff -p -u -1 -2 -r1.693 nsEventStateManager.cpp
--- content/events/src/nsEventStateManager.cpp	22 May 2007 22:08:36 -0000	1.693
+++ content/events/src/nsEventStateManager.cpp	21 Jun 2007 13:58:57 -0000
@@ -1860,41 +1860,42 @@ nsEventStateManager::DoScrollText(nsPres
   nsIFrame* scrollFrame = aTargetFrame;
 
   // If the user recently scrolled with the mousewheel, then they probably want
   // to scroll the same view as before instead of the view under the cursor.
   // nsMouseWheelTransaction tracks the frame currently being scrolled with the
   // mousewheel. We consider the transaction ended when the mouse moves more than
   // "mousewheel.transaction.ignoremovedelay" milliseconds after the last scroll
   // operation, or any time the mouse moves out of the frame, or when more than
   // "mousewheel.transaction.timeout" milliseconds have passed after the last
   // operation, even if the mouse hasn't moved.
   nsIFrame* lastScrollFrame = nsMouseWheelTransaction::GetTargetFrame();
   if (lastScrollFrame) {
-    nsCOMPtr<nsIScrollableViewProvider> svp =
-      do_QueryInterface(lastScrollFrame);
+    nsIScrollableViewProvider* svp;
+    CallQueryInterface(lastScrollFrame, &svp);
     if (svp) {
       scrollView = svp->GetScrollableView();
       nsMouseWheelTransaction::UpdateTransaction();
     } else {
       nsMouseWheelTransaction::EndTransaction();
       lastScrollFrame = nsnull;
     }
   }
   PRBool passToParent = lastScrollFrame ? PR_FALSE : PR_TRUE;
 
   for (; scrollFrame && passToParent;
        scrollFrame = GetParentFrameToScroll(aPresContext, scrollFrame)) {
     // Check whether the frame wants to provide us with a scrollable view.
     scrollView = nsnull;
-    nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(scrollFrame);
+    nsIScrollableViewProvider* svp;
+    CallQueryInterface(scrollFrame, &svp);
     if (svp) {
       scrollView = svp->GetScrollableView();
     }
     if (!scrollView) {
       continue;
     }
 
     nsPresContext::ScrollbarStyles ss =
       nsLayoutUtils::ScrollbarStylesOfView(scrollView);
     if (NS_STYLE_OVERFLOW_HIDDEN ==
         (aScrollHorizontal ? ss.mHorizontal : ss.mVertical)) {
       continue;
Index: layout/base/nsPresShell.cpp
===================================================================
RCS file: /cvsroot/mozilla/layout/base/nsPresShell.cpp,v
retrieving revision 3.1021
diff -p -u -1 -2 -r3.1021 nsPresShell.cpp
--- layout/base/nsPresShell.cpp	16 Jun 2007 05:12:58 -0000	3.1021
+++ layout/base/nsPresShell.cpp	21 Jun 2007 13:58:57 -0000
@@ -3197,25 +3197,26 @@ PresShell::GetViewToScroll(nsLayoutUtils
   if (!focusedContent && mSelection) {
     nsISelection* domSelection = mSelection->
       GetSelection(nsISelectionController::SELECTION_NORMAL);
     if (domSelection) {
       nsCOMPtr<nsIDOMNode> focusedNode;
       domSelection->GetFocusNode(getter_AddRefs(focusedNode));
       focusedContent = do_QueryInterface(focusedNode);
     }
   }
   if (focusedContent) {
     nsIFrame* startFrame = GetPrimaryFrameFor(focusedContent);
     if (startFrame) {
-      nsCOMPtr<nsIScrollableViewProvider> svp = do_QueryInterface(startFrame);
+      nsIScrollableViewProvider* svp;
+      CallQueryInterface(startFrame, &svp);
       // If this very frame provides a scroll view, start there instead of frame's
       // closest view, because the scroll view may be inside a child frame.
       // For example, this happens in the case of overflow:scroll.
       // In that case we still use GetNearestScrollingView() because
       // we need a scrolling view that matches aDirection.
       nsIScrollableView* sv;
       nsIView* startView = svp && (sv = svp->GetScrollableView()) ? sv->View() : startFrame->GetClosestView();
       NS_ASSERTION(startView, "No view to start searching for scrollable view from");
       scrollView = nsLayoutUtils::GetNearestScrollingView(startView, aDirection);
     }
   }
   if (!scrollView) {
@@ -5342,25 +5343,25 @@ PresShell::HandleEvent(nsIView         *
       }
     }
 
     nsPoint eventPoint
         = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, frame);
     nsIFrame* targetFrame = nsLayoutUtils::GetFrameForPoint(frame, eventPoint);
     if (targetFrame) {
       PresShell* shell =
           NS_STATIC_CAST(PresShell*, targetFrame->PresContext()->PresShell());
       if (shell != this) {
         // Handle the event in the correct shell.
         // Prevent deletion until we're done with event handling (bug 336582).
-        nsRefPtr<nsIPresShell> kungFuDeathGrip(shell);
+        nsCOMPtr<nsIPresShell> kungFuDeathGrip(shell);
         nsIView* subshellRootView;
         shell->GetViewManager()->GetRootView(subshellRootView);
         // We pass the subshell's root view as the view to start from. This is
         // the only correct alternative; if the event was captured then it
         // must have been captured by us or some ancestor shell and we
         // now ask the subshell to dispatch it normally.
         return shell->HandlePositionedEvent(subshellRootView, targetFrame,
                                             aEvent, aEventStatus);
       }
     }
     
     if (!targetFrame) {
@@ -6118,25 +6119,24 @@ PresShell::ProcessReflowCommands(PRBool 
       } while (mDirtyRoots.Count() &&
                (!aInterruptible || PR_IntervalNow() < deadline));
 
       // XXXwaterson for interruptible reflow, examine the tree and
       // re-enqueue any unflowed reflow targets.
 
       mIsReflowing = PR_FALSE;
     }
 
     DidDoReflow();
 
 #ifdef DEBUG
-    nsIFrame* rootFrame = FrameManager()->GetRootFrame();
     if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
       printf("\nPresShell::ProcessReflowCommands() finished: this=%p\n", (void*)this);
     }
     DoVerifyReflow();
 #endif
 
     // If any new reflow commands were enqueued during the reflow, schedule
     // another reflow event to process them.  Note that we want to do this
     // after DidDoReflow(), since that method can change whether there are
     // dirty roots around by flushing, and there's no point in posting a reflow
     // event just to have the flush revoke it.
     if (mDirtyRoots.Count())
