--- mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp.orig	2007-10-02 11:28:03.000000000 +0300
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp	2007-10-01 15:31:36.000000000 +0300
@@ -1670,37 +1670,62 @@ NS_IMETHODIMP nsRenderingContextGTK::Rel
 }
 
 NS_IMETHODIMP
 nsRenderingContextGTK::DrawTile(imgIContainer *aImage,
                                 nscoord aXImageStart, nscoord aYImageStart,
                                 const nsRect *aTargetRect)
 {
   nsRect dr(NS_RECT_FROM_TWIPS_RECT(*aTargetRect));
   aXImageStart = FROM_TWIPS_INT(aXImageStart);
   aYImageStart = FROM_TWIPS_INT(aYImageStart);
+
   mTranMatrix->TransformCoord(&dr.x, &dr.y, &dr.width, &dr.height);
   mTranMatrix->TransformCoord(&aXImageStart, &aYImageStart);
 
   // may have become empty due to transform shinking small number to 0
   if (dr.IsEmpty())
     return NS_OK;
 
-  nscoord width, height;
+  nscoord width, height, origWidth, origHeight;
   aImage->GetWidth(&width);
   aImage->GetHeight(&height);
+  origWidth = width;
+  origHeight = height;
+
+  // Get scale factor
+  float scale = 1.0f;
+  scale = mContext->GetPixelScale();
+
+  // If the page is scaled calculate the offset values
+  // from scales image width and height
+  if (scale != 1.0) {
+    PRInt32 appUnitsPerDevPixel = 60;
+    //if (theDeviceContext)
+    appUnitsPerDevPixel = mContext->AppUnitsPerDevPixel();
+
+    float p2a = nsIDeviceContext::AppUnitsPerCSSPixel();
+
+    // Calculate scaled image width and height
+    width = NSToIntRound(((float)(width) * p2a)/appUnitsPerDevPixel);
+    height = NSToIntRound(((float)(height) * p2a )/appUnitsPerDevPixel);
+  }
 
   if (width == 0 || height == 0)
     return NS_OK;
 
   nscoord xOffset = (dr.x - aXImageStart) % width;
   nscoord yOffset = (dr.y - aYImageStart) % height;
 
+  // Restore original width and height values
+  width = origWidth;
+  height = origHeight;
+
   nsCOMPtr<gfxIImageFrame> iframe;
   aImage->GetCurrentFrame(getter_AddRefs(iframe));
   if (!iframe) return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIImage> img(do_GetInterface(iframe));
   if (!img) return NS_ERROR_FAILURE;
 
   nsIDrawingSurface *surface = nsnull;
   GetDrawingSurface(&surface);
   if (!surface) return NS_ERROR_FAILURE;
@@ -1708,13 +1733,12 @@ nsRenderingContextGTK::DrawTile(imgICont
   /* bug 113561 - frame can be smaller than container */
   nsRect iframeRect;
   iframe->GetRect(iframeRect);
   PRInt32 padx = width - iframeRect.width;
   PRInt32 pady = height - iframeRect.height;
 
   return img->DrawTile(*this, surface,
                        xOffset - iframeRect.x, yOffset - iframeRect.y,
                        padx, pady,
                        dr);
-
 }
 
--- mozilla/gfx/src/gtk/nsImageGTK.cpp.orig	2007-10-02 11:28:03.000000000 +0300
+++ mozilla/gfx/src/gtk/nsImageGTK.cpp	2007-10-02 11:34:18.000000000 +0300
@@ -1989,20 +1989,76 @@ NS_IMETHODIMP nsImageGTK::DrawTile(nsIRe
     validWidth -= mDecodedX1;
     validX = mDecodedX1; 
     partial = PR_TRUE;
   }
 
   if (aTileRect.width == 0 || aTileRect.height == 0 ||
       validWidth == 0 || validHeight == 0) {
     return NS_OK;
   }
 
+  // Get scale factor
+  float scale = 1.0f;
+  nsCOMPtr<nsIDeviceContext> theDeviceContext;
+  aContext.GetDeviceContext(*getter_AddRefs(theDeviceContext));
+  if (theDeviceContext)
+    scale = theDeviceContext->GetPixelScale();
+
+  PRInt32 dWidth = 0, dHeight = 0;
+
+  if (scale != 1.0) {
+    PRInt32 appUnitsPerDevPixel = 60;
+    if (theDeviceContext)
+      appUnitsPerDevPixel = theDeviceContext->AppUnitsPerDevPixel();
+
+    float p2a = nsIDeviceContext::AppUnitsPerCSSPixel();
+
+    // Calculate scaled image width and height
+    dWidth = NSToIntRound(((float)(mWidth) * p2a)/appUnitsPerDevPixel);
+    dHeight = NSToIntRound(((float)(mHeight) * p2a)/appUnitsPerDevPixel);
+#ifdef DEBUG_TILING
+    fprintf( stderr, "scaled tile dWxdH (%4dx%4d)\n", dWidth, dHeight );
+#endif
+  }
+
+  // If the page is scaled and alpha depth is not 0 do tiling by hand. This
+  // is not the most optimal way but it works.
+  // Alpha depth 0 case is handled by gdk tiling functions.
+  if (scale != 1.0 && mAlphaDepth != 0) {
+#ifdef DEBUG_TILING
+      printf("Warning: using slow tiling\n");
+#endif
+    // Get starting and ending coordinates
+    PRInt32 aY0 = aTileRect.y - aSYOffset,
+            aX0 = aTileRect.x - aSXOffset,
+            aY1 = aTileRect.y + aTileRect.height,
+            aX1 = aTileRect.x + aTileRect.width;
+
+    // Set up clipping and call Draw().
+    aContext.PushState();
+    ((nsRenderingContextGTK&)aContext).SetClipRectInPixels(
+      aTileRect, nsClipCombine_kIntersect);
+    ((nsRenderingContextGTK&)aContext).UpdateGC();
+
+    for (PRInt32 y = aY0; y < aY1; y += dHeight + aPadY) {
+      for (PRInt32 x = aX0; x < aX1; x += dWidth + aPadX) {
+          // Use Draw method, the method draws the image
+          // in scaled mode
+          Draw(aContext, aSurface, 0, 0, mWidth, mHeight,
+            x, y, dWidth, dHeight);
+      }
+    }
+    aContext.PopState();
+
+    return NS_OK;
+  }
+
   if (partial || (mAlphaDepth == 8) || (aPadX || aPadY)) {
     PRInt32 aY0 = aTileRect.y - aSYOffset,
             aX0 = aTileRect.x - aSXOffset,
             aY1 = aTileRect.y + aTileRect.height,
             aX1 = aTileRect.x + aTileRect.width;
 
     // Set up clipping and call Draw().
     aContext.PushState();
     ((nsRenderingContextGTK&)aContext).SetClipRectInPixels(
       aTileRect, nsClipCombine_kIntersect);
@@ -2028,21 +2084,21 @@ NS_IMETHODIMP nsImageGTK::DrawTile(nsIRe
 
     return NS_OK;
   }
 
   nsRect clipRect;
   PRBool isNonEmpty;
   PRBool haveClip = NS_SUCCEEDED(aContext.GetClipRect(clipRect, isNonEmpty));
   if (haveClip && !isNonEmpty) {
     return NS_OK;
   }
-    
+
   if (mAlphaDepth == 1) {
     if (sNeedSlowTile) {
       SlowTile(drawing, aTileRect, aSXOffset, aSYOffset, clipRect, haveClip);
       return NS_OK;
     }
 
     GdkGC *tileGC;
     GdkGCValues values;
     GdkGCValuesMask valuesMask;
 
@@ -2070,23 +2126,66 @@ NS_IMETHODIMP nsImageGTK::DrawTile(nsIRe
     gdk_gc_set_fill(tileGC, GDK_TILED);
     gdk_gc_set_function(tileGC, GDK_OR);
     gdk_gc_set_tile(tileGC, mImagePixmap);
 
     gdk_draw_rectangle(drawing->GetDrawable(), tileGC, PR_TRUE,
                        aTileRect.x, aTileRect.y,
                        aTileRect.width, aTileRect.height);
 
     gdk_gc_unref(tileGC);
   } else {
+    // If the page is not scaled use mImagePixmap directly
+    GdkPixmap *tilePixmap = mImagePixmap, *pixmap = 0;
+
+    if (scale != 1.0) {
+#ifdef DEBUG_TILING
+      fprintf( stderr, "nsImage::DrawTile() Scaling - %d\n", mAlphaDepth );
+#endif
+      // When the page is scaled, scale the mImagePixmap
+      // first and the give the scaled pixmap to TilePixmap
+      gint err = 0;
+      gdk_error_trap_push();
+      pixmap = gdk_pixmap_new(nsnull, dWidth, dHeight,
+        gdk_drawable_get_depth(mImagePixmap));
+      gdk_flush();
+      if ((err=gdk_error_trap_pop()) || !pixmap) {
+        xerrmessage(err);
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+
+      if (pixmap) {
+        GdkGC *gc = ((nsRenderingContextGTK&)aContext).GetGC();
+
+        PRBool mem =
+          XlibRectStretch(mWidth, mHeight,
+                          dWidth, dHeight,
+                          0, 0,
+                          0, 0,
+                          dWidth, dHeight,
+                          mImagePixmap, pixmap,
+                          gc, sXbitGC, gdk_drawable_get_depth(mImagePixmap));
+        if (!mem) {
+          if (pixmap)
+            gdk_pixmap_unref(pixmap);
+          return NS_ERROR_OUT_OF_MEMORY;
+          }
+
+        tilePixmap = pixmap;
+      }
+    }
+   
     // In the non-alpha case, gdk can tile for us
-    TilePixmap(mImagePixmap, drawing->GetDrawable(), aSXOffset, aSYOffset,
-               aTileRect, clipRect, haveClip);
+    TilePixmap(tilePixmap, drawing->GetDrawable(), aSXOffset, aSYOffset,
+      aTileRect, clipRect, haveClip);
+
+    if (pixmap)
+      gdk_pixmap_unref(pixmap);
   }
 
   mFlags = 0;
   return NS_OK;
 }
 
 
 
 //------------------------------------------------------------
 
