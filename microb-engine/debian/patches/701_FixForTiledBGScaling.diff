--- mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp.orig	2007-10-03 11:22:39.000000000 +0300
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp	2007-10-03 14:42:49.000000000 +0300
@@ -1670,37 +1670,62 @@ NS_IMETHODIMP nsRenderingContextGTK::Rel
 }
 
 NS_IMETHODIMP
 nsRenderingContextGTK::DrawTile(imgIContainer *aImage,
                                 nscoord aXImageStart, nscoord aYImageStart,
                                 const nsRect *aTargetRect)
 {
   nsRect dr(NS_RECT_FROM_TWIPS_RECT(*aTargetRect));
   aXImageStart = FROM_TWIPS_INT(aXImageStart);
   aYImageStart = FROM_TWIPS_INT(aYImageStart);
+
   mTranMatrix->TransformCoord(&dr.x, &dr.y, &dr.width, &dr.height);
   mTranMatrix->TransformCoord(&aXImageStart, &aYImageStart);
 
   // may have become empty due to transform shinking small number to 0
   if (dr.IsEmpty())
     return NS_OK;
 
-  nscoord width, height;
+  nscoord width, height, origWidth, origHeight;
   aImage->GetWidth(&width);
   aImage->GetHeight(&height);
+  origWidth = width;
+  origHeight = height;
+
+  // Get scale factor
+  float scale = 1.0f;
+  scale = mContext->GetPixelScale();
+
+  // If the page is scaled calculate the offset values
+  // from scaled image width and height
+  if (scale != 1.0) {
+    PRInt32 appUnitsPerDevPixel = 60;
+    //if (theDeviceContext)
+    appUnitsPerDevPixel = mContext->AppUnitsPerDevPixel();
+
+    float p2a = nsIDeviceContext::AppUnitsPerCSSPixel();
+
+    // Calculate scaled image width and height
+    width = NSToIntRound(((float)(width) * p2a)/appUnitsPerDevPixel);
+    height = NSToIntRound(((float)(height) * p2a )/appUnitsPerDevPixel);
+  }
 
   if (width == 0 || height == 0)
     return NS_OK;
 
   nscoord xOffset = (dr.x - aXImageStart) % width;
   nscoord yOffset = (dr.y - aYImageStart) % height;
 
+  // Restore original width and height values
+  width = origWidth;
+  height = origHeight;
+
   nsCOMPtr<gfxIImageFrame> iframe;
   aImage->GetCurrentFrame(getter_AddRefs(iframe));
   if (!iframe) return NS_ERROR_FAILURE;
 
   nsCOMPtr<nsIImage> img(do_GetInterface(iframe));
   if (!img) return NS_ERROR_FAILURE;
 
   nsIDrawingSurface *surface = nsnull;
   GetDrawingSurface(&surface);
   if (!surface) return NS_ERROR_FAILURE;
@@ -1708,13 +1733,12 @@ nsRenderingContextGTK::DrawTile(imgICont
   /* bug 113561 - frame can be smaller than container */
   nsRect iframeRect;
   iframe->GetRect(iframeRect);
   PRInt32 padx = width - iframeRect.width;
   PRInt32 pady = height - iframeRect.height;
 
   return img->DrawTile(*this, surface,
                        xOffset - iframeRect.x, yOffset - iframeRect.y,
                        padx, pady,
                        dr);
-
 }
 
--- mozilla/gfx/src/gtk/nsImageGTK.cpp.orig	2007-10-03 11:22:50.000000000 +0300
+++ mozilla/gfx/src/gtk/nsImageGTK.cpp	2007-10-03 14:50:35.000000000 +0300
@@ -1642,49 +1642,129 @@ nsImageGTK::DrawCompositeTile(nsIRenderi
 
   PRBool flipBytes = 
     ( isLSB && ximage->byte_order != LSBFirst) ||
     (!isLSB && ximage->byte_order == LSBFirst);
 
 
   PRUint8 *imageOrigin, *alphaOrigin;
   PRUint32 imageStride, alphaStride;
   PRUint32 compX, compY;
   PRUint8 *compTarget, *compSource;
+  PRUint8 *scaledImage = 0;
+  PRUint8 *scaledAlpha = 0;
 
-  imageStride = mRowBytes;
-  alphaStride = mAlphaRowBytes;
+  float scale = 1.0f;
+  nsCOMPtr<nsIDeviceContext> theDeviceContext;
+  aContext.GetDeviceContext(*getter_AddRefs(theDeviceContext));
+  PRInt32 appUnitsPerDevPixel = 60;
+  if (theDeviceContext){
+    scale = theDeviceContext->GetPixelScale();
+    appUnitsPerDevPixel = theDeviceContext->AppUnitsPerDevPixel();
+  }
+  float p2a = nsIDeviceContext::AppUnitsPerCSSPixel();
+
+  if (scale != 1.0f) {
+    PRUint32 x1, y1, x2, y2;
+    x1 = 0;
+    y1 = 0;
+    x2 = mWidth;
+    y2 = mHeight;
+
+    PRInt32 scaledImageWidth = NSToIntRound(((float)(mWidth) * p2a)/appUnitsPerDevPixel);
+    PRInt32 scaledImageHeight = NSToIntRound(((float)(mHeight) * p2a)/appUnitsPerDevPixel);
+
+    scaledImage = (PRUint8 *)nsMemory::Alloc(3*scaledImageWidth*scaledImageHeight);
+    scaledAlpha = (PRUint8 *)nsMemory::Alloc(scaledImageWidth*scaledImageHeight);
+    if (!scaledImage || !scaledAlpha) {
+
+      XDestroyImage(ximage);
+      nsMemory::Free(readData);
+      if (scaledImage)
+        nsMemory::Free(scaledImage);
+      if (scaledAlpha)
+        nsMemory::Free(scaledAlpha);
+      return;
+    }
+
+    RectStretch(mWidth, mHeight,
+                scaledImageWidth, scaledImageHeight,
+                0, 0,
+                scaledImageWidth-1, scaledImageHeight-1,
+                mImageBits, mRowBytes, scaledImage, 3*scaledImageWidth, 24);
+
+    RectStretch(mWidth, mHeight,
+                scaledImageWidth, scaledImageHeight,
+                0, 0,
+                scaledImageWidth-1, scaledImageHeight-1,
+                mAlphaBits, mAlphaRowBytes, scaledAlpha, scaledImageWidth, 8);
+
+    imageOrigin = scaledImage;
+    imageStride = 3*scaledImageWidth;
+    alphaOrigin = scaledAlpha;
+    alphaStride = scaledImageWidth;
+  } else {
+    imageOrigin = mImageBits + destY*mRowBytes + 3*destX;
+    imageStride = mRowBytes;
+    alphaOrigin = mAlphaBits + destY*mAlphaRowBytes + destX;
+    alphaStride = mAlphaRowBytes;
+  }
 
   if (destX==mWidth)
     destX = 0;
   if (destY==mHeight)
     destY = 0;
 
   for (unsigned y=0; y<readHeight; y+=compY) {
     if (y==0) {
+      if (scale != 1.0f) {
+        PRInt32 scaledImageHeight = NSToIntRound(((float)(mHeight) * p2a)/appUnitsPerDevPixel);
+        compY = PR_MIN(scaledImageHeight-destY, readHeight-y);
+      } else {
       compY = PR_MIN(mHeight-destY, readHeight-y);
+      }
     } else {
       destY = 0;
+
+      if (scale != 1.0f) {
+        PRInt32 scaledImageHeight = NSToIntRound(((float)(mHeight) * p2a)/appUnitsPerDevPixel);
+        compY = PR_MIN(scaledImageHeight, readHeight-y);
+      } else {
       compY = PR_MIN(mHeight, readHeight-y);
+      }
     }
 
     compTarget = readData + 3*y*ximage->width;
     compSource = (unsigned char *)ximage->data + y*ximage->bytes_per_line;
 
     for (unsigned x=0; x<readWidth; x+=compX) {
       if (x==0) {
+        if (scale != 1.0f) {
+          PRInt32 scaledImageWidth = NSToIntRound(((float)(mWidth) * p2a)/appUnitsPerDevPixel);
+          compX = PR_MIN(scaledImageWidth-destX, readWidth-x);
+          imageOrigin = scaledImage + destY*3*scaledImageWidth + 3*destX;
+          alphaOrigin = scaledAlpha + destY*scaledImageWidth + destX;
+        } else {
         compX = PR_MIN(mWidth-destX, readWidth-x);
         imageOrigin = mImageBits + destY*mRowBytes + 3*destX;
         alphaOrigin = mAlphaBits + destY*mAlphaRowBytes + destX;
+        }
       } else {
+        if (scale != 1.0f) {
+          PRInt32 scaledImageWidth = NSToIntRound(((float)(mWidth) * p2a)/appUnitsPerDevPixel);
+          compX = PR_MIN(scaledImageWidth, readWidth-x);
+          imageOrigin = scaledImage + destY*3*scaledImageWidth;
+          alphaOrigin = scaledAlpha + destY*scaledImageWidth;
+        } else {
         compX = PR_MIN(mWidth, readWidth-x);
         imageOrigin = mImageBits + destY*mRowBytes;
         alphaOrigin = mAlphaBits + destY*mAlphaRowBytes;
+        }
       }
 
       if ((ximage->bits_per_pixel==32) &&
           (visual->red_prec == 8) &&
           (visual->green_prec == 8) &&
           (visual->blue_prec == 8))
         DrawComposited32(isLSB, flipBytes, 
                          imageOrigin, imageStride,
                          alphaOrigin, alphaStride, 
                          compX, compY, ximage, compTarget, compSource);
@@ -1717,20 +1797,24 @@ nsImageGTK::DrawCompositeTile(nsIRenderi
 
   GdkGC *imageGC = ((nsRenderingContextGTK&)aContext).GetGC();
   gdk_draw_rgb_image(drawing->GetDrawable(), imageGC,
                      readX, readY, readWidth, readHeight,
                      GDK_RGB_DITHER_MAX,
                      readData, 3*readWidth);
   gdk_gc_unref(imageGC);
 
   XDestroyImage(ximage);
   nsMemory::Free(readData);
+  if (scaledImage)
+    nsMemory::Free(scaledImage);
+  if (scaledAlpha)
+    nsMemory::Free(scaledAlpha);
   mFlags = 0;
 }
 
 
 PRBool nsImageGTK::CreateOffscreenPixmap(PRInt32 aWidth, PRInt32 aHeight)
 {
   gint err;
   // Render unique image bits onto an off screen pixmap only once
   // The image bits can change as a result of ImageUpdated() - for
   // example: animated GIFs.
@@ -1989,20 +2073,44 @@ NS_IMETHODIMP nsImageGTK::DrawTile(nsIRe
     validWidth -= mDecodedX1;
     validX = mDecodedX1; 
     partial = PR_TRUE;
   }
 
   if (aTileRect.width == 0 || aTileRect.height == 0 ||
       validWidth == 0 || validHeight == 0) {
     return NS_OK;
   }
 
+  // Get scale factor
+  float scale = 1.0f;
+  nsCOMPtr<nsIDeviceContext> theDeviceContext;
+  aContext.GetDeviceContext(*getter_AddRefs(theDeviceContext));
+  if (theDeviceContext)
+    scale = theDeviceContext->GetPixelScale();
+
+  PRInt32 dWidth = 0, dHeight = 0;
+
+  if (scale != 1.0) {
+    PRInt32 appUnitsPerDevPixel = 60;
+    if (theDeviceContext)
+      appUnitsPerDevPixel = theDeviceContext->AppUnitsPerDevPixel();
+
+    float p2a = nsIDeviceContext::AppUnitsPerCSSPixel();
+
+    // Calculate scaled image width and height
+    dWidth = NSToIntRound(((float)(mWidth) * p2a)/appUnitsPerDevPixel);
+    dHeight = NSToIntRound(((float)(mHeight) * p2a)/appUnitsPerDevPixel);
+#ifdef DEBUG_TILING
+    fprintf( stderr, "scaled tile dWxdH (%4dx%4d)\n", dWidth, dHeight );
+#endif
+  }
+
   if (partial || (mAlphaDepth == 8) || (aPadX || aPadY)) {
     PRInt32 aY0 = aTileRect.y - aSYOffset,
             aX0 = aTileRect.x - aSXOffset,
             aY1 = aTileRect.y + aTileRect.height,
             aX1 = aTileRect.x + aTileRect.width;
 
     // Set up clipping and call Draw().
     aContext.PushState();
     ((nsRenderingContextGTK&)aContext).SetClipRectInPixels(
       aTileRect, nsClipCombine_kIntersect);
@@ -2028,65 +2136,181 @@ NS_IMETHODIMP nsImageGTK::DrawTile(nsIRe
 
     return NS_OK;
   }
 
   nsRect clipRect;
   PRBool isNonEmpty;
   PRBool haveClip = NS_SUCCEEDED(aContext.GetClipRect(clipRect, isNonEmpty));
   if (haveClip && !isNonEmpty) {
     return NS_OK;
   }
-    
+
   if (mAlphaDepth == 1) {
     if (sNeedSlowTile) {
       SlowTile(drawing, aTileRect, aSXOffset, aSYOffset, clipRect, haveClip);
       return NS_OK;
     }
 
     GdkGC *tileGC;
     GdkGCValues values;
     GdkGCValuesMask valuesMask;
 
+    GdkPixmap *alphaPixmap = mAlphaPixmap, *imagePixmap = mImagePixmap,
+      *scaledAlpha = 0, *scaledImage = 0;
+    gint err;
+
+    if (scale != 1.0) {
+#ifdef DEBUG_TILING
+      fprintf(stderr, "nsImage::DrawTile() Scaling - %d\n", mAlphaDepth);
+#endif
+      GdkGC *gc;
+
+      gdk_error_trap_push();
+      // Create new pixmaps for scaled images
+      scaledAlpha = gdk_pixmap_new(nsnull, dWidth, dHeight, 1);
+      scaledImage = gdk_pixmap_new(nsnull, dWidth, dHeight,
+        gdk_drawable_get_depth(mImagePixmap));
+      gdk_flush();
+      if ((err=gdk_error_trap_pop()) || !scaledImage || !scaledAlpha) {
+        xerrmessage(err);
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+
+      // Stretch alpha pixmap
+      PRBool mem = XlibRectStretch(mWidth, mHeight,
+                                   dWidth, dHeight,
+                                   0, 0,
+                                   0, 0,
+                                   dWidth, dHeight,
+                                   mAlphaPixmap, scaledAlpha,
+                                   s1bitGC, s1bitGC, 1);
+
+      if (!mem) {
+        gdk_pixmap_unref(scaledAlpha);
+        gdk_pixmap_unref(scaledImage);
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+
+      // Get new GC
+      gc = gdk_gc_new(drawing->GetDrawable());
+
+      // Set clip origin and mask from scaled alpha pixmap
+      gdk_gc_set_clip_origin(gc, 0, 0);
+      gdk_gc_set_clip_mask(gc, scaledAlpha);
+
+      // Stretch image pixmap
+      mem = XlibRectStretch(mWidth, mHeight,
+                            dWidth, dHeight,
+                            0, 0,
+                            0, 0,
+                            dWidth, dHeight,
+                            mImagePixmap, scaledImage,
+                            gc, sXbitGC, gdk_rgb_get_visual()->depth);
+
+      if (!mem) {
+        gdk_pixmap_unref(scaledAlpha);
+        gdk_pixmap_unref(scaledImage);
+        gdk_gc_unref(gc);
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+
+      // Use scaled images in tiling
+      alphaPixmap = scaledAlpha;
+      imagePixmap = scaledImage;
+
+      // GC is not needed anymore
+      gdk_gc_unref(gc);
+    }
+
     memset(&values, 0, sizeof(GdkGCValues));
     values.fill = GDK_STIPPLED;
     values.function = GDK_AND;
-    values.stipple = mAlphaPixmap;
+    values.stipple = alphaPixmap;
     values.ts_x_origin = aTileRect.x - aSXOffset;
     values.ts_y_origin = aTileRect.y - aSYOffset;
     valuesMask = GdkGCValuesMask(GDK_GC_FOREGROUND | GDK_GC_FUNCTION | 
                                  GDK_GC_FILL | GDK_GC_STIPPLE | 
                                  GDK_GC_TS_X_ORIGIN | GDK_GC_TS_Y_ORIGIN);
     tileGC = gdk_gc_new_with_values(drawing->GetDrawable(), &values, valuesMask);
     
     if (haveClip) {
       GdkRectangle gdkrect = {clipRect.x, clipRect.y,
                               clipRect.width, clipRect.height};
       gdk_gc_set_clip_rectangle(tileGC, &gdkrect);
     }
 
     gdk_draw_rectangle(drawing->GetDrawable(), tileGC, PR_TRUE,
                        aTileRect.x, aTileRect.y,
                        aTileRect.width, aTileRect.height);
 
     gdk_gc_set_fill(tileGC, GDK_TILED);
     gdk_gc_set_function(tileGC, GDK_OR);
-    gdk_gc_set_tile(tileGC, mImagePixmap);
+    gdk_gc_set_tile(tileGC, imagePixmap);
 
     gdk_draw_rectangle(drawing->GetDrawable(), tileGC, PR_TRUE,
                        aTileRect.x, aTileRect.y,
                        aTileRect.width, aTileRect.height);
 
     gdk_gc_unref(tileGC);
+
+    // Unref scaled images if needed
+    if (scaledAlpha) gdk_pixmap_unref(scaledAlpha);
+    if (scaledImage) gdk_pixmap_unref(scaledImage);
   } else {
+    // If the page is not scaled use mImagePixmap directly
+    GdkPixmap *tilePixmap = mImagePixmap, *pixmap = 0;
+
+    if (scale != 1.0) {
+#ifdef DEBUG_TILING
+      fprintf( stderr, "nsImage::DrawTile() Scaling - %d\n", mAlphaDepth );
+#endif
+      // When the page is scaled, scale the mImagePixmap
+      // first and the give the scaled pixmap to TilePixmap
+      gint err = 0;
+      gdk_error_trap_push();
+      pixmap = gdk_pixmap_new(nsnull, dWidth, dHeight,
+        gdk_drawable_get_depth(mImagePixmap));
+      gdk_flush();
+      if ((err=gdk_error_trap_pop()) || !pixmap) {
+        xerrmessage(err);
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+
+      if (pixmap) {
+        GdkGC *gc = gdk_gc_new(drawing->GetDrawable());
+
+        PRBool mem =
+          XlibRectStretch(mWidth, mHeight,
+                          dWidth, dHeight,
+                          0, 0,
+                          0, 0,
+                          dWidth, dHeight,
+                          mImagePixmap, pixmap,
+                          gc, sXbitGC, gdk_drawable_get_depth(mImagePixmap));
+        if (!mem) {
+          if (pixmap)
+            gdk_pixmap_unref(pixmap);
+          return NS_ERROR_OUT_OF_MEMORY;
+          }
+
+        gdk_gc_unref(gc);
+
+        tilePixmap = pixmap;
+      }
+    }
+   
     // In the non-alpha case, gdk can tile for us
-    TilePixmap(mImagePixmap, drawing->GetDrawable(), aSXOffset, aSYOffset,
-               aTileRect, clipRect, haveClip);
+    TilePixmap(tilePixmap, drawing->GetDrawable(), aSXOffset, aSYOffset,
+      aTileRect, clipRect, haveClip);
+
+    if (pixmap)
+      gdk_pixmap_unref(pixmap);
   }
 
   mFlags = 0;
   return NS_OK;
 }
 
 
 
 //------------------------------------------------------------
 
