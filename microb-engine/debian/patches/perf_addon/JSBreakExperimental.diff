# Make UI Responsive while JS Script is working 
Index: mozilla/widget/src/xpwidgets/nsBaseAppShell.cpp
===================================================================
--- mozilla.orig/widget/src/xpwidgets/nsBaseAppShell.cpp
+++ mozilla/widget/src/xpwidgets/nsBaseAppShell.cpp
@@ -201,16 +201,22 @@
 NS_IMETHODIMP
 nsBaseAppShell::ResumeNative(void)
 {
   --mSuspendNativeCount;
   NS_ASSERTION(mSuspendNativeCount >= 0, "Unbalanced call to nsBaseAppShell::ResumeNative!");
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsBaseAppShell::WakeupNative(PRBool mayWait)
+{
+  return OnProcessNextEvent(nsnull, PR_FALSE, 0);
+}
+
 //-------------------------------------------------------------------------
 // nsIThreadObserver methods:
 
 // Called from any thread
 NS_IMETHODIMP
 nsBaseAppShell::OnDispatchedEvent(nsIThreadInternal *thr)
 {
   PRInt32 lastVal = PR_AtomicSet(&mNativeEventPending, 1);
Index: mozilla/widget/public/nsIAppShell.idl
===================================================================
--- mozilla.orig/widget/public/nsIAppShell.idl
+++ mozilla/widget/public/nsIAppShell.idl
@@ -91,9 +91,14 @@
   void suspendNative();
 
   /**
    * Resumes the use of additional platform-specific methods to run Gecko
    * events on the main application thread.  Calls to suspendNative() and
    * resumeNative() may be nested.  On some platforms this will be a no-op.
    */
   void resumeNative();
+
+  /**
+   * Will call DoNextNativeEvent for proceeding native event loop
+   */
+  void wakeupNative(in boolean mayWait);
 };
Index: mozilla/dom/src/base/nsJSEnvironment.cpp
===================================================================
--- mozilla.orig/dom/src/base/nsJSEnvironment.cpp
+++ mozilla/dom/src/base/nsJSEnvironment.cpp
@@ -121,16 +121,22 @@
 #include "prlog.h"
 #include "prthread.h"
 
 #ifdef OJI
 #include "nsIJVMManager.h"
 #include "nsILiveConnectManager.h"
 #endif
 
+#include "nsWidgetsCID.h"
+#include "nsIAppShell.h"
+#include "nsIBaseWindow.h"
+
+static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
+
 const size_t gStackSize = 8192;
 
 #ifdef PR_LOGGING
 static PRLogModuleInfo* gJSDiagnostics;
 #endif
 
 // Thank you Microsoft!
 #ifndef WINCE
@@ -707,16 +713,34 @@
 
     ctx->mIsTrackingChromeCodeTime =
       ::JS_IsSystemObject(cx, ::JS_GetGlobalObject(cx));
 
     return JS_TRUE;
   }
 
   if (callbackCount & MAYBE_GC_BRANCH_COUNT_MASK) {
+    nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
+    if (appShell) {
+    //  nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(ctx->GetGlobalObject()));
+    //  if (win) {
+    //    nsIDocShell *docShell = win->GetDocShell();
+    //    if (docShell) {
+    //      nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(docShell));
+    //      if (baseWin) {
+    //        baseWin->SetEnabled(PR_FALSE);
+    //        ctx->SetScriptsEnabled(PR_FALSE, PR_FALSE);
+            appShell->WakeupNative(PR_FALSE);
+    //        baseWin->SetEnabled(PR_TRUE);
+    //        ctx->SetScriptsEnabled(PR_TRUE, PR_FALSE);
+    //        return JS_TRUE;
+    //      }
+    //    }
+    //  }
+    }
     return JS_TRUE;
   }
 
   // XXX Save the branch callback time so we can restore it after the GC,
   // because GCing can cause JS to run on our context, causing our
   // ScriptEvaluated to be called, and clearing our branch callback time and
   // count. See bug 302333.
   PRTime callbackTime = ctx->mBranchCallbackTime;
