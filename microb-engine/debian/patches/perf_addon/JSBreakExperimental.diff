# Make UI Responsive while JS Script is working 
Index: mozilla/widget/src/xpwidgets/nsBaseAppShell.cpp
===================================================================
--- mozilla.orig/widget/src/xpwidgets/nsBaseAppShell.cpp
+++ mozilla/widget/src/xpwidgets/nsBaseAppShell.cpp
@@ -201,16 +201,22 @@
 NS_IMETHODIMP
 nsBaseAppShell::ResumeNative(void)
 {
   --mSuspendNativeCount;
   NS_ASSERTION(mSuspendNativeCount >= 0, "Unbalanced call to nsBaseAppShell::ResumeNative!");
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsBaseAppShell::WakeupNative(PRBool mayWait)
+{
+  return OnProcessNextEvent(nsnull, PR_FALSE, 0);
+}
+
 //-------------------------------------------------------------------------
 // nsIThreadObserver methods:
 
 // Called from any thread
 NS_IMETHODIMP
 nsBaseAppShell::OnDispatchedEvent(nsIThreadInternal *thr)
 {
   PRInt32 lastVal = PR_AtomicSet(&mNativeEventPending, 1);
Index: mozilla/widget/public/nsIAppShell.idl
===================================================================
--- mozilla.orig/widget/public/nsIAppShell.idl
+++ mozilla/widget/public/nsIAppShell.idl
@@ -91,9 +91,14 @@
   void suspendNative();
 
   /**
    * Resumes the use of additional platform-specific methods to run Gecko
    * events on the main application thread.  Calls to suspendNative() and
    * resumeNative() may be nested.  On some platforms this will be a no-op.
    */
   void resumeNative();
+
+  /**
+   * Will call DoNextNativeEvent for proceeding native event loop
+   */
+  void wakeupNative(in boolean mayWait);
 };
Index: mozilla/dom/src/base/nsJSEnvironment.cpp
===================================================================
--- mozilla.orig/dom/src/base/nsJSEnvironment.cpp
+++ mozilla/dom/src/base/nsJSEnvironment.cpp
@@ -121,16 +121,22 @@
 #include "prlog.h"
 #include "prthread.h"
 
 #ifdef OJI
 #include "nsIJVMManager.h"
 #include "nsILiveConnectManager.h"
 #endif
 
+#include "nsWidgetsCID.h"
+#include "nsIAppShell.h"
+#include "nsIBaseWindow.h"
+
+static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
+
 const size_t gStackSize = 8192;
 
 #ifdef PR_LOGGING
 static PRLogModuleInfo* gJSDiagnostics;
 #endif
 
 // Thank you Microsoft!
 #ifndef WINCE
@@ -707,16 +713,34 @@
 
     ctx->mIsTrackingChromeCodeTime =
       ::JS_IsSystemObject(cx, ::JS_GetGlobalObject(cx));
 
     return JS_TRUE;
   }
 
   if (callbackCount & MAYBE_GC_BRANCH_COUNT_MASK) {
+    nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
+    if (appShell) {
+      nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(ctx->GetGlobalObject()));
+      if (win) {
+        nsIDocShell *docShell = win->GetDocShell();
+        if (docShell) {
+          nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(docShell));
+          if (baseWin) {
+            baseWin->SetEnabled(PR_FALSE);
+            ctx->SetScriptsEnabled(PR_FALSE, PR_TRUE);
+            appShell->WakeupNative(PR_FALSE);
+            baseWin->SetEnabled(PR_TRUE);
+            ctx->SetScriptsEnabled(PR_TRUE, PR_TRUE);
+            return JS_TRUE;
+          }
+        }
+      }
+    }
     return JS_TRUE;
   }
 
   // XXX Save the branch callback time so we can restore it after the GC,
   // because GCing can cause JS to run on our context, causing our
   // ScriptEvaluated to be called, and clearing our branch callback time and
   // count. See bug 302333.
   PRTime callbackTime = ctx->mBranchCallbackTime;
@@ -1737,34 +1761,38 @@
 nsJSContext::CallEventHandler(nsISupports* aTarget, void *aScope, void *aHandler,
                               nsIArray *aargv, nsIVariant **arv)
 {
   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
 
   if (!mScriptsEnabled) {
     return NS_OK;
   }
+  printf("CallEventHandler Start: this:%p, targ:%p\n", this, aTarget);
+
   nsresult rv;
   JSObject* target = nsnull;
   nsAutoGCRoot root(&target, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = JSObjectFromInterface(aTarget, aScope, &target);
   NS_ENSURE_SUCCESS(rv, rv);
 
   jsval rval = JSVAL_VOID;
 
   // This one's a lot easier than EvaluateString because we don't have to
   // hassle with principals: they're already compiled into the JS function.
   // xxxmarkh - this comment is no longer true - principals are not used at
   // all now, and never were in some cases.
 
   nsCOMPtr<nsIJSContextStack> stack =
     do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
-  if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext)))
+  if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
+    printf("CallEventHandler End  : this:%p, targ:%p\n", this, aTarget);
     return NS_ERROR_FAILURE;
+  }
 
   // check if the event handler can be run on the object in question
   rv = sSecurityManager->CheckFunctionAccess(mContext, aHandler, target);
   if (NS_SUCCEEDED(rv)) {
     // We're not done yet!  Some event listeners are confused about their
     // script context, so check whether we might actually be the wrong script
     // context.  To be safe, do CheckFunctionAccess checks for both.
     nsCOMPtr<nsIContent> content = do_QueryInterface(aTarget);
@@ -1783,16 +1811,17 @@
             if (NS_SUCCEEDED(rv)) {
               rv = sSecurityManager->CheckFunctionAccess(cx, aHandler,
                                                          target);
               // Here we lose no matter what; we don't want to leave the wrong
               // cx on the stack.  I guess default to leaving mContext, to
               // cover those cases when we really do have a different context
               // for the handler and the node.  That's probably safer.
               if (NS_FAILED(stack->Pop(nsnull))) {
+                printf("CallEventHandler End  : this:%p, targ:%p\n", this, aTarget);
                 return NS_ERROR_FAILURE;
               }
             }
           }
         }
       }
     }
   }
@@ -1809,16 +1838,17 @@
     // the safe scope in many cases, which isn't very useful.  Wrapping aTarget
     // was OK because those typically have PreCreate methods that give them the
     // right scope anyway, and we want to make sure that the arguments end up
     // in the same scope as aTarget.
     rv = ConvertSupportsTojsvals(aargv, target, &argc,
                                  NS_REINTERPRET_CAST(void **, &argv), &mark);
     if (NS_FAILED(rv)) {
       stack->Pop(nsnull);
+      printf("CallEventHandler End  : this:%p, targ:%p\n", this, aTarget);
       return rv;
     }
   
     AutoFreeJSStack stackGuard(mContext, mark); // ensure always freed.
 
     jsval funval = OBJECT_TO_JSVAL(aHandler);
     JSAutoRequest ar(mContext);
     PRBool ok = ::JS_CallFunctionValue(mContext, target,
@@ -1834,29 +1864,32 @@
       // Don't pass back results from failed calls.
       rval = JSVAL_VOID;
 
       // Tell the caller that the handler threw an error.
       rv = NS_ERROR_FAILURE;
     }
   }
 
-  if (NS_FAILED(stack->Pop(nsnull)))
+  if (NS_FAILED(stack->Pop(nsnull))) {
+    printf("CallEventHandler End  : this:%p, targ:%p\n", this, aTarget);
     return NS_ERROR_FAILURE;
+  }
 
   // Convert to variant before calling ScriptEvaluated, as it may GC, meaning
   // we would need to root rval.
   JSAutoRequest ar(mContext);
   if (NS_SUCCEEDED(rv)) {
     rv = nsContentUtils::XPConnect()->JSToVariant(mContext, rval, arv);
   }
 
   // ScriptEvaluated needs to come after we pop the stack
   ScriptEvaluated(PR_TRUE);
 
+  printf("CallEventHandler End  : this:%p, targ:%p\n", this, aTarget);
   return rv;
 }
 
 nsresult
 nsJSContext::BindCompiledEventHandler(nsISupports* aTarget, void *aScope,
                                       nsIAtom *aName,
                                       void *aHandler)
 {
