Index: widget/src/gtk2/nsCommonWidget.cpp
===================================================================
--- widget/src/gtk2/nsCommonWidget.cpp.orig
+++ widget/src/gtk2/nsCommonWidget.cpp
@@ -150,16 +150,21 @@
     aEvent.isShift   = (aGdkEvent->state & GDK_SHIFT_MASK)
         ? PR_TRUE : PR_FALSE;
     aEvent.isControl = (aGdkEvent->state & GDK_CONTROL_MASK)
         ? PR_TRUE : PR_FALSE;
     aEvent.isAlt     = (aGdkEvent->state & GDK_MOD1_MASK)
         ? PR_TRUE : PR_FALSE;
     aEvent.isMeta    = (aGdkEvent->state & GDK_MOD4_MASK)
         ? PR_TRUE : PR_FALSE;
+    // The transformations above and in gdk for the keyval are not invertible
+    // so link to the GdkEvent (which will vanish soon after return from the
+    // event callback) to give plugins access to hardware_keycode and state.
+    // (An XEvent would be nice but the GdkEvent is good enough.)
+    aEvent.nativeMsg = (void *)aGdkEvent;
 
     aEvent.time      = aGdkEvent->time;
 }
 
 void
 nsCommonWidget::DispatchGotFocusEvent(void)
 {
     nsGUIEvent event(PR_TRUE, NS_GOTFOCUS, this);
Index: widget/src/gtkxtbin/gtk2xtbin.c
===================================================================
--- widget/src/gtkxtbin/gtk2xtbin.c.orig
+++ widget/src/gtkxtbin/gtk2xtbin.c
@@ -415,21 +415,27 @@
   Arg args[2];
   GtkXtBin *xtbin = GTK_XTBIN (widget);
   GtkAllocation allocation;
 
 #ifdef DEBUG_XTBIN
   printf("gtk_xtbin_resize %p %d %d\n", (void *)widget, width, height);
 #endif
 
+  xtbin->height = height;
+  xtbin->width  = width;
+
+  // Avoid BadValue errors in XtSetValues
+  if (height <= 0 || width <=0) {
+    height = 1;
+    width = 1;
+  }
   XtSetArg(args[0], XtNheight, height);
   XtSetArg(args[1], XtNwidth,  width);
   XtSetValues(xtbin->xtclient.top_widget, args, 2);
-  xtbin->height = height;
-  xtbin->width  = width;
 
   /* we need to send a size allocate so the socket knows about the
      size changes */
   allocation.x = xtbin->x;
   allocation.y = xtbin->y;
   allocation.width = xtbin->width;
   allocation.height = xtbin->height;
 
Index: layout/base/nsLayoutUtils.cpp
===================================================================
--- layout/base/nsLayoutUtils.cpp.orig
+++ layout/base/nsLayoutUtils.cpp
@@ -583,23 +583,23 @@
   nsEvent* event;
   nsresult rv = privateEvent->GetInternalNSEvent(&event);
   if (NS_FAILED(rv))
     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
   return GetEventCoordinatesRelativeTo(event, aFrame);
 }
 
 nsPoint
-nsLayoutUtils::GetEventCoordinatesRelativeTo(nsEvent* aEvent, nsIFrame* aFrame)
+nsLayoutUtils::GetEventCoordinatesRelativeTo(const nsEvent* aEvent, nsIFrame* aFrame)
 {
   if (!aEvent || (aEvent->eventStructType != NS_MOUSE_EVENT && 
                   aEvent->eventStructType != NS_MOUSE_SCROLL_EVENT))
     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 
-  nsGUIEvent* GUIEvent = NS_STATIC_CAST(nsGUIEvent*, aEvent);
+  const nsGUIEvent* GUIEvent = NS_STATIC_CAST(const nsGUIEvent*, aEvent);
   if (!GUIEvent->widget)
     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 
   // If it is, or is a descendant of, an SVG foreignobject frame,
   // then we need to do extra work
   nsIFrame* rootFrame = aFrame;
   for (nsIFrame* f = aFrame; f; f = GetCrossDocParentFrame(f)) {
 #ifdef MOZ_SVG_FOREIGNOBJECT
Index: layout/base/nsLayoutUtils.h
===================================================================
--- layout/base/nsLayoutUtils.h.orig
+++ layout/base/nsLayoutUtils.h
@@ -319,17 +319,17 @@
    * Get the coordinates of a given native mouse event, relative to a given
    * frame.
    * @param aEvent the event
    * @param aFrame the frame to make coordinates relative to
    * @return the point, or (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if
    * for some reason the coordinates for the mouse are not known (e.g.,
    * the event is not a GUI event).
    */
-  static nsPoint GetEventCoordinatesRelativeTo(nsEvent* aEvent,
+  static nsPoint GetEventCoordinatesRelativeTo(const nsEvent* aEvent,
                                                nsIFrame* aFrame);
 
 /**
    * Get the coordinates of a given native mouse event, relative to the nearest 
    * view for a given frame.
    * The "nearest view" is the view returned by nsFrame::GetOffsetFromView.
    * XXX this is extremely BOGUS because "nearest view" is a mess; every
    * use of this method is really a bug!
Index: layout/generic/Makefile.in
===================================================================
--- layout/generic/Makefile.in.orig
+++ layout/generic/Makefile.in
@@ -211,16 +211,20 @@
 		-I$(srcdir)/../tables \
 		-I$(srcdir)/../xul/base/src \
 		-I$(srcdir)/../../content/xul/content/src \
 		-I$(srcdir)/../../content/base/src \
 		-I$(srcdir)/../../content/html/content/src \
 		$(MOZ_CAIRO_CFLAGS) \
 		$(NULL)
 
+ifdef MOZ_ENABLE_GTK2
+CXXFLAGS += $(MOZ_GTK2_CFLAGS)
+endif
+
 libs::
 	$(INSTALL) $(RESOURCES_HTML) $(DIST)/bin/res/html
 	$(INSTALL) $(RESOURCES) $(DIST)/bin/res
 
 install::
 	$(SYSINSTALL) $(IFLAGS1) $(RESOURCES_HTML) $(DESTDIR)$(mozappdir)/res/html
 	$(SYSINSTALL) $(IFLAGS1) $(RESOURCES) $(DESTDIR)$(mozappdir)/res
 
Index: layout/generic/nsObjectFrame.cpp
===================================================================
--- layout/generic/nsObjectFrame.cpp.orig
+++ layout/generic/nsObjectFrame.cpp
@@ -136,20 +136,31 @@
 #endif /* MOZ_LOGGING */
 #include "prlog.h"
 
 #include <errno.h>
 
 #include "nsContentCID.h"
 static NS_DEFINE_CID(kRangeCID, NS_RANGE_CID);
 
+#ifdef MOZ_X11
+#include <X11/Xlib.h>
 /* X headers suck */
+enum { XKeyPress = KeyPress };
 #ifdef KeyPress
 #undef KeyPress
 #endif
+#ifdef MOZ_CAIRO_GFX
+#include "gfxXlibNativeRenderer.h"
+#endif
+#ifdef MOZ_WIDGET_GTK2
+#include <gdk/gdkwindow.h>
+#include <gdk/gdkx.h>
+#endif
+#endif
 
 #ifdef XP_WIN
 #include <wtypes.h>
 #include <winuser.h>
 #endif
 
 #ifdef CreateEvent // Thank you MS.
 #undef CreateEvent
@@ -330,17 +341,24 @@
   NS_IMETHOD DragEnd(nsIDOMEvent* aMouseEvent);
   
 
   nsresult Destroy();  
 
   //nsIEventListener interface
   nsEventStatus ProcessEvent(const nsGUIEvent & anEvent);
   
-  void Paint(const nsRect& aDirtyRect, PRUint32 ndc = 0);
+#ifdef XP_WIN
+  void Paint(const nsRect& aDirtyRect, HDC ndc);
+#elif defined(XP_MACOSX)
+  void Paint(const nsRect& aDirtyRect);
+#elif defined(MOZ_X11)
+  void Paint(nsIRenderingContext& aRenderingContext,
+             const nsRect& aDirtyRect);
+#endif
 
   // nsITimerCallback interface
   NS_DECL_NSITIMERCALLBACK
   
   void CancelTimer();
   void StartTimer(unsigned int aDelay);
 
   // nsIScrollPositionListener interface
@@ -384,20 +402,38 @@
   
   nsPluginDOMContextMenuListener * mCXMenuListener;  // pointer to wrapper for nsIDOMContextMenuListener
   
   nsresult DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent);
   nsresult DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent);
   nsresult DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent);
 
   nsresult EnsureCachedAttrParamArrays();
+
+#if defined(MOZ_X11) && defined(MOZ_CAIRO_GFX)
+  class Renderer : public gfxXlibNativeRenderer {
+  public:
+    Renderer(nsPluginWindow* aWindow, nsIPluginInstance* aInstance,
+             const nsIntRect& aDirtyRect)
+      : mWindow(aWindow), mInstance(aInstance), mDirtyRect(aDirtyRect)
+    {}
+    virtual nsresult NativeDraw(Display* dpy, Drawable drawable, Visual* visual,
+                                short offsetX, short offsetY,
+                                XRectangle* clipRects, PRUint32 numClipRects);
+  private:
+    nsPluginWindow* mWindow;
+    nsIPluginInstance* mInstance;
+    const nsIntRect& mDirtyRect;
+  };
+#endif
+
 };
 
-#if defined(XP_WIN) || (defined(DO_DIRTY_INTERSECT) && defined(XP_MACOSX))
-static void ConvertAppUnitsToPixels(nsPresContext& aPresContext, nsRect& aTwipsRect, nsRect& aPixelRect);
+#if defined(XP_WIN) || (defined(DO_DIRTY_INTERSECT) && defined(XP_MACOSX)) || defined(MOZ_X11)
+static void ConvertAppUnitsToPixels(const nsPresContext& aPresContext, const nsRect& aTwipsRect, nsIntRect& aPixelRect);
 #endif
 
   // Mac specific code to fix up port position and clip during paint
 #ifdef XP_MACOSX
 
 #ifdef DO_DIRTY_INTERSECT
   // convert relative coordinates to absolute
   static void ConvertRelativeToWindowAbsolute(nsIFrame* aFrame, nsPoint& aRel, nsPoint& aAbs, nsIWidget *&aContainerWidget);
@@ -838,16 +874,20 @@
   nsIView * parentWithView;
   nsPoint origin(0,0);
 
   GetOffsetFromView(origin, &parentWithView);
 
   // if it's windowless, let's make sure we have our origin set right
   // it may need to be corrected, like after scrolling
   if (aWindowless && parentWithView) {
+    // XXX Should this be replaced by nsIView::GetNearestWidget?
+    // The implementation below doesn't handle cases where the widget's origin
+    // doesn't coincide with its view's origin.
+
     nsIViewManager* parentVM = parentWithView->GetViewManager();
 
     // Walk up all the views and add up their positions until we
     // reach the first view with a window (non-null widget). This will give us our
     // position relative to the containing window which is what we want to give the plugin
     nsIView* theView = parentWithView;
     while (theView && !theView->GetWidget()) {
       if (theView->GetViewManager() != parentVM)
@@ -907,17 +947,42 @@
   PRBool windowless = (window->type == nsPluginWindowType_Drawable);
 
   nsPoint origin = GetWindowOriginInPixels(windowless);
 
   window->x = origin.x;
   window->y = origin.y;
 
   // refresh the plugin port as well
-  window->window = mInstanceOwner->GetPluginPort();
+#ifdef MOZ_X11
+  if(windowless) {
+    // There is no plugin port window but there are some extra fields to
+    // fill in.
+    nsIWidget* widget = GetWindow();
+    if (widget) {
+      NPSetWindowCallbackStruct* ws_info =
+        NS_STATIC_CAST(NPSetWindowCallbackStruct*, window->ws_info);
+      ws_info->display =
+        NS_STATIC_CAST(Display*, widget->GetNativeData(NS_NATIVE_DISPLAY));
+#ifdef MOZ_WIDGET_GTK2
+      GdkWindow* gdkWindow =
+        NS_STATIC_CAST(GdkWindow*, widget->GetNativeData(NS_NATIVE_WINDOW));
+      GdkColormap* gdkColormap = gdk_drawable_get_colormap(gdkWindow);
+      ws_info->colormap = gdk_x11_colormap_get_xcolormap(gdkColormap);
+      GdkVisual* gdkVisual = gdk_colormap_get_visual(gdkColormap);
+      ws_info->visual = gdk_x11_visual_get_xvisual(gdkVisual);
+      ws_info->depth = gdkVisual->depth;
+#endif
+    }
+  }
+  else
+#endif
+  {
+    window->window = mInstanceOwner->GetPluginPort();
+  }
 
   // this will call pi->SetWindow and take care of window subclassing
   // if needed, see bug 132759
   window->CallSetWindow(pi);
 
   mInstanceOwner->ReleasePluginPort((nsPluginPort *)window->window);
 
   return rv;
@@ -929,17 +994,22 @@
   nsIRenderingContext::AutoPushTranslation translate(aCtx, aPt.x, aPt.y);
   NS_STATIC_CAST(nsObjectFrame*, aFrame)->PrintPlugin(*aCtx, aDirtyRect);
 }
 
 static void PaintPlugin(nsIFrame* aFrame, nsIRenderingContext* aCtx,
                         const nsRect& aDirtyRect, nsPoint aPt)
 {
   nsIRenderingContext::AutoPushTranslation translate(aCtx, aPt.x, aPt.y);
+#ifdef MOZ_X11 // FIXME - Bug 385435: Don't others want this too!
+  nsRect relativeDirtyRect = aDirtyRect - aPt;
+  NS_STATIC_CAST(nsObjectFrame*, aFrame)->PaintPlugin(*aCtx, relativeDirtyRect);
+#else
   NS_STATIC_CAST(nsObjectFrame*, aFrame)->PaintPlugin(*aCtx, aDirtyRect);
+#endif
 }
 
 NS_IMETHODIMP
 nsObjectFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
                                 const nsRect&           aDirtyRect,
                                 const nsDisplayListSet& aLists)
 {
   // XXX why are we painting collapsed object frames?
@@ -1098,16 +1168,25 @@
 nsObjectFrame::PaintPlugin(nsIRenderingContext& aRenderingContext,
                            const nsRect& aDirtyRect)
 {
   // Screen painting code
 #if defined(XP_MACOSX)
   // delegate all painting to the plugin instance.
   if (mInstanceOwner)
       mInstanceOwner->Paint(aDirtyRect);
+#elif defined(MOZ_X11)
+  if (mInstanceOwner)
+    {
+      nsPluginWindow * window;
+      mInstanceOwner->GetWindow(window);
+
+      if (window->type == nsPluginWindowType_Drawable)
+        mInstanceOwner->Paint(aRenderingContext, aDirtyRect);
+    }
 #elif defined (XP_WIN) // || defined(XP_OS2)
   // XXX for OS/2 we need to overhaul this for Cairo builds
   //     for now just ignore plugin stuff
   nsCOMPtr<nsIPluginInstance> inst;
   GetPluginInstance(*getter_AddRefs(inst));
   if (inst) {
     // Look if it's windowless
     nsPluginWindow * window;
@@ -1189,16 +1268,21 @@
            //
            // since the two uses of the rectangle are mutually exclusive in some cases,
            // and since I don't see any incorrect painting (at least with Flash and ViewPoint - the originator of 135737),
            // it seems that windowless plugins are not relying on information here for clipping their drawing,
            // and we can safely use this message to tell the plugin exactly where it is in all cases.
 
               origin = GetWindowOriginInPixels(PR_TRUE);
               nsRect winlessRect = nsRect(origin, nsSize(window->width, window->height));
+              // XXX I don't think we can be certain that the location wrt to
+              // the window only changes when the location wrt to the drawable
+              // changes, but the hdc probably changes on every paint so
+              // doupdatewindow is rarely false, and there is not likely to be
+              // a problem.
               if (mWindowlessRect != winlessRect) {
                 mWindowlessRect = winlessRect;
 
                 WINDOWPOS winpos;
                 memset(&winpos, 0, sizeof(winpos));
                 winpos.x = mWindowlessRect.x;
                 winpos.y = mWindowlessRect.y;
                 winpos.cx = mWindowlessRect.width;
@@ -1213,20 +1297,21 @@
 
                 inst->HandleEvent(&pluginEvent, &eventHandled);
               }
 #endif
 
         inst->SetWindow(window);        
       }
 
+      // FIXME - Bug 385435:
       // This expects a dirty rect relative to the plugin's rect
       // XXX I wonder if this breaks if we give the frame a border so the
       // frame origin and plugin origin are not the same
-      mInstanceOwner->Paint(aDirtyRect, (PRUint32)(HDC)hdc);
+      mInstanceOwner->Paint(aDirtyRect, hdc);
 
 #ifdef MOZ_CAIRO_GFX
       RestoreDC(hdc, -1);
 
       surf->MarkDirty();
 #endif
     }
   }
@@ -1608,25 +1693,16 @@
     mCachedAttrParamValues = nsnull;
   }
 
   if (mTagText) {
     NS_Free(mTagText);
     mTagText = nsnull;
   }
 
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-  // the mem for this struct is allocated
-  // by PR_MALLOC in ns4xPluginInstance.cpp:ns4xPluginInstance::SetWindow()
-  if (mPluginWindow && mPluginWindow->ws_info) {
-    PR_Free(mPluginWindow->ws_info);
-    mPluginWindow->ws_info = nsnull;
-  }
-#endif
-
   // clean up plugin native window object
   nsCOMPtr<nsIPluginHost> ph = do_GetService(kCPluginManagerCID);
   nsCOMPtr<nsPIPluginHost> pph(do_QueryInterface(ph));
   if (pph) {
     pph->DeletePluginNativeWindow(mPluginWindow);
     mPluginWindow = nsnull;
   }
 }
@@ -1884,16 +1960,17 @@
 NS_IMETHODIMP nsPluginInstanceOwner::GetValue(nsPluginInstancePeerVariable variable, void *value)
 {
   nsresult rv = NS_ERROR_FAILURE;
 
   switch(variable) {
     case nsPluginInstancePeerVariable_NetscapeWindow:
     {      
       if (mOwner) {
+#if defined(XP_WIN) || defined(XP_OS2)
         void** pvalue = (void**)value;
         nsIViewManager* vm = mOwner->PresContext()->GetViewManager();
         if (vm) {
 #if defined(XP_WIN)
           // This property is provided to allow a "windowless" plugin to determine the window it is drawing
           // in, so it can translate mouse coordinates it receives directly from the operating system
           // to coordinates relative to itself.
         
@@ -1907,17 +1984,16 @@
           // of confusing a plugin that is using this HWND for illicit purposes, but since the documentation
           // does not suggest this HWND IS that of the document window, rather that of the window
           // the plugin is drawn in, this seems like a safe fix.
          
           // we only attempt to get the nearest window if this really is a "windowless" plugin so as not
           // to change any behaviour for the much more common windowed plugins,
           // though why this method would even be being called for a windowed plugin escapes me.
           if (mPluginWindow && mPluginWindow->type == nsPluginWindowType_Drawable) {
-            if (mOwner) {
               // it turns out that flash also uses this window for determining focus, and is currently
               // unable to show a caret correctly if we return the enclosing window. Therefore for
               // now we only return the enclosing window when there is an actual offset which
               // would otherwise cause coordinates to be offset incorrectly. (i.e.
               // if the enclosing window if offset from the document window)
               //
               // fixing both the caret and ability to interact issues for a windowless control in a non document aligned windw
               // does not seem to be possible without a change to the flash plugin
@@ -1934,26 +2010,38 @@
                 if (offset.x || offset.y) {
                   // in the case the two windows are offset from eachother, we do go ahead and return the correct enclosing window
                   // so that mouse co-ordinates are not messed up.
                   *pvalue = (void*)win->GetNativeData(NS_NATIVE_WINDOW);
                   if (*pvalue)
                     return NS_OK;
                 }
               }
-            }
           }
 #endif
           // simply return the document window
           nsCOMPtr<nsIWidget> widget;
           rv = vm->GetWidget(getter_AddRefs(widget));            
           if (widget) {
             *pvalue = (void*)widget->GetNativeData(NS_NATIVE_WINDOW);
           } else NS_ASSERTION(widget, "couldn't get doc's widget in getting doc's window handle");
         } else NS_ASSERTION(vm, "couldn't get view manager in getting doc's window handle");
+#elif defined(MOZ_WIDGET_GTK2)
+        // X11 window managers want the toplevel window for WM_TRANSIENT_FOR.
+        nsIWidget* win = mOwner->GetWindow();
+        if (!win)
+          return rv;
+        GdkWindow* gdkWindow =
+          NS_STATIC_CAST(GdkWindow*, win->GetNativeData(NS_NATIVE_WINDOW));
+        if (!gdkWindow)
+          return rv;
+        gdkWindow = gdk_window_get_toplevel(gdkWindow);
+        *NS_STATIC_CAST(Window*, value) = GDK_WINDOW_XID(gdkWindow);
+        return NS_OK;
+#endif
       } else NS_ASSERTION(mOwner, "plugin owner has no owner in getting doc's window handle");
       break;
     }
   }
 
   return rv;
 }
 
@@ -3002,22 +3090,33 @@
 }
 
 nsresult
 nsPluginInstanceOwner::HandleEvent(nsIDOMEvent* aEvent)
 {
   return NS_OK;
 }
 
+#ifdef MOZ_X11
+static unsigned int XInputEventState(const nsInputEvent& anEvent)
+{
+  unsigned int state = 0;
+  if(anEvent.isShift) state |= ShiftMask;
+  if(anEvent.isControl) state |= ControlMask;
+  if(anEvent.isAlt) state |= Mod1Mask;
+  if(anEvent.isMeta) state |= Mod4Mask;
+  return state;
+}
+#endif
 
 nsEventStatus nsPluginInstanceOwner::ProcessEvent(const nsGUIEvent& anEvent)
 {
   // printf("nsGUIEvent.message: %d\n", anEvent.message);
   nsEventStatus rv = nsEventStatus_eIgnore;
-  if (!mInstance)   // if mInstance is null, we shouldn't be here
+  if (!mInstance || !mOwner)   // if mInstance is null, we shouldn't be here
     return rv;
 
 #ifdef XP_MACOSX
   // check for null mWidget
   if (mWidget) {
     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
       EventRecord macEvent;
@@ -3083,16 +3182,208 @@
   if (pPluginEvent) {
     PRBool eventHandled = PR_FALSE;
     mInstance->HandleEvent(pPluginEvent, &eventHandled);
     if (eventHandled)
       rv = nsEventStatus_eConsumeNoDefault;
   }
 #endif
 
+#ifdef MOZ_X11
+  // this code supports windowless plugins
+  nsIWidget* widget = anEvent.widget;
+  nsPluginEvent pluginEvent;
+  pluginEvent.event.type = 0;
+
+  switch(anEvent.eventStructType)
+    {
+    case NS_MOUSE_EVENT:
+      {
+        switch (anEvent.message)
+          {
+          case NS_MOUSE_CLICK:
+          case NS_MOUSE_DOUBLECLICK:
+            // Button up/down events sent instead.
+            return rv;
+          }
+
+        // Get reference point relative to plugin origin.
+        const nsPresContext* presContext = mOwner->PresContext();
+        nsPoint appPoint =
+          nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mOwner);
+        nsIntPoint pluginPoint(presContext->AppUnitsToDevPixels(appPoint.x),
+                               presContext->AppUnitsToDevPixels(appPoint.y));
+        const nsMouseEvent& mouseEvent =
+          NS_STATIC_CAST(const nsMouseEvent&, anEvent);
+        // Get reference point relative to screen:
+        nsRect windowRect(anEvent.refPoint, nsSize(1, 1));
+        nsRect rootPoint(-1,-1,1,1);
+        if (widget)
+          widget->WidgetToScreen(windowRect, rootPoint);
+#ifdef MOZ_WIDGET_GTK2
+        Window root = GDK_ROOT_WINDOW();
+#else
+        Window root = None; // Could XQueryTree, but this is not important.
+#endif
+
+        switch (anEvent.message)
+          {
+          case NS_MOUSE_ENTER_SYNTH:
+          case NS_MOUSE_EXIT_SYNTH:
+            {
+              XCrossingEvent& event = pluginEvent.event.xcrossing;
+              event.type = anEvent.message == NS_MOUSE_ENTER_SYNTH ?
+                EnterNotify : LeaveNotify;
+              event.root = root;
+              event.time = anEvent.time;
+              event.x = pluginPoint.x;
+              event.y = pluginPoint.y;
+              event.x_root = rootPoint.x;
+              event.y_root = rootPoint.y;
+              event.state = XInputEventState(mouseEvent);
+              // information lost
+              event.subwindow = None;
+              event.mode = -1;
+              event.detail = NotifyDetailNone;
+              event.same_screen = True;
+              event.focus = mContentFocused;
+            }
+            break;
+          case NS_MOUSE_MOVE:
+            {
+              XMotionEvent& event = pluginEvent.event.xmotion;
+              event.type = MotionNotify;
+              event.root = root;
+              event.time = anEvent.time;
+              event.x = pluginPoint.x;
+              event.y = pluginPoint.y;
+              event.x_root = rootPoint.x;
+              event.y_root = rootPoint.y;
+              event.state = XInputEventState(mouseEvent);
+              // information lost
+              event.subwindow = None;
+              event.is_hint = NotifyNormal;
+              event.same_screen = True;
+            }
+            break;
+          case NS_MOUSE_BUTTON_DOWN:
+          case NS_MOUSE_BUTTON_UP:
+            {
+              XButtonEvent& event = pluginEvent.event.xbutton;
+              event.type = anEvent.message == NS_MOUSE_BUTTON_DOWN ?
+                ButtonPress : ButtonRelease;
+              event.root = root;
+              event.time = anEvent.time;
+              event.x = pluginPoint.x;
+              event.y = pluginPoint.y;
+              event.x_root = rootPoint.x;
+              event.y_root = rootPoint.y;
+              event.state = XInputEventState(mouseEvent);
+              switch (mouseEvent.button)
+                {
+                case nsMouseEvent::eMiddleButton:
+                  event.button = 2;
+                  break;
+                case nsMouseEvent::eRightButton:
+                  event.button = 3;
+                  break;
+                default: // nsMouseEvent::eLeftButton;
+                  event.button = 1;
+                  break;
+                }
+              // information lost:
+              event.subwindow = None;
+              event.same_screen = True;
+            }
+            break;
+          }
+      }
+      break;
+
+   //XXX case NS_MOUSE_SCROLL_EVENT: not received.
+
+   case NS_KEY_EVENT:
+      if (anEvent.nativeMsg)
+        {
+          XKeyEvent &event = pluginEvent.event.xkey;
+#ifdef MOZ_WIDGET_GTK2
+          event.root = GDK_ROOT_WINDOW();
+          event.time = anEvent.time;
+          const GdkEventKey* gdkEvent =
+            NS_STATIC_CAST(const GdkEventKey*, anEvent.nativeMsg);
+          event.keycode = gdkEvent->hardware_keycode;
+          event.state = gdkEvent->state;
+          switch (anEvent.message)
+            {
+            case NS_KEY_DOWN:
+              event.type = XKeyPress;
+              break;
+            case NS_KEY_UP:
+              event.type = KeyRelease;
+              break;
+            }
+#endif
+          // Information that could be obtained from nativeMsg but we may not
+          // want to promise to provide:
+          event.subwindow = None;
+          event.x = 0;
+          event.y = 0;
+          event.x_root = -1;
+          event.y_root = -1;
+          event.same_screen = False;
+        }
+      else
+        {
+          // If we need to send synthesized key events, then
+          // DOMKeyCodeToGdkKeyCode(keyEvent.keyCode) and
+          // gdk_keymap_get_entries_for_keyval will be useful, but the
+          // mappings will not be unique.
+          NS_WARNING("Synthesized key event not sent to plugin");
+        }
+      break;
+
+    default:
+      switch (anEvent.message)
+        {
+        case NS_FOCUS_CONTENT:
+        case NS_BLUR_CONTENT:
+          {
+            XFocusChangeEvent &event = pluginEvent.event.xfocus;
+            event.type =
+              anEvent.message == NS_FOCUS_CONTENT ? FocusIn : FocusOut;
+            // information lost:
+            event.mode = -1;
+            event.detail = NotifyDetailNone;
+          }
+          break;
+        }
+    }
+
+  if (!pluginEvent.event.type) {
+    PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
+           ("Unhandled event message %d with struct type %d\n",
+            anEvent.message, anEvent.eventStructType));
+    return rv;
+  }
+
+  // Fill in (useless) generic event information.
+  XAnyEvent& event = pluginEvent.event.xany;
+  event.display = widget ?
+    NS_STATIC_CAST(Display*, widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull;
+  event.window = None; // not a real window
+  // information lost:
+  event.serial = 0;
+  event.send_event = False;
+
+  PRBool eventHandled = PR_FALSE;
+  mInstance->HandleEvent(&pluginEvent, &eventHandled);
+  if (eventHandled)
+      rv = nsEventStatus_eConsumeNoDefault;
+#endif
+
   return rv;
 }
 
 nsresult
 nsPluginInstanceOwner::Destroy()
 {
   // stop the timer explicitly to reduce reference count.
   CancelTimer();
@@ -3144,36 +3435,36 @@
 
   mOwner = nsnull; // break relationship between frame and plugin instance owner
 
   return NS_OK;
 }
 
 // Paints are handled differently, so we just simulate an update event.
 
-void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect, PRUint32 ndc)
+#ifdef XP_MACOSX
+void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect)
 {
   if (!mInstance || !mOwner)
     return;
  
-#ifdef XP_MACOSX
 #ifdef DO_DIRTY_INTERSECT   // aDirtyRect isn't always correct, see bug 56128
   nsPoint rel(aDirtyRect.x, aDirtyRect.y);
   nsPoint abs(0,0);
   nsCOMPtr<nsIWidget> containerWidget;
 
   // Convert dirty rect relative coordinates to absolute and also get the containerWidget
   ConvertRelativeToWindowAbsolute(mOwner, rel, abs, *getter_AddRefs(containerWidget));
 
   nsRect absDirtyRect = nsRect(abs.x, abs.y, aDirtyRect.width, aDirtyRect.height);
 
   // Convert to absolute pixel values for the dirty rect
-  nsRect absDirtyRectInPixels;
+  nsIntRect absDirtyRectInPixels;
   ConvertAppUnitsToPixels(*mOwner->GetPresContext(), absDirtyRect,
-                       absDirtyRectInPixels);
+                          absDirtyRectInPixels);
 #endif
 
   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
   if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
     WindowRef window = FixUpPluginWindow(ePluginPaintEnable);
     if (window) {
       EventRecord updateEvent;
       InitializeEventRecord(&updateEvent);
@@ -3181,23 +3472,29 @@
       updateEvent.message = UInt32(window);
     
       nsPluginEvent pluginEvent = { &updateEvent, nsPluginPlatformWindowRef(window) };
       PRBool eventHandled = PR_FALSE;
       mInstance->HandleEvent(&pluginEvent, &eventHandled);
     }
     pluginWidget->EndDrawPlugin();
   }
+}
 #endif
 
 #ifdef XP_WIN
+void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect, HDC ndc)
+{
+  if (!mInstance || !mOwner)
+    return;
+
   nsPluginWindow * window;
   GetWindow(window);
   nsRect relDirtyRect = nsRect(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
-  nsRect relDirtyRectInPixels;
+  nsIntRect relDirtyRectInPixels;
   ConvertAppUnitsToPixels(*mOwner->PresContext(), relDirtyRect,
                           relDirtyRectInPixels);
 
   // we got dirty rectangle in relative window coordinates, but we
   // need it in absolute units and in the (left, top, right, bottom) form
   RECT drc;
   drc.left   = relDirtyRectInPixels.x + window->x;
   drc.top    = relDirtyRectInPixels.y + window->y;
@@ -3205,19 +3502,206 @@
   drc.bottom = drc.top + relDirtyRectInPixels.height;
 
   nsPluginEvent pluginEvent;
   pluginEvent.event = WM_PAINT;
   pluginEvent.wParam = (uint32)ndc;
   pluginEvent.lParam = (uint32)&drc;
   PRBool eventHandled = PR_FALSE;
   mInstance->HandleEvent(&pluginEvent, &eventHandled);
+}
 #endif
+
+#if defined(MOZ_X11)
+static void PaintX11Plugin(nsPluginWindow* aWindow,
+                           nsIPluginInstance* aInstance,
+                           Display* aDisplay,
+                           Drawable aDrawable,
+#ifdef MOZ_CAIRO_GFX
+                           const Visual* aVisual,
+                           short aOffsetX, short aOffsetY,
+                           const XRectangle& aClipRect,
+                           PRUint32 aHaveClip,
+#else
+                           nscoord aOffsetX, nscoord aOffsetY,
+                           const nsRect& aClipRect,
+                           PRBool aHaveClip,
+#endif
+                           const nsIntRect& aDirtyRect)
+{
+  // See if the plugin must be notified of new window parameters.
+  PRBool doupdatewindow = PR_FALSE;
+
+  if (aWindow->x != aOffsetX || aWindow->y != aOffsetY) {
+    aWindow->x = aOffsetX;
+    aWindow->y = aOffsetY;
+    doupdatewindow = PR_TRUE;
+  }
+
+  nsPluginRect newClipRect;
+  if(aHaveClip) {
+    newClipRect.left = aClipRect.x;
+    newClipRect.top = aClipRect.y;
+    newClipRect.right  = aClipRect.x + aClipRect.width;
+    newClipRect.bottom = aClipRect.y + aClipRect.height;
+  }
+  else {
+    // We should have been given a clip if an offset is -ve.
+    NS_ASSERTION(aOffsetX >= 0 && aOffsetY >= 0,
+                 "Clip rectangle offsets are negative!");
+    newClipRect.left = aOffsetX;
+    newClipRect.top  = aOffsetY;
+    newClipRect.right  = aOffsetX + aWindow->width;
+    newClipRect.bottom = aOffsetY + aWindow->height;
+  }
+
+  if (aWindow->clipRect.left    != newClipRect.left   ||
+      aWindow->clipRect.top     != newClipRect.top    ||
+      aWindow->clipRect.right   != newClipRect.right  ||
+      aWindow->clipRect.bottom  != newClipRect.bottom) {
+    aWindow->clipRect = newClipRect;
+    doupdatewindow = PR_TRUE;
+  }
+
+#ifdef MOZ_CAIRO_GFX
+  NPSetWindowCallbackStruct* ws_info =
+    NS_STATIC_CAST(NPSetWindowCallbackStruct*, aWindow->ws_info);
+  if ( ws_info->visual != visual) {
+    // NPAPI needs a colormap but the surface doesn't provide a colormap.  If
+    // gfxContent::CurrentSurface is a gfxXlibSurface then the visual here
+    // should be derived from that of the window and so the colormap of the
+    // window should be fine.  For other surfaces I don't know what to use.
+    NS_ASSERTION(ws_info->visual == visual,
+                 "Visual changed: colormap may not match");
+    ws_info->visual = visual;
+    doupdatewindow = PR_TRUE;
+  }
+#endif
+
+  if (doupdatewindow)
+      aInstance->SetWindow(aWindow);
+
+  nsPluginEvent pluginEvent;
+  XGraphicsExposeEvent& exposeEvent = pluginEvent.event.xgraphicsexpose;
+  // set the drawing info
+  exposeEvent.type = GraphicsExpose;
+  exposeEvent.display = aDisplay;
+  exposeEvent.drawable = aDrawable;
+  exposeEvent.x = aDirtyRect.x + aWindow->x;
+  exposeEvent.y = aDirtyRect.y + aWindow->y;
+  exposeEvent.width  = aDirtyRect.width;
+  exposeEvent.height = aDirtyRect.height;
+  exposeEvent.count = 0;
+  // information not set:
+  exposeEvent.serial = 0;
+  exposeEvent.send_event = False;
+  exposeEvent.major_code = 0;
+  exposeEvent.minor_code = 0;
+
+  PRBool eventHandled = PR_FALSE;
+  aInstance->HandleEvent(&pluginEvent, &eventHandled);
 }
 
+#ifdef MOZ_CAIRO_GFX
+nsresult
+nsPluginInstanceOwner::Renderer::NativeDraw(Display* dpy, Drawable drawable,
+                                            Visual* visual,
+                                            short offsetX, short offsetY,
+                                            XRectangle* clipRects,
+                                            PRUint32 numClipRects)
+{
+  NS_ASSERTION(numClipRects <= 1, "We don't support multiple clip rectangles!");
+
+  PaintX11Plugin(mWindow, mInstance, dpy, drawable, visual, offsetX, offsetY,
+                 clipRects[0], numClipRects, mDirtyRect);
+
+  return NS_OK;
+}
+#endif // MOZ_CAIRO_GFX
+
+void nsPluginInstanceOwner::Paint(nsIRenderingContext& aRenderingContext,
+                                  const nsRect& aDirtyRect)
+{
+  if (!mInstance || !mOwner)
+    return;
+
+  nsPluginWindow* window;
+  GetWindow(window);
+
+  nsIntRect dirtyRectInPixels;
+  ConvertAppUnitsToPixels(*mOwner->PresContext(), aDirtyRect,
+                          dirtyRectInPixels);
+  // Sanitize the dirty rect so we don't tell plugins that the area outside
+  // the plugin rectangle needs updating.
+  nsIntRect pluginDirtyRect;
+  if (!pluginDirtyRect.IntersectRect(nsIntRect(0, 0, window->width, window->height), dirtyRectInPixels))
+    return;
+
+#ifdef MOZ_CAIRO_GFX
+  Renderer renderer(window, mInstance, pluginDirtyRect);
+  PRUint32 rendererFlags =
+    Renderer::DRAW_SUPPORTS_OFFSET |
+    Renderer::DRAW_SUPPORTS_CLIP_RECT |
+    Renderer::DRAW_SUPPORTS_NONDEFAULT_VISUAL |
+    Renderer::DRAW_SUPPORTS_ALTERNATE_DISPLAY;
+
+  PRBool transparent = PR_TRUE;
+  mInstance->GetValue(nsPluginInstanceVariable_TransparentBool,
+                      (void *)&transparent);
+  if (!transparent)
+    rendererFlags |= Renderer::DRAW_IS_OPAQUE;
+
+  gfxContext* ctx =
+    NS_STATIC_CAST(gfxContext*,
+                   aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT));
+
+  // The display used by gfxXlibNativeRenderer will be the one for the cairo
+  // surface (provided that it is an Xlib surface) but the display argument
+  // here needs to be non-NULL for cairo_draw_with_xlib ->
+  // _create_temp_xlib_surface -> DefaultScreen(dpy).
+  NPSetWindowCallbackStruct* ws_info =
+    static_cast<NPSetWindowCallbackStruct*>(window->ws_info);
+  renderer.Draw(ws_info->display, ctx, window->width, window->height,
+                rendererFlags, nsnull);
+
+#elif defined(MOZ_WIDGET_GTK2)
+
+  GdkDrawable* gdkDrawable = static_cast<GdkDrawable*>
+    (aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_GDK_DRAWABLE));
+  Drawable drawable = GDK_DRAWABLE_XID(gdkDrawable);
+  Display* display = GDK_DRAWABLE_XDISPLAY(gdkDrawable);
+
+  // We could update colormap/visual/depth but they don't change.
+#ifdef DEBUG
+  GdkColormap* gdkColormap = gdk_drawable_get_colormap(gdkDrawable);
+  Colormap colormap = GDK_COLORMAP_XCOLORMAP(gdkColormap);
+  NPSetWindowCallbackStruct* ws_info =
+    static_cast<NPSetWindowCallbackStruct*>(window->ws_info);
+  NS_ASSERTION(ws_info->colormap == colormap, "Unexpected colormap change.");
+#endif
+
+  nsTransform2D* rcTransform;
+  aRenderingContext.GetCurrentTransform(rcTransform);
+  nsPoint offset;
+  rcTransform->GetTranslationCoord(&offset.x, &offset.y);
+
+  nsRect clipRect;
+  PRBool isNonEmpty;
+  PRBool haveClip =
+    NS_SUCCEEDED(aRenderingContext.GetClipRect(clipRect, isNonEmpty));
+  if (haveClip && !isNonEmpty)
+    return;
+
+  PaintX11Plugin(window, mInstance, display, drawable, offset.x, offset.y,
+                 clipRect, haveClip, pluginDirtyRect);
+#endif // MOZ_CAIRO_GFX/MOZ_WIDGET_GTK2
+}
+
+#endif // MOZ_X11
+
 // Here's how we give idle time to plugins.
 
 NS_IMETHODIMP nsPluginInstanceOwner::Notify(nsITimer* /* timer */)
 {
 #ifdef XP_MACOSX
     // validate the plugin clipping information by syncing the plugin window info to
     // reflect the current widget location. This makes sure that everything is updated
     // correctly in the event of scrolling in the window.
@@ -3425,19 +3909,19 @@
   return rv;
 }
 
 void nsPluginInstanceOwner::SetPluginHost(nsIPluginHost* aHost)
 {
   mPluginHost = aHost;
 }
 
-#if defined(XP_WIN) || (defined(DO_DIRTY_INTERSECT) && defined(XP_MACOSX))
+#if defined(XP_WIN) || (defined(DO_DIRTY_INTERSECT) && defined(XP_MACOSX)) || defined(MOZ_X11)
 // convert frame coordinates from twips to pixels
-static void ConvertAppUnitsToPixels(nsPresContext& aPresContext, nsRect& aTwipsRect, nsRect& aPixelRect)
+static void ConvertAppUnitsToPixels(const nsPresContext& aPresContext, const nsRect& aTwipsRect, nsIntRect& aPixelRect)
 {
   aPixelRect.x = aPresContext.AppUnitsToDevPixels(aTwipsRect.x);
   aPixelRect.y = aPresContext.AppUnitsToDevPixels(aTwipsRect.y);
   aPixelRect.width = aPresContext.AppUnitsToDevPixels(aTwipsRect.width);
   aPixelRect.height = aPresContext.AppUnitsToDevPixels(aTwipsRect.height);
 }
 #endif
 
Index: modules/plugin/base/public/npapi.h
===================================================================
--- modules/plugin/base/public/npapi.h.orig
+++ modules/plugin/base/public/npapi.h
@@ -431,17 +431,19 @@
   NPNVDOMWindow      = (12 | NP_ABI_MASK),
   NPNVToolkit        = (13 | NP_ABI_MASK),
   NPNVSupportsXEmbedBool = 14,
 
   /* Get the NPObject wrapper for the browser window. */
   NPNVWindowNPObject = 15,
 
   /* Get the NPObject wrapper for the plugins DOM element. */
-  NPNVPluginElementNPObject = 16
+  NPNVPluginElementNPObject = 16,
+
+  NPNVSupportsWindowless = 17
 
 #ifdef XP_MACOSX
   /* Used for negotiating drawing models */
   , NPNVpluginDrawingModel = 1000
 #ifndef NP_NO_QUICKDRAW
   , NPNVsupportsQuickDrawBool = 2000
 #endif
   , NPNVsupportsCoreGraphicsBool = 2001
Index: modules/plugin/base/public/npupp.h
===================================================================
--- modules/plugin/base/public/npupp.h.orig
+++ modules/plugin/base/public/npupp.h
@@ -618,16 +618,28 @@
 #else
 #if defined(__OS2__)
 #define OSCALL _System
 #else
 #define OSCALL
 #endif
 #endif
 
+#if defined(XP_UNIX)
+/* GCC 3.3 and later support the visibility attribute. */
+#if defined(__GNUC__) && \
+    ((__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3))
+#define NP_VISIBILITY_DEFAULT __attribute__((visibility("default")))
+#else
+#define NP_VISIBILITY_DEFAULT
+#endif
+
+#define NP_EXPORT(__type) NP_VISIBILITY_DEFAULT __type
+#endif
+
 #if defined( _WINDOWS ) || defined (__OS2__)
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* plugin meta member functions */
 #if defined(__OS2__)
@@ -667,20 +679,20 @@
 #ifdef XP_UNIX
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* plugin meta member functions */
 
-char*	NP_GetMIMEDescription(void);
-NPError	NP_Initialize(NPNetscapeFuncs*, NPPluginFuncs*);
-NPError	NP_Shutdown(void);
-NPError NP_GetValue(void *future, NPPVariable aVariable, void *aValue);
+NP_EXPORT(char*)   NP_GetMIMEDescription(void);
+NP_EXPORT(NPError) NP_Initialize(NPNetscapeFuncs*, NPPluginFuncs*);
+NP_EXPORT(NPError) NP_Shutdown(void);
+NP_EXPORT(NPError) NP_GetValue(void *future, NPPVariable aVariable, void *aValue);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* XP_UNIX */
 
 #endif /* _NPUPP_H_ */
Index: modules/plugin/base/src/ns4xPlugin.cpp
===================================================================
--- modules/plugin/base/src/ns4xPlugin.cpp.orig
+++ modules/plugin/base/src/ns4xPlugin.cpp
@@ -95,89 +95,89 @@
 static NS_DEFINE_IID(kMemoryCID, NS_MEMORY_CID);
 
 PR_BEGIN_EXTERN_C
 
   ////////////////////////////////////////////////////////////////////////
   // Static stub functions that are exported to the 4.x plugin as entry
   // points via the CALLBACKS variable.
   //
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _requestread(NPStream *pstream, NPByteRange *rangeList);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _geturlnotify(NPP npp, const char* relativeURL, const char* target,
                 void* notifyData);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _getvalue(NPP npp, NPNVariable variable, void *r_value);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _setvalue(NPP npp, NPPVariable variable, void *r_value);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _geturl(NPP npp, const char* relativeURL, const char* target);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _posturlnotify(NPP npp, const char* relativeURL, const char *target,
                  uint32 len, const char *buf, NPBool file, void* notifyData);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _posturl(NPP npp, const char* relativeURL, const char *target, uint32 len,
               const char *buf, NPBool file);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _newstream(NPP npp, NPMIMEType type, const char* window, NPStream** pstream);
 
-  static int32 NP_EXPORT
+  static int32 NP_CALLBACK
   _write(NPP npp, NPStream *pstream, int32 len, void *buffer);
 
-  static NPError NP_EXPORT
+  static NPError NP_CALLBACK
   _destroystream(NPP npp, NPStream *pstream, NPError reason);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _status(NPP npp, const char *message);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _memfree (void *ptr);
 
-  static uint32 NP_EXPORT
+  static uint32 NP_CALLBACK
   _memflush(uint32 size);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _reloadplugins(NPBool reloadPages);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _invalidaterect(NPP npp, NPRect *invalidRect);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _invalidateregion(NPP npp, NPRegion invalidRegion);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _forceredraw(NPP npp);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _pushpopupsenabledstate(NPP npp, NPBool enabled);
 
-  static void NP_EXPORT
+  static void NP_CALLBACK
   _poppopupsenabledstate(NPP npp);
 
-  static const char* NP_EXPORT
+  static const char* NP_CALLBACK
   _useragent(NPP npp);
 
-  static void* NP_EXPORT
+  static void* NP_CALLBACK
   _memalloc (uint32 size);
 
 #ifdef OJI
-  static JRIEnv* NP_EXPORT
+  static JRIEnv* NP_CALLBACK
   _getJavaEnv(void);
 
 #if 1
 
-  static jref NP_EXPORT
+  static jref NP_CALLBACK
   _getJavaPeer(NPP npp);
 
 #endif
 #endif /* OJI */
 
 PR_END_EXTERN_C
 
 #if defined(XP_MACOSX) && defined(__POWERPC__)
@@ -958,17 +958,17 @@
   return NPERR_NO_ERROR;
 }
 
 ////////////////////////////////////////////////////////////////////////
 //
 // Static callbacks that get routed back through the new C++ API
 //
 
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _geturl(NPP npp, const char* relativeURL, const char* target)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
    relativeURL));
 
   // Block Adobe Acrobat from loading URLs that are not http:, https:,
   // or ftp: URLs if the given target is null.
@@ -986,49 +986,49 @@
   }
 
   return MakeNew4xStreamInternal (npp, relativeURL, target,
                                   eNPPStreamTypeInternal_Get);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _geturlnotify(NPP npp, const char* relativeURL, const char* target,
               void* notifyData)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
     ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
      target, notifyData, relativeURL));
 
   return MakeNew4xStreamInternal (npp, relativeURL, target,
                                   eNPPStreamTypeInternal_Get, PR_TRUE,
                                   notifyData);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _posturlnotify(NPP npp, const char *relativeURL, const char *target,
                uint32 len, const char *buf, NPBool file, void *notifyData)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
                   "notify=%p, url=%s, buf=%s\n",
                   (void*)npp, target, len, file, notifyData, relativeURL,
                   buf));
 
   return MakeNew4xStreamInternal(npp, relativeURL, target,
                                  eNPPStreamTypeInternal_Post, PR_TRUE,
                                  notifyData, len, buf, file);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _posturl(NPP npp, const char *relativeURL, const char *target,
          uint32 len, const char *buf, NPBool file)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
                   "buf=%s\n",
                   (void*)npp, target, file, len, relativeURL, buf));
 
@@ -1083,17 +1083,17 @@
 ns4xStreamWrapper::GetStream(nsIOutputStream* &result)
 {
   result = fStream;
   NS_IF_ADDREF(fStream);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
    (const char *)type, target));
 
   NPError err = NPERR_INVALID_INSTANCE_ERROR;
   if (npp && npp->ndata) {
@@ -1115,17 +1115,17 @@
       err = NPERR_GENERIC_ERROR;
     }
   }
   return err;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-int32 NP_EXPORT
+int32 NP_CALLBACK
 _write(NPP npp, NPStream *pstream, int32 len, void *buffer)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
                   pstream->url, len, (char*)buffer));
 
   // negative return indicates failure to the plugin
   if (!npp)
@@ -1147,17 +1147,17 @@
   if (rv != NS_OK)
     return -1;
 
   return (int32)count;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _destroystream(NPP npp, NPStream *pstream, NPError reason)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
                   pstream->url, (int)reason));
 
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
@@ -1188,17 +1188,17 @@
     pstream->ndata = nsnull;
   }
 
   return NPERR_NO_ERROR;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _status(NPP npp, const char *message)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_Status: npp=%p, message=%s\n",
                                      (void*)npp, message));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_status: npp or npp->ndata == 0");
     return;
@@ -1209,52 +1209,52 @@
   nsCOMPtr<nsIPluginInstancePeer> peer;
   if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
     peer->ShowStatus(message);
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _memfree (void *ptr)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
 
   if (ptr)
     nsMemory::Free(ptr);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-uint32 NP_EXPORT
+uint32 NP_CALLBACK
 _memflush(uint32 size)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
 
   nsMemory::HeapMinimize(PR_TRUE);
   return 0;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _reloadplugins(NPBool reloadPages)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
 
   nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
 
   pm->ReloadPlugins(reloadPages);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _invalidaterect(NPP npp, NPRect *invalidRect)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
                   "right=%d\n", (void *)npp, invalidRect->top,
                   invalidRect->left, invalidRect->bottom, invalidRect->right));
 
   if (!npp || !npp->ndata) {
@@ -1271,17 +1271,17 @@
       // XXX nsRect & NPRect are structurally equivalent
       wpeer->InvalidateRect((nsPluginRect *)invalidRect);
     }
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _invalidateregion(NPP npp, NPRegion invalidRegion)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
                   (void*)invalidRegion));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
@@ -1297,17 +1297,17 @@
       // nsPluginRegion & NPRegion are typedef'd to the same thing
       wpeer->InvalidateRegion((nsPluginRegion)invalidRegion);
     }
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void NP_EXPORT
+void NP_CALLBACK
 _forceredraw(NPP npp)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_ForceDraw: npp=%p\n", (void*)npp));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_forceredraw: npp or npp->ndata == 0");
     return;
   }
@@ -1348,29 +1348,29 @@
   NS_ENSURE_TRUE(sgo, nsnull);
 
   nsIScriptContext *scx = sgo->GetContext();
   NS_ENSURE_TRUE(scx, nsnull);
 
   return (JSContext *)scx->GetNativeContext();
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getwindowobject(NPP npp)
 {
   JSContext *cx = GetJSContextFromNPP(npp);
   NS_ENSURE_TRUE(cx, nsnull);
 
   // Using ::JS_GetGlobalObject(cx) is ok here since the window we
   // want to return here is the outer window, *not* the inner (since
   // we don't know what the plugin will do with it).
   return nsJSObjWrapper::GetNewOrUsed(npp, cx, ::JS_GetGlobalObject(cx));
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getpluginelement(NPP npp)
 {
   nsIDOMElement *elementp = nsnull;
   NPError nperr = _getvalue(npp, NPNVDOMElement, &elementp);
 
   if (nperr != NPERR_NO_ERROR) {
     return nsnull;
   }
@@ -1407,34 +1407,34 @@
                                        utf16name.Length());
 
   if (!str)
     return nsnull;
 
   return (NPIdentifier)STRING_TO_JSVAL(str);
 }
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getstringidentifier(const NPUTF8* name)
 {
   nsCOMPtr<nsIThreadJSContextStack> stack =
     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
   if (!stack)
     return NULL;
 
   JSContext *cx = nsnull;
   stack->GetSafeJSContext(&cx);
   if (!cx)
     return NULL;
 
   JSAutoRequest ar(cx);
   return doGetIdentifier(cx, name);
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
                       NPIdentifier *identifiers)
 {
   nsCOMPtr<nsIThreadJSContextStack> stack =
     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
   if (!stack)
     return;
 
@@ -1445,23 +1445,23 @@
 
   JSAutoRequest ar(cx);
 
   for (int32_t i = 0; i < nameCount; ++i) {
     identifiers[i] = doGetIdentifier(cx, names[i]);
   }
 }
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getintidentifier(int32_t intid)
 {
   return (NPIdentifier)INT_TO_JSVAL(intid);
 }
 
-NPUTF8* NP_EXPORT
+NPUTF8* NP_CALLBACK
 _utf8fromidentifier(NPIdentifier identifier)
 {
   if (!identifier)
     return NULL;
 
   jsval v = (jsval)identifier;
 
   if (!JSVAL_IS_STRING(v)) {
@@ -1470,37 +1470,37 @@
 
   JSString *str = JSVAL_TO_STRING(v);
 
   return
     ToNewUTF8String(nsDependentString((PRUnichar *)::JS_GetStringChars(str),
                                       ::JS_GetStringLength(str)));
 }
 
-int32_t NP_EXPORT
+int32_t NP_CALLBACK
 _intfromidentifier(NPIdentifier identifier)
 {
   jsval v = (jsval)identifier;
 
   if (!JSVAL_IS_INT(v)) {
     return PR_INT32_MIN;
   }
 
   return JSVAL_TO_INT(v);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _identifierisstring(NPIdentifier identifier)
 {
   jsval v = (jsval)identifier;
 
   return JSVAL_IS_STRING(v);
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _createobject(NPP npp, NPClass* aClass)
 {
   if (!npp) {
     NS_ERROR("Null npp passed to _createobject()!");
 
     return nsnull;
   }
 
@@ -1523,70 +1523,70 @@
   if (npobj) {
     npobj->_class = aClass;
     npobj->referenceCount = 1;
   }
 
   return npobj;
 }
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _retainobject(NPObject* npobj)
 {
   if (npobj) {
     PR_AtomicIncrement((PRInt32*)&npobj->referenceCount);
   }
 
   return npobj;
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _releaseobject(NPObject* npobj)
 {
   if (!npobj)
     return;
 
   int32_t refCnt = PR_AtomicDecrement((PRInt32*)&npobj->referenceCount);
 
   if (refCnt == 0) {
     if (npobj->_class && npobj->_class->deallocate) {
       npobj->_class->deallocate(npobj);
     } else {
       PR_Free(npobj);
     }
   }
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
         uint32_t argCount, NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->invoke(npobj, method, args, argCount, result);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
                uint32_t argCount, NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->invokeDefault(npobj, args, argCount, result);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
 {
   if (!npp)
     return false;
 
   NPPAutoPusher nppPusher(npp);
 
   JSContext *cx = GetJSContextFromNPP(npp);
@@ -1626,79 +1626,79 @@
 
   nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
                                              nsnull, 0, nsnull, rval, nsnull);
 
   return NS_SUCCEEDED(rv) &&
          (!result || JSValToNPVariant(npp, cx, *rval, result));
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->getProperty(npobj, property, result);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              const NPVariant *value)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->setProperty(npobj, property, value);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->removeProperty(npobj, property);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->hasProperty(npobj, propertyName);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->hasProperty(npobj, methodName);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
            uint32_t *count)
 {
   if (!npp || !npobj || !npobj->_class)
     return false;
 
   if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
       !npobj->_class->enumerate) {
@@ -1708,17 +1708,17 @@
   }
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
   return npobj->_class->enumerate(npobj, identifier, count);
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _releasevariantvalue(NPVariant* variant)
 {
   switch (variant->type) {
   case NPVariantType_Void :
   case NPVariantType_Null :
   case NPVariantType_Bool :
   case NPVariantType_Int32 :
   case NPVariantType_Double :
@@ -1743,27 +1743,27 @@
     }
   default:
     NS_ERROR("Unknown NPVariant type!");
   }
 
   VOID_TO_NPVARIANT(*variant);
 }
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _tostring(NPObject* npobj, NPVariant *result)
 {
   NS_ERROR("Write me!");
 
   return PR_FALSE;
 }
 
 static char *gNPPException;
 
-void NP_EXPORT
+void NP_CALLBACK
 _setexception(NPObject* npobj, const NPUTF8 *message)
 {
   if (gNPPException) {
     // If a plugin throws multiple exceptions, we'll only report the
     // last one for now.
     free(gNPPException);
   }
 
@@ -1797,17 +1797,17 @@
 NPPExceptionAutoHolder::~NPPExceptionAutoHolder()
 {
   NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
 
   gNPPException = mOldException;
 }
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _getvalue(NPP npp, NPNVariable variable, void *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
                                      (void*)npp, (int)variable));
 
   nsresult res;
 
   switch(variable) {
@@ -1837,17 +1837,17 @@
 #endif
     return NPERR_GENERIC_ERROR;
   }
 
   case NPNVxtAppContext:
     return NPERR_GENERIC_ERROR;
 #endif
 
-#if defined(XP_WIN) || defined(XP_OS2)
+#if defined(XP_WIN) || defined(XP_OS2) || defined(MOZ_WIDGET_GTK2)
   case NPNVnetscapeWindow: {
     if (!npp || !npp->ndata)
       return NPERR_INVALID_INSTANCE_ERROR;
 
     ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
 
     nsCOMPtr<nsIPluginInstancePeer> peer;
     if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) &&
@@ -1959,16 +1959,25 @@
   }
 
   case NPNVPluginElementNPObject: {
     *(NPObject **)result = _getpluginelement(npp);
 
     return NPERR_NO_ERROR;
   }
 
+  case NPNVSupportsWindowless: {
+#if defined(XP_WIN) || defined(XP_MACOSX) || (defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2))
+    *(NPBool*)result = PR_TRUE;
+#else
+    *(NPBool*)result = PR_FALSE;
+#endif
+    return NPERR_NO_ERROR;
+  }
+
 #ifdef XP_MACOSX
   case NPNVpluginDrawingModel: {
     if (npp) {
       ns4xPluginInstance *inst = (ns4xPluginInstance*)npp->ndata;
       if (inst) {
         *(NPDrawingModel*)result = inst->GetDrawingModel();
         return NPERR_NO_ERROR;
       }
@@ -1994,17 +2003,17 @@
 #endif
 
   default : return NPERR_GENERIC_ERROR;
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _setvalue(NPP npp, NPPVariable variable, void *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
                                      (void*)npp, (int)variable));
 
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
 
@@ -2081,17 +2090,17 @@
 #endif
 
     default:
       return NPERR_NO_ERROR;
   }
 }
 
 ////////////////////////////////////////////////////////////////////////
-NPError NP_EXPORT
+NPError NP_CALLBACK
 _requestread(NPStream *pstream, NPByteRange *rangeList)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_RequestRead: stream=%p\n",
                                      (void*)pstream));
 
 #ifdef PLUGIN_LOGGING
   for(NPByteRange * range = rangeList; range != nsnull; range = range->next)
     PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY,
@@ -2117,70 +2126,70 @@
   if (streamlistener->mStreamInfo)
     streamlistener->mStreamInfo->RequestRead((nsByteRange *)rangeList);
 
   return NS_OK;
 }
 
 ////////////////////////////////////////////////////////////////////////
 #ifdef OJI
-JRIEnv* NP_EXPORT
+JRIEnv* NP_CALLBACK
 _getJavaEnv(void)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
   return NULL;
 }
 #endif
 
 ////////////////////////////////////////////////////////////////////////
-const char * NP_EXPORT
+const char * NP_CALLBACK
 _useragent(NPP npp)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
 
   char *retstr;
 
   nsCOMPtr<nsIPluginManager> pm(do_GetService(kPluginManagerCID));
 
   pm->UserAgent((const char **)&retstr);
 
   return retstr;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
-void * NP_EXPORT
+void * NP_CALLBACK
 _memalloc (uint32 size)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
   return nsMemory::Alloc(size);
 }
 
 #ifdef OJI
 ////////////////////////////////////////////////////////////////////////
-jref NP_EXPORT
+jref NP_CALLBACK
 _getJavaPeer(NPP npp)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
   return NULL;
 }
 
 #endif /* OJI */
 
-void NP_EXPORT
+void NP_CALLBACK
 _pushpopupsenabledstate(NPP npp, NPBool enabled)
 {
   ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
   if (!inst)
     return;
 
   inst->PushPopupsEnabledState(enabled);
 }
 
-void NP_EXPORT
+void NP_CALLBACK
 _poppopupsenabledstate(NPP npp)
 {
   ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
   if (!inst)
     return;
 
   inst->PopPopupsEnabledState();
 }
Index: modules/plugin/base/src/ns4xPlugin.h
===================================================================
--- modules/plugin/base/src/ns4xPlugin.h.orig
+++ modules/plugin/base/src/ns4xPlugin.h
@@ -50,20 +50,22 @@
 
 /*
  * Use this macro before each exported function
  * (between the return address and the function
  * itself), to ensure that the function has the
  * right calling conventions on Win16.
  */
 
+/* XXX NP_CALLBACK should be the same as NP_LOADDS in npapi.h which differs
+   for WIN16 and maybe WIN64? */
 #ifdef XP_OS2
-#define NP_EXPORT _System
+#define NP_CALLBACK _System
 #else
-#define NP_EXPORT
+#define NP_CALLBACK
 #endif
 
 #if defined(XP_WIN)
 #define NS_4XPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
 #elif defined(XP_OS2)
 #define NS_4XPLUGIN_CALLBACK(_type, _name) _type (_System * _name)
 #else
 #define NS_4XPLUGIN_CALLBACK(_type, _name) _type (* _name)
@@ -166,86 +168,86 @@
   /**
    * The browser-side callbacks that a 4.x-style plugin calls.
    */
   static NPNetscapeFuncs CALLBACKS;
 };
 
 
 PR_BEGIN_EXTERN_C
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getwindowobject(NPP npp);
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _getpluginelement(NPP npp);
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getstringidentifier(const NPUTF8* name);
 
-void NP_EXPORT
+void NP_CALLBACK
 _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
                       NPIdentifier *identifiers);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _identifierisstring(NPIdentifier identifiers);
 
-NPIdentifier NP_EXPORT
+NPIdentifier NP_CALLBACK
 _getintidentifier(int32_t intid);
 
-NPUTF8* NP_EXPORT
+NPUTF8* NP_CALLBACK
 _utf8fromidentifier(NPIdentifier identifier);
 
-int32_t NP_EXPORT
+int32_t NP_CALLBACK
 _intfromidentifier(NPIdentifier identifier);
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _createobject(NPP npp, NPClass* aClass);
 
-NPObject* NP_EXPORT
+NPObject* NP_CALLBACK
 _retainobject(NPObject* npobj);
 
-void NP_EXPORT
+void NP_CALLBACK
 _releaseobject(NPObject* npobj);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
         uint32_t argCount, NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
                uint32_t argCount, NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              NPVariant *result);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              const NPVariant *value);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName);
 
-bool NP_EXPORT
+bool NP_CALLBACK
 _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
            uint32_t *count);
 
-void NP_EXPORT
+void NP_CALLBACK
 _releasevariantvalue(NPVariant *variant);
 
-void NP_EXPORT
+void NP_CALLBACK
 _setexception(NPObject* npobj, const NPUTF8 *message);
 
 PR_END_EXTERN_C
 
 const char *
 PeekException();
 
 void
Index: modules/plugin/base/src/ns4xPluginInstance.cpp
===================================================================
--- modules/plugin/base/src/ns4xPluginInstance.cpp.orig
+++ modules/plugin/base/src/ns4xPluginInstance.cpp
@@ -54,22 +54,16 @@
 #include "nsIDocument.h"
 
 #include "nsJSNPRuntime.h"
 
 #ifdef XP_OS2
 #include "nsILegacyPluginWrapperOS2.h"
 #endif
 
-#ifdef MOZ_WIDGET_GTK2
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include "gtk2xtbin.h"
-#endif
-
 ////////////////////////////////////////////////////////////////////////
 // CID's && IID's
 static NS_DEFINE_IID(kCPluginManagerCID, NS_PLUGINMANAGER_CID); // needed for NS_TRY_SAFE_CALL
 static NS_DEFINE_IID(kIPluginStreamListenerIID, NS_IPLUGINSTREAMLISTENER_IID);
 
 ///////////////////////////////////////////////////////////////////////////////
 // ns4xPluginStreamListener Methods
 
@@ -815,21 +809,16 @@
 }
 
 
 ///////////////////////////////////////////////////////////////////////////////
 ns4xPluginInstance::~ns4xPluginInstance(void)
 {
   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("ns4xPluginInstance dtor: this=%p\n",this));
 
-#if defined (MOZ_WIDGET_GTK2)
-  if (mXtBin)
-    gtk_widget_destroy(mXtBin);
-#endif
-
   // clean the stream list if any
   for(nsInstanceStream *is = mStreams; is != nsnull;) {
     nsInstanceStream * next = is->mNext;
     delete is;
     is = next;
   }
 }
 
@@ -842,19 +831,16 @@
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP ns4xPluginInstance::Initialize(nsIPluginInstancePeer* peer)
 {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::Initialize this=%p\n",this));
 
-#if defined (MOZ_WIDGET_GTK2)
-  mXtBin = nsnull;
-#endif
   return InitializePlugin(peer);
 }
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP ns4xPluginInstance::GetPeer(nsIPluginInstancePeer* *resultingPeer)
 {
   *resultingPeer = mPeer;
   NS_IF_ADDREF(*resultingPeer);
@@ -885,23 +871,16 @@
   if (mPopupStates.Count() > 0) {
     nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
 
     if (window) {
       window->PopPopupControlState(openAbused);
     }
   }
 
-#if defined (MOZ_WIDGET_GTK2)
-  if (mXtBin) {
-    gtk_widget_destroy(mXtBin);
-    mXtBin = 0;
-  }
-#endif
-
   if(!mStarted)
     return NS_OK;
 
   if (fCallbacks->destroy == NULL)
     return NS_ERROR_FAILURE; // XXX right error?
 
   NPSavedData *sdata = 0;
 
@@ -1100,135 +1079,28 @@
   // destruction is handled in the Stop call
   return NS_OK;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP ns4xPluginInstance::SetWindow(nsPluginWindow* window)
 {
-#if defined (MOZ_WIDGET_GTK2)
-  NPSetWindowCallbackStruct *ws;
-#endif
-
   // XXX 4.x plugins don't want a SetWindow(NULL).
   if (!window || !mStarted)
     return NS_OK;
   
   NPError error;
-  
+
 #if defined (MOZ_WIDGET_GTK2)
-  PRBool isXembed = PR_FALSE;
-  // bug 108337, flash plugin on linux doesn't like window->width <= 0
-  if ((PRInt32) window->width <= 0 || (PRInt32) window->height <= 0)
+  if (window->type == nsPluginWindowType_Window &&
+      (window->width <= 0 || window->height <= 0)) {
+    // bug 108347, flash plugin on linux doesn't like window->width <= 0
     return NS_OK;
-
-  // We need to test if this is an xembed window before doing checks
-  // below, as they might be used on the first pass or on later passes
-  // when we resize the plugin window.
-  GdkWindow *win = gdk_window_lookup((XID)window->window);
-  if (!win)
-    return NS_ERROR_FAILURE;
-
-  gpointer user_data = nsnull;
-  gdk_window_get_user_data(win, &user_data);
-  if (user_data && GTK_IS_WIDGET(user_data)) {
-    GtkWidget* widget = GTK_WIDGET(user_data);
-
-    if (GTK_IS_SOCKET(widget))
-      isXembed = PR_TRUE;
-  }
-
-  // Allocate and fill out the ws_info data
-  if (!window->ws_info || !mXtBin) {
-    if (!window->ws_info) {
-#ifdef NS_DEBUG
-      printf("About to create new ws_info...\n");
-#endif    
-
-      // allocate a new NPSetWindowCallbackStruct structure at ws_info
-      window->ws_info = (NPSetWindowCallbackStruct *)PR_MALLOC(sizeof(NPSetWindowCallbackStruct));
-
-      if (!window->ws_info)
-        return NS_ERROR_OUT_OF_MEMORY;
-    }
-
-    ws = (NPSetWindowCallbackStruct *)window->ws_info;
-
-    if (!isXembed)
-    {  
-#ifdef NS_DEBUG      
-      printf("About to create new xtbin of %i X %i from %p...\n",
-             window->width, window->height, win);
-#endif
-
-#if 0
-      // if we destroyed the plugin when we left the page, we could remove this
-      // code (i believe) the problem here is that the window gets destroyed when
-      // its parent, etc does by changing a page the plugin instance is being
-      // held on to, so when we return to the page, we have a mXtBin, but it is
-      // in a not-so-good state.
-      // --
-      // this is lame.  we shouldn't be destroying this everytime, but I can't find
-      // a good way to tell if we need to destroy/recreate the xtbin or not
-      // what if the plugin wants to change the window and not just resize it??
-      // (pav)
-
-      if (mXtBin) {
-        gtk_widget_destroy(mXtBin);
-        mXtBin = NULL;
-      }
-#endif
-
-
-      if (!mXtBin) {
-        mXtBin = gtk_xtbin_new(win, 0);
-        // Check to see if creating mXtBin failed for some reason.
-        // if it did, we can't go any further.
-        if (!mXtBin)
-          return NS_ERROR_FAILURE;
-      } 
-
-      gtk_widget_set_usize(mXtBin, window->width, window->height);
-
-#ifdef NS_DEBUG
-      printf("About to show xtbin(%p)...\n", mXtBin); fflush(NULL);
-#endif
-      gtk_widget_show(mXtBin);
-#ifdef NS_DEBUG
-      printf("completed gtk_widget_show(%p)\n", mXtBin); fflush(NULL);
-#endif
-    }
-
-    // fill in window info structure 
-    ws->type = 0; // OK, that was a guess!!
-#ifdef MOZ_X11
-    ws->depth = gdk_window_get_visual(win)->depth;
-    if (!isXembed)
-      ws->display = GTK_XTBIN(mXtBin)->xtdisplay;
-    else
-      ws->display = GDK_WINDOW_XDISPLAY(win);
-    ws->visual = GDK_VISUAL_XVISUAL(gdk_window_get_visual(win));
-    ws->colormap = GDK_COLORMAP_XCOLORMAP(gdk_window_get_colormap(win));
-
-    XFlush(ws->display);
-#endif
-  } // !window->ws_info
-
-  if (!mXtBin && !isXembed)
-    return NS_ERROR_FAILURE;
-
-  if (!isXembed) {
-    // And now point the NPWindow structures window 
-    // to the actual X window
-    window->window = (nsPluginPort *)GTK_XTBIN(mXtBin)->xtwindow;
-    
-    gtk_xtbin_resize(mXtBin, window->width, window->height);
   }
-  
 #endif // MOZ_WIDGET
 
   if (fCallbacks->setwindow) {
     // XXX Turns out that NPPluginWindow and NPWindow are structurally
     // identical (on purpose!), so there's no need to make a copy.
 
     PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::SetWindow (about to call it) this=%p\n",this));
 
@@ -1347,27 +1219,31 @@
 
   PRInt16 result = 0;
   
   if (fCallbacks->event) {
 #ifdef XP_MACOSX
     result = CallNPP_HandleEventProc(fCallbacks->event,
                                      &fNPP,
                                      (void*) event->event);
-#endif
 
-#if defined(XP_WIN) || defined(XP_OS2)
+#elif defined(XP_WIN) || defined(XP_OS2)
       NPEvent npEvent;
       npEvent.event = event->event;
       npEvent.wParam = event->wParam;
       npEvent.lParam = event->lParam;
 
       NS_TRY_SAFE_CALL_RETURN(result, CallNPP_HandleEventProc(fCallbacks->event,
                                     &fNPP,
                                     (void*)&npEvent), fLibrary, this);
+#else // MOZ_X11 or other
+      NS_TRY_SAFE_CALL_RETURN(result, CallNPP_HandleEventProc(fCallbacks->event,
+                                                              &fNPP,
+                                                              (void*)&event->event),
+                                                              fLibrary, this);
 #endif
 
       NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
       ("NPP HandleEvent called: this=%p, npp=%p, event=%d, return=%d\n", 
       this, &fNPP, event->event, result));
 
       *handled = result;
     }
Index: modules/plugin/base/src/ns4xPluginInstance.h
===================================================================
--- modules/plugin/base/src/ns4xPluginInstance.h.orig
+++ modules/plugin/base/src/ns4xPluginInstance.h
@@ -58,20 +58,16 @@
 #include "nsIPluginInstanceInternal.h"
 
 #include "npupp.h"
 #ifdef OJI
 #include "jri.h"
 #endif
 #include "prlink.h"  // for PRLibrary
 
-#if defined (MOZ_WIDGET_GTK2)
-#include <gtk/gtk.h>
-#endif
-
 ////////////////////////////////////////////////////////////////////////
 
 class ns4xPluginStreamListener;
 class nsPIDOMWindow;
 
 struct nsInstanceStream
 {
     nsInstanceStream *mNext;
@@ -169,24 +165,16 @@
 
     /**
      * A pointer to the plugin's callback functions. This information
      * is actually stored in the plugin class (<b>nsPluginClass</b>),
      * and is common for all plugins of the class.
      */
     NPPluginFuncs* fCallbacks;
 
-#if defined (MOZ_WIDGET_GTK2)
-   /**
-    * Special GtkXtBin widget that encapsulates the Xt toolkit
-    * within a Gtk Application
-    */
-   GtkWidget *mXtBin;
-#endif
-
     /**
      * The 4.x-style structure used to communicate between the plugin
      * instance and the browser.
      */
     NPP_t fNPP;
 
 #ifdef XP_MACOSX
     NPDrawingModel mDrawingModel;
Index: modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp
===================================================================
--- modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp.orig
+++ modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp
@@ -43,58 +43,69 @@
  */
 
 #include "nsDebug.h"
 #include "nsPluginNativeWindow.h"
 #include "npapi.h"
 #include <gtk/gtk.h>
 #include <gdk/gdkx.h>
 #include <gdk/gdk.h>
+#include "gtk2xtbin.h"
 #ifdef OJI
 #include "plstr.h"
 #include "nsIPlugin.h"
 #include "nsIPluginHost.h"
 
 static NS_DEFINE_CID(kPluginManagerCID, NS_PLUGINMANAGER_CID);
 #endif
 
 class nsPluginNativeWindowGtk2 : public nsPluginNativeWindow {
 public: 
   nsPluginNativeWindowGtk2();
   virtual ~nsPluginNativeWindowGtk2();
 
   virtual nsresult CallSetWindow(nsCOMPtr<nsIPluginInstance> &aPluginInstance);
 private:
-  GtkWidget*  mGtkSocket;
+  NPSetWindowCallbackStruct mWsInfo;
+  /**
+   * Either a GtkSocket or a special GtkXtBin widget (derived from GtkSocket)
+   * that encapsulates the Xt toolkit within a Gtk Application.
+   */
+  GtkWidget* mSocketWidget;
   nsresult  CreateXEmbedWindow();
+  nsresult  CreateXtWindow();
   void      SetAllocation();
   PRBool    CanGetValueFromPlugin(nsCOMPtr<nsIPluginInstance> &aPluginInstance);
 };
 
 static gboolean plug_removed_cb   (GtkWidget *widget, gpointer data);
 
 nsPluginNativeWindowGtk2::nsPluginNativeWindowGtk2() : nsPluginNativeWindow()
 {
   // initialize the struct fields
   window = nsnull; 
   x = 0; 
   y = 0; 
   width = 0; 
   height = 0; 
   memset(&clipRect, 0, sizeof(clipRect));
-  ws_info = nsnull;
+  ws_info = &mWsInfo;
   type = nsPluginWindowType_Window;
-  mGtkSocket = 0;
+  mSocketWidget = 0;
+  mWsInfo.type = 0;
+  mWsInfo.display = nsnull;
+  mWsInfo.visual = nsnull;
+  mWsInfo.colormap = 0;
+  mWsInfo.depth = 0;
 }
 
 nsPluginNativeWindowGtk2::~nsPluginNativeWindowGtk2() 
 {
-  if(mGtkSocket) {
-    gtk_widget_destroy(mGtkSocket);
-    mGtkSocket = 0;
+  if(mSocketWidget) {
+    gtk_widget_destroy(mSocketWidget);
   }
 }
 
 nsresult PLUG_NewPluginNativeWindow(nsPluginNativeWindow ** aPluginNativeWindow)
 {
   NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
   *aPluginNativeWindow = new nsPluginNativeWindowGtk2();
   return *aPluginNativeWindow ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
@@ -106,91 +117,154 @@
   nsPluginNativeWindowGtk2 *p = (nsPluginNativeWindowGtk2 *)aPluginNativeWindow;
   delete p;
   return NS_OK;
 }
 
 nsresult nsPluginNativeWindowGtk2::CallSetWindow(nsCOMPtr<nsIPluginInstance> &aPluginInstance)
 {
   if(aPluginInstance) {
-    nsresult rv;
-    PRBool val = PR_FALSE;
-    if(!mGtkSocket) {
-      if (CanGetValueFromPlugin(aPluginInstance))
-        rv = aPluginInstance->GetValue
-               ((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &val);
-    }
+    if (type == nsPluginWindowType_Window) {
+      nsresult rv;
+      if(!mSocketWidget) {
+        PRBool needXEmbed = PR_FALSE;
+        if (CanGetValueFromPlugin(aPluginInstance)) {
+          rv = aPluginInstance->GetValue
+            ((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &needXEmbed);
 #ifdef DEBUG
-    printf("nsPluginNativeWindowGtk2: NPPVpluginNeedsXEmbed=%d\n", val);
+          printf("nsPluginNativeWindowGtk2: NPPVpluginNeedsXEmbed=%d\n", needXEmbed);
 #endif
-    if(val) {
-      CreateXEmbedWindow();
-    }
+        }
+        if(needXEmbed) {
+          CreateXEmbedWindow();
+        }
+        else {
+          CreateXtWindow();
+        }
+      }
 
-    if(mGtkSocket) {
-      // Make sure to resize and re-place the window if required
-      SetAllocation();
-      window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mGtkSocket));
-    }
+      if(!mSocketWidget)
+        return NS_ERROR_FAILURE;
+
+      // Make sure to resize and re-place the window if required.
+      // Need to reset "window" each time as nsObjectFrame::DidReflow sets it
+      // to the ancestor window.
+      if(GTK_IS_XTBIN(mSocketWidget)) {
+        gtk_xtbin_resize(mSocketWidget, width, height);
+        // Point the NPWindow structures window to the actual X window
+        window = (nsPluginPort *)GTK_XTBIN(mSocketWidget)->xtwindow;
+      }
+      else { // XEmbed
+        SetAllocation();
+        window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mSocketWidget));
+      }
 #ifdef DEBUG
-    printf("nsPluginNativeWindowGtk2: call SetWindow with xid=%p\n", (void *)window);
+      printf("nsPluginNativeWindowGtk2: call SetWindow with xid=%p\n", (void *)window);
 #endif
+    } // nsPluginWindowType_Window
     aPluginInstance->SetWindow(this);
   }
   else if (mPluginInstance)
     mPluginInstance->SetWindow(nsnull);
 
   SetPluginInstance(aPluginInstance);
   return NS_OK;
 }
 
 nsresult nsPluginNativeWindowGtk2::CreateXEmbedWindow() {
-  if(!mGtkSocket) {
-    GdkWindow *win = gdk_window_lookup((XID)window);
-    mGtkSocket = gtk_socket_new();
-
-    //attach the socket to the container widget
-    gtk_widget_set_parent_window(mGtkSocket, win);
-
-    // Make sure to handle the plug_removed signal.  If we don't the
-    // socket will automatically be destroyed when the plug is
-    // removed, which means we're destroying it more than once.
-    // SYNTAX ERROR.
-    g_signal_connect(mGtkSocket, "plug_removed",
-                     G_CALLBACK(plug_removed_cb), NULL);
-
-    gpointer user_data = NULL;
-    gdk_window_get_user_data(win, &user_data);
-
-    GtkContainer *container = GTK_CONTAINER(user_data);
-    gtk_container_add(container, mGtkSocket);
-    gtk_widget_realize(mGtkSocket);
+  NS_ASSERTION(!mSocketWidget,"Already created a socket widget!");
 
-    // Resize before we show
-    SetAllocation();
+  GdkWindow *parent_win = gdk_window_lookup((XID)window);
+  mSocketWidget = gtk_socket_new();
 
-    gtk_widget_show(mGtkSocket);
+  //attach the socket to the container widget
+  gtk_widget_set_parent_window(mSocketWidget, parent_win);
 
-    gdk_flush();
-    window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mGtkSocket));
-  }
+  // Make sure to handle the plug_removed signal.  If we don't the
+  // socket will automatically be destroyed when the plug is
+  // removed, which means we're destroying it more than once.
+  // SYNTAX ERROR.
+  g_signal_connect(mSocketWidget, "plug_removed",
+                   G_CALLBACK(plug_removed_cb), NULL);
+
+  gpointer user_data = NULL;
+  gdk_window_get_user_data(parent_win, &user_data);
+
+  GtkContainer *container = GTK_CONTAINER(user_data);
+  gtk_container_add(container, mSocketWidget);
+  gtk_widget_realize(mSocketWidget);
+
+  // Resize before we show
+  SetAllocation();
+
+  gtk_widget_show(mSocketWidget);
+
+  gdk_flush();
+  window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mSocketWidget));
+
+  // Fill out the ws_info structure.
+  // (The windowless case is done in nsObjectFrame.cpp.)
+  GdkWindow *gdkWindow = gdk_window_lookup((XID)window);
+  mWsInfo.display = GDK_WINDOW_XDISPLAY(gdkWindow);
+  mWsInfo.colormap = GDK_COLORMAP_XCOLORMAP(gdk_drawable_get_colormap(gdkWindow));
+  GdkVisual* gdkVisual = gdk_drawable_get_visual(gdkWindow);
+  mWsInfo.visual = GDK_VISUAL_XVISUAL(gdkVisual);
+  mWsInfo.depth = gdkVisual->depth;
 
   return NS_OK;
 }
 
 void nsPluginNativeWindowGtk2::SetAllocation() {
-  if (!mGtkSocket)
+  if (!mSocketWidget)
     return;
 
   GtkAllocation new_allocation;
   new_allocation.x = 0;
   new_allocation.y = 0;
   new_allocation.width = width;
   new_allocation.height = height;
-  gtk_widget_size_allocate(mGtkSocket, &new_allocation);
+  gtk_widget_size_allocate(mSocketWidget, &new_allocation);
+}
+
+nsresult nsPluginNativeWindowGtk2::CreateXtWindow() {
+  NS_ASSERTION(!mSocketWidget,"Already created a socket widget!");
+
+#ifdef NS_DEBUG
+  printf("About to create new xtbin of %i X %i from %p...\n",
+         width, height, (void*)window);
+#endif
+  GdkWindow *gdkWindow = gdk_window_lookup((XID)window);
+  mSocketWidget = gtk_xtbin_new(gdkWindow, 0);
+  // Check to see if creating the xtbin failed for some reason.
+  // if it did, we can't go any further.
+  if (!mSocketWidget)
+    return NS_ERROR_FAILURE;
+
+  gtk_widget_set_size_request(mSocketWidget, width, height);
+
+#ifdef NS_DEBUG
+  printf("About to show xtbin(%p)...\n", (void*)mSocketWidget); fflush(NULL);
+#endif
+  gtk_widget_show(mSocketWidget);
+#ifdef NS_DEBUG
+  printf("completed gtk_widget_show(%p)\n", (void*)mSocketWidget); fflush(NULL);
+#endif
+
+  // Fill out the ws_info structure.
+  GtkXtBin* xtbin = GTK_XTBIN(mSocketWidget);
+  // The xtbin has its own Display structure.
+  mWsInfo.display = xtbin->xtdisplay;
+  mWsInfo.colormap = xtbin->xtclient.xtcolormap;
+  mWsInfo.visual = xtbin->xtclient.xtvisual;
+  mWsInfo.depth = xtbin->xtclient.xtdepth;
+  // Leave mWsInfo.type = 0 - Who knows what this is meant to be?
+
+  XFlush(mWsInfo.display);
+
+  return NS_OK;
 }
 
 PRBool nsPluginNativeWindowGtk2::CanGetValueFromPlugin(nsCOMPtr<nsIPluginInstance> &aPluginInstance)
 {
 #ifdef OJI
   if(aPluginInstance) {
     nsresult rv;
     nsCOMPtr<nsIPluginInstancePeer> peer;
--- modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp.orig	2007-09-24 12:19:12.000000000 +0300
+++ modules/plugin/base/src/nsPluginNativeWindowGtk2.cpp	2007-09-24 13:21:26.000000000 +0300
@@ -196,20 +196,22 @@ nsresult nsPluginNativeWindowGtk2::Creat
   SetAllocation();
 
   gtk_widget_show(mSocketWidget);
 
   gdk_flush();
   window = (nsPluginPort *)gtk_socket_get_id(GTK_SOCKET(mSocketWidget));
 
   // Fill out the ws_info structure.
   // (The windowless case is done in nsObjectFrame.cpp.)
   GdkWindow *gdkWindow = gdk_window_lookup((XID)window);
+  if (!gdkWindow)
+    return NS_ERROR_FAILURE;
   mWsInfo.display = GDK_WINDOW_XDISPLAY(gdkWindow);
   mWsInfo.colormap = GDK_COLORMAP_XCOLORMAP(gdk_drawable_get_colormap(gdkWindow));
   GdkVisual* gdkVisual = gdk_drawable_get_visual(gdkWindow);
   mWsInfo.visual = GDK_VISUAL_XVISUAL(gdkVisual);
   mWsInfo.depth = gdkVisual->depth;
 
   return NS_OK;
 }
 
 void nsPluginNativeWindowGtk2::SetAllocation() {
@@ -225,20 +227,22 @@ void nsPluginNativeWindowGtk2::SetAlloca
 }
 
 nsresult nsPluginNativeWindowGtk2::CreateXtWindow() {
   NS_ASSERTION(!mSocketWidget,"Already created a socket widget!");
 
 #ifdef NS_DEBUG
   printf("About to create new xtbin of %i X %i from %p...\n",
          width, height, (void*)window);
 #endif
   GdkWindow *gdkWindow = gdk_window_lookup((XID)window);
+  if (!gdkWindow)
+    return NS_ERROR_FAILURE;
   mSocketWidget = gtk_xtbin_new(gdkWindow, 0);
   // Check to see if creating the xtbin failed for some reason.
   // if it did, we can't go any further.
   if (!mSocketWidget)
     return NS_ERROR_FAILURE;
 
   gtk_widget_set_size_request(mSocketWidget, width, height);
 
 #ifdef NS_DEBUG
   printf("About to show xtbin(%p)...\n", (void*)mSocketWidget); fflush(NULL);
