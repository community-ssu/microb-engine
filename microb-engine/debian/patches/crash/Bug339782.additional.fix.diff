# XPTC_InvokeByIndex crashes
# Bug 339782  [ARM] XPTC_InvokeByIndex crashes when cross-compiled under GCC 3.4.x with EABI (CodeSourcery)
Index: xpcom/reflect/xptcall/src/md/unix/xptcinvoke_arm.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_arm.cpp,v
retrieving revision 1.10
diff --unified -r1.10 xptcinvoke_arm.cpp
--- xpcom/reflect/xptcall/src/md/unix/xptcinvoke_arm.cpp	6 Feb 2007 08:25:37 -0000	1.10
+++ xpcom/reflect/xptcall/src/md/unix/xptcinvoke_arm.cpp	10 Oct 2007 09:35:28 -0000
@@ -43,12 +43,22 @@
 #error "This code is for Linux ARM only. Check that it works on your system, too.\nBeware that this code is highly compiler dependent."
 #endif
 
+#ifdef __ARM_EABI__
+#define DOUBLEWORD_ALIGN(p) ((PRUint32 *)((((PRUint32)(p)) + 7) & 0xfffffff8))
+#else
+#define DOUBLEWORD_ALIGN(p) (p)
+#endif
+
 // Remember that these 'words' are 32bit DWORDS
 
 static PRUint32
 invoke_count_words(PRUint32 paramCount, nsXPTCVariant* s)
 {
     PRUint32 result = 0;
+
+    /* Note that we give a "worst case" estimate of how much stack _might_ be
+     * needed, rather than the real count - this should be safe */
+
     for(PRUint32 i = 0; i < paramCount; i++, s++)
     {
         if(s->IsPtrData())
@@ -64,7 +74,7 @@
             result++;
             break;
         case nsXPTType::T_I64    :
-            result+=2;
+            result+=3;
             break;
         case nsXPTType::T_U8     :
         case nsXPTType::T_U16    :
@@ -72,13 +82,13 @@
             result++;
             break;
         case nsXPTType::T_U64    :
-            result+=2;
+            result+=3;
             break;
         case nsXPTType::T_FLOAT  :
             result++;
             break;
         case nsXPTType::T_DOUBLE :
-            result+=2;
+            result+=3;
             break;
         case nsXPTType::T_BOOL   :
         case nsXPTType::T_CHAR   :
@@ -91,6 +101,15 @@
             break;
         }
     }
+
+#ifdef __ARM_EABI__
+    /* Ensure stack is always aligned to doubleword boundary; we take 3 words
+     * off the stack to r1-r3 later, so it must always be on _odd_ word 
+     * boundary after this */
+    if (result % 2 == 0)
+        result++;
+#endif
+
     return result;
 }
 
@@ -109,13 +128,16 @@
         case nsXPTType::T_I8     : *((PRInt8*)  d) = s->val.i8;          break;
         case nsXPTType::T_I16    : *((PRInt16*) d) = s->val.i16;         break;
         case nsXPTType::T_I32    : *((PRInt32*) d) = s->val.i32;         break;
-        case nsXPTType::T_I64    : *((PRInt64*) d) = s->val.i64; d++;    break;
+        case nsXPTType::T_I64    : d = DOUBLEWORD_ALIGN(d);
+                                   *((PRInt64*) d) = s->val.i64; d++;    break;
         case nsXPTType::T_U8     : *((PRUint8*) d) = s->val.u8;          break;
         case nsXPTType::T_U16    : *((PRUint16*)d) = s->val.u16;         break;
         case nsXPTType::T_U32    : *((PRUint32*)d) = s->val.u32;         break;
-        case nsXPTType::T_U64    : *((PRUint64*)d) = s->val.u64; d++;    break;
+        case nsXPTType::T_U64    : d = DOUBLEWORD_ALIGN(d);
+                                   *((PRUint64*)d) = s->val.u64; d++;    break;
         case nsXPTType::T_FLOAT  : *((float*)   d) = s->val.f;           break;
-        case nsXPTType::T_DOUBLE : *((double*)  d) = s->val.d;   d++;    break;
+        case nsXPTType::T_DOUBLE : d = DOUBLEWORD_ALIGN(d);
+                                   *((double*)  d) = s->val.d;   d++;    break;
         case nsXPTType::T_BOOL   : *((PRBool*)  d) = s->val.b;           break;
         case nsXPTType::T_CHAR   : *((char*)    d) = s->val.c;           break;
         case nsXPTType::T_WCHAR  : *((wchar_t*) d) = s->val.wc;          break;
Index: xpcom/reflect/xptcall/src/md/unix/xptcstubs_arm.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_arm.cpp,v
retrieving revision 1.11
diff --unified -r1.11 xptcstubs_arm.cpp
--- xpcom/reflect/xptcall/src/md/unix/xptcstubs_arm.cpp	6 Feb 2007 08:25:37 -0000	1.11
+++ xpcom/reflect/xptcall/src/md/unix/xptcstubs_arm.cpp	10 Oct 2007 09:35:28 -0000
@@ -61,6 +61,12 @@
 static nsresult PrepareAndDispatch(nsXPTCStubBase* self, uint32 methodIndex, PRUint32* args) asm("_PrepareAndDispatch")
 DONT_DROP_OR_WARN;
 
+#ifdef __ARM_EABI__
+#define DOUBLEWORD_ALIGN(p) ((PRUint32 *)((((PRUint32)(p)) + 7) & 0xfffffff8))
+#else
+#define DOUBLEWORD_ALIGN(p) (p)
+#endif
+
 static nsresult
 PrepareAndDispatch(nsXPTCStubBase* self, uint32 methodIndex, PRUint32* args)
 {
@@ -104,13 +110,16 @@
         case nsXPTType::T_I8     : dp->val.i8  = *((PRInt8*)  ap);       break;
         case nsXPTType::T_I16    : dp->val.i16 = *((PRInt16*) ap);       break;
         case nsXPTType::T_I32    : dp->val.i32 = *((PRInt32*) ap);       break;
-        case nsXPTType::T_I64    : dp->val.i64 = *((PRInt64*) ap); ap++; break;
+        case nsXPTType::T_I64    : ap = DOUBLEWORD_ALIGN(ap);
+				   dp->val.i64 = *((PRInt64*) ap); ap++; break;
         case nsXPTType::T_U8     : dp->val.u8  = *((PRUint8*) ap);       break;
         case nsXPTType::T_U16    : dp->val.u16 = *((PRUint16*)ap);       break;
         case nsXPTType::T_U32    : dp->val.u32 = *((PRUint32*)ap);       break;
-        case nsXPTType::T_U64    : dp->val.u64 = *((PRUint64*)ap); ap++; break;
+        case nsXPTType::T_U64    : ap = DOUBLEWORD_ALIGN(ap);
+				   dp->val.u64 = *((PRUint64*)ap); ap++; break;
         case nsXPTType::T_FLOAT  : dp->val.f   = *((float*)   ap);       break;
-        case nsXPTType::T_DOUBLE : dp->val.d   = *((double*)  ap); ap++; break;
+        case nsXPTType::T_DOUBLE : ap = DOUBLEWORD_ALIGN(ap);
+				   dp->val.d   = *((double*)  ap); ap++; break;
         case nsXPTType::T_BOOL   : dp->val.b   = *((PRBool*)  ap);       break;
         case nsXPTType::T_CHAR   : dp->val.c   = *((char*)    ap);       break;
         case nsXPTType::T_WCHAR  : dp->val.wc  = *((wchar_t*) ap);       break;
