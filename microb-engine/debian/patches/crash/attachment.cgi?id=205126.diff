#Bug 210931  Mozilla should reset the X error handler to trap overallocation failures in gtk/gtk2 libraries [@ nsImageGTK::DrawCompositeTile ]
Index: mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsDeviceContextGTK.cpp
+++ mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp
@@ -237,17 +237,17 @@
 {
 #ifdef NS_PRINT_PREVIEW
   // Defer to Alt when there is one
 //  if (mAltDC && ((mUseAltDC & kUseAltDCFor_CREATERC_PAINT) || (mUseAltDC & kUseAltDCFor_CREATERC_REFLOW))) {
 //    return mAltDC->CreateRenderingContext(aContext);
 //  }
 #endif
 
-  nsresult             rv;
+  nsresult             rv = NS_OK;
   GtkWidget *w = (GtkWidget*)mWidget;
 
   // to call init for this, we need to have a valid nsDrawingSurfaceGTK created
   nsIRenderingContext* pContext = new nsRenderingContextGTK();
 
   if (nsnull != pContext)
   {
     NS_ADDREF(pContext);
@@ -264,33 +264,40 @@
           gwin = (GdkDrawable*)GTK_LAYOUT(w)->bin_window;
         else
           gwin = (GdkDrawable*)(w)->window;
 
         // window might not be realized... ugh
         if (gwin)
           gdk_window_ref(gwin);
         else {
+          gdk_error_trap_push();
           win = gdk_pixmap_new(nsnull,
                                w->allocation.width,
                                w->allocation.height,
                                gdk_rgb_get_visual()->depth);
+          gdk_flush();
+          if (gdk_error_trap_pop() || !win)
+            rv = NS_ERROR_OUT_OF_MEMORY;
 #ifdef MOZ_WIDGET_GTK2
-          gdk_drawable_set_colormap(win, gdk_rgb_get_colormap());
+          else
+            gdk_drawable_set_colormap(win, gdk_rgb_get_colormap());
 #endif
         }
 
-        GdkGC *gc = gdk_gc_new(win);
+        if (NS_OK == rv) {
+          GdkGC *gc = gdk_gc_new(win);
 
-        // init the nsDrawingSurfaceGTK
-        rv = surf->Init(win,gc);
+          // init the nsDrawingSurfaceGTK
+          rv = surf->Init(win,gc);
 
-        if (NS_OK == rv)
-          // Init the nsRenderingContextGTK
-          rv = pContext->Init(this, surf);
+          if (NS_OK == rv)
+            // Init the nsRenderingContextGTK
+            rv = pContext->Init(this, surf);
+        }
       }
     else
       rv = NS_ERROR_OUT_OF_MEMORY;
   }
   else
     rv = NS_ERROR_OUT_OF_MEMORY;
 
   if (NS_OK != rv)
Index: mozilla/gfx/src/gtk/nsDrawingSurfaceGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsDrawingSurfaceGTK.cpp
+++ mozilla/gfx/src/gtk/nsDrawingSurfaceGTK.cpp
@@ -305,19 +305,24 @@
   mGC = gdk_gc_ref(aGC);
   mWidth = aWidth;
   mHeight = aHeight;
   mFlags = aFlags;
 
   // we can draw on this offscreen because it has no parent
   mIsOffscreen = PR_TRUE;
 
+  gdk_error_trap_push();
   mPixmap = ::gdk_pixmap_new(nsnull, mWidth, mHeight, mDepth);
+  gdk_flush();
+  if (gdk_error_trap_pop())
+    mPixmap = nsnull;
 #ifdef MOZ_WIDGET_GTK2
-  gdk_drawable_set_colormap(GDK_DRAWABLE(mPixmap), gdk_rgb_get_colormap());
+  else if (mPixmap)
+    gdk_drawable_set_colormap(GDK_DRAWABLE(mPixmap), gdk_rgb_get_colormap());
 #endif
 
   if (mImage)
     gdk_image_destroy(mImage);
   mImage = nsnull;
 
   return mPixmap ? NS_OK : NS_ERROR_FAILURE;
 }
Index: mozilla/gfx/src/gtk/nsImageGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsImageGTK.cpp
+++ mozilla/gfx/src/gtk/nsImageGTK.cpp
@@ -355,17 +355,18 @@
             break;
           case 0:
             NS_CLEAR_BIT(mask,x);
             if (mAlphaDepth == 0) {
               mAlphaDepth=1;
 
               // promoting an image from no alpha channel to 1-bit, so
               // we need to create/clear the alpha pixmap
-              CreateOffscreenPixmap(mWidth, mHeight);
+              if (!CreateOffscreenPixmap(mWidth, mHeight))
+                break;
 
               XFillRectangle(GDK_WINDOW_XDISPLAY(mAlphaPixmap),
                              GDK_WINDOW_XWINDOW(mAlphaPixmap),
                              GDK_GC_XGC(s1bitGC),
                              mDecodedX1, mDecodedY1,
                              mDecodedX2 - mDecodedX1 + 1,
                              mDecodedY2 - mDecodedY1 + 1);
             }
@@ -448,25 +449,26 @@
               break;
             }
           }
         }
       }
     }
 
     if (mAlphaDepth != 8) {
-      CreateOffscreenPixmap(mWidth, mHeight);
-
+      PRBool mem = CreateOffscreenPixmap(mWidth, mHeight);
+      if (mem) {
       gdk_draw_rgb_image_dithalign(mImagePixmap, sXbitGC, 
-                                   rect->x, rect->y,
-                                   rect->width, rect->height,
-                                   GDK_RGB_DITHER_MAX,
-                                   mImageBits + mRowBytes*rect->y + 3*rect->x,
-                                   mRowBytes,
-                                   0, 0);
+                                     rect->x, rect->y,
+                                     rect->width, rect->height,
+                                     GDK_RGB_DITHER_NONE,
+                                     mImageBits + mRowBytes*rect->y + 3*rect->x,
+                                     mRowBytes,
+                                     0, 0);
+      }
     }
 
     if (mAlphaDepth==1) {
       XPutImage(GDK_WINDOW_XDISPLAY(mAlphaPixmap),
                 GDK_WINDOW_XWINDOW(mAlphaPixmap),
                 GDK_GC_XGC(s1bitGC),
                 mAlphaXImage,
                 rect->x, rect->y, 
@@ -483,16 +485,23 @@
 #ifdef CHEAP_PERFORMANCE_MEASURMENT
 static PRTime gConvertTime, gAlphaTime, gCopyStart, gCopyEnd, gStartTime, gPixmapTime, gEndTime;
 #endif
 
 /* Xlib image scaling... */
 
 #define sign(x) ((x)>0 ? 1:-1)
 
+static void xerrmessage(gint err) {
+ gchar msg[128];
+ XGetErrorText(GDK_DISPLAY(),err,msg,128);
+ fprintf(stderr, "X error code %d was trapped [%s]. Your page will not display correctly.\n",err,msg);
+ fflush(stderr);
+}
+
 static void XlibStretchHorizontal(long x1,long x2,long y1,long y2,
                                   long ymin,long ymax,
                                   long startColumn, long endColumn,
                                   long offsetX, long offsetY,
                                   GdkPixmap *aSrcImage, GdkPixmap *aDstImage, GdkGC *gc);
 
 /**********************************************************
  XlibRectStretch enlarges or diminishes a source rectangle of a bitmap to
@@ -502,31 +511,32 @@
 
  Entry:
 	xs1,ys1 - first point of source rectangle
 	xs2,ys2 - second point of source rectangle
 	xd1,yd1 - first point of destination rectangle
 	xd2,yd2 - second point of destination rectangle
   offx, offy - offset to target
 **********************************************************/
-void
+PRBool
 XlibRectStretch(PRInt32 srcWidth, PRInt32 srcHeight,
                 PRInt32 dstWidth, PRInt32 dstHeight,
                 PRInt32 dstOrigX, PRInt32 dstOrigY,
                 PRInt32 aDX, PRInt32 aDY,
                 PRInt32 aDWidth, PRInt32 aDHeight,
                 GdkPixmap *aSrcImage, GdkPixmap *aDstImage,
                 GdkGC *gc, GdkGC *copygc, PRInt32 aDepth)
 {
   long dx,dy,e,d,dx2;
   short sx,sy;
   GdkPixmap *aTmpImage = 0;
   PRBool skipHorizontal=PR_FALSE, skipVertical=PR_FALSE;
   long startColumn, startRow, endColumn, endRow;
   long xs1, ys1, xs2, ys2, xd1, yd1, xd2, yd2;
+  gint err;
 
   xs1 = ys1 = xd1 = yd1 = 0;
   xs2 = srcWidth-1;
   ys2 = srcHeight-1;
   xd2 = dstWidth-1;
   yd2 = dstHeight-1;
 
 //  fprintf(stderr, "XRS %p (%ld %ld)-(%ld %ld) (%ld %ld)-(%ld %ld)\n",
@@ -558,26 +568,33 @@
     skipVertical = PR_TRUE;
     aTmpImage = aDstImage;
   }
 
   if (skipVertical && skipHorizontal) {
     gdk_draw_pixmap(aDstImage, gc, aSrcImage,
                     0, 0, srcWidth, srcHeight,
                     dstOrigX, dstOrigY);
-    return;
+    return PR_TRUE;
   }
 
 //  fprintf(stderr, "scaleY Start/End = %d %d\n", scaleStartY, scaleEndY);
 
   if (!skipHorizontal && !skipVertical) {
+    gdk_error_trap_push();
     aTmpImage = gdk_pixmap_new(nsnull,
                                endColumn-startColumn,
                                scaleEndY-scaleStartY,
                                aDepth);
+    gdk_flush();
+    if ((err=gdk_error_trap_pop()) || !aTmpImage) {
+      xerrmessage(err);
+      return PR_FALSE;
+    }
+
 #ifdef MOZ_WIDGET_GTK2
     if (aDepth != 1)
       gdk_drawable_set_colormap(GDK_DRAWABLE(aTmpImage),
                                 gdk_rgb_get_colormap());
 #endif
   }
  
   dx = abs((int)(yd2-yd1));
@@ -609,16 +626,17 @@
       }
       yd1 += sx;
       e += dy;
     }
   }
 
   if (!skipHorizontal && !skipVertical)
     gdk_pixmap_unref(aTmpImage);
+  return PR_TRUE;
 }
 
 /**********************************************************
  Stretches a image horizontally by column replication/deletion.
  Used by XlibRectStretch.
 
  Entry:
 	x1,x2 - x-coordinates of the destination line
@@ -772,36 +790,47 @@
   if (aDWidth <= 0 || aDHeight <= 0 || aSWidth <= 0 || aSHeight <= 0) {
     return NS_OK;
   }
 
   if ((srcWidth != dstWidth) || (srcHeight != dstHeight)) {
     GdkPixmap *pixmap = 0;
     GdkGC *gc = 0;
     nsRegionGTK clipRgn;
+    gint err;
 
     switch (mAlphaDepth) {
     case 8:
       DrawComposited(aContext, aSurface,
                      srcWidth, srcHeight,
                      dstWidth, dstHeight,
                      dstOrigX, dstOrigY,
                      aDX, aDY,
                      aDWidth, aDHeight);
       break;
     case 1:
+
+      gdk_error_trap_push();
       pixmap = gdk_pixmap_new(nsnull, dstWidth, dstHeight, 1);
+      gdk_flush();
+      if ((err=gdk_error_trap_pop()) || !pixmap) {
+        xerrmessage(err);
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
+
       if (pixmap) {
+        PRBool mem =
         XlibRectStretch(srcWidth, srcHeight,
                         dstWidth, dstHeight,
                         0, 0,
                         0, 0,
                         dstWidth, dstHeight,
                         mAlphaPixmap, pixmap,
                         s1bitGC, s1bitGC, 1);
+        if (!mem) return NS_ERROR_OUT_OF_MEMORY;
         gc = gdk_gc_new(drawing->GetDrawable());
         if (gc) {
           gdk_gc_set_clip_origin(gc, dstOrigX, dstOrigY);
           gdk_gc_set_clip_mask(gc, pixmap);
         }
       }
 
       if (gdk_rgb_get_visual()->depth <= 8) {
@@ -846,34 +875,38 @@
           // we have both a set of rectangles and a bitmap defining the clip
           // let X11 clip to the bitmap, do the rectangles by hand
           nsRegionRectSet *rectSet = nsnull;
           clipRgn.Intersect(aDX, aDY, aDWidth, aDHeight);
           clipRgn.GetRects(&rectSet);
           for (PRUint32 i=0; i<rectSet->mRectsLen; i++) {
             nsRegionRect *rect = &(rectSet->mRects[i]);
             
+            PRBool mem =
             XlibRectStretch(srcWidth, srcHeight,
                             dstWidth, dstHeight,
                             dstOrigX, dstOrigY,
                             rect->x, rect->y,
                             rect->width, rect->height,
                             mImagePixmap, drawing->GetDrawable(),
                             gc, sXbitGC, gdk_rgb_get_visual()->depth);
+            if (!mem) return NS_ERROR_OUT_OF_MEMORY;
           }
           clipRgn.FreeRects(rectSet);
         } else {
           // only a mask
+          PRBool mem =
           XlibRectStretch(srcWidth, srcHeight,
                           dstWidth, dstHeight,
                           dstOrigX, dstOrigY,
                           aDX, aDY,
                           aDWidth, aDHeight,
                           mImagePixmap, drawing->GetDrawable(),
                           gc, sXbitGC, gdk_rgb_get_visual()->depth);
+          if (!mem) return NS_ERROR_OUT_OF_MEMORY;
         }
       }
 
       break;
     case 0:
       if (!gc)
         gc = ((nsRenderingContextGTK&)aContext).GetGC();
 
@@ -890,24 +923,27 @@
                                      aDX, aDY, aDWidth, aDHeight,
                                      GDK_RGB_DITHER_MAX, 
                                      scaledRGB + 3*((aDY-dstOrigY)*dstWidth+(aDX-dstOrigX)),
                                      3*dstWidth,
                                      (aDX-dstOrigX), (aDY-dstOrigY));
 
         nsMemory::Free(scaledRGB);
       }
-      else
+      else {
+        PRBool mem =
         XlibRectStretch(srcWidth, srcHeight,
                         dstWidth, dstHeight,
                         dstOrigX, dstOrigY,
                         aDX, aDY,
                         aDWidth, aDHeight,
                         mImagePixmap, drawing->GetDrawable(),
                         gc, sXbitGC, gdk_rgb_get_visual()->depth);
+        if (!mem) return NS_ERROR_OUT_OF_MEMORY;
+      }
       break;
     }
     if (gc)
       gdk_gc_unref(gc);
     if (pixmap)
       gdk_pixmap_unref(pixmap);
 
     mFlags = 0;
@@ -1326,23 +1362,27 @@
   readWidth = aDWidth;
   readHeight = aDHeight;
 
 //  fprintf(stderr, "dstOrigX=%d dstOrigY=%d, dstWidth=%u dstHeight=%u\n", dstOrigX, dstOrigY, dstWidth, dstHeight);
 //  fprintf(stderr, "srcWidth=%u srcHeight=%u\n", srcWidth, srcHeight);
 //  fprintf(stderr, "readX=%u readY=%u readWidth=%u readHeight=%u destX=%u destY=%u\n\n",
 //          readX, readY, readWidth, readHeight, destX, destY);
 
+  gint err;
+  gdk_error_trap_push();
   XImage *ximage = XGetImage(dpy, drawable,
                              readX, readY, readWidth, readHeight, 
                              AllPlanes, ZPixmap);
-
   NS_ASSERTION((ximage!=NULL), "XGetImage() failed");
-  if (!ximage)
+  gdk_flush();
+  if ((err=gdk_error_trap_pop()) || !ximage) {
+    xerrmessage(err);
     return;
+  }
 
   unsigned char *readData = 
     (unsigned char *)nsMemory::Alloc(3*readWidth*readHeight);
   if (!readData) {
     XDestroyImage(ximage);
     return;
   }
 
@@ -1491,23 +1531,27 @@
   if (readX+readWidth > surfaceWidth)
     readWidth = surfaceWidth-readX;
   if (readY+readHeight > surfaceHeight)
     readHeight = surfaceHeight-readY;
 
   if ((readHeight <= 0) || (readWidth <= 0))
     return;
 
+  gint err;
+  gdk_error_trap_push();
   XImage *ximage = XGetImage(dpy, drawable,
                              readX, readY, readWidth, readHeight, 
                              AllPlanes, ZPixmap);
-
   NS_ASSERTION((ximage!=NULL), "XGetImage() failed");
-  if (!ximage)
+  gdk_flush();
+  if ((err=gdk_error_trap_pop()) || !ximage) {
+    xerrmessage(err);
     return;
+  }
 
   unsigned char *readData = 
     (unsigned char *)nsMemory::Alloc(3*readWidth*readHeight);
   if (!readData) {
     XDestroyImage(ximage);
     return;
   }
 
@@ -1598,40 +1642,58 @@
   gdk_gc_unref(imageGC);
 
   XDestroyImage(ximage);
   nsMemory::Free(readData);
   mFlags = 0;
 }
 
 
-void nsImageGTK::CreateOffscreenPixmap(PRInt32 aWidth, PRInt32 aHeight)
+PRBool nsImageGTK::CreateOffscreenPixmap(PRInt32 aWidth, PRInt32 aHeight)
 {
+  gint err;
   // Render unique image bits onto an off screen pixmap only once
   // The image bits can change as a result of ImageUpdated() - for
   // example: animated GIFs.
   if (!mImagePixmap) {
 #ifdef TRACE_IMAGE_ALLOCATION
     printf("nsImageGTK::Draw(this=%p) gdk_pixmap_new(nsnull,width=%d,height=%d,depth=%d)\n",
            this,
            aWidth, aHeight,
            mDepth);
 #endif
 
     // Create an off screen pixmap to hold the image bits.
+    gdk_error_trap_push();
     mImagePixmap = gdk_pixmap_new(nsnull, aWidth, aHeight,
                                   gdk_rgb_get_visual()->depth);
+    gdk_flush();
+    if ((err=gdk_error_trap_pop()) || !mImagePixmap) {
+      xerrmessage(err);
+      mWidth = 0;
+      mHeight = 0;
+      return PR_FALSE;
+    }
+
 #ifdef MOZ_WIDGET_GTK2
     gdk_drawable_set_colormap(GDK_DRAWABLE(mImagePixmap), gdk_rgb_get_colormap());
 #endif
   }
 
     // Ditto for the clipmask
   if ((!mAlphaPixmap) && (mAlphaDepth==1)) {
+    gdk_error_trap_push();
     mAlphaPixmap = gdk_pixmap_new(nsnull, aWidth, aHeight, 1);
+    gdk_flush();
+    if ((err=gdk_error_trap_pop()) || !mAlphaPixmap) {
+      xerrmessage(err);
+      mWidth = 0;
+      mHeight = 0;
+      return PR_FALSE;
+    }
 
     // Need an XImage for clipmask updates (XPutImage)
     mAlphaXImage = XCreateImage(GDK_WINDOW_XDISPLAY(mAlphaPixmap),
                                 GDK_VISUAL_XVISUAL(gdk_rgb_get_visual()),
                                 1, /* visual depth...1 for bitmaps */
                                 XYPixmap,
                                 0, /* x offset, XXX fix this */
                                 (char *)mAlphaBits,  /* cast away our sign. */
@@ -1655,16 +1717,17 @@
       GdkColor fg = { 1, 0, 0, 0 };
       s1bitGC = gdk_gc_new(mAlphaPixmap);
       gdk_gc_set_foreground(s1bitGC, &fg);
     }
   }
 
   if (!sXbitGC)
     sXbitGC = gdk_gc_new(mImagePixmap);
+  return PR_TRUE;
 }
 
 
 void nsImageGTK::SetupGCForAlpha(GdkGC *aGC, PRInt32 aX, PRInt32 aY)
 {
   // XXX should use (different?) GC cache here
   if (mAlphaPixmap) {
     // Setup gc to use the given alpha-pixmap for clipping
@@ -1739,31 +1802,44 @@
 
 void nsImageGTK::SlowTile(nsDrawingSurfaceGTK *aSurface,
                           const nsRect &aTileRect,
                           PRInt32 aSXOffset, PRInt32 aSYOffset,
                           const nsRect& aClipRect, PRBool aHaveClip)
 {
   GdkPixmap *tileImg;
   GdkPixmap *tileMask;
+  gint err;
 
   nsRect tmpRect(0,0,aTileRect.width, aTileRect.height);
 
+  gdk_error_trap_push();
   tileImg = gdk_pixmap_new(nsnull, aTileRect.width, 
                            aTileRect.height, aSurface->GetDepth());
+  gdk_flush();
+  if ((err=gdk_error_trap_pop()) || !tileImg) {
+    xerrmessage(err);
+    return;
+  }
 #ifdef MOZ_WIDGET_GTK2
   gdk_drawable_set_colormap(GDK_DRAWABLE(tileImg), gdk_rgb_get_colormap());
 #endif
 
   TilePixmap(mImagePixmap, tileImg, aSXOffset, aSYOffset, tmpRect,
              tmpRect, PR_FALSE);
 
   // tile alpha mask
+  gdk_error_trap_push();
   tileMask = gdk_pixmap_new(nsnull, aTileRect.width, aTileRect.height,
                             mAlphaDepth);
+  gdk_flush();
+  if ((err=gdk_error_trap_pop()) || !tileMask) {
+    xerrmessage(err);
+    return;
+  }
   TilePixmap(mAlphaPixmap, tileMask, aSXOffset, aSYOffset, tmpRect,
              tmpRect, PR_FALSE);
 
   GdkGC *fgc = gdk_gc_new(aSurface->GetDrawable());
   gdk_gc_set_clip_mask(fgc, (GdkBitmap*)tileMask);
   gdk_gc_set_clip_origin(fgc, aTileRect.x, aTileRect.y);
 
   nsRect drawRect = aTileRect;
@@ -1980,27 +2056,35 @@
   return NS_OK;
 }
 
 //------------------------------------------------------------
 // lock the image pixels
 NS_IMETHODIMP
 nsImageGTK::LockImagePixels(PRBool aMaskPixels)
 {
+  gint err;
+
   if (!mOptimized)
     return NS_OK;
 
   if (aMaskPixels) {
     if (mAlphaDepth != 1 || !mAlphaPixmap)
       return NS_OK;
 
+    gdk_error_trap_push();
     XImage *xmask = XGetImage(GDK_WINDOW_XDISPLAY(mAlphaPixmap),
                               GDK_WINDOW_XWINDOW(mAlphaPixmap),
                               0, 0, mWidth, mHeight,
                               AllPlanes, XYPixmap);
+    gdk_flush();
+    if ((err=gdk_error_trap_pop()) || !xmask) {
+      xerrmessage(err);
+      return NS_OK;
+    }
 
     mAlphaBits = (PRUint8*)calloc(mAlphaRowBytes * mHeight, 1);
     if (!mAlphaBits)
       return NS_ERROR_OUT_OF_MEMORY;
 
     for (PRInt32 y = 0; y < mHeight; ++y) {
       PRUint8 *alphaTarget = mAlphaBits + y*mAlphaRowBytes;
       PRUint32 alphaBitPos = 7;
@@ -2019,26 +2103,39 @@
   }
 
   if (!mImagePixmap)
     return NS_OK;
 
   XImage *ximage, *xmask=0;
   unsigned pix;
 
+  gdk_error_trap_push();
   ximage = XGetImage(GDK_WINDOW_XDISPLAY(mImagePixmap),
                      GDK_WINDOW_XWINDOW(mImagePixmap),
                      0, 0, mWidth, mHeight,
                      AllPlanes, ZPixmap);
+  gdk_flush();
+  if ((err=gdk_error_trap_pop()) || !ximage) {
+    xerrmessage(err);
+    return NS_OK;
+  }
 
-  if ((mAlphaDepth==1) && mAlphaPixmap)
+  if ((mAlphaDepth==1) && mAlphaPixmap) {
+    gdk_error_trap_push();
     xmask = XGetImage(GDK_WINDOW_XDISPLAY(mAlphaPixmap),
                       GDK_WINDOW_XWINDOW(mAlphaPixmap),
                       0, 0, mWidth, mHeight,
                       AllPlanes, XYPixmap);
+    gdk_flush();
+    if ((err=gdk_error_trap_pop()) || !ximage) {
+      xerrmessage(err);
+      return NS_OK;
+    }
+  }
 
   mImageBits = (PRUint8*)malloc(mSizeImage);
   if (!mImageBits)
     return NS_ERROR_OUT_OF_MEMORY;
 
   GdkVisual *visual = gdk_rgb_get_visual();
   GdkColormap *colormap = gdk_rgb_get_cmap();
 
Index: mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.cpp
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
@@ -148,17 +148,22 @@
 //  ::gdk_rgb_init();
 
   mSurface = new nsDrawingSurfaceGTK();
   mDisplay = GDK_DISPLAY();
 
   if (mSurface)
   {
     if (!aWindow) return NS_ERROR_NULL_POINTER;
-
+    if (!mDisplay)
+    {
+        delete mSurface;
+        mSurface = nsnull;
+        return NS_ERROR_OUT_OF_MEMORY;
+    }
     // we want to ref the window here so that we can unref in the drawing surface.
     // otherwise, we can not unref and that causes windows that are created in the
     // drawing surface not to be freed.
     GdkDrawable *win = (GdkDrawable*)aWindow->GetNativeData(NS_NATIVE_WINDOW);
     if (win)
       gdk_window_ref((GdkWindow*)win);
     else
     {
@@ -166,20 +171,28 @@
 
       if (!w)
       {
           delete mSurface;
           mSurface = nsnull;
           return NS_ERROR_NULL_POINTER;
       }
 
+      gdk_error_trap_push();
       win = gdk_pixmap_new(nsnull,
                            w->allocation.width,
                            w->allocation.height,
                            gdk_rgb_get_visual()->depth);
+      gdk_flush();
+      if (gdk_error_trap_pop() || !win)
+      {
+        delete mSurface;
+        mSurface = nsnull;
+        return NS_ERROR_OUT_OF_MEMORY;
+      }
 #ifdef MOZ_WIDGET_GTK2
       gdk_drawable_set_colormap(win, gdk_rgb_get_colormap());
 #endif
     }
 
     GdkGC *gc = (GdkGC *)aWindow->GetNativeData(NS_NATIVE_GRAPHIC);
     mSurface->Init(win,gc);
 
@@ -196,16 +209,18 @@
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::Init(nsIDeviceContext* aContext,
                                           nsIDrawingSurface* aSurface)
 {
   mContext = aContext;
   NS_IF_ADDREF(mContext);
 
+  mDisplay = GDK_DISPLAY();
+
   mSurface = (nsDrawingSurfaceGTK *) aSurface;
   NS_ADDREF(mSurface);
   mOffscreenSurface = mSurface;
 
   return (CommonInit());
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::CommonInit()
Index: mozilla/gfx/src/gtk/nsImageGTK.h
===================================================================
--- mozilla.orig/gfx/src/gtk/nsImageGTK.h
+++ mozilla/gfx/src/gtk/nsImageGTK.h
@@ -181,17 +181,17 @@
                                 nsIDrawingSurface* aSurface,
                                 PRInt32 aSX, PRInt32 aSY,
                                 PRInt32 aSWidth, PRInt32 aSHeight,
                                 PRInt32 aDX, PRInt32 aDY,
                                 PRInt32 aDWidth, PRInt32 aDHeight);
 
   inline void TilePixmap(GdkPixmap *src, GdkPixmap *dest, PRInt32 aSXOffset, PRInt32 aSYOffset, 
                          const nsRect &destRect, const nsRect &clipRect, PRBool useClip);
-  inline void CreateOffscreenPixmap(PRInt32 aWidth, PRInt32 aHeight);
+  inline PRBool CreateOffscreenPixmap(PRInt32 aWidth, PRInt32 aHeight);
   inline void SetupGCForAlpha(GdkGC *aGC, PRInt32 aX, PRInt32 aY);
 
   void SlowTile(nsDrawingSurfaceGTK *aSurface, const nsRect &aTileRect,
                 PRInt32 aSXOffset, PRInt32 aSYOffset, const nsRect& aRect, PRBool aIsValid);
 
   PRUint8      *mImageBits;
   GdkPixmap    *mImagePixmap;
   PRUint8      *mTrueAlphaBits;
