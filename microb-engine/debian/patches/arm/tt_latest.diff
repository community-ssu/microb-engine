diff -ruN mozilla-central/js/src/Makefile.in tracemonkey/js/src/Makefile.in
--- mozilla-central/js/src/Makefile.in	2008-09-06 14:33:17.000000000 +0300
+++ tracemonkey/js/src/Makefile.in	2008-09-06 14:28:09.000000000 +0300
@@ -95,8 +95,18 @@
 endif
 endif
 
+ifeq (arm,$(findstring arm,$(OS_TEST)))
+DEFINES += -DAVMPLUS_ARM
+NANOJIT_ARCH = ARM
+ENABLE_JIT = 1
+endif
+
+ifneq (,$(filter Linux Darwin SunOS FreeBSD,$(OS_ARCH)))
+DEFINES += -DAVMPLUS_UNIX
+endif
+
 ifeq ($(OS_ARCH),Linux)
-DEFINES += -DAVMPLUS_LINUX -DLINUX
+DEFINES += -DAVMPLUS_LINUX
 endif
 
 ifeq ($(OS_ARCH),WINNT)
@@ -427,6 +437,18 @@
 endif
 endif
 
+# Sun Studio x86 has an optimization bug with LIR.cpp, use -xO2 instead.
+ifeq ($(OS_ARCH),SunOS)
+ifeq (86,$(findstring 86,$(OS_TEST)))
+ifndef GNU_CC
+LIR.o: LIR.cpp Makefile.in
+    $(REPORT_BUILD)
+    @$(MAKE_DEPS_AUTO_CXX)
+    $(CXX) -o $@ -c $(patsubst -xO%,-xO2,$(COMPILE_CFLAGS)) $<
+endif
+endif
+endif
+
 # Allow building jsinterp.c with special optimization flags
 ifdef INTERP_OPTIMIZER
 jsinterp.$(OBJ_SUFFIX): MODULE_OPTIMIZE_FLAGS=$(INTERP_OPTIMIZER)
diff -ruN mozilla-central/js/src/builtins.tbl tracemonkey/js/src/builtins.tbl
--- mozilla-central/js/src/builtins.tbl	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/builtins.tbl	2008-09-06 10:27:55.000000000 +0300
@@ -54,6 +54,7 @@
 BUILTIN1(Math_sqrt,             F,      F,      jsdouble,  jsdouble, 1, 1)
 BUILTIN1(Math_floor,            F,      F,      jsdouble,  jsdouble, 1, 1)
 BUILTIN1(Math_ceil,             F,      F,      jsdouble,  jsdouble, 1, 1)
+BUILTIN1(Math_log,              F,      F,      jsdouble,  jsdouble, 1, 1)
 BUILTIN4(Array_dense_setelem,   LO, LO, LO, LO, LO, bool,  JSContext*, JSObject*, jsint, jsval, 0, 0)
 BUILTIN3(Array_p_join,          LO, LO, LO, P,  JSString*, JSContext*, JSObject*, JSString*, 0, 0)
 BUILTIN4(String_p_substring,    LO, LO, LO, LO, P,  JSString*, JSContext*, JSString*, jsint, jsint, 1, 1)
@@ -98,6 +99,10 @@
 BUILTIN2(BooleanToNumber,       LO, LO, F,      jsdouble,  JSContext*, jsint, 1, 1)
 BUILTIN2(ObjectToString,        LO,     LO, P,  JSString*, JSContext*, JSObject*, 0, 0)
 BUILTIN3(Array_1int,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, jsint, 0, 0)
+BUILTIN3(Array_1str,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, JSString*, 0, 0)
+BUILTIN4(Array_2obj,            LO, LO, LO, LO, P, JSObject*, JSContext*, JSObject*, JSObject*, JSObject**, 0, 0)
+BUILTIN5(Array_3num,            LO, LO, F, F, F, P, JSObject*, JSContext*, JSObject*, jsdouble, jsdouble, jsdouble, 0, 0)
+BUILTIN1(Arguments,             LO,     P,      JSObject*, JSContext*, 0, 0)
 
 // soft float
 BUILTIN1(fneg,   F,       F,  jsdouble, jsdouble, 1, 1)
@@ -112,6 +117,3 @@
 BUILTIN2(fadd,   F,   F,  F,  jsdouble, jsdouble, jsdouble, 1, 1)
 BUILTIN2(fdiv,   F,   F,  F,  jsdouble, jsdouble, jsdouble, 1, 1)
 BUILTIN2(fsub,   F,   F,  F,  jsdouble, jsdouble, jsdouble, 1, 1)
-BUILTIN3(Array_1str,            LO, LO, LO, P,  JSObject*, JSContext*, JSObject*, JSString*, 0, 0)
-BUILTIN4(Array_2obj,            LO, LO, LO, LO, P, JSObject*, JSContext*, JSObject*, JSObject*, JSObject**, 0, 0)
-BUILTIN5(Array_3num,            LO, LO, F, F, F, P, JSObject*, JSContext*, JSObject*, jsdouble, jsdouble, jsdouble, 0, 0)
diff -ruN mozilla-central/js/src/config/Darwin.mk tracemonkey/js/src/config/Darwin.mk
--- mozilla-central/js/src/config/Darwin.mk	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/config/Darwin.mk	2008-09-06 10:27:55.000000000 +0300
@@ -60,7 +60,7 @@
 ifeq (86,$(findstring 86,$(CPU_ARCH)))
 CPU_ARCH = x86
 OS_CFLAGS+= -DX86_LINUX
-OS_CFLAGS += -DAVMPLUS_IA32
+OS_CFLAGS += -DAVMPLUS_IA32 -DAVMPLUS_UNIX
 NANOJIT_ARCH = i386
 endif
 GFX_ARCH = x
diff -ruN mozilla-central/js/src/config/Linux_All.mk tracemonkey/js/src/config/Linux_All.mk
--- mozilla-central/js/src/config/Linux_All.mk	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/config/Linux_All.mk	2008-09-06 10:27:55.000000000 +0300
@@ -57,7 +57,7 @@
 ifneq (x86_64,$(CPU_ARCH))
 ifeq (86,$(findstring 86,$(CPU_ARCH)))
 CPU_ARCH = x86
-OS_CFLAGS += -DX86_LINUX -DAVMPLUS_IA32 -DAVMPLUS_LINUX
+OS_CFLAGS += -DX86_LINUX -DAVMPLUS_IA32 -DAVMPLUS_UNIX -DAVMPLUS_LINUX
 NANOJIT_ARCH = i386
 
 ifeq (gcc, $(CC))
@@ -74,12 +74,12 @@
 endif # !x86_64
 
 ifeq ($(CPU_ARCH),x86_64)
-OS_CFLAGS += -DAVMPLUS_AMD64 -DAVMPLUS_64BIT -DAVMPLUS_LINUX
+OS_CFLAGS += -DAVMPLUS_AMD64 -DAVMPLUS_64BIT -DAVMPLUS_UNIX -DAVMPLUS_LINUX
 NANOJIT_ARCH = i386
 endif
 
 ifeq ($(CPU_ARCH),arm)
-OS_CFLAGS += -DAVMPLUS_ARM -DAVMPLUS_LINUX
+OS_CFLAGS += -DAVMPLUS_ARM -DAVMPLUS_UNIX -DAVMPLUS_LINUX
 NANOJIT_ARCH = ARM
 endif
 
diff -ruN mozilla-central/js/src/jsbuiltins.cpp tracemonkey/js/src/jsbuiltins.cpp
--- mozilla-central/js/src/jsbuiltins.cpp	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/jsbuiltins.cpp	2008-09-06 10:27:55.000000000 +0300
@@ -167,14 +167,13 @@
     return ceil(d);
 }
 
+extern jsdouble js_NaN;
+
 jsdouble FASTCALL
 js_Math_pow(jsdouble d, jsdouble p)
 {
-#ifdef NOTYET
-    /* XXX Need to get a NaN here without parameterizing on context all the time. */
     if (!JSDOUBLE_IS_FINITE(p) && (d == 1.0 || d == -1.0))
-        return NaN;
-#endif
+        return js_NaN;
     if (p == 0)
         return 1.0;
     return pow(d, p);
@@ -186,6 +185,16 @@
     return sqrt(d);
 }
 
+jsdouble FASTCALL
+js_Math_log(jsdouble d)
+{
+#if !JS_USE_FDLIBM_MATH && defined(SOLARIS) && defined(__GNUC__)
+    if (d < 0)
+        return js_NaN;
+#endif
+    return log(d);
+}
+
 JSBool FASTCALL
 js_Array_dense_setelem(JSContext* cx, JSObject* obj, jsint i, jsval v)
 {
@@ -350,7 +359,7 @@
          js_SkipWhiteSpace(ep, end) != end) &&
         (!js_strtointeger(cx, bp, end, &ep, 0, &d) ||
          js_SkipWhiteSpace(ep, end) != end)) {
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     }
     return d;
 }
@@ -379,7 +388,7 @@
 
     JSSTRING_CHARS_AND_END(str, bp, end);
     if (!js_strtod(cx, bp, end, &ep, &d) || ep == bp)
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     return d;
 }
 
@@ -393,7 +402,7 @@
 
     JSSTRING_CHARS_AND_END(str, bp, end);
     if (!js_strtointeger(cx, bp, end, &ep, 0, &d) || ep == bp)
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     return d;
 }
 
@@ -649,7 +658,7 @@
 js_BooleanToNumber(JSContext* cx, jsint unboxed)
 {
     if (unboxed == JSVAL_TO_BOOLEAN(JSVAL_VOID))
-        return *cx->runtime->jsNaN;
+        return js_NaN;
     return unboxed;
 }
 
@@ -719,6 +728,12 @@
             return NULL;)
 }
 
+JSObject* FASTCALL
+js_Arguments(JSContext* cx)
+{
+    return NULL;
+}
+
 /* soft float */
 
 jsdouble FASTCALL
diff -ruN mozilla-central/js/src/jsmath.cpp tracemonkey/js/src/jsmath.cpp
--- mozilla-central/js/src/jsmath.cpp	2008-09-06 14:33:18.000000000 +0300
+++ tracemonkey/js/src/jsmath.cpp	2008-09-06 14:28:09.000000000 +0300
@@ -299,8 +299,8 @@
     return js_NewNumberInRootedValue(cx, z, vp);
 }
 
-static JSBool
-math_log(JSContext *cx, uintN argc, jsval *vp)
+JSBool
+js_math_log(JSContext *cx, uintN argc, jsval *vp)
 {
     jsdouble x, z;
 
@@ -597,7 +597,7 @@
     JS_FN("cos",            js_math_cos,        1, 0),
     JS_FN("exp",            math_exp,           1, 0),
     JS_FN("floor",          js_math_floor,      1, 0),
-    JS_FN("log",            math_log,           1, 0),
+    JS_FN("log",            js_math_log,        1, 0),
     JS_FN("max",            math_max,           2, 0),
     JS_FN("min",            math_min,           2, 0),
     JS_FN("pow",            js_math_pow,        2, 0),
diff -ruN mozilla-central/js/src/jstracer.cpp tracemonkey/js/src/jstracer.cpp
--- mozilla-central/js/src/jstracer.cpp	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/jstracer.cpp	2008-09-06 14:28:09.000000000 +0300
@@ -47,6 +47,9 @@
 #include <malloc.h>
 #define alloca _alloca
 #endif
+#ifdef SOLARIS
+#include <alloca.h>
+#endif
 
 #include "nanojit/avmplus.h"    // nanojit
 #include "nanojit/nanojit.h"
@@ -74,7 +77,7 @@
 #define HOTEXIT 1
 
 /* Max call depths for inlining. */
-#define MAX_CALLDEPTH 5
+#define MAX_CALLDEPTH 10
 
 /* Max number of type mismatchs before we trash the tree. */
 #define MAX_MISMATCH 5
@@ -120,7 +123,9 @@
 /* We really need a better way to configure the JIT. Shaver, where is my fancy JIT object? */
 static bool nesting_enabled = true;
 static bool oracle_enabled = true;
+#if defined(NANOJIT_IA32)
 static bool did_we_check_sse2 = false;
+#endif
 
 #if defined(DEBUG) || defined(INCLUDE_VERBOSE_OUTPUT)
 static bool verbose_debug = getenv("TRACEMONKEY") && strstr(getenv("TRACEMONKEY"), "verbose");
@@ -345,7 +350,7 @@
 {
     jsdouble d;
     return isi2f(i) || i->isconst() ||
-        (i->isconstq() && ((d = i->constvalf()) == (jsdouble)(jsint)d) && !JSDOUBLE_IS_NEGZERO(d));
+        (i->isconstq() && (d = i->constvalf()) == jsdouble(jsint(d)) && !JSDOUBLE_IS_NEGZERO(d));
 }
 
 static bool isPromoteUint(LIns* i)
@@ -365,6 +370,11 @@
     return i->isconst() && i->constval() == c;
 }
 
+static bool isAnyConst(LIns* i)
+{
+    return i->isconst() || i->isconstq(); 
+}
+
 static bool overflowSafe(LIns* i)
 {
     LIns* c;
@@ -796,8 +806,9 @@
     this->callDepth = _fragment->calldepth;
     JS_ASSERT(!_anchor || _anchor->calldepth == _fragment->calldepth);
     this->atoms = cx->fp->script->atomMap.vector;
-    this->trashTree = false;
     this->deepAborted = false;
+    this->applyingArguments = false;
+    this->trashTree = false;
     this->whichTreeToTrash = _fragment->root;
 
     debug_only_v(printf("recording starting from %s:%u@%u\n", cx->fp->script->filename,
@@ -1346,8 +1357,8 @@
     /* If we are writing to this location for the first time, calculate the offset into the
        native frame manually, otherwise just look up the last load or store associated with
        the same source address (p) and use the same offset/base. */
-    LIns* x;
-    if ((x = nativeFrameTracker.get(p)) == NULL) {
+    LIns* x = nativeFrameTracker.get(p);
+    if (!x) {
         if (isGlobal(p))
             x = writeBack(i, gp_ins, nativeGlobalOffset(p));
         else
@@ -2274,7 +2285,7 @@
     u.code = f->code();
 
 #ifdef DEBUG
-#if defined(NANOJIT_IA32)
+#if defined(NANOJIT_IA32) || (defined(NANOJIT_AMD64) && defined(__GNUC__))
     uint64 start = rdtsc();
 #endif
 #endif
@@ -2359,10 +2370,10 @@
     JS_ASSERT(fp->slots + fp->script->nfixed +
               js_ReconstructStackDepth(cx, fp->script, fp->regs->pc) == fp->regs->sp);
 
-#if defined(DEBUG) && defined(NANOJIT_IA32)
+#if defined(DEBUG) && (defined(NANOJIT_IA32) || (defined(NANOJIT_AMD64) && defined(__GNUC__)))
     uint64 cycles = rdtsc() - start;
-#else
-    debug_only_v(uint64 cycles = 0;)
+#elif defined(DEBUG)
+    uint64 cycles = 0;
 #endif
 
     debug_only_v(printf("leaving trace at %s:%u@%u, op=%s, lr=%p, exitType=%d, sp=%d, ip=%p, "
@@ -2474,6 +2485,11 @@
 js_MonitorRecording(JSContext* cx)
 {
     TraceRecorder *tr = JS_TRACE_MONITOR(cx).recorder;
+
+    // Clear one-shot flag used to communicate between record_JSOP_CALL and record_EnterFrame.
+    tr->applyingArguments = false;
+
+    // Process deepAbort() requests now.
     if (tr->wasDeepAborted()) {
         js_AbortRecording(cx, NULL, "deep abort requested");
         return false;
@@ -2538,8 +2554,17 @@
         "mov %%edx, %0\n"
         "popa\n"
         : "=m" (features)
+        /* We have no inputs */
+        /* We don't clobber anything */
+       );
+#elif defined __SUNPRO_C || defined __SUNPRO_CC
+    asm("push %%ebx\n"
+        "mov $0x01, %%eax\n"
+        "cpuid\n"
+        "pop %%ebx\n"
+        : "=d" (features)
         : /* We have no inputs */
-        : /* We don't clobber anything */
+        : "%eax", "%ecx"
        );
 #endif
     return (features & (1<<26)) != 0;
@@ -2788,9 +2813,17 @@
         jsdouble d = asNumber(v);
         jsdpun u;
         u.d = 0;
-        guard(d == 0 || JSDOUBLE_IS_NaN(d),
-              lir->ins2(LIR_feq, get(&v), lir->insImmq(u.u64)),
-              BRANCH_EXIT);
+        LIns* v_ins = get(&v);
+
+        // Only insert the guard if the condition is not constant, since in 
+        // that case at runtime we would always take the same path as the
+        // interpreter is taking right now and hence there is no need for
+        // a guard.        
+        if (!v_ins->isconst() && !v_ins->isconstq()) {
+            guard(d == 0 || JSDOUBLE_IS_NaN(d),
+                  lir->ins2(LIR_feq, v_ins, lir->insImmq(u.u64)),
+                  BRANCH_EXIT);
+        }
     } else if (JSVAL_IS_STRING(v)) {
         guard(JSSTRING_LENGTH(JSVAL_TO_STRING(v)) == 0,
               lir->ins_eq0(lir->ins2(LIR_piand,
@@ -2922,9 +2955,12 @@
     LIns* x;
     bool negate = !!(flags & CMP_NEGATE);
     bool cond;
+    LIns* l_ins = get(&l);
+    LIns* r_ins = get(&r);
+
     if (JSVAL_IS_STRING(l) && JSVAL_IS_STRING(r)) {
         JS_ASSERT(!negate);
-        LIns* args[] = { get(&r), get(&l) };
+        LIns* args[] = { r_ins, l_ins };
         x = lir->ins1(LIR_i2f, lir->insCall(F_CompareStrings, args));
         x = lir->ins2i(op, x, 0);
         jsint result = js_CompareStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
@@ -2950,8 +2986,6 @@
         JSAutoTempValueRooter tvr(cx, 2, tmp);
 
         // TODO: coerce non-numbers to numbers if it's not string-on-string above
-        LIns* l_ins = get(&l);
-        LIns* r_ins = get(&r);
         jsdouble lnum;
         jsdouble rnum;
         LIns* args[] = { l_ins, cx_ins };
@@ -2971,7 +3005,7 @@
         }
         lnum = js_ValueToNumber(cx, &tmp[0]);
 
-        args[0] = get(&r);
+        args[0] = r_ins;
         args[1] = cx_ins;
         if (JSVAL_IS_STRING(r)) {
             r_ins = lir->insCall(F_StringToNumber, args);
@@ -3035,16 +3069,22 @@
         ABORT_TRACE("unsupported operand types for cmp");
     }
 
-    if (flags & CMP_CASE) {
-        guard(cond, x, BRANCH_EXIT);
+    /* Don't guard if the same path is always taken. */
+    if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
+        if (flags & CMP_CASE) {
+            guard(cond, x, BRANCH_EXIT);
+            return true;
+        }
+
+        /* The interpreter fuses comparisons and the following branch,
+           so we have to do that here as well. */
+        if (flags & CMP_TRY_BRANCH_AFTER_COND) {
+            fuseIf(cx->fp->regs->pc + 1, cond, x);
+        }
+    } else if (flags & CMP_CASE) {
         return true;
     }
 
-    /* The interpreter fuses comparisons and the following branch,
-       so we have to do that here as well. */
-    if (flags & CMP_TRY_BRANCH_AFTER_COND) 
-        fuseIf(cx->fp->regs->pc + 1, cond, x);
-
     /* We update the stack after the guard. This is safe since
        the guard bails out at the comparison and the interpreter
        will therefore re-execute the comparison. This way the
@@ -3063,23 +3103,33 @@
     jsval& r = stackval(-1);
     jsval& l = stackval(-2);
     bool negate = !!(flags & CMP_NEGATE);
+
+    LIns* r_ins = get(&r);
+    LIns* l_ins = get(&l);
+
     if (JSVAL_IS_STRING(l) && JSVAL_IS_STRING(r)) {
-        LIns* args[] = { get(&r), get(&l) };
+        LIns* args[] = { r_ins, l_ins };
         bool cond = js_EqualStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r)) ^ negate;
         LIns* x = lir->ins_eq0(lir->insCall(F_EqualStrings, args));
         if (!negate)
             x = lir->ins_eq0(x);
 
-        if (flags & CMP_CASE) {
-            guard(cond, x, BRANCH_EXIT);
+        /* Don't guard if the same path is always taken. */
+        if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
+            if (flags & CMP_CASE) {
+                guard(cond, x, BRANCH_EXIT);
+                return true;
+            }
+
+            /* The interpreter fuses comparisons and the following branch,
+               so we have to do that here as well. */
+            if (flags & CMP_TRY_BRANCH_AFTER_COND) {
+                fuseIf(cx->fp->regs->pc + 1, cond, x);
+            }
+        } else if (flags & CMP_CASE) {
             return true;
         }
 
-        /* The interpreter fuses comparisons and the following branch,
-           so we have to do that here as well. */
-        if (flags & CMP_TRY_BRANCH_AFTER_COND)
-            fuseIf(cx->fp->regs->pc + 1, cond, x);
-
         /* We update the stack after the guard. This is safe since
            the guard bails out at the comparison and the interpreter
            will therefore re-execute the comparison. This way the
@@ -3090,20 +3140,26 @@
     }
     if (JSVAL_IS_OBJECT(l) && JSVAL_IS_OBJECT(r)) {
         bool cond = (l == r) ^ negate;
-        LIns* x = lir->ins2(LIR_eq, get(&l), get(&r));
+        LIns* x = lir->ins2(LIR_eq, l_ins, r_ins);
         if (negate)
             x = lir->ins_eq0(x);
 
-        if (flags & CMP_CASE) {
-            guard(cond, x, BRANCH_EXIT);
+        /* Don't guard if the same path is always taken. */
+        if (!(isAnyConst(r_ins) && isAnyConst(l_ins))) {
+            if (flags & CMP_CASE) {
+                guard(cond, x, BRANCH_EXIT);
+                return true;
+            }
+
+            /* The interpreter fuses comparisons and the following branch,
+               so we have to do that here as well. */
+            if (flags & CMP_TRY_BRANCH_AFTER_COND) {
+                fuseIf(cx->fp->regs->pc + 1, cond, x);
+            }
+        } else if (flags & CMP_CASE) {
             return true;
         }
 
-        /* The interpreter fuses comparisons and the following branch,
-           so we have to do that here as well. */
-        if (flags & CMP_TRY_BRANCH_AFTER_COND)
-            fuseIf(cx->fp->regs->pc + 1, cond, x);
-
         /* We update the stack after the guard. This is safe since
            the guard bails out at the comparison and the interpreter
            will therefore re-execute the comparison. This way the
@@ -3566,7 +3622,7 @@
     // guard(index < capacity)
     guard(false, lir->ins_eq0(dslots_ins), MISMATCH_EXIT);
     guard(true,
-          lir->ins2(LIR_lt, idx_ins, lir->insLoad(LIR_ldp, dslots_ins, 0 - sizeof(jsval))),
+          lir->ins2(LIR_lt, idx_ins, lir->insLoad(LIR_ldp, dslots_ins, 0 - (int)sizeof(jsval))),
           MISMATCH_EXIT);
     return true;
 }
@@ -3606,10 +3662,20 @@
 
     jsval* vp = &fp->argv[fp->argc];
     jsval* vpstop = vp + (fp->fun->nargs - fp->argc);
-    while (vp < vpstop) {
-        if (vp >= fp->down->regs->sp)
+    if (applyingArguments) {
+        applyingArguments = false;
+        while (vp < vpstop) {
+            JS_ASSERT(vp >= fp->down->regs->sp);
             nativeFrameTracker.set(vp, (LIns*)0);
-        set(vp++, void_ins, true);
+            LIns* arg_ins = get(&fp->down->argv[fp->argc + (vp - vpstop)]);
+            set(vp++, arg_ins, true);
+        }
+    } else {
+        while (vp < vpstop) {
+            if (vp >= fp->down->regs->sp)
+                nativeFrameTracker.set(vp, (LIns*)0);
+            set(vp++, void_ins, true);
+        }
     }
 
     vp = &fp->slots[0];
@@ -3704,7 +3770,11 @@
 bool
 TraceRecorder::record_JSOP_ARGUMENTS()
 {
-    return false;
+    LIns* args[] = { cx_ins };
+    LIns* a_ins = lir->insCall(F_Arguments, args);
+    guard(false, lir->ins_eq0(a_ins), OOM_EXIT);
+    stack(0, a_ins);
+    return true;
 }
 
 bool
@@ -3863,7 +3933,11 @@
 TraceRecorder::record_JSOP_NOT()
 {
     jsval& v = stackval(-1);
-    if (JSVAL_IS_BOOLEAN(v) || JSVAL_IS_OBJECT(v)) {
+    if (JSVAL_TAG(v) == JSVAL_BOOLEAN) {
+        set(&v, lir->ins_eq0(lir->ins2i(LIR_eq, get(&v), 1)));
+        return true;
+    }
+    if (JSVAL_IS_INT(v) || JSVAL_IS_OBJECT(v)) {
         set(&v, lir->ins_eq0(get(&v)));
         return true;
     }
@@ -4497,6 +4571,7 @@
 KNOWN_NATIVE_DECL(js_math_ceil)
 KNOWN_NATIVE_DECL(js_math_cos)
 KNOWN_NATIVE_DECL(js_math_floor)
+KNOWN_NATIVE_DECL(js_math_log)
 KNOWN_NATIVE_DECL(js_math_pow)
 KNOWN_NATIVE_DECL(js_math_random)
 KNOWN_NATIVE_DECL(js_math_sin)
@@ -4511,10 +4586,11 @@
 bool
 TraceRecorder::record_JSOP_CALL()
 {
-    jsbytecode *pc = cx->fp->regs->pc;
+    JSStackFrame* fp = cx->fp;
+    jsbytecode *pc = fp->regs->pc;
     uintN argc = GET_ARGC(pc);
     jsval& fval = stackval(0 - (argc + 2));
-    JS_ASSERT(&fval >= StackBase(cx->fp));
+    JS_ASSERT(&fval >= StackBase(fp));
 
     jsval& tval = stackval(0 - (argc + 1));
     LIns* this_ins = get(&tval);
@@ -4550,6 +4626,7 @@
         { js_math_floor,               F_Math_floor,           "",    "d",    INFALLIBLE },
         { js_math_ceil,                F_Math_ceil,            "",    "d",    INFALLIBLE },
         { js_math_random,              F_Math_random,          "R",    "",    INFALLIBLE },
+        { js_math_log,                 F_Math_log,             "",    "d",    INFALLIBLE },
         { js_num_parseInt,             F_ParseInt,             "C",   "s",    INFALLIBLE },
         { js_num_parseFloat,           F_ParseFloat,           "C",   "s",    INFALLIBLE },
         { js_num_toString,             F_NumberToString,       "TC",   "",    FAIL_NULL },
@@ -4580,6 +4657,11 @@
         if (argc != 2)
             ABORT_TRACE("can't trace Function.prototype.apply with other than 2 args");
 
+        if (!guardShapelessCallee(tval))
+            return false;
+        JSObject* tfunobj = JSVAL_TO_OBJECT(tval);
+        JSFunction* tfun = GET_FUNCTION_PRIVATE(cx, tfunobj);
+
         jsval& oval = stackval(-2);
         if (JSVAL_IS_PRIMITIVE(oval))
             ABORT_TRACE("can't trace Function.prototype.apply with primitive 1st arg");
@@ -4587,22 +4669,54 @@
         jsval& aval = stackval(-1);
         if (JSVAL_IS_PRIMITIVE(aval))
             ABORT_TRACE("can't trace Function.prototype.apply with primitive 2nd arg");
+        JSObject* aobj = JSVAL_TO_OBJECT(aval);
 
         LIns* aval_ins = get(&aval);
-        if (!aval_ins->isCall() || aval_ins->fid() != F_Array_1str)
-            ABORT_TRACE("can't yet trace Function.prototype.apply on other than [str] 2nd arg");
+        if (!aval_ins->isCall())
+            ABORT_TRACE("can't trace Function.prototype.apply on non-builtin-call 2nd arg");
+
+        if (aval_ins->fid() == F_Arguments) {
+            JS_ASSERT(OBJ_GET_CLASS(cx, aobj) == &js_ArgumentsClass);
+            JS_ASSERT(OBJ_GET_PRIVATE(cx, aobj) == fp);
+            if (!FUN_INTERPRETED(tfun))
+                ABORT_TRACE("can't trace Function.prototype.apply(native_function, arguments)");
+
+            argc = fp->argc;
+            if (tfun->nargs != argc)
+                ABORT_TRACE("can't trace Function.prototype.apply(scripted_function, arguments)");
+
+            jsval* sp = fp->regs->sp - 4;
+            set(sp, get(&tval));
+            *sp++ = tval;
+            set(sp, get(&oval));
+            *sp++ = oval;
+            jsval* newsp = sp + argc;
+            if (newsp > fp->slots + fp->script->nslots) {
+                JSArena* a = cx->stackPool.current;
+                if (jsuword(newsp) > a->limit)
+                    ABORT_TRACE("can't grow stack for Function.prototype.apply");
+                if (jsuword(newsp) > a->avail)
+                    a->avail = jsuword(newsp);
+            }
+
+            jsval* argv = fp->argv;
+            for (uintN i = 0; i < JS_MIN(argc, 2); i++) {
+                set(&sp[i], get(&argv[i]));
+                sp[i] = argv[i];
+            }
+            applyingArguments = true;
+            return interpretedFunctionCall(tval, tfun, argc);
+        }
+
+        if (aval_ins->fid() != F_Array_1str)
+            ABORT_TRACE("can't trace Function.prototype.apply on other than [str] 2nd arg");
 
-        JSObject* aobj = JSVAL_TO_OBJECT(aval);
         JS_ASSERT(OBJ_IS_ARRAY(cx, aobj));
         JS_ASSERT(aobj->fslots[JSSLOT_ARRAY_LENGTH] == 1);
         JS_ASSERT(JSVAL_IS_STRING(aobj->dslots[0]));
 
-        if (!guardShapelessCallee(tval))
-            return false;
-        JSObject* tfunobj = JSVAL_TO_OBJECT(tval);
-        JSFunction* tfun = GET_FUNCTION_PRIVATE(cx, tfunobj);
         if (FUN_INTERPRETED(tfun))
-            ABORT_TRACE("can't yet trace Function.prototype.apply for scripted functions");
+            ABORT_TRACE("can't trace Function.prototype.apply for scripted functions");
 
         JSTraceableNative* known;
         for (;;) {
@@ -4869,7 +4983,7 @@
 TraceRecorder::elem(jsval& l, jsval& r, jsval*& vp, LIns*& v_ins, LIns*& addr_ins)
 {
     /* no guards for type checks, trace specialized this already */
-    if (!JSVAL_IS_INT(r) || JSVAL_IS_PRIMITIVE(l))
+    if (JSVAL_IS_PRIMITIVE(l) || !JSVAL_IS_INT(r))
         return false;
 
     /*
@@ -4904,7 +5018,14 @@
 
     /* load the value, check the type (need to check JSVAL_HOLE only for booleans) */
     v_ins = lir->insLoad(LIR_ldp, addr_ins, 0);
-    return unbox_jsval(*vp, v_ins);
+    if (!unbox_jsval(*vp, v_ins))
+        return false;
+    if (JSVAL_TAG(*vp) == JSVAL_BOOLEAN) {
+        // Check to make sure *vp isn't a hole.
+        LIns* cins = lir->ins2(LIR_eq, v_ins, lir->insImm(JSVAL_TO_BOOLEAN(JSVAL_HOLE)));
+        v_ins = lir->ins_choose(cins, lir->insImm(2), v_ins, true);
+    }
+    return v_ins;
 }
 
 bool
@@ -5627,13 +5748,27 @@
 bool
 TraceRecorder::record_JSOP_ARGSUB()
 {
-    return false;
+    JSStackFrame* fp = cx->fp;
+    if (!(fp->fun->flags & JSFUN_HEAVYWEIGHT)) {
+        uintN slot = GET_ARGNO(fp->regs->pc);
+        if (slot < fp->argc && !fp->argsobj) {
+            stack(0, get(&cx->fp->argv[slot]));
+            return true;
+        }
+    }
+    ABORT_TRACE("can't trace JSOP_ARGSUB hard case");
 }
 
 bool
 TraceRecorder::record_JSOP_ARGCNT()
 {
-    return false;
+    if (!(cx->fp->fun->flags & JSFUN_HEAVYWEIGHT)) {
+        jsdpun u;
+        u.d = cx->fp->argc;
+        stack(0, lir->insImmq(u.u64));
+        return true;
+    }
+    ABORT_TRACE("can't trace heavyweight JSOP_ARGCNT");
 }
 
 bool
@@ -6042,6 +6177,12 @@
         ABORT_TRACE("callee is not an object");
     JS_ASSERT(HAS_FUNCTION_CLASS(PCVAL_TO_OBJECT(pcval)));
 
+    if (JSVAL_IS_PRIMITIVE(l)) {
+        JSFunction* fun = GET_FUNCTION_PRIVATE(cx, PCVAL_TO_OBJECT(pcval));
+        if (!PRIMITIVE_THIS_TEST(fun, l))
+            ABORT_TRACE("callee does not accept primitive |this|");
+    }
+
     stack(-1, INS_CONSTPTR(PCVAL_TO_OBJECT(pcval)));
     return true;
 }
diff -ruN mozilla-central/js/src/jstracer.h tracemonkey/js/src/jstracer.h
--- mozilla-central/js/src/jstracer.h	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/jstracer.h	2008-09-06 10:27:55.000000000 +0300
@@ -232,8 +232,9 @@
     nanojit::LIns*          rval_ins;
     nanojit::LIns*          inner_sp_ins;
     nanojit::SideExit       exit;
-    bool                    trashTree;
     bool                    deepAborted;
+    bool                    applyingArguments;
+    bool                    trashTree;
     nanojit::Fragment*      whichTreeToTrash;
     Queue<jsbytecode*>      inlinedLoopEdges;
     Queue<jsbytecode*>      cfgMerges;
@@ -331,7 +332,10 @@
 
     void trackCfgMerges(jsbytecode* pc);
     void fuseIf(jsbytecode* pc, bool cond, nanojit::LIns* x);
+
 public:
+    friend bool js_MonitorRecording(JSContext* cx);
+
     TraceRecorder(JSContext* cx, nanojit::GuardRecord*, nanojit::Fragment*, TreeInfo*,
             unsigned ngslots, uint8* globalTypeMap, uint8* stackTypeMap, 
             nanojit::GuardRecord* expectedInnerExit);
@@ -370,8 +374,7 @@
         TraceRecorder* r = JS_TRACE_MONITOR(cx).recorder;                     \
         if (!js_MonitorRecording(cx)) {                                       \
             ENABLE_TRACER(0);                                                 \
-        } else                                                                \
-        if (!r->record_##x()) {                                               \
+        } else if (!r->record_##x()) {                                        \
             js_AbortRecording(cx, NULL, #x);                                  \
             ENABLE_TRACER(0);                                                 \
         }                                                                     \
diff -ruN mozilla-central/js/src/nanojit/LIR.cpp tracemonkey/js/src/nanojit/LIR.cpp
--- mozilla-central/js/src/nanojit/LIR.cpp	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/LIR.cpp	2008-09-06 10:27:55.000000000 +0300
@@ -1480,12 +1480,10 @@
 
     LabelMap::Entry::~Entry()
     {
-        delete name;
     }
 
     LirNameMap::Entry::~Entry()
     {
-        delete name;
     }
 
     LirNameMap::~LirNameMap()
@@ -1493,18 +1491,24 @@
         Entry *e;
 
         while ((e = names.removeLast()) != NULL) {
+            labels->core->freeString(e->name);
             delete e;
         }
     }
 
-	void LirNameMap::addName(LInsp i, Stringp name) {
+	bool LirNameMap::addName(LInsp i, Stringp name) {
 		if (!names.containsKey(i)) { 
 			Entry *e = new (labels->core->gc) Entry(name);
 			names.put(i, e);
+            return true;
 		}
+        return false;
 	}
 	void LirNameMap::addName(LInsp i, const char *name) {
-		addName(i, labels->core->newString(name));
+        Stringp new_name = labels->core->newString(name);
+        if (!addName(i, new_name)) {
+            labels->core->freeString(new_name);
+        }
 	}
 
 	void LirNameMap::copyName(LInsp i, const char *s, int suffix) {
@@ -1544,12 +1548,16 @@
 		}
 		else {
 			if (ref->isCall()) {
+#if !defined NANOJIT_64BIT
 				if (ref->isop(LIR_callh)) {
 					// we've presumably seen the other half already
 					ref = ref->oprnd1();
 				} else {
+#endif
 					copyName(ref, _functions[ref->fid()]._name, funccounts.add(ref->fid()));
+#if !defined NANOJIT_64BIT
 				}
+#endif
 			} else {
                 NanoAssert(ref->opcode() < sizeof(lirNames) / sizeof(lirNames[0]));
 				copyName(ref, lirNames[ref->opcode()], lircounts.add(ref->opcode()));
@@ -1909,6 +1917,7 @@
         Entry *e;
         
         while ((e = names.removeLast()) != NULL) {
+            core->freeString(e->name);
             delete e;
         } 
     }
diff -ruN mozilla-central/js/src/nanojit/LIR.h tracemonkey/js/src/nanojit/LIR.h
--- mozilla-central/js/src/nanojit/LIR.h	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/LIR.h	2008-09-06 10:27:55.000000000 +0300
@@ -181,7 +181,11 @@
         struct sti_type
         {
 			LOpcode			code:8;
+#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+			signed int      disp:8;     // Sun Studio requires explicitly declaring signed int bit-field
+#else
 			int32_t	    	disp:8;
+#endif
 			uint32_t		oprnd_1:8;  // 256 ins window and since they only point backwards this is sufficient.
 			uint32_t		oprnd_2:8;  
         };
@@ -199,7 +203,11 @@
         struct t_type
         {
             LOpcode         code:8;
+#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+            signed int      imm24:24;
+#else
             int32_t         imm24:24;
+#endif
         };
 
 		// imm16 form
@@ -207,7 +215,11 @@
 		{
 			LOpcode			code:8;
 			uint32_t		resv:8;  // cobberred during assembly
+#if defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+			signed int		imm16:16;
+#else
 			int32_t			imm16:16;
+#endif
 		};
 
 		// overlay used during code generation ( note that last byte is reserved for allocation )
@@ -504,7 +516,7 @@
         ~LirNameMap();
 
 		void addName(LInsp i, const char *s);
-		void addName(LInsp i, avmplus::String *s);
+		bool addName(LInsp i, avmplus::String *s);
 		void copyName(LInsp i, const char *s, int suffix);
         const char *formatRef(LIns *ref);
 		const char *formatIns(LInsp i);
diff -ruN mozilla-central/js/src/nanojit/NativeAMD64.h tracemonkey/js/src/nanojit/NativeAMD64.h
--- mozilla-central/js/src/nanojit/NativeAMD64.h	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/NativeAMD64.h	2008-09-06 10:27:55.000000000 +0300
@@ -759,8 +759,7 @@
 	IMM32(i);													\
 	*(--_nIns) = AMD64_MODRM_REG(0, r);							\
 	*(--_nIns) = AMD64_MOV_RM_IMM;								\
-	if (AMD64_NEEDS_REX(r))										\
-		*(--_nIns) = AMD64_REX(0,0,r);							\
+	*(--_nIns) = AMD64_REX(1,0,r);							    \
 	asm_output2("mov %s,%d",gpn(r),i);							\
 	} while (0)
 
@@ -1024,7 +1023,7 @@
 	underrunProtect(7);											\
 	AMD64_MODRM_DISP(b,r,d);									\
 	AMD64_OP3(AMD64_MOVD_RM_REG,1,b,r);							\
-	asm_output3("movd %s,%d(%s)",gpn(b),(d),gpn(r));			\
+	asm_output3("movd %d(%s),%s",(d),gpn(r),gpn(b));			\
 	} while (0)
 
 
diff -ruN mozilla-central/js/src/nanojit/NativeARM.cpp tracemonkey/js/src/nanojit/NativeARM.cpp
--- mozilla-central/js/src/nanojit/NativeARM.cpp	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/NativeARM.cpp	2008-09-06 10:27:55.000000000 +0300
@@ -202,9 +202,8 @@
             FMDRR(rr,R0,R1);
         } else {
             NanoAssert(d);
-            //fprintf (stderr, "call ins d: %d\n", d);
-            STMIA(Scratch, 1<<R0 | 1<<R1);
-            arm_ADDi(Scratch, FP, d);
+            STR(R0, FP, d+0);
+            STR(R1, FP, d+4);
         }
     }
 #endif
@@ -449,10 +448,8 @@
 
     if (rr != UnknownReg) {
         if (!isS8(offset >> 2) || (offset&3) != 0) {
-            underrunProtect(LD32_size + 8);
             FLDD(rr,Scratch,0);
-            ADD(Scratch, rb);
-            LD32_nochk(Scratch, offset);
+            arm_ADDi(Scratch, rb, offset);
         } else {
             FLDD(rr,rb,offset);
         }
@@ -477,8 +474,19 @@
 
 #ifdef NJ_ARM_VFP
     Reservation *valResv = getresv(value);
-
     Register rb = findRegFor(base, GpRegs);
+
+    if (value->isconstq()) {
+        const int32_t* p = (const int32_t*) (value-2);
+
+        STR(Scratch, rb, dr);
+        LD32_nochk(Scratch, p[0]);
+        STR(Scratch, rb, dr+4);
+        LD32_nochk(Scratch, p[1]);
+
+        return;
+    }
+
     Register rv = findRegFor(value, FpRegs);
 
     NanoAssert(rb != UnknownReg);
@@ -495,9 +503,7 @@
     FSTD(rv, baseReg, baseOffset);
 
     if (!isS8(dr)) {
-        underrunProtect(4 + LD32_size);
-        ADD(Scratch, rb);
-        LD32_nochk(Scratch, dr);
+        arm_ADDi(Scratch, rb, dr);
     }
 
     // if it's a constant, make sure our baseReg/baseOffset location
@@ -505,7 +511,7 @@
     if (value->isconstq()) {
         const int32_t* p = (const int32_t*) (value-2);
 
-        underrunProtect(12 + LD32_size);
+        underrunProtect(12);
 
         asm_quad_nochk(rv, p);
     }
@@ -522,27 +528,23 @@
 void
 Assembler::asm_quad_nochk(Register rr, const int32_t* p)
 {
-    *(++_nSlot) = p[0];
-    *(++_nSlot) = p[1];
+    // We're not going to use a slot, because it might be too far
+    // away.  Instead, we're going to stick a branch in the stream to
+    // jump over the constants, and then load from a short PC relative
+    // offset.
+
+    // stream should look like:
+    //    branch A
+    //    p[0]
+    //    p[1]
+    // A: FLDD PC-16
 
-    intptr_t constAddr = (intptr_t) (_nSlot-1);
-    intptr_t realOffset = PC_OFFSET_FROM(constAddr, _nIns-1);
-    intptr_t offset = realOffset;
-    Register baseReg = PC;
-
-    //int32_t *q = (int32_t*) constAddr;
-    //fprintf (stderr, "asm_quad_nochk: rr = %d cAddr: 0x%x quad: %08x:%08x q: %f @0x%08x\n", rr, constAddr, p[0], p[1], *(double*)q, _nIns);
-
-    // for FLDD, we only get a left-shifted 8-bit offset
-    if (!isS8(realOffset >> 2)) {
-        offset = 0;
-        baseReg = Scratch;
-    }
+    FLDD(rr, PC, -16);
 
-    FLDD(rr, baseReg, offset);
+    *(--_nIns) = (NIns) p[1];
+    *(--_nIns) = (NIns) p[0];
 
-    if (!isS8(realOffset >> 2))
-        LD32_nochk(Scratch, constAddr);
+    JMP_nochk(_nIns+2);
 }
 
 void
@@ -561,21 +563,28 @@
 #ifdef NJ_ARM_VFP
     freeRsrcOf(ins, false);
 
-    // XXX We probably want nochk versions of FLDD/FSTD
-    underrunProtect(16 + LD32_size);
+    if (rr == UnknownReg) {
+        underrunProtect(12);
 
-    // grab a register to do the load into if we don't have one already;
-    // XXX -- maybe do a mmq in this case?  We're going to use our
-    // D7 register that's never allocated (since it's the one we use
-    // for int-to-double conversions), so we don't have to worry about
-    // spilling something in a fp reg.
-    if (rr == UnknownReg)
-        rr = D7;
+        // asm_mmq might spill a reg, so don't call it;
+        // instead do the equivalent directly.
+        //asm_mmq(FP, d, PC, -16);
 
-    if (d)
-        FSTD(rr, FP, d);
+        STR(Scratch, FP, d+4);
+        LDR(Scratch, PC, -20);
+        STR(Scratch, FP, d);
+        LDR(Scratch, PC, -16);
+
+        *(--_nIns) = (NIns) p[1];
+        *(--_nIns) = (NIns) p[0];
+        JMP_nochk(_nIns+2);
+    } else {
+        if (d)
+            FSTD(rr, FP, d);
 
-    asm_quad_nochk(rr, p);
+        underrunProtect(16);
+        asm_quad_nochk(rr, p);
+    }
 #else
     freeRsrcOf(ins, false);
     if (d) {
@@ -628,13 +637,21 @@
     // value is either a 64bit struct or maybe a float
     // that isn't live in an FPU reg.  Either way, don't
     // put it in an FPU reg just to load & store it.
-    // get a scratch reg
+
+    // Don't use this with PC-relative loads; the registerAlloc might
+    // end up spilling a reg (and this the offset could end up being
+    // bogus)!
+    NanoAssert(rs != PC);
+
+    // use both IP and a second scratch reg
     Register t = registerAlloc(GpRegs & ~(rmask(rd)|rmask(rs)));
     _allocator.addFree(t);
-    // XXX use LDM,STM
-    STR(t, rd, dd+4);
-    LDR(t, rs, ds+4);
+
+    // XXX maybe figure out if we can use LDRD/STRD -- hard to
+    // ensure right register allocation
+    STR(Scratch, rd, dd+4);
     STR(t, rd, dd);
+    LDR(Scratch, rs, ds+4);
     LDR(t, rs, ds);
 }
 
@@ -643,29 +660,27 @@
 {
     Reservation* argRes = getresv(arg);
     bool quad = arg->isQuad();
-    intptr_t stack_growth = quad ? 8 : 4;
-
-    Register ra;
 
-    if (argRes)
-        ra = argRes->reg;
-    else
-        ra = findRegFor(arg, quad ? FpRegs : GpRegs);
-
-    if (ra == UnknownReg) {
-        STR(Scratch, SP, 0);
-        LDR(Scratch, FP, disp(argRes));
+    if (argRes && argRes->reg != UnknownReg) {
+        if (!quad) {
+            STR_preindex(argRes->reg, SP, -4);
+        } else {
+            FSTD(argRes->reg, SP, 0);
+            SUBi(SP, 8);
+        }
     } else {
+        int d = findMemFor(arg);
+
         if (!quad) {
-            Register ra = findRegFor(arg, GpRegs);
-            STR(ra, SP, 0);
+            STR_preindex(Scratch, SP, -4);
+            LDR(Scratch, FP, d);
         } else {
-            Register ra = findRegFor(arg, FpRegs);
-            FSTD(ra, SP, 0);
+            STR_preindex(Scratch, SP, -4);
+            LDR(Scratch, FP, d+4);
+            STR_preindex(Scratch, SP, -4);
+            LDR(Scratch, FP, d);
         }
     }
-
-    SUBi(SP, stack_growth);
 }
 
 void
@@ -818,6 +833,11 @@
 void
 Assembler::LD32_nochk(Register r, int32_t imm)
 {
+    if (imm == 0) {
+        XOR(r, r);
+        return;
+    }
+
     // We should always reach the const pool, since it's on the same page (<4096);
     // if we can't, someone didn't underrunProtect enough.
 
@@ -880,6 +900,49 @@
     asm_output2("%s %p", _c == AL ? "jmp" : "b(cnd)", (void*)(_t));
 }
 
+void
+Assembler::asm_add_imm(Register rd, Register rn, int32_t imm)
+{
+
+    int rot = 16;
+    uint32_t immval;
+    bool pos;
+
+    if (imm >= 0) {
+        immval = (uint32_t) imm;
+        pos = true;
+    } else {
+        immval = (uint32_t) (-imm);
+        pos = false;
+    }
+
+    while (immval && ((immval & 0x3) == 0)) {
+        immval >>= 2;
+        rot--;
+    }
+
+    rot &= 0xf;
+
+    if (immval < 256) {
+        underrunProtect(4);
+        if (pos)
+            *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<23) | (rn<<16) | (rd<<12) | (rot << 8) | immval );
+        else
+            *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<22) | (rn<<16) | (rd<<12) | (rot << 8) | immval );
+        asm_output3("add %s,%s,%d",gpn(rd),gpn(rn),imm);
+    } else {
+        // add scratch to rn, after loading the value into scratch.
+
+        // make sure someone isn't trying to use Scratch as an operand
+        NanoAssert(rn != Scratch);
+
+        *(--_nIns) = (NIns)( COND_AL | OP_STAT | (1<<23) | (rn<<16) | (rd<<12) | (Scratch));
+        asm_output3("add %s,%s,%s",gpn(rd),gpn(rn),gpn(Scratch));
+
+        LD32_nochk(Scratch, imm);
+    }
+}
+
 /*
  * VFP
  */
diff -ruN mozilla-central/js/src/nanojit/NativeARM.h tracemonkey/js/src/nanojit/NativeARM.h
--- mozilla-central/js/src/nanojit/NativeARM.h	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/NativeARM.h	2008-09-06 10:27:55.000000000 +0300
@@ -200,6 +200,7 @@
     void nativePageReset();                                             \
     void nativePageSetup();                                             \
     void asm_quad_nochk(Register, const int32_t*);                      \
+    void asm_add_imm(Register, Register, int32_t);                      \
     int* _nSlot;                                                        \
     int* _nExitSlot;
 
@@ -308,48 +309,9 @@
 // _l = _l + _r
 #define ADD(_l,_r)   arm_ADD(_l,_l,_r)
 
-// TODO: we can do better here, since we can rotate the 8-bit immediate left by
-// an even number of bits; should count zeros at the end.
-
 // Note that this sometimes converts negative immediate values to a to a sub.
 // _d = _r + _imm
-#define arm_ADDi(_d,_n,_imm)   do {                                     \
-        if ((_imm) > -256 && (_imm) < 256) {                            \
-            underrunProtect(4);                                         \
-            if ((_imm)>=0)                                              \
-                *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<23) | ((_n)<<16) | ((_d)<<12) | ((_imm)&0xFF) ); \
-            else                                                        \
-                *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<22) | ((_n)<<16) | ((_d)<<12) | ((-(_imm))&0xFF) ); \
-        } else {                                                        \
-            if ((_imm)>=0) {                                            \
-                if ((_imm)<=1020 && (((_imm)&3)==0) ) {                 \
-                    underrunProtect(4);                                 \
-                    *(--_nIns) = (NIns)( COND_AL | OP_IMM | OP_STAT | (1<<23) | ((_n)<<16) | ((_d)<<12) | (15<<8)| ((_imm)>>2) ); \
-                } else {                                                \
-                    underrunProtect(4+LD32_size);                       \
-                    *(--_nIns) = (NIns)( COND_AL | OP_STAT | (1<<23) | ((_n)<<16) | ((_d)<<12) | (Scratch)); \
-                    LD32_nochk(Scratch, _imm);                          \
-                }                                                       \
-            } else {                                                    \
-                underrunProtect(4+LD32_size);                           \
-                *(--_nIns) = (NIns)( COND_AL | OP_STAT | (1<<22) | ((_n)<<16) | ((_d)<<12) | (Scratch)); \
-                LD32_nochk(Scratch, -(_imm));                           \
-            }                                                           \
-        }                                                               \
-        asm_output3("add %s,%s,%d",gpn(_d),gpn(_n),(_imm));             \
-    } while(0)
-
-/*
- * There used to be a :
-                if ((_imm)>=-510) {                                     \
-                    underrunProtect(8);                                 \
-                    int rem = -(_imm) - 255;                            \
-                    *(--_nIns) = (NIns)( COND_AL | OP_IMM | (1<<22) | ((_n)<<16) | ((_d)<<12) | ((rem)&0xFF) ); \
-                    *(--_nIns) = (NIns)( COND_AL | OP_IMM | (1<<22) | ((_n)<<16) | ((_d)<<12) | (0xFF) ); \
-                } else {                                               
- * above, but if we do that we can't really update the status registers.  So don't do that.
- */
-
+#define arm_ADDi(_d,_n,_imm)   asm_add_imm(_d,_n,_imm)
 #define ADDi(_r,_imm)  arm_ADDi(_r,_r,_imm)
 
 // _l = _l - _r
@@ -543,7 +505,7 @@
                 LD32_nochk(Scratch, _off);                              \
             }                                                           \
         }                                                               \
-        asm_output3("ldr %s,%d(%s)",gpn((_d)),(_off),gpn((_b)));        \
+        asm_output3("ldr %s, [%s, #%d]",gpn(_d),gpn(_b),(_off));        \
     } while(0)
 
 #define LDR(_d,_b,_off)        LDR_chk(_d,_b,_off,0)
@@ -554,15 +516,18 @@
 #define ST(base,offset,reg)    STR(reg,base,offset)
 
 #define LDi(_d,_imm) do {                                               \
-        if (isS8((_imm)) || isU8((_imm))) {                             \
+        if ((_imm) == 0) {                                              \
+            XOR(_d,_d);                                                 \
+        } else if (isS8((_imm)) || isU8((_imm))) {                      \
             underrunProtect(4);                                         \
             if ((_imm)<0)   *(--_nIns) = (NIns)( COND_AL | (0x3E<<20) | ((_d)<<12) | (((_imm)^0xFFFFFFFF)&0xFF) ); \
             else            *(--_nIns) = (NIns)( COND_AL | (0x3B<<20) | ((_d)<<12) | ((_imm)&0xFF) ); \
+            asm_output2("ld  %s,0x%x",gpn((_d)),(_imm));                \
         } else {                                                        \
             underrunProtect(LD32_size);                                 \
             LD32_nochk(_d, (_imm));                                     \
+            asm_output2("ld  %s,0x%x",gpn((_d)),(_imm));                \
         }                                                               \
-        asm_output2("ld  %s,0x%x",gpn((_d)),(_imm));                      \
     } while(0)
 
 
@@ -582,7 +547,25 @@
         underrunProtect(4);                                             \
         if ((_off)<0)   *(--_nIns) = (NIns)( COND_AL | (0x50<<20) | ((_n)<<16) | ((_d)<<12) | ((-(_off))&0xFFF) ); \
         else            *(--_nIns) = (NIns)( COND_AL | (0x58<<20) | ((_n)<<16) | ((_d)<<12) | ((_off)&0xFFF) ); \
-        asm_output3("str %s, %d(%s)",gpn(_d), (_off), gpn(_n));         \
+        asm_output3("str %s, [%s, #%d]", gpn(_d), gpn(_n), (_off)); \
+    } while(0)
+
+// Rd += _off; [Rd] = Rn
+#define STR_preindex(_d,_n,_off) do {                                   \
+        NanoAssert(!IsFpReg(_d) && isS12(_off));                        \
+        underrunProtect(4);                                             \
+        if ((_off)<0)   *(--_nIns) = (NIns)( COND_AL | (0x52<<20) | ((_n)<<16) | ((_d)<<12) | ((-(_off))&0xFFF) ); \
+        else            *(--_nIns) = (NIns)( COND_AL | (0x5A<<20) | ((_n)<<16) | ((_d)<<12) | ((_off)&0xFFF) ); \
+        asm_output3("str %s, [%s, #%d]", gpn(_d), gpn(_n), (_off));      \
+    } while(0)
+
+// [Rd] = Rn ; Rd += _off
+#define STR_postindex(_d,_n,_off) do {                                  \
+        NanoAssert(!IsFpReg(_d) && isS12(_off));                        \
+        underrunProtect(4);                                             \
+        if ((_off)<0)   *(--_nIns) = (NIns)( COND_AL | (0x40<<20) | ((_n)<<16) | ((_d)<<12) | ((-(_off))&0xFFF) ); \
+        else            *(--_nIns) = (NIns)( COND_AL | (0x48<<20) | ((_n)<<16) | ((_d)<<12) | ((_off)&0xFFF) ); \
+        asm_output3("str %s, [%s], %d", gpn(_d), gpn(_n), (_off));      \
     } while(0)
 
 
diff -ruN mozilla-central/js/src/nanojit/Nativei386.cpp tracemonkey/js/src/nanojit/Nativei386.cpp
--- mozilla-central/js/src/nanojit/Nativei386.cpp	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/Nativei386.cpp	2008-09-06 10:27:55.000000000 +0300
@@ -43,7 +43,7 @@
 #include <CoreServices/CoreServices.h>
 #endif
 
-#if defined DARWIN || defined LINUX
+#if defined AVMPLUS_UNIX
 #include <sys/mman.h>
 #include <errno.h>
 #endif
@@ -344,10 +344,14 @@
 		#if defined WIN32 || defined WIN64
 			DWORD dwIgnore;
 			VirtualProtect(&page->code, count*NJ_PAGE_SIZE, PAGE_EXECUTE_READWRITE, &dwIgnore);
-		#elif defined DARWIN || defined AVMPLUS_LINUX
+		#elif defined AVMPLUS_UNIX
 			intptr_t addr = (intptr_t)&page->code;
 			addr &= ~((uintptr_t)NJ_PAGE_SIZE - 1);
+			#if defined SOLARIS
+			if (mprotect((char *)addr, count*NJ_PAGE_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
+			#else
 			if (mprotect((void *)addr, count*NJ_PAGE_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC) == -1) {
+			#endif
                 AvmDebugLog(("FATAL ERROR: mprotect(PROT_EXEC) failed\n"));
                 abort();
             }
@@ -708,6 +712,8 @@
              */
             if (value->isop(LIR_u2f) 
                 || value->isop(LIR_i2f)
+                || (value->opcode() >= LIR_fneg && value->opcode() <= LIR_fmul)
+                || value->opcode() == LIR_fdiv
                 || value->opcode() == LIR_fcall) {
                 rv = findRegFor(value, XmmRegs);
                 SSE_STQ(dr, rb, rv);
@@ -878,11 +884,25 @@
 			Register ra;
 
 			// if this is last use of lhs in reg, we can re-use result reg
-			if (rA == 0 || (ra = rA->reg) == UnknownReg)
+			if (rA == 0 || (ra = rA->reg) == UnknownReg) {
 				ra = findSpecificRegFor(lhs, rr);
+			} else if ((rmask(ra) & XmmRegs) == 0) {
+				/* We need this case on AMD64, because it's possible that 
+				 * an earlier instruction has done a quadword load and reserved a 
+				 * GPR.  If so, ask for a new register.
+				 */
+				ra = findRegFor(lhs, XmmRegs);
+			}
 			// else, rA already has a register assigned.
 
+#if defined __SUNPRO_CC
+			// from Sun Studio C++ Readme: #pragma align inside namespace requires mangled names
+			static uint32_t temp[] = {0, 0, 0, 0, 0, 0, 0};
+			static uint32_t *negateMask = (uint32_t *)alignUp(temp, 16);
+			negateMask[1] = 0x80000000;
+#else
 			static const AVMPLUS_ALIGN16(uint32_t) negateMask[] = {0,0x80000000,0,0};
+#endif
 			SSE_XORPD(rr, negateMask);
 
 			if (rr != ra)
@@ -975,8 +995,15 @@
 			Register ra;
 
 			// if this is last use of lhs in reg, we can re-use result reg
-			if (rA == 0 || (ra = rA->reg) == UnknownReg)
+			if (rA == 0 || (ra = rA->reg) == UnknownReg) {
 				ra = findSpecificRegFor(lhs, rr);
+			} else if ((rmask(ra) & XmmRegs) == 0) {
+				/* We need this case on AMD64, because it's possible that 
+				 * an earlier instruction has done a quadword load and reserved a 
+				 * GPR.  If so, ask for a new register.
+				 */
+				ra = findRegFor(lhs, XmmRegs);
+			}
 			// else, rA already has a register assigned.
 
 			if (lhs == rhs)
diff -ruN mozilla-central/js/src/nanojit/avmplus.h tracemonkey/js/src/nanojit/avmplus.h
--- mozilla-central/js/src/nanojit/avmplus.h	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/avmplus.h	2008-09-06 10:27:55.000000000 +0300
@@ -39,7 +39,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#if defined(AVMPLUS_LINUX) || defined(DARWIN) || defined(__FreeBSD__)
+#if defined(AVMPLUS_UNIX)
 #include <unistd.h>
 #include <sys/mman.h>
 #endif
@@ -99,7 +99,8 @@
 #include <stdint.h>
 #endif
 
-#if defined(_MSC_VER) && defined(AVMPLUS_IA32)
+#if defined(AVMPLUS_IA32)
+#if defined(_MSC_VER)
 __declspec(naked) static inline __int64 rdtsc()
 {
     __asm
@@ -108,16 +109,22 @@
         ret;
     }
 }
-#endif
-
-#if defined(__i386__)
-
+#elif defined(SOLARIS)
+static inline unsigned long long rdtsc(void)
+{
+    unsigned long long int x;
+    asm volatile (".byte 0x0f, 0x31" : "=A" (x));
+    return x;
+}
+#elif defined(__i386__)
 static __inline__ unsigned long long rdtsc(void)
 {
   unsigned long long int x;
      __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
      return x;
 }
+#endif /* compilers */
+
 #elif defined(__x86_64__)
 
 static __inline__ uint64_t rdtsc(void)
@@ -151,7 +158,7 @@
   return(result);
 }
 
-#endif
+#endif /* architecture */
 
 struct JSContext;
 
@@ -251,7 +258,7 @@
                             pages * kNativePageSize,
                             MEM_COMMIT | MEM_RESERVE, 
                             PAGE_EXECUTE_READWRITE);
-#elif defined AVMPLUS_LINUX || defined DARWIN
+#elif defined AVMPLUS_UNIX
         /**
          * Don't use normal heap with mprotect+PROT_EXEC for executable code.
          * SELinux and friends don't allow this.
@@ -272,8 +279,12 @@
     {
 #ifdef XP_WIN
         VirtualFree(p, 0, MEM_RELEASE);
-#elif defined AVMPLUS_LINUX || defined DARWIN
+#elif defined AVMPLUS_UNIX
+        #if defined SOLARIS
+        munmap((char*)p, pages * kNativePageSize); 
+        #else
         munmap(p, pages * kNativePageSize); 
+        #endif
 #else
         free(p);
 #endif
@@ -464,6 +475,10 @@
         static inline String* newString(const char* cstr) {
             return (String*)strdup(cstr);
         }
+
+        static inline void freeString(String* str) {
+            return free((char*)str);
+        }
     };
 
     class OSDep
diff -ruN mozilla-central/js/src/nanojit/nanojit.h tracemonkey/js/src/nanojit/nanojit.h
--- mozilla-central/js/src/nanojit/nanojit.h	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/nanojit/nanojit.h	2008-09-06 10:27:55.000000000 +0300
@@ -73,7 +73,11 @@
 	typedef avmplus::List<LIns*,avmplus::LIST_NonGCObjects>	InsList;
 	typedef avmplus::List<char*, avmplus::LIST_GCObjects> StringList;
 
-	#if defined(_DEBUG)
+	#if defined(_MSC_VER) && _MSC_VER < 1400
+		static void NanoAssertMsgf(bool a,const char *f,...) {}
+		static void NanoAssertMsg(bool a,const char *m) {}
+		static void NanoAssert(bool a) {}
+	#elif defined(_DEBUG)
 		
 		#define __NanoAssertMsgf(a, file_, line_, f, ...)  \
 			if (!(a)) { \
diff -ruN mozilla-central/js/src/trace-test.js tracemonkey/js/src/trace-test.js
--- mozilla-central/js/src/trace-test.js	2008-09-06 14:31:10.000000000 +0300
+++ tracemonkey/js/src/trace-test.js	2008-09-06 10:27:55.000000000 +0300
@@ -1178,13 +1178,107 @@
 testNegZero1Helper(1);
 test(testNegZero1);
 
-/* No test case, just make sure this doesn't assert. */
+// No test case, just make sure this doesn't assert. 
 function testNegZero2() {
     var z = 0;
     for (let j = 0; j < 5; ++j) { ({p: (-z)}); }
 }
 testNegZero2();
 
+function testConstSwitch() {
+    var x;
+    for (var j=0;j<5;++j) { switch(1.1) { case NaN: case 2: } x = 2; }
+    return x;
+}
+testConstSwitch.expected = 2;
+test(testConstSwitch);
+
+function testConstIf() {
+    var x;
+    for (var j=0;j<5;++j) { if (1.1 || 5) { } x = 2;}
+    return x;
+}
+testConstIf.expected = 2;
+test(testConstIf);
+
+function testTypeofHole() {
+  var a = new Array(6);
+  a[5] = 3;
+  for (var i = 0; i < 6; ++i)
+    a[i] = typeof a[i];
+  return a.toString();
+}
+testTypeofHole.expected = "undefined,undefined,undefined,undefined,undefined,number"
+test(testTypeofHole);
+
+function testNativeLog() {
+  var a = new Array(5);
+  for (var i = 0; i < 5; i++) {
+    a[i] = Math.log(Math.pow(Math.E, 10));
+  }
+  return a.join(",");
+}
+testNativeLog.expected = "10,10,10,10,10";
+test(testNativeLog);
+
+function test_JSOP_ARGSUB() {
+    function f0() { return arguments[0]; }
+    function f1() { return arguments[1]; }
+    function f2() { return arguments[2]; }
+    function f3() { return arguments[3]; }
+    function f4() { return arguments[4]; }
+    function f5() { return arguments[5]; }
+    function f6() { return arguments[6]; }
+    function f7() { return arguments[7]; }
+    function f8() { return arguments[8]; }
+    function f9() { return arguments[9]; }
+    var a = [];
+    for (var i = 0; i < 10; i++) {
+        a[0] = f0('a');
+        a[1] = f1('a','b');
+        a[2] = f2('a','b','c');
+        a[3] = f3('a','b','c','d');
+        a[4] = f4('a','b','c','d','e');
+        a[5] = f5('a','b','c','d','e','f');
+        a[6] = f6('a','b','c','d','e','f','g');
+        a[7] = f7('a','b','c','d','e','f','g','h');
+        a[8] = f8('a','b','c','d','e','f','g','h','i');
+        a[9] = f9('a','b','c','d','e','f','g','h','i','j');
+    }
+    return a.join("");
+}
+test_JSOP_ARGSUB.expected = "abcdefghij";
+test(test_JSOP_ARGSUB);
+
+function test_JSOP_ARGCNT() {
+    function f0() { return arguments.length; }
+    function f1() { return arguments.length; }
+    function f2() { return arguments.length; }
+    function f3() { return arguments.length; }
+    function f4() { return arguments.length; }
+    function f5() { return arguments.length; }
+    function f6() { return arguments.length; }
+    function f7() { return arguments.length; }
+    function f8() { return arguments.length; }
+    function f9() { return arguments.length; }
+    var a = [];
+    for (var i = 0; i < 10; i++) {
+        a[0] = f0('a');
+        a[1] = f1('a','b');
+        a[2] = f2('a','b','c');
+        a[3] = f3('a','b','c','d');
+        a[4] = f4('a','b','c','d','e');
+        a[5] = f5('a','b','c','d','e','f');
+        a[6] = f6('a','b','c','d','e','f','g');
+        a[7] = f7('a','b','c','d','e','f','g','h');
+        a[8] = f8('a','b','c','d','e','f','g','h','i');
+        a[9] = f9('a','b','c','d','e','f','g','h','i','j');
+    }
+    return a.join(",");
+}
+test_JSOP_ARGCNT.expected = "1,2,3,4,5,6,7,8,9,10";
+test(test_JSOP_ARGCNT);
+
 /* Keep these at the end so that we can see the summary after the trace-debug spew. */
 print("\npassed:", passes.length && passes.join(","));
 print("\nFAILED:", fails.length && fails.join(","));
