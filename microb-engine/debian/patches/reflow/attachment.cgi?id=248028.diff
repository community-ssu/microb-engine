#Bug 191699  Make white-space work on inlines
Index: mozilla/layout/generic/nsLineLayout.cpp
===================================================================
--- mozilla.orig/layout/generic/nsLineLayout.cpp
+++ mozilla/layout/generic/nsLineLayout.cpp
@@ -1181,20 +1181,16 @@ nsLineLayout::CanPlaceFrame(PerFrameData
     }
   }
   else {
     // Don't apply margin to empty frames.
     pfd->mMargin.left = pfd->mMargin.right = 0;
   }
 
   PerSpanData* psd = mCurrentSpan;
-  if (psd->mNoWrap) {
-    // When wrapping is off, everything fits.
-    return PR_TRUE;
-  }
 
   PRBool ltr = NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection;
   nscoord endMargin = ltr ? pfd->mMargin.right : pfd->mMargin.left;
 
 #ifdef NOISY_CAN_PLACE_FRAME
   if (nsnull != psd->mFrame) {
     nsFrame::ListTag(stdout, psd->mFrame->mFrame);
   }
@@ -1273,19 +1269,19 @@ nsLineLayout::CanPlaceFrame(PerFrameData
     // be added after that point, therefore we can assume that the
     // current span being placed has fit.
     //
     // So how do we get here and have a span that should already fit
     // and yet doesn't: Simple: span's that have the no-wrap attribute
     // set on them and contain a float and are placed where they
     // don't naturally fit.
     return PR_TRUE;
- }
+  }
 
-  if (aFrameCanContinueTextRun) {
+  if (aFrameCanContinueTextRun || psd->mNoWrap) {
     // Let it fit, but we reserve the right to roll back
     // to before the text run! Note that we usually won't get here because
     // a text frame will break itself to avoid exceeding the available width.
     // We'll only get here for text frames that couldn't break early enough.
 #ifdef NOISY_CAN_PLACE_FRAME
     printf("   ==> placing overflowing textrun, requesting backup\n");
 #endif
     if (!mLastOptionalBreakContent) {
@@ -1613,33 +1609,32 @@ nsLineLayout::VerticalAlignFrames(PerSpa
 
   // Get the parent frame's font for all of the frames in this span
   nsStyleContext* styleContext = spanFrame->GetStyleContext();
   nsIRenderingContext* rc = mBlockReflowState->rendContext;
   nsLayoutUtils::SetFontFromStyle(mBlockReflowState->rendContext, styleContext);
   nsCOMPtr<nsIFontMetrics> fm;
   rc->GetFontMetrics(*getter_AddRefs(fm));
 
-  PRBool preMode = (mStyleText->mWhiteSpace == NS_STYLE_WHITESPACE_PRE) ||
-    (mStyleText->mWhiteSpace == NS_STYLE_WHITESPACE_MOZ_PRE_WRAP);
+  //PRBool preMode = (mStyleText->mWhiteSpace == NS_STYLE_WHITESPACE_PRE) ||
+  //  (mStyleText->mWhiteSpace == NS_STYLE_WHITESPACE_MOZ_PRE_WRAP);
 
   // See if the span is an empty continuation. It's an empty continuation iff:
   // - it has a prev-in-flow
   // - it has no next in flow
   // - it's zero sized
   nsIFrame* spanNextInFlow = spanFrame->GetNextInFlow();
   nsIFrame* spanPrevInFlow = spanFrame->GetPrevInFlow();
   PRBool emptyContinuation = spanPrevInFlow && !spanNextInFlow &&
     (0 == spanFramePFD->mBounds.width) && (0 == spanFramePFD->mBounds.height);
 
 #ifdef NOISY_VERTICAL_ALIGN
   printf("[%sSpan]", (psd == mRootSpan)?"Root":"");
   nsFrame::ListTag(stdout, spanFrame);
-  printf(": preMode=%s strictMode=%s w/h=%d,%d emptyContinuation=%s",
-         preMode ? "yes" : "no",
+  printf(": strictMode=%s w/h=%d,%d emptyContinuation=%s",
          InStrictMode() ? "yes" : "no",
          spanFramePFD->mBounds.width, spanFramePFD->mBounds.height,
          emptyContinuation ? "yes" : "no");
   if (psd != mRootSpan) {
     printf(" bp=%d,%d,%d,%d margin=%d,%d,%d,%d",
            spanFramePFD->mBorderPadding.top,
            spanFramePFD->mBorderPadding.right,
            spanFramePFD->mBorderPadding.bottom,
@@ -1667,19 +1662,20 @@ nsLineLayout::VerticalAlignFrames(PerSpa
   // In almost standards mode or quirks mode, we should sometimes make
   // it disappear. The cases that matter are those where the span
   // contains no real text elements that would provide an ascent and
   // descent and height. However, if css style elements have been
   // applied to the span (border/padding/margin) so that it's clear the
   // document author is intending css2 behavior then we act as if strict
   // mode is set.
   //
-  // This code works correctly for preMode, because a blank line
-  // in PRE mode is encoded as a text node with a LF in it, since
-  // text nodes with only whitespace are considered in preMode.
+  // This code works correctly when preserving whitespace, because a
+  // blank line in PRE mode is encoded as a text node with a LF in it,
+  // since text nodes with only whitespace are considered for those
+  // values of 'white-space'.
   //
   // Much of this logic is shared with the various implementations of
   // nsIFrame::IsEmpty since they need to duplicate the way it makes
   // some lines empty.  However, nsIFrame::IsEmpty can't be reused here
   // since this code sets zeroEffectiveSpanBox even when there are
   // non-empty children.
   PRBool zeroEffectiveSpanBox = PR_FALSE;
   // XXXldb If we really have empty continuations, then all these other
@@ -1709,17 +1705,18 @@ nsLineLayout::VerticalAlignFrames(PerSpa
     // We shouldn't include any whitespace that collapses, unless we're
     // preformatted (in which case it shouldn't, but the width=0 test is
     // perhaps incorrect).  This includes whitespace at the beginning of
     // a line and whitespace preceded (?) by other whitespace.
     // See bug 134580 and bug 155333.
     zeroEffectiveSpanBox = PR_TRUE;
     for (PerFrameData* pfd = psd->mFirstFrame; pfd; pfd = pfd->mNext) {
       if (pfd->GetFlag(PFD_ISTEXTFRAME) &&
-          (pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME) || preMode ||
+          (pfd->GetFlag(PFD_ISNONWHITESPACETEXTFRAME) ||
+           pfd->mFrame->GetStyleText()->WhiteSpaceIsSignificant() ||
            pfd->mBounds.width != 0)) {
         zeroEffectiveSpanBox = PR_FALSE;
         break;
       }
     }
   }
   psd->mZeroEffectiveSpanBox = zeroEffectiveSpanBox;
 
@@ -2020,17 +2017,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
           // computing yTop and yBottom.
           yTop = pfd->mBounds.y + frameSpan->mMinY;
           yBottom = pfd->mBounds.y + frameSpan->mMaxY;
         }
         else {
           yTop = pfd->mBounds.y - pfd->mMargin.top;
           yBottom = yTop + logicalHeight;
         }
-        if (!preMode &&
+        if (!frame->GetStyleText()->WhiteSpaceIsSignificant() &&
             GetCompatMode() != eCompatibility_FullStandards &&
             !logicalHeight) {
           // Check if it's a BR frame that is not alone on its line (it
           // is given a height of zero to indicate this), and if so reset
           // yTop and yBottom so that BR frames don't influence the line.
           if (nsGkAtoms::brFrame == frame->GetType()) {
             yTop = VERTICAL_ALIGN_FRAMES_NO_MINIMUM;
             yBottom = VERTICAL_ALIGN_FRAMES_NO_MAXIMUM;
@@ -2094,16 +2091,18 @@ nsLineLayout::VerticalAlignFrames(PerSpa
                  ((blockTagAtom == nsGkAtoms::li) ||
                   (blockTagAtom == nsGkAtoms::dt) ||
                   (blockTagAtom == nsGkAtoms::dd))) {
           applyMinLH = PR_TRUE;
         }
       }
     }
     if (applyMinLH) {
+      PRBool preMode = mStyleText->WhiteSpaceIsSignificant();
+      // XXXldb Why do we need this test?
       if ((psd->mX != psd->mLeftEdge) || preMode || foundLI) {
 #ifdef NOISY_VERTICAL_ALIGN
         printf("  [span]==> adjusting min/maxY: currentValues: %d,%d", minY, maxY);
 #endif
         nscoord minimumLineHeight = mMinLineHeight;
         nscoord fontAscent, fontHeight;
         fm->GetMaxAscent(fontAscent);
         fm->GetHeight(fontHeight);
@@ -2117,17 +2116,17 @@ nsLineLayout::VerticalAlignFrames(PerSpa
 #ifdef NOISY_VERTICAL_ALIGN
         printf(" new values: %d,%d\n", minY, maxY);
 #endif
       }
       else {
         // XXX issues:
         // [1] BR's on empty lines stop working
         // [2] May not honor css2's notion of handling empty elements
-        // [3] blank lines in a pre-section ("\n") (handled with preMode)
+        // [3] blank lines in a pre-section ("\n")
 
         // XXX Are there other problems with this?
 #ifdef NOISY_VERTICAL_ALIGN
         printf("  [span]==> zapping min/maxY: currentValues: %d,%d newValues: 0,0\n",
                minY, maxY);
 #endif
         minY = maxY = 0;
       }
