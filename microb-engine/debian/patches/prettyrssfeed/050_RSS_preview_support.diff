Index: mozilla/toolkit/locales/jar.mn
===================================================================
--- mozilla.orig/toolkit/locales/jar.mn
+++ mozilla/toolkit/locales/jar.mn
@@ -115,8 +115,11 @@
   locale/@AB_CD@/help/help.properties                     (%chrome/mozapps/help/help.properties)
   locale/@AB_CD@/help/help.dtd                            (%chrome/mozapps/help/help.dtd)
   locale/@AB_CD@/help/help-toc.rdf                        (%chrome/mozapps/help/help-toc.rdf)
   locale/@AB_CD@/help/welcome.xhtml                       (%chrome/mozapps/help/welcome.xhtml)
 #endif
 % locale places @AB_CD@ %locale/@AB_CD@/places/
   locale/@AB_CD@/places/places.properties                 (%chrome/places/places.properties)
   locale/@AB_CD@/global/search/search.properties          (%chrome/search/search.properties)
+% locale feeds @AB_CD@ %locale/@AB_CD@/feeds/
+  locale/@AB_CD@/feeds/subscribe.properties               (%chrome/feeds/subscribe.properties)
+  locale/@AB_CD@/feeds/subscribe.dtd                      (%chrome/feeds/subscribe.dtd)
Index: mozilla/toolkit/locales/en-US/chrome/feeds/subscribe.dtd
===================================================================
--- /dev/null
+++ mozilla/toolkit/locales/en-US/chrome/feeds/subscribe.dtd
@@ -0,0 +1,6 @@
+<!ENTITY feedPage.title
+  "Viewing Feed">
+<!ENTITY feedSubscribeNow
+  "Subscribe Now">
+<!ENTITY feedLiveBookmarks
+  "Live Bookmarks">
Index: mozilla/toolkit/locales/en-US/chrome/feeds/subscribe.properties
===================================================================
--- /dev/null
+++ mozilla/toolkit/locales/en-US/chrome/feeds/subscribe.properties
@@ -0,0 +1,49 @@
+linkTitleTextFormat=Go to %S
+addHandler=Add "%S" (%S) as a Feed Reader?
+addHandlerAddButton=Add Feed Reader
+addHandlerAddButtonAccesskey=A
+handlerRegistered="%S" is already registered as a Feed Reader
+liveBookmarks=Live Bookmarks
+subscribeNow=Subscribe Now
+chooseApplicationMenuItem=Choose Applicationâ€¦
+chooseApplicationDialogTitle=Choose Application
+alwaysUse=Always use %S to subscribe to feeds
+mediaLabel=Media files
+
+# LOCALIZATION NOTE: The next string is for the size of the enclosed media.
+#   e.g. enclosureSizeText : "50.23 MB"
+#   %1$S = size (in bytes or megabytes, ...)
+#   %2$S = unit of measure (bytes, KB, MB, ...)
+enclosureSizeText=%1$S %2$S
+
+bytes=bytes
+kilobyte=KB
+megabyte=MB
+gigabyte=GB
+
+# LOCALIZATION NOTE: The next three strings explains to the user what they're
+# doing.
+#   e.g. alwaysUseForVideoPodcasts : "Always use Miro to subscribe to video podcasts."
+#   %S = application to use (Miro, iTunes, ...)
+alwaysUseForFeeds=Always use %S to subscribe to feeds.
+alwaysUseForAudioPodcasts=Always use %S to subscribe to podcasts.
+alwaysUseForVideoPodcasts=Always use %S to subscribe to video podcasts.
+
+subscribeFeedUsing=Subscribe to this feed using
+subscribeAudioPodcastUsing=Subscribe to this podcast using
+subscribeVideoPodcastUsing=Subscribe to this video podcast using
+
+feedSubscriptionFeed1=This is a "feed" of frequently changing content on this site.
+feedSubscriptionAudioPodcast1=This is a "podcast" of frequently changing content on this site.
+feedSubscriptionVideoPodcast1=This is a "video podcast" of frequently changing content on this site.
+
+feedSubscriptionFeed2=You can subscribe to this feed to receive updates when this content changes.
+feedSubscriptionAudioPodcast2=You can subscribe to this podcast to receive updates when this content changes.
+feedSubscriptionVideoPodcast2=You can subscribe to this video podcast to receive updates when this content changes.
+
+# Protocol Handling
+# "Add %appName (%appDomain) as an application for %protocolType links?"
+addProtocolHandler=Add %S (%S) as an application for %S links?
+addProtocolHandlerAddButton=Add Application
+# "%appName has already been added as an application for %protocolType links."
+protocolHandlerRegistered=%S has already been added as an application for %S links.
Index: mozilla/toolkit/components/build/nsToolkitCompsModule.cpp
===================================================================
--- mozilla.orig/toolkit/components/build/nsToolkitCompsModule.cpp
+++ mozilla/toolkit/components/build/nsToolkitCompsModule.cpp
@@ -67,16 +67,18 @@
 #include "nsUrlClassifierStreamUpdater.h"
 #include "nsUrlClassifierUtils.h"
 #include "nsUrlClassifierHashCompleter.h"
 #include "nsDocShellCID.h"
 #endif
 
 #ifdef MOZ_FEEDS
 #include "nsScriptableUnescapeHTML.h"
+#include "nsFeedSniffer.h"
+#include "nsAboutFeeds.h"
 #endif
 
 /////////////////////////////////////////////////////////////////////////////
 
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsAppStartup, Init)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsUserInfo)
 
 #if defined(XP_WIN) && !defined(MOZ_DISABLE_PARENTAL_CONTROLS)
@@ -123,16 +125,17 @@ nsUrlClassifierDBServiceConstructor(nsIS
     NS_RELEASE(inst);
 
     return rv;
 }
 #endif
 
 #ifdef MOZ_FEEDS
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsScriptableUnescapeHTML)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsFeedSniffer)
 #endif
 
 /////////////////////////////////////////////////////////////////////////////
 
 static const nsModuleComponentInfo components[] =
 {
   { "App Startup Service",
     NS_TOOLKIT_APPSTARTUP_CID,
@@ -198,12 +201,22 @@ static const nsModuleComponentInfo compo
     NS_URLCLASSIFIERHASHCOMPLETER_CONTRACTID,
     nsUrlClassifierHashCompleterConstructor },
 #endif
 #ifdef MOZ_FEEDS
   { "Unescape HTML",
     NS_SCRIPTABLEUNESCAPEHTML_CID,
     NS_SCRIPTABLEUNESCAPEHTML_CONTRACTID,
     nsScriptableUnescapeHTMLConstructor },
+  { "Feed Sniffer",
+    NS_FEEDSNIFFER_CID,
+    NS_FEEDSNIFFER_CONTRACTID,
+    nsFeedSnifferConstructor,
+    nsFeedSniffer::Register },
+  { "about:feeds Page",
+    NS_ABOUTFEEDS_CID,
+    NS_ABOUT_MODULE_CONTRACTID_PREFIX "feeds",
+    nsAboutFeeds::Create
+  },
 #endif
 };
 
 NS_IMPL_NSGETMODULE(nsToolkitCompsModule, components)
Index: mozilla/toolkit/components/build/nsToolkitCompsCID.h
===================================================================
--- mozilla.orig/toolkit/components/build/nsToolkitCompsCID.h
+++ mozilla/toolkit/components/build/nsToolkitCompsCID.h
@@ -111,16 +111,25 @@
   "@mozilla.org/browser/livemark-service;2"
 
 #define NS_MORKHISTORYIMPORTER_CONTRACTID \
   "@mozilla.org/browser/history-importer;1"
 
 #define NS_FAVICONSERVICE_CONTRACTID \
   "@mozilla.org/browser/favicon-service;1"
 
+#define NS_FEEDSNIFFER_CID \
+{ 0x6893e69, 0x71d8, 0x4b23, { 0x81, 0xeb, 0x80, 0x31, 0x4d, 0xaf, 0x3e, 0x66 } }
+
+#define NS_FEEDSNIFFER_CONTRACTID \
+"@mozilla.org/browser/feeds/sniffer;1"
+
+#define NS_ABOUTFEEDS_CID \
+{ 0x12ff56ec, 0x58be, 0x402c, { 0xb0, 0x57, 0x1, 0xf9, 0x61, 0xde, 0x96, 0x9b } }
+
 /////////////////////////////////////////////////////////////////////////////
 
 // {A0CCAAF8-09DA-44D8-B250-9AC3E93C8117}
 #define NS_ALERTSSERVICE_CID \
 { 0xa0ccaaf8, 0x9da, 0x44d8, { 0xb2, 0x50, 0x9a, 0xc3, 0xe9, 0x3c, 0x81, 0x17 } }
 
 // {84E11F80-CA55-11DD-AD8B-0800200C9A66}
 #define NS_SYSTEMALERTSSERVICE_CID \
Index: mozilla/toolkit/components/feeds/src/nsAboutFeeds.h
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/nsAboutFeeds.h
@@ -0,0 +1,60 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:set ts=4 sw=4 sts=4 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is The about:feeds Page.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#ifndef nsAboutFeeds_h__
+#define nsAboutFeeds_h__
+
+#include "nsIAboutModule.h"
+
+class nsAboutFeeds : public nsIAboutModule
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  NS_DECL_NSIABOUTMODULE
+
+  nsAboutFeeds() { }
+  virtual ~nsAboutFeeds() { }
+
+  static NS_METHOD
+    Create(nsISupports* outer, REFNSIID iid, void** result);
+protected:
+};
+
+#endif // nsAboutFeeds_h__
Index: mozilla/toolkit/components/feeds/src/WebContentConverter.js
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/WebContentConverter.js
@@ -0,0 +1,949 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Web Content Converter System.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#   Asaf Romano <mano@mozilla.com>
+#   Dan Mosedale <dmose@mozilla.org>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+function LOG(str) {
+  dump("*** " + str + "\n");
+}
+
+const WCCR_CONTRACTID = "@mozilla.org/embeddor.implemented/web-content-handler-registrar;1";
+const WCCR_CLASSID = Components.ID("{792a7e82-06a0-437c-af63-b2d12e808acc}");
+const WCCR_CLASSNAME = "Web Content Handler Registrar";
+
+const WCC_CLASSID = Components.ID("{db7ebf28-cc40-415f-8a51-1b111851df1e}");
+const WCC_CLASSNAME = "Web Service Handler";
+
+const TYPE_MAYBE_FEED = "application/vnd.mozilla.maybe.feed";
+const TYPE_ANY = "*/*";
+
+const PREF_CONTENTHANDLERS_AUTO = "browser.contentHandlers.auto.";
+const PREF_CONTENTHANDLERS_BRANCH = "browser.contentHandlers.types.";
+const PREF_SELECTED_WEB = "browser.feeds.handlers.webservice";
+const PREF_SELECTED_ACTION = "browser.feeds.handler";
+const PREF_SELECTED_READER = "browser.feeds.handler.default";
+const PREF_HANDLER_EXTERNAL_PREFIX = "network.protocol-handler.external";
+const PREF_ALLOW_DIFFERENT_HOST = "gecko.handlerService.allowRegisterFromDifferentHost";
+
+const STRING_BUNDLE_URI = "chrome://browser/locale/feeds/subscribe.properties";
+
+const NS_ERROR_MODULE_DOM = 2152923136;
+const NS_ERROR_DOM_SYNTAX_ERR = NS_ERROR_MODULE_DOM + 12;
+
+function WebContentConverter() {
+}
+WebContentConverter.prototype = {
+  convert: function WCC_convert() { },
+  asyncConvertData: function WCC_asyncConvertData() { },
+  onDataAvailable: function WCC_onDataAvailable() { },
+  onStopRequest: function WCC_onStopRequest() { },
+
+  onStartRequest: function WCC_onStartRequest(request, context) {
+    var wccr =
+        Cc[WCCR_CONTRACTID].
+        getService(Ci.nsIWebContentConverterService);
+    wccr.loadPreferredHandler(request);
+  },
+
+  QueryInterface: function WCC_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIStreamConverter) ||
+        iid.equals(Ci.nsIStreamListener) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+var WebContentConverterFactory = {
+  createInstance: function WCCF_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return new WebContentConverter().QueryInterface(iid);
+  },
+
+  QueryInterface: function WCC_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+function ServiceInfo(contentType, uri, name) {
+  this._contentType = contentType;
+  this._uri = uri;
+  this._name = name;
+}
+ServiceInfo.prototype = {
+  /**
+   * See nsIHandlerApp
+   */
+  get name() {
+    return this._name;
+  },
+
+  /**
+   * See nsIHandlerApp
+   */
+  equals: function SI_equals(aHandlerApp) {
+    if (!aHandlerApp)
+      throw Cr.NS_ERROR_NULL_POINTER;
+
+    if (aHandlerApp instanceof Ci.nsIWebContentHandlerInfo &&
+        aHandlerApp.contentType == this.contentType &&
+        aHandlerApp.uri == this.uri)
+      return true;
+
+    return false;
+  },
+
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  get contentType() {
+    return this._contentType;
+  },
+
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  get uri() {
+    return this._uri;
+  },
+
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  getHandlerURI: function SI_getHandlerURI(uri) {
+    return this._uri.replace(/%s/gi, encodeURIComponent(uri));
+  },
+
+  QueryInterface: function SI_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIWebContentHandlerInfo) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+function WebContentConverterRegistrar() {}
+
+WebContentConverterRegistrar.prototype = {
+  get stringBundle() {
+    var sb = Cc["@mozilla.org/intl/stringbundle;1"].
+              getService(Ci.nsIStringBundleService).
+              createBundle(STRING_BUNDLE_URI);
+    delete WebContentConverterRegistrar.prototype.stringBundle;
+    return WebContentConverterRegistrar.prototype.stringBundle = sb;
+  },
+
+  _getFormattedString: function WCCR__getFormattedString(key, params) {
+    return this.stringBundle.formatStringFromName(key, params, params.length);
+  },
+
+  _getString: function WCCR_getString(key) {
+    return this.stringBundle.GetStringFromName(key);
+  },
+
+  _contentTypes: { },
+
+  /**
+   * Track auto handlers for various content types using a content-type to
+   * handler map.
+   */
+  _autoHandleContentTypes: { },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  getAutoHandler:
+  function WCCR_getAutoHandler(contentType) {
+    contentType = this._resolveContentType(contentType);
+    if (contentType in this._autoHandleContentTypes)
+      return this._autoHandleContentTypes[contentType];
+    return null;
+  },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  setAutoHandler:
+  function WCCR_setAutoHandler(contentType, handler) {
+    if (handler && !this._typeIsRegistered(contentType, handler.uri))
+      throw Cr.NS_ERROR_NOT_AVAILABLE;
+
+    contentType = this._resolveContentType(contentType);
+    this._setAutoHandler(contentType, handler);
+
+    var ps =
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefService);
+    var autoBranch = ps.getBranch(PREF_CONTENTHANDLERS_AUTO);
+    if (handler)
+      autoBranch.setCharPref(contentType, handler.uri);
+    else if (autoBranch.prefHasUserValue(contentType))
+      autoBranch.clearUserPref(contentType);
+
+    ps.savePrefFile(null);
+  },
+
+  /**
+   * Update the internal data structure (not persistent)
+   */
+  _setAutoHandler:
+  function WCCR__setAutoHandler(contentType, handler) {
+    if (handler)
+      this._autoHandleContentTypes[contentType] = handler;
+    else if (contentType in this._autoHandleContentTypes)
+      delete this._autoHandleContentTypes[contentType];
+  },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  getWebContentHandlerByURI:
+  function WCCR_getWebContentHandlerByURI(contentType, uri) {
+    var handlers = this.getContentHandlers(contentType, { });
+    for (var i = 0; i < handlers.length; ++i) {
+      if (handlers[i].uri == uri)
+        return handlers[i];
+    }
+    return null;
+  },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  loadPreferredHandler:
+  function WCCR_loadPreferredHandler(request) {
+    var channel = request.QueryInterface(Ci.nsIChannel);
+    var contentType = this._resolveContentType(channel.contentType);
+    var handler = this.getAutoHandler(contentType);
+    if (handler) {
+      request.cancel(Cr.NS_ERROR_FAILURE);
+
+      var webNavigation =
+          channel.notificationCallbacks.getInterface(Ci.nsIWebNavigation);
+      webNavigation.loadURI(handler.getHandlerURI(channel.URI.spec),
+                            Ci.nsIWebNavigation.LOAD_FLAGS_NONE,
+                            null, null, null);
+    }
+  },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  removeProtocolHandler:
+  function WCCR_removeProtocolHandler(aProtocol, aURITemplate) {
+    var eps = Cc["@mozilla.org/uriloader/external-protocol-service;1"].
+              getService(Ci.nsIExternalProtocolService);
+    var handlerInfo = eps.getProtocolHandlerInfo(aProtocol);
+    var handlers =  handlerInfo.possibleApplicationHandlers;
+    for (let i = 0; i < handlers.length; i++) {
+      try { // We only want to test web handlers
+        let handler = handlers.queryElementAt(i, Ci.nsIWebHandlerApp);
+        if (handler.uriTemplate == aURITemplate) {
+          handlers.removeElementAt(i);
+          var hs = Cc["@mozilla.org/uriloader/handler-service;1"].
+                   getService(Ci.nsIHandlerService);
+          hs.store(handlerInfo);
+          return;
+        }
+      } catch (e) { /* it wasn't a web handler */ }
+    }
+  },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  removeContentHandler:
+  function WCCR_removeContentHandler(contentType, uri) {
+    function notURI(serviceInfo) {
+      return serviceInfo.uri != uri;
+    }
+
+    if (contentType in this._contentTypes) {
+      this._contentTypes[contentType] =
+        this._contentTypes[contentType].filter(notURI);
+    }
+  },
+
+  /**
+   *
+   */
+  _mappings: {
+    "application/rss+xml": TYPE_MAYBE_FEED,
+    "application/atom+xml": TYPE_MAYBE_FEED,
+  },
+
+  /**
+   * These are types for which there is a separate content converter aside
+   * from our built in generic one. We should not automatically register
+   * a factory for creating a converter for these types.
+   */
+  _blockedTypes: {
+    "application/vnd.mozilla.maybe.feed": true,
+  },
+
+  /**
+   * Determines the "internal" content type based on the _mappings.
+   * @param   contentType
+   * @returns The resolved contentType value.
+   */
+  _resolveContentType:
+  function WCCR__resolveContentType(contentType) {
+    if (contentType in this._mappings)
+      return this._mappings[contentType];
+    return contentType;
+  },
+
+  _makeURI: function(aURL, aOriginCharset, aBaseURI) {
+    var ioService = Components.classes["@mozilla.org/network/io-service;1"]
+                              .getService(Components.interfaces.nsIIOService);
+    return ioService.newURI(aURL, aOriginCharset, aBaseURI);
+  },
+
+  _checkAndGetURI:
+  function WCCR_checkAndGetURI(aURIString, aContentWindow)
+  {
+    try {
+      var uri = this._makeURI(aURIString);
+    } catch (ex) {
+      // not supposed to throw according to spec
+      return;
+    }
+
+    // For security reasons we reject non-http(s) urls (see bug 354316),
+    // we may need to revise this once we support more content types
+    // XXX this should be a "security exception" according to spec, but that
+    // isn't defined yet.
+    if (uri.scheme != "http" && uri.scheme != "https")
+      throw("Permission denied to add " + uri.spec + " as a content or protocol handler");
+
+    // We also reject handlers registered from a different host (see bug 402287)
+    // The pref allows us to test the feature
+    var pb = Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
+    if ((!pb.prefHasUserValue(PREF_ALLOW_DIFFERENT_HOST) ||
+         !pb.getBoolPref(PREF_ALLOW_DIFFERENT_HOST)) &&
+        aContentWindow.location.hostname != uri.host)
+      throw("Permission denied to add " + uri.spec + " as a content or protocol handler");
+
+    // If the uri doesn't contain '%s', it won't be a good handler
+    if (uri.spec.indexOf("%s") < 0)
+      throw NS_ERROR_DOM_SYNTAX_ERR;
+
+    return uri;
+  },
+
+  /**
+   * Determines if a web handler is already registered.
+   *
+   * @param aProtocol
+   *        The scheme of the web handler we are checking for.
+   * @param aURITemplate
+   *        The URI template that the handler uses to handle the protocol.
+   * @return true if it is already registered, false otherwise.
+   */
+  _protocolHandlerRegistered:
+  function WCCR_protocolHandlerRegistered(aProtocol, aURITemplate) {
+    var eps = Cc["@mozilla.org/uriloader/external-protocol-service;1"].
+              getService(Ci.nsIExternalProtocolService);
+    var handlerInfo = eps.getProtocolHandlerInfo(aProtocol);
+    var handlers =  handlerInfo.possibleApplicationHandlers;
+    for (let i = 0; i < handlers.length; i++) {
+      try { // We only want to test web handlers
+        let handler = handlers.queryElementAt(i, Ci.nsIWebHandlerApp);
+        if (handler.uriTemplate == aURITemplate)
+          return true;
+      } catch (e) { /* it wasn't a web handler */ }
+    }
+    return false;
+  },
+
+  /**
+   * See nsIWebContentHandlerRegistrar
+   */
+  registerProtocolHandler:
+  function WCCR_registerProtocolHandler(aProtocol, aURIString, aTitle, aContentWindow) {
+    LOG("registerProtocolHandler(" + aProtocol + "," + aURIString + "," + aTitle + ")");
+
+    // First, check to make sure this isn't already handled internally (we don't
+    // want to let them take over, say "chrome").
+    var ios = Cc["@mozilla.org/network/io-service;1"].
+              getService(Ci.nsIIOService);
+    var handler = ios.getProtocolHandler(aProtocol);
+    if (!(handler instanceof Ci.nsIExternalProtocolHandler)) {
+      // This is handled internally, so we don't want them to register
+      // XXX this should be a "security exception" according to spec, but that
+      // isn't defined yet.
+      throw("Permission denied to add " + aURIString + "as a protocol handler");
+    }
+
+    // check if it is in the black list
+    var pb = Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
+    var allowed;
+    try {
+      allowed = pb.getBoolPref(PREF_HANDLER_EXTERNAL_PREFIX + "." + aProtocol);
+    }
+    catch (e) {
+      allowed = pb.getBoolPref(PREF_HANDLER_EXTERNAL_PREFIX + "-default");
+    }
+    if (!allowed) {
+      // XXX this should be a "security exception" according to spec
+      throw("Not allowed to register a protocol handler for " + aProtocol);
+    }
+
+    var uri = this._checkAndGetURI(aURIString, aContentWindow);
+
+    var buttons, message;
+    if (this._protocolHandlerRegistered(aProtocol, uri.spec))
+      message = this._getFormattedString("protocolHandlerRegistered",
+                                         [aTitle, aProtocol]);
+    else {
+      // Now Ask the user and provide the proper callback
+      message = this._getFormattedString("addProtocolHandler",
+                                         [aTitle, uri.host, aProtocol]);
+      var fis = Cc["@mozilla.org/browser/favicon-service;1"].
+                getService(Ci.nsIFaviconService);
+      var notificationIcon = fis.getFaviconLinkForIcon(uri);
+      var notificationValue = "Protocol Registration: " + aProtocol;
+      var addButton = {
+        label: this._getString("addProtocolHandlerAddButton"),
+        accessKey: this._getString("addHandlerAddButtonAccesskey"),
+        protocolInfo: { protocol: aProtocol, uri: uri.spec, name: aTitle },
+
+        callback:
+        function WCCR_addProtocolHandlerButtonCallback(aNotification, aButtonInfo) {
+          var protocol = aButtonInfo.protocolInfo.protocol;
+          var uri      = aButtonInfo.protocolInfo.uri;
+          var name     = aButtonInfo.protocolInfo.name;
+
+          var handler = Cc["@mozilla.org/uriloader/web-handler-app;1"].
+                        createInstance(Ci.nsIWebHandlerApp);
+          handler.name = name;
+          handler.uriTemplate = uri;
+
+          var eps = Cc["@mozilla.org/uriloader/external-protocol-service;1"].
+                    getService(Ci.nsIExternalProtocolService);
+          var handlerInfo = eps.getProtocolHandlerInfo(protocol);
+          handlerInfo.possibleApplicationHandlers.appendElement(handler, false);
+
+          // Since the user has agreed to add a new handler, chances are good
+          // that the next time they see a handler of this type, they're going
+          // to want to use it.  Reset the handlerInfo to ask before the next
+          // use.
+          handlerInfo.alwaysAskBeforeHandling = true;
+
+          var hs = Cc["@mozilla.org/uriloader/handler-service;1"].
+                   getService(Ci.nsIHandlerService);
+          hs.store(handlerInfo);
+        }
+      };
+      buttons = [addButton];
+    }
+
+    var browserWindow = this._getBrowserWindowForContentWindow(aContentWindow);
+    var browserElement = this._getBrowserForContentWindow(browserWindow, aContentWindow);
+    var notificationBox = browserWindow.getBrowser().getNotificationBox(browserElement);
+    notificationBox.appendNotification(message,
+                                       notificationValue,
+                                       notificationIcon,
+                                       notificationBox.PRIORITY_INFO_LOW,
+                                       buttons);
+  },
+
+  /**
+   * See nsIWebContentHandlerRegistrar
+   * If a DOM window is provided, then the request came from content, so we
+   * prompt the user to confirm the registration.
+   */
+  registerContentHandler:
+  function WCCR_registerContentHandler(aContentType, aURIString, aTitle, aContentWindow) {
+    LOG("registerContentHandler(" + aContentType + "," + aURIString + "," + aTitle + ")");
+
+    // We only support feed types at present.
+    // XXX this should be a "security exception" according to spec, but that
+    // isn't defined yet.
+    var contentType = this._resolveContentType(aContentType);
+    if (contentType != TYPE_MAYBE_FEED)
+      return;
+
+    if (aContentWindow) {
+      var uri = this._checkAndGetURI(aURIString, aContentWindow);
+
+      var browserWindow = this._getBrowserWindowForContentWindow(aContentWindow);
+      var browserElement = this._getBrowserForContentWindow(browserWindow, aContentWindow);
+      var notificationBox = browserWindow.getBrowser().getNotificationBox(browserElement);
+      this._appendFeedReaderNotification(uri, aTitle, notificationBox);
+    }
+    else
+      this._registerContentHandler(contentType, aURIString, aTitle);
+  },
+
+  /**
+   * Returns the browser chrome window in which the content window is in
+   */
+  _getBrowserWindowForContentWindow:
+  function WCCR__getBrowserWindowForContentWindow(aContentWindow) {
+    return aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                         .getInterface(Ci.nsIWebNavigation)
+                         .QueryInterface(Ci.nsIDocShellTreeItem)
+                         .rootTreeItem
+                         .QueryInterface(Ci.nsIInterfaceRequestor)
+                         .getInterface(Ci.nsIDOMWindow)
+                         .wrappedJSObject;
+  },
+
+  /**
+   * Returns the <xul:browser> element associated with the given content
+   * window.
+   *
+   * @param aBrowserWindow
+   *        The browser window in which the content window is in.
+   * @param aContentWindow
+   *        The content window. It's possible to pass a child content window
+   *        (i.e. the content window of a frame/iframe).
+   */
+  _getBrowserForContentWindow:
+  function WCCR__getBrowserForContentWindow(aBrowserWindow, aContentWindow) {
+    // This depends on pseudo APIs of browser.js and tabbrowser.xml
+    aContentWindow = aContentWindow.top;
+    var browsers = aBrowserWindow.getBrowser().browsers;
+    for (var i = 0; i < browsers.length; ++i) {
+      if (browsers[i].contentWindow == aContentWindow)
+        return browsers[i];
+    }
+  },
+
+  /**
+   * Appends a notifcation for the given feed reader details.
+   *
+   * The notification could be either a pseudo-dialog which lets
+   * the user to add the feed reader:
+   * [ [icon] Add %feed-reader-name% (%feed-reader-host%) as a Feed Reader?  (Add) [x] ]
+   *
+   * or a simple message for the case where the feed reader is already registered:
+   * [ [icon] %feed-reader-name% is already registered as a Feed Reader             [x] ]
+   *
+   * A new notification isn't appended if the given notificationbox has a
+   * notification for the same feed reader.
+   *
+   * @param aURI
+   *        The url of the feed reader as a nsIURI object
+   * @param aName
+   *        The feed reader name as it was passed to registerContentHandler
+   * @param aNotificationBox
+   *        The notification box to which a notification might be appended
+   * @return true if a notification has been appended, false otherwise.
+   */
+  _appendFeedReaderNotification:
+  function WCCR__appendFeedReaderNotification(aURI, aName, aNotificationBox) {
+    var uriSpec = aURI.spec;
+    var notificationValue = "feed reader notification: " + uriSpec;
+    var notificationIcon = aURI.prePath + "/favicon.ico";
+
+    // Don't append a new notification if the notificationbox
+    // has a notification for the given feed reader already
+    if (aNotificationBox.getNotificationWithValue(notificationValue))
+      return false;
+
+    var buttons, message;
+    if (this.getWebContentHandlerByURI(TYPE_MAYBE_FEED, uriSpec))
+      message = this._getFormattedString("handlerRegistered", [aName]);
+    else {
+      message = this._getFormattedString("addHandler", [aName, aURI.host]);
+      var self = this;
+      var addButton = {
+        _outer: self,
+        label: self._getString("addHandlerAddButton"),
+        accessKey: self._getString("addHandlerAddButtonAccesskey"),
+        feedReaderInfo: { uri: uriSpec, name: aName },
+
+        /* static */
+        callback:
+        function WCCR__addFeedReaderButtonCallback(aNotification, aButtonInfo) {
+          var uri = aButtonInfo.feedReaderInfo.uri;
+          var name = aButtonInfo.feedReaderInfo.name;
+          var outer = aButtonInfo._outer;
+
+          // The reader could have been added from another window mean while
+          if (!outer.getWebContentHandlerByURI(TYPE_MAYBE_FEED, uri))
+            outer._registerContentHandler(TYPE_MAYBE_FEED, uri, name);
+
+          // avoid reference cycles
+          aButtonInfo._outer = null;
+
+          return false;
+        }
+      };
+      buttons = [addButton];
+    }
+
+    aNotificationBox.appendNotification(message,
+                                        notificationValue,
+                                        notificationIcon,
+                                        aNotificationBox.PRIORITY_INFO_LOW,
+                                        buttons);
+    return true;
+  },
+
+  /**
+   * Save Web Content Handler metadata to persistent preferences.
+   * @param   contentType
+   *          The content Type being handled
+   * @param   uri
+   *          The uri of the web service
+   * @param   title
+   *          The human readable name of the web service
+   *
+   * This data is stored under:
+   *
+   *    browser.contentHandlers.type0 = content/type
+   *    browser.contentHandlers.uri0 = http://www.foo.com/q=%s
+   *    browser.contentHandlers.title0 = Foo 2.0alphr
+   */
+  _saveContentHandlerToPrefs:
+  function WCCR__saveContentHandlerToPrefs(contentType, uri, title) {
+    var ps =
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefService);
+    var i = 0;
+    var typeBranch = null;
+    while (true) {
+      typeBranch =
+        ps.getBranch(PREF_CONTENTHANDLERS_BRANCH + i + ".");
+      try {
+        typeBranch.getCharPref("type");
+        ++i;
+      }
+      catch (e) {
+        // No more handlers
+        break;
+      }
+    }
+    if (typeBranch) {
+      typeBranch.setCharPref("type", contentType);
+      var pls =
+          Cc["@mozilla.org/pref-localizedstring;1"].
+          createInstance(Ci.nsIPrefLocalizedString);
+      pls.data = uri;
+      typeBranch.setComplexValue("uri", Ci.nsIPrefLocalizedString, pls);
+      pls.data = title;
+      typeBranch.setComplexValue("title", Ci.nsIPrefLocalizedString, pls);
+
+      ps.savePrefFile(null);
+    }
+  },
+
+  /**
+   * Determines if there is a type with a particular uri registered for the
+   * specified content type already.
+   * @param   contentType
+   *          The content type that the uri handles
+   * @param   uri
+   *          The uri of the
+   */
+  _typeIsRegistered: function WCCR__typeIsRegistered(contentType, uri) {
+    if (!(contentType in this._contentTypes))
+      return false;
+
+    var services = this._contentTypes[contentType];
+    for (var i = 0; i < services.length; ++i) {
+      // This uri has already been registered
+      if (services[i].uri == uri)
+        return true;
+    }
+    return false;
+  },
+
+  /**
+   * Gets a stream converter contract id for the specified content type.
+   * @param   contentType
+   *          The source content type for the conversion.
+   * @returns A contract id to construct a converter to convert between the
+   *          contentType and *\/*.
+   */
+  _getConverterContractID: function WCCR__getConverterContractID(contentType) {
+    const template = "@mozilla.org/streamconv;1?from=%s&to=*/*";
+    return template.replace(/%s/, contentType);
+  },
+
+  /**
+   * Register a web service handler for a content type.
+   *
+   * @param   contentType
+   *          the content type being handled
+   * @param   uri
+   *          the URI of the web service
+   * @param   title
+   *          the human readable name of the web service
+   */
+  _registerContentHandler:
+  function WCCR__registerContentHandler(contentType, uri, title) {
+    this._updateContentTypeHandlerMap(contentType, uri, title);
+    this._saveContentHandlerToPrefs(contentType, uri, title);
+
+    if (contentType == TYPE_MAYBE_FEED) {
+      // Make the new handler the last-selected reader in the preview page
+      // and make sure the preview page is shown the next time a feed is visited
+      var pb = Cc["@mozilla.org/preferences-service;1"].
+               getService(Ci.nsIPrefService).getBranch(null);
+      pb.setCharPref(PREF_SELECTED_READER, "web");
+
+      var supportsString =
+        Cc["@mozilla.org/supports-string;1"].
+        createInstance(Ci.nsISupportsString);
+        supportsString.data = uri;
+      pb.setComplexValue(PREF_SELECTED_WEB, Ci.nsISupportsString,
+                         supportsString);
+      pb.setCharPref(PREF_SELECTED_ACTION, "ask");
+      this._setAutoHandler(TYPE_MAYBE_FEED, null);
+    }
+  },
+
+  /**
+   * Update the content type -> handler map. This mapping is not persisted, use
+   * registerContentHandler or _saveContentHandlerToPrefs for that purpose.
+   * @param   contentType
+   *          The content Type being handled
+   * @param   uri
+   *          The uri of the web service
+   * @param   title
+   *          The human readable name of the web service
+   */
+  _updateContentTypeHandlerMap:
+  function WCCR__updateContentTypeHandlerMap(contentType, uri, title) {
+    if (!(contentType in this._contentTypes))
+      this._contentTypes[contentType] = [];
+
+    // Avoid adding duplicates
+    if (this._typeIsRegistered(contentType, uri))
+      return;
+
+    this._contentTypes[contentType].push(new ServiceInfo(contentType, uri, title));
+
+    if (!(contentType in this._blockedTypes)) {
+      var converterContractID = this._getConverterContractID(contentType);
+      var cr = Components.manager.QueryInterface(Ci.nsIComponentRegistrar);
+      cr.registerFactory(WCC_CLASSID, WCC_CLASSNAME, converterContractID,
+                         WebContentConverterFactory);
+    }
+  },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  getContentHandlers:
+  function WCCR_getContentHandlers(contentType, countRef) {
+    countRef.value = 0;
+    if (!(contentType in this._contentTypes))
+      return [];
+
+    var handlers = this._contentTypes[contentType];
+    countRef.value = handlers.length;
+    return handlers;
+  },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  resetHandlersForType:
+  function WCCR_resetHandlersForType(contentType) {
+    // currently unused within the tree, so only useful for extensions; previous
+    // impl. was buggy (and even infinite-looped!), so I argue that this is a
+    // definite improvement
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+
+  /**
+   * Registers a handler from the settings on a preferences branch.
+   *
+   * @param branch
+   *        an nsIPrefBranch containing "type", "uri", and "title" preferences
+   *        corresponding to the content handler to be registered
+   */
+  _registerContentHandlerWithBranch: function(branch) {
+    /**
+     * Since we support up to six predefined readers, we need to handle gaps
+     * better, since the first branch with user-added values will be .6
+     *
+     * How we deal with that is to check to see if there's no prefs in the
+     * branch and stop cycling once that's true.  This doesn't fix the case
+     * where a user manually removes a reader, but that's not supported yet!
+     */
+    var vals = branch.getChildList("", {});
+    if (vals.length == 0)
+      return;
+
+    try {
+      var type = branch.getCharPref("type");
+      var uri = branch.getComplexValue("uri", Ci.nsIPrefLocalizedString).data;
+      var title = branch.getComplexValue("title",
+                                         Ci.nsIPrefLocalizedString).data;
+      this._updateContentTypeHandlerMap(type, uri, title);
+    }
+    catch(ex) {
+      // do nothing, the next branch might have values
+    }
+  },
+
+  /**
+   * Load the auto handler, content handler and protocol tables from
+   * preferences.
+   */
+  _init: function WCCR__init() {
+    var ps =
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefService);
+
+    var kids = ps.getBranch(PREF_CONTENTHANDLERS_BRANCH)
+                 .getChildList("", {});
+
+    // first get the numbers of the providers by getting all ###.uri prefs
+    var nums = [];
+    for (var i = 0; i < kids.length; i++) {
+      var match = /^(\d+)\.uri$/.exec(kids[i]);
+      if (!match)
+        continue;
+      else
+        nums.push(match[1]);
+    }
+
+    // sort them, to get them back in order
+    nums.sort(function(a, b) {return a - b;});
+
+    // now register them
+    for (var i = 0; i < nums.length; i++) {
+      var branch = ps.getBranch(PREF_CONTENTHANDLERS_BRANCH + nums[i] + ".");
+      this._registerContentHandlerWithBranch(branch);
+    }
+
+    // We need to do this _after_ registering all of the available handlers,
+    // so that getWebContentHandlerByURI can return successfully.
+    try {
+      var autoBranch = ps.getBranch(PREF_CONTENTHANDLERS_AUTO);
+      var childPrefs = autoBranch.getChildList("", { });
+      for (var i = 0; i < childPrefs.length; ++i) {
+        var type = childPrefs[i];
+        var uri = autoBranch.getCharPref(type);
+        if (uri) {
+          var handler = this.getWebContentHandlerByURI(type, uri);
+          this._setAutoHandler(type, handler);
+        }
+      }
+    }
+    catch (e) {
+      // No auto branch yet, that's fine
+      //LOG("WCCR.init: There is no auto branch, benign");
+    }
+  },
+
+  /**
+   * See nsIObserver
+   */
+  observe: function WCCR_observe(subject, topic, data) {
+    var os =
+        Cc["@mozilla.org/observer-service;1"].
+        getService(Ci.nsIObserverService);
+    switch (topic) {
+    case "app-startup":
+      os.addObserver(this, "profile-after-change", false);
+      break;
+    case "profile-after-change":
+      os.removeObserver(this, "profile-after-change");
+      this._init();
+      break;
+    }
+  },
+
+  /**
+   * See nsIFactory
+   */
+  createInstance: function WCCR_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return this.QueryInterface(iid);
+  },
+
+  /**
+   * See nsIClassInfo
+   */
+  getInterfaces: function WCCR_getInterfaces(countRef) {
+    var interfaces =
+        [Ci.nsIWebContentConverterService, Ci.nsIWebContentHandlerRegistrar,
+         Ci.nsIObserver, Ci.nsIClassInfo, Ci.nsIFactory, Ci.nsISupports];
+    countRef.value = interfaces.length;
+    return interfaces;
+  },
+  getHelperForLanguage: function WCCR_getHelperForLanguage(language) {
+    return null;
+  },
+  contractID: WCCR_CONTRACTID,
+  classDescription: WCCR_CLASSNAME,
+  classID: WCCR_CLASSID,
+  implementationLanguage: Ci.nsIProgrammingLanguage.JAVASCRIPT,
+  flags: Ci.nsIClassInfo.DOM_OBJECT,
+
+  /**
+   * See nsISupports
+   */
+  QueryInterface: XPCOMUtils.generateQI(
+     [Ci.nsIWebContentConverterService,
+      Ci.nsIWebContentHandlerRegistrar,
+      Ci.nsIObserver,
+      Ci.nsIClassInfo,
+      Ci.nsIFactory,
+      Ci.nsISupports]),
+
+  _xpcom_categories: [{
+    category: "app-startup",
+    service: true
+  }]
+};
+
+function NSGetModule(cm, file) {
+  return XPCOMUtils.generateModule([WebContentConverterRegistrar]);
+}
+
+#include ../../../../toolkit/content/debug.js
+
Index: mozilla/toolkit/components/feeds/src/nsFeedSniffer.cpp
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/nsFeedSniffer.cpp
@@ -0,0 +1,447 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Content Sniffer.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Robert Sayre <sayrer@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsFeedSniffer.h"
+
+#include "prmem.h"
+
+#include "nsNetCID.h"
+#include "nsXPCOM.h"
+#include "nsCOMPtr.h"
+#include "nsStringStream.h"
+
+#include "nsToolkitCompsCID.h"
+
+#include "nsICategoryManager.h"
+#include "nsIServiceManager.h"
+#include "nsComponentManagerUtils.h"
+#include "nsServiceManagerUtils.h"
+
+#include "nsIStreamConverterService.h"
+#include "nsIStreamConverter.h"
+
+#include "nsIStreamListener.h"
+
+#include "nsIHttpChannel.h"
+#include "nsIMIMEHeaderParam.h"
+
+#include "nsIObserver.h"
+
+#define TYPE_ATOM "application/atom+xml"
+#define TYPE_RSS "application/rss+xml"
+#define TYPE_MAYBE_FEED "application/vnd.mozilla.maybe.feed"
+
+#define NS_RDF "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+#define NS_RSS "http://purl.org/rss/1.0/"
+
+#define MAX_BYTES 512
+
+NS_IMPL_ISUPPORTS3(nsFeedSniffer,
+                   nsIContentSniffer,
+                   nsIStreamListener,
+                   nsIRequestObserver)
+
+nsresult
+nsFeedSniffer::ConvertEncodedData(nsIRequest* request,
+                                  const PRUint8* data,
+                                  PRUint32 length)
+{
+  nsresult rv = NS_OK;
+
+ mDecodedData = "";
+ nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(request));
+  if (!httpChannel)
+    return NS_ERROR_NO_INTERFACE;
+
+  nsCAutoString contentEncoding;
+  httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("Content-Encoding"),
+                                 contentEncoding);
+  if (!contentEncoding.IsEmpty()) {
+    nsCOMPtr<nsIStreamConverterService> converterService(do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID));
+    if (converterService) {
+      ToLowerCase(contentEncoding);
+
+      nsCOMPtr<nsIStreamListener> converter;
+      rv = converterService->AsyncConvertData(contentEncoding.get(),
+                                              "uncompressed", this, nsnull,
+                                              getter_AddRefs(converter));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      converter->OnStartRequest(request, nsnull);
+
+      nsCOMPtr<nsIStringInputStream> rawStream =
+        do_CreateInstance(NS_STRINGINPUTSTREAM_CONTRACTID);
+      if (!rawStream)
+        return NS_ERROR_FAILURE;
+
+      rv = rawStream->SetData((const char*)data, length);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = converter->OnDataAvailable(request, nsnull, rawStream, 0, length);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      converter->OnStopRequest(request, nsnull, NS_OK);
+    }
+  }
+  return rv;
+}
+
+template<int N>
+static PRBool
+StringBeginsWithLowercaseLiteral(nsAString& aString,
+                                 const char (&aSubstring)[N])
+{
+  return StringHead(aString, N).LowerCaseEqualsLiteral(aSubstring);
+}
+
+// XXXsayrer put this in here to get on the branch with minimal delay.
+// Trunk really needs to factor this out. This is the third usage.
+PRBool
+HasAttachmentDisposition(nsIHttpChannel* httpChannel)
+{
+  if (!httpChannel)
+    return PR_FALSE;
+
+  nsCAutoString contentDisposition;
+  nsresult rv =
+    httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("content-disposition"),
+                                   contentDisposition);
+
+  if (NS_SUCCEEDED(rv) && !contentDisposition.IsEmpty()) {
+    nsCOMPtr<nsIURI> uri;
+    httpChannel->GetURI(getter_AddRefs(uri));
+    nsCOMPtr<nsIMIMEHeaderParam> mimehdrpar =
+      do_GetService(NS_MIMEHEADERPARAM_CONTRACTID, &rv);
+    if (NS_SUCCEEDED(rv))
+    {
+      nsCAutoString fallbackCharset;
+      if (uri)
+        uri->GetOriginCharset(fallbackCharset);
+      nsAutoString dispToken;
+      // Get the disposition type
+      rv = mimehdrpar->GetParameter(contentDisposition, "", fallbackCharset,
+                                    PR_TRUE, nsnull, dispToken);
+      // RFC 2183, section 2.8 says that an unknown disposition
+      // value should be treated as "attachment"
+      // XXXbz this code is duplicated in GetFilenameAndExtensionFromChannel in
+      // nsExternalHelperAppService.  Factor it out!
+      if (NS_FAILED(rv) ||
+          (// Some broken sites just send
+           // Content-Disposition: ; filename="file"
+           // screen those out here.
+           !dispToken.IsEmpty() &&
+           !StringBeginsWithLowercaseLiteral(dispToken, "inline") &&
+           // Broken sites just send
+           // Content-Disposition: filename="file"
+           // without a disposition token... screen those out.
+           !StringBeginsWithLowercaseLiteral(dispToken, "filename")) &&
+          // Also in use is Content-Disposition: name="file"
+          !StringBeginsWithLowercaseLiteral(dispToken, "name"))
+        // We have a content-disposition of "attachment" or unknown
+        return PR_TRUE;
+    }
+  }
+
+  return PR_FALSE;
+}
+
+/**
+ * @return the first occurrence of a character within a string buffer,
+ *         or nsnull if not found
+ */
+static const char*
+FindChar(char c, const char *begin, const char *end)
+{
+  for (; begin < end; ++begin) {
+    if (*begin == c)
+      return begin;
+  }
+  return nsnull;
+}
+
+/**
+ *
+ * Determine if a substring is the "documentElement" in the document.
+ *
+ * All of our sniffed substrings: <rss, <feed, <rdf:RDF must be the "document"
+ * element within the XML DOM, i.e. the root container element. Otherwise,
+ * it's possible that someone embedded one of these tags inside a document of
+ * another type, e.g. a HTML document, and we don't want to show the preview
+ * page if the document isn't actually a feed.
+ *
+ * @param   start
+ *          The beginning of the data being sniffed
+ * @param   end
+ *          The end of the data being sniffed, right before the substring that
+ *          was found.
+ * @returns PR_TRUE if the found substring is the documentElement, PR_FALSE
+ *          otherwise.
+ */
+static PRBool
+IsDocumentElement(const char *start, const char* end)
+{
+  // For every tag in the buffer, check to see if it's a PI, Doctype or
+  // comment, our desired substring or something invalid.
+  while ( (start = FindChar('<', start, end)) ) {
+    ++start;
+    if (start >= end)
+      return PR_FALSE;
+
+    // Check to see if the character following the '<' is either '?' or '!'
+    // (processing instruction or doctype or comment)... these are valid nodes
+    // to have in the prologue.
+    if (*start != '?' && *start != '!')
+      return PR_FALSE;
+
+    // Now advance the iterator until the '>' (We do this because we don't want
+    // to sniff indicator substrings that are embedded within other nodes, e.g.
+    // comments: <!-- <rdf:RDF .. > -->
+    start = FindChar('>', start, end);
+    if (!start)
+      return PR_FALSE;
+
+    ++start;
+  }
+  return PR_TRUE;
+}
+
+/**
+ * Determines whether or not a string exists as the root element in an XML data
+ * string buffer.
+ * @param   dataString
+ *          The data being sniffed
+ * @param   substring
+ *          The substring being tested for existence and root-ness.
+ * @returns PR_TRUE if the substring exists and is the documentElement, PR_FALSE
+ *          otherwise.
+ */
+static PRBool
+ContainsTopLevelSubstring(const char *dataString, const char *substring)
+{
+  if (NULL == dataString)
+  {
+     return PR_FALSE;
+  }
+  const char *foundSubstring = strstr(dataString, substring);
+  if (NULL == foundSubstring)
+  {
+     return PR_FALSE;
+  }
+
+  // Only do the validation when we find the substring.
+  return IsDocumentElement(dataString, foundSubstring);
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::GetMIMETypeFromContent(nsIRequest* request,
+                                      const PRUint8* data,
+                                      PRUint32 length,
+                                      nsACString& sniffedType)
+{
+  nsCOMPtr<nsIHttpChannel> channel(do_QueryInterface(request));
+  if (!channel)
+    return NS_ERROR_NO_INTERFACE;
+
+  // Check that this is a GET request, since you can't subscribe to a POST...
+  nsCAutoString method;
+  channel->GetRequestMethod(method);
+  if (!method.Equals("GET")) {
+    sniffedType.Truncate();
+    return NS_OK;
+  }
+
+  // We need to find out if this is a load of a view-source document. In this
+  // case we do not want to override the content type, since the source display
+  // does not need to be converted from feed format to XUL. More importantly,
+  // we don't want to change the content type from something
+  // nsContentDLF::CreateInstance knows about (e.g. application/xml, text/html
+  // etc) to something that only the application fe knows about (maybe.feed)
+  // thus deactivating syntax highlighting.
+  nsCOMPtr<nsIURI> originalURI;
+  channel->GetOriginalURI(getter_AddRefs(originalURI));
+
+  nsCAutoString scheme;
+  originalURI->GetScheme(scheme);
+  if (scheme.EqualsLiteral("view-source")) {
+    sniffedType.Truncate();
+    return NS_OK;
+  }
+
+  // Check the Content-Type to see if it is set correctly. If it is set to
+  // something specific that we think is a reliable indication of a feed, don't
+  // bother sniffing since we assume the site maintainer knows what they're
+  // doing.
+  nsCAutoString contentType;
+  channel->GetContentType(contentType);
+  PRBool noSniff = contentType.EqualsLiteral(TYPE_RSS) ||
+                   contentType.EqualsLiteral(TYPE_ATOM);
+
+  // Check to see if this was a feed request from the location bar or from
+  // the feed: protocol. This is also a reliable indication.
+  // The value of the header doesn't matter.
+  if (!noSniff) {
+    nsCAutoString sniffHeader;
+    nsresult foundHeader =
+      channel->GetRequestHeader(NS_LITERAL_CSTRING("X-Moz-Is-Feed"),
+                                sniffHeader);
+    noSniff = NS_SUCCEEDED(foundHeader);
+  }
+
+  if (noSniff) {
+    // check for an attachment after we have a likely feed.
+    if(HasAttachmentDisposition(channel)) {
+      sniffedType.Truncate();
+      return NS_OK;
+    }
+
+    // set the feed header as a response header, since we have good metadata
+    // telling us that the feed is supposed to be RSS or Atom
+    channel->SetResponseHeader(NS_LITERAL_CSTRING("X-Moz-Is-Feed"),
+                               NS_LITERAL_CSTRING("1"), PR_FALSE);
+    sniffedType.AssignLiteral(TYPE_MAYBE_FEED);
+    return NS_OK;
+  }
+
+  // Now we need to potentially decompress data served with
+  // Content-Encoding: gzip
+  nsresult rv = ConvertEncodedData(request, data, length);
+  if (NS_FAILED(rv))
+    return rv;
+
+  const char* testData =
+    mDecodedData.IsEmpty() ? (const char*)data : mDecodedData.get();
+
+  // The strategy here is based on that described in:
+  // http://blogs.msdn.com/rssteam/articles/PublishersGuide.aspx
+  // for interoperarbility purposes.
+
+  // We cap the number of bytes to scan at MAX_BYTES to prevent picking up
+  // false positives by accidentally reading document content, e.g. a "how to
+  // make a feed" page.
+  if (length > MAX_BYTES)
+    length = MAX_BYTES;
+
+  // Thus begins the actual sniffing.
+  PRBool isFeed = PR_FALSE;
+  nsCString strData(testData, length);
+
+  //((const char*)testData, length);
+  // RSS 0.91/0.92/2.0
+  isFeed = ContainsTopLevelSubstring(strData.get(), "<rss");
+
+  // Atom 1.0
+  if (!isFeed)
+    isFeed = ContainsTopLevelSubstring(strData.get(), "<feed");
+
+  // RSS 1.0
+  if (!isFeed) {
+    isFeed = ContainsTopLevelSubstring(strData.get(), "<rdf:RDF") &&
+      NULL != strstr(strData.get(), NS_RDF) &&
+      NULL != strstr(strData.get(), NS_RSS);
+  }
+
+  // If we sniffed a feed, coerce our internal type
+  if (isFeed && !HasAttachmentDisposition(channel)) {
+    sniffedType.AssignLiteral(TYPE_MAYBE_FEED);
+    nsCAutoString url;
+    rv = originalURI->GetSpec(url);
+    NS_ENSURE_SUCCESS(rv, PR_TRUE);
+
+    nsCOMPtr<nsISupports> service = do_GetService("@browser/engine-client-observer;1", &rv);
+    NS_ENSURE_SUCCESS(rv, PR_TRUE);
+    nsCOMPtr<nsIObserver> Observer = do_QueryInterface(service, &rv);
+    NS_ENSURE_SUCCESS(rv, PR_TRUE);
+    rv = Observer->Observe(nsnull, "DOMLink_MAYBE_FEED", NS_ConvertUTF8toUTF16(url).get());
+  }
+  else
+    sniffedType.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::OnStartRequest(nsIRequest* request, nsISupports* context)
+{
+  return NS_OK;
+}
+
+NS_METHOD
+nsFeedSniffer::AppendSegmentToString(nsIInputStream* inputStream,
+                                     void* closure,
+                                     const char* rawSegment,
+                                     PRUint32 toOffset,
+                                     PRUint32 count,
+                                     PRUint32* writeCount)
+{
+  nsCString* decodedData = static_cast<nsCString*>(closure);
+  decodedData->Append(rawSegment, count);
+  *writeCount = count;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::OnDataAvailable(nsIRequest* request, nsISupports* context,
+                               nsIInputStream* stream, PRUint32 offset,
+                               PRUint32 count)
+{
+  PRUint32 read;
+  return stream->ReadSegments(AppendSegmentToString, &mDecodedData, count,
+                              &read);
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::OnStopRequest(nsIRequest* request, nsISupports* context,
+                             nsresult status)
+{
+  return NS_OK;
+}
+
+NS_METHOD
+nsFeedSniffer::Register(nsIComponentManager *compMgr, nsIFile *path,
+                        const char *registryLocation,
+                        const char *componentType,
+                        const nsModuleComponentInfo *info)
+{
+  nsresult rv;
+  nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  return catman->AddCategoryEntry(NS_CONTENT_SNIFFER_CATEGORY, "Feed Sniffer",
+                                  NS_FEEDSNIFFER_CONTRACTID, PR_TRUE, PR_TRUE,
+                                  nsnull);
+}
Index: mozilla/toolkit/components/feeds/src/nsFeedSniffer.h
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/nsFeedSniffer.h
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Content Sniffer.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsString.h"
+#include "nsIGenericFactory.h"
+#include "nsIContentSniffer.h"
+#include "nsIStreamListener.h"
+
+class nsFeedSniffer : public nsIContentSniffer, nsIStreamListener
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSICONTENTSNIFFER
+  NS_DECL_NSIREQUESTOBSERVER
+  NS_DECL_NSISTREAMLISTENER
+
+  static NS_METHOD AppendSegmentToString(nsIInputStream* inputStream,
+                                         void* closure,
+                                         const char* rawSegment,
+                                         PRUint32 toOffset,
+                                         PRUint32 count,
+                                         PRUint32* writeCount);
+
+  static NS_METHOD Register(nsIComponentManager* compMgr, nsIFile* path,
+                            const char* registryLocation,
+                            const char* componentType,
+                            const nsModuleComponentInfo *info);
+
+protected:
+  nsresult ConvertEncodedData(nsIRequest* request, const PRUint8* data,
+                              PRUint32 length);
+
+private:
+  nsCString mDecodedData;
+};
+
Index: mozilla/toolkit/components/feeds/src/FeedWriter.js
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/FeedWriter.js
@@ -0,0 +1,1448 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Feed Writer.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#   Jeff Walden <jwalden+code@mit.edu>
+#   Asaf Romano <mano@mozilla.com>
+#   Robert Sayre <sayrer@gmail.com>
+#   Michael Ventnor <m.ventnor@gmail.com>
+#   Will Guaraldi <will.guaraldi@pculture.org>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+const Cu = Components.utils;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+function LOG(str) {
+  var prefB = Cc["@mozilla.org/preferences-service;1"].
+              getService(Ci.nsIPrefBranch);
+
+  var shouldLog = false;
+  try {
+    shouldLog = prefB.getBoolPref("feeds.log");
+  }
+  catch (ex) {
+  }
+
+  if (shouldLog)
+    dump("*** Feeds: " + str + "\n");
+}
+
+/**
+ * Wrapper function for nsIIOService::newURI.
+ * @param aURLSpec
+ *        The URL string from which to create an nsIURI.
+ * @returns an nsIURI object, or null if the creation of the URI failed.
+ */
+function makeURI(aURLSpec, aCharset) {
+  var ios = Cc["@mozilla.org/network/io-service;1"].
+            getService(Ci.nsIIOService);
+  try {
+    return ios.newURI(aURLSpec, aCharset, null);
+  } catch (ex) { }
+
+  return null;
+}
+
+const XML_NS = "http://www.w3.org/XML/1998/namespace"
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const TYPE_MAYBE_FEED = "application/vnd.mozilla.maybe.feed";
+const TYPE_MAYBE_AUDIO_FEED = "application/vnd.mozilla.maybe.audio.feed";
+const TYPE_MAYBE_VIDEO_FEED = "application/vnd.mozilla.maybe.video.feed";
+const URI_BUNDLE = "chrome://feeds/locale/subscribe.properties";
+const SUBSCRIBE_PAGE_URI = "chrome://feeds/content/subscribe.xhtml";
+
+const PREF_SELECTED_APP = "browser.feeds.handlers.application";
+const PREF_SELECTED_WEB = "browser.feeds.handlers.webservice";
+const PREF_SELECTED_ACTION = "browser.feeds.handler";
+const PREF_SELECTED_READER = "browser.feeds.handler.default";
+
+const PREF_VIDEO_SELECTED_APP = "browser.videoFeeds.handlers.application";
+const PREF_VIDEO_SELECTED_WEB = "browser.videoFeeds.handlers.webservice";
+const PREF_VIDEO_SELECTED_ACTION = "browser.videoFeeds.handler";
+const PREF_VIDEO_SELECTED_READER = "browser.videoFeeds.handler.default";
+
+const PREF_AUDIO_SELECTED_APP = "browser.audioFeeds.handlers.application";
+const PREF_AUDIO_SELECTED_WEB = "browser.audioFeeds.handlers.webservice";
+const PREF_AUDIO_SELECTED_ACTION = "browser.audioFeeds.handler";
+const PREF_AUDIO_SELECTED_READER = "browser.audioFeeds.handler.default";
+
+const PREF_SHOW_FIRST_RUN_UI = "browser.feeds.showFirstRunUI";
+
+const TITLE_ID = "feedTitleText";
+const SUBTITLE_ID = "feedSubtitleText";
+
+function getPrefAppForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_APP;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_APP;
+
+    default:
+      return PREF_SELECTED_APP;
+  }
+}
+
+function getPrefWebForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_WEB;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_WEB;
+
+    default:
+      return PREF_SELECTED_WEB;
+  }
+}
+
+function getPrefActionForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_ACTION;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_ACTION;
+
+    default:
+      return PREF_SELECTED_ACTION;
+  }
+}
+
+function getPrefReaderForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_READER;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_READER;
+
+    default:
+      return PREF_SELECTED_READER;
+  }
+}
+
+/**
+ * Converts a number of bytes to the appropriate unit that results in a
+ * number that needs fewer than 4 digits
+ *
+ * @return a pair: [new value with 3 sig. figs., its unit]
+  */
+function convertByteUnits(aBytes) {
+  var units = ["bytes", "kilobyte", "megabyte", "gigabyte"];
+  let unitIndex = 0;
+
+  // convert to next unit if it needs 4 digits (after rounding), but only if
+  // we know the name of the next unit
+  while ((aBytes >= 999.5) && (unitIndex < units.length - 1)) {
+    aBytes /= 1024;
+    unitIndex++;
+  }
+
+  // Get rid of insignificant bits by truncating to 1 or 0 decimal points
+  // 0 -> 0; 1.2 -> 1.2; 12.3 -> 12.3; 123.4 -> 123; 234.5 -> 235
+  aBytes = aBytes.toFixed((aBytes > 0) && (aBytes < 100) ? 1 : 0);
+
+  return [aBytes, units[unitIndex]];
+}
+
+function FeedWriter() {}
+FeedWriter.prototype = {
+  _mimeSvc      : Cc["@mozilla.org/mime;1"].
+                  getService(Ci.nsIMIMEService),
+
+  _getPropertyAsBag: function FW__getPropertyAsBag(container, property) {
+    return container.fields.getProperty(property).
+                     QueryInterface(Ci.nsIPropertyBag2);
+  },
+
+  _getPropertyAsString: function FW__getPropertyAsString(container, property) {
+    try {
+      return container.fields.getPropertyAsAString(property);
+    }
+    catch (e) {
+    }
+    return "";
+  },
+
+  _setContentText: function FW__setContentText(id, text) {
+    this._contentSandbox.element = this._document.getElementById(id);
+    this._contentSandbox.textNode = this._document.createTextNode(text);
+    var codeStr =
+      "while (element.hasChildNodes()) " +
+      "  element.removeChild(element.firstChild);" +
+      "element.appendChild(textNode);";
+    Cu.evalInSandbox(codeStr, this._contentSandbox);
+    this._contentSandbox.element = null;
+    this._contentSandbox.textNode = null;
+  },
+
+  /**
+   * Safely sets the href attribute on an anchor tag, providing the URI
+   * specified can be loaded according to rules.
+   * @param   element
+   *          The element to set a URI attribute on
+   * @param   attribute
+   *          The attribute of the element to set the URI to, e.g. href or src
+   * @param   uri
+   *          The URI spec to set as the href
+   */
+  _safeSetURIAttribute:
+  function FW__safeSetURIAttribute(element, attribute, uri) {
+    var secman = Cc["@mozilla.org/scriptsecuritymanager;1"].
+                 getService(Ci.nsIScriptSecurityManager);
+    const flags = Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL;
+    try {
+      secman.checkLoadURIStrWithPrincipal(this._feedPrincipal, uri, flags);
+      // checkLoadURIStrWithPrincipal will throw if the link URI should not be
+      // loaded, either because our feedURI isn't allowed to load it or per
+      // the rules specified in |flags|, so we'll never "linkify" the link...
+    }
+    catch (e) {
+      // Not allowed to load this link because secman.checkLoadURIStr threw
+      return;
+    }
+
+    this._contentSandbox.element = element;
+    this._contentSandbox.uri = uri;
+    var codeStr = "element.setAttribute('" + attribute + "', uri);";
+    Cu.evalInSandbox(codeStr, this._contentSandbox);
+  },
+
+  /**
+   * Use this sandbox to run any dom manipulation code on nodes which
+   * are already inserted into the content document.
+   */
+  __contentSandbox: null,
+  get _contentSandbox() {
+    if (!this.__contentSandbox)
+      this.__contentSandbox = new Cu.Sandbox(this._window);
+
+    return this.__contentSandbox;
+  },
+
+  /**
+   * Calls doCommand for a the given XUL element within the context of the
+   * content document.
+   *
+   * @param aElement
+   *        the XUL element to call doCommand() on.
+   */
+  _safeDoCommand: function FW___safeDoCommand(aElement) {
+    this._contentSandbox.element = aElement;
+    Cu.evalInSandbox("element.doCommand();", this._contentSandbox);
+    this._contentSandbox.element = null;
+  },
+
+  __faviconService: null,
+  get _faviconService() {
+    if (!this.__faviconService)
+      this.__faviconService = Cc["@mozilla.org/browser/favicon-service;1"].
+                              getService(Ci.nsIFaviconService);
+
+    return this.__faviconService;
+  },
+
+  __bundle: null,
+  get _bundle() {
+    if (!this.__bundle) {
+      this.__bundle = Cc["@mozilla.org/intl/stringbundle;1"].
+                      getService(Ci.nsIStringBundleService).
+                      createBundle(URI_BUNDLE);
+    }
+    return this.__bundle;
+  },
+
+  _getFormattedString: function FW__getFormattedString(key, params) {
+    return this._bundle.formatStringFromName(key, params, params.length);
+  },
+
+  _getString: function FW__getString(key) {
+    return this._bundle.GetStringFromName(key);
+  },
+
+  /* Magic helper methods to be used instead of xbl properties */
+  _getSelectedItemFromMenulist: function FW__getSelectedItemFromList(aList) {
+    var node = aList.firstChild.firstChild;
+    while (node) {
+      if (node.localName == "menuitem" && node.getAttribute("selected") == "true")
+        return node;
+
+      node = node.nextSibling;
+    }
+
+    return null;
+  },
+
+  _setCheckboxCheckedState: function FW__setCheckboxCheckedState(aCheckbox, aValue) {
+    // see checkbox.xml, xbl bindings are not applied within the sandbox!
+    this._contentSandbox.checkbox = aCheckbox;
+    var codeStr;
+    var change = (aValue != (aCheckbox.getAttribute('checked') == 'true'));
+    if (aValue)
+      codeStr = "checkbox.setAttribute('checked', 'true'); ";
+    else
+      codeStr = "checkbox.removeAttribute('checked'); ";
+
+    if (change) {
+      this._contentSandbox.document = this._document;
+      codeStr += "var event = document.createEvent('Events'); " +
+                 "event.initEvent('CheckboxStateChange', true, true);" +
+                 "checkbox.dispatchEvent(event);"
+    }
+
+    Cu.evalInSandbox(codeStr, this._contentSandbox);
+  },
+
+   /**
+   * Returns a date suitable for displaying in the feed preview.
+   * If the date cannot be parsed, the return value is "false".
+   * @param   dateString
+   *          A date as extracted from a feed entry. (entry.updated)
+   */
+  _parseDate: function FW__parseDate(dateString) {
+    // Convert the date into the user's local time zone
+    dateObj = new Date(dateString);
+
+    // Make sure the date we're given is valid.
+    if (!dateObj.getTime())
+      return false;
+
+    var dateService = Cc["@mozilla.org/intl/scriptabledateformat;1"].
+                      getService(Ci.nsIScriptableDateFormat);
+    return dateService.FormatDateTime("", dateService.dateFormatLong, dateService.timeFormatNoSeconds,
+                                      dateObj.getFullYear(), dateObj.getMonth()+1, dateObj.getDate(),
+                                      dateObj.getHours(), dateObj.getMinutes(), dateObj.getSeconds());
+  },
+
+  /**
+   * Returns the feed type.
+   */
+  __feedType: null,
+  _getFeedType: function FW__getFeedType() {
+    if (this.__feedType != null)
+      return this.__feedType;
+
+    try {
+      // grab the feed because it's got the feed.type in it.
+      var container = this._getContainer();
+      var feed = container.QueryInterface(Ci.nsIFeed);
+      this.__feedType = feed.type;
+      return feed.type;
+    } catch (ex) { }
+
+    return Ci.nsIFeed.TYPE_FEED;
+  },
+
+  /**
+   * Maps a feed type to a maybe-feed mimetype.
+   */
+  _getMimeTypeForFeedType: function FW__getMimeTypeForFeedType() {
+    switch (this._getFeedType()) {
+      case Ci.nsIFeed.TYPE_VIDEO:
+        return TYPE_MAYBE_VIDEO_FEED;
+
+      case Ci.nsIFeed.TYPE_AUDIO:
+        return TYPE_MAYBE_AUDIO_FEED;
+
+      default:
+        return TYPE_MAYBE_FEED;
+    }
+  },
+
+  /**
+   * Writes the feed title into the preview document.
+   * @param   container
+   *          The feed container
+   */
+  _setTitleText: function FW__setTitleText(container) {
+    if (container.title) {
+      var title = container.title.plainText();
+      this._setContentText(TITLE_ID, title);
+      this._contentSandbox.document = this._document;
+      this._contentSandbox.title = title;
+      var codeStr = "document.title = title;"
+      Cu.evalInSandbox(codeStr, this._contentSandbox);
+    }
+
+    var feed = container.QueryInterface(Ci.nsIFeed);
+    if (feed && feed.subtitle)
+      this._setContentText(SUBTITLE_ID, container.subtitle.plainText());
+  },
+
+  /**
+   * Writes the title image into the preview document if one is present.
+   * @param   container
+   *          The feed container
+   */
+  _setTitleImage: function FW__setTitleImage(container) {
+    try {
+      var parts = container.image;
+
+      // Set up the title image (supplied by the feed)
+      var feedTitleImage = this._document.getElementById("feedTitleImage");
+      this._safeSetURIAttribute(feedTitleImage, "src",
+                                parts.getPropertyAsAString("url"));
+
+      // Set up the title image link
+      var feedTitleLink = this._document.getElementById("feedTitleLink");
+
+      var titleText = this._getFormattedString("linkTitleTextFormat",
+                                               [parts.getPropertyAsAString("title")]);
+      this._contentSandbox.feedTitleLink = feedTitleLink;
+      this._contentSandbox.titleText = titleText;
+      this._contentSandbox.feedTitleText = this._document.getElementById("feedTitleText");
+      this._contentSandbox.titleImageWidth = parseInt(parts.getPropertyAsAString("width")) + 15;
+
+      // Fix the margin on the main title, so that the image doesn't run over
+      // the underline
+      var codeStr = "feedTitleLink.setAttribute('title', titleText); " +
+                    "feedTitleText.style.marginRight = titleImageWidth + 'px';";
+      Cu.evalInSandbox(codeStr, this._contentSandbox);
+      this._contentSandbox.feedTitleLink = null;
+      this._contentSandbox.titleText = null;
+      this._contentSandbox.feedTitleText = null;
+      this._contentSandbox.titleImageWidth = null;
+
+      this._safeSetURIAttribute(feedTitleLink, "href",
+                                parts.getPropertyAsAString("link"));
+    }
+    catch (e) {
+      LOG("Failed to set Title Image (this is benign): " + e);
+    }
+  },
+
+  /**
+   * Writes all entries contained in the feed.
+   * @param   container
+   *          The container of entries in the feed
+   */
+  _writeFeedContent: function FW__writeFeedContent(container) {
+    // Build the actual feed content
+    var feed = container.QueryInterface(Ci.nsIFeed);
+    if (feed.items.length == 0)
+      return;
+
+    this._contentSandbox.feedContent =
+      this._document.getElementById("feedContent");
+
+    for (var i = 0; i < feed.items.length; ++i) {
+      var entry = feed.items.queryElementAt(i, Ci.nsIFeedEntry);
+      entry.QueryInterface(Ci.nsIFeedContainer);
+
+      var entryContainer = this._document.createElementNS(HTML_NS, "div");
+      entryContainer.className = "entry";
+
+      // If the entry has a title, make it a link
+      if (entry.title) {
+        var a = this._document.createElementNS(HTML_NS, "a");
+        a.appendChild(this._document.createTextNode(entry.title.plainText()));
+
+        // Entries are not required to have links, so entry.link can be null.
+        if (entry.link)
+          this._safeSetURIAttribute(a, "href", entry.link.spec);
+
+        var title = this._document.createElementNS(HTML_NS, "h3");
+        title.appendChild(a);
+
+        var lastUpdated = this._parseDate(entry.updated);
+        if (lastUpdated) {
+          var dateDiv = this._document.createElementNS(HTML_NS, "div");
+          dateDiv.className = "lastUpdated";
+          dateDiv.textContent = lastUpdated;
+          title.appendChild(dateDiv);
+        }
+
+        entryContainer.appendChild(title);
+      }
+
+      var body = this._document.createElementNS(HTML_NS, "div");
+      var summary = entry.summary || entry.content;
+      var docFragment = null;
+      if (summary) {
+        if (summary.base)
+          body.setAttributeNS(XML_NS, "base", summary.base.spec);
+        else
+          LOG("no base?");
+        docFragment = summary.createDocumentFragment(body);
+        if (docFragment)
+          body.appendChild(docFragment);
+
+        // If the entry doesn't have a title, append a # permalink
+        // See http://scripting.com/rss.xml for an example
+        if (!entry.title && entry.link) {
+          var a = this._document.createElementNS(HTML_NS, "a");
+          a.appendChild(this._document.createTextNode("#"));
+          this._safeSetURIAttribute(a, "href", entry.link.spec);
+          body.appendChild(this._document.createTextNode(" "));
+          body.appendChild(a);
+        }
+
+      }
+      body.className = "feedEntryContent";
+      entryContainer.appendChild(body);
+
+      if (entry.enclosures && entry.enclosures.length > 0) {
+        var enclosuresDiv = this._buildEnclosureDiv(entry);
+        entryContainer.appendChild(enclosuresDiv);
+      }
+
+      this._contentSandbox.entryContainer = entryContainer;
+      this._contentSandbox.clearDiv =
+        this._document.createElementNS(HTML_NS, "div");
+      this._contentSandbox.clearDiv.style.clear = "both";
+
+      var codeStr = "feedContent.appendChild(entryContainer); " +
+                     "feedContent.appendChild(clearDiv);"
+      Cu.evalInSandbox(codeStr, this._contentSandbox);
+    }
+
+    this._contentSandbox.feedContent = null;
+    this._contentSandbox.entryContainer = null;
+    this._contentSandbox.clearDiv = null;
+  },
+
+  /**
+   * Takes a url to a media item and returns the best name it can come up with.
+   * Frequently this is the filename portion (e.g. passing in
+   * http://example.com/foo.mpeg would return "foo.mpeg"), but in more complex
+   * cases, this will return the entire url (e.g. passing in
+   * http://example.com/somedirectory/ would return
+   * http://example.com/somedirectory/).
+   * @param aURL
+   *        The URL string from which to create a display name
+   * @returns a string
+   */
+  _getURLDisplayName: function FW__getURLDisplayName(aURL) {
+    var url = makeURI(aURL);
+    url.QueryInterface(Ci.nsIURL);
+    if (url == null || url.fileName.length == 0)
+      return aURL;
+
+    return decodeURI(url.fileName);
+  },
+
+  /**
+   * Takes a FeedEntry with enclosures, generates the HTML code to represent
+   * them, and returns that.
+   * @param   entry
+   *          FeedEntry with enclosures
+   * @returns element
+   */
+  _buildEnclosureDiv: function FW__buildEnclosureDiv(entry) {
+    var enclosuresDiv = this._document.createElementNS(HTML_NS, "div");
+    enclosuresDiv.className = "enclosures";
+
+    enclosuresDiv.appendChild(this._document.createTextNode(this._getString("mediaLabel")));
+
+    var roundme = function(n) {
+      return (Math.round(n * 100) / 100).toLocaleString();
+    }
+
+    for (var i_enc = 0; i_enc < entry.enclosures.length; ++i_enc) {
+      var enc = entry.enclosures.queryElementAt(i_enc, Ci.nsIWritablePropertyBag2);
+
+      if (!(enc.hasKey("url")))
+        continue;
+
+      var enclosureDiv = this._document.createElementNS(HTML_NS, "div");
+      enclosureDiv.setAttribute("class", "enclosure");
+
+      var mozicon = "moz-icon://.txt?size=16";
+      var type_text = null;
+      var size_text = null;
+
+      if (enc.hasKey("type")) {
+        type_text = enc.get("type");
+        try {
+          var handlerInfoWrapper = this._mimeSvc.getFromTypeAndExtension(enc.get("type"), null);
+
+          if (handlerInfoWrapper)
+            type_text = handlerInfoWrapper.description;
+
+          if  (type_text && type_text.length > 0)
+            mozicon = "moz-icon://goat?size=16&contentType=" + enc.get("type");
+
+        } catch (ex) { }
+
+      }
+
+      if (enc.hasKey("length") && /^[0-9]+$/.test(enc.get("length"))) {
+        var enc_size = convertByteUnits(parseInt(enc.get("length")));
+
+        var size_text = this._getFormattedString("enclosureSizeText",
+                             [enc_size[0], this._getString(enc_size[1])]);
+      }
+
+      var iconimg = this._document.createElementNS(HTML_NS, "img");
+      iconimg.setAttribute("src", mozicon);
+      iconimg.setAttribute("class", "type-icon");
+      enclosureDiv.appendChild(iconimg);
+
+      enclosureDiv.appendChild(this._document.createTextNode( " " ));
+
+      var enc_href = this._document.createElementNS(HTML_NS, "a");
+      enc_href.appendChild(this._document.createTextNode(this._getURLDisplayName(enc.get("url"))));
+      this._safeSetURIAttribute(enc_href, "href", enc.get("url"));
+      enclosureDiv.appendChild(enc_href);
+
+      if (type_text && size_text)
+        enclosureDiv.appendChild(this._document.createTextNode( " (" + type_text + ", " + size_text + ")"));
+
+      else if (type_text)
+        enclosureDiv.appendChild(this._document.createTextNode( " (" + type_text + ")"))
+
+      else if (size_text)
+        enclosureDiv.appendChild(this._document.createTextNode( " (" + size_text + ")"))
+
+      enclosuresDiv.appendChild(enclosureDiv);
+    }
+
+    return enclosuresDiv;
+  },
+
+  /**
+   * Gets a valid nsIFeedContainer object from the parsed nsIFeedResult.
+   * Displays error information if there was one.
+   * @param   result
+   *          The parsed feed result
+   * @returns A valid nsIFeedContainer object containing the contents of
+   *          the feed.
+   */
+  _getContainer: function FW__getContainer(result) {
+    var feedService =
+        Cc["@mozilla.org/browser/feeds/result-service;1"].
+        getService(Ci.nsIFeedResultService);
+
+    try {
+      var result =
+        feedService.getFeedResult(this._getOriginalURI(this._window));
+    }
+    catch (e) {
+      LOG("Subscribe Preview: feed not available?!");
+    }
+
+    if (result.bozo) {
+      LOG("Subscribe Preview: feed result is bozo?!");
+    }
+
+    try {
+      var container = result.doc;
+    }
+    catch (e) {
+      LOG("Subscribe Preview: no result.doc? Why didn't the original reload?");
+      return null;
+    }
+    return container;
+  },
+
+  /**
+   * Get the human-readable display name of a file. This could be the
+   * application name.
+   * @param   file
+   *          A nsIFile to look up the name of
+   * @returns The display name of the application represented by the file.
+   */
+  _getFileDisplayName: function FW__getFileDisplayName(file) {
+#ifdef XP_WIN
+    if (file instanceof Ci.nsILocalFileWin) {
+      try {
+        return file.getVersionInfoField("FileDescription");
+      }
+      catch (e) {
+      }
+    }
+#endif
+#ifdef XP_MACOSX
+    var lfm = file.QueryInterface(Ci.nsILocalFileMac);
+    try {
+      return lfm.bundleDisplayName;
+    }
+    catch (e) {
+      // fall through to the file name
+    }
+#endif
+    var ios =
+        Cc["@mozilla.org/network/io-service;1"].
+        getService(Ci.nsIIOService);
+    var url = ios.newFileURI(file).QueryInterface(Ci.nsIURL);
+    return url.fileName;
+  },
+
+  /**
+   * Get moz-icon url for a file
+   * @param   file
+   *          A nsIFile object for which the moz-icon:// is returned
+   * @returns moz-icon url of the given file as a string
+   */
+  _getFileIconURL: function FW__getFileIconURL(file) {
+    var ios = Cc["@mozilla.org/network/io-service;1"].
+              getService(Components.interfaces.nsIIOService);
+    var fph = ios.getProtocolHandler("file")
+                 .QueryInterface(Ci.nsIFileProtocolHandler);
+    var urlSpec = fph.getURLSpecFromFile(file);
+    return "moz-icon://" + urlSpec + "?size=16";
+  },
+
+  /**
+   * Helper method to set the selected application and system default
+   * reader menuitems details from a file object
+   *   @param aMenuItem
+   *          The menuitem on which the attributes should be set
+   *   @param aFile
+   *          The menuitem's associated file
+   */
+  _initMenuItemWithFile: function(aMenuItem, aFile) {
+    this._contentSandbox.menuitem = aMenuItem;
+    this._contentSandbox.label = this._getFileDisplayName(aFile);
+    this._contentSandbox.image = this._getFileIconURL(aFile);
+    var codeStr = "menuitem.setAttribute('label', label); " +
+                  "menuitem.setAttribute('image', image);"
+    Cu.evalInSandbox(codeStr, this._contentSandbox);
+  },
+
+  /**
+   * Displays a prompt from which the user may choose a (client) feed reader.
+   * @return - true if a feed reader was selected, false otherwise.
+   */
+  _chooseClientApp: function FW__chooseClientApp() {
+    try {
+      var fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
+      fp.init(this._window,
+              this._getString("chooseApplicationDialogTitle"),
+              Ci.nsIFilePicker.modeOpen);
+      fp.appendFilters(Ci.nsIFilePicker.filterApps);
+
+      if (fp.show() == Ci.nsIFilePicker.returnOK) {
+        this._selectedApp = fp.file;
+        if (this._selectedApp) {
+          // XXXben - we need to compare this with the running instance executable
+          //          just don't know how to do that via script...
+          // XXXmano TBD: can probably add this to nsIShellService
+#ifdef XP_WIN
+#expand           if (fp.file.leafName != "__MOZ_APP_NAME__.exe") {
+#else
+#ifdef XP_MACOSX
+#expand           if (fp.file.leafName != "__MOZ_APP_DISPLAYNAME__.app") {
+#else
+#expand           if (fp.file.leafName != "__MOZ_APP_NAME__-bin") {
+#endif
+#endif
+            this._initMenuItemWithFile(this._contentSandbox.selectedAppMenuItem,
+                                       this._selectedApp);
+
+            // Show and select the selected application menuitem
+            var codeStr = "selectedAppMenuItem.hidden = false;" +
+                          "selectedAppMenuItem.doCommand();"
+            Cu.evalInSandbox(codeStr, this._contentSandbox);
+            return true;
+          }
+        }
+      }
+    }
+    catch(ex) { }
+
+    return false;
+  },
+
+  _setAlwaysUseCheckedState: function FW__setAlwaysUseCheckedState(feedType) {
+    var checkbox = this._document.getElementById("alwaysUse");
+    if (checkbox) {
+      var alwaysUse = false;
+      try {
+        var prefs = Cc["@mozilla.org/preferences-service;1"].
+                    getService(Ci.nsIPrefBranch);
+        if (prefs.getCharPref(getPrefActionForType(feedType)) != "ask")
+          alwaysUse = true;
+      }
+      catch(ex) { }
+      this._setCheckboxCheckedState(checkbox, alwaysUse);
+    }
+  },
+
+  _setSubscribeUsingLabel: function FW__setSubscribeUsingLabel() {
+    var stringLabel = "subscribeFeedUsing";
+    switch (this._getFeedType()) {
+      case Ci.nsIFeed.TYPE_VIDEO:
+        stringLabel = "subscribeVideoPodcastUsing";
+        break;
+
+      case Ci.nsIFeed.TYPE_AUDIO:
+        stringLabel = "subscribeAudioPodcastUsing";
+        break;
+    }
+
+    this._contentSandbox.subscribeUsing =
+      this._document.getElementById("subscribeUsingDescription");
+    this._contentSandbox.label = this._getString(stringLabel);
+    var codeStr = "subscribeUsing.setAttribute('value', label);"
+    Cu.evalInSandbox(codeStr, this._contentSandbox);
+  },
+
+  _setAlwaysUseLabel: function FW__setAlwaysUseLabel() {
+    var checkbox = this._document.getElementById("alwaysUse");
+    if (checkbox) {
+      var handlersMenuList = this._document.getElementById("handlersMenuList");
+      if (handlersMenuList) {
+        var handlerName = this._getSelectedItemFromMenulist(handlersMenuList)
+                              .getAttribute("label");
+        var stringLabel = "alwaysUseForFeeds";
+        switch (this._getFeedType()) {
+          case Ci.nsIFeed.TYPE_VIDEO:
+            stringLabel = "alwaysUseForVideoPodcasts";
+            break;
+
+          case Ci.nsIFeed.TYPE_AUDIO:
+            stringLabel = "alwaysUseForAudioPodcasts";
+            break;
+        }
+
+        this._contentSandbox.checkbox = checkbox;
+        this._contentSandbox.label = this._getFormattedString(stringLabel, [handlerName]);
+
+        var codeStr = "checkbox.setAttribute('label', label);";
+        Cu.evalInSandbox(codeStr, this._contentSandbox);
+      }
+    }
+  },
+
+  // nsIDomEventListener
+  handleEvent: function(event) {
+    // see comments in the write method
+    event = new XPCNativeWrapper(event);
+    if (event.target.ownerDocument != this._document) {
+      LOG("FeedWriter.handleEvent: Someone passed the feed writer as a listener to the events of another document!");
+      return;
+    }
+
+    if (event.type == "command") {
+      switch (event.target.id) {
+        case "subscribeButton":
+          this.subscribe();
+          break;
+        case "chooseApplicationMenuItem":
+          /* Bug 351263: Make sure to not steal focus if the "Choose
+           * Application" item is being selected with the keyboard. We do this
+           * by ignoring command events while the dropdown is closed (user
+           * arrowing through the combobox), but handling them while the
+           * combobox dropdown is open (user pressed enter when an item was
+           * selected). If we don't show the filepicker here, it will be shown
+           * when clicking "Subscribe Now".
+           */
+          var popupbox = this._document.getElementById("handlersMenuList")
+                             .firstChild.boxObject;
+          popupbox.QueryInterface(Components.interfaces.nsIPopupBoxObject);
+          if (popupbox.popupState == "hiding" && !this._chooseClientApp()) {
+            // Select the (per-prefs) selected handler if no application was
+            // selected
+            this._setSelectedHandler(this._getFeedType());
+          }
+          break;
+        default:
+          this._setAlwaysUseLabel();
+      }
+    }
+  },
+
+  _setSelectedHandler: function FW__setSelectedHandler(feedType) {
+    var prefs =
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefBranch);
+
+    var handler = "bookmarks";
+    try {
+      handler = prefs.getCharPref(getPrefReaderForType(feedType));
+    }
+    catch (ex) { }
+
+    switch (handler) {
+      case "web": {
+        var handlersMenuList = this._document.getElementById("handlersMenuList");
+        if (handlersMenuList) {
+          var url = prefs.getComplexValue(getPrefWebForType(feedType), Ci.nsISupportsString).data;
+          var handlers =
+            handlersMenuList.getElementsByAttribute("webhandlerurl", url);
+          if (handlers.length == 0) {
+            LOG("FeedWriter._setSelectedHandler: selected web handler isn't in the menulist")
+            return;
+          }
+
+          this._safeDoCommand(handlers[0]);
+        }
+        break;
+      }
+      case "client": {
+        try {
+          this._selectedApp =
+            prefs.getComplexValue(getPrefAppForType(feedType), Ci.nsILocalFile);
+        }
+        catch(ex) {
+          this._selectedApp = null;
+        }
+
+        if (this._selectedApp) {
+          this._initMenuItemWithFile(this._contentSandbox.selectedAppMenuItem,
+                                     this._selectedApp);
+          var codeStr = "selectedAppMenuItem.hidden = false; " +
+                        "selectedAppMenuItem.doCommand(); ";
+
+          // Only show the default reader menuitem if the default reader
+          // isn't the selected application
+          if (this._defaultSystemReader) {
+            var shouldHide =
+              this._defaultSystemReader.path == this._selectedApp.path;
+            codeStr += "defaultHandlerMenuItem.hidden = " + shouldHide + ";"
+          }
+          Cu.evalInSandbox(codeStr, this._contentSandbox);
+          break;
+        }
+      }
+      case "bookmarks":
+      default: {
+        var liveBookmarksMenuItem = this._document.getElementById("liveBookmarksMenuItem");
+        if (liveBookmarksMenuItem)
+          this._safeDoCommand(liveBookmarksMenuItem);
+      }
+    }
+  },
+
+  _initSubscriptionUI: function FW__initSubscriptionUI() {
+    var handlersMenuPopup = this._document.getElementById("handlersMenuPopup");
+    if (!handlersMenuPopup)
+      return;
+
+    var feedType = this._getFeedType();
+    var codeStr;
+
+    // change the background
+    var header = this._document.getElementById("feedHeader");
+    this._contentSandbox.header = header;
+    switch (feedType) {
+      case Ci.nsIFeed.TYPE_VIDEO:
+        codeStr = "header.className = 'videoPodcastBackground'; ";
+        break;
+
+      case Ci.nsIFeed.TYPE_AUDIO:
+        codeStr = "header.className = 'audioPodcastBackground'; ";
+        break;
+
+      default:
+        codeStr = "header.className = 'feedBackground'; ";
+    }
+
+
+    // Last-selected application
+    var menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+    menuItem.id = "selectedAppMenuItem";
+    menuItem.className = "menuitem-iconic";
+    menuItem.setAttribute("handlerType", "client");
+    try {
+      var prefs = Cc["@mozilla.org/preferences-service;1"].
+                  getService(Ci.nsIPrefBranch);
+      this._selectedApp = prefs.getComplexValue(getPrefAppForType(feedType),
+                                                Ci.nsILocalFile);
+
+      if (this._selectedApp.exists())
+        this._initMenuItemWithFile(menuItem, this._selectedApp);
+      else {
+        // Hide the menuitem if the last selected application doesn't exist
+        menuItem.setAttribute("hidden", true);
+      }
+    }
+    catch(ex) {
+      // Hide the menuitem until an application is selected
+      menuItem.setAttribute("hidden", true);
+    }
+    this._contentSandbox.handlersMenuPopup = handlersMenuPopup;
+    this._contentSandbox.selectedAppMenuItem = menuItem;
+
+    codeStr += "handlersMenuPopup.appendChild(selectedAppMenuItem); ";
+
+    // List the default feed reader
+    try {
+      this._defaultSystemReader = Cc["@mozilla.org/browser/shell-service;1"].
+                                  getService(Ci.nsIShellService).
+                                  defaultFeedReader;
+      menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+      menuItem.id = "defaultHandlerMenuItem";
+      menuItem.className = "menuitem-iconic";
+      menuItem.setAttribute("handlerType", "client");
+
+      this._initMenuItemWithFile(menuItem, this._defaultSystemReader);
+
+      // Hide the default reader item if it points to the same application
+      // as the last-selected application
+      if (this._selectedApp &&
+          this._selectedApp.path == this._defaultSystemReader.path)
+        menuItem.hidden = true;
+    }
+    catch(ex) { menuItem = null; /* no default reader */ }
+
+    if (menuItem) {
+      this._contentSandbox.defaultHandlerMenuItem = menuItem;
+      codeStr += "handlersMenuPopup.appendChild(defaultHandlerMenuItem); ";
+    }
+
+    // "Choose Application..." menuitem
+    menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+    menuItem.id = "chooseApplicationMenuItem";
+    menuItem.setAttribute("label", this._getString("chooseApplicationMenuItem"));
+
+    this._contentSandbox.chooseAppMenuItem = menuItem;
+    codeStr += "handlersMenuPopup.appendChild(chooseAppMenuItem); ";
+
+    // separator
+    this._contentSandbox.chooseAppSep =
+      this._document.createElementNS(XUL_NS, "menuseparator")
+    codeStr += "handlersMenuPopup.appendChild(chooseAppSep); ";
+
+    Cu.evalInSandbox(codeStr, this._contentSandbox);
+
+    var historySvc = Cc["@mozilla.org/browser/nav-history-service;1"].
+                     getService(Ci.nsINavHistoryService);
+    historySvc.addObserver(this, false);
+
+    // List of web handlers
+    var wccr = Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+               getService(Ci.nsIWebContentConverterService);
+    var handlers = wccr.getContentHandlers(this._getMimeTypeForFeedType(feedType), {});
+    if (handlers.length != 0) {
+      for (var i = 0; i < handlers.length; ++i) {
+        menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+        menuItem.className = "menuitem-iconic";
+        menuItem.setAttribute("label", handlers[i].name);
+        menuItem.setAttribute("handlerType", "web");
+        menuItem.setAttribute("webhandlerurl", handlers[i].uri);
+        this._contentSandbox.menuItem = menuItem;
+        codeStr = "handlersMenuPopup.appendChild(menuItem);";
+        Cu.evalInSandbox(codeStr, this._contentSandbox);
+
+        // For privacy reasons we cannot set the image attribute directly
+        // to the icon url, see Bug 358878
+        var uri = makeURI(handlers[i].uri);
+        if (!this._setFaviconForWebReader(uri, menuItem)) {
+          if (uri && /^https?/.test(uri.scheme)) {
+            var iconURL = makeURI(uri.prePath + "/favicon.ico");
+            this._faviconService.setAndLoadFaviconForPage(uri, iconURL, true);
+          }
+        }
+      }
+      this._contentSandbox.menuItem = null;
+    }
+
+    this._setSelectedHandler(feedType);
+
+    // "Subscribe using..."
+    this._setSubscribeUsingLabel();
+
+    // "Always use..." checkbox initial state
+    this._setAlwaysUseCheckedState(feedType);
+    this._setAlwaysUseLabel();
+
+    // We update the "Always use.." checkbox label whenever the selected item
+    // in the list is changed
+    handlersMenuPopup.addEventListener("command", this, false);
+
+    // Set up the "Subscribe Now" button
+    this._document
+        .getElementById("subscribeButton")
+        .addEventListener("command", this, false);
+
+    // first-run ui
+    var showFirstRunUI = true;
+    try {
+      showFirstRunUI = prefs.getBoolPref(PREF_SHOW_FIRST_RUN_UI);
+    }
+    catch (ex) { }
+    if (showFirstRunUI) {
+      var textfeedinfo1, textfeedinfo2;
+      switch (feedType) {
+        case Ci.nsIFeed.TYPE_VIDEO:
+          textfeedinfo1 = "feedSubscriptionVideoPodcast1";
+          textfeedinfo2 = "feedSubscriptionVideoPodcast2";
+          break;
+        case Ci.nsIFeed.TYPE_AUDIO:
+          textfeedinfo1 = "feedSubscriptionAudioPodcast1";
+          textfeedinfo2 = "feedSubscriptionAudioPodcast2";
+          break;
+        default:
+          textfeedinfo1 = "feedSubscriptionFeed1";
+          textfeedinfo2 = "feedSubscriptionFeed2";
+      }
+
+      this._contentSandbox.feedinfo1 =
+        this._document.getElementById("feedSubscriptionInfo1");
+      this._contentSandbox.feedinfo1Str = this._getString(textfeedinfo1);
+      this._contentSandbox.feedinfo2 =
+        this._document.getElementById("feedSubscriptionInfo2");
+      this._contentSandbox.feedinfo2Str = this._getString(textfeedinfo2);
+      this._contentSandbox.header = header;
+      codeStr = "feedinfo1.value = feedinfo1Str; " +
+                "feedinfo2.value = feedinfo2Str; " +
+                "header.setAttribute('firstrun', 'true');"
+      Cu.evalInSandbox(codeStr, this._contentSandbox);
+      prefs.setBoolPref(PREF_SHOW_FIRST_RUN_UI, false);
+    }
+  },
+
+  /**
+   * Returns the original URI object of the feed and ensures that this
+   * component is only ever invoked from the preview document.
+   * @param aWindow
+   *        The window of the document invoking the BrowserFeedWriter
+   */
+  _getOriginalURI: function FW__getOriginalURI(aWindow) {
+    var chan = aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+               getInterface(Ci.nsIWebNavigation).
+               QueryInterface(Ci.nsIDocShell).currentDocumentChannel;
+
+    var uri = makeURI(SUBSCRIBE_PAGE_URI);
+    var resolvedURI = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                      getService(Ci.nsIChromeRegistry).
+                      convertChromeURL(uri);
+
+    if (resolvedURI.equals(chan.URI))
+      return chan.originalURI;
+
+    return null;
+  },
+
+  _window: null,
+  _document: null,
+  _feedURI: null,
+  _feedPrincipal: null,
+
+  // nsIFeedWriter
+  init: function FW_init(aWindow) {
+    // Explicitly wrap |window| in an XPCNativeWrapper to make sure
+    // it's a real native object! This will throw an exception if we
+    // get a non-native object.
+    var window = new XPCNativeWrapper(aWindow);
+    this._feedURI = this._getOriginalURI(window);
+    if (!this._feedURI)
+      return;
+
+    this._window = window;
+    this._document = window.document;
+
+    var secman = Cc["@mozilla.org/scriptsecuritymanager;1"].
+                 getService(Ci.nsIScriptSecurityManager);
+    this._feedPrincipal = secman.getCodebasePrincipal(this._feedURI);
+
+    LOG("Subscribe Preview: feed uri = " + this._window.location.href);
+
+    // Set up the subscription UI
+    this._initSubscriptionUI();
+    var prefs = Cc["@mozilla.org/preferences-service;1"].
+                getService(Ci.nsIPrefBranch2);
+    prefs.addObserver(PREF_SELECTED_ACTION, this, false);
+    prefs.addObserver(PREF_SELECTED_READER, this, false);
+    prefs.addObserver(PREF_SELECTED_WEB, this, false);
+    prefs.addObserver(PREF_SELECTED_APP, this, false);
+    prefs.addObserver(PREF_VIDEO_SELECTED_ACTION, this, false);
+    prefs.addObserver(PREF_VIDEO_SELECTED_READER, this, false);
+    prefs.addObserver(PREF_VIDEO_SELECTED_WEB, this, false);
+    prefs.addObserver(PREF_VIDEO_SELECTED_APP, this, false);
+
+    prefs.addObserver(PREF_AUDIO_SELECTED_ACTION, this, false);
+    prefs.addObserver(PREF_AUDIO_SELECTED_READER, this, false);
+    prefs.addObserver(PREF_AUDIO_SELECTED_WEB, this, false);
+    prefs.addObserver(PREF_AUDIO_SELECTED_APP, this, false);
+  },
+
+  writeContent: function FW_writeContent() {
+    if (!this._window)
+      return;
+
+    try {
+      // Set up the feed content
+      var container = this._getContainer();
+      if (!container)
+        return;
+
+      this._setTitleText(container);
+      this._setTitleImage(container);
+      this._writeFeedContent(container);
+    }
+    finally {
+      this._removeFeedFromCache();
+    }
+  },
+
+  close: function FW_close() {
+    this._document
+        .getElementById("handlersMenuPopup")
+        .removeEventListener("command", this, false);
+    this._document
+        .getElementById("subscribeButton")
+        .removeEventListener("command", this, false);
+    this._document = null;
+    this._window = null;
+    var prefs = Cc["@mozilla.org/preferences-service;1"].
+                getService(Ci.nsIPrefBranch2);
+    prefs.removeObserver(PREF_SELECTED_ACTION, this);
+    prefs.removeObserver(PREF_SELECTED_READER, this);
+    prefs.removeObserver(PREF_SELECTED_WEB, this);
+    prefs.removeObserver(PREF_SELECTED_APP, this);
+    prefs.removeObserver(PREF_VIDEO_SELECTED_ACTION, this);
+    prefs.removeObserver(PREF_VIDEO_SELECTED_READER, this);
+    prefs.removeObserver(PREF_VIDEO_SELECTED_WEB, this);
+    prefs.removeObserver(PREF_VIDEO_SELECTED_APP, this);
+
+    prefs.removeObserver(PREF_AUDIO_SELECTED_ACTION, this);
+    prefs.removeObserver(PREF_AUDIO_SELECTED_READER, this);
+    prefs.removeObserver(PREF_AUDIO_SELECTED_WEB, this);
+    prefs.removeObserver(PREF_AUDIO_SELECTED_APP, this);
+
+    this._removeFeedFromCache();
+    this.__faviconService = null;
+    this.__bundle = null;
+    this._feedURI = null;
+    this.__contentSandbox = null;
+
+    var historySvc = Cc["@mozilla.org/browser/nav-history-service;1"].
+                     getService(Ci.nsINavHistoryService);
+    historySvc.removeObserver(this);
+  },
+
+  _removeFeedFromCache: function FW__removeFeedFromCache() {
+    if (this._feedURI) {
+      var feedService = Cc["@mozilla.org/browser/feeds/result-service;1"].
+                        getService(Ci.nsIFeedResultService);
+      feedService.removeFeedResult(this._feedURI);
+      this._feedURI = null;
+    }
+  },
+
+  subscribe: function FW_subscribe() {
+    var feedType = this._getFeedType();
+
+    // Subscribe to the feed using the selected handler and save prefs
+    var prefs = Cc["@mozilla.org/preferences-service;1"].
+                getService(Ci.nsIPrefBranch);
+    var defaultHandler = "reader";
+    var useAsDefault = this._document.getElementById("alwaysUse")
+                                     .getAttribute("checked");
+
+    var handlersMenuList = this._document.getElementById("handlersMenuList");
+    var selectedItem = this._getSelectedItemFromMenulist(handlersMenuList);
+
+    // Show the file picker before subscribing if the
+    // choose application menuitem was choosen using the keyboard
+    if (selectedItem.id == "chooseApplicationMenuItem") {
+      if (!this._chooseClientApp())
+        return;
+
+      selectedItem = this._getSelectedItemFromMenulist(handlersMenuList);
+    }
+
+    if (selectedItem.hasAttribute("webhandlerurl")) {
+      var webURI = selectedItem.getAttribute("webhandlerurl");
+      prefs.setCharPref(getPrefReaderForType(feedType), "web");
+
+      var supportsString = Cc["@mozilla.org/supports-string;1"].
+                           createInstance(Ci.nsISupportsString);
+      supportsString.data = webURI;
+      prefs.setComplexValue(getPrefWebForType(feedType), Ci.nsISupportsString,
+                            supportsString);
+
+      var wccr = Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+                 getService(Ci.nsIWebContentConverterService);
+      var handler = wccr.getWebContentHandlerByURI(this._getMimeTypeForFeedType(feedType), webURI);
+      if (handler) {
+        if (useAsDefault)
+          wccr.setAutoHandler(this._getMimeTypeForFeedType(feedType), handler);
+
+        this._window.location.href = handler.getHandlerURI(this._window.location.href);
+      }
+    }
+    else {
+      switch (selectedItem.id) {
+        case "selectedAppMenuItem":
+          prefs.setCharPref(getPrefReaderForType(feedType), "client");
+          prefs.setComplexValue(getPrefAppForType(feedType), Ci.nsILocalFile,
+                                this._selectedApp);
+          break;
+        case "defaultHandlerMenuItem":
+          prefs.setCharPref(getPrefReaderForType(feedType), "client");
+          prefs.setComplexValue(getPrefAppForType(feedType), Ci.nsILocalFile,
+                                this._defaultSystemReader);
+          break;
+        case "liveBookmarksMenuItem":
+          defaultHandler = "bookmarks";
+          prefs.setCharPref(getPrefReaderForType(feedType), "bookmarks");
+          break;
+      }
+      var feedService = Cc["@mozilla.org/browser/feeds/result-service;1"].
+                        getService(Ci.nsIFeedResultService);
+
+      // Pull the title and subtitle out of the document
+      var feedTitle = this._document.getElementById(TITLE_ID).textContent;
+      var feedSubtitle = this._document.getElementById(SUBTITLE_ID).textContent;
+      feedService.addToClientReader(this._window.location.href, feedTitle, feedSubtitle, feedType);
+    }
+
+    // If "Always use..." is checked, we should set PREF_*SELECTED_ACTION
+    // to either "reader" (If a web reader or if an application is selected),
+    // or to "bookmarks" (if the live bookmarks option is selected).
+    // Otherwise, we should set it to "ask"
+    if (useAsDefault)
+      prefs.setCharPref(getPrefActionForType(feedType), defaultHandler);
+    else
+      prefs.setCharPref(getPrefActionForType(feedType), "ask");
+  },
+
+  // nsIObserver
+  observe: function FW_observe(subject, topic, data) {
+    if (!this._window) {
+      // this._window is null unless this.write was called with a trusted
+      // window object.
+      return;
+    }
+
+    var feedType = this._getFeedType();
+
+    if (topic == "nsPref:changed") {
+      switch (data) {
+        case PREF_SELECTED_READER:
+        case PREF_SELECTED_WEB:
+        case PREF_SELECTED_APP:
+        case PREF_VIDEO_SELECTED_READER:
+        case PREF_VIDEO_SELECTED_WEB:
+        case PREF_VIDEO_SELECTED_APP:
+        case PREF_AUDIO_SELECTED_READER:
+        case PREF_AUDIO_SELECTED_WEB:
+        case PREF_AUDIO_SELECTED_APP:
+          this._setSelectedHandler(feedType);
+          break;
+        case PREF_SELECTED_ACTION:
+        case PREF_VIDEO_SELECTED_ACTION:
+        case PREF_AUDIO_SELECTED_ACTION:
+          this._setAlwaysUseCheckedState(feedType);
+      }
+    }
+  },
+
+  /**
+   * Sets the icon for the given web-reader item in the readers menu
+   * if the favicon-service has the necessary icon stored.
+   * @param aURI
+   *        the reader URI.
+   * @param aMenuItem
+   *        the reader item in the readers menulist.
+   * @return true if the icon was set, false otherwise.
+   */
+  _setFaviconForWebReader:
+  function FW__setFaviconForWebReader(aURI, aMenuItem) {
+    var faviconsSvc = this._faviconService;
+    var faviconURL = null;
+    try {
+      faviconURL = faviconsSvc.getFaviconForPage(aURI);
+    }
+    catch(ex) { }
+
+    if (faviconURL) {
+      var mimeType = { };
+      var bytes = faviconsSvc.getFaviconData(faviconURL, mimeType,
+                                             { /* dataLen */ });
+      if (bytes) {
+        var dataURI = "data:" + mimeType.value + ";" + "base64," +
+                      btoa(String.fromCharCode.apply(null, bytes));
+
+        this._contentSandbox.menuItem = aMenuItem;
+        this._contentSandbox.dataURI = dataURI;
+        var codeStr = "menuItem.setAttribute('image', dataURI);";
+        Cu.evalInSandbox(codeStr, this._contentSandbox);
+        this._contentSandbox.menuItem = null;
+        this._contentSandbox.dataURI = null;
+
+        return true;
+      }
+    }
+
+    return false;
+  },
+
+   // nsINavHistoryService
+   onPageChanged: function FW_onPageChanged(aURI, aWhat, aValue) {
+     if (aWhat == Ci.nsINavHistoryObserver.ATTRIBUTE_FAVICON) {
+       // Go through the readers menu and look for the corresponding
+       // reader menu-item for the page if any.
+       var spec = aURI.spec;
+       var handlersMenulist = this._document.getElementById("handlersMenuList");
+       var possibleHandlers = handlersMenulist.firstChild.childNodes;
+       for (var i=0; i < possibleHandlers.length ; i++) {
+         if (possibleHandlers[i].getAttribute("webhandlerurl") == spec) {
+           this._setFaviconForWebReader(aURI, possibleHandlers[i]);
+           return;
+         }
+       }
+     }
+   },
+
+   onBeginUpdateBatch: function() { },
+   onEndUpdateBatch: function() { },
+   onVisit: function() { },
+   onTitleChanged: function() { },
+   onDeleteURI: function() { },
+   onClearHistory: function() { },
+   onPageExpired: function() { },
+
+  // nsIClassInfo
+  getInterfaces: function FW_getInterfaces(countRef) {
+    var interfaces = [Ci.nsIFeedWriter, Ci.nsIClassInfo, Ci.nsISupports];
+    countRef.value = interfaces.length;
+    return interfaces;
+  },
+  getHelperForLanguage: function FW_getHelperForLanguage(language) null,
+  contractID: "@mozilla.org/browser/feeds/result-writer;1",
+  classDescription: "Feed Writer",
+  classID: Components.ID("{49bb6593-3aff-4eb3-a068-2712c28bd58e}"),
+  implementationLanguage: Ci.nsIProgrammingLanguage.JAVASCRIPT,
+  flags: Ci.nsIClassInfo.DOM_OBJECT,
+  _xpcom_categories: [{ category: "JavaScript global constructor",
+                        entry: "BrowserFeedWriter"}],
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIFeedWriter, Ci.nsIClassInfo,
+                                         Ci.nsIDOMEventListener, Ci.nsIObserver,
+                                         Ci.nsINavHistoryObserver])
+};
+
+function NSGetModule(cm, file)
+  XPCOMUtils.generateModule([FeedWriter]);
Index: mozilla/toolkit/components/feeds/src/GenericFactory.js
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/GenericFactory.js
@@ -0,0 +1,63 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Generic Component Factory.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+/**
+ * An object implementing nsIFactory that can construct other objects upon
+ * createInstance, passing a set of parameters to that object's constructor.
+ */
+function GenericComponentFactory(ctor, params) {
+  this._ctor = ctor;
+  this._params = params;
+}
+GenericComponentFactory.prototype = {
+  _ctor: null,
+  _params: null,
+
+  createInstance: function GCF_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return (new this._ctor(this._params)).QueryInterface(iid);
+  },
+
+  QueryInterface: function GCF_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
Index: mozilla/toolkit/components/feeds/src/FeedConverter.js
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/FeedConverter.js
@@ -0,0 +1,691 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Feed Stream Converter.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#   Jeff Walden <jwalden+code@mit.edu>
+#   Will Guaraldi <will.guaraldi@pculture.org>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+function LOG(str) {
+  dump("*** " + str + "\n");
+}
+
+const FC_CLASSID = Components.ID("{229fa115-9412-4d32-baf3-2fc407f76fb1}");
+const FC_CLASSNAME = "Feed Stream Converter";
+const FS_CLASSID = Components.ID("{2376201c-bbc6-472f-9b62-7548040a61c6}");
+const FS_CLASSNAME = "Feed Result Service";
+const FS_CONTRACTID = "@mozilla.org/browser/feeds/result-service;1";
+const FPH_CONTRACTID = "@mozilla.org/network/protocol;1?name=feed";
+const FPH_CLASSID = Components.ID("{4f91ef2e-57ba-472e-ab7a-b4999e42d6c0}");
+const FPH_CLASSNAME = "Feed Protocol Handler";
+const PCPH_CONTRACTID = "@mozilla.org/network/protocol;1?name=pcast";
+const PCPH_CLASSID = Components.ID("{1c31ed79-accd-4b94-b517-06e0c81999d5}");
+const PCPH_CLASSNAME = "Podcast Protocol Handler";
+
+const TYPE_MAYBE_FEED = "application/vnd.mozilla.maybe.feed";
+const TYPE_MAYBE_VIDEO_FEED = "application/vnd.mozilla.maybe.video.feed";
+const TYPE_MAYBE_AUDIO_FEED = "application/vnd.mozilla.maybe.audio.feed";
+const TYPE_ANY = "*/*";
+
+const FEEDHANDLER_URI = "about:feeds";
+
+const PREF_SELECTED_APP = "browser.feeds.handlers.application";
+const PREF_SELECTED_WEB = "browser.feeds.handlers.webservice";
+const PREF_SELECTED_ACTION = "browser.feeds.handler";
+const PREF_SELECTED_READER = "browser.feeds.handler.default";
+
+const PREF_VIDEO_SELECTED_APP = "browser.videoFeeds.handlers.application";
+const PREF_VIDEO_SELECTED_WEB = "browser.videoFeeds.handlers.webservice";
+const PREF_VIDEO_SELECTED_ACTION = "browser.videoFeeds.handler";
+const PREF_VIDEO_SELECTED_READER = "browser.videoFeeds.handler.default";
+
+const PREF_AUDIO_SELECTED_APP = "browser.audioFeeds.handlers.application";
+const PREF_AUDIO_SELECTED_WEB = "browser.audioFeeds.handlers.webservice";
+const PREF_AUDIO_SELECTED_ACTION = "browser.audioFeeds.handler";
+const PREF_AUDIO_SELECTED_READER = "browser.audioFeeds.handler.default";
+
+function getPrefAppForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_APP;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_APP;
+
+    default:
+      return PREF_SELECTED_APP;
+  }
+}
+
+function getPrefWebForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_WEB;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_WEB;
+
+    default:
+      return PREF_SELECTED_WEB;
+  }
+}
+
+function getPrefActionForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_ACTION;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_ACTION;
+
+    default:
+      return PREF_SELECTED_ACTION;
+  }
+}
+
+function getPrefReaderForType(t) {
+  switch (t) {
+    case Ci.nsIFeed.TYPE_VIDEO:
+      return PREF_VIDEO_SELECTED_READER;
+
+    case Ci.nsIFeed.TYPE_AUDIO:
+      return PREF_AUDIO_SELECTED_READER;
+
+    default:
+      return PREF_SELECTED_READER;
+  }
+}
+
+function safeGetCharPref(pref, defaultValue) {
+  var prefs =
+      Cc["@mozilla.org/preferences-service;1"].
+      getService(Ci.nsIPrefBranch);
+  try {
+    return prefs.getCharPref(pref);
+  }
+  catch (e) {
+  }
+  return defaultValue;
+}
+
+function FeedConverter() {
+}
+FeedConverter.prototype = {
+  /**
+   * This is the downloaded text data for the feed.
+   */
+  _data: null,
+
+  /**
+   * This is the object listening to the conversion, which is ultimately the
+   * docshell for the load.
+   */
+  _listener: null,
+
+  /**
+   * Records if the feed was sniffed
+   */
+  _sniffed: false,
+
+  /**
+   * See nsIStreamConverter.idl
+   */
+  canConvert: function FC_canConvert(sourceType, destinationType) {
+    // We only support one conversion.
+    return destinationType == TYPE_ANY && ((sourceType == TYPE_MAYBE_FEED) ||
+                                           (sourceType == TYPE_MAYBE_VIDEO) ||
+                                           (sourceType == TYPE_MAYBE_AUDIO));
+  },
+
+  /**
+   * See nsIStreamConverter.idl
+   */
+  convert: function FC_convert(sourceStream, sourceType, destinationType,
+                               context) {
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+
+  /**
+   * See nsIStreamConverter.idl
+   */
+  asyncConvertData: function FC_asyncConvertData(sourceType, destinationType,
+                                                 listener, context) {
+    this._listener = listener;
+  },
+
+  /**
+   * Whether or not the preview page is being forced.
+   */
+  _forcePreviewPage: false,
+
+  /**
+   * Release our references to various things once we're done using them.
+   */
+  _releaseHandles: function FC__releaseHandles() {
+    this._listener = null;
+    this._request = null;
+    this._processor = null;
+  },
+
+  /**
+   * See nsIFeedResultListener.idl
+   */
+  handleResult: function FC_handleResult(result) {
+    // Feeds come in various content types, which our feed sniffer coerces to
+    // the maybe.feed type. However, feeds are used as a transport for
+    // different data types, e.g. news/blogs (traditional feed), video/audio
+    // (podcasts) and photos (photocasts, photostreams). Each of these is
+    // different in that there's a different class of application suitable for
+    // handling feeds of that type, but without a content-type differentiation
+    // it is difficult for us to disambiguate.
+    //
+    // The other problem is that if the user specifies an auto-action handler
+    // for one feed application, the fact that the content type is shared means
+    // that all other applications will auto-load with that handler too,
+    // regardless of the content-type.
+    //
+    // This means that content-type alone is not enough to determine whether
+    // or not a feed should be auto-handled. This means that for feeds we need
+    // to always use this stream converter, even when an auto-action is
+    // specified, not the basic one provided by WebContentConverter. This
+    // converter needs to consume all of the data and parse it, and based on
+    // that determination make a judgement about type.
+    //
+    // Since there are no content types for this content, and I'm not going to
+    // invent any, the upshot is that while a user can set an auto-handler for
+    // generic feed content, the system will prevent them from setting an auto-
+    // handler for other stream types. In those cases, the user will always see
+    // the preview page and have to select a handler. We can guess and show
+    // a client handler, but will not be able to show web handlers for those
+    // types.
+    //
+    // If this is just a feed, not some kind of specialized application, then
+    // auto-handlers can be set and we should obey them.
+    try {
+      var feedService =
+          Cc["@mozilla.org/browser/feeds/result-service;1"].
+          getService(Ci.nsIFeedResultService);
+      if (!this._forcePreviewPage && result.doc) {
+        var feed = result.doc.QueryInterface(Ci.nsIFeed);
+        var handler = safeGetCharPref(getPrefActionForType(feed.type), "ask");
+
+        if (handler != "ask") {
+          if (handler == "reader")
+            handler = safeGetCharPref(getPrefReaderForType(feed.type), "bookmarks");
+          switch (handler) {
+            case "web":
+              var wccr =
+                  Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+                  getService(Ci.nsIWebContentConverterService);
+              if ((feed.type == Ci.nsIFeed.TYPE_FEED &&
+                   wccr.getAutoHandler(TYPE_MAYBE_FEED)) ||
+                  (feed.type == Ci.nsIFeed.TYPE_VIDEO &&
+                   wccr.getAutoHandler(TYPE_MAYBE_VIDEO_FEED)) ||
+                  (feed.type == Ci.nsIFeed.TYPE_AUDIO &&
+                   wccr.getAutoHandler(TYPE_MAYBE_AUDIO_FEED))) {
+                wccr.loadPreferredHandler(this._request);
+                return;
+              }
+              break;
+
+            default:
+              LOG("unexpected handler: " + handler);
+              // fall through -- let feed service handle error
+            case "bookmarks":
+            case "client":
+              try {
+                var title = feed.title ? feed.title.plainText() : "";
+                var desc = feed.subtitle ? feed.subtitle.plainText() : "";
+                feedService.addToClientReader(result.uri.spec, title, desc, feed.type);
+                return;
+              } catch(ex) { /* fallback to preview mode */ }
+          }
+        }
+      }
+
+      var ios =
+          Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+      var chromeChannel;
+
+      // show the feed page if it wasn't sniffed and we have a document,
+      // or we have a document, title, and link or id
+      if (result.doc && (!this._sniffed ||
+          (result.doc.title && (result.doc.link || result.doc.id)))) {
+
+        // If there was no automatic handler, or this was a podcast,
+        // photostream or some other kind of application, we must always
+        // show the preview page.
+
+        // Store the result in the result service so that the display
+        // page can access it.
+
+        feedService.addFeedResult(result);
+
+        // Now load the actual XUL document.
+        var chromeURI = ios.newURI(FEEDHANDLER_URI, null, null);
+        chromeChannel = ios.newChannelFromURI(chromeURI, null);
+        chromeChannel.originalURI = result.uri;
+      }
+      else
+        chromeChannel = ios.newChannelFromURI(result.uri, null);
+
+      chromeChannel.loadGroup = this._request.loadGroup;
+      chromeChannel.asyncOpen(this._listener, null);
+    }
+    finally {
+      this._releaseHandles();
+    }
+  },
+
+  /**
+   * See nsIStreamListener.idl
+   */
+  onDataAvailable: function FC_onDataAvailable(request, context, inputStream,
+                                               sourceOffset, count) {
+    if (this._processor)
+      this._processor.onDataAvailable(request, context, inputStream,
+                                      sourceOffset, count);
+  },
+
+  /**
+   * See nsIRequestObserver.idl
+   */
+  onStartRequest: function FC_onStartRequest(request, context) {
+    var channel = request.QueryInterface(Ci.nsIChannel);
+
+    // Check for a header that tells us there was no sniffing
+    // The value doesn't matter.
+    try {
+      var httpChannel = channel.QueryInterface(Ci.nsIHttpChannel);
+      var noSniff = httpChannel.getResponseHeader("X-Moz-Is-Feed");
+    }
+    catch (ex) {
+      this._sniffed = true;
+    }
+
+    this._request = request;
+
+    // Save and reset the forced state bit early, in case there's some kind of
+    // error.
+    var feedService =
+        Cc["@mozilla.org/browser/feeds/result-service;1"].
+        getService(Ci.nsIFeedResultService);
+    this._forcePreviewPage = feedService.forcePreviewPage;
+    feedService.forcePreviewPage = false;
+
+    // Parse feed data as it comes in
+    this._processor =
+        Cc["@mozilla.org/feed-processor;1"].
+        createInstance(Ci.nsIFeedProcessor);
+    this._processor.listener = this;
+    this._processor.parseAsync(null, channel.URI);
+
+    this._processor.onStartRequest(request, context);
+  },
+
+  /**
+   * See nsIRequestObserver.idl
+   */
+  onStopRequest: function FC_onStopReqeust(request, context, status) {
+    if (this._processor)
+      this._processor.onStopRequest(request, context, status);
+  },
+
+  /**
+   * See nsISupports.idl
+   */
+  QueryInterface: function FC_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFeedResultListener) ||
+        iid.equals(Ci.nsIStreamConverter) ||
+        iid.equals(Ci.nsIStreamListener) ||
+        iid.equals(Ci.nsIRequestObserver)||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+};
+
+var FeedConverterFactory = {
+  createInstance: function FS_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return new FeedConverter().QueryInterface(iid);
+  },
+
+  QueryInterface: function FS_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+};
+
+/**
+ * Keeps parsed FeedResults around for use elsewhere in the UI after the stream
+ * converter completes.
+ */
+var FeedResultService = {
+
+  /**
+   * A URI spec -> [nsIFeedResult] hash. We have to keep a list as the
+   * value in case the same URI is requested concurrently.
+   */
+  _results: { },
+
+  /**
+   * See nsIFeedResultService.idl
+   */
+  forcePreviewPage: false,
+
+  /**
+   * See nsIFeedResultService.idl
+   */
+  addToClientReader: function FRS_addToClientReader(spec, title, subtitle, feedType) {
+    var prefs =
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefBranch);
+
+    var handler = safeGetCharPref(getPrefActionForType(feedType), "bookmarks");
+    if (handler == "ask" || handler == "reader")
+      handler = safeGetCharPref(getPrefReaderForType(feedType), "bookmarks");
+
+    switch (handler) {
+    case "client":
+      var clientApp = prefs.getComplexValue(getPrefAppForType(feedType), Ci.nsILocalFile);
+
+      // For the benefit of applications that might know how to deal with more
+      // URLs than just feeds, send feed: URLs in the following format:
+      //
+      // http urls: replace scheme with feed, e.g.
+      // http://foo.com/index.rdf -> feed://foo.com/index.rdf
+      // other urls: prepend feed: scheme, e.g.
+      // https://foo.com/index.rdf -> feed:https://foo.com/index.rdf
+      var ios =
+          Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+      var feedURI = ios.newURI(spec, null, null);
+      if (feedURI.schemeIs("http")) {
+        feedURI.scheme = "feed";
+        spec = feedURI.spec;
+      }
+      else
+        spec = "feed:" + spec;
+
+      var ss =
+          Cc["@mozilla.org/browser/shell-service;1"].
+          getService(Ci.nsIShellService);
+      ss.openApplicationWithURI(clientApp, spec);
+      break;
+
+    default:
+      // "web" should have been handled elsewhere
+      LOG("unexpected handler: " + handler);
+      // fall through
+    case "bookmarks":
+      var wm =
+          Cc["@mozilla.org/appshell/window-mediator;1"].
+          getService(Ci.nsIWindowMediator);
+      var topWindow = wm.getMostRecentWindow("navigator:browser");
+      topWindow.PlacesCommandHook.addLiveBookmark(spec, title, subtitle);
+      break;
+    }
+  },
+
+  /**
+   * See nsIFeedResultService.idl
+   */
+  addFeedResult: function FRS_addFeedResult(feedResult) {
+    NS_ASSERT(feedResult.uri != null, "null URI!");
+    NS_ASSERT(feedResult.uri != null, "null feedResult!");
+    var spec = feedResult.uri.spec;
+    if(!this._results[spec])
+      this._results[spec] = [];
+    this._results[spec].push(feedResult);
+  },
+
+  /**
+   * See nsIFeedResultService.idl
+   */
+  getFeedResult: function RFS_getFeedResult(uri) {
+    NS_ASSERT(uri != null, "null URI!");
+    var resultList = this._results[uri.spec];
+    for (var i in resultList) {
+      if (resultList[i].uri == uri)
+        return resultList[i];
+    }
+    return null;
+  },
+
+  /**
+   * See nsIFeedResultService.idl
+   */
+  removeFeedResult: function FRS_removeFeedResult(uri) {
+    NS_ASSERT(uri != null, "null URI!");
+    var resultList = this._results[uri.spec];
+    if (!resultList)
+      return;
+    var deletions = 0;
+    for (var i = 0; i < resultList.length; ++i) {
+      if (resultList[i].uri == uri) {
+        delete resultList[i];
+        ++deletions;
+      }
+    }
+
+    // send the holes to the end
+    resultList.sort();
+    // and trim the list
+    resultList.splice(resultList.length - deletions, deletions);
+    if (resultList.length == 0)
+      delete this._results[uri.spec];
+  },
+
+  createInstance: function FRS_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return this.QueryInterface(iid);
+  },
+
+  QueryInterface: function FRS_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFeedResultService) ||
+        iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+};
+
+/**
+ * A protocol handler that attempts to deal with the variant forms of feed:
+ * URIs that are actually either http or https.
+ */
+function FeedProtocolHandler(scheme) {
+  this._scheme = scheme;
+  var ios =
+      Cc["@mozilla.org/network/io-service;1"].
+      getService(Ci.nsIIOService);
+  this._http = ios.getProtocolHandler("http");
+}
+FeedProtocolHandler.prototype = {
+  _scheme: "",
+  get scheme() {
+    return this._scheme;
+  },
+
+  get protocolFlags() {
+    return this._http.protocolFlags;
+  },
+
+  get defaultPort() {
+    return this._http.defaultPort;
+  },
+
+  allowPort: function FPH_allowPort(port, scheme) {
+    return this._http.allowPort(port, scheme);
+  },
+
+  newURI: function FPH_newURI(spec, originalCharset, baseURI) {
+    // See bug 408599 - feed URIs can be either standard URLs of the form
+    // feed://example.com, in which case the real protocol is http, or nested
+    // URIs of the form feed:realscheme:. When realscheme is either http or
+    // https, we deal with the way that creates a standard URL with the
+    // realscheme as the host by unmangling in newChannel; for others, we fail
+    // rather than let it wind up loading something like www.realscheme.com//foo
+
+    const feedSlashes = "feed://";
+    const feedHttpSlashes = "feed:http://";
+    const feedHttpsSlashes = "feed:https://";
+    const NS_ERROR_MALFORMED_URI = 0x804B000A;
+
+    if (spec.substr(0, feedSlashes.length) != feedSlashes &&
+        spec.substr(0, feedHttpSlashes.length) != feedHttpSlashes &&
+        spec.substr(0, feedHttpsSlashes.length) != feedHttpsSlashes)
+      throw NS_ERROR_MALFORMED_URI;
+
+    var uri =
+        Cc["@mozilla.org/network/standard-url;1"].
+        createInstance(Ci.nsIStandardURL);
+    uri.init(Ci.nsIStandardURL.URLTYPE_STANDARD, 80, spec, originalCharset,
+             baseURI);
+    return uri;
+  },
+
+  newChannel: function FPH_newChannel(aUri) {
+    var ios =
+        Cc["@mozilla.org/network/io-service;1"].
+        getService(Ci.nsIIOService);
+    // feed: URIs either start feed://, in which case the real scheme is http:
+    // or feed:http(s)://, (which by now we've changed to feed://realscheme//)
+    var feedSpec = aUri.spec;
+    const httpsChunk = "feed://https//";
+    const httpChunk = "feed://http//";
+    if (feedSpec.substr(0, httpsChunk.length) == httpsChunk)
+      feedSpec = "https://" + feedSpec.substr(httpsChunk.length);
+    else if (feedSpec.substr(0, httpChunk.length) == httpChunk)
+      feedSpec = "http://" + feedSpec.substr(httpChunk.length);
+    else
+      feedSpec = feedSpec.replace(/^feed/, "http");
+
+    var uri = ios.newURI(feedSpec, aUri.originCharset, null);
+    var channel =
+      ios.newChannelFromURI(uri, null).QueryInterface(Ci.nsIHttpChannel);
+    // Set this so we know this is supposed to be a feed
+    channel.setRequestHeader("X-Moz-Is-Feed", "1", false);
+    channel.originalURI = aUri;
+    return channel;
+  },
+
+  QueryInterface: function FPH_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIProtocolHandler) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+var Module = {
+  QueryInterface: function M_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIModule) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+
+  getClassObject: function M_getClassObject(cm, cid, iid) {
+    if (!iid.equals(Ci.nsIFactory))
+      throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+
+    if (cid.equals(FS_CLASSID))
+      return FeedResultService;
+    if (cid.equals(FPH_CLASSID))
+      return new GenericComponentFactory(FeedProtocolHandler, "feed");
+    if (cid.equals(PCPH_CLASSID))
+      return new GenericComponentFactory(FeedProtocolHandler, "pcast");
+    if (cid.equals(FC_CLASSID))
+      return new GenericComponentFactory(FeedConverter);
+
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+
+  registerSelf: function M_registerSelf(cm, file, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+
+    cr.registerFactoryLocation(FS_CLASSID, FS_CLASSNAME, FS_CONTRACTID,
+                               file, location, type);
+    cr.registerFactoryLocation(FPH_CLASSID, FPH_CLASSNAME, FPH_CONTRACTID,
+                               file, location, type);
+    cr.registerFactoryLocation(PCPH_CLASSID, PCPH_CLASSNAME, PCPH_CONTRACTID,
+                               file, location, type);
+
+    // The feed converter is always attached, since parsing must be done to
+    // determine whether or not auto-handling can occur.
+    const converterPrefix = "@mozilla.org/streamconv;1?from=";
+    var converterContractID =
+        converterPrefix + TYPE_MAYBE_FEED + "&to=" + TYPE_ANY;
+    cr.registerFactoryLocation(FC_CLASSID, FC_CLASSNAME, converterContractID,
+                               file, location, type);
+
+    converterContractID =
+        converterPrefix + TYPE_MAYBE_VIDEO_FEED + "&to=" + TYPE_ANY;
+    cr.registerFactoryLocation(FC_CLASSID, FC_CLASSNAME, converterContractID,
+                               file, location, type);
+
+    converterContractID =
+        converterPrefix + TYPE_MAYBE_AUDIO_FEED + "&to=" + TYPE_ANY;
+    cr.registerFactoryLocation(FC_CLASSID, FC_CLASSNAME, converterContractID,
+                               file, location, type);
+    },
+
+  unregisterSelf: function M_unregisterSelf(cm, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+    cr.unregisterFactoryLocation(FPH_CLASSID, location);
+    cr.unregisterFactoryLocation(PCPH_CLASSID, location);
+  },
+
+  canUnload: function M_canUnload(cm) {
+    return true;
+  }
+};
+
+function NSGetModule(cm, file) {
+  return Module;
+}
+
+#include ../../../../toolkit/content/debug.js
+#include GenericFactory.js
Index: mozilla/toolkit/components/feeds/src/nsAboutFeeds.cpp
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/src/nsAboutFeeds.cpp
@@ -0,0 +1,100 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:set ts=4 sw=4 sts=4 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is The about:feeds Page.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsAboutFeeds.h"
+#include "nsNetUtil.h"
+#include "nsIScriptSecurityManager.h"
+
+NS_IMPL_ISUPPORTS1(nsAboutFeeds, nsIAboutModule)
+
+#define FEEDS_PAGE_URI "chrome://feeds/content/subscribe.xhtml"
+
+NS_IMETHODIMP
+nsAboutFeeds::NewChannel(nsIURI* uri, nsIChannel** result)
+{
+
+  nsresult rv;
+  nsCOMPtr<nsIIOService> ios(do_GetIOService(&rv));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsIChannel> channel;
+  rv = ios->NewChannel(NS_LITERAL_CSTRING(FEEDS_PAGE_URI),
+                       nsnull, nsnull, getter_AddRefs(channel));
+  if (NS_FAILED(rv))
+    return rv;
+
+  channel->SetOriginalURI(uri);
+
+  nsCOMPtr<nsIScriptSecurityManager> ssm =
+    do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsIPrincipal> principal;
+  rv = ssm->GetCodebasePrincipal(uri, getter_AddRefs(principal));
+  if (NS_FAILED(rv))
+    return rv;
+
+  rv = channel->SetOwner(principal);
+  if (NS_FAILED(rv))
+    return rv;
+
+  NS_ADDREF(*result = channel);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsAboutFeeds::GetURIFlags(nsIURI* uri, PRUint32* uriFlags)
+{
+  // Feeds page needs script, and is untrusted-content-safe
+  *uriFlags = URI_SAFE_FOR_UNTRUSTED_CONTENT | ALLOW_SCRIPT;
+  return NS_OK;
+}
+
+NS_METHOD
+nsAboutFeeds::Create(nsISupports* outer, REFNSIID iid, void** result)
+{
+  nsAboutFeeds* aboutFeeds = new nsAboutFeeds();
+  if (aboutFeeds == nsnull)
+    return NS_ERROR_OUT_OF_MEMORY;
+  NS_ADDREF(aboutFeeds);
+  nsresult rv = aboutFeeds->QueryInterface(iid, result);
+  NS_RELEASE(aboutFeeds);
+  return rv;
+}
Index: mozilla/toolkit/components/feeds/public/nsIFeedResultService.idl
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/public/nsIFeedResultService.idl
@@ -0,0 +1,100 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Result Service.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Robert Sayre <sayrer@gmail.com>
+ *   Will Guaraldi <will.guaraldi@pculture.org>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+interface nsIURI;
+interface nsIRequest;
+interface nsIFeedResult;
+
+/**
+ * nsIFeedResultService provides a globally-accessible object for retrieving
+ * the results of feed processing.
+ */
+[scriptable, uuid(950a829e-c20e-4dc3-b447-f8b753ae54da)]
+interface nsIFeedResultService : nsISupports
+{
+  /**
+   * When set to true, forces the preview page to be displayed, regardless
+   * of the user's preferences.
+   */
+  attribute boolean forcePreviewPage;
+
+  /**
+   * Adds a URI to the user's specified external feed handler, or live
+   * bookmarks.
+   * @param   uri
+   *          The uri of the feed to add.
+   * @param   title
+   *          The title of the feed to add.
+   * @param   subtitle
+   *          The subtitle of the feed to add.
+   * @param   feedType
+   *          The nsIFeed type of the feed.  See nsIFeed.idl
+   */
+  void addToClientReader(in AUTF8String uri,
+                         in AString title,
+                         in AString subtitle,
+                         in unsigned long feedType);
+
+  /**
+   * Registers a Feed Result object with a globally accessible service
+   * so that it can be accessed by a singleton method outside the usual
+   * flow of control in document loading.
+   *
+   * @param   feedResult
+   *          An object implementing nsIFeedResult representing the feed.
+   */
+  void addFeedResult(in nsIFeedResult feedResult);
+
+  /**
+   * Gets a Feed Handler object registered using addFeedResult.
+   *
+   * @param   uri
+   *          The URI of the feed a handler is being requested for
+   */
+  nsIFeedResult getFeedResult(in nsIURI uri);
+
+  /**
+   * Unregisters a Feed Handler object registered using addFeedResult.
+   * @param   uri
+   *          The feed URI the handler was registered under. This must be
+   *          the same *instance* the feed was registered under.
+   */
+  void removeFeedResult(in nsIURI uri);
+};
Index: mozilla/toolkit/components/feeds/public/nsIFeedWriter.idl
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/public/nsIFeedWriter.idl
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Writer.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Asaf Romano <mano@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIDOMWindow;
+
+/**
+ * Instances of this component write UI into the display page. This component
+ * is trusted so can access preferences etc, but page content isn't and so
+ * cannot.
+ */
+[scriptable, uuid(67003393-018c-4e96-af10-c6c51a049fad)]
+interface nsIFeedWriter : nsISupports
+{
+  /**
+   * Initializes the feed writer and loads the feed subscription UI.
+   * @param  aWindow
+   *         The DOMWindow of the preview page.
+   *         window.location.href == the URI of the feed.
+   */
+  void init(in nsIDOMWindow aWindow);
+
+  /**
+   * Writes the feed content, assumes that the feed writer is initialized.
+   */
+  void writeContent();
+
+  /**
+   * Uninitialize the feed writer.
+   */
+  void close();
+};
Index: mozilla/toolkit/components/feeds/public/Makefile.in
===================================================================
--- mozilla.orig/toolkit/components/feeds/public/Makefile.in
+++ mozilla/toolkit/components/feeds/public/Makefile.in
@@ -50,11 +50,13 @@ XPIDLSRCS = nsIFeedProcessor.idl \
             nsIFeed.idl \
             nsIFeedContainer.idl \
             nsIFeedEntry.idl \
             nsIFeedTextConstruct.idl \
             nsIScriptableUnescapeHTML.idl \
             nsIFeedElementBase.idl \
             nsIFeedGenerator.idl \
             nsIFeedPerson.idl \
+	    nsIFeedResultService.idl \
+	    nsIFeedWriter.idl \
             $(NULL)
 
 include $(topsrcdir)/config/rules.mk
Index: mozilla/toolkit/components/feeds/content/subscribe.css
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/content/subscribe.css
@@ -0,0 +1,155 @@
+
+*[hidden] {
+  display: none;
+}
+
+html {
+  background: -moz-Dialog;
+  font: 3mm tahoma,arial,helvetica,sans-serif;
+}
+
+#feedBody {
+  border: 1px solid THreeDShadow;
+  padding: 3em;
+  -moz-padding-start: 30px;
+  margin: 2em auto;
+  background: -moz-Field;
+}
+
+#feedHeaderContainer {
+  border: 1px solid ThreeDShadow;
+  -moz-border-radius: 10px;
+  margin: -4em auto 0 auto;
+  background-color: InfoBackground;
+}
+
+#feedHeader {
+  margin-top: 4.9em;
+  margin-bottom: 1em;
+  -moz-margin-start: 1.4em;
+  -moz-margin-end: 1em;
+  -moz-padding-start: 2.9em;
+  font-size: 110%;
+  background: url("chrome://browser/skin/feeds/feedIcon.png") 0% 10% no-repeat InfoBackground;
+  color: InfoText;
+}
+
+#feedHeader[dir="rtl"] {
+  background-position: 100% 10%;
+}
+
+#feedIntroText {
+  display: none;
+}
+
+#feedHeader[firstrun="true"] #feedIntroText {
+  padding-top: 0.1em;
+  -moz-padding-start: 0.6em;
+  display: block;
+}
+
+#feedHeader[firstrun="true"] > #feedSubscribeLine {
+  -moz-padding-start: 1.8em;
+}
+
+#feedSubscribeLine {
+  padding-top: 0.2em;
+}
+
+#alwaysUse {
+  padding: 5px;
+}
+
+
+#handlersMenuList > menupopup > menuitem {
+  -moz-padding-start: 23px;
+}
+
+#handlersMenuList > menupopup > menuitem.menuitem-iconic {
+  -moz-padding-start: 2px;
+}
+
+#handlersMenuList > menupopup > .menuitem-iconic  > .menu-iconic-left {
+  display: -moz-box;
+  min-width: 16px;
+  -moz-padding-end: 2px;
+}
+
+#feedHeader[dir="rtl"] #handlersMenuList > menupopup {
+  direction: rtl;
+}
+
+/* Don't print subscription UI */
+@media print {
+  #feedHeaderContainer {
+    display: none;
+  }
+}
+
+body {
+  margin: 0;
+  padding: 0 3em;
+  color: -moz-fieldText;
+  font: message-box;
+}
+
+h1 {
+  font-size: 160%;
+  border-bottom: 2px solid ThreeDLightShadow;
+  margin: 0 0 .2em 0;
+}
+
+h2 {
+  color: ThreeDDarkShadow;
+  font-size: 110%;
+  font-weight: normal;
+  margin: 0 0 .6em 0;
+}
+
+#feedTitleLink {
+  float: right;
+  -moz-margin-start: .6em;
+  -moz-margin-end: 0;
+  margin-top: 0;
+  margin-bottom: 0;
+}
+
+a[href] img {
+  border: none;
+}
+
+#feedTitleContainer {
+  -moz-margin-start: 0;
+  -moz-margin-end: .6em;
+  margin-top: 0;
+  margin-bottom: 0;
+}
+
+#feedTitleImage {
+  -moz-margin-start: .6em;
+  -moz-margin-end: 0;
+  margin-top: 0;
+  margin-bottom: 0;
+  max-width: 300px;
+  max-height: 150px;
+}
+
+.feedEntryContent {
+  font-size: 110%;
+}
+
+.link {
+  color: #0000FF;
+  text-decoration: underline;
+  cursor: pointer;
+}
+
+.link:hover:active {
+  color: #FF0000;
+}
+
+.lastUpdated {
+  font-size: 85%;
+  font-weight: normal;
+}
+
Index: mozilla/toolkit/components/feeds/content/subscribe.js
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/content/subscribe.js
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Subscribe Handler.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Asaf Romano <mano@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var SubscribeHandler = {
+  /**
+   * The nsIFeedWriter object that produces the UI
+   */
+  _feedWriter: null,
+
+  init: function SH_init() {
+    this._feedWriter = new BrowserFeedWriter();
+    this._feedWriter.init(window);
+  },
+
+  writeContent: function SH_writeContent() {
+    this._feedWriter.writeContent();
+  },
+
+  uninit: function SH_uninit() {
+    this._feedWriter.close();
+  },
+
+  subscribe: function FH_subscribe() {
+    this._feedWriter.subscribe();
+  }
+};
Index: mozilla/toolkit/components/feeds/content/subscribe.xhtml
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/content/subscribe.xhtml
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!DOCTYPE html [
+  <!ENTITY % htmlDTD
+    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+    "DTD/xhtml1-strict.dtd">
+  %htmlDTD;
+  <!ENTITY % globalDTD
+    SYSTEM "chrome://global/locale/global.dtd">
+  %globalDTD;
+  <!ENTITY % feedDTD
+    SYSTEM "chrome://feeds/locale/subscribe.dtd">
+  %feedDTD;
+]>
+
+<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
+
+<html id="feedHandler"
+      xmlns="http://www.w3.org/1999/xhtml"
+      xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <head>
+    <title>&feedPage.title;</title>
+    <link rel="stylesheet"
+            href="chrome://feeds/content/subscribe.css"
+          type="text/css"
+          media="all"/>
+    <script type="application/x-javascript"
+            src="chrome://feeds/content/subscribe.js"/>
+  </head>
+  <body onload="SubscribeHandler.writeContent();" onunload="SubscribeHandler.uninit();">
+<!--Commenting header from the page to make impossible to subscribe. For subscription we have the button on toolbar -->
+<!--
+    <div id="feedHeaderContainer">
+      <div id="feedHeader" dir="&locale.dir;">
+        <div id="feedIntroText"
+          ><xul:description id="feedSubscriptionInfo1" /><xul:description id="feedSubscriptionInfo2"
+        /></div>
+-->
+<!-- XXXmano this can't have any whitespace in it.  Otherwise you would see
+     how much XUL-in-XHTML sucks, see bug 348830 -->
+<!--
+        <div id="feedSubscribeLine"
+          ><xul:vbox
+            ><xul:hbox align="center"
+              ><xul:description id="subscribeUsingDescription"
+              /><xul:menulist id="handlersMenuList" aria-labelledby="subscribeUsingDescription"
+                ><xul:menupopup menugenerated="true" id="handlersMenuPopup"
+                  ><xul:menuitem id="liveBookmarksMenuItem" label="&feedLiveBookmarks;" class="menuitem-iconic" image="chrome://browser/skin/page-livemarks.png" selected="true"
+                  /><xul:menuseparator
+                /></xul:menupopup
+              ></xul:menulist
+            ></xul:hbox
+            ><xul:hbox
+              ><xul:checkbox id="alwaysUse" checked="false"
+            /></xul:hbox
+            ><xul:hbox align="center"
+              ><xul:spacer flex="1"
+              /><xul:button label="&feedSubscribeNow;" id="subscribeButton"
+            /></xul:hbox
+          ></xul:vbox
+        ></div
+      ></div>
+    </div>
+-->
+    <script type="application/x-javascript">
+      SubscribeHandler.init();
+    </script>
+
+    <div id="feedBody">
+      <div id="feedTitle">
+        <a id="feedTitleLink">
+          <img id="feedTitleImage"/>
+        </a>
+        <div id="feedTitleContainer">
+          <h1 id="feedTitleText"/>
+          <h2 id="feedSubtitleText"/>
+        </div>
+      </div>
+      <div id="feedContent"/>
+    </div>
+  </body>
+</html>
Index: mozilla/toolkit/components/feeds/jar.mn
===================================================================
--- /dev/null
+++ mozilla/toolkit/components/feeds/jar.mn
@@ -0,0 +1,6 @@
+toolkit.jar:
+%  content feeds %content/feeds/ xpcnativewrappers=yes contentaccessible=yes
+*+ content/feeds/subscribe.xhtml        (content/subscribe.xhtml)
+*+ content/feeds/subscribe.js           (content/subscribe.js)
+*+ content/feeds/subscribe.css          (content/subscribe.css)
+
Index: mozilla/toolkit/components/feeds/src/Makefile.in
===================================================================
--- mozilla.orig/toolkit/components/feeds/src/Makefile.in
+++ mozilla/toolkit/components/feeds/src/Makefile.in
@@ -52,16 +52,38 @@ REQUIRES	= \
 		xpcom \
 		necko \
 		string \
 		widget \
 		dom \
 		htmlparser \
 		content \
 		layout \
+		caps \
+		js \
+		xpconnect \
+		mimetype \
 		$(NULL)
 
-CPPSRCS		= nsScriptableUnescapeHTML.cpp \
+CPPSRCS		= \
+		nsScriptableUnescapeHTML.cpp \
+		nsAboutFeeds.cpp \
+		nsFeedSniffer.cpp \
 		$(NULL)
 
+LIBS            = \
+               $(XPCOM_LIBS) \
+               $(NSPR_LIBS) \
+               $(MOZ_JS_LIBS) \
+               $(MOZ_UNICHARUTIL_LIBS) \
+               $(NULL)
+
+LOCAL_INCLUDES = -I$(srcdir)/../../../../toolkit/components/build/
+
 EXTRA_COMPONENTS = FeedProcessor.js
 
+EXTRA_PP_COMPONENTS = \
+               FeedConverter.js \
+               FeedWriter.js \
+               WebContentConverter.js \
+               $(NULL)
+
 include $(topsrcdir)/config/rules.mk
