--- mozilla/widget/public/nsIWidget.h.orig	2007-04-06 03:11:41.000000000 +0300
+++ mozilla/widget/public/nsIWidget.h	2007-12-13 08:06:21.000000000 +0200
@@ -705,20 +705,27 @@ class nsIWidget : public nsISupports {
      * Update the alpha channel for some pixels of the top-level window
      * that contains this widget.
      * The window must have been made translucent using SetWindowTranslucency.
      * Pixel RGB color values are already premultiplied with alpha channel values.
      * @param aRect the rect to update
      * @param aAlphas the alpha values, in w x h array, row-major order,
      * in units of 1/255. nsBlender::GetAlphas is a good way to compute this array.
      */
     NS_IMETHOD UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas) = 0;
 
+    /**
+     * Are we in gtkmozembed transparency context or not. If TRUE the
+     * background of body can be transparent.
+     * @param aContext TRUE if transparency context has been set on.
+     */
+    NS_IMETHOD GetMozEmbedTransparencyContext(PRBool& aContext) = 0;
+
     /** 
      * Hide window chrome (borders, buttons) for this widget.
      *
      */
     NS_IMETHOD HideWindowChrome(PRBool aShouldHide) = 0;
 
     /**
      * Put the toplevel window into or out of fullscreen mode.
      *
      */
--- mozilla/widget/src/xpwidgets/nsBaseWidget.cpp.orig	2007-04-06 03:11:42.000000000 +0300
+++ mozilla/widget/src/xpwidgets/nsBaseWidget.cpp	2007-12-13 08:03:57.000000000 +0200
@@ -525,20 +525,25 @@ NS_IMETHODIMP nsBaseWidget::SetWindowTra
 NS_IMETHODIMP nsBaseWidget::GetWindowTranslucency(PRBool& aTranslucent) {
   aTranslucent = PR_FALSE;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsBaseWidget::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas) {
   NS_ASSERTION(PR_FALSE, "Window is not translucent");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+NS_IMETHODIMP nsBaseWidget::GetMozEmbedTransparencyContext(PRBool& aContext) {
+  aContext = PR_FALSE;
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 //-------------------------------------------------------------------------
 //
 // Hide window borders/decorations for this widget
 //
 //-------------------------------------------------------------------------
 NS_IMETHODIMP nsBaseWidget::HideWindowChrome(PRBool aShouldHide)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
--- mozilla/widget/src/xpwidgets/nsBaseWidget.h.orig	2007-04-06 03:11:42.000000000 +0300
+++ mozilla/widget/src/xpwidgets/nsBaseWidget.h	2007-12-12 09:30:04.000000000 +0200
@@ -96,20 +96,21 @@ public:
   NS_IMETHOD              SetBackgroundColor(const nscolor &aColor);
   virtual nsCursor        GetCursor();
   NS_IMETHOD              SetCursor(nsCursor aCursor);
   NS_IMETHOD              SetCursor(imgIContainer* aCursor,
                                     PRUint32 aHotspotX, PRUint32 aHotspotY);
   NS_IMETHOD              GetWindowType(nsWindowType& aWindowType);
   NS_IMETHOD              SetWindowType(nsWindowType aWindowType);
   NS_IMETHOD              SetWindowTranslucency(PRBool aTranslucent);
   NS_IMETHOD              GetWindowTranslucency(PRBool& aTranslucent);
   NS_IMETHOD              UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
+  NS_IMETHOD              GetMozEmbedTransparencyContext(PRBool& aContext);
   NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
   NS_IMETHOD              MakeFullScreen(PRBool aFullScreen);
   nsresult                MakeFullScreenInternal(PRBool aFullScreen);
   virtual nsIRenderingContext* GetRenderingContext();
   virtual nsIDeviceContext* GetDeviceContext();
   virtual nsIToolkit*     GetToolkit();  
 #ifdef MOZ_CAIRO_GFX
   virtual gfxASurface*    GetThebesSurface();
 #endif
   NS_IMETHOD              SetModal(PRBool aModal); 
--- mozilla/widget/src/gtk2/nsWindow.cpp.orig	2007-12-13 12:24:11.000000000 +0200
+++ mozilla/widget/src/gtk2/nsWindow.cpp	2007-12-13 12:34:39.000000000 +0200
@@ -135,20 +135,22 @@ static GdkWindow *get_inner_gdk_window (
                                         gint x, gint y,
                                         gint *retx, gint *rety);
 
 static inline PRBool is_context_menu_key(const nsKeyEvent& inKeyEvent);
 static void   key_event_to_context_menu_event(const nsKeyEvent* inKeyEvent,
                                               nsMouseEvent* outCMEvent);
 
 static int    is_parent_ungrab_enter(GdkEventCrossing *aEvent);
 static int    is_parent_grab_leave(GdkEventCrossing *aEvent);
 
+static nsWindow *get_window_for_drawingarea(MozDrawingarea* drawingarea);
+
 /* callbacks from widgets */
 static gboolean expose_event_cb           (GtkWidget *widget,
                                            GdkEventExpose *event);
 static gboolean configure_event_cb        (GtkWidget *widget,
                                            GdkEventConfigure *event);
 static void     size_allocate_cb          (GtkWidget *widget,
                                            GtkAllocation *allocation);
 static gboolean delete_event_cb           (GtkWidget *widget,
                                            GdkEventAny *event);
 static gboolean enter_notify_event_cb     (GtkWidget *widget,
@@ -351,20 +353,23 @@ nsWindow::nsWindow()
 
 #ifdef ACCESSIBILITY
     mRootAccessible  = nsnull;
 #endif
 
     mIsTranslucent = PR_FALSE;
     mTransparencyBitmap = nsnull;
 
     mTransparencyBitmapWidth  = 0;
     mTransparencyBitmapHeight = 0;
+
+    mMozEmbedTransparencyContextChecked = PR_FALSE;
+    mMozEmbedTransparencyContext = PR_FALSE;
 }
 
 nsWindow::~nsWindow()
 {
     LOG(("nsWindow::~nsWindow() [%p]\n", (void *)this));
     if (mLastDragMotionWindow == this) {
         mLastDragMotionWindow = NULL;
     }
 
     delete[] mTransparencyBitmap;
@@ -3354,32 +3359,49 @@ nsWindow::EnsureGrabs(void)
 {
     if (mRetryPointerGrab)
         GrabPointer();
     if (mRetryKeyboardGrab)
         GrabKeyboard();
 }
 
 NS_IMETHODIMP
 nsWindow::SetWindowTranslucency(PRBool aTranslucent)
 {
-    if (!mShell) {
-        // Pass the request to the toplevel window
-        GtkWidget *topWidget = nsnull;
-        GetToplevelWidget(&topWidget);
-        if (!topWidget)
-            return NS_ERROR_FAILURE;
+    DoMozEmbedTransparencyContextCheck();
 
-        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
-        if (!topWindow)
-            return NS_ERROR_FAILURE;
+    // If we are not in mozembed transparency context use normal behavior
+    if (!mMozEmbedTransparencyContext) {
+        if (!mShell) {
+            // Pass the request to the toplevel window
+            GtkWidget *topWidget = nsnull;
+            GetToplevelWidget(&topWidget);
+            if (!topWidget)
+                return NS_ERROR_FAILURE;
+    
+            nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+            if (!topWindow)
+                return NS_ERROR_FAILURE;
+    
+            return topWindow->SetWindowTranslucency(aTranslucent);
+        }
+    } else {
+        if (!mContainer) {
+            // Pass request to nsWindow having mContainer
+            if (!mDrawingarea)
+                return NS_ERROR_FAILURE;
+
+            nsWindow *window = get_window_for_drawingarea(mDrawingarea);
+            if (!window)
+                return NS_ERROR_FAILURE;
 
-        return topWindow->SetWindowTranslucency(aTranslucent);
+            return window->SetWindowTranslucency(aTranslucent);
+        }
     }
 
     if (mIsTranslucent == aTranslucent)
         return NS_OK;
 
     if (!aTranslucent) {
         if (mTransparencyBitmap) {
             delete[] mTransparencyBitmap;
             mTransparencyBitmap = nsnull;
             mTransparencyBitmapWidth = 0;
@@ -3389,36 +3411,56 @@ nsWindow::SetWindowTranslucency(PRBool a
     } // else the new default alpha values are "all 1", so we don't
     // need to change anything yet
 
     mIsTranslucent = aTranslucent;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::GetWindowTranslucency(PRBool& aTranslucent)
 {
-    if (!mShell) {
-        // Pass the request to the toplevel window
-        GtkWidget *topWidget = nsnull;
-        GetToplevelWidget(&topWidget);
-        if (!topWidget) {
-            aTranslucent = PR_FALSE;
-            return NS_ERROR_FAILURE;
-        }
+    DoMozEmbedTransparencyContextCheck();
 
-        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
-        if (!topWindow) {
-            aTranslucent = PR_FALSE;
-            return NS_ERROR_FAILURE;
+    if (!mMozEmbedTransparencyContext) {
+        if (!mShell) {
+            // Pass the request to the toplevel window
+            GtkWidget *topWidget = nsnull;
+            GetToplevelWidget(&topWidget);
+            if (!topWidget) {
+                aTranslucent = PR_FALSE;
+                return NS_ERROR_FAILURE;
+            }
+    
+            nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+            if (!topWindow) {
+                aTranslucent = PR_FALSE;
+                return NS_ERROR_FAILURE;
+            }
+    
+            return topWindow->GetWindowTranslucency(aTranslucent);
         }
+    } else {
+        if (!mContainer) {
+            // Pass request to nsWindow having mContainer
+            if (!mDrawingarea) {
+                aTranslucent = PR_FALSE;
+                return NS_ERROR_FAILURE;
+            }
+
+            nsWindow *window = get_window_for_drawingarea(mDrawingarea);
+            if (!window) {
+                aTranslucent = PR_FALSE;
+                return NS_ERROR_FAILURE;
+            }
 
-        return topWindow->GetWindowTranslucency(aTranslucent);
+            return window->GetWindowTranslucency(aTranslucent);
+        }
     }
 
     aTranslucent = mIsTranslucent;
     return NS_OK;
 }
 
 void
 nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
 {
     if (!mTransparencyBitmap)
@@ -3506,47 +3548,83 @@ void UpdateMaskBits(gchar* aMaskBits, PR
             // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
             maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
         }
         aAlphas += aStride;
     }
 }
 
 void
 nsWindow::ApplyTransparencyBitmap()
 {
-    gtk_widget_reset_shapes(mShell);
-    GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(mShell->window,
-            mTransparencyBitmap,
-            mTransparencyBitmapWidth, mTransparencyBitmapHeight);
-    if (!maskBitmap)
-        return;
+    GtkWidget* widget = nsnull;
 
-    gtk_widget_shape_combine_mask(mShell, maskBitmap, 0, 0);
-    gdk_bitmap_unref(maskBitmap);
+    DoMozEmbedTransparencyContextCheck();
+
+    // If we are not in mozembed transparency context use normal behavior
+    if (!mMozEmbedTransparencyContext)
+        widget = mShell;
+    else {
+        // In mozembed transparency context get widget from mContainer
+        if (!mContainer)
+            return;
+ 
+        widget = gtk_widget_get_parent(GTK_WIDGET(mContainer));
+    }
+
+    if (widget) {
+        gtk_widget_reset_shapes(widget);
+        GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(
+                widget->window,
+                mTransparencyBitmap,
+                mTransparencyBitmapWidth,
+                mTransparencyBitmapHeight);
+        if (!maskBitmap)
+            return;
+
+        gtk_widget_shape_combine_mask(widget, maskBitmap, 0, 0);
+        gdk_bitmap_unref(maskBitmap);
+    }
 }
 
 nsresult
 nsWindow::UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                PRUint8* aAlphas, PRInt32 aStride)
 {
-    if (!mShell) {
-        // Pass the request to the toplevel window
-        GtkWidget *topWidget = nsnull;
-        GetToplevelWidget(&topWidget);
-        if (!topWidget)
-            return NS_ERROR_FAILURE;
+    DoMozEmbedTransparencyContextCheck();
 
-        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
-        if (!topWindow)
-            return NS_ERROR_FAILURE;
+    // If we are not in mozembed transparency context use normal behavior
+    if (!mMozEmbedTransparencyContext) {
+        if (!mShell) {
+            // Pass the request to the toplevel window
+            GtkWidget *topWidget = nsnull;
+            GetToplevelWidget(&topWidget);
+            if (!topWidget)
+                return NS_ERROR_FAILURE;
+  
+            nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+            if (!topWindow)
+                return NS_ERROR_FAILURE;
+  
+            return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
+        }
+    } else {
+        if (!mContainer) {
+            // Pass request to nsWindow having mContainer
+            if (!mDrawingarea)
+                return NS_ERROR_FAILURE;
+
+            nsWindow *window = get_window_for_drawingarea(mDrawingarea);
+            if (!window)
+                return NS_ERROR_FAILURE;
 
-        return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
+            return window->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
+        }
     }
 
     NS_ASSERTION(mIsTranslucent, "Window is not transparent");
 
     if (mTransparencyBitmap == nsnull) {
         PRInt32 size = ((mBounds.width+7)/8)*mBounds.height;
         mTransparencyBitmap = new gchar[size];
         if (mTransparencyBitmap == nsnull)
             return NS_ERROR_FAILURE;
         memset(mTransparencyBitmap, 255, size);
@@ -3572,20 +3650,64 @@ nsWindow::UpdateTranslucentWindowAlphaIn
     }
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas)
 {
     return UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aRect.width);
 }
 
+NS_IMETHODIMP
+nsWindow::GetMozEmbedTransparencyContext(PRBool& aContext)
+{
+    if (!mContainer) {
+        // Pass request to nsWindow having mContainer
+        if (!mDrawingarea) {
+            aContext = PR_FALSE;
+            return NS_ERROR_FAILURE;
+        }
+
+        nsWindow *window = get_window_for_drawingarea(mDrawingarea);
+        if (!window) {
+            aContext = PR_FALSE;
+            return NS_ERROR_FAILURE;
+        }
+
+        return window->GetMozEmbedTransparencyContext(aContext);
+    }
+
+    GtkWidget *widget = gtk_widget_get_parent(GTK_WIDGET(mContainer));
+    if (!widget) {
+        aContext = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    gboolean val = PR_FALSE;
+    g_object_get(G_OBJECT(widget),
+                 "mozembed_transparency_context", &val,
+                 NULL);
+ 
+    aContext = val;
+    return NS_OK;
+}
+
+void nsWindow::DoMozEmbedTransparencyContextCheck()
+{
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+    if (!mMozEmbedTransparencyContextChecked) {
+        GetMozEmbedTransparencyContext(mMozEmbedTransparencyContext);
+        mMozEmbedTransparencyContextChecked = PR_TRUE;
+    }
+ #endif
+}
+
 void
 nsWindow::GrabPointer(void)
 {
     LOG(("GrabPointer %d\n", mRetryPointerGrab));
 
     mRetryPointerGrab = PR_FALSE;
 
     // If the window isn't visible, just set the flag to retry the
     // grab.  When this window becomes visible, the grab will be
     // retried.
@@ -4292,20 +4414,35 @@ get_gtk_cursor(nsCursor aCursor)
 
         gdk_bitmap_unref(mask);
         gdk_bitmap_unref(cursor);
     }
 
     gCursorCache[aCursor] = gdkcursor;
 
     return gdkcursor;
 }
 
+/*static*/
+nsWindow *get_window_for_drawingarea(MozDrawingarea* drawingarea)
+{
+    gpointer user_data = nsnull;
+    gdk_window_get_user_data(drawingarea->inner_window, &user_data);
+    if (!user_data)
+        return nsnull;
+
+    MozContainer *mozContainer = MOZ_CONTAINER(user_data);
+    if (!mozContainer)
+        return nsnull;
+
+    return get_window_for_gtk_widget(GTK_WIDGET(mozContainer));
+}
+
 // gtk callbacks
 
 /* static */
 gboolean
 expose_event_cb(GtkWidget *widget, GdkEventExpose *event)
 {
     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
     if (!window)
         return FALSE;
 
--- mozilla/widget/src/gtk2/nsWindow.h.orig	2007-12-13 12:24:11.000000000 +0200
+++ mozilla/widget/src/gtk2/nsWindow.h	2007-12-13 12:35:57.000000000 +0200
@@ -342,36 +342,39 @@ public:
 #endif
 
    void                ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight);
    void                ApplyTransparencyBitmap();
    NS_IMETHOD          SetWindowTranslucency(PRBool aTransparent);
    NS_IMETHOD          GetWindowTranslucency(PRBool& aTransparent);
    nsresult            UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                             PRUint8* aAlphas, PRInt32 aStride);
    NS_IMETHOD          UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
 
+   NS_IMETHOD          GetMozEmbedTransparencyContext(PRBool& aContext);
+
 #ifdef MOZ_CAIRO_GFX
     gfxASurface       *GetThebesSurface();
 #endif
 
 #ifdef ACCESSIBILITY
     static PRBool      sAccessibilityEnabled;
 #endif
     guint              mThemeTimeoutSource;
 
 private:
     void               GetToplevelWidget(GtkWidget **aWidget);
     void               GetContainerWindow(nsWindow  **aWindow);
     void               SetUrgencyHint(GtkWidget *top_window, PRBool state);
     void              *SetupPluginPort(void);
     nsresult           SetWindowIconList(const nsCStringArray &aIconList);
     void               SetDefaultIcon(void);
+    void               DoMozEmbedTransparencyContextCheck();
 
     GtkWidget          *mShell;
     MozContainer       *mContainer;
     MozDrawingarea     *mDrawingarea;
 
     GtkWindowGroup     *mWindowGroup;
 
     PRUint32            mContainerGotFocus : 1,
                         mContainerLostFocus : 1,
                         mContainerBlockFocus : 1,
@@ -402,20 +405,23 @@ private:
     // The cursor cache
     static GdkCursor   *gsGtkCursorCache[eCursorCount];
 
     // Transparency
     PRBool       mIsTranslucent;
     // This bitmap tracks which pixels are transparent. We don't support
     // full translucency at this time; each pixel is either fully opaque
     // or fully transparent.
     gchar*       mTransparencyBitmap;
  
+    PRBool       mMozEmbedTransparencyContextChecked;
+    PRBool       mMozEmbedTransparencyContext;
+
     // all of our DND stuff
     // this is the last window that had a drag event happen on it.
     static nsWindow    *mLastDragMotionWindow;
     void   InitDragEvent         (nsMouseEvent &aEvent);
     void   UpdateDragStatus      (nsMouseEvent &aEvent,
                                   GdkDragContext *aDragContext,
                                   nsIDragService *aDragService);
 
     // this is everything we need to be able to fire motion events
     // repeatedly
--- mozilla/gfx/public/nsIBlender.h.orig	2007-12-05 13:49:45.000000000 +0200
+++ mozilla/gfx/public/nsIBlender.h	2007-12-10 12:44:10.000000000 +0200
@@ -95,16 +95,17 @@ public:
                    nsIRenderingContext *aSecondSrc = nsnull, nscolor aSrcBackColor = NS_RGB(0, 0, 0),
                    nscolor aSecondSrcBackColor = NS_RGB(0, 0, 0)) = 0;
 
   /**
    GetAlphas computes an array of alpha values for a rectangle of pixels, using
    the drawn-onto-black and the drawn-onto-white images. The pixels are
    returned in a new'ed array of aRect.width*aRect.height elements, in row-major
    order. This array must be freed by the caller.
   */
   NS_IMETHOD GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                       nsIDrawingSurface* aWhite, PRUint8** aAlphas) = 0;
+                       nsIDrawingSurface* aWhite, PRUint8** aAlphas,
+                       PRBool aMozEmbedTransparencyContext = PR_FALSE) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIBlender, NS_IBLENDER_IID)
 
 #endif
--- mozilla/gfx/src/nsBlender.h.orig	2007-12-05 12:52:03.000000000 +0200
+++ mozilla/gfx/src/nsBlender.h	2007-12-10 12:44:10.000000000 +0200
@@ -70,21 +70,22 @@ public:
   NS_IMETHOD Blend(PRInt32 aSX, PRInt32 aSY, PRInt32 aWidth, PRInt32 aHeight,nsIDrawingSurface* aSrc,
                    nsIDrawingSurface* aDest, PRInt32 aDX, PRInt32 aDY, float aSrcOpacity,
                    nsIDrawingSurface* aSecondSrc = nsnull, nscolor aSrcBackColor = NS_RGB(0, 0, 0),
                    nscolor aSecondSrcBackColor = NS_RGB(0, 0, 0));
   NS_IMETHOD Blend(PRInt32 aSX, PRInt32 aSY, PRInt32 aWidth, PRInt32 aHeight, nsIRenderingContext *aSrc,
                    nsIRenderingContext *aDest, PRInt32 aDX, PRInt32 aDY, float aSrcOpacity,
                    nsIRenderingContext *aSecondSrc = nsnull, nscolor aSrcBackColor = NS_RGB(0, 0, 0),
                    nscolor aSecondSrcBackColor = NS_RGB(0, 0, 0));
 
   NS_IMETHOD GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                       nsIDrawingSurface* aWhite, PRUint8** aAlphas);
+                       nsIDrawingSurface* aWhite, PRUint8** aAlphas,
+                       PRBool aMozEmbedTransparencyContext = PR_FALSE);
 
 protected:
 
  /** --------------------------------------------------------------------------
   * Destructor for a nsBlender object
   */
   virtual ~nsBlender();
 
   //called by nsIBlender Blend() functions
   nsresult Blend(PRUint8 *aSrcBits, PRInt32 aSrcStride,
--- mozilla/gfx/src/nsBlender.cpp.orig	2007-12-13 12:23:57.000000000 +0200
+++ mozilla/gfx/src/nsBlender.cpp	2007-12-13 12:41:30.000000000 +0200
@@ -32,20 +32,24 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsBlender.h"
 #include "nsCRT.h"
 
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+const PRUint8 MOZEMBEDTRANSPARENCY_ALPHA_TRESHOLD = (PRUint8)180;
+#endif
+
 /** ---------------------------------------------------
  *  See documentation in nsBlender.h
  *	@update 2/25/00 dwc
  */
 nsBlender :: nsBlender()
 {
 }
 
 /** ---------------------------------------------------
  *  See documentation in nsBlender.h
@@ -239,36 +243,43 @@ NS_IMETHODIMP nsBlender::Blend(PRInt32 a
  * Let A be the unknown source pixel's alpha value and let C be its (unknown) color.
  * Let S be the value painted onto black and T be the value painted onto white.
  * Then S = C*(A/255) and T = 255*(1 - A/255) + C*(A/255).
  * Therefore A = 255 - (T - S)
  * This is true no matter what color component we look at.
  */
 static void ComputeAlphasByByte(PRInt32 aNumLines, PRInt32 aBytesPerLine,
                                 PRInt32 aBytesPerPixel,
                                 PRUint8 *aOnBlackImage, PRUint8 *aOnWhiteImage,
                                 PRInt32 aBytesLineSpan, PRUint8 *aAlphas,
-                                PRUint32 aAlphasSize)
+                                PRUint32 aAlphasSize, PRBool aMozEmbedTransparencyContext)
 {
   NS_ASSERTION(aBytesPerPixel == 3 || aBytesPerPixel == 4,
                "Only 24 or 32 bits per pixel supported here");
 
   PRIntn y;
   PRUint8* alphas = aAlphas;
   for (y = 0; y < aNumLines; y++) {
     // Look at component #1. It must be a real color no matter what
     // RGBA ordering is used.
     PRUint8 *s1 = aOnBlackImage + 1;
     PRUint8 *s2 = aOnWhiteImage + 1;
     
     PRIntn i;
     for (i = 1; i < aBytesPerLine; i += aBytesPerPixel) {
-      *alphas++ = (PRUint8)(255 - (*s2 - *s1));
+      PRUint8 curAlpha = (PRUint8)(255 - (*s2 - *s1));
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+      // In mozembed transparency context use alpha treshold to make alphas exactly 1 or 0
+      if (aMozEmbedTransparencyContext)
+        curAlpha > MOZEMBEDTRANSPARENCY_ALPHA_TRESHOLD ? curAlpha = (PRUint8)255 : curAlpha = (PRUint8)0;
+#endif
+     *alphas++ = curAlpha;
+
       s1 += aBytesPerPixel;
       s2 += aBytesPerPixel;
     }
   
     aOnBlackImage += aBytesLineSpan;
     aOnWhiteImage += aBytesLineSpan;
   }
 
   NS_ASSERTION(alphas - aAlphas == aAlphasSize, "alpha24/32 calculation error");
 }
@@ -276,21 +287,21 @@ static void ComputeAlphasByByte(PRInt32 
 /**  Use the green channel to work out the alpha value,
      since green has the most bits in most divisions of 16-bit color.
 
      The green values range from 0 to (1 << BLEND_GREEN_BITS) - 1.
      Therefore we multiply a green value by 255/((1 << BLEND_GREEN_BITS) - 1)
      to get a real alpha value.
 */
 static void ComputeAlphas16(PRInt32 aNumLines, PRInt32 aBytesPerLine,
                             PRUint8 *aOnBlackImage, PRUint8 *aOnWhiteImage,
                             PRInt32 aBytesLineSpan, PRUint8 *aAlphas,
-                            PRUint32 aAlphasSize)
+                            PRUint32 aAlphasSize, PRBool aMozEmbedTransparencyContext)
 {
   PRIntn y;
   PRUint8* alphas = aAlphas;
   for (y = 0; y < aNumLines; y++) {
     PRUint16 *s1 = (PRUint16*)aOnBlackImage;
     PRUint16 *s2 = (PRUint16*)aOnWhiteImage;
     
       // GREEN16 returns a value between 0 and 255 representing the
       // green value of the pixel. It only has BLEND_GREEN_BITS of
       // precision (so the values are typically 0, 8, 16, ..., 248). 
@@ -300,60 +311,68 @@ static void ComputeAlphas16(PRInt32 aNum
       // have GREEN16(pix1) = 0, GREEN16(pix2) = 248, and the resulting 
       // alpha value would just be 248, but we need 255. So we need to
       // do some rescaling.
     const PRUint32 SCALE_DENOMINATOR =   // usually 248
       ((1 << BLEND_GREEN_BITS) - 1) << (8 - BLEND_GREEN_BITS);
 
     PRIntn i;
     for (i = 0; i < aBytesPerLine; i += 2) {
       PRUint32 pix1 = GREEN16(*s1);
       PRUint32 pix2 = GREEN16(*s2);
-      *alphas++ = (PRUint8)(255 - ((pix2 - pix1)*255)/SCALE_DENOMINATOR);
+      PRUint8 curAlpha = (PRUint8)(255 - ((pix2 - pix1)*255)/SCALE_DENOMINATOR);
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+      // In mozembed transparency context use alpha treshold to make alphas exactly 1 or 0
+      if (aMozEmbedTransparencyContext)
+        curAlpha > MOZEMBEDTRANSPARENCY_ALPHA_TRESHOLD ? curAlpha = (PRUint8)255 : curAlpha = (PRUint8)0;
+#endif
+      *alphas++ = curAlpha;
+
       s1++;
       s2++;
     }
     
     aOnBlackImage += aBytesLineSpan;
     aOnWhiteImage += aBytesLineSpan;
   }
 
   NS_ASSERTION(alphas - aAlphas == aAlphasSize, "alpha16 calculation error");
 }
 
 static void ComputeAlphas(PRInt32 aNumLines, PRInt32 aBytesPerLine,
                           PRInt32 aDepth,
                           PRUint8 *aOnBlackImage, PRUint8 *aOnWhiteImage,
                           PRInt32 aBytesLineSpan, PRUint8 *aAlphas,
-                          PRUint32 aAlphasSize)
+                          PRUint32 aAlphasSize, PRBool aMozEmbedTransparencyContext)
 {
   switch (aDepth) {
     case 32:
     case 24:
       ComputeAlphasByByte(aNumLines, aBytesPerLine, aDepth/8,
                           aOnBlackImage, aOnWhiteImage,
-                          aBytesLineSpan, aAlphas, aAlphasSize);
+                          aBytesLineSpan, aAlphas, aAlphasSize, aMozEmbedTransparencyContext);
       break;
 
     case 16:
       ComputeAlphas16(aNumLines, aBytesPerLine, aOnBlackImage, aOnWhiteImage,
-                      aBytesLineSpan, aAlphas, aAlphasSize);
+                      aBytesLineSpan, aAlphas, aAlphasSize, aMozEmbedTransparencyContext);
       break;
     
     default:
       NS_ERROR("Unknown depth for alpha calculation");
       // make them all opaque
       memset(aAlphas, 255, aAlphasSize);
   }
 }
 
 NS_IMETHODIMP nsBlender::GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                                   nsIDrawingSurface* aWhite, PRUint8** aAlphas) {
+                                   nsIDrawingSurface* aWhite, PRUint8** aAlphas,
+                                   PRBool aMozEmbedTransparencyContext /*= PR_FALSE*/) {
   nsresult result;
 
   nsIDrawingSurface* blackSurface = (nsIDrawingSurface *)aBlack;
   nsIDrawingSurface* whiteSurface = (nsIDrawingSurface *)aWhite;
 
   nsRect r = aRect;
 
   rangeCheck(blackSurface, r.x, r.y, r.width, r.height);
   rangeCheck(whiteSurface, r.x, r.y, r.width, r.height);
 
@@ -375,21 +394,22 @@ NS_IMETHODIMP nsBlender::GetAlphas(const
                    "Mismatched bitmap formats (black/white) in Blender");
       if (blackSpan == whiteSpan && blackBytesPerLine == whiteBytesPerLine) {
         *aAlphas = new PRUint8[r.width*r.height];
         if (*aAlphas) {
           // compute depth like this to make sure it's consistent with the memory layout
           // and work around some GTK bugs. If there are no gfx bugs, then this is correct,
           // if there are gfx bugs, this will prevent a crash.
           PRUint32 depth = (blackBytesPerLine/r.width)*8;
           ComputeAlphas(r.height, blackBytesPerLine, depth,
                         blackBytes, whiteBytes, blackSpan, 
-                        *aAlphas, r.width*r.height);
+                        *aAlphas, r.width*r.height,
+                        aMozEmbedTransparencyContext);
         } else {
           result = NS_ERROR_FAILURE;
         }
       } else {
         result = NS_ERROR_FAILURE;
       }
 
       whiteSurface->Unlock();
     }
 
--- mozilla/layout/generic/nsContainerFrame.cpp.orig	2007-12-06 15:51:45.000000000 +0200
+++ mozilla/layout/generic/nsContainerFrame.cpp	2007-12-12 15:53:05.000000000 +0200
@@ -409,29 +409,42 @@ SyncFrameViewGeometryDependentProperties
     nsCSSRendering::FindBackground(aPresContext, aFrame, &bg, &isCanvas);
 
   if (isCanvas) {
     nsIView* rootView;
     vm->GetRootView(rootView);
     nsIView* rootParent = rootView->GetParent();
 
     nsIDocument *doc = aPresContext->PresShell()->GetDocument();
     if (doc) {
       nsIContent *rootElem = doc->GetRootContent();
-      if (!doc->GetParentDocument() &&
+
+      // Check for mozembed transparency context
+      PRBool transparencyContext = PR_FALSE;
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+      if (rootView->HasWidget())
+          rootView->GetWidget()->GetMozEmbedTransparencyContext(transparencyContext);
+#endif
+
+      if ((!doc->GetParentDocument() &&
           (nsCOMPtr<nsISupports>(doc->GetContainer())) &&
-          rootElem && rootElem->IsNodeOfType(nsINode::eXUL)) {
-        // we're XUL at the root of the document hierarchy. Try to make our
+          rootElem && rootElem->IsNodeOfType(nsINode::eXUL)) ||
+          (!doc->GetParentDocument() &&
+          (nsCOMPtr<nsISupports>(doc->GetContainer())) && rootElem && transparencyContext)) {
+        // we're XUL at the root of the document hierarchy or we are on mozembed transparency
+        // context. Try to make our
         // window translucent.
         // don't proceed unless this is the root view
         // (sometimes the non-root-view is a canvas)
-        if (aView->HasWidget() && aView == rootView) {
+        if (aView->HasWidget() && aView == rootView && !transparencyContext)
           aView->GetWidget()->SetWindowTranslucency(nsLayoutUtils::FrameHasTransparency(aFrame));
+        else if (transparencyContext) {
+          rootView->GetWidget()->SetWindowTranslucency(nsLayoutUtils::FrameHasTransparency(aFrame));
         }
       }
     }
   }
 }
 
 void
 nsContainerFrame::SyncFrameViewAfterReflow(nsPresContext* aPresContext,
                                            nsIFrame*       aFrame,
                                            nsIView*        aView,
--- mozilla/view/src/nsViewManager.h.orig	2007-12-05 12:56:14.000000000 +0200
+++ mozilla/view/src/nsViewManager.h	2007-12-10 12:44:10.000000000 +0200
@@ -515,19 +515,22 @@ private:
   static PRInt32           mVMCount;        //number of viewmanagers
 
   //Rendering context used to cleanup the blending buffers
   static nsIRenderingContext* gCleanupContext;
 
   //list of view managers
   static nsVoidArray       *gViewManagers;
 
   void PostInvalidateEvent();
 
+  PRBool mMozEmbedTransparencyContextChecked;
+  PRBool mMozEmbedTransparencyContext;
+
 #ifdef NS_VM_PERF_METRICS
   MOZ_TIMER_DECLARE(mWatch) //  Measures compositing+paint time for current document
 #endif
 };
 
 //when the refresh happens, should it be double buffered?
 #define NS_VMREFRESH_DOUBLE_BUFFER      0x0001
 
 #endif /* nsViewManager_h___ */
--- mozilla/view/src/nsViewManager.cpp.orig	2007-12-05 12:56:18.000000000 +0200
+++ mozilla/view/src/nsViewManager.cpp	2007-12-12 15:59:24.000000000 +0200
@@ -173,20 +173,22 @@ nsViewManager::nsViewManager()
   gViewManagers->AppendElement(this);
 
   mVMCount++;
   // NOTE:  we use a zeroing operator new, so all data members are
   // assumed to be cleared here.
   mDefaultBackgroundColor = NS_RGBA(0, 0, 0, 0);
   mAllowDoubleBuffering = PR_TRUE; 
   mHasPendingUpdates = PR_FALSE;
   mRecursiveRefreshPending = PR_FALSE;
   mUpdateBatchFlags = 0;
+  mMozEmbedTransparencyContextChecked = PR_FALSE;
+  mMozEmbedTransparencyContext = PR_FALSE;
 }
 
 nsViewManager::~nsViewManager()
 {
   if (mRootView) {
     // Destroy any remaining views
     mRootView->Destroy();
     mRootView = nsnull;
   }
 
@@ -815,27 +817,36 @@ void nsViewManager::RenderViews(nsView *
     mObserver->Paint(displayRoot, &aRC, damageRegion);
     aRC.PopState();
 #ifndef MOZ_CAIRO_GFX
     if (translucentWindow)
       mObserver->Paint(displayRoot, buffers->mWhiteCX, aRegion);
 #endif
   }
 
 #ifndef MOZ_CAIRO_GFX
   if (translucentWindow) {
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+    // Check for mozembed transparency context
+    if (!mMozEmbedTransparencyContextChecked) {
+      widget->GetMozEmbedTransparencyContext(mMozEmbedTransparencyContext);
+      mMozEmbedTransparencyContextChecked = PR_TRUE;
+    }
+#endif
+
     // Get the alpha channel into an array so we can send it to the widget
     nsRect r = aRegion.GetBounds();
     r *= (1.0f / mContext->AppUnitsPerDevPixel());
     nsRect bufferRect(0, 0, r.width, r.height);
     PRUint8* alphas = nsnull;
     nsresult rv = mBlender->GetAlphas(bufferRect, buffers->mBlack,
-                                      buffers->mWhite, &alphas);
+                                      buffers->mWhite, &alphas,
+                                      mMozEmbedTransparencyContext);
     
     if (NS_SUCCEEDED(rv)) {
       widget->UpdateTranslucentWindowAlpha(r, alphas);
     }
     delete[] alphas;
     delete buffers;
   }
 #endif
 }
 
--- mozilla/configure.in.orig	2007-12-10 08:32:12.000000000 +0200
+++ mozilla/configure.in	2007-12-10 12:44:10.000000000 +0200
@@ -7103,20 +7103,34 @@ MOZ_ARG_DISABLE_BOOL(xul,
 if test "$MOZ_XUL"; then
   AC_DEFINE(MOZ_XUL)
 else
   dnl remove extensions that require XUL
   MOZ_EXTENSIONS=`echo $MOZ_EXTENSIONS | sed -e 's/inspector//' -e 's/venkman//' -e 's/irc//' -e 's/tasks//'`
 fi
 
 AC_SUBST(MOZ_XUL)
 
 dnl ========================================================
+dnl enable mozembedtransparency
+dnl ========================================================
+
+MOZ_ARG_ENABLE_BOOL(mozembedtransparency,
+[  --enable-mozembedtransparency           Enable mozembedtransparency],
+    MOZ_GTK_EMBED_TRANSPARENCY=1,
+    MOZ_GTK_EMBED_TRANSPARENCY=)
+
+if test -n "$MOZ_GTK_EMBED_TRANSPARENCY"; then
+  AC_DEFINE(MOZ_GTK_EMBED_TRANSPARENCY)
+fi
+
+
+dnl ========================================================
 dnl Two ways to enable Python support:
 dnl   --enable-extensions=python # select all available.
 dnl    (MOZ_PYTHON_EXTENSIONS contains the list of extensions)
 dnl or:
 dnl   --enable-extensions=python/xpcom,... # select individual ones
 dnl
 dnl If either is used, we locate the Python to use.
 dnl ========================================================
 dnl
 dnl If 'python' appears anywhere in the extensions list, go lookin'...
