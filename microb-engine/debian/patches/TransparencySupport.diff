--- mozilla/widget/src/gtk2/nsWindow.cpp.orig	2007-11-27 09:41:08.000000000 +0200
+++ mozilla/widget/src/gtk2/nsWindow.cpp	2007-11-27 08:13:09.000000000 +0200
@@ -3402,39 +3402,43 @@ nsWindow::SetWindowTranslucency(PRBool a
     } // else the new default alpha values are "all 1", so we don't
     // need to change anything yet
 
     mIsTranslucent = aTranslucent;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::GetWindowTranslucency(PRBool& aTranslucent)
 {
+/*
     if (!mShell) {
         // Pass the request to the toplevel window
         GtkWidget *topWidget = nsnull;
         GetToplevelWidget(&topWidget);
         if (!topWidget) {
             aTranslucent = PR_FALSE;
             return NS_ERROR_FAILURE;
         }
 
         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
         if (!topWindow) {
             aTranslucent = PR_FALSE;
             return NS_ERROR_FAILURE;
         }
 
         return topWindow->GetWindowTranslucency(aTranslucent);
     }
 
     aTranslucent = mIsTranslucent;
+*/
+	  aTranslucent = PR_TRUE;
+
     return NS_OK;
 }
 
 void
 nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
 {
     if (!mTransparencyBitmap)
         return;
 
     if (aNewWidth == mTransparencyBitmapWidth &&
@@ -3519,51 +3523,79 @@ void UpdateMaskBits(gchar* aMaskBits, PR
             // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
             maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
         }
         aAlphas += aStride;
     }
 }
 
 void
 nsWindow::ApplyTransparencyBitmap()
 {
-    gtk_widget_reset_shapes(mShell);
-    GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(mShell->window,
-            mTransparencyBitmap,
-            mTransparencyBitmapWidth, mTransparencyBitmapHeight);
-    if (!maskBitmap)
-        return;
-
-    gtk_widget_shape_combine_mask(mShell, maskBitmap, 0, 0);
-    gdk_bitmap_unref(maskBitmap);
+    GtkWidget* widget = nsnull;
+  
+    if (!mDrawingarea) {
+      LOG(("!mDrawingarea\n"));
+      return;
+      }
+  
+    gpointer user_data = nsnull;
+    gdk_window_get_user_data(mDrawingarea->inner_window, &user_data);
+    if (!user_data) {
+        LOG(("!user_data\n"));
+        return;
+        }
+  
+    // Get parent moz container
+    MozContainer *mozContainer = MOZ_CONTAINER(user_data);
+    widget = gtk_widget_get_parent(GTK_WIDGET(mozContainer));
+  
+    LOG(("widget = %p\n", widget));
+  
+    if (widget) {
+      gtk_widget_reset_shapes(/*mShell*/widget);
+      GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(
+              /*mShell*/widget->window,
+              mTransparencyBitmap,
+              mTransparencyBitmapWidth,
+              mTransparencyBitmapHeight);
+      if (!maskBitmap)
+          return;
+    
+      gtk_widget_shape_combine_mask(/*mShell*/widget, maskBitmap, 0, 0);
+      gdk_bitmap_unref(maskBitmap);
+    }
+  else {
+    LOG(("!widget\n"));
+  }
 }
 
 nsresult
 nsWindow::UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                PRUint8* aAlphas, PRInt32 aStride)
 {
+/*
     if (!mShell) {
         // Pass the request to the toplevel window
         GtkWidget *topWidget = nsnull;
         GetToplevelWidget(&topWidget);
         if (!topWidget)
             return NS_ERROR_FAILURE;
 
         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
         if (!topWindow)
             return NS_ERROR_FAILURE;
 
         return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
     }
 
     NS_ASSERTION(mIsTranslucent, "Window is not transparent");
-
+*/
     if (mTransparencyBitmap == nsnull) {
         PRInt32 size = ((mBounds.width+7)/8)*mBounds.height;
         mTransparencyBitmap = new gchar[size];
         if (mTransparencyBitmap == nsnull)
             return NS_ERROR_FAILURE;
         memset(mTransparencyBitmap, 255, size);
         mTransparencyBitmapWidth = mBounds.width;
         mTransparencyBitmapHeight = mBounds.height;
     }
 
--- mozilla/widget/src/gtk2/nsWindow.h.orig	2007-11-27 09:41:08.000000000 +0200
+++ mozilla/widget/src/gtk2/nsWindow.h	2007-11-26 15:53:08.000000000 +0200
@@ -33,20 +33,22 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __nsWindow_h__
 #define __nsWindow_h__
 
+#define MOZ_XUL 1
+
 #include "nsAutoPtr.h"
 
 #include "nsCommonWidget.h"
 
 #include "mozcontainer.h"
 #include "mozdrawingarea.h"
 #include "nsWeakReference.h"
 
 #include "nsIDragService.h"
 #include "nsITimer.h"
--- mozilla/gfx/src/nsBlender.h.orig	2005-11-25 10:16:27.000000000 +0200
+++ mozilla/gfx/src/nsBlender.h	2007-11-26 15:49:55.000000000 +0200
@@ -33,20 +33,22 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef nsBlender_h___
 #define nsBlender_h___
 
+#define MOZ_XUL 1
+
 #include "nsCOMPtr.h"
 #include "nsIBlender.h"
 #include "nsIDeviceContext.h"
 
 typedef enum
 {
   nsLowQual = 0,
   nsLowMedQual,
   nsMedQual,
   nsHighMedQual,
--- mozilla/gfx/src/nsBlender.cpp.orig	2005-08-02 22:48:39.000000000 +0300
+++ mozilla/gfx/src/nsBlender.cpp	2007-11-27 09:34:22.000000000 +0200
@@ -307,38 +307,44 @@ static void ComputeAlphas16(PRInt32 aNum
       // have GREEN16(pix1) = 0, GREEN16(pix2) = 248, and the resulting 
       // alpha value would just be 248, but we need 255. So we need to
       // do some rescaling.
     const PRUint32 SCALE_DENOMINATOR =   // usually 248
       ((1 << BLEND_GREEN_BITS) - 1) << (8 - BLEND_GREEN_BITS);
 
     PRIntn i;
     for (i = 0; i < aBytesPerLine; i += 2) {
       PRUint32 pix1 = GREEN16(*s1);
       PRUint32 pix2 = GREEN16(*s2);
-      *alphas++ = (PRUint8)(255 - ((pix2 - pix1)*255)/SCALE_DENOMINATOR);
+
+      PRUint8 curAlpha = (PRUint8)(255 - ((pix2 - pix1)*255)/SCALE_DENOMINATOR);
+      curAlpha > (PRUint8)180 ? curAlpha = (PRUint8)255 : curAlpha = (PRUint8)0;
+      *alphas++ = curAlpha; /*(PRUint8)(255 - ((pix2 - pix1)*255)/SCALE_DENOMINATOR);*/
+
       s1++;
       s2++;
     }
-    
+
     aOnBlackImage += aBytesLineSpan;
     aOnWhiteImage += aBytesLineSpan;
   }
 
   NS_ASSERTION(alphas - aAlphas == aAlphasSize, "alpha16 calculation error");
 }
 
 static void ComputeAlphas(PRInt32 aNumLines, PRInt32 aBytesPerLine,
                           PRInt32 aDepth,
                           PRUint8 *aOnBlackImage, PRUint8 *aOnWhiteImage,
                           PRInt32 aBytesLineSpan, PRUint8 *aAlphas,
                           PRUint32 aAlphasSize)
 {
+//  printf("!!!! ComputeAlphas %d\n", aDepth);
+
   switch (aDepth) {
     case 32:
     case 24:
       ComputeAlphasByByte(aNumLines, aBytesPerLine, aDepth/8,
                           aOnBlackImage, aOnWhiteImage,
                           aBytesLineSpan, aAlphas, aAlphasSize);
       break;
 
     case 16:
       ComputeAlphas16(aNumLines, aBytesPerLine, aOnBlackImage, aOnWhiteImage,
