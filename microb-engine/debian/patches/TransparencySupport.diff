--- mozilla/widget/src/gtk2/nsWindow.cpp.orig	2007-12-05 12:51:39.000000000 +0200
+++ mozilla/widget/src/gtk2/nsWindow.cpp	2007-12-10 12:37:12.000000000 +0200
@@ -351,20 +351,23 @@ nsWindow::nsWindow()
 
 #ifdef ACCESSIBILITY
     mRootAccessible  = nsnull;
 #endif
 
     mIsTranslucent = PR_FALSE;
     mTransparencyBitmap = nsnull;
 
     mTransparencyBitmapWidth  = 0;
     mTransparencyBitmapHeight = 0;
+
+    mMozEmbedTransparencyContextChecked = PR_FALSE;
+    mMozEmbedTransparencyContext = PR_FALSE;
 }
 
 nsWindow::~nsWindow()
 {
     LOG(("nsWindow::~nsWindow() [%p]\n", (void *)this));
     if (mLastDragMotionWindow == this) {
         mLastDragMotionWindow = NULL;
     }
 
     delete[] mTransparencyBitmap;
@@ -1765,21 +1768,21 @@ nsWindow::OnExposeEvent(GtkWidget *aWidg
                 nsRefPtr<gfxImageSurface> img =
                     new gfxImageSurface(gfxIntSize(boundsRect.width, boundsRect.height),
                                         gfxImageSurface::ImageFormatA8);
                 img->SetDeviceOffset(gfxPoint(-boundsRect.x, -boundsRect.y));
             
                 nsRefPtr<gfxContext> imgCtx = new gfxContext(img);
                 imgCtx->SetPattern(pattern);
                 imgCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
                 imgCtx->Paint();
         
-#ifdef MOZ_XUL
+#if defined(MOZ_XUL) || defined(MOZ_GTK_EMBED_TRANSPARENCY)
                 UpdateTranslucentWindowAlphaInternal(nsRect(boundsRect.x, boundsRect.y,
                                                             boundsRect.width, boundsRect.height),
                                                      img->Data(), img->Stride());
 #endif
             } else {
 #ifdef MOZ_ENABLE_GLITZ
                 ctx->PopGroupToSource();
                 ctx->Paint();
 #else // MOZ_ENABLE_GLITZ
                 if (bufferPixmapSurface) {
@@ -3353,31 +3356,21 @@ nsWindow::NativeShow (PRBool  aAction)
 
 void
 nsWindow::EnsureGrabs(void)
 {
     if (mRetryPointerGrab)
         GrabPointer();
     if (mRetryKeyboardGrab)
         GrabKeyboard();
 }
 
-#ifndef MOZ_XUL
-void
-nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
-{
-}
-
-void
-nsWindow::ApplyTransparencyBitmap()
-{
-}
-#else
+#if defined(MOZ_XUL) || defined(MOZ_GTK_EMBED_TRANSPARENCY)
 NS_IMETHODIMP
 nsWindow::SetWindowTranslucency(PRBool aTranslucent)
 {
     if (!mShell) {
         // Pass the request to the toplevel window
         GtkWidget *topWidget = nsnull;
         GetToplevelWidget(&topWidget);
         if (!topWidget)
             return NS_ERROR_FAILURE;
 
@@ -3402,39 +3395,70 @@ nsWindow::SetWindowTranslucency(PRBool a
     } // else the new default alpha values are "all 1", so we don't
     // need to change anything yet
 
     mIsTranslucent = aTranslucent;
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::GetWindowTranslucency(PRBool& aTranslucent)
 {
-    if (!mShell) {
-        // Pass the request to the toplevel window
-        GtkWidget *topWidget = nsnull;
-        GetToplevelWidget(&topWidget);
-        if (!topWidget) {
-            aTranslucent = PR_FALSE;
-            return NS_ERROR_FAILURE;
+    if (!mMozEmbedTransparencyContextChecked) {
+        nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+        if (prefs) {
+          PRBool val = PR_FALSE;
+          nsresult rv = prefs->GetBoolPref("gtkmozembed.transparency.context", &val);
+          if (NS_SUCCEEDED(rv))
+              mMozEmbedTransparencyContext = val;
+        }
+        mMozEmbedTransparencyContextChecked = PR_TRUE;
+    }
+
+    // If we are not in webruntime context use normal behavior
+    if (!mMozEmbedTransparencyContext) {
+        if (!mShell) {
+            // Pass the request to the toplevel window
+            GtkWidget *topWidget = nsnull;
+            GetToplevelWidget(&topWidget);
+            if (!topWidget) {
+                aTranslucent = PR_FALSE;
+                return NS_ERROR_FAILURE;
+            }
+    
+            nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+            if (!topWindow) {
+                aTranslucent = PR_FALSE;
+                return NS_ERROR_FAILURE;
+            }
+    
+            return topWindow->GetWindowTranslucency(aTranslucent);
         }
-
-        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
-        if (!topWindow) {
+    
+        aTranslucent = mIsTranslucent;
+    } else {
+        // In webruntime context check if background has been set
+        // transparent, see nsContainerFrame::SyncFrameViewGeometryDependentProperties
+        nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+        PRBool val = PR_FALSE;
+        nsresult rv;
+
+        if (prefs)
+            rv = prefs->GetBoolPref("gtkmozembed.background.transparency", &val);
+
+        if (NS_SUCCEEDED(rv)) {
+            aTranslucent = val;
+            mIsTranslucent = val;
+        } else {
             aTranslucent = PR_FALSE;
-            return NS_ERROR_FAILURE;
         }
-
-        return topWindow->GetWindowTranslucency(aTranslucent);
     }
 
-    aTranslucent = mIsTranslucent;
     return NS_OK;
 }
 
 void
 nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
 {
     if (!mTransparencyBitmap)
         return;
 
     if (aNewWidth == mTransparencyBitmapWidth &&
@@ -3519,47 +3543,75 @@ void UpdateMaskBits(gchar* aMaskBits, PR
             // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
             maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
         }
         aAlphas += aStride;
     }
 }
 
 void
 nsWindow::ApplyTransparencyBitmap()
 {
-    gtk_widget_reset_shapes(mShell);
-    GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(mShell->window,
-            mTransparencyBitmap,
-            mTransparencyBitmapWidth, mTransparencyBitmapHeight);
-    if (!maskBitmap)
-        return;
-
-    gtk_widget_shape_combine_mask(mShell, maskBitmap, 0, 0);
-    gdk_bitmap_unref(maskBitmap);
+    GtkWidget* widget = nsnull;
+  
+    // If we are not in webruntime context use normal behavior
+    if (!mMozEmbedTransparencyContext)
+        widget = mShell;
+    else {
+        // In webruntime context get widget from parent
+        // moz container
+        if (!mDrawingarea)
+            return;
+      
+        gpointer user_data = nsnull;
+        gdk_window_get_user_data(mDrawingarea->inner_window, &user_data);
+        if (!user_data)
+            return;
+      
+        // Get parent moz container
+        MozContainer *mozContainer = MOZ_CONTAINER(user_data);
+        widget = gtk_widget_get_parent(GTK_WIDGET(mozContainer));
+    }
+  
+    if (widget) {
+        gtk_widget_reset_shapes(widget);
+        GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(
+                widget->window,
+                mTransparencyBitmap,
+                mTransparencyBitmapWidth,
+                mTransparencyBitmapHeight);
+        if (!maskBitmap)
+            return;
+      
+        gtk_widget_shape_combine_mask(widget, maskBitmap, 0, 0);
+        gdk_bitmap_unref(maskBitmap);
+    }
 }
 
 nsresult
 nsWindow::UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                PRUint8* aAlphas, PRInt32 aStride)
 {
-    if (!mShell) {
-        // Pass the request to the toplevel window
-        GtkWidget *topWidget = nsnull;
-        GetToplevelWidget(&topWidget);
-        if (!topWidget)
-            return NS_ERROR_FAILURE;
-
-        nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
-        if (!topWindow)
-            return NS_ERROR_FAILURE;
-
-        return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
+    // If we are not in webruntime context use normal behavior
+    if (!mMozEmbedTransparencyContext) {
+        if (!mShell) {
+            // Pass the request to the toplevel window
+            GtkWidget *topWidget = nsnull;
+            GetToplevelWidget(&topWidget);
+            if (!topWidget)
+                return NS_ERROR_FAILURE;
+    
+            nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
+            if (!topWindow)
+                return NS_ERROR_FAILURE;
+    
+            return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
+        }
     }
 
     NS_ASSERTION(mIsTranslucent, "Window is not transparent");
 
     if (mTransparencyBitmap == nsnull) {
         PRInt32 size = ((mBounds.width+7)/8)*mBounds.height;
         mTransparencyBitmap = new gchar[size];
         if (mTransparencyBitmap == nsnull)
             return NS_ERROR_FAILURE;
         memset(mTransparencyBitmap, 255, size);
@@ -3584,20 +3636,30 @@ nsWindow::UpdateTranslucentWindowAlphaIn
         ApplyTransparencyBitmap();
     }
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsWindow::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas)
 {
     return UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aRect.width);
 }
+#else
+void
+nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
+{
+}
+
+void
+nsWindow::ApplyTransparencyBitmap()
+{
+}
 #endif
 
 void
 nsWindow::GrabPointer(void)
 {
     LOG(("GrabPointer %d\n", mRetryPointerGrab));
 
     mRetryPointerGrab = PR_FALSE;
 
     // If the window isn't visible, just set the flag to retry the
--- mozilla/widget/src/gtk2/nsWindow.h.orig	2007-12-05 12:51:52.000000000 +0200
+++ mozilla/widget/src/gtk2/nsWindow.h	2007-12-10 12:22:22.000000000 +0200
@@ -336,21 +336,21 @@ public:
     NS_IMETHOD GetIMEOpenState(PRBool* aState);
     NS_IMETHOD SetIMEEnabled(PRUint32 aState);
     NS_IMETHOD GetIMEEnabled(PRUint32* aState);
     NS_IMETHOD CancelIMEComposition();
     NS_IMETHOD GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState);
 
 #endif
 
    void                ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight);
    void                ApplyTransparencyBitmap();
-#ifdef MOZ_XUL
+#if defined(MOZ_XUL) || defined(MOZ_GTK_EMBED_TRANSPARENCY)
    NS_IMETHOD          SetWindowTranslucency(PRBool aTransparent);
    NS_IMETHOD          GetWindowTranslucency(PRBool& aTransparent);
    nsresult            UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
                                                             PRUint8* aAlphas, PRInt32 aStride);
    NS_IMETHOD          UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
 #endif
 
 #ifdef MOZ_CAIRO_GFX
     gfxASurface       *GetThebesSurface();
 #endif
@@ -404,20 +404,23 @@ private:
     // The cursor cache
     static GdkCursor   *gsGtkCursorCache[eCursorCount];
 
     // Transparency
     PRBool       mIsTranslucent;
     // This bitmap tracks which pixels are transparent. We don't support
     // full translucency at this time; each pixel is either fully opaque
     // or fully transparent.
     gchar*       mTransparencyBitmap;
  
+    PRBool       mMozEmbedTransparencyContextChecked;
+    PRBool       mMozEmbedTransparencyContext;
+
     // all of our DND stuff
     // this is the last window that had a drag event happen on it.
     static nsWindow    *mLastDragMotionWindow;
     void   InitDragEvent         (nsMouseEvent &aEvent);
     void   UpdateDragStatus      (nsMouseEvent &aEvent,
                                   GdkDragContext *aDragContext,
                                   nsIDragService *aDragService);
 
     // this is everything we need to be able to fire motion events
     // repeatedly
--- mozilla/gfx/public/nsIBlender.h.orig	2007-12-05 13:49:45.000000000 +0200
+++ mozilla/gfx/public/nsIBlender.h	2007-12-10 12:00:40.000000000 +0200
@@ -95,16 +95,17 @@ public:
                    nsIRenderingContext *aSecondSrc = nsnull, nscolor aSrcBackColor = NS_RGB(0, 0, 0),
                    nscolor aSecondSrcBackColor = NS_RGB(0, 0, 0)) = 0;
 
   /**
    GetAlphas computes an array of alpha values for a rectangle of pixels, using
    the drawn-onto-black and the drawn-onto-white images. The pixels are
    returned in a new'ed array of aRect.width*aRect.height elements, in row-major
    order. This array must be freed by the caller.
   */
   NS_IMETHOD GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                       nsIDrawingSurface* aWhite, PRUint8** aAlphas) = 0;
+                       nsIDrawingSurface* aWhite, PRUint8** aAlphas,
+                       PRBool aMozEmbedTransparencyContext = PR_FALSE) = 0;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIBlender, NS_IBLENDER_IID)
 
 #endif
--- mozilla/gfx/src/nsBlender.h.orig	2007-12-05 12:52:03.000000000 +0200
+++ mozilla/gfx/src/nsBlender.h	2007-12-10 12:17:44.000000000 +0200
@@ -70,21 +70,22 @@ public:
   NS_IMETHOD Blend(PRInt32 aSX, PRInt32 aSY, PRInt32 aWidth, PRInt32 aHeight,nsIDrawingSurface* aSrc,
                    nsIDrawingSurface* aDest, PRInt32 aDX, PRInt32 aDY, float aSrcOpacity,
                    nsIDrawingSurface* aSecondSrc = nsnull, nscolor aSrcBackColor = NS_RGB(0, 0, 0),
                    nscolor aSecondSrcBackColor = NS_RGB(0, 0, 0));
   NS_IMETHOD Blend(PRInt32 aSX, PRInt32 aSY, PRInt32 aWidth, PRInt32 aHeight, nsIRenderingContext *aSrc,
                    nsIRenderingContext *aDest, PRInt32 aDX, PRInt32 aDY, float aSrcOpacity,
                    nsIRenderingContext *aSecondSrc = nsnull, nscolor aSrcBackColor = NS_RGB(0, 0, 0),
                    nscolor aSecondSrcBackColor = NS_RGB(0, 0, 0));
 
   NS_IMETHOD GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                       nsIDrawingSurface* aWhite, PRUint8** aAlphas);
+                       nsIDrawingSurface* aWhite, PRUint8** aAlphas,
+                       PRBool aMozEmbedTransparencyContext = PR_FALSE);
 
 protected:
 
  /** --------------------------------------------------------------------------
   * Destructor for a nsBlender object
   */
   virtual ~nsBlender();
 
   //called by nsIBlender Blend() functions
   nsresult Blend(PRUint8 *aSrcBits, PRInt32 aSrcStride,
--- mozilla/gfx/src/nsBlender.cpp.orig	2007-12-05 12:52:23.000000000 +0200
+++ mozilla/gfx/src/nsBlender.cpp	2007-12-10 12:20:38.000000000 +0200
@@ -32,20 +32,24 @@
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsBlender.h"
 #include "nsCRT.h"
 
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+const PRUint8 MOZEMBEDTRANSPARENCY_ALPHA_TRESHOLD = (PRUint8)180;
+#endif
+
 /** ---------------------------------------------------
  *  See documentation in nsBlender.h
  *	@update 2/25/00 dwc
  */
 nsBlender :: nsBlender()
 {
 }
 
 /** ---------------------------------------------------
  *  See documentation in nsBlender.h
@@ -228,54 +232,55 @@ NS_IMETHODIMP nsBlender::Blend(PRInt32 a
   nsIDrawingSurface* srcSurface, *destSurface, *secondSrcSurface = nsnull;
   aSrc->GetDrawingSurface(&srcSurface);
   aDest->GetDrawingSurface(&destSurface);
   if (aSecondSrc != nsnull)
     aSecondSrc->GetDrawingSurface(&secondSrcSurface);
   return Blend(aSX, aSY, aWidth, aHeight, srcSurface, destSurface,
                aDX, aDY, aSrcOpacity, secondSrcSurface, aSrcBackColor,
                aSecondSrcBackColor);
 }
 
-#ifndef MOZ_XUL
-NS_IMETHODIMP nsBlender::GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                                   nsIDrawingSurface* aWhite, PRUint8** aAlphas) {
-  NS_ERROR("GetAlphas not implemented because XUL support not built");
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-#else
+#if defined(MOZ_XUL) || defined(MOZ_GTK_EMBED_TRANSPARENCY)
 /**
  * Let A be the unknown source pixel's alpha value and let C be its (unknown) color.
  * Let S be the value painted onto black and T be the value painted onto white.
  * Then S = C*(A/255) and T = 255*(1 - A/255) + C*(A/255).
  * Therefore A = 255 - (T - S)
  * This is true no matter what color component we look at.
  */
 static void ComputeAlphasByByte(PRInt32 aNumLines, PRInt32 aBytesPerLine,
                                 PRInt32 aBytesPerPixel,
                                 PRUint8 *aOnBlackImage, PRUint8 *aOnWhiteImage,
                                 PRInt32 aBytesLineSpan, PRUint8 *aAlphas,
-                                PRUint32 aAlphasSize)
+                                PRUint32 aAlphasSize, PRBool aMozEmbedTransparencyContext)
 {
   NS_ASSERTION(aBytesPerPixel == 3 || aBytesPerPixel == 4,
                "Only 24 or 32 bits per pixel supported here");
 
   PRIntn y;
   PRUint8* alphas = aAlphas;
   for (y = 0; y < aNumLines; y++) {
     // Look at component #1. It must be a real color no matter what
     // RGBA ordering is used.
     PRUint8 *s1 = aOnBlackImage + 1;
     PRUint8 *s2 = aOnWhiteImage + 1;
     
     PRIntn i;
     for (i = 1; i < aBytesPerLine; i += aBytesPerPixel) {
-      *alphas++ = (PRUint8)(255 - (*s2 - *s1));
+      PRUint8 curAlpha = (PRUint8)(255 - (*s2 - *s1));
+
+      // In webruntime context use alpha treshold to make alphas exactly 1 or 0
+      if (aMozEmbedTransparencyContext)
+        curAlpha > MOZEMBEDTRANSPARENCY_ALPHA_TRESHOLD ? curAlpha = (PRUint8)255 : curAlpha = (PRUint8)0;
+
+      *alphas++ = curAlpha;
+
       s1 += aBytesPerPixel;
       s2 += aBytesPerPixel;
     }
   
     aOnBlackImage += aBytesLineSpan;
     aOnWhiteImage += aBytesLineSpan;
   }
 
   NS_ASSERTION(alphas - aAlphas == aAlphasSize, "alpha24/32 calculation error");
 }
@@ -283,21 +288,21 @@ static void ComputeAlphasByByte(PRInt32 
 /**  Use the green channel to work out the alpha value,
      since green has the most bits in most divisions of 16-bit color.
 
      The green values range from 0 to (1 << BLEND_GREEN_BITS) - 1.
      Therefore we multiply a green value by 255/((1 << BLEND_GREEN_BITS) - 1)
      to get a real alpha value.
 */
 static void ComputeAlphas16(PRInt32 aNumLines, PRInt32 aBytesPerLine,
                             PRUint8 *aOnBlackImage, PRUint8 *aOnWhiteImage,
                             PRInt32 aBytesLineSpan, PRUint8 *aAlphas,
-                            PRUint32 aAlphasSize)
+                            PRUint32 aAlphasSize, PRBool aMozEmbedTransparencyContext)
 {
   PRIntn y;
   PRUint8* alphas = aAlphas;
   for (y = 0; y < aNumLines; y++) {
     PRUint16 *s1 = (PRUint16*)aOnBlackImage;
     PRUint16 *s2 = (PRUint16*)aOnWhiteImage;
     
       // GREEN16 returns a value between 0 and 255 representing the
       // green value of the pixel. It only has BLEND_GREEN_BITS of
       // precision (so the values are typically 0, 8, 16, ..., 248). 
@@ -307,60 +312,69 @@ static void ComputeAlphas16(PRInt32 aNum
       // have GREEN16(pix1) = 0, GREEN16(pix2) = 248, and the resulting 
       // alpha value would just be 248, but we need 255. So we need to
       // do some rescaling.
     const PRUint32 SCALE_DENOMINATOR =   // usually 248
       ((1 << BLEND_GREEN_BITS) - 1) << (8 - BLEND_GREEN_BITS);
 
     PRIntn i;
     for (i = 0; i < aBytesPerLine; i += 2) {
       PRUint32 pix1 = GREEN16(*s1);
       PRUint32 pix2 = GREEN16(*s2);
-      *alphas++ = (PRUint8)(255 - ((pix2 - pix1)*255)/SCALE_DENOMINATOR);
+
+      PRUint8 curAlpha = (PRUint8)(255 - ((pix2 - pix1)*255)/SCALE_DENOMINATOR);
+      
+      // In webruntime context use alpha treshold to make alphas exactly 1 or 0
+      if (aMozEmbedTransparencyContext)
+        curAlpha > MOZEMBEDTRANSPARENCY_ALPHA_TRESHOLD ? curAlpha = (PRUint8)255 : curAlpha = (PRUint8)0;
+      
+      *alphas++ = curAlpha;
+
       s1++;
       s2++;
     }
     
     aOnBlackImage += aBytesLineSpan;
     aOnWhiteImage += aBytesLineSpan;
   }
 
   NS_ASSERTION(alphas - aAlphas == aAlphasSize, "alpha16 calculation error");
 }
 
 static void ComputeAlphas(PRInt32 aNumLines, PRInt32 aBytesPerLine,
                           PRInt32 aDepth,
                           PRUint8 *aOnBlackImage, PRUint8 *aOnWhiteImage,
                           PRInt32 aBytesLineSpan, PRUint8 *aAlphas,
-                          PRUint32 aAlphasSize)
+                          PRUint32 aAlphasSize, PRBool aMozEmbedTransparencyContext)
 {
   switch (aDepth) {
     case 32:
     case 24:
       ComputeAlphasByByte(aNumLines, aBytesPerLine, aDepth/8,
                           aOnBlackImage, aOnWhiteImage,
-                          aBytesLineSpan, aAlphas, aAlphasSize);
+                          aBytesLineSpan, aAlphas, aAlphasSize, aMozEmbedTransparencyContext);
       break;
 
     case 16:
       ComputeAlphas16(aNumLines, aBytesPerLine, aOnBlackImage, aOnWhiteImage,
-                      aBytesLineSpan, aAlphas, aAlphasSize);
+                      aBytesLineSpan, aAlphas, aAlphasSize, aMozEmbedTransparencyContext);
       break;
     
     default:
       NS_ERROR("Unknown depth for alpha calculation");
       // make them all opaque
       memset(aAlphas, 255, aAlphasSize);
   }
 }
 
 NS_IMETHODIMP nsBlender::GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
-                                   nsIDrawingSurface* aWhite, PRUint8** aAlphas) {
+                                   nsIDrawingSurface* aWhite, PRUint8** aAlphas,
+                                   PRBool aMozEmbedTransparencyContext /*= PR_FALSE*/) {
   nsresult result;
 
   nsIDrawingSurface* blackSurface = (nsIDrawingSurface *)aBlack;
   nsIDrawingSurface* whiteSurface = (nsIDrawingSurface *)aWhite;
 
   nsRect r = aRect;
 
   rangeCheck(blackSurface, r.x, r.y, r.width, r.height);
   rangeCheck(whiteSurface, r.x, r.y, r.width, r.height);
 
@@ -376,43 +390,50 @@ NS_IMETHODIMP nsBlender::GetAlphas(const
     result = whiteSurface->Lock(r.x, r.y, r.width, r.height,
                                 (void**)&whiteBytes, &whiteSpan,
                                 &whiteBytesPerLine, NS_LOCK_SURFACE_READ_ONLY);
     if (NS_SUCCEEDED(result)) {
       NS_ASSERTION(blackSpan == whiteSpan &&
                    blackBytesPerLine == whiteBytesPerLine,
                    "Mismatched bitmap formats (black/white) in Blender");
       if (blackSpan == whiteSpan && blackBytesPerLine == whiteBytesPerLine) {
         *aAlphas = new PRUint8[r.width*r.height];
         if (*aAlphas) {
+
           // compute depth like this to make sure it's consistent with the memory layout
           // and work around some GTK bugs. If there are no gfx bugs, then this is correct,
           // if there are gfx bugs, this will prevent a crash.
           PRUint32 depth = (blackBytesPerLine/r.width)*8;
           ComputeAlphas(r.height, blackBytesPerLine, depth,
                         blackBytes, whiteBytes, blackSpan, 
-                        *aAlphas, r.width*r.height);
+                        *aAlphas, r.width*r.height, aMozEmbedTransparencyContext);
         } else {
           result = NS_ERROR_FAILURE;
         }
       } else {
         result = NS_ERROR_FAILURE;
       }
 
       whiteSurface->Unlock();
     }
 
     blackSurface->Unlock();
   }
   
   return result;
 }
-#endif // MOZ_XUL
+#else
+NS_IMETHODIMP nsBlender::GetAlphas(const nsRect& aRect, nsIDrawingSurface* aBlack,
+                                   nsIDrawingSurface* aWhite, PRUint8** aAlphas) {
+  NS_ERROR("GetAlphas not implemented because XUL support not built");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+#endif // MOZ_XUL || MOZ_GTK_EMBED_TRANSPARENCY
 
 /**
   This is a simple case for 8-bit blending. We treat the opacity as binary.
 */
 static void Do8Blend(float aOpacity, PRInt32 aNumLines, PRInt32 aNumBytes,
                      PRUint8 *aSImage, PRUint8 *aS2Image, PRUint8 *aDImage,
                      PRInt32 aSLSpan, PRInt32 aDLSpan)
 {
   if (aOpacity <= 0.0) {
     return;
--- mozilla/layout/generic/nsContainerFrame.cpp.orig	2007-12-06 15:51:45.000000000 +0200
+++ mozilla/layout/generic/nsContainerFrame.cpp	2007-12-10 12:17:23.000000000 +0200
@@ -59,21 +59,22 @@
 #include "nsIWidget.h"
 #include "nsGfxCIID.h"
 #include "nsIServiceManager.h"
 #include "nsCSSRendering.h"
 #include "nsTransform2D.h"
 #include "nsRegion.h"
 #include "nsLayoutErrors.h"
 #include "nsDisplayList.h"
 #include "nsContentErrors.h"
 #include "nsIEventStateManager.h"
-
+#include "nsIPrefService.h"
+#include "nsIPrefBranch.h"
 #ifdef NS_DEBUG
 #undef NOISY
 #else
 #undef NOISY
 #endif
 
 nsContainerFrame::~nsContainerFrame()
 {
 }
 
@@ -409,29 +410,48 @@ SyncFrameViewGeometryDependentProperties
     nsCSSRendering::FindBackground(aPresContext, aFrame, &bg, &isCanvas);
 
   if (isCanvas) {
     nsIView* rootView;
     vm->GetRootView(rootView);
     nsIView* rootParent = rootView->GetParent();
 
     nsIDocument *doc = aPresContext->PresShell()->GetDocument();
     if (doc) {
       nsIContent *rootElem = doc->GetRootContent();
-      if (!doc->GetParentDocument() &&
+
+      // Check for mozembed transparency context
+      PRBool transparencyContext = PR_FALSE;
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+      nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+
+      if (prefs) {
+        PRBool val = PR_FALSE;
+        nsresult rv = prefs->GetBoolPref("gtkmozembed.transparency.context", &val);
+        if (NS_SUCCEEDED(rv))
+          transparencyContext = val;
+      }
+#endif
+
+      if ((!doc->GetParentDocument() &&
           (nsCOMPtr<nsISupports>(doc->GetContainer())) &&
-          rootElem && rootElem->IsNodeOfType(nsINode::eXUL)) {
-        // we're XUL at the root of the document hierarchy. Try to make our
+          rootElem && rootElem->IsNodeOfType(nsINode::eXUL)) ||
+          (!doc->GetParentDocument() &&
+          (nsCOMPtr<nsISupports>(doc->GetContainer())) && rootElem && transparencyContext)) {
+        // we're XUL at the root of the document hierarchy or we are on webruntime
+        // context. Try to make our
         // window translucent.
         // don't proceed unless this is the root view
         // (sometimes the non-root-view is a canvas)
-        if (aView->HasWidget() && aView == rootView) {
+        if (aView->HasWidget() && aView == rootView && !transparencyContext)
           aView->GetWidget()->SetWindowTranslucency(nsLayoutUtils::FrameHasTransparency(aFrame));
+        else if (transparencyContext) {
+          prefs->SetBoolPref("gtkmozembed.background.transparency", nsLayoutUtils::FrameHasTransparency(aFrame));
         }
       }
     }
   }
 }
 
 void
 nsContainerFrame::SyncFrameViewAfterReflow(nsPresContext* aPresContext,
                                            nsIFrame*       aFrame,
                                            nsIView*        aView,
--- mozilla/view/src/nsViewManager.h.orig	2007-12-05 12:56:14.000000000 +0200
+++ mozilla/view/src/nsViewManager.h	2007-12-10 12:00:40.000000000 +0200
@@ -515,19 +515,22 @@ private:
   static PRInt32           mVMCount;        //number of viewmanagers
 
   //Rendering context used to cleanup the blending buffers
   static nsIRenderingContext* gCleanupContext;
 
   //list of view managers
   static nsVoidArray       *gViewManagers;
 
   void PostInvalidateEvent();
 
+  PRBool mMozEmbedTransparencyContextChecked;
+  PRBool mMozEmbedTransparencyContext;
+
 #ifdef NS_VM_PERF_METRICS
   MOZ_TIMER_DECLARE(mWatch) //  Measures compositing+paint time for current document
 #endif
 };
 
 //when the refresh happens, should it be double buffered?
 #define NS_VMREFRESH_DOUBLE_BUFFER      0x0001
 
 #endif /* nsViewManager_h___ */
--- mozilla/view/src/nsViewManager.cpp.orig	2007-12-05 12:56:18.000000000 +0200
+++ mozilla/view/src/nsViewManager.cpp	2007-12-10 12:21:32.000000000 +0200
@@ -173,20 +173,22 @@ nsViewManager::nsViewManager()
   gViewManagers->AppendElement(this);
 
   mVMCount++;
   // NOTE:  we use a zeroing operator new, so all data members are
   // assumed to be cleared here.
   mDefaultBackgroundColor = NS_RGBA(0, 0, 0, 0);
   mAllowDoubleBuffering = PR_TRUE; 
   mHasPendingUpdates = PR_FALSE;
   mRecursiveRefreshPending = PR_FALSE;
   mUpdateBatchFlags = 0;
+  mMozEmbedTransparencyContextChecked = PR_FALSE;
+  mMozEmbedTransparencyContext = PR_FALSE;
 }
 
 nsViewManager::~nsViewManager()
 {
   if (mRootView) {
     // Destroy any remaining views
     mRootView->Destroy();
     mRootView = nsnull;
   }
 
@@ -815,27 +817,42 @@ void nsViewManager::RenderViews(nsView *
     mObserver->Paint(displayRoot, &aRC, damageRegion);
     aRC.PopState();
 #ifndef MOZ_CAIRO_GFX
     if (translucentWindow)
       mObserver->Paint(displayRoot, buffers->mWhiteCX, aRegion);
 #endif
   }
 
 #ifndef MOZ_CAIRO_GFX
   if (translucentWindow) {
+#ifdef MOZ_GTK_EMBED_TRANSPARENCY
+    // Check for mozembed transparency context
+    if (!mMozEmbedTransparencyContextChecked) {
+      nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+      if (prefs) {
+        PRBool val = PR_FALSE;
+        nsresult rv = prefs->GetBoolPref("gtkmozembed.transparency.context", &val);
+        if (NS_SUCCEEDED(rv))
+          mMozEmbedTransparencyContext = val;
+      }
+      mMozEmbedTransparencyContextChecked = PR_TRUE;
+    }
+#endif
+
     // Get the alpha channel into an array so we can send it to the widget
     nsRect r = aRegion.GetBounds();
     r *= (1.0f / mContext->AppUnitsPerDevPixel());
     nsRect bufferRect(0, 0, r.width, r.height);
     PRUint8* alphas = nsnull;
     nsresult rv = mBlender->GetAlphas(bufferRect, buffers->mBlack,
-                                      buffers->mWhite, &alphas);
+                                      buffers->mWhite, &alphas,
+                                      mMozEmbedTransparencyContext);
     
     if (NS_SUCCEEDED(rv)) {
       widget->UpdateTranslucentWindowAlpha(r, alphas);
     }
     delete[] alphas;
     delete buffers;
   }
 #endif
 }
 
--- mozilla/configure.in.orig	2007-12-10 08:32:12.000000000 +0200
+++ mozilla/configure.in	2007-12-10 12:31:32.000000000 +0200
@@ -7103,20 +7103,34 @@ MOZ_ARG_DISABLE_BOOL(xul,
 if test "$MOZ_XUL"; then
   AC_DEFINE(MOZ_XUL)
 else
   dnl remove extensions that require XUL
   MOZ_EXTENSIONS=`echo $MOZ_EXTENSIONS | sed -e 's/inspector//' -e 's/venkman//' -e 's/irc//' -e 's/tasks//'`
 fi
 
 AC_SUBST(MOZ_XUL)
 
 dnl ========================================================
+dnl enable mozembedtransparency
+dnl ========================================================
+
+MOZ_ARG_ENABLE_BOOL(mozembedtransparency,
+[  --enable-mozembedtransparency           Enable mozembedtransparency],
+    MOZ_GTK_EMBED_TRANSPARENCY=1,
+    MOZ_GTK_EMBED_TRANSPARENCY=)
+
+if test -n "$MOZ_GTK_EMBED_TRANSPARENCY"; then
+  AC_DEFINE(MOZ_GTK_EMBED_TRANSPARENCY)
+fi
+
+
+dnl ========================================================
 dnl Two ways to enable Python support:
 dnl   --enable-extensions=python # select all available.
 dnl    (MOZ_PYTHON_EXTENSIONS contains the list of extensions)
 dnl or:
 dnl   --enable-extensions=python/xpcom,... # select individual ones
 dnl
 dnl If either is used, we locate the Python to use.
 dnl ========================================================
 dnl
 dnl If 'python' appears anywhere in the extensions list, go lookin'...
