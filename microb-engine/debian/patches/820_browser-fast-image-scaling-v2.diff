diff -u -N -r mozilla/gfx/src/gtk/nsImageGTK.cpp mozilla/gfx/src/gtk/nsImageGTK.cpp
--- mozilla/gfx/src/gtk/nsImageGTK.cpp	2008-05-16 14:52:37.000000000 +0300
+++ mozilla/gfx/src/gtk/nsImageGTK.cpp	2008-05-16 14:22:58.000000000 +0300
@@ -84,7 +84,6 @@
 
 nsImageGTK::nsImageGTK()
   : mImageBits(nsnull)
-  , mImagePixmap(nsnull)
   , mTrueAlphaBits(nsnull)
   , mAlphaBits(nsnull)
   , mAlphaPixmap(nsnull)
@@ -133,10 +132,6 @@
     gdk_pixmap_unref(mAlphaPixmap);
   }
 
-  if (mImagePixmap) {
-    gdk_pixmap_unref(mImagePixmap);
-  }
-
   if (mAlphaXImage) {
     mAlphaXImage->data = 0;
     XDestroyImage(mAlphaXImage);
@@ -379,10 +374,7 @@
       }
       
       if (mAlphaDepth==8) {
-        if (mImagePixmap) {
-          gdk_pixmap_unref(mImagePixmap);
-          mImagePixmap = 0;
-        }
+        mImagePixmap.Free();
         if (mAlphaPixmap) {
           gdk_pixmap_unref(mAlphaPixmap);
           mAlphaPixmap = 0;
@@ -456,7 +448,7 @@
     if (mAlphaDepth != 8) {
       PRBool mem = CreateOffscreenPixmap(mWidth, mHeight);
       if (mem) {
-      gdk_draw_rgb_image_dithalign(mImagePixmap, sXbitGC, 
+      gdk_draw_rgb_image_dithalign(mImagePixmap.pixmap, sXbitGC, 
                                      rect->x, rect->y,
                                      rect->width, rect->height,
                                      GDK_RGB_DITHER_NONE,
@@ -679,6 +671,160 @@
 
 #undef sign
 
+static inline void scale_line_16(PRInt16 *dst, const PRInt16 *src, int dstw, int srcw)
+{
+    int count = dstw, x = dstw + (srcw >> 1);
+    int tmp1, tmp2, tmp3, tmp4;
+#ifdef __arm__
+    /* ensure 32-bit alignment for 'dst' pointer by processing 1 pixel if needed */
+    if (((int)dst & 1) && (--count >= 0)) {
+        x -= srcw;
+        while (x < 0) {
+            x += dstw;
+            src++;
+        }
+        *dst++ = *src;
+    }
+    /* run unrolled assembly optimized loop */
+    __asm__ __volatile__ (
+        "subs   %[count], %[count], #4\n"
+        "blt    5f\n"
+    "0:\n"
+        "subs   %[x], %[x], %[srcw]\n"
+    "1:\n"
+        "addlt  %[src], %[src], #2\n"
+        "addlts %[x], %[x], %[dstw]\n"
+        "blt    1b\n"
+        "ldrh   %[tmp1], [%[src]]\n"
+
+        "subs   %[x], %[x], %[srcw]\n"
+    "2:\n"
+        "addlt  %[src], %[src], #2\n"
+        "addlts %[x], %[x], %[dstw]\n"
+        "blt    2b\n"
+        "ldrh   %[tmp2], [%[src]]\n"
+
+        "subs   %[x], %[x], %[srcw]\n"
+    "3:\n"
+        "addlt  %[src], %[src], #2\n"
+        "addlts %[x], %[x], %[dstw]\n"
+        "blt    3b\n"
+        "ldrh   %[tmp3], [%[src]]\n"
+
+        "subs   %[x], %[x], %[srcw]\n"
+    "4:\n"
+        "addlt  %[src], %[src], #2\n"
+        "addlts %[x], %[x], %[dstw]\n"
+        "blt    4b\n"
+        "ldrh   %[tmp4], [%[src]]\n"
+
+        "subs   %[count], %[count], #4\n"
+        "orr    %[tmp1], %[tmp1], %[tmp2], asl #16\n"
+        "str    %[tmp1], [%[dst]], #4\n"
+        "orr    %[tmp3], %[tmp3], %[tmp4], asl #16\n"
+        "str    %[tmp3], [%[dst]], #4\n"
+        "bge    0b\n"
+    "5:\n"
+        : [dst] "+&r" (dst), [src] "+&r" (src), [count] "+&r" (count), [x] "+&r" (x), 
+          [tmp1] "+&r" (tmp1), [tmp2] "+&r" (tmp2), [tmp3] "+&r" (tmp3), [tmp4] "+&r" (tmp4)
+        : [dstw] "r" (dstw), [srcw] "r" (srcw)
+        : "cc", "memory"
+    );
+    count += 4;
+    /* fall through and process the remaining pixels (if any) using generic C code */
+#endif
+    while (--count >= 0) {
+        x -= srcw;
+        while (x < 0) {
+            x += dstw;
+            src++;
+        }
+        *dst++ = *src;
+    }
+}
+
+static int scale_image_16(
+    PRInt16 *dstbuf, int dstw, int dsth, int dststride,
+    PRInt16 *srcbuf, int srcw, int srch, int srcstride)
+{
+    int count = dsth, x = dsth + (srch >> 1);
+
+    while (--count >= 0) {
+        x -= srch;
+        while (x < 0) {
+            x += dsth;
+            srcbuf = (PRInt16 *)((char *)srcbuf + srcstride);
+        }
+
+        scale_line_16(dstbuf, srcbuf, dstw, srcw);
+
+        dstbuf = (PRInt16 *)((char *)dstbuf + dststride);
+    }
+    return 0;
+}
+
+/**
+ * A variant of XlibRectStretch function which can use direct access to the source pixmap pixel data.
+ */
+PRBool
+XlibRectStretch(PRInt32 srcWidth, PRInt32 srcHeight,
+                PRInt32 dstWidth, PRInt32 dstHeight,
+                PRInt32 dstOrigX, PRInt32 dstOrigY,
+                PRInt32 aDX, PRInt32 aDY,
+                PRInt32 aDWidth, PRInt32 aDHeight,
+                GdkShmPixmap &aSrcImage, GdkPixmap *aDstImage,
+                GdkGC *gc, GdkGC *copygc, PRInt32 aDepth)
+{
+    if (!aSrcImage.mem || aSrcImage.depth != 16)
+        return XlibRectStretch(srcWidth, srcHeight,
+                dstWidth, dstHeight,
+                dstOrigX, dstOrigY,
+                aDX, aDY,
+                aDWidth, aDHeight,
+                aSrcImage.pixmap, aDstImage,
+                gc, copygc, aDepth);
+
+    int sDX = (aDX - dstOrigX) * srcWidth / dstWidth;
+    int sDY = (aDY - dstOrigY) * srcHeight / dstHeight;
+    int sDWidth = aDWidth * srcWidth / dstWidth;
+    int sDHeight = aDHeight * srcHeight / dstHeight;
+
+    if (sDX < 0 || sDY < 0 || sDX + sDWidth > aSrcImage.width || sDY + sDHeight > aSrcImage.height) {
+        fprintf(stderr, "[microb-engine] XlibRectStretch: invalid size - w:%d, h:%d (%d, %d, %d, %d)\n",
+            aSrcImage.width, aSrcImage.height, sDX, sDY, sDWidth, sDHeight);
+        return XlibRectStretch(srcWidth, srcHeight,
+                dstWidth, dstHeight,
+                dstOrigX, dstOrigY,
+                aDX, aDY,
+                aDWidth, aDHeight,
+                aSrcImage.pixmap, aDstImage,
+                gc, copygc, aDepth);
+    }
+
+    GdkShmPixmap tmp;
+    tmp.Create(aDWidth, aDHeight);
+
+    scale_image_16(
+        (PRInt16 *)((char *)tmp.mem),
+        aDWidth,
+        aDHeight,
+        tmp.bpl,
+        (PRInt16 *)((char *)aSrcImage.mem + sDY * aSrcImage.bpl + sDX * 2),
+        sDWidth,
+        sDHeight,
+        aSrcImage.bpl);
+
+    gdk_window_copy_area(aDstImage,
+                         gc,
+                         aDX,                         // xdest
+                         aDY,                         // ydest
+                         tmp.pixmap,                  // source window
+                         0,                           // xsrc
+                         0,                           // ysrc
+                         aDWidth,                     // width
+                         aDHeight);                   // height
+    return PR_TRUE;
+}
 
 
 // Draw the bitmap, this method has a source and destination coordinates
@@ -967,7 +1113,7 @@
                             dstOrigX, dstOrigY,
                             rect->x, rect->y,
                             rect->width, rect->height,
-                            mImagePixmap, drawing->GetDrawable(),
+                            mImagePixmap.pixmap, drawing->GetDrawable(),
                             gc, sXbitGC, gdk_rgb_get_visual()->depth);
             if (!mem) return NS_ERROR_OUT_OF_MEMORY;
           }
@@ -980,7 +1126,7 @@
                           dstOrigX, dstOrigY,
                           aDX, aDY,
                           aDWidth, aDHeight,
-                          mImagePixmap, drawing->GetDrawable(),
+                          mImagePixmap.pixmap, drawing->GetDrawable(),
                           gc, sXbitGC, gdk_rgb_get_visual()->depth);
           if (!mem) return NS_ERROR_OUT_OF_MEMORY;
         }
@@ -1070,7 +1216,7 @@
                            copyGC,                      // gc
                            rect->x,                     // xdest
                            rect->y,                     // ydest
-                           mImagePixmap,                // source window
+                           mImagePixmap.pixmap,         // source window
                            aSX+(rect->x-aDX),           // xsrc
                            aSY+(rect->y-aDY),           // ysrc
                            rect->width,                 // width
@@ -1083,7 +1229,7 @@
                          copyGC,                      // gc
                          aDX,                         // xdest
                          aDY,                         // ydest
-                         mImagePixmap,                // source window
+                         mImagePixmap.pixmap,         // source window
                          aSX,                         // xsrc
                          aSY,                         // ysrc
                          aSWidth,                     // width
@@ -1818,7 +1964,7 @@
   // Render unique image bits onto an off screen pixmap only once
   // The image bits can change as a result of ImageUpdated() - for
   // example: animated GIFs.
-  if (!mImagePixmap) {
+  if (!mImagePixmap.pixmap) {
 #ifdef TRACE_IMAGE_ALLOCATION
     printf("nsImageGTK::Draw(this=%p) gdk_pixmap_new(nsnull,width=%d,height=%d,depth=%d)\n",
            this,
@@ -1828,10 +1974,9 @@
 
     // Create an off screen pixmap to hold the image bits.
     gdk_error_trap_push();
-    mImagePixmap = gdk_pixmap_new(nsnull, aWidth, aHeight,
-                                  gdk_rgb_get_visual()->depth);
+    mImagePixmap.Create(aWidth, aHeight);
     gdk_flush();
-    if ((err=gdk_error_trap_pop()) || !mImagePixmap) {
+    if ((err=gdk_error_trap_pop()) || !mImagePixmap.pixmap) {
       xerrmessage(err);
       mWidth = 0;
       mHeight = 0;
@@ -1839,7 +1984,7 @@
     }
 
 #ifdef MOZ_WIDGET_GTK2
-    gdk_drawable_set_colormap(GDK_DRAWABLE(mImagePixmap), gdk_rgb_get_colormap());
+    gdk_drawable_set_colormap(GDK_DRAWABLE(mImagePixmap.pixmap), gdk_rgb_get_colormap());
 #endif
   }
 
@@ -1886,7 +2031,7 @@
   }
 
   if (!sXbitGC)
-    sXbitGC = gdk_gc_new(mImagePixmap);
+    sXbitGC = gdk_gc_new(mImagePixmap.pixmap);
   return PR_TRUE;
 }
 
@@ -1988,7 +2133,7 @@
   gdk_drawable_set_colormap(GDK_DRAWABLE(tileImg), gdk_rgb_get_colormap());
 #endif
 
-  TilePixmap(mImagePixmap, tileImg, aSXOffset, aSYOffset, tmpRect,
+  TilePixmap(mImagePixmap.pixmap, tileImg, aSXOffset, aSYOffset, tmpRect,
              tmpRect, PR_FALSE);
 
   // tile alpha mask
@@ -2154,7 +2299,7 @@
     GdkGCValues values;
     GdkGCValuesMask valuesMask;
 
-    GdkPixmap *alphaPixmap = mAlphaPixmap, *imagePixmap = mImagePixmap,
+    GdkPixmap *alphaPixmap = mAlphaPixmap, *imagePixmap = mImagePixmap.pixmap,
       *scaledAlpha = 0, *scaledImage = 0;
     gint err;
 
@@ -2168,7 +2313,7 @@
       // Create new pixmaps for scaled images
       scaledAlpha = gdk_pixmap_new(nsnull, dWidth, dHeight, 1);
       scaledImage = gdk_pixmap_new(nsnull, dWidth, dHeight,
-        gdk_drawable_get_depth(mImagePixmap));
+        gdk_drawable_get_depth(mImagePixmap.pixmap));
       gdk_flush();
       if ((err=gdk_error_trap_pop()) || !scaledImage || !scaledAlpha) {
         xerrmessage(err);
@@ -2203,7 +2348,7 @@
                             0, 0,
                             0, 0,
                             dWidth, dHeight,
-                            mImagePixmap, scaledImage,
+                            mImagePixmap.pixmap, scaledImage,
                             gc, sXbitGC, gdk_rgb_get_visual()->depth);
 
       if (!mem) {
@@ -2257,7 +2402,7 @@
     if (scaledImage) gdk_pixmap_unref(scaledImage);
   } else {
     // If the page is not scaled use mImagePixmap directly
-    GdkPixmap *tilePixmap = mImagePixmap, *pixmap = 0;
+    GdkPixmap *tilePixmap = mImagePixmap.pixmap, *pixmap = 0;
 
     if (scale != 1.0) {
 #ifdef DEBUG_TILING
@@ -2268,7 +2413,7 @@
       gint err = 0;
       gdk_error_trap_push();
       pixmap = gdk_pixmap_new(nsnull, dWidth, dHeight,
-        gdk_drawable_get_depth(mImagePixmap));
+        gdk_drawable_get_depth(mImagePixmap.pixmap));
       gdk_flush();
       if ((err=gdk_error_trap_pop()) || !pixmap) {
         xerrmessage(err);
@@ -2285,7 +2430,7 @@
                           0, 0,
                           dWidth, dHeight,
                           mImagePixmap, pixmap,
-                          gc, sXbitGC, gdk_drawable_get_depth(mImagePixmap));
+                          gc, sXbitGC, gdk_drawable_get_depth(mImagePixmap.pixmap));
         if (!mem) {
           if (pixmap)
             gdk_pixmap_unref(pixmap);
@@ -2407,15 +2552,15 @@
     return NS_OK;
   }
 
-  if (!mImagePixmap)
+  if (!mImagePixmap.pixmap)
     return NS_OK;
 
   XImage *ximage, *xmask=0;
   unsigned pix;
 
   gdk_error_trap_push();
-  ximage = XGetImage(GDK_WINDOW_XDISPLAY(mImagePixmap),
-                     GDK_WINDOW_XWINDOW(mImagePixmap),
+  ximage = XGetImage(GDK_WINDOW_XDISPLAY(mImagePixmap.pixmap),
+                     GDK_WINDOW_XWINDOW(mImagePixmap.pixmap),
                      0, 0, mWidth, mHeight,
                      AllPlanes, ZPixmap);
   gdk_flush();
diff -u -N -r mozilla/gfx/src/gtk/nsImageGTK.h mozilla/gfx/src/gtk/nsImageGTK.h
--- mozilla/gfx/src/gtk/nsImageGTK.h	2008-05-16 14:52:36.000000000 +0300
+++ mozilla/gfx/src/gtk/nsImageGTK.h	2008-05-16 14:18:03.000000000 +0300
@@ -47,6 +47,7 @@
 #ifdef MOZ_WIDGET_GTK2
 #include "nsIGdkPixbufImage.h"
 #endif
+#include "nsShmPixmapGTK.h"
 
 class nsDrawingSurfaceGTK;
 
@@ -193,7 +194,7 @@
                 PRInt32 aSXOffset, PRInt32 aSYOffset, const nsRect& aRect, PRBool aIsValid);
 
   PRUint8      *mImageBits;
-  GdkPixmap    *mImagePixmap;
+  GdkShmPixmap  mImagePixmap;
   PRUint8      *mTrueAlphaBits;
   PRUint8      *mAlphaBits;
   GdkPixmap    *mAlphaPixmap;
diff -u -N -r mozilla/gfx/src/gtk/nsShmPixmapGTK.h mozilla/gfx/src/gtk/nsShmPixmapGTK.h
--- mozilla/gfx/src/gtk/nsShmPixmapGTK.h	1970-01-01 02:00:00.000000000 +0200
+++ mozilla/gfx/src/gtk/nsShmPixmapGTK.h	2008-05-16 14:18:03.000000000 +0300
@@ -0,0 +1,137 @@
+#ifndef nsShmPixmapGTK_h___
+#define nsShmPixmapGTK_h___
+
+#include <stdlib.h>
+#include <string.h>
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+
+#include <sys/ipc.h>
+#include <X11/Xlib.h>
+#include <sys/shm.h>
+#include <X11/extensions/XShm.h>
+
+/**
+ * A wrapper which can create GdkPixmap object and provide direct 
+ * access to its pixel data just like GdkImage
+ */
+class GdkShmPixmap
+{
+    XShmSegmentInfo  m_xssi;
+    XImage          *m_ximage;
+    Pixmap           m_xpixmap;
+
+    int CreateShm()
+    {
+        memset(&m_xssi, 0, sizeof(m_xssi));
+
+        m_ximage = XShmCreateImage(GDK_DISPLAY(), GDK_VISUAL_XVISUAL(gdk_visual_get_system()),
+            gdk_visual_get_system()->depth, ZPixmap, NULL, &m_xssi, width, height);
+        if (!m_ximage) return -1;
+
+        bpl = m_ximage->bytes_per_line;
+
+        m_xssi.shmid = shmget(IPC_PRIVATE, m_ximage->bytes_per_line * height, IPC_CREAT | 0777);
+        if (m_xssi.shmid < 0) {
+            XDestroyImage(m_ximage);
+            m_ximage = 0;
+            return -1;
+        }
+
+        m_xssi.shmaddr = (char *)shmat(m_xssi.shmid, 0, 0);
+        mem = (gpointer)m_xssi.shmaddr;
+
+        if (!m_xssi.shmaddr) {
+            shmctl(m_xssi.shmid, IPC_RMID, 0);
+            m_xssi.shmid = -1;
+            XDestroyImage(m_ximage);
+            m_ximage = 0;
+            return -1;
+        }
+
+        m_xssi.readOnly = False;
+        if (!XShmAttach(GDK_DISPLAY(), &m_xssi)) {
+            shmdt(m_xssi.shmaddr);
+            m_xssi.shmaddr = 0;
+            mem = 0;
+            shmctl(m_xssi.shmid, IPC_RMID, 0);
+            m_xssi.shmid = -1;
+            XDestroyImage(m_ximage);
+            m_ximage = 0;
+            return -1;
+        }
+
+        m_xpixmap = XShmCreatePixmap(GDK_DISPLAY(), GDK_ROOT_WINDOW(),
+            (char *)mem, &m_xssi, width, height, gdk_visual_get_system()->depth);
+        if (!m_xpixmap) {
+            XShmDetach(GDK_DISPLAY(), &m_xssi);
+            shmdt(m_xssi.shmaddr);
+            m_xssi.shmaddr = 0;
+            mem = 0;
+            shmctl(m_xssi.shmid, IPC_RMID, 0);
+            m_xssi.shmid = -1;
+            XDestroyImage(m_ximage);
+            m_ximage = 0;
+            return -1;
+        }
+        return 1;
+    }
+
+    void FreeShm()
+    {
+        if (mem) {
+            XShmDetach(GDK_DISPLAY(), &m_xssi);
+            XFreePixmap(GDK_DISPLAY(), m_xpixmap);
+            m_xpixmap = 0;
+            XDestroyImage(m_ximage);
+            m_ximage = 0;
+            shmdt(m_xssi.shmaddr);
+            m_xssi.shmaddr = 0;
+            mem = 0;
+            shmctl(m_xssi.shmid, IPC_RMID, 0);
+            m_xssi.shmid = -1;
+        }
+    }
+
+public: // Clone of some GdkImage data
+    int              width;
+    int              height;
+    guint16          depth;
+    guint16          bpl;
+    gpointer         mem;
+    GdkPixmap       *pixmap;
+
+public:
+
+    GdkShmPixmap() { width = 0; height = 0; depth = 0; bpl = 0; mem = 0; pixmap = 0; m_xssi.shmaddr = 0; m_xssi.shmid = -1; }
+    ~GdkShmPixmap() { if (pixmap) Free(); }
+
+    int Create(int pixmap_width, int pixmap_height)
+    {
+        if (pixmap) Free();
+
+        width  = pixmap_width;
+        height = pixmap_height;
+        depth  = gdk_visual_get_system()->depth;
+
+        if (CreateShm() < 0) {
+            // failed to create shared memory pixmap, so use 'normal' pixmap in this case
+            pixmap = gdk_pixmap_new(NULL, width, height, depth);
+        } else {
+            pixmap = gdk_pixmap_foreign_new(m_xpixmap);
+        }
+        if (!pixmap) return -1;
+        return 1;
+    }
+
+    void Free()
+    {
+        if (pixmap) g_object_unref(pixmap);
+        pixmap = 0;
+        FreeShm();
+        width = 0; height = 0; depth = 0; bpl = 0; mem = 0; pixmap = 0; m_xssi.shmaddr = 0; m_xssi.shmid = -1;
+    }
+};
+
+#endif
diff -u -N -r mozilla/toolkit/library/Makefile.in mozilla/toolkit/library/Makefile.in
--- mozilla/toolkit/library/Makefile.in	2008-05-16 14:52:49.000000000 +0300
+++ mozilla/toolkit/library/Makefile.in	2008-05-16 14:18:03.000000000 +0300
@@ -214,6 +214,8 @@
 endif
 endif
 
+EXTRA_DSO_LDOPTS += -lXext
+
 ifeq ($(OS_ARCH),BeOS)
 EXTRA_DSO_LDOPTS += -lbe -ltracker
 endif
