--- mozilla/layout/generic/nsGfxScrollFrame.h.orig	2007-05-23 06:48:43.000000000 +0300
+++ mozilla/layout/generic/nsGfxScrollFrame.h	2007-09-26 11:02:10.000000000 +0300
@@ -189,20 +189,21 @@ public:
   nsRevocableEventPtr<ScrollEvent> mScrollEvent;
   nsRevocableEventPtr<AsyncScrollPortEvent> mAsyncScrollPortEvent;
   nsIScrollableView* mScrollableView;
   nsIBox* mHScrollbarBox;
   nsIBox* mVScrollbarBox;
   nsIFrame* mScrolledFrame;
   nsIBox* mScrollCornerBox;
   nsContainerFrame* mOuter;
 
   nsRect mRestoreRect;
+  float mRestoreZoom;
   nsPoint mLastPos;
 
   PRPackedBool mNeverHasVerticalScrollbar:1;
   PRPackedBool mNeverHasHorizontalScrollbar:1;
   PRPackedBool mHasVerticalScrollbar:1;
   PRPackedBool mHasHorizontalScrollbar:1;
   PRPackedBool mViewInitiatedScroll:1;
   PRPackedBool mFrameInitiatedScroll:1;
   PRPackedBool mDidHistoryRestore:1;
   // Is this the scrollframe for the document's viewport?
--- mozilla/layout/generic/nsGfxScrollFrame.cpp.orig	2007-09-25 16:53:03.000000000 +0300
+++ mozilla/layout/generic/nsGfxScrollFrame.cpp	2007-09-26 12:39:01.000000000 +0300
@@ -1218,20 +1218,21 @@ NS_INTERFACE_MAP_END_INHERITING(nsBoxFra
 nsGfxScrollFrameInner::nsGfxScrollFrameInner(nsContainerFrame* aOuter,
                                              PRBool aIsRoot,
                                              PRBool aIsXUL)
   : mScrollableView(nsnull),
     mHScrollbarBox(nsnull),
     mVScrollbarBox(nsnull),
     mScrolledFrame(nsnull),
     mScrollCornerBox(nsnull),
     mOuter(aOuter),
     mRestoreRect(-1, -1, -1, -1),
+    mRestoreZoom(-1.0),
     mLastPos(-1, -1),
     mNeverHasVerticalScrollbar(PR_FALSE),
     mNeverHasHorizontalScrollbar(PR_FALSE),
     mHasVerticalScrollbar(PR_FALSE), 
     mHasHorizontalScrollbar(PR_FALSE),
     mViewInitiatedScroll(PR_FALSE),
     mFrameInitiatedScroll(PR_FALSE),
     mDidHistoryRestore(PR_FALSE),
     mIsRoot(aIsRoot),
     mIsXUL(aIsXUL),
@@ -1471,20 +1472,27 @@ nsGfxScrollFrameInner::GetScrollbarStyle
 void
 nsGfxScrollFrameInner::ScrollToRestoredPosition()
 {
   nsIScrollableView* scrollingView = GetScrollableView();
   if (!scrollingView) {
     return;
   }
   if (mRestoreRect.y == -1 || mLastPos.x == -1 || mLastPos.y == -1) {
     return;
   }
+
+  if (mOuter) {
+    nsPresContext* presContext = mOuter->PresContext();
+    if (presContext && mRestoreZoom != presContext->GetFullZoom())
+      presContext->SetFullZoom(mRestoreZoom);
+  }
+
   // make sure our scroll position did not change for where we last put
   // it. if it does then the user must have moved it, and we no longer
   // need to restore.
   nscoord x = 0;
   nscoord y = 0;
   scrollingView->GetScrollPosition(x, y);
 
   // if we didn't move, we still need to restore
   if (x == mLastPos.x && y == mLastPos.y) {
     nsRect childRect(0, 0, 0, 0);
@@ -1505,20 +1513,21 @@ nsGfxScrollFrameInner::ScrollToRestoredP
     if (y != cy || x != cx) {
       scrollingView->ScrollTo(x, y, 0);
       // scrollpostion goes from twips to pixels. this fixes any roundoff
       // problems.
       scrollingView->GetScrollPosition(mLastPos.x, mLastPos.y);
     } else {
       // if we reached the position then stop
       mRestoreRect.y = -1;
       mLastPos.x = -1;
       mLastPos.y = -1;
+      mRestoreZoom = -1.0;
     }
   } else {
     // user moved the position, so we won't need to restore
     mLastPos.x = -1;
     mLastPos.y = -1;
   }
 }
 
 nsresult
 nsGfxScrollFrameInner::FireScrollPortEvent()
@@ -2704,28 +2713,32 @@ nsGfxScrollFrameInner::SaveState(nsIStat
   }
 
   nsRect childRect = child->GetBounds();
   childRect.x = x;
   childRect.y = y;
   nsAutoPtr<nsPresState> state;
   nsresult rv = NS_NewPresState(getter_Transfers(state));
   NS_ENSURE_SUCCESS(rv, nsnull);
 
   state->SetScrollState(childRect);
+  nsPresContext* presContext = mOuter->PresContext();
+  if (presContext)
+    state->SetZoomState(presContext->GetFullZoom());
 
   return state.forget();
 }
 
 void
 nsGfxScrollFrameInner::RestoreState(nsPresState* aState)
 {
   mRestoreRect = aState->GetScrollState();
+  mRestoreZoom = aState->GetZoomState();
   mLastPos.x = -1;
   mLastPos.y = -1;
   mDidHistoryRestore = PR_TRUE;
   nsIScrollableView* scrollingView = GetScrollableView();
   if (scrollingView) {
     scrollingView->GetScrollPosition(mLastPos.x, mLastPos.y);
   } else {
     mLastPos = nsPoint(0, 0);
   }
 }
--- mozilla/layout/base/nsPresState.h.orig	2006-11-06 18:08:20.000000000 +0200
+++ mozilla/layout/base/nsPresState.h	2007-09-26 11:19:16.000000000 +0300
@@ -63,22 +63,25 @@ public:
 
   NS_HIDDEN_(nsresult) GetStateProperty(const nsAString& aProperty,
                                         nsAString& aResult);
 
   NS_HIDDEN_(nsresult) SetStateProperty(const nsAString& aProperty,
                                         const nsAString& aValue);
 
   NS_HIDDEN_(nsresult) RemoveStateProperty(const nsAString& aProperty);
 
   NS_HIDDEN_(nsresult) SetScrollState(const nsRect& aState);
+  NS_HIDDEN_(nsresult) SetZoomState(const float aZoom);
 
   nsRect GetScrollState();
+  float GetZoomState();
 
 // MEMBER VARIABLES
 protected:
   nsInterfaceHashtable<nsStringHashKey,nsISupports> mPropertyTable;
   nsAutoPtr<nsRect> mScrollState;
+  float mZoomState;
 };
 
 NS_HIDDEN_(nsresult) NS_NewPresState(nsPresState **aState);
 
 #endif /* nsPresState_h_ */
--- mozilla/layout/base/nsPresState.cpp.orig	2006-11-06 18:08:20.000000000 +0200
+++ mozilla/layout/base/nsPresState.cpp	2007-09-26 11:30:56.000000000 +0300
@@ -47,20 +47,21 @@
 #include "nsXPIDLString.h"
 #include "nsReadableUtils.h"
 #include "nsLayoutErrors.h"
 #include "nsPresState.h"
 #include "nsString.h"
 // Implementation /////////////////////////////////////////////////////////////////
 
 nsresult
 nsPresState::Init()
 {
+  mZoomState = -1.0;
   return mPropertyTable.Init(8) ? NS_OK : NS_ERROR_FAILURE;
 }
 
 nsresult
 nsPresState::GetStateProperty(const nsAString& aName, nsAString& aResult)
 {
   nsresult rv = NS_STATE_PROPERTY_NOT_THERE;
   aResult.Truncate();
 
   // Retrieve from hashtable.
@@ -138,20 +139,33 @@ nsPresState::GetScrollState()
 {
   if (!mScrollState) {
     nsRect empty(0,0,0,0);
     return empty;  
   }
 
   return *mScrollState;
 }
 
 nsresult
+nsPresState::SetZoomState(const float aZoom)
+{
+  mZoomState = aZoom;
+  return NS_OK;
+}
+
+float
+nsPresState::GetZoomState()
+{
+  return mZoomState;
+}
+
+nsresult
 NS_NewPresState(nsPresState** aState)
 {
   nsPresState *state;
 
   *aState = nsnull;
   state = new nsPresState();
   if (!state)
     return NS_ERROR_OUT_OF_MEMORY;
 
   nsresult rv = state->Init();
