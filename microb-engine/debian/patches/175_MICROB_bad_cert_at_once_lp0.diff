# Patches for microb-engine
# Oleg Romashin <ext-oleg.2.romashin@nokia.com>
# DP: New BadCertificate Listener Interface
# NOBUGFIXME

Index: security/manager/pki/src/nsNSSDialogs.cpp
===================================================================
--- security/manager/pki/src/nsNSSDialogs.cpp.orig
+++ security/manager/pki/src/nsNSSDialogs.cpp
@@ -370,17 +370,17 @@ nsNSSDialogs::NotifyCrlNextupdate(nsIInt
     return rv;
 
   rv = nsNSSDialogHelper::openDialog(nsnull,
                              "chrome://pippki/content/serverCrlNextupdate.xul",
                              block);
   return NS_OK;
 }
 
-NS_IMETHODIMP 
+NS_IMETHODIMP
 nsNSSDialogs::CrlImportStatusDialog(nsIInterfaceRequestor *ctx, nsICRLInfo *crl)
 {
   nsresult rv;
 
   nsCOMPtr<nsIPKIParamBlock> block = do_CreateInstance(kPKIParamBlockCID,&rv);
   if (NS_FAILED(rv))
     return rv;
   
@@ -751,9 +751,19 @@ nsNSSDialogs::ConfirmKeyEscrow(nsIX509Ce
   rv = dlgParamBlock->GetInt(1, &status);
  
   if (status) {
     *_retval = PR_TRUE;
   } 
   return rv;
 }
 
-
+#ifdef BAD_CERT_LISTENER2
+NS_IMETHODIMP
+nsNSSDialogs::ConfirmBadCertificate(nsIInterfaceRequestor *ctx,
+                                    nsIX509Cert *cert,
+                                    PRBool aSecSuccess,
+                                    PRUint32 aError,
+                                    PRBool *_retval)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+#endif
Index: security/manager/ssl/public/Makefile.in
===================================================================
--- security/manager/ssl/public/Makefile.in.orig
+++ security/manager/ssl/public/Makefile.in
@@ -47,16 +47,17 @@ include $(DEPTH)/config/autoconf.mk
 
 MODULE = pipnss
 GRE_MODULE	= 1
 
 SDK_XPIDLSRCS = \
     nsIASN1Object.idl \
     nsIASN1Sequence.idl \
     nsIBadCertListener.idl \
+    nsIBadCertListener2.idl \
     nsICertificateDialogs.idl \
     nsICRLInfo.idl \
     nsIX509Cert.idl \
     nsIX509CertDB.idl \
     nsIX509CertValidity.idl \
     $(NULL)
 
 XPIDLSRCS = \
Index: security/manager/ssl/src/nsNSSIOLayer.cpp
===================================================================
--- security/manager/ssl/src/nsNSSIOLayer.cpp.orig
+++ security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -47,16 +47,17 @@
 #include "prnetdb.h"
 #include "nsIPrompt.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 #include "nsIServiceManager.h"
 #include "nsIWebProgressListener.h"
 #include "nsIChannel.h"
 #include "nsIBadCertListener.h"
+#include "nsIBadCertListener2.h"
 #include "nsNSSCertificate.h"
 #include "nsIProxyObjectManager.h"
 #include "nsProxiedService.h"
 #include "nsIDateTimeFormat.h"
 #include "nsDateTimeFormatCID.h"
 #include "nsIClientAuthDialogs.h"
 
 #include "nsXPIDLString.h"
@@ -1379,73 +1380,58 @@ addCertToDB(CERTCertificate *peerCert, P
   }
   return retVal;
 }
 
 static PRBool
 nsContinueDespiteCertError(nsNSSSocketInfo  *infoObject,
                            PRFileDesc       *sslSocket,
                            int               error,
-                           nsNSSCertificate *nssCert)
+                           nsNSSCertificate *nssCert, nsIBadCertListener *badCertHandler, PRUint32 *aEnumErr)
 {
   PRBool retVal = PR_FALSE;
-  nsIBadCertListener *badCertHandler = nsnull;
   PRInt16 addType = nsIBadCertListener::UNINIT_ADD_FLAG;
   nsresult rv;
 
   if (!nssCert)
     return PR_FALSE;
 
   // Try to get a nsIBadCertListener implementation from the socket consumer
   // first.  If that fails, fallback to the default UI.
-  nsCOMPtr<nsIInterfaceRequestor> callbacks;
-  infoObject->GetNotificationCallbacks(getter_AddRefs(callbacks));
-  if (callbacks) {
-    nsCOMPtr<nsIBadCertListener> handler = do_GetInterface(callbacks);
-    if (handler) {
-      NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
-                           NS_GET_IID(nsIBadCertListener),
-                           handler,
-                           NS_PROXY_SYNC,
-                           (void**)&badCertHandler);
-    }
-  }
-  if (!badCertHandler) {
-    rv = getNSSDialogs((void**)&badCertHandler, 
-                       NS_GET_IID(nsIBadCertListener),
-                       NS_BADCERTLISTENER_CONTRACTID);
-    if (NS_FAILED(rv)) 
-      return PR_FALSE;
-  }
   nsIInterfaceRequestor *csi = NS_STATIC_CAST(nsIInterfaceRequestor*,
                                                  infoObject);
   nsIX509Cert *callBackCert = NS_STATIC_CAST(nsIX509Cert*, nssCert);
   CERTCertificate *peerCert = nssCert->GetCert();
   NS_ASSERTION(peerCert, "Got nsnull cert back from nsNSSCertificate");
   switch (error) {
   case SEC_ERROR_UNKNOWN_ISSUER:
+    *aEnumErr |= nsIX509Cert::ISSUER_UNKNOWN;
   case SEC_ERROR_CA_CERT_INVALID:
+    *aEnumErr |= nsIX509Cert::INVALID_CA;
   case SEC_ERROR_UNTRUSTED_ISSUER:
+    *aEnumErr |= nsIX509Cert::ISSUER_NOT_TRUSTED;
   /* This is a temporay fix for bug# - We are showing a unknown ca dialog,
      when actually the ca cert has expired/not yet valid. We need to change
      this in future - need to define a proper ui for this situation
   */
   case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
     {
+      *aEnumErr |= nsIX509Cert::ISSUER_NOT_TRUSTED;
       nsPSMUITracker tracker;
       if (tracker.isUIForbidden()) {
         rv = NS_ERROR_NOT_AVAILABLE;
       }
       else {
         rv = badCertHandler->ConfirmUnknownIssuer(csi, callBackCert, &addType, &retVal);
       }
     }
     break;
   case SSL_ERROR_BAD_CERT_DOMAIN:
     {
+      *aEnumErr |= nsIX509Cert::NOT_VERIFIED_UNKNOWN;
       nsXPIDLCString url; url.Adopt(SSL_RevealURL(sslSocket));
       NS_ASSERTION(url.get(), "could not find valid URL in ssl socket");
       {
         nsPSMUITracker tracker;
         if (tracker.isUIForbidden()) {
           rv = NS_ERROR_NOT_AVAILABLE;
         }
         else {
@@ -1455,55 +1441,57 @@ nsContinueDespiteCertError(nsNSSSocketIn
       }
       if (NS_SUCCEEDED(rv) && retVal) {
         rv = CERT_AddOKDomainName(peerCert, url);
       }
     }
     break;
   case SEC_ERROR_EXPIRED_CERTIFICATE:
     {
+      *aEnumErr |= nsIX509Cert::CERT_EXPIRED;
       nsPSMUITracker tracker;
       if (tracker.isUIForbidden()) {
         rv = NS_ERROR_NOT_AVAILABLE;
       }
       else {
         rv = badCertHandler->ConfirmCertExpired(csi, callBackCert, & retVal);
       }
     }
     if (rv == SECSuccess && retVal) {
       // XXX We need an NSS API for this equivalent functionality.
       //     Having to reach inside the cert is evil.
       peerCert->timeOK = PR_TRUE;
     }
     break;
   case SEC_ERROR_CRL_EXPIRED:
     {
+      *aEnumErr |= nsIX509Cert::CERT_REVOKED;
       nsXPIDLCString url; url.Adopt(SSL_RevealURL(sslSocket));
       NS_ASSERTION(url, "could not find valid URL in ssl socket");
       {
         nsPSMUITracker tracker;
         if (tracker.isUIForbidden()) {
           rv = NS_ERROR_NOT_AVAILABLE;
         }
         else {
           rv = badCertHandler->NotifyCrlNextupdate(csi, url, callBackCert);
         }
       }
       retVal = PR_FALSE;
     }
     break;
   default:
     nsHandleSSLError(infoObject,error);
+    *aEnumErr |= nsIX509Cert::USAGE_NOT_ALLOWED;
     retVal = PR_FALSE;
     rv = NS_ERROR_FAILURE;
   }
   if (retVal && addType != nsIBadCertListener::UNINIT_ADD_FLAG) {
     addCertToDB(peerCert, addType);
   }
-  NS_RELEASE(badCertHandler);
   CERT_DestroyCertificate(peerCert);
   return NS_FAILED(rv) ? PR_FALSE : retVal;
 }
 
 static SECStatus
 verifyCertAgain(CERTCertificate *cert, 
                 PRFileDesc      *sslSocket,
                 nsNSSSocketInfo *infoObject)
@@ -2359,53 +2347,104 @@ done:
   return ret;
 }
 
 static SECStatus
 nsNSSBadCertHandler(void *arg, PRFileDesc *sslSocket)
 {
   nsNSSShutDownPreventionLock locker;
   SECStatus rv = SECFailure;
+  nsresult rv_dlg = NS_OK, rv_dlg2 = NS_OK;
+  PRUint32 enum_err = nsIX509Cert::VERIFIED_OK;
   int error;
   nsNSSSocketInfo* infoObject = (nsNSSSocketInfo *)arg;
   CERTCertificate *peerCert;
   nsNSSCertificate *nssCert;
 
   error = PR_GetError();
   peerCert = SSL_PeerCertificate(sslSocket);
   nssCert = new nsNSSCertificate(peerCert);
   if (!nssCert) {
     return SECFailure;
   } 
   NS_ADDREF(nssCert);
-  infoObject->SetBadCertUIStatus(nsNSSSocketInfo::bcuis_active);
-  while (rv != SECSuccess) {
-     //Func nsContinueDespiteCertError does the same set of checks as func.
-     //nsCertErrorNeedsDialog. So, removing call to nsCertErrorNeedsDialog
-     if (!nsContinueDespiteCertError(infoObject, sslSocket, 
-                                    error, nssCert)) {
-      break;
+
+  nsIBadCertListener *badCertHandler = nsnull;
+  nsIBadCertListener2 *badCertHandler2 = nsnull;
+  nsCOMPtr<nsIInterfaceRequestor> callbacks;
+  infoObject->GetNotificationCallbacks(getter_AddRefs(callbacks));
+  if (callbacks) {
+    nsCOMPtr<nsIBadCertListener> handler = do_GetInterface(callbacks);
+    if (handler) {
+      NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
+                           NS_GET_IID(nsIBadCertListener),
+                           handler,
+                           NS_PROXY_SYNC,
+                           (void**)&badCertHandler);
+
+      NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
+                           NS_GET_IID(nsIBadCertListener2),
+                           handler,
+                           NS_PROXY_SYNC,
+                           (void**)&badCertHandler2);
     }
-    rv = verifyCertAgain(peerCert, sslSocket, infoObject);
-	error = PR_GetError();
   }
+  if (!badCertHandler) {
+    rv_dlg = getNSSDialogs((void**)&badCertHandler,
+                           NS_GET_IID(nsIBadCertListener),
+                           NS_BADCERTLISTENER_CONTRACTID);
+  }
+
+	if (!badCertHandler2) {
+    rv_dlg2 = getNSSDialogs((void**)&badCertHandler2,
+                            NS_GET_IID(nsIBadCertListener2),
+                            NS_BADCERTLISTENER2_CONTRACTID);
+  }
+
+  if (!NS_FAILED(rv_dlg) && badCertHandler) {
+    if (rv != SECSuccess) enum_err = 0;
+    while (rv != SECSuccess) {
+      //Func nsContinueDespiteCertError does the same set of checks as func.
+      //nsCertErrorNeedsDialog. So, removing call to nsCertErrorNeedsDialog
+      if (!nsContinueDespiteCertError(infoObject, sslSocket,
+                                      error, nssCert, badCertHandler, &enum_err)) {
+        break;
+      }
+      rv = verifyCertAgain(peerCert, sslSocket, infoObject);
+      error = PR_GetError();
+    }
+    nsIX509Cert *confirmedCert = NS_STATIC_CAST(nsIX509Cert*, nssCert);
+    nsIInterfaceRequestor *ccsi = NS_STATIC_CAST(nsIInterfaceRequestor*,
+                                                 infoObject);
+
+    if (!NS_FAILED(rv_dlg2) && badCertHandler2) {
+      PRBool confirmVal = PR_TRUE;
+      rv_dlg2 = badCertHandler2->ConfirmBadCertificate(ccsi, confirmedCert, rv == SECSuccess, enum_err, &confirmVal);
+			if (rv_dlg2 != NS_ERROR_NOT_IMPLEMENTED && (NS_FAILED(rv_dlg2) || !confirmVal))
+        rv = SECFailure;
+      NS_RELEASE(badCertHandler2);
+      infoObject->SetBadCertUIStatus(nsNSSSocketInfo::bcuis_active);
+    }
+  }
+
+  NS_RELEASE(badCertHandler);
   infoObject->SetBadCertUIStatus(nsNSSSocketInfo::bcuis_was_shown);
   NS_RELEASE(nssCert);
-  CERT_DestroyCertificate(peerCert); 
+  CERT_DestroyCertificate(peerCert);
   if (rv != SECSuccess) {
     // if the cert is bad, we don't want to connect
     infoObject->SetCanceled(PR_TRUE);
   }
   return rv;
 }
 
 static PRFileDesc*
 nsSSLIOLayerImportFD(PRFileDesc *fd,
-                     nsNSSSocketInfo *infoObject,
-                     const char *host)
+                     nsNSSSocketInfo *infoObject,
+                     const char *host)
 {
   nsNSSShutDownPreventionLock locker;
   PRFileDesc* sslSock = SSL_ImportFD(nsnull, fd);
   if (!sslSock) {
     NS_ASSERTION(PR_FALSE, "NSS: Error importing socket");
     return nsnull;
   }
   SSL_SetPKCS11PinArg(sslSock, (nsIInterfaceRequestor*)infoObject);
@@ -2554,8 +2593,9 @@ nsSSLIOLayerAddToSocket(PRInt32 family,
   return NS_OK;
  loser:
   NS_IF_RELEASE(infoObject);
   if (layer) {
     layer->dtor(layer);
   }
   return NS_ERROR_FAILURE;
 }
+
Index: security/manager/ssl/public/nsIBadCertListener2.idl
===================================================================
--- /dev/null
+++ security/manager/ssl/public/nsIBadCertListener2.idl
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ *
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Oleg Romashin <romaxa@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIX509Cert;
+interface nsIInterfaceRequestor;
+
+/**
+ * Functions that display common warning for site with bad certificate.
+ */
+[scriptable, uuid(e13d7006-5ecf-41b1-aef1-072a7667cd66)]
+interface nsIBadCertListener2 : nsISupports {
+
+  boolean confirmBadCertificate(in nsIInterfaceRequestor socketInfo,
+                                in nsIX509Cert cert, in boolean aSecSuccess, in unsigned long aError);
+};
+
+%{C++
+#define NS_BADCERTLISTENER2_CONTRACTID "@mozilla.org/nsBadCertListener2;1"
+%}
Index: security/manager/pki/src/nsNSSDialogs.h
===================================================================
--- security/manager/pki/src/nsNSSDialogs.h.orig
+++ security/manager/pki/src/nsNSSDialogs.h
@@ -37,16 +37,19 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #ifndef __NS_NSSDIALOGS_H__
 #define __NS_NSSDIALOGS_H__
 
 #include "nsITokenPasswordDialogs.h"
 #include "nsIBadCertListener.h"
+#ifdef BAD_CERT_LISTENER2
+#include "nsIBadCertListener2.h"
+#endif
 #include "nsICertificateDialogs.h"
 #include "nsIClientAuthDialogs.h"
 #include "nsICertPickDialogs.h"
 #include "nsITokenDialogs.h"
 #include "nsIDOMCryptoDialogs.h"
 #include "nsIGenKeypairInfoDlg.h"
 
 #include "nsCOMPtr.h"
@@ -54,27 +57,33 @@
 
 #define NS_NSSDIALOGS_CID \
   { 0x518e071f, 0x1dd2, 0x11b2, \
     { 0x93, 0x7e, 0xc4, 0x5f, 0x14, 0xde, 0xf7, 0x78 }}
 
 class nsNSSDialogs
 : public nsITokenPasswordDialogs,
   public nsIBadCertListener,
+#ifdef BAD_CERT_LISTENER2
+  public nsIBadCertListener2,
+#endif
   public nsICertificateDialogs,
   public nsIClientAuthDialogs,
   public nsICertPickDialogs,
   public nsITokenDialogs,
   public nsIDOMCryptoDialogs,
   public nsIGeneratingKeypairInfoDialogs
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSITOKENPASSWORDDIALOGS
   NS_DECL_NSIBADCERTLISTENER
+#ifdef BAD_CERT_LISTENER2
+    NS_DECL_NSIBADCERTLISTENER2
+#endif
   NS_DECL_NSICERTIFICATEDIALOGS
   NS_DECL_NSICLIENTAUTHDIALOGS
   NS_DECL_NSICERTPICKDIALOGS
   NS_DECL_NSITOKENDIALOGS
   NS_DECL_NSIDOMCRYPTODIALOGS
   NS_DECL_NSIGENERATINGKEYPAIRINFODIALOGS
   nsNSSDialogs();
   virtual ~nsNSSDialogs();
Index: security/manager/pki/src/Makefile.in
===================================================================
--- security/manager/pki/src/Makefile.in.orig
+++ security/manager/pki/src/Makefile.in
@@ -76,15 +76,17 @@ REQUIRES	= nspr \
 		  pipnss \
 		  layout \
 		  $(NULL)
 
 INCLUDES	+= \
 		-I$(DIST)/public/nss \
 		$(NULL)
 
+DEFINES += -DBAD_CERT_LISTENER2
+
 EXTRA_DSO_LDOPTS += \
 		$(MOZ_COMPONENT_LIBS) \
 		$(MOZ_JS_LIBS) \
 		$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
