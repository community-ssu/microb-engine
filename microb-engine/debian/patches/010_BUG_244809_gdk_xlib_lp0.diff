#244809
#nsRenderingContextGTK::FillPolygon shouldn't use gdk_draw_polygon
Index: gfx/src/gtk/nsDrawingSurfaceGTK.h
===================================================================
--- gfx/src/gtk/nsDrawingSurfaceGTK.h.orig
+++ gfx/src/gtk/nsDrawingSurfaceGTK.h
@@ -96,17 +96,17 @@
   NS_IMETHOD IsPixelAddressable(PRBool *aAddressable);
   NS_IMETHOD GetPixelFormat(nsPixelFormat *aFormat);
 
 /* below are utility functions used mostly for nsRenderingContext and nsImage
  * to plug into gdk_* functions for drawing.  You should not set a pointer
  * that might hang around with the return from these.  instead use the ones
  * above.  pav
  */
-  GdkDrawable *GetDrawable(void) { return mPixmap; }
+  inline GdkDrawable *GetDrawable(void) { return mPixmap; }
 
   void GetSize(PRUint32 *aWidth, PRUint32 *aHeight) { *aWidth = mWidth; *aHeight = mHeight; }
 
   PRInt32 GetDepth() { return mDepth; }
 
 #ifdef MOZ_ENABLE_XFT
   XftDraw *GetXftDraw     (void);
   void     GetLastXftClip (nsIRegion **aLastRegion);
Index: gfx/src/gtk/nsRenderingContextGTK.cpp
===================================================================
--- gfx/src/gtk/nsRenderingContextGTK.cpp.orig
+++ gfx/src/gtk/nsRenderingContextGTK.cpp
@@ -131,16 +131,17 @@
                                           nsIWidget *aWindow)
 {
   mContext = aContext;
   NS_IF_ADDREF(mContext);
 
 //  ::gdk_rgb_init();
 
   mSurface = new nsDrawingSurfaceGTK();
+  mDisplay = GDK_DISPLAY();
 
   if (mSurface)
   {
     if (!aWindow) return NS_ERROR_NULL_POINTER;
 
     // we want to ref the window here so that we can unref in the drawing surface.
     // otherwise, we can not unref and that causes windows that are created in the
     // drawing surface not to be freed.
@@ -604,17 +605,17 @@
   }
 
   mGC = gcCache->GetGC(mOffscreenSurface->GetDrawable(),
                        &values,
                        valuesMask,
                        rgn);
 
   if (mDashes)
-    ::XSetDashes(GDK_DISPLAY(), GDK_GC_XGC(mGC),
+    ::XSetDashes(mDisplay, GDK_GC_XGC(mGC),
                  0, mDashList, mDashes);
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::SetClipRegion(const nsIRegion& aRegion,
                                                    nsClipCombine aCombine)
 {
   CreateClipRegion();
 
@@ -860,46 +861,49 @@
     diffX = (diffX>0?1:-1);
   }
   if (0!=diffY) {
     diffY = (diffY>0?1:-1);
   }
 
   UpdateGC();
 
-  ::gdk_draw_line(mSurface->GetDrawable(),
-                  mGC,
-                  aX0, aY0, aX1-diffX, aY1-diffY);
+  ::XDrawLine(mDisplay, GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+              GDK_GC_XGC(mGC), aX0, aY0, aX1 - diffX, aY1 - diffY);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawPolyline(const nsPoint aPoints[], PRInt32 aNumPoints)
 {
-  PRInt32 i;
+  NS_ENSURE_TRUE(mTranMatrix != nsnull, NS_ERROR_FAILURE);
+  NS_ENSURE_TRUE(mSurface    != nsnull, NS_ERROR_FAILURE);
 
-  g_return_val_if_fail(mTranMatrix != NULL, NS_ERROR_FAILURE);
-  g_return_val_if_fail(mSurface != NULL, NS_ERROR_FAILURE);
-
-  GdkPoint *pts = new GdkPoint[aNumPoints];
-  for (i = 0; i < aNumPoints; i++)
-  {
-    nsPoint p = aPoints[i];
-    mTranMatrix->TransformCoord(&p.x,&p.y);
-    pts[i].x = p.x;
-    pts[i].y = p.y;
+  PRInt32  i;
+  XPoint * xpoints;
+  XPoint * thispoint;
+
+  xpoints = (XPoint *) malloc(sizeof(XPoint) * aNumPoints);
+  NS_ENSURE_TRUE(xpoints != nsnull, NS_ERROR_OUT_OF_MEMORY);
+
+  for (i = 0; i < aNumPoints; i++){
+    thispoint = (xpoints+i);
+    thispoint->x = aPoints[i].x;
+    thispoint->y = aPoints[i].y;
+    mTranMatrix->TransformCoord((PRInt32*)&thispoint->x,(PRInt32*)&thispoint->y);
   }
 
   UpdateGC();
 
-  ::gdk_draw_lines(mSurface->GetDrawable(),
-                   mGC,
-                   pts, aNumPoints);
+  ::XDrawLines(mDisplay,
+               GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+               GDK_GC_XGC(mGC),
+               xpoints, aNumPoints, CoordModeOrigin);
 
-  delete[] pts;
+  free((void *)xpoints);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawRect(const nsRect& aRect)
 {
   return DrawRect(aRect.x, aRect.y, aRect.width, aRect.height);
 }
@@ -928,21 +932,24 @@
   ConditionRect(x,y,w,h);
 
   // Don't draw empty rectangles; also, w/h are adjusted down by one
   // so that the right number of pixels are drawn.
   if (w && h) {
 
     UpdateGC();
 
-    ::gdk_draw_rectangle(mSurface->GetDrawable(), mGC,
-                         FALSE,
-                         x, y,
-                         w - 1,
-                         h - 1);
+    ::XDrawRectangle(mDisplay,
+                     GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+                     GDK_GC_XGC(mGC),
+                     x,
+                     y,
+                     w-1,
+                     h-1);
+
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::FillRect(const nsRect& aRect)
 {
   return FillRect(aRect.x, aRect.y, aRect.width, aRect.height);
@@ -965,19 +972,23 @@
 
   // After the transform, if the numbers are huge, chop them, because
   // they're going to be converted from 32 bit to 16 bit.
   // It's all way off the screen anyway.
   ConditionRect(x,y,w,h);
 
   UpdateGC();
 
-  ::gdk_draw_rectangle(mSurface->GetDrawable(), mGC,
-                       TRUE,
-                       x, y, w, h);
+  if (!mDisplay)
+    mDisplay = GDK_DISPLAY();
+
+  ::XFillRectangle(mDisplay,
+                   GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+                   GDK_GC_XGC(mGC),
+                   x,y,w,h);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::InvertRect(const nsRect& aRect)
 {
   return InvertRect(aRect.x, aRect.y, aRect.width, aRect.height);
 }
@@ -1006,71 +1017,91 @@
   // It's all way off the screen anyway.
   ConditionRect(x,y,w,h);
 
   mFunction = GDK_XOR;
 
   UpdateGC();
 
   // Fill the rect
-  ::gdk_draw_rectangle(mSurface->GetDrawable(), mGC,
-                       TRUE,
-                       x, y, w, h);
+  ::XFillRectangle(mDisplay,
+                   GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+                   GDK_GC_XGC(mGC),
+                   x,
+                   y,
+                   w,
+                   h);
 
   // Back to normal copy drawing mode
   mFunction = GDK_COPY;
 
   // Restore current color
   mCurrentColor = backupColor;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawPolygon(const nsPoint aPoints[], PRInt32 aNumPoints)
 {
-  g_return_val_if_fail(mTranMatrix != NULL, NS_ERROR_FAILURE);
-  g_return_val_if_fail(mSurface != NULL, NS_ERROR_FAILURE);
 
-  GdkPoint *pts = new GdkPoint[aNumPoints];
-  for (PRInt32 i = 0; i < aNumPoints; i++)
-  {
-    nsPoint p = aPoints[i];
-    mTranMatrix->TransformCoord(&p.x,&p.y);
-    pts[i].x = p.x;
-    pts[i].y = p.y;
+  NS_ENSURE_TRUE(mTranMatrix != nsnull, NS_ERROR_FAILURE);
+  NS_ENSURE_TRUE(mSurface    != nsnull, NS_ERROR_FAILURE);
+
+  PRInt32 i ;
+  XPoint * xpoints;
+  XPoint * thispoint;
+
+  xpoints = (XPoint *) malloc(sizeof(XPoint) * aNumPoints);
+  NS_ENSURE_TRUE(xpoints != nsnull, NS_ERROR_OUT_OF_MEMORY);
+
+  for (i = 0; i < aNumPoints; i++){
+    thispoint = (xpoints+i);
+    thispoint->x = aPoints[i].x;
+    thispoint->y = aPoints[i].y;
+    mTranMatrix->TransformCoord((PRInt32*)&thispoint->x,(PRInt32*)&thispoint->y);
   }
 
   UpdateGC();
 
-  ::gdk_draw_polygon(mSurface->GetDrawable(), mGC, FALSE, pts, aNumPoints);
+  ::XDrawLines(mDisplay,
+               GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+               GDK_GC_XGC(mGC),
+               xpoints, aNumPoints, CoordModeOrigin);
 
-  delete[] pts;
+  free((void *)xpoints);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::FillPolygon(const nsPoint aPoints[], PRInt32 aNumPoints)
 {
   g_return_val_if_fail(mTranMatrix != NULL, NS_ERROR_FAILURE);
   g_return_val_if_fail(mSurface != NULL, NS_ERROR_FAILURE);
 
-  GdkPoint *pts = new GdkPoint[aNumPoints];
-  for (PRInt32 i = 0; i < aNumPoints; i++)
-  {
+  PRInt32 i ;
+  XPoint * xpoints;
+
+  xpoints = (XPoint *) malloc(sizeof(XPoint) * aNumPoints);
+  NS_ENSURE_TRUE(xpoints != nsnull, NS_ERROR_OUT_OF_MEMORY);
+
+  for (i = 0; i < aNumPoints; ++i) {
     nsPoint p = aPoints[i];
-    mTranMatrix->TransformCoord(&p.x,&p.y);
-    pts[i].x = p.x;
-    pts[i].y = p.y;
+    mTranMatrix->TransformCoord(&p.x, &p.y);
+    xpoints[i].x = p.x;
+    xpoints[i].y = p.y;
   }
 
   UpdateGC();
 
-  ::gdk_draw_polygon(mSurface->GetDrawable(), mGC, TRUE, pts, aNumPoints);
+  ::XFillPolygon(mDisplay,
+                 GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+                 GDK_GC_XGC(mGC),
+                 xpoints, aNumPoints, Complex, CoordModeOrigin);
 
-  delete[] pts;
+  free((void *)xpoints);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawEllipse(const nsRect& aRect)
 {
   return DrawEllipse(aRect.x, aRect.y, aRect.width, aRect.height);
 }
@@ -1086,19 +1117,20 @@
   y = aY;
   w = aWidth;
   h = aHeight;
 
   mTranMatrix->TransformCoord(&x,&y,&w,&h);
 
   UpdateGC();
 
-  ::gdk_draw_arc(mSurface->GetDrawable(), mGC, FALSE,
-                 x, y, w, h,
-                 0, 360 * 64);
+  ::XDrawArc(mDisplay,
+             GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+             GDK_GC_XGC(mGC),
+             x, y, w, h, 0, 360 * 64);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::FillEllipse(const nsRect& aRect)
 {
   return FillEllipse(aRect.x, aRect.y, aRect.width, aRect.height);
 }
@@ -1118,24 +1150,26 @@
   mTranMatrix->TransformCoord(&x,&y,&w,&h);
 
   UpdateGC();
 
   if (w < 16 || h < 16) {
     /* Fix for bug 91816 ("bullets are not displayed correctly on certain text zooms")
      * De-uglify bullets on some X servers:
      * 1st: Draw... */
-    ::gdk_draw_arc(mSurface->GetDrawable(), mGC, FALSE,
-                   x, y, w, h,
-                   0, 360 * 64);
+     ::XDrawArc(mDisplay,
+               GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+               GDK_GC_XGC(mGC),
+               x, y, w, h, 0, 360*64);
     /*  ...then fill. */
   }
-  ::gdk_draw_arc(mSurface->GetDrawable(), mGC, TRUE,
-                 x, y, w, h,
-                 0, 360 * 64);
+  ::XFillArc(mDisplay,
+             GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+             GDK_GC_XGC(mGC),
+             x, y, w, h, 0, 360*64);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawArc(const nsRect& aRect,
                                              float aStartAngle, float aEndAngle)
 {
   return DrawArc(aRect.x,aRect.y,aRect.width,aRect.height,aStartAngle,aEndAngle);
@@ -1154,20 +1188,21 @@
   y = aY;
   w = aWidth;
   h = aHeight;
 
   mTranMatrix->TransformCoord(&x,&y,&w,&h);
 
   UpdateGC();
 
-  ::gdk_draw_arc(mSurface->GetDrawable(), mGC, FALSE,
-                 x, y, w, h,
-                 NSToIntRound(aStartAngle * 64.0f),
-                 NSToIntRound(aEndAngle * 64.0f));
+  ::XDrawArc(mDisplay,
+             GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+             GDK_GC_XGC(mGC),
+             x,y,w,h, NSToIntRound(aStartAngle * 64.0f),
+             NSToIntRound(aEndAngle * 64.0f));
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::FillArc(const nsRect& aRect,
                                              float aStartAngle, float aEndAngle)
 {
   return FillArc(aRect.x,aRect.y,aRect.width,aRect.height,aStartAngle,aEndAngle);
@@ -1187,20 +1222,21 @@
   y = aY;
   w = aWidth;
   h = aHeight;
 
   mTranMatrix->TransformCoord(&x,&y,&w,&h);
 
   UpdateGC();
 
-  ::gdk_draw_arc(mSurface->GetDrawable(), mGC, TRUE,
-                 x, y, w, h,
-                 NSToIntRound(aStartAngle * 64.0f),
-                 NSToIntRound(aEndAngle * 64.0f));
+  ::XFillArc(mDisplay,
+             GDK_DRAWABLE_XID(mSurface->GetDrawable()),
+             GDK_GC_XGC(mGC),
+             x,y,w,h, NSToIntRound(aStartAngle * 64.0f),
+             NSToIntRound(aEndAngle * 64.0f));
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsRenderingContextGTK::GetWidth(char aC, nscoord &aWidth)
 {
     // Check for the very common case of trying to get the width of a single
Index: gfx/src/gtk/nsRenderingContextGTK.h
===================================================================
--- gfx/src/gtk/nsRenderingContextGTK.h.orig
+++ gfx/src/gtk/nsRenderingContextGTK.h
@@ -48,16 +48,17 @@
 #include "nsIWidget.h"
 #include "nsRect.h"
 #include "nsIDeviceContext.h"
 #include "nsVoidArray.h"
 #include "nsGfxCIID.h"
 #include "nsDrawingSurfaceGTK.h"
 #include "nsRegionGTK.h"
 #include "nsIFontMetricsGTK.h"
+#include "X11/Xlib.h"
 
 #include <gtk/gtk.h>
 
 class nsRenderingContextGTK : public nsRenderingContextImpl
 {
 public:
   nsRenderingContextGTK();
   virtual ~nsRenderingContextGTK();
@@ -282,16 +283,17 @@
 
   GdkGC                 *mGC;
   GdkFunction            mFunction;
   GdkLineStyle           mLineStyle;
   char                   mDashList[2];
   int                    mDashes;
   nscolor                mCurrentColor;
   nsLineStyle            mCurrentLineStyle;
+  Display                *mDisplay;
 
   // ConditionRect is used to fix coordinate overflow problems for
   // rectangles after they are transformed to screen coordinates
   void ConditionRect(nscoord &x, nscoord &y, nscoord &w, nscoord &h) {
     if ( y < -32766 ) {
       y = -32766;
     }
 
