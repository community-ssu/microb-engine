diff -U8 -prN mozilla-orig/toolkit/components/Makefile.in mozilla/toolkit/components/Makefile.in
--- mozilla-orig/toolkit/components/Makefile.in	2008-01-15 10:22:25.000000000 -0400
+++ mozilla/toolkit/components/Makefile.in	2008-01-15 10:41:12.000000000 -0400
@@ -62,17 +62,17 @@ DIRS += \
 
 ifneq (,$(filter cocoa, $(MOZ_WIDGET_TOOLKIT)))
 TOOL_DIRS += alerts
 else
 DIRS += alerts
 endif
 
 ifdef MOZ_FEEDS
-DIRS += feeds
+DIRS += feeds browser-feeds
 endif
 
 ifdef MOZ_PLACES
 ifdef MOZ_STORAGE
 DIRS += places
 endif
 endif
 
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/Makefile.in mozilla/toolkit/components/browser-feeds/Makefile.in
--- mozilla-orig/toolkit/components/browser-feeds/Makefile.in	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/Makefile.in	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,46 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Feed Handling System
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Ben Goodger <beng@google.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+DIRS = public src
+
+include $(topsrcdir)/config/rules.mk
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/content/subscribe.css mozilla/toolkit/components/browser-feeds/content/subscribe.css
--- mozilla-orig/toolkit/components/browser-feeds/content/subscribe.css	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/content/subscribe.css	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,154 @@
+
+*[hidden] {
+  display: none;
+}
+
+html {
+  background: -moz-Dialog;
+  font: 3mm tahoma,arial,helvetica,sans-serif;
+}
+
+#feedBody {
+  border: 1px solid THreeDShadow;
+  padding: 3em;
+  -moz-padding-start: 30px;
+  margin: 2em auto;
+  background: -moz-Field;
+}
+
+#feedHeaderContainer {
+  border: 1px solid ThreeDShadow;
+  -moz-border-radius: 10px;
+  margin: -4em auto 0 auto;
+  background-color: InfoBackground;
+}
+
+#feedHeader {  
+  margin-top: 4.9em;
+  margin-bottom: 1em;
+  -moz-margin-start: 1.4em;
+  -moz-margin-end: 1em;
+  -moz-padding-start: 2.9em;
+  font-size: 110%;
+  background: url("chrome://browser/skin/feeds/feedIcon.png") 0% 10% no-repeat InfoBackground;
+  color: InfoText;
+}
+
+#feedHeader[dir="rtl"] {
+  background-position: 100% 10%;
+}
+
+#feedIntroText {
+  display: none;
+}
+
+#feedHeader[firstrun="true"] #feedIntroText {
+  padding-top: 0.1em;
+  -moz-padding-start: 0.6em;
+  display: block;
+}
+
+#feedHeader[firstrun="true"] > #feedSubscribeLine {
+  -moz-padding-start: 1.8em;
+}
+
+#feedSubscribeLine {
+  padding-top: 0.2em;
+}
+
+#alwaysUse {
+  padding: 5px;
+}
+
+
+#handlersMenuList > menupopup > menuitem {
+  -moz-padding-start: 23px;
+}
+
+#handlersMenuList > menupopup > menuitem.menuitem-iconic {
+  -moz-padding-start: 2px;
+}
+
+#handlersMenuList > menupopup > .menuitem-iconic  > .menu-iconic-left {
+  display: -moz-box;
+  min-width: 16px;
+  -moz-padding-end: 2px;
+}
+
+#feedHeader[dir="rtl"] #handlersMenuList > menupopup {
+  direction: rtl;
+}
+
+/* Don't print subscription UI */
+@media print {
+  #feedHeaderContainer {
+    display: none;
+  }
+}
+
+body {
+  margin: 0;
+  padding: 0 3em;
+  color: -moz-fieldText;
+  font: message-box;
+}
+
+h1 {
+  font-size: 160%;
+  border-bottom: 2px solid ThreeDLightShadow;
+  margin: 0 0 .2em 0;
+}
+
+h2 {
+  color: ThreeDDarkShadow;
+  font-size: 110%;
+  font-weight: normal;
+  margin: 0 0 .6em 0;
+}
+
+#feedTitleLink {
+  float: right;
+  -moz-margin-start: .6em;
+  -moz-margin-end: 0;
+  margin-top: 0;
+  margin-bottom: 0;
+}
+
+a[href] img {
+  border: none;
+}
+
+#feedTitleContainer {
+  -moz-margin-start: 0;
+  -moz-margin-end: .6em;
+  margin-top: 0;
+  margin-bottom: 0;
+}
+
+#feedTitleImage {
+  -moz-margin-start: .6em;
+  -moz-margin-end: 0;
+  margin-top: 0;
+  margin-bottom: 0;
+  max-width: 300px;
+  max-height: 150px;
+}
+
+.feedEntryContent {
+  font-size: 110%;
+}
+ 
+.link {
+  color: #0000FF;
+  text-decoration: underline;
+  cursor: pointer;
+}
+
+.link:hover:active {
+  color: #FF0000;
+}
+
+.lastUpdated {
+  font-size: 85%;
+  font-weight: normal;
+}
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/content/subscribe.dtd mozilla/toolkit/components/browser-feeds/content/subscribe.dtd
--- mozilla-orig/toolkit/components/browser-feeds/content/subscribe.dtd	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/content/subscribe.dtd	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,16 @@
+<!ENTITY feedPage.title
+  "Viewing Feed">
+<!ENTITY feedSubscriptionInfo1a
+  "This is a &#8220;">
+<!ENTITY feedName
+  "feed">
+<!ENTITY feedSubscriptionInfo1b
+  "&#8221; of frequently changing content on this site.">
+<!ENTITY feedSubscriptionInfo2
+  "You can subscribe to this feed to receive updates when this content changes.">
+<!ENTITY feedSubscribeNow
+  "Subscribe Now">
+<!ENTITY subscribeUsing
+  "Subscribe to this feed using ">
+<!ENTITY feedLiveBookmarks
+  "Live Bookmarks">
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/content/subscribe.js mozilla/toolkit/components/browser-feeds/content/subscribe.js
--- mozilla-orig/toolkit/components/browser-feeds/content/subscribe.js	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/content/subscribe.js	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Subscribe Handler.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Asaf Romano <mano@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var SubscribeHandler = {
+  /**
+   * The nsIFeedWriter object that produces the UI
+   */
+  _feedWriter: null,
+  
+  init: function SH_init() {
+    this._feedWriter = new BrowserFeedWriter();
+    this._feedWriter.init(window);
+  },
+
+  writeContent: function SH_writeContent() {
+    this._feedWriter.writeContent();
+  },
+
+  uninit: function SH_uninit() {
+    this._feedWriter.close();
+  },
+  
+  subscribe: function FH_subscribe() {
+   this._feedWriter.subscribe();
+  }
+};
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/content/subscribe.xhtml mozilla/toolkit/components/browser-feeds/content/subscribe.xhtml
--- mozilla-orig/toolkit/components/browser-feeds/content/subscribe.xhtml	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/content/subscribe.xhtml	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,100 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<!DOCTYPE html [
+  <!ENTITY % htmlDTD
+    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+    "DTD/xhtml1-strict.dtd">
+  %htmlDTD;
+  <!ENTITY % globalDTD
+    SYSTEM "chrome://global/locale/global.dtd">
+  %globalDTD;
+  <!ENTITY % feedDTD
+    SYSTEM "chrome://browser/content/feeds/subscribe.dtd">
+  %feedDTD;
+]>
+
+<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
+
+<html id="feedHandler"
+      xmlns="http://www.w3.org/1999/xhtml"
+      xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+      xmlns:aaa="http://www.w3.org/2005/07/aaa">
+  <head>
+    <title>&feedPage.title;</title>
+    <link rel="stylesheet"
+          href="chrome://browser/content/feeds/subscribe.css"
+          type="text/css"
+          media="all"/>
+    <script type="application/x-javascript"
+            src="chrome://browser/content/feeds/subscribe.js"/>
+  </head>
+  <body onload="SubscribeHandler.writeContent();" onunload="SubscribeHandler.uninit();">
+    <div id="feedHeaderContainer">
+      <div id="feedHeader" dir="&locale.dir;">
+        <div id="feedIntroText">
+          <p id="feedSubscriptionInfo1">
+            &feedSubscriptionInfo1a;<strong>&feedName;</strong>&feedSubscriptionInfo1b;
+          </p>
+          <p id="feedSubscriptionInfo2">&feedSubscriptionInfo2;</p>
+        </div>
+
+<!-- XXXmano this can't have any whitespace in it.  Otherwise you would see
+     how much XUL-in-XHTML sucks, see bug 348830 -->
+        <div id="feedSubscribeLine">
+          <form>
+            Subscribe to this feed using
+            <select id="handlersMenuList">
+              <option webhandlerurl="http://fusion.google.com/add?feedurl=%s">  Google  </option>
+              <option webhandlerurl="http://add.my.yahoo.com/rss?url=%s">  Yahoo  </option>
+              <option webhandlerurl="http://www.bloglines.com/login?r=/sub/%s"> Bloglines  </option>
+            </select>
+            <br/>
+            <br/>
+            <input type="checkbox" name="alwaysUse" id="alwaysUse"/> Always use this reader
+            <br/>
+            <br/>
+            <input type="button" value="Subscribe" id="subscribeButton"/>
+          </form>
+	</div
+      ></div>
+    </div>
+
+	  <!--
+	  <xul:vbox>
+            <xul:hbox align="center">
+              <xul:description id="subscribeUsingDescription">&subscribeUsing;               </xul:description>
+              <xul:menulist id="handlersMenuList" aaa:labelledby="subscribeUsingDescription">
+                <xul:menupopup menugenerated="true" id="handlersMenuPopup">
+                    <xul:menuitem id="liveBookmarksMenuItem" label="&feedLiveBookmarks;" class="menuitem-iconic" image="chrome://browser/skin/page-livemarks.png" selected="true"/>
+                    <xul:menuseparator/>
+                </xul:menupopup>
+              </xul:menulist>
+            </xul:hbox>
+            <xul:hbox>
+              <xul:checkbox id="alwaysUse" checked="false"/>
+            </xul:hbox>
+            <xul:hbox align="center">
+                <xul:spacer flex="1"/>
+                <xul:button label="&feedSubscribeNow;" id="subscribeButton"/>
+            </xul:hbox>
+        </xul:vbox>
+	-->
+
+    <script type="application/x-javascript">
+      SubscribeHandler.init();
+    </script>
+
+    <div id="feedBody">
+      <div id="feedTitle">
+        <a id="feedTitleLink">
+          <img id="feedTitleImage"/>
+        </a>
+        <div id="feedTitleContainer">
+          <h1 id="feedTitleText"/>
+          <h2 id="feedSubtitleText"/>
+        </div>
+      </div>
+      <div id="feedContent"/>
+    </div>
+  </body>
+</html>
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/jar.mn mozilla/toolkit/components/browser-feeds/jar.mn
--- mozilla-orig/toolkit/components/browser-feeds/jar.mn	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/jar.mn	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,8 @@
+browser.jar:
+% content browser %content/browser/ xpcnativewrappers=yes
+* content/browser/feeds/subscribe.xhtml               (content/subscribe.xhtml) 
+* content/browser/feeds/subscribe.js                  (content/subscribe.js)
+* content/browser/feeds/subscribe.dtd                 (content/subscribe.dtd)
+* content/browser/feeds/subscribe.css                 (content/subscribe.css)
+
+
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/public/Makefile.in mozilla/toolkit/components/browser-feeds/public/Makefile.in
--- mozilla-orig/toolkit/components/browser-feeds/public/Makefile.in	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/public/Makefile.in	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,50 @@
+#
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is mozilla.org code.
+#
+# The Initial Developer of the Original Code is
+# Netscape Communications Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2001
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH   = ../../../..
+topsrcdir = @top_srcdir@
+srcdir    = @srcdir@
+VPATH   = @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = browser-feeds
+XPIDL_MODULE  = browser-feeds
+
+XPIDLSRCS = nsIFeedResultService.idl nsIWebContentConverterRegistrar.idl nsIFeedWriter.idl
+
+include $(topsrcdir)/config/rules.mk
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/public/nsIFeedResultService.idl mozilla/toolkit/components/browser-feeds/public/nsIFeedResultService.idl
--- mozilla-orig/toolkit/components/browser-feeds/public/nsIFeedResultService.idl	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/public/nsIFeedResultService.idl	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Result Service.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Robert Sayre <sayrer@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+interface nsIURI;
+interface nsIRequest;
+interface nsIFeedResult;
+
+/**
+ * nsIFeedResultService provides a globally-accessible object for retreiving
+ * the results of feed processing.
+ */
+[scriptable, uuid(f3262589-48b2-4019-9947-90e5269bbfb9)]
+interface nsIFeedResultService : nsISupports
+{
+  /**
+   * When set to true, forces the preview page to be displayed, regardless
+   * of the user's preferences.
+   */
+  attribute boolean forcePreviewPage;
+
+  /**
+   * Adds a URI to the user's specified external feed handler, or live 
+   * bookmarks. 
+   * @param   uri
+   *          The uri of the feed to add.
+   * @param   title
+   *          The title of the feed to add.
+   * @param   subtitle
+   *          The subtitle of the feed to add.
+   */
+  void addToClientReader(in AUTF8String uri, 
+                         in AString title,
+                         in AString subtitle);
+
+  /**
+   * Registers a Feed Result object with a globally accessible service
+   * so that it can be accessed by a singleton method outside the usual
+   * flow of control in document loading.
+   *
+   * @param   feedResult
+   *          An object implementing nsIFeedResult representing the feed.
+   */
+  void addFeedResult(in nsIFeedResult feedResult);
+
+  /**
+   * Gets a Feed Handler object registered using addFeedResult.
+   *
+   * @param   uri
+   *          The URI of the feed a handler is being requested for
+   */
+  nsIFeedResult getFeedResult(in nsIURI uri);
+
+  /**
+   * Unregisters a Feed Handler object registered using addFeedResult.
+   * @param   uri
+   *          The feed URI the handler was registered under. This must be
+   *          the same *instance* the feed was registered under.
+   */
+  void removeFeedResult(in nsIURI uri);
+};
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/public/nsIFeedWriter.idl mozilla/toolkit/components/browser-feeds/public/nsIFeedWriter.idl
--- mozilla-orig/toolkit/components/browser-feeds/public/nsIFeedWriter.idl	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/public/nsIFeedWriter.idl	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Writer.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Asaf Romano <mano@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIDOMWindow;
+
+/**
+ * Instances of this component write UI into the display page. This component
+ * is trusted so can access preferences etc, but page content isn't and so
+ * cannot.
+ */
+[scriptable, uuid(67003393-018c-4e96-af10-c6c51a049fad)]
+interface nsIFeedWriter : nsISupports
+{
+  /**
+   * Initializes the feed writer and loads the feed subscription UI.
+   * @param  aWindow
+   *         The DOMWindow of the preview page.
+   *         window.location.href == the URI of the feed.
+   */
+  void init(in nsIDOMWindow aWindow);
+
+  /**
+   * Writes the feed content, assumes that the feed writer is initialized.
+   */
+  void writeContent();
+
+  /**
+   * Uninitialize the feed writer.
+   */
+  void close();
+};
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/public/nsIWebContentConverterRegistrar.idl mozilla/toolkit/components/browser-feeds/public/nsIWebContentConverterRegistrar.idl
--- mozilla-orig/toolkit/components/browser-feeds/public/nsIWebContentConverterRegistrar.idl	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/public/nsIWebContentConverterRegistrar.idl	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,185 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Web Content Converter Registrar.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIRequest;
+
+[scriptable, uuid(2bd97d63-e928-4d52-9fd4-34061349a9a6)]
+interface nsIWebContentHandlerInfo : nsISupports
+{
+  /**
+   * The content type handled by the handler
+   */
+  readonly attribute AString contentType;
+
+  /**
+   * The uri of the handler, with an embedded %s where the URI of the loaded
+   * document will be encoded.
+   */
+  readonly attribute AString uri;
+
+  /**
+   * A human readable title of the handler.
+   */
+  readonly attribute AString name;
+
+  /** 
+   * Gets the service URL Spec, with the loading document URI encoded in it.
+   * @param   uri
+   *          The URI of the document being loaded
+   * @returns The URI of the service with the loading document URI encoded in 
+   *          it.
+   */
+  AString getHandlerURI(in AString uri);
+
+  /**
+   * Determines if this handler object is equivalent to another.
+   * @param   other
+   *          The other handler info object
+   * @returns true if the two objects are equivalent (same content type, 
+   *          same uri).
+   */
+  boolean equals(in nsIWebContentHandlerInfo other);
+};
+
+[scriptable, uuid(632b16a8-5c6b-4dc5-a8db-01771af7a79d)]
+interface nsIWebContentConverterService : nsISupports
+{
+  /**
+   * Specifies the handler to be used to automatically handle all links of a
+   * certain content type from now on. 
+   * @param   contentType
+   *          The content type to automatically load with the specified handler
+   * @param   handler
+   *          A web service handler. If this is null, no automatic action is
+   *          performed and the user must choose.
+   * @throws  NS_ERROR_NOT_AVAILABLE if the service refered to by |handler| is 
+   *          not already registered.
+   */
+  void setAutoHandler(in AString contentType, in nsIWebContentHandlerInfo handler);
+
+  /**
+   * Gets the auto handler specified for a particular content type
+   * @param   contentType
+   *          The content type to look up an auto handler for.
+   * @returns The web service handler that will automatically handle all 
+   *          documents of the specified type. null if there is no automatic
+   *          handler. (Handlers may be registered, just none of them specified
+   *          as "automatic").
+   */
+  nsIWebContentHandlerInfo getAutoHandler(in AString contentType);
+
+  /**
+   * Gets a web handler for the specified service URI
+   * @param   contentType
+   *          The content type of the service being located
+   * @param   uri
+   *          The service URI of the handler to locate.
+   * @returns A web service handler that uses the specified uri.
+   */
+  nsIWebContentHandlerInfo getWebContentHandlerByURI(in AString contentType, 
+                                                     in AString uri);
+
+  /**
+   * Loads the preferred handler when content of a registered type is about
+   * to be loaded.
+   * @param   request
+   *          The nsIRequest for the load of the content
+   */
+  void loadPreferredHandler(in nsIRequest request);
+
+  /**
+   * Removes a registered protocol handler
+   * @param   protocol
+   *          The protocol scheme to remove a service handler for
+   * @param   uri
+   *          The uri of the service handler to remove
+   */
+  void removeProtocolHandler(in AString protocol, in AString uri);
+
+  /**
+   * Removes a registered content handler
+   * @param   contentType
+   *          The content type to remove a service handler for
+   * @param   uri
+   *          The uri of the service handler to remove
+   */
+  void removeContentHandler(in AString contentType, in AString uri);
+
+  /**
+   * Registers a protocol handler for a web service
+   * @param   protocol
+   *          The protocol scheme to register a service handler for
+   * @param   uri
+   *          The uri of the service handler to register
+   * @param   title
+   *          The human readable title of the service
+   */
+  void registerProtocolHandler(in AString scheme, in AString uri, 
+                               in AString title);
+
+  /**
+   * Registers a content handler for a web service
+   * @param   contentType
+   *          The content type to register a service handler for
+   * @param   uri
+   *          The uri of the service handler to register
+   * @param   title
+   *          The human readable title of the service
+   */
+  void registerContentHandler(in AString contentType, in AString uri,
+                              in AString title);
+
+  /**
+   * Gets the list of content handlers for a particular type.
+   * @param   contentType
+   *          The content type to get handlers for
+   * @returns An array of nsIWebContentHandlerInfo objects
+   */
+  void getContentHandlers(in AString contentType, out unsigned long count,
+                          [retval,array,size_is(count)] out nsIWebContentHandlerInfo handlers);
+
+  /**
+   * Resets the list of available content handlers to the default set from
+   * the distribution.
+   * @param   contentType
+   *          The content type to reset handlers for
+   */
+  void resetHandlersForType(in AString contentType);
+};
+
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/FeedConverter.js mozilla/toolkit/components/browser-feeds/src/FeedConverter.js
--- mozilla-orig/toolkit/components/browser-feeds/src/FeedConverter.js	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/FeedConverter.js	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,595 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Feed Stream Converter.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#   Jeff Walden <jwalden+code@mit.edu>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+function LOG(str) {
+  dump("*** " + str + "\n");
+}
+
+const FC_CLASSID = Components.ID("{229fa115-9412-4d32-baf3-2fc407f76fb1}");
+const FC_CLASSNAME = "Feed Stream Converter";
+const FS_CLASSID = Components.ID("{2376201c-bbc6-472f-9b62-7548040a61c6}");
+const FS_CLASSNAME = "Feed Result Service";
+const FS_CONTRACTID = "@mozilla.org/browser/feeds/result-service;1";
+const FPH_CONTRACTID = "@mozilla.org/network/protocol;1?name=feed";
+const FPH_CLASSID = Components.ID("{4f91ef2e-57ba-472e-ab7a-b4999e42d6c0}");
+const FPH_CLASSNAME = "Feed Protocol Handler";
+const PCPH_CONTRACTID = "@mozilla.org/network/protocol;1?name=pcast";
+const PCPH_CLASSID = Components.ID("{1c31ed79-accd-4b94-b517-06e0c81999d5}");
+const PCPH_CLASSNAME = "Podcast Protocol Handler";
+
+const TYPE_MAYBE_FEED = "application/vnd.mozilla.maybe.feed";
+const TYPE_ANY = "*/*";
+
+const FEEDHANDLER_URI = "about:feeds";
+
+const PREF_SELECTED_APP = "browser.feeds.handlers.application";
+const PREF_SELECTED_WEB = "browser.feeds.handlers.webservice";
+const PREF_SELECTED_ACTION = "browser.feeds.handler";
+const PREF_SELECTED_READER = "browser.feeds.handler.default";
+
+function safeGetCharPref(pref, defaultValue) {
+  var prefs =   
+      Cc["@mozilla.org/preferences-service;1"].
+      getService(Ci.nsIPrefBranch);
+  try {
+    return prefs.getCharPref(pref);
+  }
+  catch (e) {
+  }
+  return defaultValue;
+}
+
+function FeedConverter() {
+}
+FeedConverter.prototype = {
+  /**
+   * This is the downloaded text data for the feed.
+   */
+  _data: null,
+  
+  /**
+   * This is the object listening to the conversion, which is ultimately the
+   * docshell for the load.
+   */
+  _listener: null,
+
+  /**
+   * Records if the feed was sniffed
+   */
+  _sniffed: false,
+  
+  /**
+   * See nsIStreamConverter.idl
+   */
+  canConvert: function FC_canConvert(sourceType, destinationType) {
+    // We only support one conversion.
+    return destinationType == TYPE_ANY && sourceType == TYPE_MAYBE_FEED;
+  },
+  
+  /**
+   * See nsIStreamConverter.idl
+   */
+  convert: function FC_convert(sourceStream, sourceType, destinationType, 
+                               context) {
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+  
+  /**
+   * See nsIStreamConverter.idl
+   */
+  asyncConvertData: function FC_asyncConvertData(sourceType, destinationType,
+                                                 listener, context) {
+    this._listener = listener;
+  },
+  
+  /**
+   * Whether or not the preview page is being forced.
+   */
+  _forcePreviewPage: false,
+  
+  /** 
+   * Release our references to various things once we're done using them.
+   */
+  _releaseHandles: function FC__releaseHandles() {
+    this._listener = null;
+    this._request = null;
+  },
+  
+  /**
+   * See nsIFeedResultListener.idl
+   */
+  handleResult: function FC_handleResult(result) {
+    // Feeds come in various content types, which our feed sniffer coerces to
+    // the maybe.feed type. However, feeds are used as a transport for 
+    // different data types, e.g. news/blogs (traditional feed), video/audio
+    // (podcasts) and photos (photocasts, photostreams). Each of these is 
+    // different in that there's a different class of application suitable for
+    // handling feeds of that type, but without a content-type differentiation
+    // it is difficult for us to disambiguate.
+    // 
+    // The other problem is that if the user specifies an auto-action handler
+    // for one feed application, the fact that the content type is shared means 
+    // that all other applications will auto-load with that handler too, 
+    // regardless of the content-type. 
+    //
+    // This means that content-type alone is not enough to determine whether
+    // or not a feed should be auto-handled. This means that for feeds we need
+    // to always use this stream converter, even when an auto-action is 
+    // specified, not the basic one provided by WebContentConverter. This 
+    // converter needs to consume all of the data and parse it, and based on
+    // that determination make a judgement about type. 
+    //
+    // Since there are no content types for this content, and I'm not going to
+    // invent any, the upshot is that while a user can set an auto-handler for
+    // generic feed content, the system will prevent them from setting an auto-
+    // handler for other stream types. In those cases, the user will always see
+    // the preview page and have to select a handler. We can guess and show 
+    // a client handler, but will not be able to show web handlers for those
+    // types.
+    //
+    // If this is just a feed, not some kind of specialized application, then
+    // auto-handlers can be set and we should obey them. 
+    try {
+      var feedService = 
+          Cc["@mozilla.org/browser/feeds/result-service;1"].
+          getService(Ci.nsIFeedResultService);
+      if (!this._forcePreviewPage && result.doc) {
+        var handler = safeGetCharPref(PREF_SELECTED_ACTION, "ask");
+        if (handler != "ask") {
+          if (handler == "reader")
+            handler = safeGetCharPref(PREF_SELECTED_READER, "bookmarks");
+          switch (handler) {
+            case "web":
+              var wccr = 
+                  Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+                  getService(Ci.nsIWebContentConverterService);
+              var feed = result.doc.QueryInterface(Ci.nsIFeed);
+              if (feed.type == Ci.nsIFeed.TYPE_FEED &&
+                  wccr.getAutoHandler(TYPE_MAYBE_FEED)) {
+                wccr.loadPreferredHandler(this._request);
+                return;
+              }
+              break;
+
+            default:
+              LOG("unexpected handler: " + handler);
+              // fall through -- let feed service handle error
+            case "bookmarks":
+            case "client":
+              try {
+                var feed = result.doc.QueryInterface(Ci.nsIFeed);
+                var title = feed.title ? feed.title.plainText() : "";
+                var desc = feed.subtitle ? feed.subtitle.plainText() : "";
+                feedService.addToClientReader(result.uri.spec, title, desc);
+                return;
+              } catch(ex) { /* fallback to preview mode */ }
+          }
+        }
+      }
+          
+      var ios = 
+          Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+      var chromeChannel;
+
+      // show the feed page if it wasn't sniffed and we have a document,
+      // or we have a document, title, and link or id
+      if (result.doc && (!this._sniffed ||
+          (result.doc.title && (result.doc.link || result.doc.id)))) {
+
+        // If there was no automatic handler, or this was a podcast,
+        // photostream or some other kind of application, we must always
+        // show the preview page.
+        
+        // Store the result in the result service so that the display
+        // page can access it.
+
+        feedService.addFeedResult(result);
+
+        // Now load the actual XUL document.
+        var chromeURI = ios.newURI(FEEDHANDLER_URI, null, null);
+        chromeChannel = ios.newChannelFromURI(chromeURI, null);
+        chromeChannel.originalURI = result.uri;
+      }
+      else
+        chromeChannel = ios.newChannelFromURI(result.uri, null);
+
+      chromeChannel.loadGroup = this._request.loadGroup;
+      chromeChannel.asyncOpen(this._listener, null);
+    }
+    finally {
+      this._releaseHandles();
+    }
+  },
+  
+  /**
+   * See nsIStreamListener.idl
+   */
+  onDataAvailable: function FC_onDataAvailable(request, context, inputStream, 
+                                               sourceOffset, count) {
+    this._processor.onDataAvailable(request, context, inputStream,
+                                    sourceOffset, count);
+  },
+  
+  /**
+   * See nsIRequestObserver.idl
+   */
+  onStartRequest: function FC_onStartRequest(request, context) {
+    var channel = request.QueryInterface(Ci.nsIChannel);
+
+    // Check for a header that tells us there was no sniffing
+    // The value doesn't matter.
+    try {
+      var httpChannel = channel.QueryInterface(Ci.nsIHttpChannel);
+      var noSniff = httpChannel.getResponseHeader("X-Moz-Is-Feed");
+    }
+    catch (ex) {
+      this._sniffed = true;
+    }
+
+    this._request = request;
+    
+    // Save and reset the forced state bit early, in case there's some kind of
+    // error.
+    var feedService = 
+        Cc["@mozilla.org/browser/feeds/result-service;1"].
+        getService(Ci.nsIFeedResultService);
+    this._forcePreviewPage = feedService.forcePreviewPage;
+    feedService.forcePreviewPage = false;
+
+    // Parse feed data as it comes in
+    this._processor =
+        Cc["@mozilla.org/feed-processor;1"].
+        createInstance(Ci.nsIFeedProcessor);
+    this._processor.listener = this;
+    this._processor.parseAsync(null, channel.URI);
+    
+    this._processor.onStartRequest(request, context);
+  },
+  
+  /**
+   * See nsIRequestObserver.idl
+   */
+  onStopRequest: function FC_onStopReqeust(request, context, status) {
+    this._processor.onStopRequest(request, context, status);
+  },
+  
+  /**
+   * See nsISupports.idl
+   */
+  QueryInterface: function FC_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFeedResultListener) ||
+        iid.equals(Ci.nsIStreamConverter) ||
+        iid.equals(Ci.nsIStreamListener) ||
+        iid.equals(Ci.nsIRequestObserver)||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+};
+
+var FeedConverterFactory = {
+  createInstance: function FS_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return new FeedConverter().QueryInterface(iid);
+  },
+
+  QueryInterface: function FS_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+};
+
+/**
+ * Keeps parsed FeedResults around for use elsewhere in the UI after the stream
+ * converter completes. 
+ */
+var FeedResultService = {
+  
+  /**
+   * A URI spec -> [nsIFeedResult] hash. We have to keep a list as the
+   * value in case the same URI is requested concurrently.
+   */
+  _results: { },
+  
+  /**
+   * See nsIFeedService.idl
+   */
+  forcePreviewPage: false,
+  
+  /**
+   * See nsIFeedService.idl
+   */
+  addToClientReader: function FRS_addToClientReader(spec, title, subtitle) {
+    var prefs =   
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefBranch);
+
+    var handler = safeGetCharPref(PREF_SELECTED_ACTION, "bookmarks");
+    if (handler == "ask" || handler == "reader")
+      handler = safeGetCharPref(PREF_SELECTED_READER, "bookmarks");
+
+    switch (handler) {
+    case "client":
+      var clientApp = prefs.getComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile);
+#ifdef XP_MACOSX
+      // On OS X, the built in feed dispatcher (Safari) sends feeds to other
+      // applications (When Default Reader is adjusted) in the following format:
+      //
+      // http urls: replace scheme with feed, e.g.
+      // http://foo.com/index.rdf -> feed://foo.com/index.rdf
+      // other urils: prepend feed: scheme, e.g.
+      // https://foo.com/index.rdf -> feed:https://foo.com/index.rdf
+      //
+      // We duplicate this here for compatibility. 
+      var ios = 
+          Cc["@mozilla.org/network/io-service;1"].
+          getService(Ci.nsIIOService);
+      var macURI = ios.newURI(spec, null, null);
+      if (macURI.schemeIs("http")) {
+        macURI.scheme = "feed";
+        spec = macURI.spec;
+      }
+      else
+        spec = "feed:" + spec;
+#endif
+      var ss = 
+          Cc["@mozilla.org/browser/shell-service;1"].
+          getService(Ci.nsIShellService);
+      ss.openApplicationWithURI(clientApp, spec);
+      break;
+
+    default:
+      // "web" should have been handled elsewhere
+      LOG("unexpected handler: " + handler);
+      // fall through
+    case "bookmarks":
+      var wm = 
+          Cc["@mozilla.org/appshell/window-mediator;1"].
+          getService(Ci.nsIWindowMediator);
+      var topWindow = wm.getMostRecentWindow("navigator:browser");
+#ifdef MOZ_PLACES_BOOKMARKS
+      topWindow.PlacesCommandHook.addLiveBookmark(spec, title, subtitle);
+#else
+      topWindow.FeedHandler.addLiveBookmark(spec, title, subtitle);
+#endif
+      break;
+    }
+  },
+  
+  /**
+   * See nsIFeedService.idl
+   */
+  addFeedResult: function FRS_addFeedResult(feedResult) {
+    NS_ASSERT(feedResult.uri != null, "null URI!");
+    NS_ASSERT(feedResult.uri != null, "null feedResult!");
+    var spec = feedResult.uri.spec;
+    if(!this._results[spec])  
+      this._results[spec] = [];
+    this._results[spec].push(feedResult);
+  },
+  
+  /**
+   * See nsIFeedService.idl
+   */
+  getFeedResult: function RFS_getFeedResult(uri) {
+    NS_ASSERT(uri != null, "null URI!");
+    var resultList = this._results[uri.spec];
+    for (var i in resultList) {
+      if (resultList[i].uri == uri)
+        return resultList[i];
+    }
+    return null;
+  },
+  
+  /**
+   * See nsIFeedService.idl
+   */
+  removeFeedResult: function FRS_removeFeedResult(uri) {
+    NS_ASSERT(uri != null, "null URI!");
+    var resultList = this._results[uri.spec];
+    if (!resultList)
+      return;
+    var deletions = 0;
+    for (var i = 0; i < resultList.length; ++i) {
+      if (resultList[i].uri == uri) {
+        delete resultList[i];
+        ++deletions;
+      }
+    }
+    
+    // send the holes to the end
+    resultList.sort();
+    // and trim the list
+    resultList.splice(resultList.length - deletions, deletions);
+    if (resultList.length == 0)
+      delete this._results[uri.spec];
+  },
+
+  createInstance: function FRS_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return this.QueryInterface(iid);
+  },
+  
+  QueryInterface: function FRS_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFeedResultService) ||
+        iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+};
+
+/**
+ * A protocol handler that converts the URIs of Apple's various bogo protocol
+ * schemes into http, as they should be. Mostly, this object just forwards 
+ * things through to the HTTP protocol handler.
+ */
+function FeedProtocolHandler(scheme) {
+  this._scheme = scheme;
+  var ios = 
+      Cc["@mozilla.org/network/io-service;1"].
+      getService(Ci.nsIIOService);
+  this._http = ios.getProtocolHandler("http");
+}
+FeedProtocolHandler.prototype = {
+  _scheme: "",
+  get scheme() {
+    return this._scheme;
+  },
+  
+  get protocolFlags() {
+    return this._http.protocolFlags;
+  },
+  
+  get defaultPort() {
+    return this._http.defaultPort;
+  },
+  
+  allowPort: function FPH_allowPort(port, scheme) {
+    return this._http.allowPort(port, scheme);
+  },
+  
+  newURI: function FPH_newURI(spec, originalCharset, baseURI) {
+    var uri = 
+        Cc["@mozilla.org/network/standard-url;1"].
+        createInstance(Ci.nsIStandardURL);
+    uri.init(Ci.nsIStandardURL.URLTYPE_STANDARD, 80, spec, originalCharset,
+             baseURI);
+    return uri;
+  },
+  
+  newChannel: function FPH_newChannel(uri) {
+    var ios = 
+        Cc["@mozilla.org/network/io-service;1"].
+        getService(Ci.nsIIOService);
+    // feed: URIs either start feed://, in which case the real scheme is http:
+    // or feed:http(s)://, (which by now we've changed to feed://realscheme//)
+    const httpsChunk = "feed://https//";
+    const httpChunk = "feed://http//";
+    if (uri.spec.substr(0, httpsChunk.length) == httpsChunk)
+      uri.spec = "https://" + uri.spec.substr(httpsChunk.length);
+    else if (uri.spec.substr(0, httpChunk.length) == httpChunk)
+      uri.spec = "http://" + uri.spec.substr(httpChunk.length);
+    else
+      uri.scheme = "http";
+
+    var channel =
+      ios.newChannelFromURI(uri, null).QueryInterface(Ci.nsIHttpChannel);
+    // Set this so we know this is supposed to be a feed
+    channel.setRequestHeader("X-Moz-Is-Feed", "1", false);
+    channel.originalURI = uri;
+    return channel;
+  },
+  
+  QueryInterface: function FPH_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIProtocolHandler) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }  
+};
+
+var Module = {
+  QueryInterface: function M_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIModule) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+  
+  getClassObject: function M_getClassObject(cm, cid, iid) {
+    if (!iid.equals(Ci.nsIFactory))
+      throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+    
+    if (cid.equals(FS_CLASSID))
+      return FeedResultService;
+    if (cid.equals(FPH_CLASSID))
+      return new GenericComponentFactory(FeedProtocolHandler, "feed");
+    if (cid.equals(PCPH_CLASSID))
+      return new GenericComponentFactory(FeedProtocolHandler, "pcast");
+    if (cid.equals(FC_CLASSID))
+      return new GenericComponentFactory(FeedConverter);
+      
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+  
+  registerSelf: function M_registerSelf(cm, file, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+    
+    cr.registerFactoryLocation(FS_CLASSID, FS_CLASSNAME, FS_CONTRACTID,
+                               file, location, type);
+    cr.registerFactoryLocation(FPH_CLASSID, FPH_CLASSNAME, FPH_CONTRACTID,
+                               file, location, type);
+    cr.registerFactoryLocation(PCPH_CLASSID, PCPH_CLASSNAME, PCPH_CONTRACTID,
+                               file, location, type);
+
+    // The feed converter is always attached, since parsing must be done to 
+    // determine whether or not auto-handling can occur. 
+    const converterPrefix = "@mozilla.org/streamconv;1?from=";
+    var converterContractID = 
+        converterPrefix + TYPE_MAYBE_FEED + "&to=" + TYPE_ANY;
+    cr.registerFactoryLocation(FC_CLASSID, FC_CLASSNAME, converterContractID,
+                               file, location, type);
+  },
+  
+  unregisterSelf: function M_unregisterSelf(cm, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+    cr.unregisterFactoryLocation(FPH_CLASSID, location);
+    cr.unregisterFactoryLocation(PCPH_CLASSID, location);
+  },
+  
+  canUnload: function M_canUnload(cm) {
+    return true;
+  }
+};
+
+function NSGetModule(cm, file) {
+  return Module;
+}
+
+#include ../../../../toolkit/content/debug.js
+#include GenericFactory.js
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/FeedWriter.js mozilla/toolkit/components/browser-feeds/src/FeedWriter.js
--- mozilla-orig/toolkit/components/browser-feeds/src/FeedWriter.js	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/FeedWriter.js	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,1284 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Feed Writer.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#   Jeff Walden <jwalden+code@mit.edu>
+#   Asaf Romano <mano@mozilla.com>
+#   Robert Sayre <sayrer@gmail.com>
+#   Michael Ventnor <m.ventnor@gmail.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+function LOG(str) {
+  var prefB = 
+    Cc["@mozilla.org/preferences-service;1"].
+    getService(Ci.nsIPrefBranch);
+
+  var shouldLog = false;
+  try {
+    shouldLog = prefB.getBoolPref("feeds.log");
+  } 
+  catch (ex) {
+  }
+
+  if (shouldLog)
+    dump("*** Feeds: " + str + "\n");
+}
+
+/**
+ * Wrapper function for nsIIOService::newURI.
+ * @param aURLSpec
+ *        The URL string from which to create an nsIURI.
+ * @returns an nsIURI object, or null if the creation of the URI failed.
+ */
+function makeURI(aURLSpec, aCharset) {
+  var ios = Cc["@mozilla.org/network/io-service;1"].
+            getService(Ci.nsIIOService);
+  try {
+    return ios.newURI(aURLSpec, aCharset, null);
+  } catch (ex) { }
+
+  return null;
+}
+
+
+const XML_NS = "http://www.w3.org/XML/1998/namespace"
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+const TYPE_MAYBE_FEED = "application/vnd.mozilla.maybe.feed";
+const URI_BUNDLE = "chrome://browser/locale/feeds/subscribe.properties";
+
+const PREF_SELECTED_APP = "browser.feeds.handlers.application";
+const PREF_SELECTED_WEB = "browser.feeds.handlers.webservice";
+const PREF_SELECTED_ACTION = "browser.feeds.handler";
+const PREF_SELECTED_READER = "browser.feeds.handler.default";
+const PREF_SHOW_FIRST_RUN_UI = "browser.feeds.showFirstRunUI";
+
+const FW_CLASSID = Components.ID("{49bb6593-3aff-4eb3-a068-2712c28bd58e}");
+const FW_CLASSNAME = "Feed Writer";
+const FW_CONTRACTID = "@mozilla.org/browser/feeds/result-writer;1";
+
+const TITLE_ID = "feedTitleText";
+const SUBTITLE_ID = "feedSubtitleText";
+
+#ifdef MOZ_PLACES
+const NH_CONTRACTID = "@mozilla.org/browser/nav-history-service;1";
+const FAV_CONTRACTID = "@mozilla.org/browser/favicon-service;1";
+#else
+const ICON_DATAURL_PREFIX = "data:image/x-icon;base64,";
+#endif
+
+function FeedWriter() {
+}
+FeedWriter.prototype = {
+  _getPropertyAsBag: function FW__getPropertyAsBag(container, property) {
+    return container.fields.getProperty(property).
+                     QueryInterface(Ci.nsIPropertyBag2);
+  },
+  
+  _getPropertyAsString: function FW__getPropertyAsString(container, property) {
+    try {
+      return container.fields.getPropertyAsAString(property);
+    }
+    catch (e) {
+    }
+    return "";
+  },
+  
+  _setContentText: function FW__setContentText(id, text) {
+    var element = this._document.getElementById(id);
+    while (element.hasChildNodes())
+      element.removeChild(element.firstChild);
+    element.appendChild(this._document.createTextNode(text));
+  },
+  
+  /**
+   * Safely sets the href attribute on an anchor tag, providing the URI 
+   * specified can be loaded according to rules. 
+   * @param   element
+   *          The element to set a URI attribute on
+   * @param   attribute
+   *          The attribute of the element to set the URI to, e.g. href or src
+   * @param   uri
+   *          The URI spec to set as the href
+   */
+  _safeSetURIAttribute: 
+  function FW__safeSetURIAttribute(element, attribute, uri) {
+    var secman = 
+        Cc["@mozilla.org/scriptsecuritymanager;1"].
+        getService(Ci.nsIScriptSecurityManager);    
+    const flags = Ci.nsIScriptSecurityManager.DISALLOW_INHERIT_PRINCIPAL;
+    try {
+      secman.checkLoadURIStr(this._window.location.href, uri, flags);
+      // checkLoadURIStr will throw if the link URI should not be loaded per 
+      // the rules specified in |flags|, so we'll never "linkify" the link...
+      element.setAttribute(attribute, uri);
+    }
+    catch (e) {
+      // Not allowed to load this link because secman.checkLoadURIStr threw
+    }
+  },
+
+#ifdef MOZ_PLACES
+  __faviconService: null,
+  get _faviconService() {
+    if (!this.__faviconService) {
+      this.__faviconService =
+        Cc[FAV_CONTRACTID].getService(Ci.nsIFaviconService);
+    }
+
+    return this.__faviconService;
+  },
+#endif
+
+  __bundle: null,
+  get _bundle() {
+    if (!this.__bundle) {
+      this.__bundle = Cc["@mozilla.org/intl/stringbundle;1"].
+                      getService(Ci.nsIStringBundleService).
+                      createBundle(URI_BUNDLE);
+    }
+    return this.__bundle;
+  },
+  
+  _getFormattedString: function FW__getFormattedString(key, params) {
+    return this._bundle.formatStringFromName(key, params, params.length);
+  },
+  
+  _getString: function FW__getString(key) {
+    return this._bundle.GetStringFromName(key);
+  },
+
+  /* Magic helper methods to be used instead of xbl properties */
+  _getSelectedItemFromMenulist: function FW__getSelectedItemFromList(aList) {
+    var node = aList.firstChild.firstChild;
+    while (node) {
+      if (node.localName == "menuitem" && node.getAttribute("selected") == "true")
+        return node;
+
+      node = node.nextSibling;
+    }
+
+    return null;
+  },
+
+  _setCheckboxCheckedState: function FW__setCheckboxCheckedState(aCheckbox, aValue) {
+dump ("_setCheckboxCheckedState\n");
+    // see checkbox.xml
+    var change = (aValue != (aCheckbox.getAttribute('checked') == 'true'));
+    if (aValue)
+      aCheckbox.setAttribute('checked', 'true');
+    else
+      aCheckbox.removeAttribute('checked');
+
+    if (change) {
+      var event = this._document.createEvent('Events');
+      event.initEvent('CheckboxStateChange', true, true);
+      aCheckbox.dispatchEvent(event);
+    }
+  },
+
+  // For setting and getting the file expando property, we need to keep a
+  // reference to explict XPCNativeWrappers around the associated menuitems
+  _selectedApplicationItemWrapped: null,
+  get selectedApplicationItemWrapped() {
+    if (!this._selectedApplicationItemWrapped) {
+      this._selectedApplicationItemWrapped =
+        XPCNativeWrapper(this._document.getElementById("selectedAppMenuItem"));
+    }
+
+    return this._selectedApplicationItemWrapped;
+  },
+
+  _defaultSystemReaderItemWrapped: null,
+  get defaultSystemReaderItemWrapped() {
+    if (!this._defaultSystemReaderItemWrapped) {
+      // Unlike the selected application item, this might not exist at all,
+      // see _initSubscriptionUI
+      var menuItem = this._document.getElementById("defaultHandlerMenuItem");
+      if (menuItem)
+        this._defaultSystemReaderItemWrapped = XPCNativeWrapper(menuItem);
+    }
+
+    return this._defaultSystemReaderItemWrapped;
+  },
+
+   /**
+   * Returns a date suitable for displaying in the feed preview. 
+   * If the date cannot be parsed, the return value is "false".
+   * @param   dateString
+   *          A date as extracted from a feed entry. (entry.updated)
+   */
+  _parseDate: function FW__parseDate(dateString) {
+    // Convert the date into the user's local time zone
+    dateObj = new Date(dateString);
+
+    // Make sure the date we're given is valid.
+    if (!dateObj.getTime())
+      return false;
+
+    var dateService = Cc["@mozilla.org/intl/scriptabledateformat;1"].
+                      getService(Ci.nsIScriptableDateFormat);
+    return dateService.FormatDateTime("", dateService.dateFormatLong, dateService.timeFormatNoSeconds,
+                                      dateObj.getFullYear(), dateObj.getMonth()+1, dateObj.getDate(),
+                                      dateObj.getHours(), dateObj.getMinutes(), dateObj.getSeconds());
+  },
+
+  /**
+   * Writes the feed title into the preview document.
+   * @param   container
+   *          The feed container
+   */
+  _setTitleText: function FW__setTitleText(container) {
+    if (container.title) {
+      this._setContentText(TITLE_ID, container.title.plainText());
+      this._document.title = container.title.plainText();
+    }
+    
+    var feed = container.QueryInterface(Ci.nsIFeed);
+    if (feed && feed.subtitle)
+      this._setContentText(SUBTITLE_ID, container.subtitle.plainText());
+  },
+  
+  /**
+   * Writes the title image into the preview document if one is present.
+   * @param   container
+   *          The feed container
+   */
+  _setTitleImage: function FW__setTitleImage(container) {
+    try {
+      var parts = container.image;
+      
+      // Set up the title image (supplied by the feed)
+      var feedTitleImage = this._document.getElementById("feedTitleImage");
+      this._safeSetURIAttribute(feedTitleImage, "src", 
+                                parts.getPropertyAsAString("url"));
+      
+      // Set up the title image link
+      var feedTitleLink = this._document.getElementById("feedTitleLink");
+      
+      var titleText = 
+        this._getFormattedString("linkTitleTextFormat", 
+                                 [parts.getPropertyAsAString("title")]);
+      feedTitleLink.setAttribute("title", titleText);
+      this._safeSetURIAttribute(feedTitleLink, "href", 
+                                parts.getPropertyAsAString("link"));
+
+      // Fix the margin on the main title, so that the image doesn't run over
+      // the underline
+      var feedTitleText = this._document.getElementById("feedTitleText");
+      var titleImageWidth = parseInt(parts.getPropertyAsAString("width")) + 15;
+      feedTitleText.style.marginRight = titleImageWidth + "px";
+    }
+    catch (e) {
+      LOG("Failed to set Title Image (this is benign): " + e);
+    }
+  },
+  
+  /**
+   * Writes all entries contained in the feed.
+   * @param   container
+   *          The container of entries in the feed
+   */
+  _writeFeedContent: function FW__writeFeedContent(container) {
+    // Build the actual feed content
+    var feedContent = this._document.getElementById("feedContent");
+    var feed = container.QueryInterface(Ci.nsIFeed);
+    
+    for (var i = 0; i < feed.items.length; ++i) {
+      var entry = feed.items.queryElementAt(i, Ci.nsIFeedEntry);
+      entry.QueryInterface(Ci.nsIFeedContainer);
+      
+      var entryContainer = this._document.createElementNS(HTML_NS, "div");
+      entryContainer.className = "entry";
+
+      // If the entry has a title, make it a link
+      if (entry.title) {
+        var a = this._document.createElementNS(HTML_NS, "a");
+        a.appendChild(this._document.createTextNode(entry.title.plainText()));
+      
+        // Entries are not required to have links, so entry.link can be null.
+        if (entry.link)
+          this._safeSetURIAttribute(a, "href", entry.link.spec);
+
+        var title = this._document.createElementNS(HTML_NS, "h3");
+        title.appendChild(a);
+        entryContainer.appendChild(title);
+
+        var lastUpdated = this._parseDate(entry.updated);
+        if (lastUpdated) {
+          var dateDiv = this._document.createElementNS(HTML_NS, "div");
+          dateDiv.setAttribute("class", "lastUpdated");
+          title.appendChild(dateDiv);
+          dateDiv.textContent = lastUpdated;
+        }
+      }
+
+      var body = this._document.createElementNS(HTML_NS, "div");
+      var summary = entry.summary || entry.content;
+      var docFragment = null;
+      if (summary) {
+
+        if (summary.base)
+          body.setAttributeNS(XML_NS, "base", summary.base.spec);
+        else
+          LOG("no base?");
+        docFragment = summary.createDocumentFragment(body);
+        if (docFragment)
+          body.appendChild(docFragment);
+
+        // If the entry doesn't have a title, append a # permalink
+        // See http://scripting.com/rss.xml for an example
+        if (!entry.title && entry.link) {
+          var a = this._document.createElementNS(HTML_NS, "a");
+          a.appendChild(this._document.createTextNode("#"));
+          this._safeSetURIAttribute(a, "href", entry.link.spec);
+          body.appendChild(this._document.createTextNode(" "));
+          body.appendChild(a);
+        }
+
+      }
+      body.className = "feedEntryContent";
+      entryContainer.appendChild(body);
+      feedContent.appendChild(entryContainer);
+      var clearDiv = this._document.createElementNS(HTML_NS, "div");
+      clearDiv.style.clear = "both";
+      feedContent.appendChild(clearDiv);
+    }
+  },
+  
+  /**
+   * Gets a valid nsIFeedContainer object from the parsed nsIFeedResult.
+   * Displays error information if there was one.
+   * @param   result
+   *          The parsed feed result
+   * @returns A valid nsIFeedContainer object containing the contents of
+   *          the feed.
+   */
+  _getContainer: function FW__getContainer(result) {
+    var feedService = 
+        Cc["@mozilla.org/browser/feeds/result-service;1"].
+        getService(Ci.nsIFeedResultService);
+ 
+    try {
+      var result = 
+        feedService.getFeedResult(this._getOriginalURI(this._window));
+    }
+    catch (e) {
+      LOG("Subscribe Preview: feed not available?!");
+    }
+    
+    if (result.bozo) {
+      LOG("Subscribe Preview: feed result is bozo?!");
+    }
+
+    try {
+      var container = result.doc;
+      container.title;
+    }
+    catch (e) {
+      LOG("Subscribe Preview: An error occurred in parsing! Fortunately, you can still subscribe...");
+      var feedError = this._document.getElementById("feedError");
+      feedError.removeAttribute("style");
+      var feedBody = this._document.getElementById("feedBody");
+      feedBody.setAttribute("style", "display:none;");
+      this._setContentText("errorCode", e);
+      return null;
+    }
+    return container;
+  },
+  
+  /**
+   * Get the human-readable display name of a file. This could be the 
+   * application name.
+   * @param   file
+   *          A nsIFile to look up the name of
+   * @returns The display name of the application represented by the file.
+   */
+  _getFileDisplayName: function FW__getFileDisplayName(file) {
+#ifdef XP_WIN
+    if (file instanceof Ci.nsILocalFileWin) {
+      try {
+        return file.getVersionInfoField("FileDescription");
+      }
+      catch (e) {
+      }
+    }
+#endif
+#ifdef XP_MACOSX
+    var lfm = file.QueryInterface(Ci.nsILocalFileMac);
+    try {
+      return lfm.bundleDisplayName;
+    }
+    catch (e) {
+      // fall through to the file name
+    }
+#endif
+    var ios = 
+        Cc["@mozilla.org/network/io-service;1"].
+        getService(Ci.nsIIOService);
+    var url = ios.newFileURI(file).QueryInterface(Ci.nsIURL);
+    return url.fileName;
+  },
+
+  /**
+   * Get moz-icon url for a file
+   * @param   file
+   *          A nsIFile object for which the moz-icon:// is returned
+   * @returns moz-icon url of the given file as a string
+   */
+  _getFileIconURL: function FW__getFileIconURL(file) {
+    var ios = Cc["@mozilla.org/network/io-service;1"].
+              getService(Components.interfaces.nsIIOService);
+    var fph = ios.getProtocolHandler("file")
+                 .QueryInterface(Ci.nsIFileProtocolHandler);
+    var urlSpec = fph.getURLSpecFromFile(file);
+    return "moz-icon://" + urlSpec + "?size=16";
+  },
+
+  /**
+   * Helper method to set the selected application and system default
+   * reader menuitems details from a file object
+   *   @param aMenuItem
+   *          The menuitem on which the attributes should be set
+   *   @param aFile
+   *          The menuitem's associated file
+   */
+  _initMenuItemWithFile: function(aMenuItem, aFile) {
+    aMenuItem.setAttribute("label", this._getFileDisplayName(aFile));
+    aMenuItem.setAttribute("image", this._getFileIconURL(aFile));
+    aMenuItem.file = aFile;
+  },
+
+  /**
+   * Displays a prompt from which the user may choose a (client) feed reader.
+   * @return - true if a feed reader was selected, false otherwise.
+   */
+  _chooseClientApp: function FW__chooseClientApp() {
+    try {
+      var fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
+      fp.init(this._window,
+              this._getString("chooseApplicationDialogTitle"),
+              Ci.nsIFilePicker.modeOpen);
+      fp.appendFilters(Ci.nsIFilePicker.filterApps);
+
+      if (fp.show() == Ci.nsIFilePicker.returnOK) {
+        var selectedApp = fp.file;
+        if (selectedApp) {
+          // XXXben - we need to compare this with the running instance executable
+          //          just don't know how to do that via script...
+          // XXXmano TBD: can probably add this to nsIShellService
+#ifdef XP_WIN
+#expand           if (fp.file.leafName != "__MOZ_APP_NAME__.exe") {
+#else
+#ifdef XP_MACOSX
+#expand           if (fp.file.leafName != "__MOZ_APP_DISPLAYNAME__.app") {
+#else
+#expand           if (fp.file.leafName != "__MOZ_APP_NAME__-bin") {
+#endif
+#endif
+            var selectedAppMenuItem = this.selectedApplicationItemWrapped;
+            this._initMenuItemWithFile(selectedAppMenuItem, selectedApp);
+
+            // Show and select the selected application menuitem
+            selectedAppMenuItem.hidden = false;
+            selectedAppMenuItem.doCommand();
+            return true;
+          }
+        }
+      }
+    }
+    catch(ex) { }
+
+    return false;
+  },
+
+  _setAlwaysUseCheckedState: function FW__setAlwaysUseCheckedState() {
+dump ("_setAlwaysUseCheckedState\n");
+    var checkbox = this._document.getElementById("alwaysUse");
+    if (checkbox) {
+      var alwaysUse = false;
+      try {
+        var prefs = Cc["@mozilla.org/preferences-service;1"].
+                    getService(Ci.nsIPrefBranch);
+        if (prefs.getCharPref(PREF_SELECTED_ACTION) != "ask")
+          alwaysUse = true;
+      }
+      catch(ex) { }
+      this._setCheckboxCheckedState(checkbox, alwaysUse);
+    }
+  },
+
+  _setAlwaysUseLabel: function FW__setAlwaysUseLabel() {
+    var checkbox = this._document.getElementById("alwaysUse");
+    if (checkbox) {
+      var handlersMenuList = this._document.getElementById("handlersMenuList");
+      if (handlersMenuList) {
+        var handlerName = this._getSelectedItemFromMenulist(handlersMenuList)
+                              .getAttribute("label");
+        checkbox.setAttribute("label", this._getFormattedString("alwaysUse", [handlerName]));
+      }
+    }
+  },
+
+  /**
+   * See nsIDOMEventListener
+   */
+  handleEvent: function(event) {
+    dump ("handleEvent\n\n");
+    // see comments in the write method
+    event = new XPCNativeWrapper(event);
+    if (event.target.ownerDocument != this._document) {
+      LOG("FeedWriter.handleEvent: Someone passed the feed writer as a listener to the events of another document!");
+      return;
+    }
+
+    if (event.type == "click") {
+      switch (event.target.id) {
+        case "subscribeButton":
+          this.subscribe();
+          break;
+      }
+    }
+
+    if (event.type == "change") {
+      switch (event.target.id) {
+        case "useAsDefault":
+          //this.checkOnChange();
+          break;
+      }
+    }
+
+
+    if (event.type == "command") {
+      switch (event.target.id) {
+        case "subscribeButton":
+          this.subscribe();
+          break;
+        case "chooseApplicationMenuItem":
+          /* Bug 351263: Make sure to not steal focus if the "Choose
+           * Application" item is being selected with the keyboard. We do this
+           * by ignoring command events while the dropdown is closed (user
+           * arrowing through the combobox), but handling them while the
+           * combobox dropdown is open (user pressed enter when an item was
+           * selected). If we don't show the filepicker here, it will be shown
+           * when clicking "Subscribe Now".
+           */
+          if (this._document.getElementById("handlersMenuList")
+                  .getAttribute("open") == "true") {
+            if (!this._chooseClientApp()) {
+              // Select the (per-prefs) selected handler if no application was
+              // selected
+              this._setSelectedHandler();
+            }
+          }
+          break;
+        default:
+          this._setAlwaysUseLabel();
+      }
+    }
+  },
+
+  _setSelectedHandler: function FW__setSelectedHandler() {
+    var prefs =   
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefBranch);
+
+    var handler = "bookmarks";
+    try {
+      handler = prefs.getCharPref(PREF_SELECTED_READER);
+    }
+    catch (ex) { }
+    
+    switch (handler) {
+      case "web": {
+        var handlersMenuList = this._document.getElementById("handlersMenuList");
+         if (handlersMenuList) {
+          var url = prefs.getComplexValue(PREF_SELECTED_WEB, Ci.nsISupportsString).data;
+          var handlers =
+            handlersMenuList.getElementsByAttribute("webhandlerurl", url);
+          if (handlers.length == 0) {
+            LOG("FeedWriter._setSelectedHandler: selected web handler isn't in the menulist")
+            return;
+          }
+
+          handlers[0].doCommand();
+        }
+        break;
+      }
+      case "client": {
+        var selectedAppMenuItem = this.selectedApplicationItemWrapped;
+        if (selectedAppMenuItem) {
+          try {
+            var selectedApp = prefs.getComplexValue(PREF_SELECTED_APP,
+                                                    Ci.nsILocalFile);
+          } catch(ex) { }
+
+          if (selectedApp) {
+            this._initMenuItemWithFile(selectedAppMenuItem, selectedApp);
+            selectedAppMenuItem.hidden = false;
+            selectedAppMenuItem.doCommand();
+
+            // Only show the default reader menuitem if the default reader
+            // isn't the selected application
+            var defaultHandlerMenuItem = this.defaultSystemReaderItemWrapped;
+            if (defaultHandlerMenuItem) {
+              defaultHandlerMenuItem.hidden =
+                defaultHandlerMenuItem.file.path == selectedApp.path;
+            }
+            break;
+          }
+        }
+      }
+      case "bookmarks":
+      default: {
+        var liveBookmarksMenuItem =
+          this._document.getElementById("liveBookmarksMenuItem");
+        if (liveBookmarksMenuItem)
+          liveBookmarksMenuItem.doCommand();
+      } 
+    }
+  },
+
+  _initSubscriptionUI: function FW__initSubscriptionUI() {
+
+    dump ("_initSubscriptionUI\n" );
+    // Set up the "Subscribe Now" button
+    this._document
+        .getElementById("subscribeButton")
+        .addEventListener("click", this, false);
+
+    this._document
+        .getElementById("alwaysUse")
+        .addEventListener("change", this, false);
+
+    // "Always use..." checkbox initial state
+    this._setAlwaysUseCheckedState();
+    //this._setAlwaysUseLabel();
+
+    var handlersMenuPopup =
+      this._document.getElementById("handlersMenuPopup");
+    if (!handlersMenuPopup)
+      return;
+
+    // Last-selected application
+    var selectedApp;
+    menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+    menuItem.id = "selectedAppMenuItem";
+    menuItem.className = "menuitem-iconic";
+    menuItem.setAttribute("handlerType", "client");
+    handlersMenuPopup.appendChild(menuItem);
+
+    var selectedApplicationItem = this.selectedApplicationItemWrapped;
+    try {
+      var prefs = Cc["@mozilla.org/preferences-service;1"].
+                  getService(Ci.nsIPrefBranch);
+      selectedApp = prefs.getComplexValue(PREF_SELECTED_APP,
+                                          Ci.nsILocalFile);
+
+      if (selectedApp.exists()) {
+        this._initMenuItemWithFile(selectedApplicationItem, selectedApp);
+      }
+      else {
+        // Hide the menuitem if the last selected application doesn't exist
+        selectedApplicationItem.hidden = true;
+      }
+    }
+    catch(ex) {
+      // Hide the menuitem until an application is selected
+      selectedApplicationItem.hidden = true;
+    }
+
+    // List the default feed reader
+    var defaultReader = null;
+    try {
+      var defaultReader = Cc["@mozilla.org/browser/shell-service;1"].
+                          getService(Ci.nsIShellService).defaultFeedReader;
+      menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+      menuItem.id = "defaultHandlerMenuItem";
+      menuItem.className = "menuitem-iconic";
+      menuItem.setAttribute("handlerType", "client");
+      handlersMenuPopup.appendChild(menuItem);
+
+      var defaultSystemReaderItem = this.defaultSystemReaderItemWrapped;
+      this._initMenuItemWithFile(defaultSystemReaderItem, defaultReader);
+
+      // Hide the default reader item if it points to the same application
+      // as the last-selected application
+      if (selectedApp && selectedApp.path == defaultReader.path)
+        defaultSystemReaderItem.hidden = true;
+    }
+    catch(ex) { /* no default reader */ }
+
+    // "Choose Application..." menuitem
+    menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+    menuItem.id = "chooseApplicationMenuItem";
+    menuItem.setAttribute("label", this._getString("chooseApplicationMenuItem"));
+    handlersMenuPopup.appendChild(menuItem);
+
+    // separator
+    handlersMenuPopup.appendChild(this._document.createElementNS(XUL_NS,
+                                  "menuseparator"));
+
+#ifdef MOZ_PLACES
+    var historySvc = Cc[NH_CONTRACTID].getService(Ci.nsINavHistoryService);
+    historySvc.addObserver(this, false);
+#endif
+
+    // List of web handlers
+    var wccr = 
+      Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+      getService(Ci.nsIWebContentConverterService);
+    var handlers = wccr.getContentHandlers(TYPE_MAYBE_FEED, {});
+    if (handlers.length != 0) {
+      for (var i = 0; i < handlers.length; ++i) {
+        menuItem = this._document.createElementNS(XUL_NS, "menuitem");
+        menuItem.className = "menuitem-iconic";
+        menuItem.setAttribute("label", handlers[i].name);
+        menuItem.setAttribute("handlerType", "web");
+        menuItem.setAttribute("webhandlerurl", handlers[i].uri);
+        handlersMenuPopup.appendChild(menuItem);
+
+        // For privacy reasons we cannot set the image attribute directly
+        // to the icon url, see Bug 358878
+        var uri = makeURI(handlers[i].uri);
+#ifdef MOZ_PLACES
+        if (!this._setFaviconForWebReader(uri, menuItem)) {
+          if (uri && /^https?/.test(uri.scheme)) {
+            var iconURL = makeURI(uri.prePath + "/favicon.ico");
+            this._faviconService.setAndLoadFaviconForPage(uri, iconURL, true);
+          }
+        }
+#else
+        if (uri && /^https?/.test(uri.scheme))
+          new iconDataURIGenerator(uri.prePath + "/favicon.ico", menuItem);
+#endif
+      }
+    }
+
+    this._setSelectedHandler();
+
+    // "Always use..." checkbox initial state
+    this._setAlwaysUseCheckedState();
+    this._setAlwaysUseLabel();
+
+    // We update the "Always use.." checkbox label whenever the selected item
+    // in the list is changed
+    handlersMenuPopup.addEventListener("command", this, false);
+
+    // Set up the "Subscribe Now" button
+    this._document
+        .getElementById("subscribeButton")
+        .addEventListener("command", this, false);
+    
+    // first-run ui
+    var showFirstRunUI = true;
+    try {
+      showFirstRunUI = prefs.getBoolPref(PREF_SHOW_FIRST_RUN_UI);
+    }
+    catch (ex) { }
+    if (showFirstRunUI) {
+      var feedHeader = this._document.getElementById("feedHeader");
+      if (feedHeader)
+        feedHeader.setAttribute("firstrun", "true");
+
+      prefs.setBoolPref(PREF_SHOW_FIRST_RUN_UI, false);
+    }
+  },
+  
+  /**
+   * Returns the original URI object of the feed and ensures that this
+   * component is only ever invoked from the preview document.  
+   * @param aWindow 
+   *        The window of the document invoking the BrowserFeedWriter
+   */
+  _getOriginalURI: function FW__getOriginalURI(aWindow) {
+    var chan = 
+        aWindow.QueryInterface(Ci.nsIInterfaceRequestor).
+        getInterface(Ci.nsIWebNavigation).
+        QueryInterface(Ci.nsIDocShell).currentDocumentChannel;
+
+    const SUBSCRIBE_PAGE_URI = "chrome://browser/content/feeds/subscribe.xhtml";
+    var uri = makeURI(SUBSCRIBE_PAGE_URI);
+    var resolvedURI = Cc["@mozilla.org/chrome/chrome-registry;1"].
+                      getService(Ci.nsIChromeRegistry).
+                      convertChromeURL(uri);
+
+    if (resolvedURI.equals(chan.URI))
+      return chan.originalURI;
+
+    return null;
+  },
+
+  _window: null,
+  _document: null,
+  _feedURI: null,
+
+  /**
+   * See nsIFeedWriter
+   */
+  init: function FW_init(aWindow) {
+    // Explicitly wrap |window| in an XPCNativeWrapper to make sure
+    // it's a real native object! This will throw an exception if we
+    // get a non-native object.
+    var window = new XPCNativeWrapper(aWindow);
+    this._feedURI = this._getOriginalURI(window);
+    if (!this._feedURI)
+      return;
+
+    this._window = window;
+    this._document = window.document;
+
+    LOG("Subscribe Preview: feed uri = " + this._window.location.href);
+
+    // Set up the subscription UI
+    this._initSubscriptionUI();
+    var prefs = Cc["@mozilla.org/preferences-service;1"].
+                getService(Ci.nsIPrefBranch2);
+    prefs.addObserver(PREF_SELECTED_ACTION, this, false);
+    prefs.addObserver(PREF_SELECTED_READER, this, false);
+    prefs.addObserver(PREF_SELECTED_WEB, this, false);
+    prefs.addObserver(PREF_SELECTED_APP, this, false);
+  },
+
+  /**
+   * See nsIFeedWriter
+   */
+  writeContent: function FW_writeContent() {
+    if (!this._window)
+      return;
+
+    try {
+      // Set up the feed content
+      var container = this._getContainer();
+      if (!container)
+        return;
+      
+      this._setTitleText(container);
+      this._setTitleImage(container);
+      this._writeFeedContent(container);
+    }
+    finally {
+      this._removeFeedFromCache();
+    }
+  },
+
+  /**
+   * See nsIFeedWriter
+   */
+  close: function FW_close() {
+    this._document = null;
+    this._window = null;
+    var prefs =   
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefBranch2);
+    prefs.removeObserver(PREF_SELECTED_ACTION, this);
+    prefs.removeObserver(PREF_SELECTED_READER, this);
+    prefs.removeObserver(PREF_SELECTED_WEB, this);
+    prefs.removeObserver(PREF_SELECTED_APP, this);
+    this._removeFeedFromCache();
+
+#ifdef MOZ_PLACES
+    var historySvc = Cc[NH_CONTRACTID].getService(Ci.nsINavHistoryService);
+    historySvc.removeObserver(this);
+#endif
+  },
+
+  _removeFeedFromCache: function FW__removeFeedFromCache() {
+    if (this._feedURI) {
+      var feedService = 
+          Cc["@mozilla.org/browser/feeds/result-service;1"].
+          getService(Ci.nsIFeedResultService);
+      feedService.removeFeedResult(this._feedURI);
+      this._feedURI = null;
+    }
+  },
+
+  subscribe: function FW_subscribe() {
+    // Subscribe to the feed using the selected handler and save prefs
+    var prefs =   
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefBranch);
+    var defaultHandler = "reader";
+    var useAsDefault = this._document.getElementById("alwaysUse").checked;
+                                     //.getAttribute("checked");
+
+    var handlersMenuList = this._document.getElementById("handlersMenuList");
+    var selectedItem = handlersMenuList.options[handlersMenuList.selectedIndex];
+    //var selectedItem = this._getSelectedItemFromMenulist(handlersMenuList);
+
+    // Show the file picker before subscribing if the
+    // choose application menuitem was choosen using the keyboard
+    //if (selectedItem.id == "chooseApplicationMenuItem") {
+    //  if (!this._chooseClientApp())
+    //    return;
+      
+    //  selectedItem = this._getSelectedItemFromMenulist(handlersMenuList);
+    //}
+
+    if (selectedItem.hasAttribute("webhandlerurl")) {
+      var webURI = selectedItem.getAttribute("webhandlerurl");
+      prefs.setCharPref(PREF_SELECTED_READER, "web");
+
+      var supportsString = Cc["@mozilla.org/supports-string;1"].
+                           createInstance(Ci.nsISupportsString);
+      supportsString.data = webURI;
+      prefs.setComplexValue(PREF_SELECTED_WEB, Ci.nsISupportsString,
+                            supportsString);
+
+      var wccr = 
+        Cc["@mozilla.org/embeddor.implemented/web-content-handler-registrar;1"].
+        getService(Ci.nsIWebContentConverterService);
+      var handler = wccr.getWebContentHandlerByURI(TYPE_MAYBE_FEED, webURI);
+      if (handler) {
+        if (useAsDefault)
+          wccr.setAutoHandler(TYPE_MAYBE_FEED, handler);
+
+        this._window.location.href =
+          handler.getHandlerURI(this._window.location.href);
+      }
+    }
+    //else {
+    //  switch (selectedItem.id) {
+    //    case "selectedAppMenuItem":
+    //      prefs.setCharPref(PREF_SELECTED_READER, "client");
+    //      prefs.setComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile, 
+    //                            this.selectedApplicationItemWrapped.file);
+    //      break;
+    //    case "defaultHandlerMenuItem":
+    //      prefs.setCharPref(PREF_SELECTED_READER, "client");
+    //      prefs.setComplexValue(PREF_SELECTED_APP, Ci.nsILocalFile, 
+    //                            this.defaultSystemReaderItemWrapped.file);
+    //      break;
+    //    case "liveBookmarksMenuItem":
+    //      defaultHandler = "bookmarks";
+    //      prefs.setCharPref(PREF_SELECTED_READER, "bookmarks");
+    //      break;
+    //  }
+    //  var feedService = Cc["@mozilla.org/browser/feeds/result-service;1"].
+    //                    getService(Ci.nsIFeedResultService);
+
+      // Pull the title and subtitle out of the document
+    //  var feedTitle = this._document.getElementById(TITLE_ID).textContent;
+    //  var feedSubtitle =
+    //    this._document.getElementById(SUBTITLE_ID).textContent;
+    //  feedService.addToClientReader(this._window.location.href,
+    //                                feedTitle, feedSubtitle);
+    //}
+
+    // If "Always use..." is checked, we should set PREF_SELECTED_ACTION
+    // to either "reader" (If a web reader or if an application is selected),
+    // or to "bookmarks" (if the live bookmarks option is selected).
+    // Otherwise, we should set it to "ask"
+    if (useAsDefault)
+      prefs.setCharPref(PREF_SELECTED_ACTION, defaultHandler);
+    else
+      prefs.setCharPref(PREF_SELECTED_ACTION, "ask");
+  },
+
+  /**
+   * See nsIObserver
+   */
+  observe: function FW_observe(subject, topic, data) {
+    if (!this._window) {
+      // this._window is null unless this.write was called with a trusted
+      // window object.
+      return;
+    }
+
+    if (topic == "nsPref:changed") {
+      switch (data) {
+        case PREF_SELECTED_READER:
+        case PREF_SELECTED_WEB:
+        case PREF_SELECTED_APP:
+        dump ("**********observer*********\n\n");
+          this._setSelectedHandler();
+          break;
+        case PREF_SELECTED_ACTION:
+          this._setAlwaysUseCheckedState();
+      }
+    } 
+  },
+
+#ifdef MOZ_PLACES
+  /**
+   * Sets the icon for the given web-reader item in the readers menu
+   * if the favicon-service has the necessary icon stored.
+   * @param aURI
+   *        the reader URI.
+   * @param aMenuItem
+   *        the reader item in the readers menulist.
+   * @return true if the icon was set, false otherwise.
+   */
+  _setFaviconForWebReader:
+  function FW__setFaviconForWebReader(aURI, aMenuItem) {
+    var faviconsSvc = this._faviconService;
+    var faviconURL = null;
+    try {
+      faviconURL = faviconsSvc.getFaviconForPage(aURI);
+    }
+    catch(ex) { }
+
+    if (faviconURL) {
+      var mimeType = { };
+      var bytes = faviconsSvc.getFaviconData(faviconURL, mimeType,
+                                             { /* dataLen */ });
+      if (bytes) {
+        var dataURI = "data:" + mimeType.value + ";" + "base64," +
+                      btoa(String.fromCharCode.apply(null, bytes));
+        aMenuItem.setAttribute("image", dataURI);
+        return true;
+      }
+    }
+
+    return false;
+  },
+
+  /**
+   * See nsINavHistoryService
+   */
+   onPageChanged: function FW_onPageChanged(aURI, aWhat, aValue) {
+     if (aWhat == Ci.nsINavHistoryObserver.ATTRIBUTE_FAVICON) {
+       // Go through the readers menu and look for the corresponding
+       // reader menu-item for the page if any.
+       var spec = aURI.spec;
+       var handlersMenulist = this._document.getElementById("handlersMenuList");
+       var possibleHandlers = handlersMenulist.firstChild.childNodes;
+       for (var i=0; i < possibleHandlers.length ; i++) {
+         if (possibleHandlers[i].getAttribute("webhandlerurl") == spec) {
+           this._setFaviconForWebReader(aURI, possibleHandlers[i]);
+           return;
+         }
+       }
+     }
+   },
+
+   onBeginUpdateBatch: function() { },
+   onEndUpdateBatch: function() { },
+   onVisit: function() { },
+   onTitleChanged: function() { },
+   onDeleteURI: function() { },
+   onClearHistory: function() { },
+   onPageExpired: function() { },
+#endif
+
+  /**
+   * See nsIClassInfo
+   */
+  getInterfaces: function WCCR_getInterfaces(countRef) {
+    var interfaces = 
+        [Ci.nsIFeedWriter, Ci.nsIClassInfo, Ci.nsISupports];
+    countRef.value = interfaces.length;
+    return interfaces;
+  },
+  getHelperForLanguage: function WCCR_getHelperForLanguage(language) {
+    return null;
+  },
+  contractID: FW_CONTRACTID,
+  classDescription: FW_CLASSNAME,
+  classID: FW_CLASSID,
+  implementationLanguage: Ci.nsIProgrammingLanguage.JAVASCRIPT,
+  flags: Ci.nsIClassInfo.DOM_OBJECT,
+
+  QueryInterface: function FW_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFeedWriter) ||
+        iid.equals(Ci.nsIClassInfo) ||
+        iid.equals(Ci.nsIDOMEventListener) ||
+        iid.equals(Ci.nsIObserver) ||
+#ifdef MOZ_PLACES
+        iid.equals(Ci.nsINavHistoryObserver) ||
+#endif
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+#ifndef MOZ_PLACES
+function iconDataURIGenerator(aURISpec, aElement) {
+  var ios = Cc["@mozilla.org/network/io-service;1"].
+            getService(Ci.nsIIOService);
+  var chan = ios.newChannelFromURI(makeURI(aURISpec));
+  chan.notificationCallbacks = this;
+  chan.asyncOpen(this, null);
+
+  this._channel = chan;
+  this._bytes = [];
+  this._element = aElement;
+}
+iconDataURIGenerator.prototype = {
+  _channel: null,
+  _countRead: 0,
+  _stream: null,
+
+  QueryInterface: function FW_IDUG_loadQI(aIID) {
+    if (aIID.equals(Ci.nsISupports)           ||
+        aIID.equals(Ci.nsIRequestObserver)    ||
+        aIID.equals(Ci.nsIStreamListener)     ||
+        aIID.equals(Ci.nsIChannelEventSink)   ||
+        aIID.equals(Ci.nsIInterfaceRequestor) ||
+        aIID.equals(Ci.nsIBadCertListener)    ||
+        // See bug 358878 comment 11
+        aIID.equals(Ci.nsIPrompt)             ||
+        // See FIXME comment below
+        aIID.equals(Ci.nsIHttpEventSink)      ||
+        aIID.equals(Ci.nsIProgressEventSink)  ||
+        false)
+      return this;
+
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+
+  // nsIRequestObserver
+  onStartRequest: function FW_IDUG_loadStartR(aRequest, aContext) {
+    this._stream = Cc["@mozilla.org/binaryinputstream;1"].
+                   createInstance(Ci.nsIBinaryInputStream);
+  },
+
+  onStopRequest: function FW_IDUG_loadStopR(aRequest, aContext, aStatusCode) {
+    var requestFailed = !Components.isSuccessCode(aStatusCode);
+    if (!requestFailed && (aRequest instanceof Ci.nsIHttpChannel))
+      requestFailed = !aRequest.requestSucceeded;
+
+    if (!requestFailed && this._countRead != 0) {
+      var str = String.fromCharCode.apply(null, this._bytes);
+      try {
+        var dataURI = ICON_DATAURL_PREFIX + btoa(str);
+        this._element.setAttribute("image", dataURI);
+      }
+      catch(ex) {}
+    }
+    this._channel = null;
+    this._element  = null;
+  },
+
+  // nsIStreamListener
+  onDataAvailable: function FW_IDUG_loadDAvailable(aRequest, aContext,
+                                                   aInputStream, aOffset,
+                                                   aCount) {
+    this._stream.setInputStream(aInputStream);
+
+    // Get a byte array of the data
+    this._bytes = this._bytes.concat(this._stream.readByteArray(aCount));
+    this._countRead += aCount;
+  },
+
+  // nsIChannelEventSink
+  onChannelRedirect: function FW_IDUG_loadCRedirect(aOldChannel, aNewChannel,
+                                                    aFlags) {
+    this._channel = aNewChannel;
+  },
+
+  // nsIInterfaceRequestor
+  getInterface: function FW_IDUG_load_GI(aIID) {
+    return this.QueryInterface(aIID);
+  },
+
+  // nsIBadCertListener
+  confirmUnknownIssuer: function FW_IDUG_load_CUI(aSocketInfo, aCert,
+                                                  aCertAddType) {
+    return false;
+  },
+
+  confirmMismatchDomain: function FW_IDUG_load_CMD(aSocketInfo, aTargetURL,
+                                                   aCert) {
+    return false;
+  },
+
+  confirmCertExpired: function FW_IDUG_load_CCE(aSocketInfo, aCert) {
+    return false;
+  },
+
+  notifyCrlNextupdate: function FW_IDUG_load_NCN(aSocketInfo, aTargetURL, aCert) {
+  },
+
+  // FIXME: bug 253127
+  // nsIHttpEventSink
+  onRedirect: function (aChannel, aNewChannel) { },
+  // nsIProgressEventSink
+  onProgress: function (aRequest, aContext, aProgress, aProgressMax) { },
+  onStatus: function (aRequest, aContext, aStatus, aStatusArg) { }
+};
+#endif
+
+var Module = {
+  QueryInterface: function M_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIModule) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+
+  getClassObject: function M_getClassObject(cm, cid, iid) {
+    if (!iid.equals(Ci.nsIFactory))
+      throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+    
+    if (cid.equals(FW_CLASSID))
+      return new GenericComponentFactory(FeedWriter);
+
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+  
+  registerSelf: function M_registerSelf(cm, file, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+    
+    cr.registerFactoryLocation(FW_CLASSID, FW_CLASSNAME, FW_CONTRACTID,
+                               file, location, type);
+    
+    var catman = 
+        Cc["@mozilla.org/categorymanager;1"].
+        getService(Ci.nsICategoryManager);
+    catman.addCategoryEntry("JavaScript global constructor",
+                            "BrowserFeedWriter", FW_CONTRACTID, true, true);
+  },
+
+  unregisterSelf: function M_unregisterSelf(cm, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+    cr.unregisterFactoryLocation(FW_CLASSID, location);
+  },
+
+  canUnload: function M_canUnload(cm) {
+    return true;
+  }
+};
+
+function NSGetModule(cm, file) {
+  return Module;
+}
+
+#include ../../../../toolkit/content/debug.js
+#include GenericFactory.js
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/GenericFactory.js mozilla/toolkit/components/browser-feeds/src/GenericFactory.js
--- mozilla-orig/toolkit/components/browser-feeds/src/GenericFactory.js	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/GenericFactory.js	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,63 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Generic Component Factory.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+/**
+ * An object implementing nsIFactory that can construct other objects upon
+ * createInstance, passing a set of parameters to that object's constructor.
+ */
+function GenericComponentFactory(ctor, params) {
+  this._ctor = ctor;
+  this._params = params;
+}
+GenericComponentFactory.prototype = {
+  _ctor: null,
+  _params: null,
+  
+  createInstance: function GCF_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return (new this._ctor(this._params)).QueryInterface(iid);
+  },
+  
+  QueryInterface: function GCF_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports)) 
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/Makefile.in mozilla/toolkit/components/browser-feeds/src/Makefile.in
--- mozilla-orig/toolkit/components/browser-feeds/src/Makefile.in	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/Makefile.in	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,68 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Feed Handling System
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Ben Goodger <beng@google.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE = browser_feeds
+LIBRARY_NAME = browser_feeds_s
+FORCE_STATIC_LIB = 1
+FORCE_USE_PIC = 1
+USE_STATIC_LIBS = 1
+LIBXUL_LIBRARY = 1
+
+DEFINES += \
+	-DMOZ_APP_NAME=$(MOZ_APP_NAME) \
+	-DMOZ_APP_DISPLAYNAME=$(MOZ_APP_DISPLAYNAME) \
+	$(NULL)
+
+EXTRA_PP_COMPONENTS = \
+	FeedConverter.js \
+	FeedWriter.js \
+	WebContentConverter.js \
+	$(NULL)
+
+REQUIRES = xpcom string necko caps js xpconnect mimetype
+
+CPPSRCS = nsFeedSniffer.cpp nsAboutFeeds.cpp
+
+LOCAL_INCLUDES = -I$(srcdir)/../../build
+
+include $(topsrcdir)/config/rules.mk
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/WebContentConverter.js mozilla/toolkit/components/browser-feeds/src/WebContentConverter.js
--- mozilla-orig/toolkit/components/browser-feeds/src/WebContentConverter.js	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/WebContentConverter.js	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,825 @@
+# -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Web Content Converter System.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2006
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#   Ben Goodger <beng@google.com>
+#   Asaf Romano <mano@mozilla.com>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK ***** */
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cr = Components.results;
+
+function LOG(str) {
+  dump("*** " + str + "\n");
+}
+
+const WCCR_CONTRACTID = "@mozilla.org/embeddor.implemented/web-content-handler-registrar;1";
+const WCCR_CLASSID = Components.ID("{792a7e82-06a0-437c-af63-b2d12e808acc}");
+const WCCR_CLASSNAME = "Web Content Handler Registrar";
+
+const WCC_CLASSID = Components.ID("{db7ebf28-cc40-415f-8a51-1b111851df1e}");
+const WCC_CLASSNAME = "Web Service Handler";
+
+const TYPE_MAYBE_FEED = "application/vnd.mozilla.maybe.feed";
+const TYPE_ANY = "*/*";
+
+const PREF_CONTENTHANDLERS_AUTO = "browser.contentHandlers.auto.";
+const PREF_CONTENTHANDLERS_BRANCH = "browser.contentHandlers.types.";
+const PREF_SELECTED_WEB = "browser.feeds.handlers.webservice";
+const PREF_SELECTED_ACTION = "browser.feeds.handler";
+const PREF_SELECTED_READER = "browser.feeds.handler.default";
+
+const STRING_BUNDLE_URI = "chrome://browser/locale/feeds/subscribe.properties";
+
+const NS_ERROR_MODULE_DOM = 2152923136;
+const NS_ERROR_DOM_SYNTAX_ERR = NS_ERROR_MODULE_DOM + 12;
+
+function WebContentConverter() {
+}
+WebContentConverter.prototype = {
+  convert: function WCC_convert() { },
+  asyncConvertData: function WCC_asyncConvertData() { },
+  onDataAvailable: function WCC_onDataAvailable() { },
+  onStopRequest: function WCC_onStopRequest() { },
+  
+  onStartRequest: function WCC_onStartRequest(request, context) {
+    var wccr = 
+        Cc[WCCR_CONTRACTID].
+        getService(Ci.nsIWebContentConverterService);
+    wccr.loadPreferredHandler(request);
+  },
+  
+  QueryInterface: function WCC_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIStreamConverter) ||
+        iid.equals(Ci.nsIStreamListener) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+var WebContentConverterFactory = {
+  createInstance: function WCCF_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return new WebContentConverter().QueryInterface(iid);
+  },
+    
+  QueryInterface: function WCC_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+function ServiceInfo(contentType, uri, name) {
+  this._contentType = contentType;
+  this._uri = uri;
+  this._name = name;
+}
+ServiceInfo.prototype = {
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  get contentType() {
+    return this._contentType;
+  },
+
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  get uri() {
+    return this._uri;
+  },
+
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  get name() {
+    return this._name;
+  },
+  
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  getHandlerURI: function SI_getHandlerURI(uri) {
+    return this._uri.replace(/%s/gi, encodeURIComponent(uri));
+  },
+  
+  /**
+   * See nsIWebContentHandlerInfo
+   */
+  equals: function SI_equals(other) {
+    return this.contentType == other.contentType &&
+           this.uri == other.uri;
+  },
+  
+  QueryInterface: function SI_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIWebContentHandlerInfo) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  }
+};
+
+var WebContentConverterRegistrar = {
+  _stringBundle: null,
+
+  get stringBundle() {
+    if (!this._stringBundle) {
+      this._stringBundle = Cc["@mozilla.org/intl/stringbundle;1"].
+                            getService(Ci.nsIStringBundleService).
+                            createBundle(STRING_BUNDLE_URI);
+    }
+
+    return this._stringBundle;
+  },
+
+  _getFormattedString: function WCCR__getFormattedString(key, params) {
+    return this.stringBundle.formatStringFromName(key, params, params.length);
+  },
+  
+  _getString: function WCCR_getString(key) {
+    return this.stringBundle.GetStringFromName(key);
+  },
+
+  _contentTypes: { },
+  _protocols: { },
+
+  /**
+   * Track auto handlers for various content types using a content-type to 
+   * handler map.
+   */
+  _autoHandleContentTypes: { },
+
+  /**
+   * See nsIWebContentConverterService
+   */
+  getAutoHandler: 
+  function WCCR_getAutoHandler(contentType) {
+    contentType = this._resolveContentType(contentType);
+    if (contentType in this._autoHandleContentTypes)
+      return this._autoHandleContentTypes[contentType];
+    return null;
+  },
+  
+  /**
+   * See nsIWebContentConverterService
+   */
+  setAutoHandler:
+  function WCCR_setAutoHandler(contentType, handler) {
+    if (handler && !this._typeIsRegistered(contentType, handler.uri))
+      throw Cr.NS_ERROR_NOT_AVAILABLE;
+      
+    contentType = this._resolveContentType(contentType);
+    this._setAutoHandler(contentType, handler);
+    
+    var ps = 
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefService);
+    var autoBranch = ps.getBranch(PREF_CONTENTHANDLERS_AUTO);
+    if (handler)
+      autoBranch.setCharPref(contentType, handler.uri);
+    else if (autoBranch.prefHasUserValue(contentType))
+      autoBranch.clearUserPref(contentType);
+     
+    ps.savePrefFile(null);
+  },
+  
+  /**
+   * Update the internal data structure (not persistent)
+   */
+  _setAutoHandler:
+  function WCCR__setAutoHandler(contentType, handler) {
+    if (handler) 
+      this._autoHandleContentTypes[contentType] = handler;
+    else if (contentType in this._autoHandleContentTypes)
+      delete this._autoHandleContentTypes[contentType];
+  },
+  
+  /**
+   * See nsIWebContentConverterService
+   */
+  getWebContentHandlerByURI:
+  function WCCR_getWebContentHandlerByURI(contentType, uri) {
+    var handlers = this.getContentHandlers(contentType, { });
+    for (var i = 0; i < handlers.length; ++i) {
+      if (handlers[i].uri == uri) 
+        return handlers[i];
+    }
+    return null;
+  },
+  
+  /**
+   * See nsIWebContentConverterService
+   */
+  loadPreferredHandler: 
+  function WCCR_loadPreferredHandler(request) {
+    var channel = request.QueryInterface(Ci.nsIChannel);
+    var contentType = this._resolveContentType(channel.contentType);
+    var handler = this.getAutoHandler(contentType);
+    if (handler) {
+      request.cancel(Cr.NS_ERROR_FAILURE);
+      
+      var webNavigation = 
+          channel.notificationCallbacks.getInterface(Ci.nsIWebNavigation);
+      webNavigation.loadURI(handler.getHandlerURI(channel.URI.spec), 
+                            Ci.nsIWebNavigation.LOAD_FLAGS_NONE, 
+                            null, null, null);
+    }      
+  },
+  
+  /**
+   * See nsIWebContentConverterService
+   */
+  removeProtocolHandler: 
+  function WCCR_removeProtocolHandler(protocol, uri) {
+    function notURI(currentURI) {
+      return currentURI != uri;
+    }
+  
+    if (protocol in this._protocols) 
+      this._protocols[protocol] = this._protocols[protocol].filter(notURI);
+  },
+  
+  /**
+   * See nsIWebContentConverterService
+   */
+  removeContentHandler: 
+  function WCCR_removeContentHandler(contentType, uri) {
+    function notURI(serviceInfo) {
+      return serviceInfo.uri != uri;
+    }
+  
+    if (contentType in this._contentTypes) {
+      this._contentTypes[contentType] = 
+        this._contentTypes[contentType].filter(notURI);
+    }
+  },
+  
+  /**
+   *
+   */
+  _mappings: { 
+    "application/rss+xml": TYPE_MAYBE_FEED,
+    "application/atom+xml": TYPE_MAYBE_FEED,
+  },
+  
+  /**
+   * These are types for which there is a separate content converter aside 
+   * from our built in generic one. We should not automatically register
+   * a factory for creating a converter for these types.
+   */
+  _blockedTypes: {
+    "application/vnd.mozilla.maybe.feed": true,
+  },
+  
+  /**
+   * Determines the "internal" content type based on the _mappings.
+   * @param   contentType
+   * @returns The resolved contentType value. 
+   */
+  _resolveContentType: 
+  function WCCR__resolveContentType(contentType) {
+    if (contentType in this._mappings)
+      return this._mappings[contentType];
+    return contentType;
+  },
+
+  _makeURI: function(aURL, aOriginCharset, aBaseURI) {
+    var ioService = Components.classes["@mozilla.org/network/io-service;1"]
+                              .getService(Components.interfaces.nsIIOService);
+    return ioService.newURI(aURL, aOriginCharset, aBaseURI);
+  },
+
+  /**
+   * See nsIWebContentHandlerRegistrar
+   */
+  registerProtocolHandler: 
+  function WCCR_registerProtocolHandler(aProtocol, aURI, aTitle, aContentWindow) {
+    // not yet implemented
+    return;
+  },
+
+  /**
+   * See nsIWebContentHandlerRegistrar
+   * This is the web front end into the registration system, so a prompt to 
+   * confirm the registration is provided, and the result is saved to 
+   * preferences.
+   */
+  registerContentHandler: 
+  function WCCR_registerContentHandler(aContentType, aURIString, aTitle, aContentWindow) {
+    LOG("registerContentHandler(" + aContentType + "," + aURIString + "," + aTitle + ")");
+
+    // We only support feed types at present.
+    // XXX this should be a "security exception" according to spec, but that
+    // isn't defined yet.
+    var contentType = this._resolveContentType(aContentType);
+    if (contentType != TYPE_MAYBE_FEED)
+      return;
+
+    try {
+      var uri = this._makeURI(aURIString);
+    } catch (ex) {
+      // not supposed to throw according to spec
+      return; 
+    }
+    
+    // If the uri doesn't contain '%s', it won't be a good content handler
+    if (uri.spec.indexOf("%s") < 0)
+      throw NS_ERROR_DOM_SYNTAX_ERR; 
+            
+    // For security reasons we reject non-http(s) urls (see bug Bug 354316),
+    // we may need to revise this once we support more content types
+    // XXX this should be a "security exception" according to spec, but that
+    // isn't defined yet.
+    if (uri.scheme != "http" &&  uri.scheme != "https")
+      throw("Permission denied to add " + uri.spec + "as a content handler");
+
+    var browserWindow = this._getBrowserWindowForContentWindow(aContentWindow);
+    var browserElement = this._getBrowserForContentWindow(browserWindow, aContentWindow);
+    var notificationBox = browserWindow.getBrowser().getNotificationBox(browserElement);
+    this._appendFeedReaderNotification(uri, aTitle, notificationBox);
+  },
+
+  /**
+   * Returns the browser chrome window in which the content window is in
+   */
+  _getBrowserWindowForContentWindow:
+  function WCCR__getBrowserWindowForContentWindow(aContentWindow) {
+    return aContentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
+                         .getInterface(Ci.nsIWebNavigation)
+                         .QueryInterface(Ci.nsIDocShellTreeItem)
+                         .rootTreeItem
+                         .QueryInterface(Ci.nsIInterfaceRequestor)
+                         .getInterface(Ci.nsIDOMWindow)
+                         .wrappedJSObject;
+  },
+
+  /**
+   * Returns the <xul:browser> element associated with the given content
+   * window.
+   *
+   * @param aBrowserWindow
+   *        The browser window in which the content window is in.
+   * @param aContentWindow
+   *        The content window. It's possible to pass a child content window
+   *        (i.e. the content window of a frame/iframe).
+   */
+  _getBrowserForContentWindow:
+  function WCCR__getBrowserForContentWindow(aBrowserWindow, aContentWindow) {
+    // This depends on pseudo APIs of browser.js and tabbrowser.xml
+    aContentWindow = aContentWindow.top;
+    var browsers = aBrowserWindow.getBrowser().browsers;
+    for (var i = 0; i < browsers.length; ++i) {
+      if (browsers[i].contentWindow == aContentWindow)
+        return browsers[i];
+    }
+  },
+
+  /**
+   * Appends a notifcation for the given feed reader details.
+   *
+   * The notification could be either a pseudo-dialog which lets
+   * the user to add the feed reader:
+   * [ [icon] Add %feed-reader-name% (%feed-reader-host%) as a Feed Reader?  (Add) [x] ]
+   *
+   * or a simple message for the case where the feed reader is already registered:
+   * [ [icon] %feed-reader-name% is already registered as a Feed Reader             [x] ]
+   *
+   * A new notification isn't appended if the given notificationbox has a
+   * notification for the same feed reader.
+   *
+   * @param aURI
+   *        The url of the feed reader as a nsIURI object
+   * @param aName
+   *        The feed reader name as it was passed to registerContentHandler
+   * @param aNotificationBox
+   *        The notification box to which a notification might be appended
+   * @return true if a notification has been appended, false otherwise.
+   */
+  _appendFeedReaderNotification:
+  function WCCR__appendFeedReaderNotification(aURI, aName, aNotificationBox) {
+    var uriSpec = aURI.spec;
+    var notificationValue = "feed reader notification: " + uriSpec;
+    var notificationIcon = aURI.prePath + "/favicon.ico";
+
+    // Don't append a new notification if the notificationbox
+    // has a notification for the given feed reader already
+    if (aNotificationBox.getNotificationWithValue(notificationValue))
+      return false;
+
+    var buttons, message;
+    if (this.getWebContentHandlerByURI(TYPE_MAYBE_FEED, uriSpec))
+      message = this._getFormattedString("handlerRegistered", [aName]);
+    else {
+      message = this._getFormattedString("addHandler", [aName, aURI.host]);
+      var self = this;
+      var addButton = {
+        _outer: self,
+        label: self._getString("addHandlerAddButton"),
+        accessKey: self._getString("addHandlerAddButtonAccesskey"),
+        feedReaderInfo: { uri: uriSpec, name: aName },
+
+        /* static */
+        callback:
+        function WCCR__addFeedReaderButtonCallback(aNotification, aButtonInfo) {
+          var uri = aButtonInfo.feedReaderInfo.uri;
+          var name = aButtonInfo.feedReaderInfo.name;
+          var outer = aButtonInfo._outer;
+
+          // The reader could have been added from another window mean while
+          if (!outer.getWebContentHandlerByURI(TYPE_MAYBE_FEED, uri)) {
+            outer._registerContentHandler(TYPE_MAYBE_FEED, uri, name);
+            outer._saveContentHandlerToPrefs(TYPE_MAYBE_FEED, uri, name);
+
+            // Make the new handler the last-selected reader in the preview page
+            // and make sure the preview page is shown the next time a feed is visited
+            var pb = Cc["@mozilla.org/preferences-service;1"].
+                     getService(Ci.nsIPrefService).getBranch(null);
+            pb.setCharPref(PREF_SELECTED_READER, "web");
+
+            var supportsString = 
+              Cc["@mozilla.org/supports-string;1"].
+              createInstance(Ci.nsISupportsString);
+              supportsString.data = uri;
+            pb.setComplexValue(PREF_SELECTED_WEB, Ci.nsISupportsString,
+                               supportsString);
+            pb.setCharPref(PREF_SELECTED_ACTION, "ask");
+            outer._setAutoHandler(TYPE_MAYBE_FEED, null);
+          }
+
+          // avoid reference cycles
+          aButtonInfo._outer = null;
+
+          return false;
+        }
+      };
+      buttons = [addButton];
+    }
+
+    aNotificationBox.appendNotification(message,
+                                        notificationValue,
+                                        notificationIcon,
+                                        aNotificationBox.PRIORITY_INFO_LOW,
+                                        buttons);
+    return true;
+  },
+
+  /**
+   * Save Web Content Handler metadata to persistent preferences. 
+   * @param   contentType
+   *          The content Type being handled
+   * @param   uri
+   *          The uri of the web service
+   * @param   title
+   *          The human readable name of the web service
+   *
+   * This data is stored under:
+   * 
+   *    browser.contentHandlers.type0 = content/type
+   *    browser.contentHandlers.uri0 = http://www.foo.com/q=%s
+   *    browser.contentHandlers.title0 = Foo 2.0alphr
+   */
+  _saveContentHandlerToPrefs: 
+  function WCCR__saveContentHandlerToPrefs(contentType, uri, title) {
+    var ps = 
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefService);
+    var i = 0;
+    var typeBranch = null;
+    while (true) {
+      typeBranch = 
+        ps.getBranch(PREF_CONTENTHANDLERS_BRANCH + i + ".");
+      try {
+        typeBranch.getCharPref("type");
+        ++i;
+      }
+      catch (e) {
+        // No more handlers
+        break;
+      }
+    }
+    if (typeBranch) {
+      typeBranch.setCharPref("type", contentType);
+      var pls = 
+          Cc["@mozilla.org/pref-localizedstring;1"].
+          createInstance(Ci.nsIPrefLocalizedString);
+      pls.data = uri;
+      typeBranch.setComplexValue("uri", Ci.nsIPrefLocalizedString, pls);
+      pls.data = title;
+      typeBranch.setComplexValue("title", Ci.nsIPrefLocalizedString, pls);
+    
+      ps.savePrefFile(null);
+    }
+  },
+  
+  /**
+   * Determines if there is a type with a particular uri registered for the 
+   * specified content type already.
+   * @param   contentType
+   *          The content type that the uri handles
+   * @param   uri
+   *          The uri of the 
+   */
+  _typeIsRegistered: function WCCR__typeIsRegistered(contentType, uri) {
+    if (!(contentType in this._contentTypes))
+      return false;
+      
+    var services = this._contentTypes[contentType];
+    for (var i = 0; i < services.length; ++i) {
+      // This uri has already been registered
+      if (services[i].uri == uri)
+        return true;
+    }
+    return false;
+  },
+  
+  /**
+   * Gets a stream converter contract id for the specified content type.
+   * @param   contentType
+   *          The source content type for the conversion.
+   * @returns A contract id to construct a converter to convert between the 
+   *          contentType and *\/*.
+   */
+  _getConverterContractID: function WCCR__getConverterContractID(contentType) {
+    const template = "@mozilla.org/streamconv;1?from=%s&to=*/*";
+    return template.replace(/%s/, contentType);
+  },
+  
+  /**
+   * Update the content type -> handler map. This mapping is not persisted, use
+   * registerContentHandler or _saveContentHandlerToPrefs for that purpose.
+   * @param   contentType
+   *          The content Type being handled
+   * @param   uri
+   *          The uri of the web service
+   * @param   title
+   *          The human readable name of the web service
+   */
+  _registerContentHandler: 
+  function WCCR__registerContentHandler(contentType, uri, title) {
+    if (!(contentType in this._contentTypes))
+      this._contentTypes[contentType] = [];
+
+    // Avoid adding duplicates
+    if (this._typeIsRegistered(contentType, uri)) 
+      return;
+    
+    this._contentTypes[contentType].push(new ServiceInfo(contentType, uri, title));
+    
+    if (!(contentType in this._blockedTypes)) {
+      var converterContractID = this._getConverterContractID(contentType);
+      var cr = Components.manager.QueryInterface(Ci.nsIComponentRegistrar);
+      cr.registerFactory(WCC_CLASSID, WCC_CLASSNAME, converterContractID, 
+                         WebContentConverterFactory);
+    }
+  },
+  
+  /**
+   * See nsIWebContentConverterService
+   */
+  getContentHandlers: 
+  function WCCR_getContentHandlers(contentType, countRef) {
+    countRef.value = 0;
+    if (!(contentType in this._contentTypes))
+      return [];
+    
+    var handlers = this._contentTypes[contentType];
+    countRef.value = handlers.length;
+    return handlers;
+  },
+  
+  /**
+   * See nsIWebContentConverterService
+   */
+  resetHandlersForType: 
+  function WCCR_resetHandlersForType(contentType) {
+    // currently unused within the tree, so only useful for extensions; previous
+    // impl. was buggy (and even infinite-looped!), so I argue that this is a
+    // definite improvement
+    throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+  },
+  
+  /**
+   * Registers a handler from the settings on a preferences branch.
+   *
+   * @param branch
+   *        an nsIPrefBranch containing "type", "uri", and "title" preferences
+   *        corresponding to the content handler to be registered
+   */
+  _registerContentHandlerWithBranch: function(branch) {
+    /**
+     * Since we support up to six predefined readers, we need to handle gaps 
+     * better, since the first branch with user-added values will be .6
+     * 
+     * How we deal with that is to check to see if there's no prefs in the 
+     * branch and stop cycling once that's true.  This doesn't fix the case
+     * where a user manually removes a reader, but that's not supported yet!
+     */
+    var vals = branch.getChildList("", {});
+    if (vals.length == 0)
+      return;
+
+    try {
+      var type = branch.getCharPref("type");
+      //var uri = branch.getComplexValue("uri", Ci.nsIPrefLocalizedString).data;
+      //var title = branch.getComplexValue("title",Ci.nsIPrefLocalizedString).data;
+      var uri = branch.getCharPref("uri");
+      var title = branch.getCharPref("title");;
+      this._registerContentHandler(type, uri, title);
+    }
+    catch(ex) {
+      // do nothing, the next branch might have values
+    }
+  },
+
+  /**
+   * Load the auto handler, content handler and protocol tables from 
+   * preferences.
+   */
+  _init: function WCCR__init() {
+    var ps = 
+        Cc["@mozilla.org/preferences-service;1"].
+        getService(Ci.nsIPrefService);
+
+    var kids = ps.getBranch(PREF_CONTENTHANDLERS_BRANCH)
+                 .getChildList("", {});
+
+    // first get the numbers of the providers by getting all ###.uri prefs
+    var nums = [];
+    for (var i = 0; i < kids.length; i++) {
+      var match = /^(\d+)\.uri$/.exec(kids[i]);
+      if (!match)
+        continue;
+      else
+        nums.push(match[1]);
+    }
+
+    // now register them
+    for (var i = 0; i < nums.length; i++) {
+      var branch = ps.getBranch(PREF_CONTENTHANDLERS_BRANCH + nums[i] + ".");
+      this._registerContentHandlerWithBranch(branch);
+    }
+
+    // We need to do this _after_ registering all of the available handlers, 
+    // so that getWebContentHandlerByURI can return successfully.
+    try {
+      var autoBranch = ps.getBranch(PREF_CONTENTHANDLERS_AUTO);
+      var childPrefs = autoBranch.getChildList("", { });
+      for (var i = 0; i < childPrefs.length; ++i) {
+        var type = childPrefs[i];
+        var uri = autoBranch.getCharPref(type);
+        if (uri) {
+          var handler = this.getWebContentHandlerByURI(type, uri);
+          this._setAutoHandler(type, handler);
+        }
+      }
+    }
+    catch (e) {
+      // No auto branch yet, that's fine
+      //LOG("WCCR.init: There is no auto branch, benign");
+    }
+  },
+
+  /**
+   * See nsIObserver
+   */
+  observe: function WCCR_observe(subject, topic, data) {
+    var os = 
+        Cc["@mozilla.org/observer-service;1"].
+        getService(Ci.nsIObserverService);
+    switch (topic) {
+    case "app-startup":
+      os.addObserver(this, "profile-after-change", false);
+      os.addObserver(this, "xpcom-shutdown", false);
+      break;
+    case "profile-after-change":
+      os.removeObserver(this, "profile-after-change");
+      this._init();
+      break;
+    case "xpcom-shutdown":
+      this.classID = null;
+    }
+  },
+  
+  /**
+   * See nsIFactory
+   */
+  createInstance: function WCCR_createInstance(outer, iid) {
+    if (outer != null)
+      throw Cr.NS_ERROR_NO_AGGREGATION;
+    return this.QueryInterface(iid);
+  },
+
+  /**
+   * See nsIClassInfo
+   */
+  getInterfaces: function WCCR_getInterfaces(countRef) {
+    var interfaces = 
+        [Ci.nsIWebContentConverterService, Ci.nsIWebContentHandlerRegistrar,
+         Ci.nsIObserver, Ci.nsIClassInfo, Ci.nsIFactory, Ci.nsISupports];
+    countRef.value = interfaces.length;
+    return interfaces;
+  },
+  getHelperForLanguage: function WCCR_getHelperForLanguage(language) {
+    return null;
+  },
+  contractID: WCCR_CONTRACTID,
+  classDescription: WCCR_CLASSNAME,
+  classID: WCCR_CLASSID,
+  implementationLanguage: Ci.nsIProgrammingLanguage.JAVASCRIPT,
+  flags: Ci.nsIClassInfo.DOM_OBJECT,
+  
+  /**
+   * See nsISupports
+   */
+  QueryInterface: function WCCR_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIWebContentConverterService) || 
+        iid.equals(Ci.nsIWebContentHandlerRegistrar) ||
+        iid.equals(Ci.nsIObserver) ||
+        iid.equals(Ci.nsIClassInfo) ||
+        iid.equals(Ci.nsIFactory) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+};
+
+var Module = {
+  QueryInterface: function M_QueryInterface(iid) {
+    if (iid.equals(Ci.nsIModule) ||
+        iid.equals(Ci.nsISupports))
+      return this;
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+  
+  getClassObject: function M_getClassObject(cm, cid, iid) {
+    if (!iid.equals(Ci.nsIFactory))
+      throw Cr.NS_ERROR_NOT_IMPLEMENTED;
+    
+    if (cid.equals(WCCR_CLASSID))
+      return WebContentConverterRegistrar;
+      
+    throw Cr.NS_ERROR_NO_INTERFACE;
+  },
+  
+  registerSelf: function M_registerSelf(cm, file, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+    cr.registerFactoryLocation(WCCR_CLASSID, WCCR_CLASSNAME, WCCR_CONTRACTID,
+                               file, location, type);
+
+    var catman = 
+        Cc["@mozilla.org/categorymanager;1"].getService(Ci.nsICategoryManager);
+    catman.addCategoryEntry("app-startup", WCCR_CLASSNAME, 
+                            "service," + WCCR_CONTRACTID, true, true);
+  },
+  
+  unregisterSelf: function M_unregisterSelf(cm, location, type) {
+    var cr = cm.QueryInterface(Ci.nsIComponentRegistrar);
+    cr.unregisterFactoryLocation(WCCR_CLASSID, location);
+  },
+  
+  canUnload: function M_canUnload(cm) {
+    return true;
+  }
+};
+
+function NSGetModule(cm, file) {
+  return Module;
+}
+
+#include ../../../../toolkit/content/debug.js
+
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/nsAboutFeeds.cpp mozilla/toolkit/components/browser-feeds/src/nsAboutFeeds.cpp
--- mozilla-orig/toolkit/components/browser-feeds/src/nsAboutFeeds.cpp	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/nsAboutFeeds.cpp	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:set ts=4 sw=4 sts=4 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is The about:feeds Page.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsAboutFeeds.h"
+#include "nsNetUtil.h"
+#include "nsIScriptSecurityManager.h"
+
+NS_IMPL_ISUPPORTS1(nsAboutFeeds, nsIAboutModule)
+
+#define FEEDS_PAGE_URI "chrome://browser/content/feeds/subscribe.xhtml"
+
+NS_IMETHODIMP
+nsAboutFeeds::NewChannel(nsIURI* uri, nsIChannel** result)
+{
+  printf ("nsAboutFeeds::NewChannel\n");
+  nsresult rv;
+  nsCOMPtr<nsIIOService> ios(do_GetIOService(&rv));
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsIChannel> channel;
+  rv = ios->NewChannel(NS_LITERAL_CSTRING(FEEDS_PAGE_URI),
+                       nsnull, nsnull, getter_AddRefs(channel));
+  if (NS_FAILED(rv))
+    return rv;
+
+  channel->SetOriginalURI(uri);
+
+  nsCOMPtr<nsIScriptSecurityManager> ssm =
+    do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsIPrincipal> principal;
+  rv = ssm->GetCodebasePrincipal(uri, getter_AddRefs(principal));
+  if (NS_FAILED(rv))
+    return rv;
+
+  rv = channel->SetOwner(principal);
+  if (NS_FAILED(rv))
+    return rv;
+
+  NS_ADDREF(*result = channel);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsAboutFeeds::GetURIFlags(nsIURI* uri, PRUint32* uriFlags)
+{
+  // Feeds page needs script, and is untrusted-content-safe
+  *uriFlags = URI_SAFE_FOR_UNTRUSTED_CONTENT | ALLOW_SCRIPT;
+  return NS_OK;
+}
+
+NS_METHOD
+nsAboutFeeds::Create(nsISupports* outer, REFNSIID iid, void** result)
+{
+  printf ("nsAboutFeeds::Create\n");
+  nsAboutFeeds* aboutFeeds = new nsAboutFeeds();
+  if (aboutFeeds == nsnull)
+    return NS_ERROR_OUT_OF_MEMORY;
+  NS_ADDREF(aboutFeeds);
+  nsresult rv = aboutFeeds->QueryInterface(iid, result);
+  NS_RELEASE(aboutFeeds);
+  return rv;
+}
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/nsAboutFeeds.h mozilla/toolkit/components/browser-feeds/src/nsAboutFeeds.h
--- mozilla-orig/toolkit/components/browser-feeds/src/nsAboutFeeds.h	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/nsAboutFeeds.h	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,60 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* vim:set ts=4 sw=4 sts=4 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is The about:feeds Page.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#ifndef nsAboutFeeds_h__
+#define nsAboutFeeds_h__
+
+#include "nsIAboutModule.h"
+
+class nsAboutFeeds : public nsIAboutModule
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  NS_DECL_NSIABOUTMODULE
+
+  nsAboutFeeds() { }
+  virtual ~nsAboutFeeds() { }
+  
+  static NS_METHOD
+    Create(nsISupports* outer, REFNSIID iid, void** result);
+protected:
+};
+
+#endif // nsAboutFeeds_h__
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/nsFeedSniffer.cpp mozilla/toolkit/components/browser-feeds/src/nsFeedSniffer.cpp
--- mozilla-orig/toolkit/components/browser-feeds/src/nsFeedSniffer.cpp	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/nsFeedSniffer.cpp	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,467 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Content Sniffer.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *   Robert Sayre <sayrer@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsFeedSniffer.h"
+
+#include "prmem.h"
+
+#include "nsNetCID.h"
+#include "nsXPCOM.h"
+#include "nsCOMPtr.h"
+#include "nsStringStream.h"
+
+//#include "nsBrowserCompsCID.h"
+#include "nsToolkitCompsCID.h"
+
+#include "nsICategoryManager.h"
+#include "nsIServiceManager.h"
+#include "nsComponentManagerUtils.h"
+#include "nsServiceManagerUtils.h"
+
+#include "nsIStreamConverterService.h"
+#include "nsIStreamConverter.h"
+
+#include "nsIStreamListener.h"
+
+#include "nsIHttpChannel.h"
+#include "nsIMIMEHeaderParam.h"
+
+#define TYPE_ATOM "application/atom+xml"
+#define TYPE_RSS "application/rss+xml"
+#define TYPE_MAYBE_FEED "application/vnd.mozilla.maybe.feed"
+
+#define NS_RDF "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+#define NS_RSS "http://purl.org/rss/1.0/"
+
+#define MAX_BYTES 512
+
+NS_IMPL_ISUPPORTS2(nsFeedSniffer, nsIContentSniffer, nsIStreamListener)
+
+nsresult
+nsFeedSniffer::ConvertEncodedData(nsIRequest* request,
+                                  const PRUint8* data,
+                                  PRUint32 length)
+{
+  printf ("nsFeedSniffer::ConvertEncodedData\n");
+  nsresult rv = NS_OK;
+
+  mDecodedData = "";
+  nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(request));
+  if (!httpChannel)
+    return NS_ERROR_NO_INTERFACE;
+
+  nsCAutoString contentEncoding;
+  httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("Content-Encoding"), 
+                                 contentEncoding);
+  if (!contentEncoding.IsEmpty()) {
+    nsCOMPtr<nsIStreamConverterService> converterService(do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID));
+    if (converterService) {
+      ToLowerCase(contentEncoding);
+
+      nsCOMPtr<nsIStreamListener> converter;
+      rv = converterService->AsyncConvertData(contentEncoding.get(), 
+                                              "uncompressed", this, nsnull, 
+                                              getter_AddRefs(converter));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      converter->OnStartRequest(request, nsnull);
+
+      nsCOMPtr<nsIStringInputStream> rawStream =
+        do_CreateInstance(NS_STRINGINPUTSTREAM_CONTRACTID);
+      if (!rawStream)
+        return NS_ERROR_FAILURE;
+
+      rv = rawStream->SetData((const char*)data, length);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = converter->OnDataAvailable(request, nsnull, rawStream, 0, length);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      converter->OnStopRequest(request, nsnull, NS_OK);
+    }
+  }
+  return rv;
+}
+
+template<int N>
+static PRBool
+StringBeginsWithLowercaseLiteral(nsAString& aString,
+                                 const char (&aSubstring)[N])
+{
+  return StringHead(aString, N).LowerCaseEqualsLiteral(aSubstring);
+}
+
+// XXXsayrer put this in here to get on the branch with minimal delay.
+// Trunk really needs to factor this out. This is the third usage.
+PRBool
+HasAttachmentDisposition(nsIHttpChannel* httpChannel)
+{
+  if (!httpChannel)
+    return PR_FALSE;
+  
+  nsCAutoString contentDisposition;
+  nsresult rv = 
+    httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("content-disposition"),
+                                   contentDisposition);
+  
+  if (NS_SUCCEEDED(rv) && !contentDisposition.IsEmpty()) {
+    nsCOMPtr<nsIURI> uri;
+    httpChannel->GetURI(getter_AddRefs(uri));
+    nsCOMPtr<nsIMIMEHeaderParam> mimehdrpar =
+      do_GetService(NS_MIMEHEADERPARAM_CONTRACTID, &rv);
+    if (NS_SUCCEEDED(rv))
+    {
+      nsCAutoString fallbackCharset;
+      if (uri)
+        uri->GetOriginCharset(fallbackCharset);
+      nsAutoString dispToken;
+      // Get the disposition type
+      rv = mimehdrpar->GetParameter(contentDisposition, "", fallbackCharset,
+                                    PR_TRUE, nsnull, dispToken);
+      // RFC 2183, section 2.8 says that an unknown disposition
+      // value should be treated as "attachment"
+      // XXXbz this code is duplicated in GetFilenameAndExtensionFromChannel in
+      // nsExternalHelperAppService.  Factor it out!
+      if (NS_FAILED(rv) || 
+          (// Some broken sites just send
+           // Content-Disposition: ; filename="file"
+           // screen those out here.
+           !dispToken.IsEmpty() &&
+           !StringBeginsWithLowercaseLiteral(dispToken, "inline") &&
+           // Broken sites just send
+           // Content-Disposition: filename="file"
+           // without a disposition token... screen those out.
+           !StringBeginsWithLowercaseLiteral(dispToken, "filename")) &&
+          // Also in use is Content-Disposition: name="file"
+          !StringBeginsWithLowercaseLiteral(dispToken, "name"))
+        // We have a content-disposition of "attachment" or unknown
+        return PR_TRUE;
+    }
+  } 
+  
+  return PR_FALSE;
+}
+
+/**
+ * @return the first occurrence of a character within a string buffer,
+ *         or nsnull if not found
+ */
+static const char*
+FindChar(char c, const char *begin, const char *end)
+{
+  for (; begin < end; ++begin) {
+    if (*begin == c)
+      return begin;
+  }
+  return nsnull;
+}
+
+/**
+ *
+ * Determine if a substring is the "documentElement" in the document.
+ *
+ * All of our sniffed substrings: <rss, <feed, <rdf:RDF must be the "document"
+ * element within the XML DOM, i.e. the root container element. Otherwise,
+ * it's possible that someone embedded one of these tags inside a document of
+ * another type, e.g. a HTML document, and we don't want to show the preview
+ * page if the document isn't actually a feed.
+ * 
+ * @param   start
+ *          The beginning of the data being sniffed
+ * @param   end
+ *          The end of the data being sniffed, right before the substring that
+ *          was found.
+ * @returns PR_TRUE if the found substring is the documentElement, PR_FALSE 
+ *          otherwise.
+ */
+static PRBool
+IsDocumentElement(const char *start, const char* end)
+{
+  // For every tag in the buffer, check to see if it's a PI, Doctype or 
+  // comment, our desired substring or something invalid.
+  while ( (start = FindChar('<', start, end)) ) {
+    ++start;
+    if (start >= end)
+      return PR_FALSE;
+
+    // Check to see if the character following the '<' is either '?' or '!'
+    // (processing instruction or doctype or comment)... these are valid nodes
+    // to have in the prologue. 
+    if (*start != '?' && *start != '!')
+      return PR_FALSE;
+    
+    // Now advance the iterator until the '>' (We do this because we don't want
+    // to sniff indicator substrings that are embedded within other nodes, e.g.
+    // comments: <!-- <rdf:RDF .. > -->
+    start = FindChar('>', start, end);
+    if (!start)
+      return PR_FALSE;
+
+    ++start;
+  }
+  return PR_TRUE;
+}
+
+/**
+ * Determines whether or not a string exists as the root element in an XML data
+ * string buffer.
+ * @param   dataString
+ *          The data being sniffed
+ * @param   substring
+ *          The substring being tested for existence and root-ness.
+ * @returns PR_TRUE if the substring exists and is the documentElement, PR_FALSE
+ *          otherwise.
+ */
+static PRBool
+ContainsTopLevelSubstring(nsACString& dataString, const char *substring) 
+{
+  printf("ContainsTopLevelSubstring\n");
+/*
+  PRInt32 offset = dataString.Find(substring);
+  if (offset == -1)
+    return PR_FALSE;
+
+  const char *begin = dataString.BeginReading();
+*/
+
+  nsCString s(dataString);
+  const char *data = (const char *) s.get();
+  const char *begin = strstr(data, substring);
+
+  if (!begin)
+    return PR_FALSE;
+
+  PRInt32 offset = strlen(data) - strlen(begin);
+
+  begin = strdup (data);
+
+// printf ("\n\n\n******************************************\n");
+// printf ("'%d\n'", offset);
+// printf ("'%s'\n", begin);
+// printf ("******************************************\n");
+
+  // Only do the validation when we find the substring.
+  return IsDocumentElement(begin, begin + offset);
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::GetMIMETypeFromContent(nsIRequest* request, 
+                                      const PRUint8* data, 
+                                      PRUint32 length, 
+                                      nsACString& sniffedType)
+{
+  printf ("nsFeedSniffer::GetMIMETypeFromContent\n");
+  nsCOMPtr<nsIHttpChannel> channel(do_QueryInterface(request));
+  if (!channel)
+    return NS_ERROR_NO_INTERFACE;
+
+  // Check that this is a GET request, since you can't subscribe to a POST...
+  nsCAutoString method;
+  channel->GetRequestMethod(method);
+  if (!method.Equals("GET")) {
+    sniffedType.Truncate();
+    return NS_OK;
+  }
+
+  // We need to find out if this is a load of a view-source document. In this
+  // case we do not want to override the content type, since the source display
+  // does not need to be converted from feed format to XUL. More importantly, 
+  // we don't want to change the content type from something 
+  // nsContentDLF::CreateInstance knows about (e.g. application/xml, text/html 
+  // etc) to something that only the application fe knows about (maybe.feed) 
+  // thus deactivating syntax highlighting.
+  nsCOMPtr<nsIURI> originalURI;
+  channel->GetOriginalURI(getter_AddRefs(originalURI));
+
+  nsCAutoString scheme;
+  originalURI->GetScheme(scheme);
+  if (scheme.EqualsLiteral("view-source")) {
+    printf ("nsFeedSniffer::GetMIMETypeFromContent view-source\n");
+    sniffedType.Truncate();
+    return NS_OK;
+  }
+
+  // Check the Content-Type to see if it is set correctly. If it is set to 
+  // something specific that we think is a reliable indication of a feed, don't
+  // bother sniffing since we assume the site maintainer knows what they're 
+  // doing. 
+  nsCAutoString contentType;
+  channel->GetContentType(contentType);
+  PRBool noSniff = contentType.EqualsLiteral(TYPE_RSS) ||
+                   contentType.EqualsLiteral(TYPE_ATOM);
+
+  // Check to see if this was a feed request from the location bar or from
+  // the feed: protocol. This is also a reliable indication.
+  // The value of the header doesn't matter.  
+  if (!noSniff) {
+    printf ("nsFeedSniffer::GetMIMETypeFromContent !noSniff\n");
+    nsCAutoString sniffHeader;
+    nsresult foundHeader =
+      channel->GetRequestHeader(NS_LITERAL_CSTRING("X-Moz-Is-Feed"),
+                                sniffHeader);
+    noSniff = NS_SUCCEEDED(foundHeader);
+  }
+
+  if (noSniff) {
+    printf ("nsFeedSniffer::GetMIMETypeFromContent noSniff\n");
+    // check for an attachment after we have a likely feed.
+    if(HasAttachmentDisposition(channel)) {
+      printf ("nsFeedSniffer::GetMIMETypeFromContent !noSniff HasAttachmentDisposition\n");
+      sniffedType.Truncate();
+      return NS_OK;
+    }
+
+    // set the feed header as a response header, since we have good metadata
+    // telling us that the feed is supposed to be RSS or Atom
+    channel->SetResponseHeader(NS_LITERAL_CSTRING("X-Moz-Is-Feed"),
+                               NS_LITERAL_CSTRING("1"), PR_FALSE);
+    sniffedType.AssignLiteral(TYPE_MAYBE_FEED);
+    printf ("nsFeedSniffer::GetMIMETypeFromContent TYPE_MAYBE_FEED\n");
+    return NS_OK;
+  }
+
+  // Now we need to potentially decompress data served with 
+  // Content-Encoding: gzip
+  nsresult rv = ConvertEncodedData(request, data, length);
+  if (NS_FAILED(rv))
+    return rv;
+  
+  const char* testData = 
+    mDecodedData.IsEmpty() ? (const char*)data : mDecodedData.get();
+
+  // The strategy here is based on that described in:
+  // http://blogs.msdn.com/rssteam/articles/PublishersGuide.aspx
+  // for interoperarbility purposes.
+
+  // We cap the number of bytes to scan at MAX_BYTES to prevent picking up 
+  // false positives by accidentally reading document content, e.g. a "how to
+  // make a feed" page.
+  if (length > MAX_BYTES)
+    length = MAX_BYTES;
+
+  // Thus begins the actual sniffing.
+//  nsDependentCSubstring dataString((const char*)testData, length);
+// printf ("nsFeedSniffer::GetMIMETypeFromContent 2\n");
+  char *tmp_str = strdup(testData);
+  strncpy(tmp_str, testData, length);
+  if (!tmp_str)  
+    return NS_OK; 
+
+// printf ("******************************************\n");
+// printf ("'%s'\n", tmp_str);
+// printf ("******************************************\n");
+
+  nsCString dataString((const char *)tmp_str);
+
+  PRBool isFeed = PR_FALSE;
+
+  // RSS 0.91/0.92/2.0
+  isFeed = ContainsTopLevelSubstring(dataString, "<rss");
+//   if (!isFeed) printf ("nsFeedSniffer::GetMIMETypeFromContent !isFeed 1\n");
+  // Atom 1.0
+  if (!isFeed)
+    isFeed = ContainsTopLevelSubstring(dataString, "<feed");
+//   if (!isFeed) printf ("nsFeedSniffer::GetMIMETypeFromContent !isFeed 2\n");
+  // RSS 1.0
+  if (!isFeed) {
+    isFeed = ContainsTopLevelSubstring(dataString, "<rdf:RDF") &&
+      dataString.Find(NS_RDF) &&
+      dataString.Find(NS_RSS);
+  }
+
+  // If we sniffed a feed, coerce our internal type
+  if (isFeed && !HasAttachmentDisposition(channel)) {
+    printf ("IS MAYBE FEED\n");
+    sniffedType.AssignLiteral(TYPE_MAYBE_FEED); }
+  else
+    sniffedType.Truncate();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::OnStartRequest(nsIRequest* request, nsISupports* context)
+{
+  return NS_OK;
+}
+
+NS_METHOD
+nsFeedSniffer::AppendSegmentToString(nsIInputStream* inputStream,
+                                     void* closure,
+                                     const char* rawSegment,
+                                     PRUint32 toOffset,
+                                     PRUint32 count,
+                                     PRUint32* writeCount)
+{
+  nsCString* decodedData = NS_STATIC_CAST(nsCString*, closure);
+  decodedData->Append(rawSegment, count);
+  *writeCount = count;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::OnDataAvailable(nsIRequest* request, nsISupports* context,
+                               nsIInputStream* stream, PRUint32 offset, 
+                               PRUint32 count)
+{
+  PRUint32 read;
+  return stream->ReadSegments(AppendSegmentToString, &mDecodedData, count, 
+                              &read);
+}
+
+NS_IMETHODIMP
+nsFeedSniffer::OnStopRequest(nsIRequest* request, nsISupports* context, 
+                             nsresult status)
+{
+  return NS_OK; 
+}
+
+NS_METHOD
+nsFeedSniffer::Register(nsIComponentManager *compMgr, nsIFile *path, 
+                        const char *registryLocation,
+                        const char *componentType, 
+                        const nsModuleComponentInfo *info)
+{
+  nsresult rv;
+  nsCOMPtr<nsICategoryManager> catman = do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv);
+  if (NS_FAILED(rv)) 
+    return rv;
+
+  return catman->AddCategoryEntry(NS_CONTENT_SNIFFER_CATEGORY, "Feed Sniffer", 
+                                  NS_FEEDSNIFFER_CONTRACTID, PR_TRUE, PR_TRUE, 
+                                  nsnull);
+}
diff -U8 -prN mozilla-orig/toolkit/components/browser-feeds/src/nsFeedSniffer.h mozilla/toolkit/components/browser-feeds/src/nsFeedSniffer.h
--- mozilla-orig/toolkit/components/browser-feeds/src/nsFeedSniffer.h	1969-12-31 20:00:00.000000000 -0400
+++ mozilla/toolkit/components/browser-feeds/src/nsFeedSniffer.h	2008-01-15 10:25:39.000000000 -0400
@@ -0,0 +1,78 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Feed Content Sniffer.
+ *
+ * The Initial Developer of the Original Code is Google Inc.
+ * Portions created by the Initial Developer are Copyright (C) 2006
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Ben Goodger <beng@google.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "nsIGenericFactory.h"
+#include "nsIContentSniffer.h"
+#include "nsIStreamListener.h"
+#ifdef MOZILLA_INTERNAL_API
+#include "nsString.h"
+#include "nsXPIDLString.h"
+#include "nsReadableUtils.h"
+#else
+#include "nsStringAPI.h"
+#endif
+
+
+class nsFeedSniffer : public nsIContentSniffer, nsIStreamListener
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSICONTENTSNIFFER
+  NS_DECL_NSIREQUESTOBSERVER
+  NS_DECL_NSISTREAMLISTENER
+
+  static NS_METHOD AppendSegmentToString(nsIInputStream* inputStream,
+                                         void* closure,
+                                         const char* rawSegment,
+                                         PRUint32 toOffset,
+                                         PRUint32 count,
+                                         PRUint32* writeCount);
+
+  static NS_METHOD Register(nsIComponentManager* compMgr, nsIFile* path, 
+                            const char* registryLocation,
+                            const char* componentType, 
+                            const nsModuleComponentInfo *info);
+
+protected:
+  nsresult ConvertEncodedData(nsIRequest* request, const PRUint8* data,
+                              PRUint32 length);
+
+private:
+  nsCString mDecodedData;
+};
+
diff -U8 -prN mozilla-orig/toolkit/components/build/Makefile.in mozilla/toolkit/components/build/Makefile.in
--- mozilla-orig/toolkit/components/build/Makefile.in	2008-01-15 10:22:26.000000000 -0400
+++ mozilla/toolkit/components/build/Makefile.in	2008-01-15 10:40:46.000000000 -0400
@@ -82,29 +82,31 @@ REQUIRES = 	\
 		find \
 		gfx \
 		locale \
 		unicharutil \
 		xuldoc \
 		alerts \
 		url-classifier \
 		feeds \
+		browser-feeds \
 		storage \
 		$(NULL)
 
 EXPORTS = nsToolkitCompsCID.h
 
 CPPSRCS = nsToolkitCompsModule.cpp
 
 LOCAL_INCLUDES = \
 	-I$(srcdir)/../downloads/src \
 	-I$(srcdir)/../startup/src \
 	-I$(srcdir)/../typeaheadfind/src \
 	-I$(srcdir)/../url-classifier/src \
 	-I$(srcdir)/../feeds/src \
+	-I$(srcdir)/../browser-feeds/src \
 	$(NULL)
 
 ifdef ALERTS_SERVICE
 LOCAL_INCLUDES += \
 	-I$(srcdir)/../alerts/src \
 	$(NULL)
 endif
 
@@ -132,16 +134,17 @@ SHARED_LIBRARY_LIBS += ../alerts/src/mac
 endif
 
 ifdef MOZ_URL_CLASSIFIER
 SHARED_LIBRARY_LIBS += ../url-classifier/src/$(LIB_PREFIX)urlclassifier_s.$(LIB_SUFFIX)
 endif
 
 ifdef MOZ_FEEDS
 SHARED_LIBRARY_LIBS += ../feeds/src/$(LIB_PREFIX)feed_s.$(LIB_SUFFIX)
+SHARED_LIBRARY_LIBS += ../browser-feeds/src/$(LIB_PREFIX)browser_feeds_s.$(LIB_SUFFIX)
 endif
 
 SHARED_LIBRARY_LIBS += ../typeaheadfind/src/$(LIB_PREFIX)fastfind_s.$(LIB_SUFFIX)
 EXTRA_DSO_LIBS = gkgfx
 
 EXTRA_DSO_LDOPTS += \
 	$(LIBS_DIR) \
 	$(EXTRA_DSO_LIBS) \
diff -U8 -prN mozilla-orig/toolkit/components/build/nsToolkitCompsCID.h mozilla/toolkit/components/build/nsToolkitCompsCID.h
--- mozilla-orig/toolkit/components/build/nsToolkitCompsCID.h	2008-01-15 10:22:26.000000000 -0400
+++ mozilla/toolkit/components/build/nsToolkitCompsCID.h	2008-01-15 10:42:43.000000000 -0400
@@ -172,8 +172,18 @@
 #define NS_NAVBOOKMARKSSERVICE_CID \
 { 0x9de95a0c, 0x39a4, 0x4d64, {0x9a, 0x53, 0x17, 0x94, 0x0d, 0xd7, 0xca, 0xbb}}
 
 #define NS_MORKHISTORYIMPORTER_CID \
 { 0x428e6d12, 0x9c6d, 0x436f, {0xb7, 0xa3, 0x6c, 0xa5, 0xf4, 0x80, 0x92, 0x12}}
 
 #define NS_FAVICONSERVICE_CID \
 { 0x984e3259, 0x9266, 0x49cf, { 0xb6, 0x05, 0x60, 0xb0, 0x22, 0xa0, 0x07, 0x56 } }
+
+#define NS_FEEDSNIFFER_CID \
+{ 0x6893e69, 0x71d8, 0x4b23, { 0x81, 0xeb, 0x80, 0x31, 0x4d, 0xaf, 0x3e, 0x66 } }
+
+#define NS_FEEDSNIFFER_CONTRACTID \
+"@mozilla.org/browser/feeds/sniffer;1"
+
+#define NS_ABOUTFEEDS_CID \
+{ 0x12ff56ec, 0x58be, 0x402c, { 0xb0, 0x57, 0x1, 0xf9, 0x61, 0xde, 0x96, 0x9b } }
+
diff -U8 -prN mozilla-orig/toolkit/components/build/nsToolkitCompsModule.cpp mozilla/toolkit/components/build/nsToolkitCompsModule.cpp
--- mozilla-orig/toolkit/components/build/nsToolkitCompsModule.cpp	2008-01-15 10:22:26.000000000 -0400
+++ mozilla/toolkit/components/build/nsToolkitCompsModule.cpp	2008-01-15 10:43:02.000000000 -0400
@@ -61,16 +61,18 @@
 #ifdef MOZ_URL_CLASSIFIER
 #include "nsUrlClassifierDBService.h"
 #include "nsUrlClassifierStreamUpdater.h"
 #include "nsUrlClassifierUtils.h"
 #endif
 
 #ifdef MOZ_FEEDS
 #include "nsScriptableUnescapeHTML.h"
+#include "nsFeedSniffer.h"
+#include "nsAboutFeeds.h"
 #endif
 
 /////////////////////////////////////////////////////////////////////////////
 
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsAppStartup, Init)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsUserInfo)
 
 #ifdef ALERTS_SERVICE
@@ -95,16 +97,17 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsTypeAhe
 NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsUrlClassifierDBService,
                                          nsUrlClassifierDBService::GetInstance)
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsUrlClassifierStreamUpdater)
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsUrlClassifierUtils, Init)
 #endif
 
 #ifdef MOZ_FEEDS
 NS_GENERIC_FACTORY_CONSTRUCTOR(nsScriptableUnescapeHTML)
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsFeedSniffer)
 #endif
 
 /////////////////////////////////////////////////////////////////////////////
 
 static const nsModuleComponentInfo components[] =
 {
   { "App Startup Service",
     NS_TOOLKIT_APPSTARTUP_CID,
@@ -157,12 +160,22 @@ static const nsModuleComponentInfo compo
     NS_URLCLASSIFIERUTILS_CONTRACTID,
     nsUrlClassifierUtilsConstructor },
 #endif
 #ifdef MOZ_FEEDS
   { "Unescape HTML",
     NS_SCRIPTABLEUNESCAPEHTML_CID,
     NS_SCRIPTABLEUNESCAPEHTML_CONTRACTID,
     nsScriptableUnescapeHTMLConstructor },
+  { "Feed Sniffer",
+    NS_FEEDSNIFFER_CID,
+    NS_FEEDSNIFFER_CONTRACTID,
+    nsFeedSnifferConstructor,
+   nsFeedSniffer::Register },
+  { "about:feeds Page",
+    NS_ABOUTFEEDS_CID,
+    NS_ABOUT_MODULE_CONTRACTID_PREFIX "feeds",
+    nsAboutFeeds::Create
+  },
 #endif
 };
 
 NS_IMPL_NSGETMODULE(nsToolkitCompsModule, components)
diff -U8 -prN mozilla-orig/toolkit/library/libxul-config.mk mozilla/toolkit/library/libxul-config.mk
--- mozilla-orig/toolkit/library/libxul-config.mk	2008-01-15 10:22:28.000000000 -0400
+++ mozilla/toolkit/library/libxul-config.mk	2008-01-15 10:39:47.000000000 -0400
@@ -259,17 +259,17 @@ endif
 COMPONENT_LIBS += \
 	jar$(VERSION_NUMBER) \
 	$(NULL)
 	
 COMPONENT_LIBS += \
  	commandlines \
  	$(NULL)
 
-ifndef MOZ_MICROB
+ifdef MOZ_MICROB
 COMPONENT_LIBS += \
  	toolkitcomps \
  	$(NULL)
 endif
 
 ifdef MOZ_MATHML
 COMPONENT_LIBS += ucvmath
 endif
diff -U8 -prN mozilla-orig/toolkit/library/nsStaticXULComponents.cpp mozilla/toolkit/library/nsStaticXULComponents.cpp
--- mozilla-orig/toolkit/library/nsStaticXULComponents.cpp	2008-01-15 10:22:28.000000000 -0400
+++ mozilla/toolkit/library/nsStaticXULComponents.cpp	2008-01-15 10:42:09.000000000 -0400
@@ -258,17 +258,17 @@
 #define XULENABLED_MODULES                   \
     MODULE(tkAutoCompleteModule)             \
     MODULE(PKI)
 #endif
 #else
 #define XULENABLED_MODULES
 #endif
 
-#ifndef MOZ_MICROB
+#ifdef MOZ_MICROB
 #define STD_MODULES                          \
     MODULE(nsToolkitCompsModule)             \
     MODULE(nsJarModule)
 #else
 #define STD_MODULES MODULE(nsJarModule)
 #endif
 
 #ifdef MOZ_SPELLCHECK
