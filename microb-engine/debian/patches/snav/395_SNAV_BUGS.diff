# Overall improvements on Spatial navigation (snav) default algorithm. 
# Solved bugs: 51075, 49691, 44373, 35989, 35989, 51092, 51012, 51992, 51989. 
Index: mozilla/content/html/content/src/nsHTMLInputElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsHTMLInputElement.cpp
+++ mozilla/content/html/content/src/nsHTMLInputElement.cpp
@@ -1601,23 +1601,26 @@
           if ((aVisitor.mEvent->message == NS_KEY_PRESS &&
                keyEvent->keyCode == NS_VK_RETURN) ||
               (aVisitor.mEvent->message == NS_KEY_UP &&
                keyEvent->keyCode == NS_VK_SPACE)) {
             switch(mType) {
               case NS_FORM_INPUT_CHECKBOX:
               case NS_FORM_INPUT_RADIO:
               {
-                // Checkbox and Radio try to submit on Enter press
-                if (keyEvent->keyCode != NS_VK_SPACE) {
-                  MaybeSubmitForm(aVisitor.mPresContext);
+#ifdef MOZ_MICROB
+                if (!nsContentUtils::GetBoolPref("snav.enabled", PR_TRUE))
+#endif
+                  // Checkbox and Radio try to submit on Enter press
+                  if (keyEvent->keyCode != NS_VK_SPACE) {
+                    MaybeSubmitForm(aVisitor.mPresContext);
 
-                  break;  // If we are submitting, do not send click event
-                }
-                // else fall through and treat Space like click...
+                    break;  // If we are submitting, do not send click event
+                  }
+                  // else fall through and treat Space like click...
               }
               case NS_FORM_INPUT_BUTTON:
               case NS_FORM_INPUT_RESET:
               case NS_FORM_INPUT_SUBMIT:
               case NS_FORM_INPUT_IMAGE: // Bug 34418
               {
                 nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
                                    NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
@@ -1628,50 +1631,53 @@
                                             nsnull, &status);
               } // case
             } // switch
           }
           if (aVisitor.mEvent->message == NS_KEY_PRESS &&
               mType == NS_FORM_INPUT_RADIO && !keyEvent->isAlt &&
               !keyEvent->isControl && !keyEvent->isMeta) {
             PRBool isMovingBack = PR_FALSE;
-            switch (keyEvent->keyCode) {
-              case NS_VK_UP: 
-              case NS_VK_LEFT:
-                isMovingBack = PR_TRUE;
-              case NS_VK_DOWN:
-              case NS_VK_RIGHT:
-              // Arrow key pressed, focus+select prev/next radio button
-              nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
-              if (container) {
-                nsAutoString name;
-                if (GetNameIfExists(name)) {
-                  nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton;
-                  container->GetNextRadioButton(name, isMovingBack, this,
-                                                getter_AddRefs(selectedRadioButton));
-                  nsCOMPtr<nsIContent> radioContent =
-                    do_QueryInterface(selectedRadioButton);
-                  if (radioContent) {
-                    rv = selectedRadioButton->Focus();
-                    if (NS_SUCCEEDED(rv)) {
-                      nsEventStatus status = nsEventStatus_eIgnore;
-                      nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
-                                         NS_MOUSE_CLICK, nsnull,
-                                         nsMouseEvent::eReal);
-                      rv = nsEventDispatcher::Dispatch(radioContent,
-                                                       aVisitor.mPresContext,
-                                                       &event, nsnull, &status);
+#ifdef MOZ_MICROB
+            if (!nsContentUtils::GetBoolPref("snav.enabled", PR_TRUE))
+#endif
+              switch (keyEvent->keyCode) {
+                case NS_VK_UP:
+                case NS_VK_LEFT:
+                  isMovingBack = PR_TRUE;
+                case NS_VK_DOWN:
+                case NS_VK_RIGHT:
+                // Arrow key pressed, focus+select prev/next radio button
+                nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
+                if (container) {
+                  nsAutoString name;
+                  if (GetNameIfExists(name)) {
+                    nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton;
+                    container->GetNextRadioButton(name, isMovingBack, this,
+                                                  getter_AddRefs(selectedRadioButton));
+                    nsCOMPtr<nsIContent> radioContent =
+                      do_QueryInterface(selectedRadioButton);
+                    if (radioContent) {
+                      rv = selectedRadioButton->Focus();
                       if (NS_SUCCEEDED(rv)) {
-                        aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
+                        nsEventStatus status = nsEventStatus_eIgnore;
+                        nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
+                                           NS_MOUSE_CLICK, nsnull,
+                                           nsMouseEvent::eReal);
+                        rv = nsEventDispatcher::Dispatch(radioContent,
+                                                         aVisitor.mPresContext,
+                                                         &event, nsnull, &status);
+                        if (NS_SUCCEEDED(rv)) {
+                          aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
+                        }
                       }
                     }
                   }
                 }
               }
-            }
           }
 
           /*
            * If this is input type=text, and the user hit enter, fire onChange
            * and submit the form (if we are in one)
            *
            * Bug 99920, bug 109463 and bug 147850:
            * (a) if there is a submit control in the form, click the first
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigationService.cpp
===================================================================
--- mozilla.orig/extensions/spatialnavigation/src/nsSpatialNavigationService.cpp
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationService.cpp
@@ -35,17 +35,17 @@
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSpatialNavigationPrivate.h"
 #include "nsIObserverService.h"
 
 nsSpatialNavigationService::nsSpatialNavigationService()  
 {
   mEnabled             = PR_TRUE;
-  mIgnoreTextFields    = PR_TRUE;
+  mIgnoreTextFields    = PR_FALSE;
   mDisableJSWhenFocusing = PR_TRUE;
 
   mKeyCodeLeft         = nsIDOMKeyEvent::DOM_VK_LEFT;
   mKeyCodeRight        = nsIDOMKeyEvent::DOM_VK_RIGHT;
   mKeyCodeUp           = nsIDOMKeyEvent::DOM_VK_UP;
   mKeyCodeDown         = nsIDOMKeyEvent::DOM_VK_DOWN;
 
   mKeyCodeModifier     = 0x00000012 | 0x00100000; // By default ALT and SHIFT
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigationPrivate.h
===================================================================
--- mozilla.orig/extensions/spatialnavigation/src/nsSpatialNavigationPrivate.h
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationPrivate.h
@@ -66,16 +66,17 @@
 #include "nsIDOMHTMLAnchorElement.h"
 #include "nsIDOMHTMLAreaElement.h"
 #include "nsIDOMHTMLCollection.h"
 #include "nsIDOMHTMLDocument.h"
 #include "nsIDOMHTMLFrameElement.h"
 #include "nsIDOMHTMLHtmlElement.h"
 #include "nsIDOMHTMLIFrameElement.h"
 #include "nsIDOMHTMLInputElement.h"
+#include "nsIDOMHTMLTextAreaElement.h"
 #include "nsIDOMHTMLMapElement.h"
 #include "nsIDOMHTMLOptionElement.h"
 #include "nsIDOMHTMLSelectElement.h"
 #include "nsIDOMKeyEvent.h"
 #include "nsIDOMKeyListener.h"
 #include "nsIDOMNSEvent.h"
 #include "nsIDOMNSHTMLElement.h"
 #include "nsIDOMNSUIEvent.h"
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp
===================================================================
--- mozilla.orig/extensions/spatialnavigation/src/nsSpatialNavigation.cpp
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp
@@ -186,90 +186,83 @@
   
   if (mService->mKeyCodeModifier & 0x00000012)
   {
     if (NS_FAILED(keyEvent->GetAltKey(&isModifier)))
       return NS_ERROR_FAILURE;
     if (!isModifier)
       return NS_OK;  
   }
-  
-  
+
   if (keyCode == mService->mKeyCodeLeft)
   {
-  
-   // ************************************************************************************
-    // NS_FORM_TEXTAREA cases:
-
-    // ************************************************************************************
-    // NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE cases
-
+    //************************************************************************************
+    // NS_FORM_TEXTAREA & (NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE) cases
 
+    PRInt32 selectionStart = 0, textLength = 0;
     if (formControlType == NS_FORM_INPUT_TEXT || 
-        formControlType == NS_FORM_INPUT_PASSWORD)
+        formControlType == NS_FORM_INPUT_PASSWORD ||
+        formControlType == NS_FORM_INPUT_FILE)
     {
-      PRInt32 selectionStart, textLength;
       nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(targetContent);
       if (input) {
         input->GetSelectionStart (&selectionStart);
         input->GetTextLength (&textLength);
-      } else {
-        nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
-        if (textArea) {
-          textArea->GetSelectionStart (&selectionStart);
-          textArea->GetTextLength (&textLength);
-        }
       }
-	  
-      if (textLength != 0 && selectionStart != 0)
-        return NS_OK;
+    } else if (formControlType == NS_FORM_TEXTAREA) {
+
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionStart (&selectionStart);
+        textArea->GetTextLength (&textLength);
+      }
     }
 
+    if (textLength != 0 && selectionStart != 0)
+      return NS_OK;
+
     // We're using this key, no one else should
     aEvent->StopPropagation();
-	aEvent->PreventDefault();
-	
+    aEvent->PreventDefault();
     return Left();
   }
-  
+
   if (keyCode == mService->mKeyCodeRight)
   {
-    // ************************************************************************************
-    // NS_FORM_TEXTAREA cases:
+    //************************************************************************************
+    // NS_FORM_TEXTAREA & (NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE) cases
 
-    // ************************************************************************************
-    // NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE cases
+    PRInt32 selectionEnd = 0, textLength = 0;
 
     if (formControlType == NS_FORM_INPUT_TEXT || 
-        formControlType == NS_FORM_INPUT_PASSWORD)
+        formControlType == NS_FORM_INPUT_PASSWORD ||
+        formControlType == NS_FORM_INPUT_FILE)
     {
-      PRInt32 selectionEnd, textLength;
       nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(targetContent);
       if (input) {
         input->GetSelectionEnd (&selectionEnd);
         input->GetTextLength (&textLength);
-      } else {
-        nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
-        if (textArea) {
-          textArea->GetSelectionEnd (&selectionEnd);
-          textArea->GetTextLength (&textLength);
-        }
       }
-      
-      // going down.
+    } else if (formControlType == NS_FORM_TEXTAREA) {
 
-      if (textLength  != selectionEnd)
-        return NS_OK;
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionEnd (&selectionEnd);
+        textArea->GetTextLength (&textLength);
+      }
     }
-	
+
+    if (textLength  != selectionEnd)
+      return NS_OK;
+
     aEvent->StopPropagation();
-	aEvent->PreventDefault();
+    aEvent->PreventDefault();
     return Right();
   }
-  
+
   if (keyCode == mService->mKeyCodeUp)
   {
 
     // If we are going up or down, in a select, lets not
     // navigate.
     //
     // FIX: What we really want to do is determine if we are
     // at the start or the end fo the form element, and
@@ -279,21 +272,38 @@
     // ************************************************************************************
     // NS_FORM_SELECT cases:
     // * if it is a select form of 'size' attr != than '1' then we do as above.
 
     // * if it is a select form of 'size' attr == than '1', snav can take care of it.
     // if (formControlType == NS_FORM_SELECT)
     //   return NS_OK;
 
+    //************************************************************************************
+    // NS_FORM_TEXTAREA & (NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE) cases
+
+    if (formControlType == NS_FORM_TEXTAREA) {
+
+      PRInt32 selectionStart = 0, textLength = 0;
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionStart (&selectionStart);
+        textArea->GetTextLength (&textLength);
+      }
+
+      if (textLength != 0 && selectionStart != 0)
+        return NS_OK;
+    }
+
+    // We're using this key, no one else should
     aEvent->StopPropagation();
     aEvent->PreventDefault();
     return Up();
   }
-  
+
   if (keyCode == mService->mKeyCodeDown)
   {
     // If we are going up or down, in a select, lets not
     // navigate.
     //
     // FIX: What we really want to do is determine if we are
     // at the start or the end fo the form element, and
     // based on the selected position we decide to nav. or
@@ -302,16 +312,29 @@
     // ************************************************************************************
     // NS_FORM_SELECT cases:
     // * if it is a select form of 'size' attr != than '1' then we do as above.
 
     // * if it is a select form of 'size' attr == than '1', snav can take care of it.
     // if (formControlType == NS_FORM_SELECT)
     //   return NS_OK;
 
+    if (formControlType == NS_FORM_TEXTAREA) {
+
+      PRInt32 selectionEnd = 0, textLength = 0;
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionEnd (&selectionEnd);
+        textArea->GetTextLength (&textLength);
+      }
+
+      if (textLength  != selectionEnd)
+        return NS_OK;
+    }
+
     aEvent->StopPropagation();  // We're using this key, no one else should
     aEvent->PreventDefault();
     return Down();
   }
   
   return NS_OK;
 }
 
@@ -770,21 +793,24 @@
   
   if (element)
   {
     nsCOMPtr<nsIContent> content = do_QueryInterface(element);
     NS_IF_ADDREF(*aContent = content);
     return;
   }
 
+  contentWindow = getContentWindow();
+  DisableJSScope foopy (contentWindow);
+
   //xxxx should/can we prevent it from going into chrome???
   if (direction == eNavLeft || direction == eNavUp)
-    focusController->MoveFocus(PR_FALSE, nsnull);
-  else
     focusController->MoveFocus(PR_TRUE, nsnull);
+  else
+    focusController->MoveFocus(PR_FALSE, nsnull);
   
   // so there is no focused content -- lets make some up, hightlight it and return.  
   focusController->GetFocusedElement(getter_AddRefs(element));
 }
 
 void 
 nsSpatialNavigation::setFocusedContent(nsIContent* c)
 {
@@ -801,18 +827,17 @@
   nsIContent* currentContent = c;
   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(currentContent);
   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(element));
 
   nsCOMPtr<nsIDOMWindow> contentWindow;
   if (mService->mDisableJSWhenFocusing)
     contentWindow = getContentWindow();
 
-  // We do not want to have JS disable at anytime - see bug 51075
-  // DisableJSScope foopy (contentWindow);
+  DisableJSScope foopy (contentWindow);
 
   //#ifdef OLDER_LAYOUT  
   nsPresContext* presContext = getPresContext(c);
   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
   presContext->EventStateManager()->SetContentState(c, NS_EVENT_STATE_FOCUS);
   presShell->ScrollContentIntoView(c, 
                                    NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
                                    NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE);
Index: mozilla/layout/forms/nsListControlFrame.cpp
===================================================================
--- mozilla.orig/layout/forms/nsListControlFrame.cpp
+++ mozilla/layout/forms/nsListControlFrame.cpp
@@ -360,17 +360,21 @@
 
   // set up back stop colors and then ask L&F service for the real colors
   nscolor color;
   presContext->LookAndFeel()->
     GetColor(lastItemIsSelected ?
              nsILookAndFeel::eColor_WidgetSelectForeground :
              nsILookAndFeel::eColor_WidgetSelectBackground, color);
 
+#ifdef MOZ_MICROB
+  nscoord onePixelInTwips = nsPresContext::CSSPixelsToAppUnits(3);
+#else
   nscoord onePixelInTwips = nsPresContext::CSSPixelsToAppUnits(1);
+#endif
 
   nsRect dirty;
   nscolor colors[] = {color, color, color, color};
   PRUint8 borderStyle[] = {NS_STYLE_BORDER_STYLE_DOTTED, NS_STYLE_BORDER_STYLE_DOTTED, NS_STYLE_BORDER_STYLE_DOTTED, NS_STYLE_BORDER_STYLE_DOTTED};
   nsRect innerRect = fRect;
   innerRect.Deflate(nsSize(onePixelInTwips, onePixelInTwips));
   nsCSSRendering::DrawDashedSides(0, aRC, dirty, borderStyle, colors, fRect, innerRect, 0, nsnull);
 }
@@ -963,17 +967,22 @@
   PRBool isShift;
   PRBool isControl;
 #ifdef XP_MACOSX
   mouseEvent->GetMetaKey(&isControl);
 #else
   mouseEvent->GetCtrlKey(&isControl);
 #endif
   mouseEvent->GetShiftKey(&isShift);
+
+#ifdef MOZ_MICROB
+  return PerformSelection(aClickedIndex, isShift, PR_TRUE);
+#else
   return PerformSelection(aClickedIndex, isShift, isControl);
+#endif
 }
 
 //---------------------------------------------------------
 void
 nsListControlFrame::CaptureMouseEvents(PRBool aGrabMouseEvents)
 {
   // Currently cocoa widgets use a native popup widget which tracks clicks synchronously,
   // so we never want to do mouse capturing. Note that we only bail if the list
@@ -1496,24 +1505,33 @@
 PRBool
 nsListControlFrame::SetOptionsSelectedFromFrame(PRInt32 aStartIndex,
                                                 PRInt32 aEndIndex,
                                                 PRBool aValue,
                                                 PRBool aClearAll)
 {
   nsCOMPtr<nsISelectElement> selectElement(do_QueryInterface(mContent));
   PRBool wasChanged = PR_FALSE;
-  nsresult rv = selectElement->SetOptionsSelectedByIndex(aStartIndex,
+
+#ifdef MOZ_MICROB
+  if (!mChangedByKeyPressing) {
+#endif
+    nsresult rv = selectElement->SetOptionsSelectedByIndex(aStartIndex,
                                                          aEndIndex,
                                                          aValue,
                                                          aClearAll,
                                                          PR_FALSE,
                                                          PR_TRUE,
                                                          &wasChanged);
-  NS_ASSERTION(NS_SUCCEEDED(rv), "SetSelected failed");
+    NS_ASSERTION(NS_SUCCEEDED(rv), "SetSelected failed");
+#ifdef MOZ_MICROB
+  }
+  mChangedByKeyPressing = PR_FALSE;
+#endif
+
   return wasChanged;
 }
 
 PRBool
 nsListControlFrame::ToggleOptionSelectedFromFrame(PRInt32 aIndex)
 {
   nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
   NS_ASSERTION(options, "No options");
@@ -2462,33 +2480,55 @@
     mComboboxFrame->ShowDropDown(!mComboboxFrame->IsDroppedDown());
     if (!weakFrame.IsAlive())
       return;
     mComboboxFrame->RedisplaySelectedText();
   }
 }
 
 nsresult
-nsListControlFrame::KeyPress(nsIDOMEvent* aKeyEvent)
+nsListControlFrame::KeyDown(nsIDOMEvent* aKeyEvent)
 {
   NS_ASSERTION(aKeyEvent, "keyEvent is null.");
 
   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled))
     return NS_OK;
 
   // Start by making sure we can query for a key event
   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aKeyEvent);
   NS_ENSURE_TRUE(keyEvent, NS_ERROR_FAILURE);
 
   PRUint32 keycode = 0;
   PRUint32 charcode = 0;
   keyEvent->GetKeyCode(&keycode);
   keyEvent->GetCharCode(&charcode);
 
-  PRBool isAlt = PR_FALSE;
+#ifdef MOZ_MICROB
+
+	PRBool dropDownIsHidden = PR_FALSE;
+
+	// if it is in drop-down mode, it means it has 'size' attr == '1'
+ 	if (IsInDropDownMode()) {
+
+     dropDownIsHidden = !mComboboxFrame->IsDroppedDown();
+		 if (dropDownIsHidden) {
+
+			 if (keycode == nsIDOMKeyEvent::DOM_VK_RETURN) {
+			 	 DropDownToggleKey(aKeyEvent);
+			 }
+			 return NS_OK;
+		 }
+	} else {
+		// TODO: options inside a select form have to get focus on them only
+	 	//       if user press <ENTER> after select form gets focused
+		//       (see nsListControlFrame::SetFocus). We have to find a way to make it work
+ 	}
+#endif
+
+ 	PRBool isAlt = PR_FALSE;
 
   keyEvent->GetAltKey(&isAlt);
   if (isAlt) {
     if (keycode == nsIDOMKeyEvent::DOM_VK_UP || keycode == nsIDOMKeyEvent::DOM_VK_DOWN) {
       DropDownToggleKey(aKeyEvent);
     }
     return NS_OK;
   }
@@ -2504,16 +2544,25 @@
 
   // now make sure there are options or we are wasting our time
   nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
   NS_ENSURE_TRUE(options, NS_ERROR_FAILURE);
 
   PRUint32 numOptions = 0;
   options->GetLength(&numOptions);
 
+#ifdef MOZ_MICROB
+  mChangedByKeyPressing = PR_FALSE;
+
+  // lowest index in the search range
+  PRInt32 bottom      = 0;
+  // highest index in the search range
+  PRInt32 top         = numOptions;
+#endif
+
   // Whether we did an incremental search or another action
   PRBool didIncrementalSearch = PR_FALSE;
   
   // this is the new index to set
   // DOM_VK_RETURN & DOM_VK_ESCAPE will not set this
   PRInt32 newIndex = kNothingSelected;
 
   // set up the old and new selected index and process it
@@ -2530,39 +2579,83 @@
     isControl = mControlSelectMode = GetMultiple();
   } else if (charcode != ' ') {
     mControlSelectMode = PR_FALSE;
   }
   switch (keycode) {
 
     case nsIDOMKeyEvent::DOM_VK_UP:
     case nsIDOMKeyEvent::DOM_VK_LEFT: {
-      AdjustIndexForDisabledOpt(mEndSelectionIndex, newIndex,
+
+#ifdef MOZ_MICROB
+       // if we are in the fisrt option in a selection, and user presses up/left, lets snav take care of it.
+       if (mEndSelectionIndex <= bottom)
+         return NS_OK;
+
+       mChangedByKeyPressing = PR_TRUE;
+
+       if (IsInDropDownMode()) {
+          if (mComboboxFrame->IsDroppedDown()) {
+            mChangedByKeyPressing = PR_FALSE;
+          }
+       }
+#endif
+     AdjustIndexForDisabledOpt(mEndSelectionIndex, newIndex,
                                 (PRInt32)numOptions,
                                 -1, -1);
       } break;
     
     case nsIDOMKeyEvent::DOM_VK_DOWN:
     case nsIDOMKeyEvent::DOM_VK_RIGHT: {
+
+ #ifdef MOZ_MICROB
+       // if we are in the last option in a selection, and user presses down/right,
+       // lets snav take care of it.
+       if (mEndSelectionIndex >= top-1)
+         return NS_OK;
+
+       mChangedByKeyPressing = PR_TRUE;
+
+       // if it is in drop-down mode, it means it has 'size' attr == '1'
+       if (IsInDropDownMode()) {
+          if (mComboboxFrame->IsDroppedDown()) {
+           mChangedByKeyPressing = PR_FALSE;
+          }
+        }
+#endif
       AdjustIndexForDisabledOpt(mEndSelectionIndex, newIndex,
                                 (PRInt32)numOptions,
                                 1, 1);
       } break;
 
     case nsIDOMKeyEvent::DOM_VK_RETURN: {
       if (mComboboxFrame != nsnull) {
         if (mComboboxFrame->IsDroppedDown()) {
           nsWeakFrame weakFrame(this);
           ComboboxFinish(mEndSelectionIndex);
           if (!weakFrame.IsAlive())
             return NS_OK;
         }
         FireOnChange();
         return NS_OK;
       } else {
+#ifdef MOZ_MICROB
+         if (IsContentSelectedByIndex(mEndSelectionIndex)) {
+
+           //SingleSelection (mEndSelectionIndex, PR_TRUE);
+           PerformSelection (mEndSelectionIndex, isShift, PR_TRUE);
+
+           mChangedByKeyPressing = PR_TRUE;
+           AdjustIndexForDisabledOpt(mEndSelectionIndex, mEndSelectionIndex,
+                                 (PRInt32)numOptions,
+                                 0, 0);
+         }
+         // keyboardless devices has no <control>, so we assume it is pressed.
+         isControl = GetMultiple();
+ #endif
         newIndex = mEndSelectionIndex;
       }
       } break;
 
     case nsIDOMKeyEvent::DOM_VK_ESCAPE: {
       nsWeakFrame weakFrame(this);
       AboutToRollup();
       if (!weakFrame.IsAlive()) {
@@ -2705,25 +2798,39 @@
   }
 
   // Actually process the new index and let the selection code
   // do the scrolling for us
   if (newIndex != kNothingSelected) {
     // If you hold control, no key will actually do anything except space.
     PRBool wasChanged = PR_FALSE;
     if (isControl && charcode != ' ') {
+#ifndef MOZ_MICROB
       mStartSelectionIndex = newIndex;
       mEndSelectionIndex = newIndex;
       ScrollToIndex(newIndex);
+#else
+      if (mChangedByKeyPressing) {
+        mStartSelectionIndex = newIndex;
+        mEndSelectionIndex = newIndex;
+        ScrollToIndex(newIndex);
+      } else {
+        wasChanged = PerformSelection(newIndex, isShift, isControl);
+      }
+#endif
     } else if (mControlSelectMode && charcode == ' ') {
       wasChanged = SingleSelection(newIndex, PR_TRUE);
     } else {
       wasChanged = PerformSelection(newIndex, isShift, isControl);
     }
+#ifndef MOZ_MICROB
     if (wasChanged) {
+#else
+    if (wasChanged && mChangedByKeyPressing) {
+#endif
        // dispatch event, update combobox, etc.
       if (!UpdateSelection()) {
         return NS_OK;
       }
     }
 #ifdef ACCESSIBILITY
     if (charcode != ' ') {
       FireMenuItemActiveEvent();
@@ -2775,19 +2882,19 @@
 NS_IMETHODIMP \
 nsListEventListener::_event(nsIDOMEvent* aEvent) \
 { return NS_OK; }
 
 IGNORE_EVENT(HandleEvent)
 
 /*================== nsIDOMKeyListener =========================*/
 
-IGNORE_EVENT(KeyDown)
+FORWARD_EVENT(KeyDown)
 IGNORE_EVENT(KeyUp)
-FORWARD_EVENT(KeyPress)
+IGNORE_EVENT(KeyPress)
 
 /*=============== nsIDOMMouseListener ======================*/
 
 FORWARD_EVENT(MouseDown)
 FORWARD_EVENT(MouseUp)
 IGNORE_EVENT(MouseClick)
 IGNORE_EVENT(MouseDblClick)
 IGNORE_EVENT(MouseOver)
Index: mozilla/layout/forms/nsListControlFrame.h
===================================================================
--- mozilla.orig/layout/forms/nsListControlFrame.h
+++ mozilla/layout/forms/nsListControlFrame.h
@@ -207,17 +207,17 @@
   nsresult MouseDown(nsIDOMEvent* aMouseEvent);
   nsresult MouseUp(nsIDOMEvent* aMouseEvent);
 
   // mouse motion listeners
   nsresult MouseMove(nsIDOMEvent* aMouseEvent);
   nsresult DragMove(nsIDOMEvent* aMouseEvent);
 
   // key listener (might destroy |this|)
-  nsresult KeyPress(nsIDOMEvent* aKeyEvent);
+  nsresult KeyDown(nsIDOMEvent* aKeyEvent);
 
   /**
    * Returns the options collection for aContent, if any.
    */
   static already_AddRefed<nsIDOMHTMLOptionsCollection>
     GetOptions(nsIContent * aContent);
 
   /**
@@ -448,12 +448,15 @@
 
 private:
   NS_IMETHOD_(nsrefcnt) AddRef() { return NS_OK; }
   NS_IMETHOD_(nsrefcnt) Release() { return NS_OK; }
 
   // for incremental typing navigation
   static nsAString& GetIncrementalString ();
   static DOMTimeStamp gLastKeyTime;
+#ifdef MOZ_MICROB
+  PRBool mChangedByKeyPressing;
+#endif
 };
 
 #endif /* nsListControlFrame_h___ */
 
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigationUtils.cpp
===================================================================
--- mozilla.orig/extensions/spatialnavigation/src/nsSpatialNavigationUtils.cpp
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationUtils.cpp
@@ -405,17 +405,22 @@
 
   nsCOMPtr<nsIDOMHTMLOptionElement> optionElement = do_QueryInterface(currentContent);
   if (optionElement && NS_SUCCEEDED(optionElement->GetDisabled(&disabled)))
     return !disabled;
 
   nsAutoString inputType;
   nsCOMPtr<nsIDOMHTMLInputElement> inputElement = do_QueryInterface(currentContent);
   if (inputElement && NS_SUCCEEDED(inputElement->GetDisabled(&disabled)) && NS_SUCCEEDED(inputElement->GetType(inputType)))
-    return !disabled && (! inputType.EqualsIgnoreCase("hidden"));
+    return !disabled && (! inputType.LowerCaseEqualsLiteral("hidden")) && (!inputType.LowerCaseEqualsLiteral("button"));
+
+  nsAutoString textareaType;
+  nsCOMPtr<nsIDOMHTMLTextAreaElement> textareaElement = do_QueryInterface(currentContent);
+  if (textareaElement && NS_SUCCEEDED(textareaElement->GetDisabled(&disabled)) && NS_SUCCEEDED(textareaElement->GetType(textareaType)))
+    return !disabled && (! textareaType.LowerCaseEqualsLiteral("hidden"));
 
   return PR_FALSE;
 }
 
 nsRect makeRectRelativeToGlobalView(nsIFrame *aFrame)
 {
   nsRect result;
   result.SetRect(0,0,0,0);
