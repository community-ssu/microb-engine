# Maemo Bugzilla Bug 1791 link navigation should be triggered by key-up not key-down and only if scrolling isn't triggered
# bug 50934 [SNAV] Incorrect focus behaviour when scrolling page with HW keys

diff -ruN -p -u10 mozilla/extensions/spatialnavigation/src.orig/nsSpatialNavigation.cpp mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp
--- mozilla/extensions/spatialnavigation/src.orig/nsSpatialNavigation.cpp	2007-09-16 08:23:51.000000000 +0300
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp	2007-09-16 16:53:50.000000000 +0300
@@ -52,54 +52,132 @@ NS_IMPL_ADDREF(nsSpatialNavigation)
 NS_IMPL_RELEASE(nsSpatialNavigation)
 
 
 nsSpatialNavigation::nsSpatialNavigation(nsSpatialNavigationService* aService)
 {
   NS_ASSERTION(aService, "Should not create this object without a valid service");
 
   mService = aService; // back pointer -- no reference
 
   mNavigationFramesState = PR_FALSE;
+  mKeyPressedState = 0;
 }
 
+#ifdef DEBUG_romaxa
+nsresult debug_content(nsISupports *content)
+{
+  nsresult rv;
+  nsCOMPtr<nsIDOMNode> node;
+  node = do_QueryInterface(content, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsRect rect = makeRectRelativeToGlobalView(node);
+  nsString str;
+  node->GetNodeName(str);
+  printf("DBG:N:'%s', rect[%i,%i,%i,%i]",
+          NS_ConvertUTF16toUTF8(str).get(),
+          rect.x,rect.y,rect.width,rect.height);
+/*
+  nsCOMPtr<nsIDOMNSHTMLElement> nselem;
+  nselem = do_QueryInterface(content, &rv);
+  if (nselem) {
+    PRInt32 st,sl,ct,cl,ot,ol;
+    nselem->GetScrollTop(&st);
+    nselem->GetScrollLeft(&sl);
+    nselem->GetClientTop(&ct);
+    nselem->GetClientLeft(&cl);
+    nselem->GetOffsetTop(&ot);
+    nselem->GetOffsetLeft(&ol);
+    printf(" st:%i,sl:%i,ct:%i,cl:%i,ot:%i,ol%i ", st,sl,ct,cl,ot,ol);
+  }
+*/
+  printf("\n");
+}
+#endif
+
 nsSpatialNavigation::~nsSpatialNavigation()
 {
 }
 
-NS_IMETHODIMP
-nsSpatialNavigation::HandleEvent(nsIDOMEvent* aEvent)
+NS_IMETHODIMP 
+nsSpatialNavigation::Up()
 {
-  return NS_OK;
+  return handleMove(eNavUp);
+}
+
+NS_IMETHODIMP 
+nsSpatialNavigation::Down()
+{
+  return handleMove(eNavDown);
+}
+
+NS_IMETHODIMP 
+nsSpatialNavigation::Left()
+{
+  return handleMove(eNavLeft);
+}
+
+NS_IMETHODIMP 
+nsSpatialNavigation::Right()
+{
+  return handleMove(eNavRight);
 }
 
 NS_IMETHODIMP
-nsSpatialNavigation::KeyUp(nsIDOMEvent* aEvent)
+nsSpatialNavigation::KeyDown(nsIDOMEvent* aEvent)
 {
-  return NS_OK;
+  mKeyPressedCount = 0;
+  if (!mService->mEnabled)
+    return NS_OK;
+
+/*if (!mKeyPressedState) {
+    aEvent->StopPropagation();
+    aEvent->PreventDefault();
+  }*/
+  return HandleKey(aEvent, PR_FALSE);
 }
 
 NS_IMETHODIMP
 nsSpatialNavigation::KeyPress(nsIDOMEvent* aEvent)
 {
+  if (!mService->mEnabled)
+    return NS_OK;
+  mKeyPressedCount++;
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsSpatialNavigation::KeyDown(nsIDOMEvent* aEvent)
+nsSpatialNavigation::KeyUp(nsIDOMEvent* aEvent)
 {
-  nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
-  PRBool enabled;
-  prefBranch->GetBoolPref("snav.enabled", &enabled);
-  if (!enabled) //  this doesn't work.  wtf? if (!mService->mEnabled)
+  if (!mService->mEnabled)
     return NS_OK;
- 
 
+  if (mKeyPressedCount > 1) {
+    if (mKeyPressedState == 0) {
+      mKeyPressedState = 1;
+    }
+    
+    mKeyPressedCount = 0;
+    return NS_OK;
+  }
+  mKeyPressedCount = 0;
+  return HandleKey(aEvent, PR_TRUE);
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::HandleEvent(nsIDOMEvent* aEvent)
+{
+  return NS_OK;
+}
+
+nsresult 
+nsSpatialNavigation::HandleKey(nsIDOMEvent* aEvent, PRBool aReal)
+{
   nsCOMPtr<nsIDOMNSUIEvent> uiEvent(do_QueryInterface(aEvent));
   if (uiEvent)
   {
     // If a web page wants to use the keys mapped to our
     // move, they have to use evt.preventDefault() after
     // they get the key
 
     PRBool preventDefault;
     uiEvent->GetPreventDefault(&preventDefault);
     if (preventDefault)
@@ -231,21 +309,21 @@ nsSpatialNavigation::KeyDown(nsIDOMEvent
         textArea->GetTextLength (&textLength);
       }
     }
 
     if (textLength != 0 && selectionStart != 0)
       return NS_OK;
 
     // We're using this key, no one else should
     aEvent->StopPropagation();
     aEvent->PreventDefault();
-    return Left();
+    return aReal?Left():NS_OK;
   }
 
   if (keyCode == mService->mKeyCodeRight)
   {
     //************************************************************************************
     // NS_FORM_TEXTAREA & (NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE) cases
 
     PRInt32 selectionEnd = 0, textLength = 0;
 
     if (formControlType == NS_FORM_INPUT_TEXT || 
@@ -264,21 +342,21 @@ nsSpatialNavigation::KeyDown(nsIDOMEvent
         textArea->GetSelectionEnd (&selectionEnd);
         textArea->GetTextLength (&textLength);
       }
     }
 
     if (textLength  != selectionEnd)
       return NS_OK;
 
     aEvent->StopPropagation();
     aEvent->PreventDefault();
-    return Right();
+    return aReal?Right():NS_OK;
   }
 
   if (keyCode == mService->mKeyCodeUp)
   {
 
     // If we are going up or down, in a select, lets not
     // navigate.
     //
     // FIX: What we really want to do is determine if we are
     // at the start or the end fo the form element, and
@@ -305,21 +383,21 @@ nsSpatialNavigation::KeyDown(nsIDOMEvent
         textArea->GetTextLength (&textLength);
       }
 
       if (textLength != 0 && selectionStart != 0)
         return NS_OK;
     }
 
     // We're using this key, no one else should
     aEvent->StopPropagation();
     aEvent->PreventDefault();
-    return Up();
+    return aReal?Up():NS_OK;
   }
 
   if (keyCode == mService->mKeyCodeDown)
   {
     // If we are going up or down, in a select, lets not
     // navigate.
     //
     // FIX: What we really want to do is determine if we are
     // at the start or the end fo the form element, and
     // based on the selected position we decide to nav. or
@@ -341,23 +419,22 @@ nsSpatialNavigation::KeyDown(nsIDOMEvent
         textArea->GetSelectionEnd (&selectionEnd);
         textArea->GetTextLength (&textLength);
       }
 
       if (textLength  != selectionEnd)
         return NS_OK;
     }
 
     aEvent->StopPropagation();  // We're using this key, no one else should
     aEvent->PreventDefault();
-    return Down();
+    return aReal?Down():NS_OK;
   }
-  
   return NS_OK;
 }
 
 NS_IMETHODIMP 
 nsSpatialNavigation::Init(nsIDOMWindow *aWindow)
 {
   mTopWindow = aWindow;
 
   nsCOMPtr<nsIDOM3EventTarget> target;
   nsCOMPtr<nsIDOMEventGroup> systemGroup;
@@ -385,44 +462,20 @@ nsSpatialNavigation::Shutdown()
   target->RemoveGroupedEventListener(NS_LITERAL_STRING("keypress"),
                                      NS_STATIC_CAST(nsIDOMKeyListener*, this),
                                      PR_FALSE, 
                                      systemGroup);
   mTopWindow = nsnull;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP 
-nsSpatialNavigation::Up()
-{
-  return handleMove(eNavUp);
-}
-
-NS_IMETHODIMP 
-nsSpatialNavigation::Down()
-{
-  return handleMove(eNavDown);
-}
-
-NS_IMETHODIMP 
-nsSpatialNavigation::Left()
-{
-  return handleMove(eNavLeft);
-}
-
-NS_IMETHODIMP 
-nsSpatialNavigation::Right()
-{
-  return handleMove(eNavRight);
-}
-
-NS_IMETHODIMP 
 nsSpatialNavigation::GetAttachedWindow(nsIDOMWindow * *aAttachedWindow)
 {
   NS_IF_ADDREF(*aAttachedWindow = mTopWindow);
   return NS_OK;
 }
 
 void DoTraversal(int aDirection,
                  nsIBidirectionalEnumerator* aFrameTraversal, 
                  nsIFrame* aFocusedFrame,
                  nsRect& aFocusedRect,
@@ -652,43 +705,150 @@ nsSpatialNavigation::getContentInDirecti
 
 
   if ( (hhElement || iFrameElement) && mNavigationFramesState)
   {
     mNavigationFramesState = PR_FALSE;
   }
 
   return NS_OK;
 }
 
+static nsresult
+PutFakeSelectionTo(nsPresContext* aPresContext, PRInt32 aY = 0, PRBool aForward = PR_TRUE, PRInt32 aX = 0)
+{
+  NS_ENSURE_ARG_POINTER(aPresContext);
+  nsCOMPtr<nsIPresShell> presShell = aPresContext->PresShell();
+  NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
+  nsIViewManager* viewManager = presShell->GetViewManager();
+  NS_ENSURE_TRUE(viewManager, NS_ERROR_FAILURE);
+  nsIView* rootView = nsnull;
+  viewManager->GetRootView(rootView);
+  NS_ENSURE_TRUE(rootView, NS_ERROR_FAILURE);
+  nsEventStatus status;
+  nsMouseEvent event(PR_FALSE, NS_MOUSE_BUTTON_DOWN, rootView->GetWidget(), nsMouseEvent::eReal);
+  event.refPoint.x = aX;
+  event.refPoint.y = aY;
+  event.isAlt = PR_TRUE;
+  event.time = PR_IntervalNow();
+  viewManager->DispatchEvent(&event, &status);
+  event.message = NS_MOUSE_BUTTON_UP;
+  event.time = PR_IntervalNow();
+  viewManager->DispatchEvent(&event, &status);
+  return aPresContext->EventStateManager()->ShiftFocus(aForward, nsnull);
+}
+
+static nsPoint
+getPointByDirection(nsIDOMWindow *aWin, PRInt32 aDirection, PRBool *aDoForward = nsnull)
+{
+  nsPoint pt(0,0);
+  NS_ENSURE_TRUE(aWin, pt);
+  nsCOMPtr<nsIDOMWindowInternal> dwinint = do_QueryInterface(aWin);
+  PRInt32 oh,sy,yo,smy;
+  if (aDirection == eNavDown) {
+//    dwinint->GetPageYOffset(&yo);
+    pt.y = 0;
+//    if (aDoForward)
+//      *aDoForward = yo?PR_TRUE:PR_FALSE;
+  }
+  else if (aDirection == eNavUp) {
+    dwinint->GetOuterHeight(&oh);
+    dwinint->GetScreenY(&sy);
+//    dwinint->GetScrollMaxY(&smy);
+    pt.y = oh - sy;
+//    if (aDoForward)
+//      *aDoForward = yo==smy?PR_FALSE:PR_TRUE;
+  }
+  else {
+    dwinint->GetOuterHeight(&oh);
+    dwinint->GetScreenY(&sy);
+    pt.y = (oh - sy) / 2;
+    if (aDoForward)
+      *aDoForward = eNavLeft?PR_TRUE:PR_FALSE;
+  }
+  return pt;
+}
+
+PRBool
+nsSpatialNavigation::isContentInsideWindow(nsIContent* aContent, nsIDOMWindow* aWin, PRInt32 *xpos, PRInt32 *ypos)
+{
+  PRBool inside = PR_TRUE;
+  NS_ENSURE_TRUE(aWin, PR_FALSE);
+  NS_ENSURE_TRUE(aContent, PR_FALSE);
+  nsCOMPtr<nsIDOMWindowInternal> dwinint = do_QueryInterface(aWin);
+  NS_ENSURE_TRUE(dwinint, PR_FALSE);
+  nsCOMPtr<nsIDOMNode> node;
+  node = do_QueryInterface(aContent);
+  nsRect rect = makeRectRelativeToGlobalView(node);
+  PRInt32 xo,yo,ow,oh;
+  dwinint->GetOuterHeight(&oh);
+  dwinint->GetOuterWidth(&ow);
+  dwinint->GetPageYOffset(&yo);
+  dwinint->GetPageXOffset(&xo);
+  if (rect.y + rect.height < yo) {
+    inside = PR_FALSE;
+    if (ypos)
+      *ypos = -1;
+  }
+  if (yo + oh < rect.y) {
+    inside = PR_FALSE;
+    if (ypos)
+      *ypos = 1;
+  }
+  if (rect.x + rect.width < xo) {
+    inside = PR_FALSE;
+    if (xpos)
+      *xpos = -1;
+  }
+  if (xo + ow < rect.x) {
+    inside = PR_FALSE;
+    if (xpos)
+      *xpos = 1;
+  }
+  return inside;
+}
 
 nsresult
 nsSpatialNavigation::handleMove(int direction)
 {
   nsCOMPtr<nsIContent> focusedContent;
-  PRBool doScroll = getFocusedContent(direction, getter_AddRefs(focusedContent));
+  getFocusedContent(direction, getter_AddRefs(focusedContent));
 
   // there are some websites which have no focusable elements,
   // only text, for example. In these cases, scrolling have to be
   // performed by snav.
   if (!focusedContent) {
-     if (doScroll)
-       ScrollWindow(direction, getContentWindow());
-     return NS_OK;
+    PRBool forward = PR_TRUE;
+    nsPoint pt = getPointByDirection(getContentWindow(), direction, &forward);
+    if (NS_SUCCEEDED(PutFakeSelectionTo(getPresContext(nsnull), pt.y, forward)))
+      return NS_OK;
+    ScrollWindow(direction, getContentWindow());
+    return NS_OK;
   }
   
   nsPresContext* presContext = getPresContext(focusedContent);
   if(!presContext)
     return NS_ERROR_NULL_POINTER;
 
   nsIFrame* focusedFrame;
   getFrameForContent(focusedContent, &focusedFrame);
 
+  if (mKeyPressedState) {
+    if (!isContentInsideWindow(focusedContent, mTopWindow)) {
+      mKeyPressedState = 0;
+      PRBool forward = PR_TRUE;
+      nsPoint pt = getPointByDirection(getContentWindow(), direction, &forward);
+      PutFakeSelectionTo(getPresContext(nsnull), pt.y, forward);
+      return NS_OK;
+    }
+  }
+  mKeyPressedState = 0;
+
   nsRect focusedRect;
   PRBool isAREA = isArea(focusedContent);
   if (!isAREA) 
   {
     // RECT !!
 		if (focusedFrame)
 	 		focusedRect = makeRectRelativeToGlobalView(focusedFrame);
 
     // deflate the rect to avoid overlapping with other
     // rects.
@@ -781,85 +941,63 @@ nsSpatialNavigation::handleMove(int dire
 
     getContentInDirection(direction, presContext, subdocRect, subdocFrame, PR_TRUE, PR_FALSE, getter_AddRefs(c));
   }
 
   if (c) {
     nsCOMPtr<nsIContent> subdocContent;
     getContentFromFrame(c, getter_AddRefs(subdocContent));
 
     if (subdocContent) {
       mNavigationFramesState = PR_TRUE;
-      setFocusedContent(c);
-      return NS_OK;
     }
 
     setFocusedContent(c);
     return NS_OK;
   }
   
   // if everything fails, default is to move the focus just as if the user hit tab.
   //  presContext->EventStateManager()->ShiftFocus(PR_TRUE, focusedContent);
 
   // how about this, if we find anything, we just scroll the
   // page in the direction of the navigation??
   ScrollWindow(direction, getContentWindow());
 
   ///////////////////////////////////////////////////////////////////////////////////////////////////
 
   return NS_OK;
 
 }
 
-PRBool
+void
 nsSpatialNavigation::getFocusedContent(int direction, nsIContent** aContent)
 {
   *aContent = nsnull;
   
   nsCOMPtr<nsIDOMWindow> contentWindow = getContentWindow();
   if (!contentWindow)
-    return PR_TRUE;
+    return;
   
   nsCOMPtr<nsPIDOMWindow> privateWindow = do_QueryInterface(contentWindow);
   nsIFocusController *focusController = privateWindow->GetRootFocusController();
   
   if (!focusController)
-    return PR_TRUE;
+    return;
   
   nsCOMPtr<nsIDOMElement> element;
   focusController->GetFocusedElement(getter_AddRefs(element));
   
   if (element)
   {
     nsCOMPtr<nsIContent> content = do_QueryInterface(element);
     NS_IF_ADDREF(*aContent = content);
-    return PR_TRUE;
+    return;
   }
-
-  contentWindow = getContentWindow();
-  DisableJSScope foopy (contentWindow);
-
-  //xxxx should/can we prevent it from going into chrome???
-//  if (direction == eNavLeft || direction == eNavUp)
-   focusController->MoveFocus(PR_TRUE, nsnull);
-   nsresult rv = focusController->GetFocusedElement(getter_AddRefs(element));
-   if (element) {
-     nsCOMPtr<nsIContent> c = do_QueryInterface(element);
-     foopy.~DisableJSScope();
-     setFocusedContent(c);
-     return PR_FALSE;
-   }
-//  else
-//    focusController->MoveFocus(PR_FALSE, nsnull);
-  
-  // so there is no focused content -- lets make some up, hightlight it and return.  
-//  focusController->GetFocusedElement(getter_AddRefs(element));
-  return PR_TRUE;
 }
 
 void 
 nsSpatialNavigation::setFocusedContent(nsIContent* c)
 {
   if (!c)
     return;
 
   nsCOMPtr<nsIContent> subdocContent;
   getContentFromFrame(c, getter_AddRefs(subdocContent));
@@ -871,29 +1009,31 @@ nsSpatialNavigation::setFocusedContent(n
   nsIContent* currentContent = c;
   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(currentContent);
   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(element));
 
   nsCOMPtr<nsIDOMWindow> contentWindow;
   if (mService->mDisableJSWhenFocusing)
     contentWindow = getContentWindow();
 
   DisableJSScope foopy (contentWindow);
 
-  //#ifdef OLDER_LAYOUT  
   nsPresContext* presContext = getPresContext(c);
   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
-  presContext->EventStateManager()->SetContentState(c, NS_EVENT_STATE_FOCUS);
-  presShell->ScrollContentIntoView(c, 
-                                   NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
-                                   NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE);
-  presContext->EventStateManager()->MoveCaretToFocus();
-
+  //#ifdef OLDER_LAYOUT  
+  if (mService->mOrderLayout) {
+    // Google Spreadsheets works ugly with this call
+    presContext->EventStateManager()->SetContentState(c, NS_EVENT_STATE_FOCUS);  
+    presShell->ScrollContentIntoView(c, 
+                                     NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
+                                     NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE);
+    presContext->EventStateManager()->MoveCaretToFocus();
+  }
   //#else
   nsCOMPtr<nsIDOMNSHTMLElement> nsElement = do_QueryInterface(element);
   if (nsElement) 
     nsElement->Focus();
   //#endif
 
   nsIFrame* focusedFrame;
   getFrameForContent(c, &focusedFrame);
   nsRect rect = makeRectRelativeToGlobalView(focusedFrame);
   nsIViewManager* viewManager = presShell->GetViewManager();
@@ -929,24 +1069,29 @@ nsSpatialNavigation::getContentWindow()
 	return nsnull;
 
   NS_ADDREF(resultWindow = windowContent);
   return resultWindow;
 }
 
 
 nsPresContext* 
 nsSpatialNavigation::getPresContext(nsIContent* content)
 {
-  if (!content) return nsnull;
-  
-  nsCOMPtr<nsIDocument> doc = content->GetDocument();
-  if (!doc) return nsnull;
-  
+  nsCOMPtr<nsIDocument> doc;
+  if (!content) {
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    if (mTopWindow)
+      mTopWindow->GetDocument(getter_AddRefs(domDoc));
+    doc = do_QueryInterface(domDoc);
+  } else
+    doc = content->GetDocument();
+
+  if (!doc) return nsnull;  
   // the only case where there could be more shells in printpreview
   nsIPresShell *shell = doc->GetPrimaryShell();
   if (!shell) return nsnull;
   
   nsPresContext *presContext = shell->GetPresContext();
   return presContext;
 }
 
 
diff -ruN -p -u10 mozilla/extensions/spatialnavigation/src.orig/nsSpatialNavigationPrivate.h mozilla/extensions/spatialnavigation/src/nsSpatialNavigationPrivate.h
--- mozilla/extensions/spatialnavigation/src.orig/nsSpatialNavigationPrivate.h	2007-09-16 08:23:55.000000000 +0300
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationPrivate.h	2007-09-16 13:13:56.000000000 +0300
@@ -144,54 +144,59 @@ public:
   // ----- nsIDOMKeyListener ----------------------------
   NS_IMETHOD KeyDown(nsIDOMEvent* aKeyEvent);
   NS_IMETHOD KeyUp(nsIDOMEvent* aKeyEvent);
   NS_IMETHOD KeyPress(nsIDOMEvent* aKeyEvent);
   
   nsSpatialNavigation(nsSpatialNavigationService* aService);
   
 private:
   ~nsSpatialNavigation();
   
+  nsresult HandleKey(nsIDOMEvent* aKeyEvent, PRBool aReal);
   nsPresContext* getPresContext(nsIContent* aContent);
   
   PRInt64 spatialDistance(int direction, nsRect& a, nsRect& b);
   
   nsIDOMWindow* getContentWindow();
   
   void setFocusedContent(nsIContent* aContent);
-  PRBool getFocusedContent(int direction, nsIContent** aContent);
+  void getFocusedContent(int direction, nsIContent** aContent);
+  PRBool isContentInsideWindow(nsIContent* aContent, nsIDOMWindow* aWin, PRInt32 *xpos = nsnull, PRInt32 *ypos = nsnull);
   
   nsresult handleMove(int direction);
   nsresult getContentInDirection(int direction, nsPresContext* presContext, nsRect& focusedRect, nsIFrame* focusedFrame, PRBool aFocusDocuments, PRBool isAREA, nsIContent** aContent);
 
   nsCOMPtr<nsIDOMWindow> mTopWindow;
 
   nsSpatialNavigationService* mService;
 
   PRBool mNavigationFramesState;
+  PRUint32 mKeyPressedCount;
+  PRUint16 mKeyPressedState;
 };
 
 
 
 class nsSpatialNavigationService: public nsIObserver 
 {
 public:  
   nsSpatialNavigationService();  
   virtual ~nsSpatialNavigationService();  
   
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
 
   nsCOMArray<nsISpatialNavigation> mObjects;
 
   PRBool  mEnabled;
   PRBool  mIgnoreTextFields;
+  PRBool  mOrderLayout;
   PRBool  mDisableJSWhenFocusing;
 
   PRInt32 mKeyCodeLeft;
   PRInt32 mKeyCodeRight;
   PRInt32 mKeyCodeUp;
   PRInt32 mKeyCodeDown;
   PRInt32 mKeyCodeModifier;
 
 };
 
diff -ruN -p -u10 mozilla/extensions/spatialnavigation/src.orig/nsSpatialNavigationService.cpp mozilla/extensions/spatialnavigation/src/nsSpatialNavigationService.cpp
--- mozilla/extensions/spatialnavigation/src.orig/nsSpatialNavigationService.cpp	2007-09-16 08:23:51.000000000 +0300
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationService.cpp	2007-09-16 12:20:46.000000000 +0300
@@ -34,20 +34,21 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsSpatialNavigationPrivate.h"
 #include "nsIObserverService.h"
 
 nsSpatialNavigationService::nsSpatialNavigationService()  
 {
   mEnabled             = PR_TRUE;
   mIgnoreTextFields    = PR_FALSE;
+  mOrderLayout         = PR_TRUE;
   mDisableJSWhenFocusing = PR_TRUE;
 
   mKeyCodeLeft         = nsIDOMKeyEvent::DOM_VK_LEFT;
   mKeyCodeRight        = nsIDOMKeyEvent::DOM_VK_RIGHT;
   mKeyCodeUp           = nsIDOMKeyEvent::DOM_VK_UP;
   mKeyCodeDown         = nsIDOMKeyEvent::DOM_VK_DOWN;
 
   mKeyCodeModifier     = 0x00000012 | 0x00100000; // By default ALT and SHIFT
 }  
 
@@ -132,20 +133,23 @@ nsSpatialNavigationService::Observe(nsIS
     
     // note that if Get*Pref fails, the pref may not exist, so we fallback to
     // the defaults as defined in the constructor
     
     rv = prefBranch->GetBoolPref("snav.enabled", &tempBool);
     if (NS_SUCCEEDED(rv))
       mEnabled = tempBool;
     rv = prefBranch->GetBoolPref("snav.ignoreTextFields", &tempBool);
     if (NS_SUCCEEDED(rv))
       mIgnoreTextFields = tempBool;
+    rv = prefBranch->GetBoolPref("snav.orderLayout", &tempBool);
+    if (NS_SUCCEEDED(rv))
+      mOrderLayout = tempBool;
     rv = prefBranch->GetIntPref("snav.directionalBias", &tempInt32);
     if (NS_SUCCEEDED(rv))
     {
       gDirectionalBias = tempInt32;
       if (gDirectionalBias == 0)
         gDirectionalBias = 1;
     }
     rv = prefBranch->GetBoolPref("snav.disableJS", &tempBool);
     if (NS_SUCCEEDED(rv))
       mDisableJSWhenFocusing = tempBool;
@@ -179,20 +183,24 @@ nsSpatialNavigationService::Observe(nsIS
     nsString prefs(aData);
 
     if (prefs.EqualsLiteral("snav.enabled"))
     {
       prefBranch->GetBoolPref(prefc.get(), &mEnabled);
     }
     else if (prefs.EqualsLiteral("snav.ignoreTextFields"))
     {
       prefBranch->GetBoolPref(prefc.get(), &mIgnoreTextFields);
     }
+    else if (prefs.EqualsLiteral("snav.orderLayout"))
+    {
+      prefBranch->GetBoolPref(prefc.get(), &mOrderLayout);
+    }
     else if (prefs.EqualsLiteral("snav.directionalBias"))
     {
       prefBranch->GetIntPref(prefc.get(), &gDirectionalBias);
       if (gDirectionalBias == 0)
         gDirectionalBias = 1;
     }
     else if (prefs.EqualsLiteral("snav.disableJS"))
     {
       prefBranch->GetBoolPref(prefc.get(), &mDisableJSWhenFocusing);
     }
