--- mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp.orig	2007-07-13 15:35:23.000000000 +0300
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp	2007-07-13 16:20:45.000000000 +0300
@@ -627,27 +627,28 @@ nsSpatialNavigation::getContentInDirecti
   }
 
   return NS_OK;
 }
 
 
 nsresult
 nsSpatialNavigation::handleMove(int direction)
 {
   nsCOMPtr<nsIContent> focusedContent;
-  getFocusedContent(direction, getter_AddRefs(focusedContent));
+  PRBool doScroll = getFocusedContent(direction, getter_AddRefs(focusedContent));
 
   // there are some websites which have no focusable elements,
   // only text, for example. In these cases, scrolling have to be
   // performed by snav.
   if (!focusedContent) {
-     ScrollWindow(direction, getContentWindow());
+     if (doScroll)
+       ScrollWindow(direction, getContentWindow());
      return NS_OK;
   }
   nsPresContext* presContext = getPresContext(focusedContent);
   if(!presContext)
     return NS_ERROR_NULL_POINTER;
 
   nsIFrame* focusedFrame;
   getFrameForContent(focusedContent, &focusedFrame);
 
   nsRect focusedRect;
@@ -770,56 +771,60 @@ nsSpatialNavigation::handleMove(int dire
   // how about this, if we find anything, we just scroll the
   // page in the direction of the navigation??
   ScrollWindow(direction, getContentWindow());
 
   ///////////////////////////////////////////////////////////////////////////////////////////////////
 
   return NS_OK;
 
 }
 
-void
+PRBool
 nsSpatialNavigation::getFocusedContent(int direction, nsIContent** aContent)
 {
   *aContent = nsnull;
   
   nsCOMPtr<nsIDOMWindow> contentWindow = getContentWindow();
   if (!contentWindow)
-    return;
+    return PR_TRUE;
   
   nsCOMPtr<nsPIDOMWindow> privateWindow = do_QueryInterface(contentWindow);
   nsIFocusController *focusController = privateWindow->GetRootFocusController();
   
   if (!focusController)
-    return;
+    return PR_TRUE;
   
   nsCOMPtr<nsIDOMElement> element;
   focusController->GetFocusedElement(getter_AddRefs(element));
   
   if (element)
   {
     nsCOMPtr<nsIContent> content = do_QueryInterface(element);
     NS_IF_ADDREF(*aContent = content);
-    return;
+    return PR_TRUE;
   }
 
   contentWindow = getContentWindow();
   DisableJSScope foopy (contentWindow);
 
   //xxxx should/can we prevent it from going into chrome???
 //  if (direction == eNavLeft || direction == eNavUp)
-    focusController->MoveFocus(PR_TRUE, nsnull);
+   focusController->MoveFocus(PR_TRUE, nsnull);
+   nsresult rv = focusController->GetFocusedElement(getter_AddRefs(element));
+   if (element)
+     return PR_FALSE;
 //  else
 //    focusController->MoveFocus(PR_FALSE, nsnull);
   
   // so there is no focused content -- lets make some up, hightlight it and return.  
 //  focusController->GetFocusedElement(getter_AddRefs(element));
+  return PR_TRUE;
 }
 
 void 
 nsSpatialNavigation::setFocusedContent(nsIContent* c)
 {
   if (!c)
     return;
 
   nsCOMPtr<nsIContent> subdocContent;
   getContentFromFrame(c, getter_AddRefs(subdocContent));
--- nsSpatialNavigationPrivate.h.orig	2007-07-13 15:35:24.000000000 +0300
+++ nsSpatialNavigationPrivate.h	2007-07-13 16:13:50.000000000 +0300
@@ -150,21 +150,21 @@ public:
 private:
   ~nsSpatialNavigation();
   
   nsPresContext* getPresContext(nsIContent* aContent);
   
   PRInt64 spatialDistance(int direction, nsRect& a, nsRect& b);
   
   nsIDOMWindow* getContentWindow();
   
   void setFocusedContent(nsIContent* aContent);
-  void getFocusedContent(int direction, nsIContent** aContent);
+  PRBool getFocusedContent(int direction, nsIContent** aContent);
   
   nsresult handleMove(int direction);
   nsresult getContentInDirection(int direction, nsPresContext* presContext, nsRect& focusedRect, nsIFrame* focusedFrame, PRBool aFocusDocuments, PRBool isAREA, nsIContent** aContent);
 
   nsCOMPtr<nsIDOMWindow> mTopWindow;
 
   nsSpatialNavigationService* mService;
 
   PRBool mNavigationFramesState;
 };
