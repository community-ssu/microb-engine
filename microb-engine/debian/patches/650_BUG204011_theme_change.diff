--- mozilla/widget/src/gtk2/nsWindow.h.orig	2007-08-27 19:52:12.000000000 +0300
+++ mozilla/widget/src/gtk2/nsWindow.h	2007-08-28 11:33:07.000000000 +0300
@@ -351,20 +351,21 @@ public:
    NS_IMETHOD          UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas);
 #endif
 
 #ifdef MOZ_CAIRO_GFX
     gfxASurface       *GetThebesSurface();
 #endif
 
 #ifdef ACCESSIBILITY
     static PRBool      sAccessibilityEnabled;
 #endif
+    guint              mThemeTimeoutSource;
 
 private:
     void               GetToplevelWidget(GtkWidget **aWidget);
     void               GetContainerWindow(nsWindow  **aWindow);
     void               SetUrgencyHint(GtkWidget *top_window, PRBool state);
     void              *SetupPluginPort(void);
     nsresult           SetWindowIconList(const nsCStringArray &aIconList);
     void               SetDefaultIcon(void);
 
     GtkWidget          *mShell;
@@ -466,21 +467,20 @@ private:
         PRUint32 mask;
         PRUint32* flag = GetFlagWord32(aKeyCode, &mask);
         *flag |= mask;
     }
 
     void ClearKeyDownFlag(PRUint32 aKeyCode) {
         PRUint32 mask;
         PRUint32* flag = GetFlagWord32(aKeyCode, &mask);
         *flag &= ~mask;
     }
-
 };
 
 class nsChildWindow : public nsWindow {
 public:
     nsChildWindow();
     ~nsChildWindow();
 };
 
 #endif /* __nsWindow_h__ */
 
--- mozilla/widget/src/gtk2/nsWindow.cpp.orig	2007-08-27 19:52:16.000000000 +0300
+++ mozilla/widget/src/gtk2/nsWindow.cpp	2007-08-28 11:44:23.000000000 +0300
@@ -245,20 +245,21 @@ static PRBool            gRaiseWindows  
 static nsWindow         *gPluginFocusWindow    = NULL;
 
 // to handle event order
 static PRBool            gWaitingForButtonUp   = PR_FALSE;
 static GSList           *gEventList            = NULL;
 
 nsCOMPtr  <nsIRollupListener> gRollupListener;
 nsWeakPtr                     gRollupWindow;
 
 #define NS_WINDOW_TITLE_MAX_LENGTH 4095
+#define GTK_THEME_CHANGE_TIMEOUT 1500
 
 #ifdef USE_XIM
 
 static nsWindow    *gIMEFocusWindow = NULL;
 static GdkEventKey *gKeyEvent = NULL;
 static PRBool       gKeyEventCommitted = PR_FALSE;
 static PRBool       gKeyEventChanged = PR_FALSE;
 static PRBool       gIMESuppressCommit = PR_FALSE;
 
 static void IM_commit_cb              (GtkIMContext *aContext,
@@ -317,20 +318,21 @@ nsWindow::nsWindow()
     mContainerBlockFocus = PR_FALSE;
     mIsVisible           = PR_FALSE;
     mRetryPointerGrab    = PR_FALSE;
     mRetryKeyboardGrab   = PR_FALSE;
     mActivatePending     = PR_FALSE;
     mTransientParent     = nsnull;
     mWindowType          = eWindowType_child;
     mSizeState           = nsSizeMode_Normal;
     mOldFocusWindow      = 0;
     mPluginType          = PluginType_NONE;
+    mThemeTimeoutSource  = 0;
 
     if (!gGlobalsInitialized) {
         gGlobalsInitialized = PR_TRUE;
 
         // It's OK if either of these fail, but it may not be one day.
         initialize_prefs();
     }
 
     memset(mKeyDownFlags, 0, sizeof(mKeyDownFlags));
 
@@ -425,20 +427,29 @@ nsWindow::Destroy(void)
     if (mIsDestroyed || !mCreated)
         return NS_OK;
 
     LOG(("nsWindow::Destroy [%p]\n", (void *)this));
     mIsDestroyed = PR_TRUE;
     mCreated = PR_FALSE;
     
     g_signal_handlers_disconnect_by_func(gtk_settings_get_default(),
                                          (gpointer)G_CALLBACK(theme_changed_cb),
                                          this);
+    if (mContainer)
+        g_signal_handlers_disconnect_by_func(G_OBJECT(mContainer),
+                                             (gpointer)G_CALLBACK(theme_changed_cb),
+                                             this);
+
+    if (mThemeTimeoutSource) {
+        g_source_remove(mThemeTimeoutSource);                                                                                                                                                  
+        mThemeTimeoutSource = 0;
+    }
 
     // ungrab if required
     nsCOMPtr<nsIWidget> rollupWidget = do_QueryReferent(gRollupWindow);
     if (NS_STATIC_CAST(nsIWidget *, this) == rollupWidget.get()) {
         if (gRollupListener)
             gRollupListener->Rollup();
         gRollupWindow = nsnull;
         gRollupListener = nsnull;
     }
 
@@ -3042,20 +3053,22 @@ nsWindow::NativeCreate(nsIWidget        
         GtkSettings* default_settings = gtk_settings_get_default();
         g_signal_connect_after(default_settings,
                                "notify::gtk-theme-name",
                                G_CALLBACK(theme_changed_cb), this);
         g_signal_connect_after(default_settings,
                                "notify::gtk-font-name",
                                G_CALLBACK(theme_changed_cb), this);
     }
 
     if (mContainer) {
+        g_signal_connect(G_OBJECT(mContainer), "style_set",
+                         G_CALLBACK(theme_changed_cb), this);
         g_signal_connect_after(G_OBJECT(mContainer), "size_allocate",
                                G_CALLBACK(size_allocate_cb), NULL);
         g_signal_connect(G_OBJECT(mContainer), "expose_event",
                          G_CALLBACK(expose_event_cb), NULL);
         g_signal_connect_after(G_OBJECT(mContainer), "enter_notify_event",
                          G_CALLBACK(enter_notify_event_cb), NULL);
         g_signal_connect_after(G_OBJECT(mContainer), "leave_notify_event",
                          G_CALLBACK(leave_notify_event_cb), NULL);
         g_signal_connect_after(G_OBJECT(mContainer), "motion_notify_event",
                          G_CALLBACK(motion_notify_event_cb), NULL);
@@ -4620,26 +4633,39 @@ window_state_event_cb (GtkWidget *widget
 {
     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
     if (!window)
         return FALSE;
 
     window->OnWindowStateEvent(widget, event);
 
     return FALSE;
 }
 
+static gboolean
+timeout_theme_change(void *data)
+{
+    nsRefPtr<nsWindow> window = (nsWindow *)data;
+    window->ThemeChanged();
+    return FALSE;
+}
+
 /* static */
 void
 theme_changed_cb (GtkSettings *settings, GParamSpec *pspec, nsWindow *data)
 {
-    nsRefPtr<nsWindow> window = data;
-    window->ThemeChanged();
+    nsRefPtr<nsWindow> window = (nsWindow *)data;
+    if (window->mThemeTimeoutSource) {
+      g_source_remove(window->mThemeTimeoutSource);
+      window->mThemeTimeoutSource = 0;
+    }
+    window->mThemeTimeoutSource =
+        g_timeout_add(GTK_THEME_CHANGE_TIMEOUT, timeout_theme_change, (void*)data);
 }
 
 //////////////////////////////////////////////////////////////////////
 // These are all of our drag and drop operations
 
 void
 nsWindow::InitDragEvent(nsMouseEvent &aEvent)
 {
     // set the keyboard modifiers
     gint x, y;
