# Zoom and auto image zoom fixes                                                                                                                                                                     
# Works fine on trunk      
--- mozilla/content/html/document/src/nsImageDocument.cpp.orig	2007-09-10 16:02:04.000000000 +0300
+++ mozilla/content/html/document/src/nsImageDocument.cpp	2007-09-10 16:10:06.000000000 +0300
@@ -400,20 +400,26 @@ nsImageDocument::GetImageRequest(imgIReq
   }
 
   *aImageRequest = nsnull;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImageDocument::ShrinkToFit()
 {
   // Keep image content alive while changing the attributes.
+  nsIPresShell *shell = GetPrimaryShell();
+  if (shell) {
+    nsPresContext* context = shell->GetPresContext();
+    if (context && 1.0 != context->GetFullZoom())
+      return NS_OK;
+  }
   nsCOMPtr<nsIContent> imageContent = mImageContent;
   nsCOMPtr<nsIDOMHTMLImageElement> image = do_QueryInterface(mImageContent);
   image->SetWidth(PR_MAX(1, NSToCoordFloor(GetRatio() * mImageWidth)));
   image->SetHeight(PR_MAX(1, NSToCoordFloor(GetRatio() * mImageHeight)));
   
   imageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
                         NS_LITERAL_STRING("cursor: -moz-zoom-in"), PR_TRUE);
   
   mImageIsResized = PR_TRUE;
   
@@ -527,38 +533,50 @@ nsImageDocument::HandleEvent(nsIDOMEvent
         nsCOMPtr<nsIDOMNSHTMLElement> nsElement(do_QueryInterface(mImageContent));
         nsElement->GetOffsetLeft(&left);
         nsElement->GetOffsetTop(&top);
         x -= left;
         y -= top;
       }
       mShouldResize = PR_FALSE;
       RestoreImageTo(x, y);
     }
     else if (mImageIsOverflowing) {
+      nsIPresShell *shell = GetPrimaryShell();
+      if (shell) {
+        nsPresContext* context = shell->GetPresContext();
+        if (context && 1.0 != context->GetFullZoom())
+          context->SetFullZoom(1.0);
+      }
       ShrinkToFit();
     }
   }
   else if (eventType.EqualsLiteral("keypress")) {
     nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
     PRUint32 charCode;
     keyEvent->GetCharCode(&charCode);
     // plus key
     if (charCode == 0x2B) {
       mShouldResize = PR_FALSE;
       if (mImageIsResized) {
         RestoreImage();
       }
     }
     // minus key
     else if (charCode == 0x2D) {
       mShouldResize = PR_TRUE;
       if (mImageIsOverflowing) {
+        nsIPresShell *shell = GetPrimaryShell();
+        if (shell) {
+          nsPresContext* context = shell->GetPresContext();
+          if (context && 1.0 != context->GetFullZoom())
+            context->SetFullZoom(1.0);
+        }
         ShrinkToFit();
       }
     }
   }
 
   return NS_OK;
 }
 
 nsresult
 nsImageDocument::CreateSyntheticDocument()
@@ -629,20 +647,24 @@ nsImageDocument::CheckOverflowing(PRBool
     nsMargin m;
     if (styleContext->GetStyleMargin()->GetMargin(m))
       visibleArea.Deflate(m);
     m = styleContext->GetStyleBorder()->GetBorder();
     visibleArea.Deflate(m);
     if (styleContext->GetStylePadding()->GetPadding(m))
       visibleArea.Deflate(m);
 
     mVisibleWidth = nsPresContext::AppUnitsToIntCSSPixels(visibleArea.width);
     mVisibleHeight = nsPresContext::AppUnitsToIntCSSPixels(visibleArea.height);
+    if (context && 1.0 != context->GetFullZoom()) {
+      RestoreImage();
+      return NS_OK;
+    }
   }
 
   PRBool imageWasOverflowing = mImageIsOverflowing;
   mImageIsOverflowing =
     mImageWidth > mVisibleWidth || mImageHeight > mVisibleHeight;
   PRBool windowBecameBigEnough = imageWasOverflowing && !mImageIsOverflowing;
 
   if (changeState || mShouldResize || mFirstResize ||
       windowBecameBigEnough) {
     if (mImageIsOverflowing && (changeState || mShouldResize)) {
