#Bug 4821
#Bug 389720
#Bug 382595  SVG image is covered with horizontal lines when scrolled - recent regression
#391494:  full page zoom causes scrollbars to be cut off or hidden entirely (all zoom levels except 50%, 100%, 150%, 200%)
#390180:  Full page zoom interacts badly with bfcache
#389938:  Full page zoom does not affect text with CSS font set to message-box
Index: mozilla/gfx/public/nsIDeviceContext.h
===================================================================
--- mozilla.orig/gfx/public/nsIDeviceContext.h
+++ mozilla/gfx/public/nsIDeviceContext.h
@@ -467,16 +467,37 @@
 
   /**
    * Check to see if the DPI has changed
    * @return whether there was actually a change in the DPI
    *         (whether AppUnitsPerDevPixel() or AppUnitsPerInch() changed)
   */
   virtual PRBool CheckDPIChange() = 0;
 
+  /**
+   * Set the pixel scaling factor: all lengths are multiplied by this factor
+   * when we convert them to device pixels. Returns whether the ratio of
+   * app units to dev pixels changed because of the scale factor.
+   */
+  virtual PRBool SetPixelScale(float aScale) = 0;
+
+  /**
+   * Get the pixel scaling factor; defaults to 1.0, but can be changed with
+   * SetPixelScale.
+   */
+  float GetPixelScale() const { return mPixelScale; }
+
+  /**
+   * Get the unscaled ratio of app units to dev pixels; useful if something
+   * needs to be converted from to unscaled pixels
+   */
+  PRInt32 UnscaledAppUnitsPerDevPixel() const { return mAppUnitsPerDevNotScaledPixel; }
+
 protected:
   PRInt32 mAppUnitsPerDevPixel;
   PRInt32 mAppUnitsPerInch;
+  PRInt32 mAppUnitsPerDevNotScaledPixel;
+  float  mPixelScale;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIDeviceContext, NS_IDEVICE_CONTEXT_IID)
 
 #endif /* nsIDeviceContext_h___ */
Index: mozilla/gfx/src/nsDeviceContext.cpp
===================================================================
--- mozilla.orig/gfx/src/nsDeviceContext.cpp
+++ mozilla/gfx/src/nsDeviceContext.cpp
@@ -52,16 +52,19 @@
 #include "nsIRenderingContext.h"
 
 NS_IMPL_ISUPPORTS3(DeviceContextImpl, nsIDeviceContext, nsIObserver, nsISupportsWeakReference)
 
 DeviceContextImpl::DeviceContextImpl()
 {
   mAppUnitsPerDevPixel = -1;
   mAppUnitsPerInch = -1;
+  mAppUnitsPerDevNotScaledPixel = -1;
+  mPixelScale = 1.0f;
+
   mFontCache = nsnull;
   mWidget = nsnull;
   mFontAliasTable = nsnull;
 
 #ifdef NS_DEBUG
   mInitialized = PR_FALSE;
 #endif
 }
@@ -494,27 +497,29 @@
   // First check our cache
   // start from the end, which is where we put the most-recent-used element
 
   nsIFontMetrics* fm;
   PRInt32 n = mFontMetrics.Count() - 1;
   for (PRInt32 i = n; i >= 0; --i) {
     fm = NS_STATIC_CAST(nsIFontMetrics*, mFontMetrics[i]);
     if (fm->Font().Equals(aFont)) {
+    if (mContext->AppUnitsPerDevPixel() == fm->mP2A) {
       nsCOMPtr<nsIAtom> langGroup;
       fm->GetLangGroup(getter_AddRefs(langGroup));
       if (aLangGroup == langGroup.get()) {
         if (i != n) {
           // promote it to the end of the cache
           mFontMetrics.MoveElement(i, n);
         }
         NS_ADDREF(aMetrics = fm);
         return NS_OK;
       }
     }
+    }
   }
 
   // It's not in the cache. Get font metrics and then cache them.
 
   aMetrics = nsnull;
   nsresult rv = CreateFontMetricsInstance(&fm);
   if (NS_FAILED(rv)) return rv;
   rv = fm->Init(aFont, aLangGroup, mContext);
Index: mozilla/gfx/src/thebes/nsThebesDeviceContext.cpp
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesDeviceContext.cpp
+++ mozilla/gfx/src/thebes/nsThebesDeviceContext.cpp
@@ -226,27 +226,30 @@
 
     NS_ASSERTION(dpi != -1, "no dpi set");
 
     if (dotsArePixels) {
         // First figure out the closest multiple of 96, which is the number of
         // dev pixels per CSS pixel.  Then, divide that into AppUnitsPerCSSPixel()
         // to get the number of app units per dev pixel.  The PR_MAXes are to
         // make sure we don't end up dividing by zero.
-        mAppUnitsPerDevPixel = ((float)AppUnitsPerCSSPixel() * 96.) / (float)dpi;
+        mAppUnitsPerDevNotScaledPixel = PR_MAX(1, AppUnitsPerCSSPixel() /
+                                        PR_MAX(1, (dpi + 48) / 96));
 
     } else {
         /* set mAppUnitsPerDevPixel so we're using exactly 72 dpi, even
          * though that means we have a non-integer number of device "pixels"
          * per CSS pixel
          */
-        mAppUnitsPerDevPixel = (AppUnitsPerCSSPixel() * 96) / dpi;
+        mAppUnitsPerDevNotScaledPixel = (AppUnitsPerCSSPixel() * 96) / dpi;
     }
 
-    mAppUnitsPerInch = NSIntPixelsToAppUnits(dpi, mAppUnitsPerDevPixel);
+    mAppUnitsPerInch = NSIntPixelsToAppUnits(dpi, mAppUnitsPerDevNotScaledPixel);
+
+    UpdateScaledAppUnits();
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsThebesDeviceContext::Init(nsNativeWidget aWidget)
 {
     mWidget = aWidget;
@@ -415,17 +418,17 @@
 
     aFont->name = fontName;
     aFont->style = fontStyle.style;
     aFont->systemFont = fontStyle.systemFont;
     aFont->variant = NS_FONT_VARIANT_NORMAL;
     aFont->familyNameQuirks = fontStyle.familyNameQuirks;
     aFont->weight = fontStyle.weight;
     aFont->decorations = NS_FONT_DECORATION_NONE;
-    aFont->size = NSFloatPixelsToAppUnits(fontStyle.size, AppUnitsPerDevPixel());
+    aFont->size = NSFloatPixelsToAppUnits(fontStyle.size, UnscaledAppUnitsPerDevPixel());
     //aFont->langGroup = fontStyle.langGroup;
     aFont->sizeAdjust = fontStyle.sizeAdjust;
 
     return rv;
 }
 
 NS_IMETHODIMP
 nsThebesDeviceContext::CheckFontExistence(const nsString& aFaceName)
@@ -742,16 +745,35 @@
         printf("%d %d\n", (PRInt32)mWidth, (PRInt32)mHeight);
     } else {
         mWidth = NSToIntRound(size.width);
         mHeight = NSToIntRound(size.height);
     }
 }
 
 PRBool nsThebesDeviceContext::CheckDPIChange() {
-    PRInt32 oldDevPixels = mAppUnitsPerDevPixel;
+    PRInt32 oldDevPixels = mAppUnitsPerDevNotScaledPixel;
     PRInt32 oldInches = mAppUnitsPerInch;
 
     SetDPI();
 
-    return oldDevPixels != mAppUnitsPerDevPixel ||
+    return oldDevPixels != mAppUnitsPerDevNotScaledPixel ||
            oldInches != mAppUnitsPerInch;
 }
+
+PRBool
+nsThebesDeviceContext::SetPixelScale(float aScale)
+{
+    if (aScale <= 0) {
+        NS_NOTREACHED("Invalid pixel scale value");
+        return PR_FALSE;
+    }
+    PRInt32 oldAppUnitsPerDevPixel = mAppUnitsPerDevPixel;
+    mPixelScale = aScale;
+    UpdateScaledAppUnits();
+    return oldAppUnitsPerDevPixel != mAppUnitsPerDevPixel;
+}
+
+void
+nsThebesDeviceContext::UpdateScaledAppUnits()
+{
+    mAppUnitsPerDevPixel = PR_MAX(1, PRInt32(float(mAppUnitsPerDevNotScaledPixel) / mPixelScale));
+}
Index: mozilla/gfx/src/thebes/nsThebesDeviceContext.h
===================================================================
--- mozilla.orig/gfx/src/thebes/nsThebesDeviceContext.h
+++ mozilla/gfx/src/thebes/nsThebesDeviceContext.h
@@ -112,16 +112,18 @@
     NS_IMETHOD BeginPage(void);
     NS_IMETHOD EndPage(void);
     /* end printing goop */
 
     static void DebugShowCairoSurface (const char *aName, cairo_surface_t *aSurface);
 
     virtual PRBool CheckDPIChange();
 
+    virtual PRBool SetPixelScale(float aScale);
+
     nsNativeWidget GetWidget() { return mWidget; }
 #ifdef XP_WIN
     HDC GetPrintHDC() {
         if (mPrintingSurface) {
             NS_ASSERTION(mPrintingSurface->GetType() == gfxASurface::SurfaceTypeWin32, "invalid surface type");
             return reinterpret_cast<gfxWindowsSurface*>(mPrintingSurface.get())->GetDC();
         }
         return nsnull;
@@ -138,16 +140,17 @@
 #endif
 
 protected:
     nsresult SetDPI();
     void ComputeClientRectUsingScreen(nsRect *outRect);
     void ComputeFullAreaUsingScreen(nsRect *outRect);
     void FindScreen(nsIScreen **outScreen);
     void CalcPrintingSize();
+    void UpdateScaledAppUnits();
 
     PRUint32 mDepth;
 
 private:
     nsCOMPtr<nsIScreenManager> mScreenManager;
 
     nscoord mWidth;
     nscoord mHeight;
Index: mozilla/docshell/base/nsIMarkupDocumentViewer.idl
===================================================================
--- mozilla.orig/docshell/base/nsIMarkupDocumentViewer.idl
+++ mozilla/docshell/base/nsIMarkupDocumentViewer.idl
@@ -59,16 +59,19 @@
 	/*
 	Scrolls to a given DOM content node. 
 	*/
 	void scrollToNode(in nsIDOMNode node);
 
 	/** The amount by which to scale all text. Default is 1.0. */
 	attribute float textZoom;
 
+	/** The amount by which to scale all lengths. Default is 1.0. */
+	attribute float fullZoom;
+
 	/** Disable entire author style level (including HTML presentation hints) */
 	attribute boolean authorStyleDisabled;
 
 	/*
 	XXX Comment here!
 	*/
 	attribute ACString defaultCharacterSet;
 
Index: mozilla/layout/base/nsDocumentViewer.cpp
===================================================================
--- mozilla.orig/layout/base/nsDocumentViewer.cpp
+++ mozilla/layout/base/nsDocumentViewer.cpp
@@ -405,16 +405,17 @@
   nsCOMPtr<nsIDOMFocusListener> mFocusListener;
 
   nsCOMPtr<nsIContentViewer> mPreviousViewer;
   nsCOMPtr<nsISHEntry> mSHEntry;
 
   nsIWidget* mParentWidget;          // purposely won't be ref counted
 
   float mTextZoom;      // Text zoom, defaults to 1.0
+  float mPageZoom;
 
   PRInt16 mNumURLStarts;
   PRInt16 mDestroyRefCount;    // a second "refcount" for the document viewer's "destroy"
 
   unsigned      mEnableRendering : 1;
   unsigned      mStopped : 1;
   unsigned      mLoaded : 1;
   unsigned      mDeferredWindowClose : 1;
@@ -500,17 +501,17 @@
   mDebugFile = nsnull;
 #endif
 
 #endif // NS_PRINTING
 }
 
 // Note: operator new zeros our memory, so no need to init things to null.
 DocumentViewerImpl::DocumentViewerImpl()
-  : mTextZoom(1.0),
+  : mTextZoom(1.0), mPageZoom(1.0),
     mIsSticky(PR_TRUE),
     mHintCharsetSource(kCharsetUninitialized)
 {
   PrepareToStartLoad();
 }
 
 NS_IMPL_ADDREF(DocumentViewerImpl)
 NS_IMPL_RELEASE(DocumentViewerImpl)
@@ -675,22 +676,23 @@
   }
 
   mPresShell->BeginObservingDocument();
 
   // Initialize our view manager
   nsRect bounds;
   mWindow->GetBounds(bounds);
 
-  nscoord width = mPresContext->DevPixelsToAppUnits(bounds.width);
-  nscoord height = mPresContext->DevPixelsToAppUnits(bounds.height);
+  nscoord width = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel() * bounds.width;
+  nscoord height = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel() * bounds.height;
 
   mViewManager->DisableRefresh();
   mViewManager->SetWindowDimensions(width, height);
   mPresContext->SetTextZoom(mTextZoom);
+  mPresContext->SetFullZoom(mPageZoom);
 
   // Setup default view manager background color
 
   // This may be overridden by the docshell with the background color
   // for the last document loaded into the docshell
   mViewManager->SetDefaultBackgroundColor(mPresContext->DefaultBackgroundColor());
 
   if (aDoInitialReflow) {
@@ -2630,43 +2632,50 @@
             (*aFunc)(markupCV, aClosure);
           }
         }
       }
     }
   }
 }
 
-struct TextZoomInfo
+struct ZoomInfo
 {
-  float mTextZoom;
+  float mZoom;
 };
 
 static void
 SetChildTextZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
 {
-  struct TextZoomInfo* textZoomInfo = (struct TextZoomInfo*) aClosure;
-  aChild->SetTextZoom(textZoomInfo->mTextZoom);
+  struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
+  aChild->SetTextZoom(ZoomInfo->mZoom);
+}
+
+static void
+SetChildFullZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
+{
+  struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
+  aChild->SetFullZoom(ZoomInfo->mZoom);
 }
 
 NS_IMETHODIMP
 DocumentViewerImpl::SetTextZoom(float aTextZoom)
 {
   mTextZoom = aTextZoom;
 
   if (mViewManager) {
     mViewManager->BeginUpdateViewBatch();
   }
       
   // Set the text zoom on all children of mContainer (even if our zoom didn't
   // change, our children's zoom may be different, though it would be unusual).
   // Do this first, in case kids are auto-sizing and post reflow commands on
   // our presshell (which should be subsumed into our own style change reflow).
-  struct TextZoomInfo textZoomInfo = { aTextZoom };
-  CallChildren(SetChildTextZoom, &textZoomInfo);
+  struct ZoomInfo ZoomInfo = { aTextZoom };
+  CallChildren(SetChildTextZoom, &ZoomInfo);
 
   // Now change our own zoom
   if (mPresContext && aTextZoom != mPresContext->TextZoom()) {
       mPresContext->SetTextZoom(aTextZoom);
   }
 
   if (mViewManager) {
     mViewManager->EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
@@ -2681,16 +2690,39 @@
   NS_ENSURE_ARG_POINTER(aTextZoom);
   NS_ASSERTION(!mPresContext || mPresContext->TextZoom() == mTextZoom, 
                "mPresContext->TextZoom() != mTextZoom");
 
   *aTextZoom = mTextZoom;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+DocumentViewerImpl::SetFullZoom(float aFullZoom)
+{
+  mPageZoom = aFullZoom;
+  struct ZoomInfo ZoomInfo = { aFullZoom };
+  CallChildren(SetChildFullZoom, &ZoomInfo);
+  if (mPresContext) {
+      mPresContext->SetFullZoom(aFullZoom);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+DocumentViewerImpl::GetFullZoom(float* aFullZoom)
+{
+  NS_ENSURE_ARG_POINTER(aFullZoom);
+  NS_ASSERTION(!mPresContext || mPresContext->GetFullZoom() == mPageZoom,
+               "mPresContext->TextZoom() != mTextZoom");
+  *aFullZoom = mPresContext ? mPresContext->GetFullZoom() : 1.0f;
+  return NS_OK;
+}
+
 static void
 SetChildAuthorStyleDisabled(nsIMarkupDocumentViewer* aChild, void* aClosure)
 {
   PRBool styleDisabled  = *NS_STATIC_CAST(PRBool*, aClosure);
   aChild->SetAuthorStyleDisabled(styleDisabled);
 }
 
 
Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -154,17 +154,17 @@
 static NS_DEFINE_CID(kLookAndFeelCID,  NS_LOOKANDFEEL_CID);
 #include "nsContentCID.h"
 static NS_DEFINE_CID(kSelectionImageService, NS_SELECTIONIMAGESERVICE_CID);
 
   // NOTE! nsPresContext::operator new() zeroes out all members, so don't
   // bother initializing members to 0.
 
 nsPresContext::nsPresContext(nsIDocument* aDocument, nsPresContextType aType)
-  : mType(aType), mDocument(aDocument), mTextZoom(1.0),
+  : mType(aType), mDocument(aDocument), mTextZoom(1.0), mFullZoom(1.0), mTrueZoomMode(PR_FALSE),
     mPageSize(-1, -1), mPPScale(1.0f),
     mViewportStyleOverflow(NS_STYLE_OVERFLOW_AUTO, NS_STYLE_OVERFLOW_AUTO),
     mImageAnimationModePref(imgIContainer::kNormalAnimMode),
     // Font sizes default to zero; they will be set in GetFontPreferences
     mDefaultVariableFont("serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                          NS_FONT_WEIGHT_NORMAL, 0, 0),
     mDefaultFixedFont("monospace", NS_FONT_STYLE_NORMAL,
                       NS_FONT_VARIANT_NORMAL, NS_FONT_WEIGHT_NORMAL, 0, 0),
@@ -271,16 +271,20 @@
 #ifdef IBMBIDI
   nsContentUtils::UnregisterPrefCallback("bidi.", PrefChangedCallback, this);
 
   delete mBidiUtils;
 #endif // IBMBIDI
   nsContentUtils::UnregisterPrefCallback("layout.css.dpi",
                                          nsPresContext::PrefChangedCallback,
                                          this);
+  nsContentUtils::UnregisterPrefCallback("layout.full.true.zoom.mode",
+                                         nsPresContext::PrefChangedCallback,
+                                         this);
+
 
   NS_IF_RELEASE(mDeviceContext);
   NS_IF_RELEASE(mLookAndFeel);
   NS_IF_RELEASE(mLangGroup);
 }
 
 NS_IMPL_ISUPPORTS1(nsPresContext, nsIObserver)
 
@@ -524,16 +528,20 @@
 
   // * document colors
   GetDocumentColorPreferences();
 
   // * link colors
   mUnderlineLinks =
     nsContentUtils::GetBoolPref("browser.underline_anchors", mUnderlineLinks);
 
+  // True Zoom Mode
+  mTrueZoomMode =
+    nsContentUtils::GetBoolPref("layout.full.true.zoom.mode", mTrueZoomMode);
+
   nsAdoptingCString colorStr =
     nsContentUtils::GetCharPref("browser.anchor_color");
 
   if (!colorStr.IsEmpty()) {
     mLinkColor = MakeColorPref(colorStr);
   }
 
   colorStr =
@@ -656,24 +664,32 @@
 
 void
 nsPresContext::PreferenceChanged(const char* aPrefName)
 {
   if (!nsCRT::strcmp(aPrefName, "layout.css.dpi")) {
     nsRect bounds(mVisibleArea);
     bounds *= 1.0f / AppUnitsPerDevPixel();
     if (mDeviceContext->CheckDPIChange() && mShell) {
-      mDeviceContext->FlushFontCache();
+      //ROMAXA mDeviceContext->FlushFontCache();
 
-      nsIViewManager* vm = GetViewManager();
       nscoord width = DevPixelsToAppUnits(bounds.width);
       nscoord height = DevPixelsToAppUnits(bounds.height);
-      vm->SetWindowDimensions(width, height);
 
-      ClearStyleDataAndReflow();
+      if (nsContentUtils::GetBoolPref("layout.full.zoom.mode.fast", PR_FALSE)) {
+      /* XXX this way of reflow works 3x faster, but buggy
+       Internal scrolbars also resized (Iframe, textarea...)
+      */
+      mShell->FrameNeedsReflow(mShell->GetRootFrame(), nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+      mShell->ResizeReflow(width, height);
+      } else {
+        nsIViewManager* vm = GetViewManager();
+        vm->SetWindowDimensions(width, height);
+        ClearStyleDataAndReflow();
+      }
     }
     return;
   }
   // we use a zero-delay timer to coalesce multiple pref updates
   if (!mPrefChangedTimer)
   {
     mPrefChangedTimer = do_CreateInstance("@mozilla.org/timer;1");
     if (!mPrefChangedTimer)
@@ -711,16 +727,18 @@
 nsPresContext::Init(nsIDeviceContext* aDeviceContext)
 {
   NS_ASSERTION(!(mInitialized == PR_TRUE), "attempt to reinit pres context");
   NS_ENSURE_ARG(aDeviceContext);
 
   mDeviceContext = aDeviceContext;
   NS_ADDREF(mDeviceContext);
 
+  mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
+
   if (!mImageLoaders.Init())
     return NS_ERROR_OUT_OF_MEMORY;
   
   // Get the look and feel service here; default colors will be initialized
   // from calling GetUserPreferences() when we get a presshell.
   nsresult rv = CallGetService(kLookAndFeelCID, &mLookAndFeel);
   if (NS_FAILED(rv)) {
     NS_ERROR("LookAndFeel service must be implemented for this toolkit");
@@ -759,16 +777,19 @@
                                        this);
 #ifdef IBMBIDI
   nsContentUtils::RegisterPrefCallback("bidi.", PrefChangedCallback,
                                        this);
 #endif
   nsContentUtils::RegisterPrefCallback("layout.css.dpi",
                                        nsPresContext::PrefChangedCallback,
                                        this);
+  nsContentUtils::RegisterPrefCallback("layout.full.true.zoom.mode",
+                                       nsPresContext::PrefChangedCallback,
+                                       this);
 
   rv = mEventManager->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
   mEventManager->SetPresContext(this);
 
 #ifdef DEBUG
   mInitialized = PR_TRUE;
@@ -1053,19 +1074,37 @@
 
 const nsFont*
 nsPresContext::GetDefaultFontExternal(PRUint8 aFontID) const
 {
   return GetDefaultFontInternal(aFontID);
 }
 
 void
-nsPresContext::SetTextZoomExternal(float aZoom)
+nsPresContext::SetFullZoom(float aZoom)
 {
-  SetTextZoomInternal(aZoom);
+  float oldWidth = mVisibleArea.width / (float)mCurAppUnitsPerDevPixel;
+  float oldHeight = mVisibleArea.height / (float)mCurAppUnitsPerDevPixel;
+  if (!mShell) {
+    return;
+  }
+  if (mDeviceContext->SetPixelScale(aZoom)) {
+    // ROMAXA mDeviceContext->FlushFontCache();
+  }
+  if (mFullZoom != aZoom) {
+    mFullZoom = aZoom;
+    if (nsContentUtils::GetBoolPref("layout.full.zoom.mode.fast", PR_FALSE)) {
+      mShell->FrameNeedsReflow(mShell->GetRootFrame(), nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
+      mShell->ResizeReflow(oldWidth * AppUnitsPerDevPixel(), oldHeight * AppUnitsPerDevPixel());
+    } else {
+      GetViewManager()->SetWindowDimensions(oldWidth * AppUnitsPerDevPixel(), oldHeight * AppUnitsPerDevPixel());
+      ClearStyleDataAndReflow();
+    }
+  }
+  mCurAppUnitsPerDevPixel = AppUnitsPerDevPixel();
 }
 
 imgIRequest*
 nsPresContext::LoadImage(imgIRequest* aImage, nsIFrame* aTargetFrame)
 {
   // look and see if we have a loader for the target frame.
   nsCOMPtr<nsImageLoader> loader;
   mImageLoaders.Get(aTargetFrame, getter_AddRefs(loader));
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -445,26 +445,24 @@
   float GetPrintPreviewScale() { return mPPScale; }
   void SetPrintPreviewScale(float aScale) { mPPScale = aScale; }
 
   nsIDeviceContext* DeviceContext() { return mDeviceContext; }
   nsIEventStateManager* EventStateManager() { return mEventManager; }
   nsIAtom* GetLangGroup() { return mLangGroup; }
 
   float TextZoom() { return mTextZoom; }
-  void SetTextZoomInternal(float aZoom) {
+  void SetTextZoom(float aZoom) {
     mTextZoom = aZoom;
     ClearStyleDataAndReflow();
   }
-  virtual NS_HIDDEN_(void) SetTextZoomExternal(float aZoom);
-#ifdef _IMPL_NS_LAYOUT
-  void SetTextZoom(float aZoom) { SetTextZoomInternal(aZoom); }
-#else
-  void SetTextZoom(float aZoom) { SetTextZoomExternal(aZoom); }
-#endif
+
+  PRBool TrueZoomMode() { return mTrueZoomMode; }
+  float GetFullZoom() { return mFullZoom; }
+  void SetFullZoom(float aZoom);
 
   static PRInt32 AppUnitsPerCSSPixel() { return nsIDeviceContext::AppUnitsPerCSSPixel(); }
   PRInt32 AppUnitsPerDevPixel() const  { return mDeviceContext->AppUnitsPerDevPixel(); }
   PRInt32 AppUnitsPerInch() const      { return mDeviceContext->AppUnitsPerInch(); }
 
   static nscoord CSSPixelsToAppUnits(PRInt32 aPixels)
   { return NSIntPixelsToAppUnits(aPixels,
                                  nsIDeviceContext::AppUnitsPerCSSPixel()); }
@@ -763,16 +761,18 @@
   nsWeakPtr             mContainer;
 
   // Only used in the root prescontext (this->RootPresContext() == this)
   // This is a list of all active popups from bottom to top in z-order
   // (usually empty, of course)
   nsTArray<nsIFrame*>   mActivePopups;
 
   float                 mTextZoom;      // Text zoom, defaults to 1.0
+  float                 mFullZoom;      // Page zoom, defaults to 1.0
+  PRInt32               mCurAppUnitsPerDevPixel;
 
 #ifdef IBMBIDI
   nsBidiPresUtils*      mBidiUtils;
 #endif
 
   nsCOMPtr<nsITheme> mTheme;
   nsCOMPtr<nsILanguageAtomService> mLangService;
   nsCOMPtr<nsIPrintSettings> mPrintSettings;
@@ -839,16 +839,17 @@
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
   unsigned              mIsBidiSystem : 1;
 
 #endif
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
+  PRPackedBool          mTrueZoomMode : 1;
 
 
 protected:
 
   ~nsPresContext() NS_HIDDEN;
 
   // these are private, use the list in nsFont.h if you want a public list
   enum {
Index: mozilla/content/events/src/nsDOMUIEvent.cpp
===================================================================
--- mozilla.orig/content/events/src/nsDOMUIEvent.cpp
+++ mozilla/content/events/src/nsDOMUIEvent.cpp
@@ -120,22 +120,23 @@
        mEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
        !NS_IS_DRAG_EVENT(mEvent))) {
     return nsPoint(0, 0);
   }
 
   if (!((nsGUIEvent*)mEvent)->widget ) {
     return mEvent->refPoint;
   }
-    
+
   nsRect bounds(mEvent->refPoint, nsSize(1, 1));
   nsRect offset;
   ((nsGUIEvent*)mEvent)->widget->WidgetToScreen ( bounds, offset );
-  return nsPoint(nsPresContext::AppUnitsToIntCSSPixels(mPresContext->DevPixelsToAppUnits(offset.x)),
-                 nsPresContext::AppUnitsToIntCSSPixels(mPresContext->DevPixelsToAppUnits(offset.y)));
+  PRInt32 factor = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel();
+  return nsPoint(nsPresContext::AppUnitsToIntCSSPixels(offset.x * factor),
+                 nsPresContext::AppUnitsToIntCSSPixels(offset.y * factor));
 }
 
 nsPoint nsDOMUIEvent::GetClientPoint() {
   if (!mEvent ||
       (mEvent->eventStructType != NS_MOUSE_EVENT &&
        mEvent->eventStructType != NS_POPUP_EVENT &&
        mEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
        !NS_IS_DRAG_EVENT(mEvent)) ||
Index: mozilla/gfx/src/nsRect.cpp
===================================================================
--- mozilla.orig/gfx/src/nsRect.cpp
+++ mozilla/gfx/src/nsRect.cpp
@@ -199,22 +199,22 @@
   nscoord bottom = NSToCoordFloor(float(YMost()) * aScale);
   x = NSToCoordCeil(float(x) * aScale);
   y = NSToCoordCeil(float(y) * aScale);
   width = (right - x);
   height = (bottom - y);
   return *this;
 }
 
-nsRect& nsRect::ScaleRoundPreservingCenters(float aScale)
+nsRect& nsRect::ScaleRoundPreservingCentersInverse(float aScale)
 {
-  nscoord right = NSToCoordRound(float(XMost()) * aScale);
-  nscoord bottom = NSToCoordRound(float(YMost()) * aScale);
-  x = NSToCoordRound(float(x) * aScale);
-  y = NSToCoordRound(float(y) * aScale);
+  nscoord right = NSToCoordRound(float(XMost()) / aScale);
+  nscoord bottom = NSToCoordRound(float(YMost()) / aScale);
+  x = NSToCoordRound(float(x) / aScale);
+  y = NSToCoordRound(float(y) / aScale);
   width = (right - x);
   height = (bottom - y);
   return *this;
 }
 
 #ifdef DEBUG
 // Diagnostics
 
Index: mozilla/gfx/public/nsRect.h
===================================================================
--- mozilla.orig/gfx/public/nsRect.h
+++ mozilla/gfx/public/nsRect.h
@@ -160,19 +160,19 @@
                                           return *this;}
 
   // Scale by aScale, converting coordinates to integers so that the result
   // is the smallest integer-coordinate rectangle containing the unrounded result
   nsRect& ScaleRoundOut(float aScale);
   // Scale by aScale, converting coordinates to integers so that the result
   // is the larges integer-coordinate rectangle contained in the unrounded result
   nsRect& ScaleRoundIn(float aScale);
-  // Scale by aScale, converting coordinates to integers so that the result
-  // contains the same pixel centers as the unrounded result
-  nsRect& ScaleRoundPreservingCenters(float aScale);
+  // Scale by the inverse of aScale, converting coordinates to integers so that
+  // the result contains the same pixel centers as the unrounded result
+  nsRect & ScaleRoundPreservingCentersInverse (float aScale);
 
   // Helpers for accessing the vertices
   nsPoint TopLeft() const { return nsPoint(x, y); }
   nsPoint TopRight() const { return nsPoint(XMost(), y); }
   nsPoint BottomLeft() const { return nsPoint(x, YMost()); }
   nsPoint BottomRight() const { return nsPoint(XMost(), YMost()); }
 
   nsSize Size() const { return nsSize(width, height); }
Index: mozilla/view/src/nsView.cpp
===================================================================
--- mozilla.orig/view/src/nsView.cpp
+++ mozilla/view/src/nsView.cpp
@@ -361,17 +361,17 @@
       nsRect screenRect(0,0,1,1);
       parentWidget->WidgetToScreen(screenRect, screenRect);
       viewBounds += nsPoint(NSIntPixelsToAppUnits(screenRect.x, p2a),
                             NSIntPixelsToAppUnits(screenRect.y, p2a));
     }
   }
 
   nsRect newBounds(viewBounds);
-  newBounds.ScaleRoundPreservingCenters(1.0f / p2a);
+  newBounds.ScaleRoundPreservingCentersInverse(p2a);
 
   nsPoint roundedOffset(NSIntPixelsToAppUnits(newBounds.x, p2a),
                         NSIntPixelsToAppUnits(newBounds.y, p2a));
   mViewToWidgetOffset = viewBounds.TopLeft() - roundedOffset;
 
   return newBounds;
 }
 
Index: mozilla/docshell/base/nsDocShell.cpp
===================================================================
--- mozilla.orig/docshell/base/nsDocShell.cpp
+++ mozilla/docshell/base/nsDocShell.cpp
@@ -5402,19 +5402,22 @@
         nsIRequest *request = nsnull;
         if (doc)
             request = doc->GetChannel();
         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
     }
 
     nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV(do_QueryInterface(mContentViewer));
     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV(do_QueryInterface(viewer));
-    float zoom = 1.0;
-    if (oldMUDV && newMUDV)
-        oldMUDV->GetTextZoom(&zoom);
+    float textZoom = 1.0f;
+    float pageZoom = 1.0f;
+    if (oldMUDV && newMUDV) {
+        oldMUDV->GetTextZoom(&textZoom);
+        oldMUDV->GetFullZoom(&pageZoom);
+    }
 
     // Protect against mLSHE going away via a load triggered from
     // pagehide or unload.
     nsCOMPtr<nsISHEntry> origLSHE = mLSHE;
 
     // Notify the old content viewer that it's being hidden.
     FirePageHideNotification(!mSavingOldViewer);
 
@@ -5583,18 +5586,20 @@
     mEODForCurrentDocument = PR_FALSE;
 
     // Tell the event loop to favor plevents over user events, see comments
     // in CreateContentViewer.
     if (++gNumberOfDocumentsLoading == 1)
         FavorPerformanceHint(PR_TRUE, NS_EVENT_STARVATION_DELAY_HINT);
 
 
-    if (oldMUDV && newMUDV)
-        newMUDV->SetTextZoom(zoom);
+    if (oldMUDV && newMUDV) {
+        newMUDV->SetTextZoom(textZoom);
+        newMUDV->SetFullZoom(pageZoom);
+    }
 
     nsCOMPtr<nsIDocument> document = do_QueryInterface(domDoc);
     if (document) {
         // Use the uri from the mLSHE we had when we entered this function
         // (which need not match the document's URI if anchors are involved),
         // since that's the history entry we're loading.  Note that if we use
         // origLSHE we don't have to worry about whether the entry in question
         // is still mLSHE or whether it's now mOSHE.
@@ -5917,16 +5922,17 @@
     nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
 
     nsCAutoString defaultCharset;
     nsCAutoString forceCharset;
     nsCAutoString hintCharset;
     PRInt32 hintCharsetSource;
     nsCAutoString prevDocCharset;
     float textZoom;
+    float pageZoom;
     PRBool styleDisabled;
     // |newMUDV| also serves as a flag to set the data from the above vars
     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV;
 
     if (mContentViewer || parent) {
         nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV;
         if (mContentViewer) {
             // Get any interesting state from old content viewer
@@ -5967,16 +5973,19 @@
                                   NS_ERROR_FAILURE);
                 NS_ENSURE_SUCCESS(oldMUDV->
                                   GetHintCharacterSetSource(&hintCharsetSource),
                                   NS_ERROR_FAILURE);
                 NS_ENSURE_SUCCESS(oldMUDV->
                                   GetTextZoom(&textZoom),
                                   NS_ERROR_FAILURE);
                 NS_ENSURE_SUCCESS(oldMUDV->
+                                  GetFullZoom(&pageZoom),
+                                  NS_ERROR_FAILURE);
+                NS_ENSURE_SUCCESS(oldMUDV->
                                   GetAuthorStyleDisabled(&styleDisabled),
                                   NS_ERROR_FAILURE);
                 NS_ENSURE_SUCCESS(oldMUDV->
                                   GetPrevDocCharacterSet(prevDocCharset),
                                   NS_ERROR_FAILURE);
             }
         }
     }
@@ -6100,16 +6109,18 @@
                           NS_ERROR_FAILURE);
         NS_ENSURE_SUCCESS(newMUDV->
                           SetHintCharacterSetSource(hintCharsetSource),
                           NS_ERROR_FAILURE);
         NS_ENSURE_SUCCESS(newMUDV->SetPrevDocCharacterSet(prevDocCharset),
                           NS_ERROR_FAILURE);
         NS_ENSURE_SUCCESS(newMUDV->SetTextZoom(textZoom),
                           NS_ERROR_FAILURE);
+        NS_ENSURE_SUCCESS(newMUDV->SetFullZoom(pageZoom),
+                          NS_ERROR_FAILURE);
         NS_ENSURE_SUCCESS(newMUDV->SetAuthorStyleDisabled(styleDisabled),
                           NS_ERROR_FAILURE);
     }
 
     // End copying block (Don't mess with the old content/document viewer
     // beyond here!!)
 
     // See the book I wrote above regarding why the focus controller is 
Index: mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsDeviceContextGTK.cpp
+++ mozilla/gfx/src/gtk/nsDeviceContextGTK.cpp
@@ -604,21 +604,22 @@
     mDpi = OSVal;
   } else {
     // if we couldn't get the pref or it's negative, and the OS
     // value is under 96ppi, then use 96.
     mDpi = 96;
   }
 
   // make p2t a nice round number - this prevents rounding problems
-  mAppUnitsPerDevPixel = ((float)AppUnitsPerCSSPixel() * 96.) / (float)mDpi;
-  mAppUnitsPerInch = NSIntPixelsToAppUnits(mDpi, mAppUnitsPerDevPixel);
-  mAppUnitsPerDevPixel = mAppUnitsPerDevPixel;
-  mPixelScale = (float)nsIDeviceContext::AppUnitsPerCSSPixel()/(float)mAppUnitsPerDevPixel;
+  mAppUnitsPerDevNotScaledPixel = PR_MAX(1, AppUnitsPerCSSPixel() /
+                                         PR_MAX(1, (mDpi + 48) / 96));
 
+  mAppUnitsPerInch = NSIntPixelsToAppUnits(mDpi, mAppUnitsPerDevNotScaledPixel);
+
+  UpdateScaledAppUnits();
   // XXX need to reflow all documents
   return NS_OK;
 }
 
 static void DoClearCachedSystemFonts()
 {
   //clear our cache of stored system fonts
   if (gSystemFonts) {
@@ -669,16 +670,35 @@
       }
     }
     SetDPI(prefDPI);
 
     return oldDevPixels != mAppUnitsPerDevPixel ||
            oldInches != mAppUnitsPerInch;
 }
 
+PRBool
+nsDeviceContextGTK::SetPixelScale(float aScale)
+{
+    if (aScale <= 0) {
+        NS_NOTREACHED("Invalid pixel scale value");
+        return PR_FALSE;
+    }
+    PRInt32 oldAppUnitsPerDevPixel = mAppUnitsPerDevPixel;
+    mPixelScale = aScale;
+    UpdateScaledAppUnits();
+    return oldAppUnitsPerDevPixel != mAppUnitsPerDevPixel;
+}
+
+void
+nsDeviceContextGTK::UpdateScaledAppUnits()
+{
+    mAppUnitsPerDevPixel = PR_MAX(1, PRInt32(float(mAppUnitsPerDevNotScaledPixel) / mPixelScale));
+}
+
 #define DEFAULT_TWIP_FONT_SIZE 240
 
 nsSystemFontsGTK::nsSystemFontsGTK(float aPixelsToTwips)
   : mDefaultFont("sans-serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                  NS_FONT_WEIGHT_NORMAL, NS_FONT_DECORATION_NONE,
                  DEFAULT_TWIP_FONT_SIZE),
     mButtonFont("sans-serif", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
                 NS_FONT_WEIGHT_NORMAL, NS_FONT_DECORATION_NONE,
Index: mozilla/gfx/src/gtk/nsImageGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsImageGTK.cpp
+++ mozilla/gfx/src/gtk/nsImageGTK.cpp
@@ -693,20 +693,42 @@
     UpdateCachedImage();
 
   if ((mAlphaDepth==1) && mIsSpacer)
     return NS_OK;
 
   if (mDecodedX2 < mDecodedX1 || mDecodedY2 < mDecodedY1)
     return NS_OK;
 
+  float scale = 1.0f;
+  nsCOMPtr<nsIDeviceContext> theDeviceContext;
+  aContext.GetDeviceContext(*getter_AddRefs(theDeviceContext));
+  if (theDeviceContext)
+    scale = theDeviceContext->GetPixelScale();
+
+  PRInt32 origDX = aDX, origDY = aDY, origDWidth = aDWidth, origDHeight = aDHeight;
   PRBool hack = ((aDWidth != aSWidth || aDHeight != aSHeight) && mWidth != aSWidth && aSHeight != mHeight);
   PRInt32 ssW = aSWidth-aSX, ssH = aSHeight - aSY;
-  if (aSX > 0) aSX -= !hack;
-  if (aSY > 0) aSY -= !hack;
+  if (scale != 1.0) {
+    aSWidth = mWidth - 1;
+    aDWidth = NSToIntRound((float)(mWidth) * scale);
+    aDWidth = origDWidth>aDWidth?origDWidth + 1:aDWidth + 1;
+    aDX -= aSX;
+    aSX = 0;
+    aSHeight = mHeight - 1;
+    aDHeight = NSToIntRound((float)(mHeight) * scale);
+    aDHeight = origDHeight>aDHeight?origDHeight + 1:aDHeight + 1;
+    aDY -= aSY;
+    aSY = 0;
+  }
+  else {
+    if (aSX > 0) aSX -= !hack;
+    if (aSY > 0) aSY -= !hack;
+  }
+
 
 #ifdef TRACE_IMAGE_ALLOCATION
   fprintf(stderr, "nsImageGTK::Draw(%p) s=(%4d %4d %4d %4d) d=(%4d %4d %4d %4d)\n",
          this,
          aSX, aSY, aSWidth, aSHeight,
          aDX, aDY, aDWidth, aDHeight);
 #endif
 
@@ -751,45 +773,88 @@
     aDY += (mDecodedY1 - aSY)*dstHeight/srcHeight;
     aSY = mDecodedY1;
   }
 
   if (aDWidth <= 0 || aDHeight <= 0 || aSWidth <= 0 || aSHeight <= 0) {
     return NS_OK;
   }
 
+  // clip to drawing rect
+  float widthScale = srcWidth/dstWidth;
+  float heightScale = srcHeight/dstHeight;
+  if (scale != 1.0f) {
+    if (aDX + aDWidth > (PRInt32)origDWidth) {
+      z = aDX + aDWidth - origDWidth - origDX;
+      aDWidth -= z;
+      aSWidth -= z*widthScale;
+    }
+
+    if (aDX < origDX) {
+      z = aDX - origDX;
+      aDWidth += z;
+      aSWidth += z*widthScale;
+      aSX -= z*widthScale;
+      aDX = origDX;
+    }
+
+    if (aDY + aDHeight > (PRInt32)origDHeight) {
+      z = aDY + aDHeight - origDHeight - origDY;
+      aDHeight -= z;
+      aSHeight -= z*heightScale;
+    }
+
+    if (aDY < origDY) {
+      z = aDY - origDY;
+      aDHeight += z;
+      aSHeight += z*heightScale;
+      aSY -= z*heightScale;
+      aDY = origDY;
+    }
+  }
+
+  if (aDWidth <= 0 || aDHeight <= 0 || aSWidth <= 0 || aSHeight <= 0) {
+    return NS_OK;
+  }
+
   // clip to drawing surface
   nsDrawingSurfaceGTK *drawing = (nsDrawingSurfaceGTK*)aSurface;
   PRUint32 surfaceWidth, surfaceHeight;
   drawing->GetDimensions(&surfaceWidth, &surfaceHeight);
+  origDWidth = surfaceWidth;
+  origDHeight = surfaceHeight;
+  origDX = 0;
+  origDY = 0;
 
-  if (aDX + aDWidth > (PRInt32)surfaceWidth) {
-    z = aDX + aDWidth - surfaceWidth;
+  if (aDX + aDWidth > (PRInt32)origDWidth) {
+    z = aDX + aDWidth - origDWidth - origDX;
     aDWidth -= z;
-    aSWidth -= z*srcWidth/dstWidth;
+    aSWidth -= z*widthScale;
   }
 
-  if (aDX < 0) {
-    aDWidth += aDX;
-    aSWidth += aDX*srcWidth/dstWidth;
-    aSX -= aDX*srcWidth/dstWidth;
-    aDX = 0;
+  if (aDX < origDX) {
+    z = aDX - origDX;
+    aDWidth += z;
+    aSWidth += z*widthScale;
+    aSX -= z*widthScale;
+    aDX = origDX;
   }
 
-  if (aDY + aDHeight > (PRInt32)surfaceHeight) {
-    z = aDY + aDHeight - surfaceHeight;
+  if (aDY + aDHeight > (PRInt32)origDHeight) {
+    z = aDY + aDHeight - origDHeight - origDY;
     aDHeight -= z;
-    aSHeight -= z*srcHeight/dstHeight;
+    aSHeight -= z*heightScale;
   }
 
-  if (aDY < 0) {
-    aDHeight += aDY;
-    aSHeight += aDY*srcHeight/dstHeight;
-    aSY -= aDY*srcHeight/dstHeight;
-    aDY = 0;
+  if (aDY < origDY) {
+    z = aDY - origDY;
+    aDHeight += z;
+    aSHeight += z*heightScale;
+    aSY -= z*heightScale;
+    aDY = origDY;
   }
 
   if (aDWidth <= 0 || aDHeight <= 0 || aSWidth <= 0 || aSHeight <= 0) {
     return NS_OK;
   }
 
   if ((srcWidth != dstWidth) || (srcHeight != dstHeight)) {
     GdkPixmap *pixmap = 0;
Index: mozilla/gfx/src/gtk/nsDeviceContextGTK.h
===================================================================
--- mozilla.orig/gfx/src/gtk/nsDeviceContextGTK.h
+++ mozilla/gfx/src/gtk/nsDeviceContextGTK.h
@@ -85,19 +85,21 @@
 
   NS_IMETHOD GetDepth(PRUint32& aDepth);
 
   NS_IMETHOD ClearCachedSystemFonts();
 
   static int prefChanged(const char *aPref, void *aClosure);
 
   virtual PRBool CheckDPIChange();
+  virtual PRBool SetPixelScale(float aScale);
 
 protected:
   nsresult   SetDPI(PRInt32 aPrefDPI = 96);
+  void UpdateScaledAppUnits();
   
 private:
   PRUint32      mDepth;
   PRBool        mWriteable;
   PRUint32      mNumCells;
   static nscoord mDpi;
 
   float         mWidthFloat;
Index: mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
===================================================================
--- mozilla.orig/gfx/src/gtk/nsRenderingContextGTK.cpp
+++ mozilla/gfx/src/gtk/nsRenderingContextGTK.cpp
@@ -1527,19 +1527,18 @@
                                                    PRUint32 &aWidth)
 {
   return mFontMetrics->GetRangeWidth(aText, aLength, aStart, aEnd, aWidth);
 }
 
 NS_IMETHODIMP nsRenderingContextGTK::DrawImage(imgIContainer *aImage, const nsRect & twSrcRect, const nsRect & twDestRect)
 {
   UpdateGC();
-#define NS_RECT_FROM_TWIPS_RECT2(_r)   (nsRect(FROM_TWIPS_INT2((_r).x), FROM_TWIPS_INT2((_r).y), FROM_TWIPS_INT2((_r).width), FROM_TWIPS_INT2((_r).height)))
-#define NS_RECT_FROM_TWIPS_RECT3(_r)   (nsRect(FROM_TWIPS_INT((_r).x), FROM_TWIPS_INT((_r).y), FROM_TWIPS_INT((_r).width), FROM_TWIPS_INT((_r).height)))
   nsRect aDestRect = NS_RECT_FROM_TWIPS_RECT(twDestRect);
+  #define NS_RECT_FROM_TWIPS_RECT2(_r)   (nsRect(FROM_TWIPS_INT2((_r).x), FROM_TWIPS_INT2((_r).y), FROM_TWIPS_INT2((_r).width), FROM_TWIPS_INT2((_r).height)))
   nsRect aSrcRect = NS_RECT_FROM_TWIPS_RECT2(twSrcRect);
   //1,2,3... Some problems with images... stipes....;
   nsRect dr = aDestRect;
   mTranMatrix->TransformCoord(&dr.x, &dr.y, &dr.width, &dr.height);
 
   // We should NOT be transforming the source rect (which is based on the image
   // origin) using the rendering context's translation!
   // However, given that we are, remember that the transformation of a
Index: mozilla/gfx/src/ps/nsDeviceContextPS.h
===================================================================
--- mozilla.orig/gfx/src/ps/nsDeviceContextPS.h
+++ mozilla/gfx/src/ps/nsDeviceContextPS.h
@@ -96,16 +96,17 @@
   
   NS_IMETHOD  SetSpec(nsIDeviceContextSpec *aSpec);
 
   nsPostScriptObj*    GetPrintContext() { return mPSObj; }
   nsHashtable*        GetPSFontGeneratorList() { return mPSFontGeneratorList; }
   PRBool               mFTPEnable;
 
   PRBool      CheckDPIChange();
+  PRBool      SetPixelScale(float scale);
   NS_IMETHOD  InitForPrinting(nsIDeviceContextSpec *aSpec);
 
 protected:
   virtual     ~nsDeviceContextPS();
   
   nsIDrawingSurface*       mSurface;
   PRUint32               mDepth;
   nsCOMPtr<nsIDeviceContextSpec>  mSpec;
Index: mozilla/gfx/src/ps/nsDeviceContextPS.cpp
===================================================================
--- mozilla.orig/gfx/src/ps/nsDeviceContextPS.cpp
+++ mozilla/gfx/src/ps/nsDeviceContextPS.cpp
@@ -570,8 +570,20 @@
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsDeviceContextPS::InitForPrinting(nsIDeviceContextSpec* spec)
 {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+PRBool nsDeviceContextPS::SetPixelScale(float aScale)
+{
+    if (aScale <= 0) {
+        NS_NOTREACHED("Invalid pixel scale value");
+        return PR_FALSE;
+    }
+    PRInt32 oldAppUnitsPerDevPixel = mAppUnitsPerDevPixel;
+    mPixelScale = aScale;
+    mAppUnitsPerDevPixel = PR_MAX(1, PRInt32(float(mAppUnitsPerDevNotScaledPixel) / mPixelScale));
+    return oldAppUnitsPerDevPixel != mAppUnitsPerDevPixel;
+    return PR_TRUE;
+}
Index: mozilla/layout/generic/nsGfxScrollFrame.cpp
===================================================================
--- mozilla.orig/layout/generic/nsGfxScrollFrame.cpp
+++ mozilla/layout/generic/nsGfxScrollFrame.cpp
@@ -423,16 +423,19 @@
   if (aAssumeVScroll) {
     nsSize vScrollbarPrefSize = 
       mInner.mVScrollbarBox->GetPrefSize(NS_CONST_CAST(nsBoxLayoutState&, 
                                                        aState.mBoxState));
     availWidth = PR_MAX(0, availWidth - vScrollbarPrefSize.width);
   }
   // pixel align the content
   nsPresContext* presContext = PresContext();
+  if (presContext->TrueZoomMode() && aFirstPass) {
+    availWidth = availWidth * presContext->GetFullZoom();
+  }
   nscoord twp = nsPresContext::CSSPixelsToAppUnits(1);
   availWidth -=  availWidth % twp;
 
   if (!aFirstPass)
     mInner.mScrolledFrame->AddStateBits(NS_FRAME_IS_DIRTY);
 
   // We're forcing the padding on our scrolled frame, so let it know what that
   // padding is.
@@ -1419,20 +1422,25 @@
   }
 
   if (mIsRoot) {
     result = presContext->GetViewportOverflowOverride();
 
     nsCOMPtr<nsISupports> container = presContext->GetContainer();
     nsCOMPtr<nsIScrollable> scrollable = do_QueryInterface(container);
     if (scrollable) {
+      if (presContext->TrueZoomMode()) {
+        result.mHorizontal = NS_STYLE_OVERFLOW_AUTO;
+        result.mVertical = NS_STYLE_OVERFLOW_AUTO;
+      } else {
       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_X,
                        result.mHorizontal);
       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_Y,
                        result.mVertical);
+      }
     }
   } else {
     const nsStyleDisplay *disp = mOuter->GetStyleDisplay();
     result.mHorizontal = disp->mOverflowX;
     result.mVertical = disp->mOverflowY;
   }
 
   NS_ASSERTION(result.mHorizontal != NS_STYLE_OVERFLOW_VISIBLE &&
Index: mozilla/gfx/public/nsIFontMetrics.h
===================================================================
--- mozilla.orig/gfx/public/nsIFontMetrics.h
+++ mozilla/gfx/public/nsIFontMetrics.h
@@ -228,16 +228,21 @@
    */
   NS_IMETHOD  GetAveCharWidth(nscoord& aAveCharWidth) = 0;
 
   /**
    * Returns the often needed width of the space character
    */
   NS_IMETHOD  GetSpaceWidth(nscoord& aSpaceCharWidth) = 0;
 
+  /**
+   * DPI Value
+   */
+  PRInt32 mP2A;
+
 protected:
 
   nsFont mFont;		// The font for this metrics object.
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIFontMetrics, NS_IFONT_METRICS_IID)
 
 #endif /* nsIFontMetrics_h___ */
