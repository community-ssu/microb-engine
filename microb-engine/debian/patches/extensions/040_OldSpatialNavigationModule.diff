Index: mozilla/extensions/spatialnavigation/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/Makefile.in
@@ -0,0 +1,37 @@
+
+DEPTH=../..
+topsrcdir=@top_srcdir@
+srcdir=@srcdir@
+VPATH=@srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE	= snav
+#XPI_NAME = snav
+
+ifdef MOZ_XUL_APP
+#INSTALL_EXTENSION_ID = snav@extensions.mozilla.org
+#DIST_FILES = install.rdf
+#NO_JAR_AUTO_REG        = 1
+#USE_EXTENSION_MANIFEST = 1
+#XPI_PKGNAME            = snav-$(MOZ_APP_VERSION)
+
+# We should really pull FIREFOX_VERSION and THUNDERBIRD_VERSION from
+# browser/config/version.txt mail/config/version.txt but we can't be assured
+# that we've even pulled those files. So we hardcode them.
+
+XULAPP_DEFINES = \
+	-DFIREFOX_VERSION=$(FIREFOX_VERSION) \
+	-DTHUNDERBIRD_VERSION=$(THUNDERBIRD_VERSION) \
+	-DEXTENSION_VERSION=$(MOZILLA_VERSION) \
+	$(NULL)
+
+ifdef TARGET_XPCOM_ABI
+XULAPP_DEFINES += -DEM_ABI=$(OS_TARGET)_$(TARGET_XPCOM_ABI)
+endif
+endif
+
+DIRS    = src
+DIRS   += public
+
+include $(topsrcdir)/config/rules.mk
Index: mozilla/extensions/spatialnavigation/install.rdf
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/install.rdf
@@ -0,0 +1,40 @@
+<?xml version="1.0"?>
+
+#filter substitution
+
+<RDF xmlns="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+     xmlns:em="http://www.mozilla.org/2004/em-rdf#">
+  <Description about="urn:mozilla:install-manifest">
+    <em:id>fit-to-view@extensions.mozilla.org</em:id>
+    <em:version>@EXTENSION_VERSION@</em:version>
+
+#ifdef EM_ABI
+    <em:targetPlatform>@EM_ABI@</em:targetPlatform>
+#endif
+
+    <em:targetApplication>
+      <!-- Firefox -->
+      <Description>
+        <em:id>{ec8030f7-c20a-464f-9b0e-13a3a9e97384}</em:id>
+        <em:minVersion>@FIREFOX_VERSION@</em:minVersion>
+        <em:maxVersion>@FIREFOX_VERSION@</em:maxVersion>
+      </Description>
+    </em:targetApplication>
+
+    <em:targetApplication>
+      <!-- Thunderbird -->
+      <Description>
+        <em:id>{3550f703-e582-4d05-9a08-453d09bdfdc6}</em:id>
+        <em:minVersion>@THUNDERBIRD_VERSION@</em:minVersion>
+        <em:maxVersion>@THUNDERBIRD_VERSION@</em:maxVersion>
+      </Description>
+    </em:targetApplication>
+
+    <!-- front-end metadata -->
+    <em:name>Spatial Navigation</em:name>
+    <em:description>Navigate between links using the arrow keys in addition to the tab key.</em:description>
+    <em:creator>mozilla.org</em:creator>
+    <em:contributor>Doug Turner &lt;dougt@meer.net&gt;</em:contributor>
+    <em:homepageURL>http://www.mozilla.org/access/keyboard/snav/</em:homepageURL>
+  </Description>
+</RDF>
Index: mozilla/extensions/spatialnavigation/public/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/public/Makefile.in
@@ -0,0 +1,49 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Spatial Navigation
+#
+# The Initial Developer of the Original Code is
+# Douglas F. Turner II
+# Portions created by the Initial Developer are Copyright (C) 2004
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH=../../..
+topsrcdir=@top_srcdir@
+srcdir=@srcdir@
+VPATH=@srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE=snav
+
+XPIDLSRCS = nsISpatialNavigation.idl
+
+include $(topsrcdir)/config/rules.mk
+
Index: mozilla/extensions/spatialnavigation/public/nsISpatialNavigation.idl
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/public/nsISpatialNavigation.idl
@@ -0,0 +1,54 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Spatial Navigation
+ *
+ * The Initial Developer of the Original Code is
+ * Douglas F. Turner II
+ * Portions created by the Initial Developer are Copyright (C) 2004
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIDOMWindow;
+
+[scriptable, uuid(ef7cb437-9eb3-47c7-9d89-71679bfefcc1)]
+interface nsISpatialNavigation: nsISupports
+{
+  void init(in nsIDOMWindow aWindow);
+  void shutdown();
+
+  void up();
+  void down();
+  void left();
+  void right();
+
+  readonly attribute nsIDOMWindow attachedWindow;
+};
Index: mozilla/extensions/spatialnavigation/src/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/src/Makefile.in
@@ -0,0 +1,109 @@
+# vim:set ts=8 sw=8 sts=8 noet:
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is the Mozilla Browser code.
+#
+# The Initial Developer of the Original Code is Google Inc.
+# Portions created by the Initial Developer are Copyright (C) 2005
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Darin Fisher <darin@meer.net>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= snav
+LIBRARY_NAME    = snav
+ifneq ($(OS_ARCH),WINNT)
+SHORT_LIBNAME = snav
+endif
+FORCE_SHARED_LIB = 1
+IS_COMPONENT = 1
+
+REQUIRES = \
+	xpcom \
+	string \
+	pref \
+	js \
+	dom \
+	dom_base \
+	gfx \
+	thebes \
+	layout \
+	content \
+	widget \
+	locale \
+	necko \
+	docshell \
+	unicharutil \
+	view \
+	webshell \
+	windowwatcher \
+	webbrwsr \
+	 $(NULL)
+
+CPPSRCS  = \
+	nsRect.cpp \
+	nsSpatialNavigation.cpp \
+	nsSpatialNavigationUtils.cpp \
+	nsSpatialNavigationService.cpp \
+	$(NULL)
+
+
+EXTRA_DSO_LDOPTS = \
+	$(XPCOM_GLUE_LDOPTS) \
+	$(NSPR_LIBS) \
+	$(NULL)
+
+EXTRA_DSO_LDOPTS += $(MOZ_COMPONENT_LIBS)
+
+EXPORT_RESOURCE = \
+	$(NULL)
+
+
+ifdef MOZ_XUL_APP
+ifdef TARGET_XPCOM_ABI
+FINAL_TARGET=$(DIST)/xpi-stage/$(XPI_NAME)/platform/$(OS_TARGET)_$(TARGET_XPCOM_ABI)
+endif
+endif
+
+DEFINES += -D_IMPL_NS_GFX
+
+#EXTRA_COMPONENTS = $(srcdir)/SimpleTest.js
+
+include $(topsrcdir)/config/rules.mk
+
+ifdef GNU_CC
+CFLAGS   += -fno-unit-at-a-time
+CXXFLAGS += -fno-unit-at-a-time
+endif
Index: mozilla/extensions/spatialnavigation/src/nsRect.cpp
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/src/nsRect.cpp
@@ -0,0 +1,186 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ * Netscape Communications Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsRect.h"
+#include "nsStringGlue.h"
+#include "nsIDeviceContext.h"
+
+// Containment
+PRBool nsRect::Contains(nscoord aX, nscoord aY) const
+{
+  return (PRBool) ((aX >= x) && (aY >= y) &&
+                   (aX < XMost()) && (aY < YMost()));
+}
+
+//Also Returns true if aRect is Empty
+PRBool nsRect::Contains(const nsRect &aRect) const
+{
+  return aRect.IsEmpty() ||
+          ((PRBool) ((aRect.x >= x) && (aRect.y >= y) &&
+                    (aRect.XMost() <= XMost()) && (aRect.YMost() <= YMost())));
+}
+
+// Intersection. Returns TRUE if the receiver overlaps aRect and
+// FALSE otherwise
+PRBool nsRect::Intersects(const nsRect &aRect) const
+{
+  return (PRBool) ((x < aRect.XMost()) && (y < aRect.YMost()) &&
+                   (aRect.x < XMost()) && (aRect.y < YMost()));
+}
+
+// Computes the area in which aRect1 and aRect2 overlap and fills 'this' with
+// the result. Returns FALSE if the rectangles don't intersect.
+PRBool nsRect::IntersectRect(const nsRect &aRect1, const nsRect &aRect2)
+{
+  nscoord  xmost1 = aRect1.XMost();
+  nscoord  ymost1 = aRect1.YMost();
+  nscoord  xmost2 = aRect2.XMost();
+  nscoord  ymost2 = aRect2.YMost();
+  nscoord  temp;
+
+  x = PR_MAX(aRect1.x, aRect2.x);
+  y = PR_MAX(aRect1.y, aRect2.y);
+
+  // Compute the destination width
+  temp = PR_MIN(xmost1, xmost2);
+  if (temp <= x) {
+    Empty();
+    return PR_FALSE;
+  }
+  width = temp - x;
+
+  // Compute the destination height
+  temp = PR_MIN(ymost1, ymost2);
+  if (temp <= y) {
+    Empty();
+    return PR_FALSE;
+  }
+  height = temp - y;
+
+  return PR_TRUE;
+}
+
+// Computes the smallest rectangle that contains both aRect1 and aRect2 and
+// fills 'this' with the result. Returns FALSE if both aRect1 and aRect2 are
+// empty and TRUE otherwise
+PRBool nsRect::UnionRect(const nsRect &aRect1, const nsRect &aRect2)
+{
+  PRBool  result = PR_TRUE;
+
+  // Is aRect1 empty?
+  if (aRect1.IsEmpty()) {
+    if (aRect2.IsEmpty()) {
+      // Both rectangles are empty which is an error
+      Empty();
+      result = PR_FALSE;
+    } else {
+      // aRect1 is empty so set the result to aRect2
+      *this = aRect2;
+    }
+  } else if (aRect2.IsEmpty()) {
+    // aRect2 is empty so set the result to aRect1
+    *this = aRect1;
+  } else {
+    UnionRectIncludeEmpty(aRect1, aRect2);
+  }
+
+  return result;
+}
+
+void nsRect::UnionRectIncludeEmpty(const nsRect &aRect1, const nsRect &aRect2)
+{
+  nscoord xmost1 = aRect1.XMost();
+  nscoord xmost2 = aRect2.XMost();
+  nscoord ymost1 = aRect1.YMost();
+  nscoord ymost2 = aRect2.YMost();
+
+  // Compute the origin
+  x = PR_MIN(aRect1.x, aRect2.x);
+  y = PR_MIN(aRect1.y, aRect2.y);
+
+  // Compute the size
+  width = PR_MAX(xmost1, xmost2) - x;
+  height = PR_MAX(ymost1, ymost2) - y;
+}
+
+// Inflate the rect by the specified width and height
+void nsRect::Inflate(nscoord aDx, nscoord aDy)
+{
+  x -= aDx;
+  y -= aDy;
+  width += 2 * aDx;
+  height += 2 * aDy;
+}
+
+// Inflate the rect by the specified margin
+void nsRect::Inflate(const nsMargin &aMargin)
+{
+  x -= aMargin.left;
+  y -= aMargin.top;
+  width += aMargin.left + aMargin.right;
+  height += aMargin.top + aMargin.bottom;
+}
+
+// Deflate the rect by the specified width and height
+void nsRect::Deflate(nscoord aDx, nscoord aDy)
+{
+  x += aDx;
+  y += aDy;
+  width = PR_MAX(0, width - 2 * aDx);
+  height = PR_MAX(0, height - 2 * aDy);
+}
+
+// Deflate the rect by the specified margin
+void nsRect::Deflate(const nsMargin &aMargin)
+{
+  x += aMargin.left;
+  y += aMargin.top;
+  width = PR_MAX(0, width - aMargin.LeftRight());
+  height = PR_MAX(0, height - aMargin.TopBottom());
+}
+
+// scale the rect but round to smallest containing rect
+nsRect& nsRect::ScaleRoundOut(float aScale)
+{
+  nscoord right = NSToCoordCeil(float(XMost()) * aScale);
+  nscoord bottom = NSToCoordCeil(float(YMost()) * aScale);
+  x = NSToCoordFloor(float(x) * aScale);
+  y = NSToCoordFloor(float(y) * aScale);
+  width = (right - x);
+  height = (bottom - y);
+  return *this;
+}
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigation.cpp
@@ -0,0 +1,1373 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Spatial Navigation
+ *
+ * The Initial Developer of the Original Code is
+ * Douglas F. Turner II  <dougt@meer.net>
+ * Portions created by the Initial Developer are Copyright (C) 2004-2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSpatialNavigationPrivate.h"
+#include "nsGUIEvent.h"
+#include "nsIDOMHTMLImageElement.h"
+#include "nsIDOMNSHTMLAnchorElement.h"
+
+// #define DEBUG_romaxa 1
+
+PRInt32 gRectFudge = 1;
+PRInt32 gRectFudgeY = 1;
+
+PRInt32 gDirectionalBias = 1;
+
+NS_INTERFACE_MAP_BEGIN(nsSpatialNavigation)
+  NS_INTERFACE_MAP_ENTRY(nsISpatialNavigation)
+  NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMKeyListener)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(nsSpatialNavigation)
+NS_IMPL_RELEASE(nsSpatialNavigation)
+
+
+nsSpatialNavigation::nsSpatialNavigation(nsSpatialNavigationService* aService)
+{
+  NS_ASSERTION(aService, "Should not create this object without a valid service");
+
+  mService = aService; // back pointer -- no reference
+
+  mNavigationFramesState = PR_FALSE;
+  mKeyPressedState = 0;
+  mKeyWasDown = PR_FALSE;
+  mSelectPopup = PR_FALSE;
+  mSelectPopupCount = 0;
+  mSelectMultiCount = 0;
+  mSelectControlSelected = PR_FALSE;
+  mSelectNavCount = 0;
+}
+
+// #ifdef DEBUG_romaxa
+nsresult debug_content(nsISupports *content)
+{
+  nsresult rv;
+  nsCOMPtr<nsIDOMNode> node;
+  node = do_QueryInterface(content, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  // nsRect rect = makeRectRelativeToGlobalView(node);
+  nsString str;
+  node->GetNodeName(str);
+
+/*******************************************
+  printf("DBG:N:'%s', rect[%i,%i,%i,%i]",
+          NS_ConvertUTF16toUTF8(str).get(),
+          rect.x,rect.y,rect.width,rect.height);
+*******************************************/
+
+
+  nsCOMPtr<nsIDOMHTMLAnchorElement> link(do_QueryInterface(content));
+  if (link)
+  {
+    nsCOMPtr<nsIDOMNSHTMLAnchorElement> nslink(do_QueryInterface(link));
+
+    nsAutoString text;
+    if (nslink) nslink->GetText(text);
+
+    nsAutoString href;
+    link->GetHref(href);
+    printf("<%s href=\"%s\">%s</a>\n", NS_ConvertUTF16toUTF8(str).get(), NS_ConvertUTF16toUTF8(href).get(), NS_ConvertUTF16toUTF8(text).get());
+  }
+    else
+  {
+    nsCOMPtr<nsIDOMHTMLInputElement> inputEl(do_QueryInterface(content));
+
+    // printf("inputEl (%p)\n", (void*) inputEl);
+
+    if (inputEl)
+    {
+      nsAutoString name, type, value;
+
+      inputEl->GetName(name);
+      inputEl->GetType(type);
+      inputEl->GetValue(value);
+
+      printf("<%s name=\"%s\" type=\"%s\" value=\"%s\">\n", NS_ConvertUTF16toUTF8(str).get(),
+                                               NS_ConvertUTF16toUTF8(name).get(),
+                                               NS_ConvertUTF16toUTF8(type).get(),
+                                               NS_ConvertUTF16toUTF8(value).get());
+    }
+      else
+    {
+      printf("<%s>\n", NS_ConvertUTF16toUTF8(str).get());
+    }
+  }
+
+/*
+  nsCOMPtr<nsIDOMNSHTMLElement> nselem;
+  nselem = do_QueryInterface(content, &rv);
+  if (nselem) {
+    PRInt32 st,sl,ct,cl,ot,ol;
+    nselem->GetScrollTop(&st);
+    nselem->GetScrollLeft(&sl);
+    nselem->GetClientTop(&ct);
+    nselem->GetClientLeft(&cl);
+    nselem->GetOffsetTop(&ot);
+    nselem->GetOffsetLeft(&ol);
+    printf(" st:%i,sl:%i,ct:%i,cl:%i,ot:%i,ol%i ", st,sl,ct,cl,ot,ol);
+  }
+*/
+  printf("\n");
+}
+// #endif
+
+nsSpatialNavigation::~nsSpatialNavigation()
+{
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::Up()
+{
+  return handleMove(eNavUp);
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::Down()
+{
+  return handleMove(eNavDown);
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::Left()
+{
+  return handleMove(eNavLeft);
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::Right()
+{
+  return handleMove(eNavRight);
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::KeyDown(nsIDOMEvent* aEvent)
+{
+  mKeyWasDown = PR_TRUE;
+  mKeyPressedCount = 0;
+
+  if (!mService->mEnabled) return NS_OK;
+
+/****************
+  // if (!mKeyPressedState)
+  {
+    aEvent->StopPropagation();
+    aEvent->PreventDefault();
+  }
+****************/
+
+  return HandleKey(aEvent, PR_FALSE);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::KeyPress(nsIDOMEvent* aEvent)
+{
+  if (!mService->mEnabled) return NS_OK;
+
+  mKeyPressedCount++;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::KeyUp(nsIDOMEvent* aEvent)
+{
+  if (mSelectPopupCount == 1)
+  {
+    mSelectPopupCount = 0;;
+    return NS_OK;
+  }
+
+  if (!mService->mEnabled)
+  {
+    mKeyWasDown = PR_FALSE;
+    return NS_OK;
+  }
+
+  if (mKeyPressedCount > 1)
+  {
+    if (mKeyPressedState == 0) mKeyPressedState = 1;
+
+    mKeyPressedCount = 0;
+    mKeyWasDown = PR_FALSE;
+
+    return NS_OK;
+  }
+
+  mKeyPressedCount = 0;
+  nsresult rv = HandleKey(aEvent, PR_TRUE);
+  mKeyWasDown = PR_FALSE;
+
+  return rv;
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::HandleEvent(nsIDOMEvent* aEvent)
+{
+  return NS_OK;
+}
+
+nsresult
+nsSpatialNavigation::HandleKey(nsIDOMEvent* aEvent, PRBool aReal)
+{
+  nsCOMPtr<nsIDOMNSUIEvent> uiEvent(do_QueryInterface(aEvent));
+  if (uiEvent)
+  {
+    // If a web page wants to use the keys mapped to our
+    // move, they have to use evt.preventDefault() after
+    // they get the key
+
+    PRBool preventDefault;
+    uiEvent->GetPreventDefault(&preventDefault);
+    if (preventDefault)
+      return NS_OK;
+  }
+
+  PRInt32 formControlType = -1;
+  // check to see if we are in a text field.
+  // based on nsTypeAheadFind.
+
+  //nsEvent should be renamed.
+  nsCOMPtr<nsIDOMNSEvent> nsEvent = do_QueryInterface(aEvent);
+  if (!nsEvent)
+    return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsIDOMEventTarget> domEventTarget;
+  nsEvent->GetOriginalTarget(getter_AddRefs(domEventTarget));
+
+  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(domEventTarget);
+
+  if (targetContent->IsNodeOfType(nsINode::eXUL))
+    return NS_OK;
+
+  PRBool designMode = PR_FALSE;
+  nsCOMPtr<nsIDOMNode> eventNode = do_QueryInterface(domEventTarget);
+  nsCOMPtr<nsIDOMDocument> domDoc;
+  if (eventNode)
+    eventNode->GetOwnerDocument(getter_AddRefs(domDoc));
+  nsCOMPtr<nsIDOMNSHTMLDocument> htmlDoc = do_QueryInterface(domDoc);
+  if (htmlDoc) {
+    nsString DMode;
+    htmlDoc->GetDesignMode(DMode);
+    designMode = DMode.EqualsLiteral("on");
+    if (designMode) return NS_OK;
+  }
+
+  if (targetContent->IsNodeOfType(nsINode::eHTML_FORM_CONTROL))
+  {
+      nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(targetContent));
+      formControlType = formControl->GetType();
+
+      if (mService->mIgnoreTextFields)
+      {
+        if (formControlType == NS_FORM_TEXTAREA ||
+            formControlType == NS_FORM_INPUT_TEXT ||
+            formControlType == NS_FORM_INPUT_PASSWORD ||
+            formControlType == NS_FORM_INPUT_FILE)
+        {
+          return NS_OK;
+        }
+      }
+
+      if (formControlType == NS_FORM_SELECT)
+      {
+        if (!mSelectControlSelected)
+        {
+          aEvent->StopPropagation();
+          aEvent->PreventDefault();
+        }
+
+        PRUint32 keyCode;
+        nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aEvent));
+
+        if (!keyEvent) return NS_ERROR_FAILURE;
+
+        if (NS_FAILED(keyEvent->GetKeyCode(&keyCode)))
+          return NS_ERROR_FAILURE;
+
+
+        nsCOMPtr<nsIDOMHTMLSelectElement> element = do_QueryInterface(mLastContent);
+        if (element)
+        {
+          PRBool isMultiple = PR_FALSE;
+          element->GetMultiple(&isMultiple);
+
+          PRInt32 size  = 0;
+          PRUint32 len  = 0;
+          PRInt32 index = 0;
+
+          element->GetSize(&size);
+          element->GetLength(&len);
+          element->GetSelectedIndex(&index);
+
+          if (keyCode == nsIDOMKeyEvent::DOM_VK_RETURN)
+          {
+            if (isMultiple && !mSelectControlSelected)
+            {
+              element->SetSelectedIndex(0);
+              mSelectMultiCount = 0;
+            }
+
+            mSelectControlSelected = isMultiple ? PR_TRUE : !mSelectControlSelected;
+
+            if (size < 2)
+            {
+              mSelectPopup = !mSelectPopup;
+              ++mSelectPopupCount;
+            }
+          }
+
+          if (mSelectControlSelected && isMultiple)
+          {
+            if (keyCode == nsIDOMKeyEvent::DOM_VK_DOWN) ++mSelectMultiCount;
+            if (keyCode == nsIDOMKeyEvent::DOM_VK_UP) --mSelectMultiCount;
+
+            if (mSelectMultiCount >= 0 && mSelectMultiCount <= len)
+            {
+              return NS_OK;
+            }
+              else
+            {
+              if (mSelectMultiCount < 0) mSelectMultiCount = 0;
+              if (mSelectMultiCount > (PRInt32)len) mSelectMultiCount = len;
+
+              mSelectControlSelected = PR_FALSE;
+            }
+          }
+            else
+          {
+            if (mSelectPopup)
+            {
+              aEvent->StopPropagation();
+              aEvent->PreventDefault();
+
+              return NS_OK;
+            }
+
+            if (mSelectControlSelected)
+            {
+              if (mSelectNavCount == len || mSelectNavCount < 0)
+              {
+                mSelectControlSelected = PR_FALSE;
+                mSelectNavCount = 0;
+              }
+                else if (!mSelectPopup)
+              {
+                if (keyCode == nsIDOMKeyEvent::DOM_VK_DOWN) ++mSelectNavCount;
+
+                if (keyCode == nsIDOMKeyEvent::DOM_VK_UP) --mSelectNavCount;
+
+                element->SetSelectedIndex(mSelectNavCount);
+
+                return NS_OK;
+              }
+            }
+              else if (size > 1 && index < 0 && !mSelectControlSelected)
+            {
+              element->SetSelectedIndex(-1);
+            }
+          }
+        }
+      }
+  }
+  else if (mService->mIgnoreTextFields && targetContent->IsNodeOfType(nsINode::eHTML))
+  {
+    // Test for isindex, a deprecated kind of text field. We're using a string
+    // compare because <isindex> is not considered a form control, so it does
+    // not support nsIFormControl or eHTML_FORM_CONTROL, and it's not worth
+    // having a table of atoms just for it.
+
+      if (isContentOfType(targetContent, "isindex"))
+        return NS_OK;
+  }
+
+  PRUint32 keyCode;
+  PRBool isModifier;
+  nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aEvent));
+
+  if (!keyEvent)
+    return NS_ERROR_FAILURE;
+
+  if (NS_FAILED(keyEvent->GetKeyCode(&keyCode)))
+  return NS_ERROR_FAILURE;
+
+  if (keyCode == nsIDOMKeyEvent::DOM_VK_RETURN && !aReal && formControlType != NS_FORM_TEXTAREA) {
+    nsCOMPtr<nsIContent> focusedContent;
+    getFocusedContent(0, getter_AddRefs(focusedContent));
+    if (focusedContent && !isContentInsideWindow(focusedContent, mTopWindow)) {
+      nsCOMPtr<nsIDOMNSHTMLElement> nsElement = do_QueryInterface(focusedContent);
+      if (nsElement) {
+        nsElement->Blur();
+        return NS_OK;
+      }
+    }
+  }
+
+  // figure out what modifier to use
+
+  /************************************************
+    Value of the keyCodeModifier is
+
+    SHIFT          = 0x00100000
+    CONTROL        = 0x00001100
+    ALT            = 0x00000012
+  *************************************************/
+
+
+  if (mService->mKeyCodeModifier & 0x00100000)
+  {
+    if (NS_FAILED(keyEvent->GetShiftKey(&isModifier)))
+      return NS_ERROR_FAILURE;
+    if (!isModifier)
+      return NS_OK;
+  }
+
+  if (mService->mKeyCodeModifier & 0x00001100)
+  {
+    if (NS_FAILED(keyEvent->GetCtrlKey(&isModifier)))
+      return NS_ERROR_FAILURE;
+    if (!isModifier)
+      return NS_OK;
+  }
+
+  if (mService->mKeyCodeModifier & 0x00000012)
+  {
+    if (NS_FAILED(keyEvent->GetAltKey(&isModifier)))
+      return NS_ERROR_FAILURE;
+    if (!isModifier)
+      return NS_OK;
+  }
+
+  if (keyCode == mService->mKeyCodeLeft)
+  {
+    //************************************************************************************
+    // NS_FORM_TEXTAREA & (NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE) cases
+
+    PRInt32 selectionStart = 0, textLength = 0;
+    if (formControlType == NS_FORM_INPUT_TEXT ||
+        formControlType == NS_FORM_INPUT_PASSWORD ||
+        formControlType == NS_FORM_INPUT_FILE)
+    {
+      nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(targetContent);
+      if (input) {
+        input->GetSelectionStart (&selectionStart);
+        input->GetTextLength (&textLength);
+      }
+    } else if (formControlType == NS_FORM_TEXTAREA) {
+
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionStart (&selectionStart);
+        textArea->GetTextLength (&textLength);
+      }
+    }
+
+    if (textLength != 0 && selectionStart != 0)
+      return NS_OK;
+
+    // We're using this key, no one else should
+    aEvent->StopPropagation();
+    aEvent->PreventDefault();
+    return aReal?Left():NS_OK;
+  }
+
+  if (keyCode == mService->mKeyCodeRight)
+  {
+    //************************************************************************************
+    // NS_FORM_TEXTAREA & (NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE) cases
+
+    PRInt32 selectionEnd = 0, textLength = 0;
+
+    if (formControlType == NS_FORM_INPUT_TEXT ||
+        formControlType == NS_FORM_INPUT_PASSWORD ||
+        formControlType == NS_FORM_INPUT_FILE)
+    {
+      nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(targetContent);
+      if (input) {
+        input->GetSelectionEnd (&selectionEnd);
+        input->GetTextLength (&textLength);
+      }
+    } else if (formControlType == NS_FORM_TEXTAREA) {
+
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionEnd (&selectionEnd);
+        textArea->GetTextLength (&textLength);
+      }
+    }
+
+    if (textLength  != selectionEnd)
+      return NS_OK;
+
+    aEvent->StopPropagation();
+    aEvent->PreventDefault();
+    return aReal?Right():NS_OK;
+  }
+
+  if (keyCode == mService->mKeyCodeUp)
+  {
+
+    // If we are going up or down, in a select, lets not
+    // navigate.
+    //
+    // FIX: What we really want to do is determine if we are
+    // at the start or the end fo the form element, and
+    // based on the selected position we decide to nav. or
+    // not.
+
+    // ************************************************************************************
+    // NS_FORM_SELECT cases:
+    // * if it is a select form of 'size' attr != than '1' then we do as above.
+
+    // * if it is a select form of 'size' attr == than '1', snav can take care of it.
+    // if (formControlType == NS_FORM_SELECT)
+    //   return NS_OK;
+
+    //************************************************************************************
+    // NS_FORM_TEXTAREA & (NS_FORM_INPUT_TEXT | NS_FORM_INPUT_PASSWORD | NS_FORM_INPUT_FILE) cases
+
+    if (formControlType == NS_FORM_TEXTAREA) {
+
+      PRInt32 selectionStart = 0, textLength = 0;
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionStart (&selectionStart);
+        textArea->GetTextLength (&textLength);
+      }
+
+      if (textLength != 0 && selectionStart != 0)
+      {
+        printf("RETURNING ...\n");
+        // return NS_OK;
+      }
+    }
+
+    // We're using this key, no one else should
+    aEvent->StopPropagation();
+    aEvent->PreventDefault();
+    return aReal?Up():NS_OK;
+  }
+
+  if (keyCode == mService->mKeyCodeDown)
+  {
+    // If we are going up or down, in a select, lets not
+    // navigate.
+    //
+    // FIX: What we really want to do is determine if we are
+    // at the start or the end fo the form element, and
+    // based on the selected position we decide to nav. or
+    // not.
+
+    // ************************************************************************************
+    // NS_FORM_SELECT cases:
+    // * if it is a select form of 'size' attr != than '1' then we do as above.
+
+    // * if it is a select form of 'size' attr == than '1', snav can take care of it.
+    // if (formControlType == NS_FORM_SELECT)
+    //   return NS_OK;
+
+    if (formControlType == NS_FORM_TEXTAREA) {
+
+      PRInt32 selectionEnd = 0, textLength = 0;
+      nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea = do_QueryInterface(targetContent);
+      if (textArea) {
+        textArea->GetSelectionEnd (&selectionEnd);
+        textArea->GetTextLength (&textLength);
+      }
+
+      if (textLength  != selectionEnd)
+      {
+        printf("RETURNING ...\n");
+        // return NS_OK;
+      }
+    }
+
+    aEvent->StopPropagation();  // We're using this key, no one else should
+    aEvent->PreventDefault();
+    return aReal?Down():NS_OK;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::Init(nsIDOMWindow *aWindow)
+{
+  mTopWindow = aWindow;
+
+  nsCOMPtr<nsIDOM3EventTarget> target;
+  nsCOMPtr<nsIDOMEventGroup> systemGroup;
+  nsresult rv = getEventTargetFromWindow(aWindow, getter_AddRefs(target), getter_AddRefs(systemGroup));
+  if (NS_FAILED(rv))
+    return rv;
+
+  target->AddGroupedEventListener(NS_LITERAL_STRING("keypress"),
+                                  static_cast<nsIDOMKeyListener*>(this),
+                                  PR_FALSE,
+                                  systemGroup);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::Shutdown()
+{
+  nsCOMPtr<nsIDOM3EventTarget> target;
+  nsCOMPtr<nsIDOMEventGroup> systemGroup;
+  nsresult rv = getEventTargetFromWindow(mTopWindow, getter_AddRefs(target), getter_AddRefs(systemGroup));
+  if (NS_FAILED(rv))
+    return rv;
+
+  target->RemoveGroupedEventListener(NS_LITERAL_STRING("keypress"),
+                                     static_cast<nsIDOMKeyListener*>(this),
+                                     PR_FALSE,
+                                     systemGroup);
+  mTopWindow = nsnull;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSpatialNavigation::GetAttachedWindow(nsIDOMWindow * *aAttachedWindow)
+{
+  NS_IF_ADDREF(*aAttachedWindow = mTopWindow);
+  return NS_OK;
+}
+
+void DoTraversal(int aDirection,
+                 nsIFrameEnumerator* aFrameTraversal,
+                 nsIFrame* aFocusedFrame,
+                 nsRect& aFocusedRect,
+                 PRBool isAREA,
+                 PRBool focusDocuments,
+                 nsPresContext* aPresContext,
+                 PRInt64* aDSoFar,
+                 nsIContent** aCurrentContent)
+{
+
+  PRInt64 precedentDistance = LL_MaxInt();
+  *aCurrentContent = nsnull;
+
+  // There are some rects with zero width or height.
+  // calculating distance from a non point is troublesome.
+  // we will fix this up here by setting such a point to at
+  // least 1 px.
+
+  // printf("aFocusedRect.width(%d), aFocusedRect.height(%d)\n", aFocusedRect.width, aFocusedRect.height);
+
+  if (aFocusedRect.width == 0) {
+    // printf("FOCUSED RECT WIDTH IS ZERO !!!!!\n");
+    aFocusedRect.width = 1;
+  }
+
+  if (aFocusedRect.height == 0) {
+    // printf("FOCUSED RECT HEIGHT IS ZERO !!!!!\n");
+    aFocusedRect.height = 1;
+  }
+
+  nsIFrame* frame;
+  nsRect frameRect;
+
+  PRInt64 d;
+  PRBool superPrecedent = PR_FALSE;
+  PRBool precedent = PR_FALSE;
+
+  do
+  {
+    aFrameTraversal->Next();
+
+    frame = aFrameTraversal->CurrentItem();
+    if (!frame)
+      break;
+#ifdef DEBUG_outputframes
+    printf("got frame %x\n", frame);
+#endif
+    // So, here we want to make sure that the frame that we
+    // nav to isn't part of the flow of the currently
+    // focused frame
+
+  if (!isAREA)
+    {
+      nsIFrame* flowFrame = aFocusedFrame;
+      PRBool currentFrameIsFocusedFrame = PR_FALSE;
+      while (flowFrame)
+      {
+        if (flowFrame == frame)
+        {
+          currentFrameIsFocusedFrame = PR_TRUE;
+          break;
+        }
+        flowFrame = flowFrame->GetNextInFlow();
+      }
+      if (currentFrameIsFocusedFrame)
+        continue;
+  }
+
+    ////////////////////////////////////////////////////////////////////////////////////
+    // a special case for area's which are not enumerated by the nsIFrameTraversal
+    ////////////////////////////////////////////////////////////////////////////////////
+    if (isMap(frame))
+    {
+      nsIContent* c = frame->GetContent();
+      nsCOMPtr<nsIDOMHTMLMapElement> element = do_QueryInterface(c);
+      if (!element)
+        continue;
+
+      nsCOMPtr<nsIDOMHTMLCollection> mapAreas;
+      element->GetAreas(getter_AddRefs(mapAreas));
+      if (!mapAreas)
+        continue;
+
+      PRUint32 length;
+      mapAreas->GetLength(&length);
+
+      for (PRUint32 i = 0; i < length; i++)
+      {
+        nsCOMPtr<nsIDOMNode> domNode;
+        mapAreas->Item(i,getter_AddRefs(domNode));
+
+        nsCOMPtr<nsIDOMHTMLAreaElement> e = do_QueryInterface(domNode);
+        nsCOMPtr<nsIContent> content= do_QueryInterface(domNode);
+        getFrameForContent(content, &frame);
+
+        getRectOfAreaElement(frame, e, &frameRect);
+
+        if (!isRectInDirection(aDirection, aFocusedRect, frameRect))
+          continue;
+
+        d = spatialDistance(aDirection, aFocusedRect, frameRect);
+
+        if ((*aDSoFar) > d)
+        {
+          (*aDSoFar) = d;
+          NS_IF_RELEASE(*aCurrentContent);
+          NS_ADDREF(*aCurrentContent = content);
+        }
+      }
+      continue;
+    }
+    ////////////////////////////////////////////////////////////////////////////////////
+
+    // we don't want to worry about the same frame if we
+    // aren't an area
+    if (frame == aFocusedFrame ||
+        (aFocusedFrame && (frame->GetContent() == aFocusedFrame->GetContent())))
+      continue;
+
+    // make sure the frame is targetable for focus
+    if (!isTargetable(focusDocuments, frame)) continue;
+
+    // RECT !!
+    frameRect = makeRectRelativeToGlobalView(frame);
+
+    // until I track down exactly why "makeRectRelativeToGlobalView" is giving
+    // us negative heights let's get the height directly --pete
+
+    nsCOMPtr<nsIContent> content = frame->GetContent();
+    if (!content) continue;
+
+    // no frames without size and be navigated to
+    // successfully.
+    if (frameRect.width == 0 || frameRect.height == 0)
+    {
+      useImageIf(content, frameRect);
+      const nsSize ns(frameRect.width, frameRect.height);
+      frame->SetSize(ns);
+    }
+
+    // deflate the rect to avoid overlapping with other
+    // rects.
+    frameRect.Deflate(gRectFudge, gRectFudgeY);
+
+    // ensure positive width
+    frameRect.width = abs(frameRect.width);
+    frameRect.height = abs(frameRect.height);
+
+    if (!isRectInDirection(aDirection, aFocusedRect, frameRect))
+      continue;
+
+    nsCOMPtr<nsIDOMNode> n = do_QueryInterface(content);
+    nsString str;
+    if (n) n->GetNodeName(str);
+
+    if (str.Equals(NS_LITERAL_STRING("IFRAME"))) continue;
+
+    PRBool isInView = IsPartiallyVisible(aPresContext->PresShell(), frame, PR_FALSE);
+
+    // if target takes precedence then use it - distance is not always the shortest for a precedent target
+    if (isInView && takesSuperPrecedence(aDirection, aFocusedRect, frameRect))
+    {
+      // reset distance as we are now in super precedence mode
+      if (!superPrecedent) *aDSoFar = LL_MaxInt();
+      superPrecedent = PR_TRUE;
+
+      precedentDistance = getPrecedentDistance(aDirection, aFocusedRect, frameRect);
+
+      if ((*aDSoFar) > precedentDistance)
+      {
+        (*aDSoFar) = precedentDistance;
+
+        NS_IF_RELEASE(*aCurrentContent);
+        NS_ADDREF(*aCurrentContent = content);
+      }
+    }
+
+    if (superPrecedent) continue;
+
+    // if target takes precedence then use it - distance is not always the shortest for a precedent target
+    if (isInView && takesPrecedence(aDirection, aFocusedRect, frameRect))
+    {
+      precedent = PR_TRUE;
+
+      precedentDistance = getPrecedentDistance(aDirection, aFocusedRect, frameRect);
+
+      if ((*aDSoFar) > precedentDistance)
+      {
+        (*aDSoFar) = precedentDistance;
+
+        NS_IF_RELEASE(*aCurrentContent);
+        NS_ADDREF(*aCurrentContent = content);
+      }
+    }
+
+    if (precedent) continue;
+
+    d = spatialDistance(aDirection, aFocusedRect, frameRect);
+
+    if ((*aDSoFar) >= d)
+    {
+#ifdef DEBUG_dougt
+      if (d == 0)
+      {
+        printf("there is overlapping content;\n");
+      }
+#endif
+      (*aDSoFar) = d;
+      NS_IF_RELEASE(*aCurrentContent);
+      NS_ADDREF(*aCurrentContent = content);
+#ifdef DEBUG_romaxa
+      nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
+      nsString str;
+      if (node)
+        node->GetNodeName(str);
+      printf("N:'%s', fr[%i,%i,%i,%i],tr[%i,%i,%i,%i],d:%i\n",
+             NS_ConvertUTF16toUTF8(str).get(),
+             aFocusedRect.x,aFocusedRect.y,aFocusedRect.width,aFocusedRect.height,
+             frameRect.x,frameRect.y,frameRect.width,frameRect.height,
+             (PRInt32)d);
+#endif
+    }
+  }
+  while(1);
+}
+
+inline void centerRect(int aDirection, nsRect& aRect)
+{
+  if (aDirection == eNavLeft)
+    aRect.x = 1000000;
+  else if (aDirection == eNavRight)
+    aRect.x = 0;
+  else if (aDirection == eNavUp)
+    aRect.y = 1000000;
+  else
+    aRect.y = 0;
+
+  aRect.height = 1;
+  aRect.width = 1;
+}
+
+nsresult
+nsSpatialNavigation::getContentInDirection(int aDirection,
+                                           nsPresContext* aPresContext,
+                                           nsRect& aFocusedRect,
+                                           nsIFrame* aFocusedFrame,
+                                           PRBool aIsAREA,
+                                           PRBool aFocusDocuments,
+                                           nsIContent** aContent)
+{
+  NS_ENSURE_ARG_POINTER(aFocusedFrame);
+  // Check to see if we should decend into subdoc
+  nsIContent* subFrameContent = aFocusedFrame->GetContent();
+  nsCOMPtr<nsIDOMHTMLHtmlElement> hhElement = do_QueryInterface(subFrameContent);
+  nsCOMPtr<nsIDOMHTMLIFrameElement> iFrameElement = do_QueryInterface(subFrameContent);
+
+  if ( (hhElement || iFrameElement) && mNavigationFramesState)
+  {
+    aPresContext = getPresContext(subFrameContent);
+    centerRect(aDirection, aFocusedRect);
+  }
+
+
+  nsCOMPtr<nsIFrameEnumerator> frameTraversal;
+  nsresult result = createFrameTraversal(aPresContext,
+                                         ePreOrder,
+                                         PR_FALSE, // aVisual
+                                         PR_FALSE, // aLockInScrollView
+                                         PR_TRUE,  // aFollowOOFs
+                                         getter_AddRefs(frameTraversal));
+  if (NS_FAILED(result))
+    return result;
+
+  nsCOMPtr<nsIContent> currentContent;
+  PRInt64 currentDistance = LL_MaxInt();
+
+  DoTraversal(aDirection,
+              frameTraversal,
+              aFocusedFrame,
+              aFocusedRect,
+              aIsAREA,
+              aFocusDocuments,
+              aPresContext,
+              &currentDistance,
+              aContent);
+
+
+  if ( (hhElement || iFrameElement) && mNavigationFramesState)
+  {
+    mNavigationFramesState = PR_FALSE;
+  }
+
+  return NS_OK;
+}
+
+static nsresult
+PutFakeSelectionTo(nsPresContext* aPresContext, PRInt32 aY = 0, PRBool aForward = PR_TRUE, PRInt32 aX = 0)
+{
+  NS_ENSURE_ARG_POINTER(aPresContext);
+  nsCOMPtr<nsIPresShell> presShell = aPresContext->PresShell();
+  NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
+  nsIViewManager* viewManager = presShell->GetViewManager();
+  NS_ENSURE_TRUE(viewManager, NS_ERROR_FAILURE);
+  nsIView* rootView = nsnull;
+  viewManager->GetRootView(rootView);
+  NS_ENSURE_TRUE(rootView, NS_ERROR_FAILURE);
+  nsEventStatus status;
+  nsMouseEvent event(PR_FALSE, NS_MOUSE_BUTTON_DOWN, rootView->GetWidget(), nsMouseEvent::eReal);
+  event.refPoint.x = aX;
+  event.refPoint.y = aY;
+  event.isAlt = PR_TRUE;
+  event.time = PR_IntervalNow();
+  viewManager->DispatchEvent(&event, &status);
+  event.message = NS_MOUSE_BUTTON_UP;
+  event.time = PR_IntervalNow();
+  viewManager->DispatchEvent(&event, &status);
+  return aPresContext->EventStateManager()->ShiftFocus(aForward, nsnull);
+}
+
+static nsPoint
+getPointByDirection(nsIDOMWindow *aWin, PRInt32 aDirection, PRBool *aDoForward = nsnull)
+{
+  nsPoint pt(0,0);
+  NS_ENSURE_TRUE(aWin, pt);
+  nsCOMPtr<nsIDOMWindowInternal> dwinint = do_QueryInterface(aWin);
+  PRInt32 oh,sy,yo,smy;
+  if (aDirection == eNavDown) {
+//    dwinint->GetPageYOffset(&yo);
+    pt.y = 0;
+//    if (aDoForward)
+//      *aDoForward = yo?PR_TRUE:PR_FALSE;
+  }
+  else if (aDirection == eNavUp) {
+    dwinint->GetOuterHeight(&oh);
+    dwinint->GetScreenY(&sy);
+//    dwinint->GetScrollMaxY(&smy);
+    pt.y = oh - sy;
+//    if (aDoForward)
+//      *aDoForward = yo==smy?PR_FALSE:PR_TRUE;
+  }
+  else {
+    dwinint->GetOuterHeight(&oh);
+    dwinint->GetScreenY(&sy);
+    pt.y = (oh - sy) / 2;
+    if (aDoForward)
+      *aDoForward = eNavLeft?PR_TRUE:PR_FALSE;
+  }
+  return pt;
+}
+
+PRBool
+nsSpatialNavigation::isContentInsideWindow(nsIContent* aContent, nsIDOMWindow* aWin, PRInt32 *xpos, PRInt32 *ypos)
+{
+  PRBool inside = PR_TRUE;
+  NS_ENSURE_TRUE(aWin, PR_FALSE);
+  NS_ENSURE_TRUE(aContent, PR_FALSE);
+  nsCOMPtr<nsIDOMWindowInternal> dwinint = do_QueryInterface(aWin);
+  NS_ENSURE_TRUE(dwinint, PR_FALSE);
+  nsCOMPtr<nsIDOMNode> node;
+  node = do_QueryInterface(aContent);
+  nsRect rect = makeRectRelativeToGlobalView(node);
+  PRInt32 xo,yo,ow,oh;
+  dwinint->GetOuterHeight(&oh);
+  dwinint->GetOuterWidth(&ow);
+  dwinint->GetPageYOffset(&yo);
+  dwinint->GetPageXOffset(&xo);
+  if (rect.y + rect.height < 0) {
+    inside = PR_FALSE;
+    if (ypos)
+      *ypos = -1;
+  }
+  if (oh < rect.y) {
+    inside = PR_FALSE;
+    if (ypos)
+      *ypos = 1;
+  }
+  if (rect.x + rect.width < 0) {
+    inside = PR_FALSE;
+    if (xpos)
+      *xpos = -1;
+  }
+  if (ow < rect.x) {
+    inside = PR_FALSE;
+    if (xpos)
+      *xpos = 1;
+  }
+  return inside;
+}
+
+nsresult
+nsSpatialNavigation::handleMove(int direction)
+{
+  nsCOMPtr<nsIContent> focusedContent;
+  getFocusedContent(direction, getter_AddRefs(focusedContent));
+
+  // there are some websites which have no focusable elements,
+  // only text, for example. In these cases, scrolling have to be
+  // performed by snav.
+  if (!focusedContent) {
+    PRBool forward = PR_TRUE;
+    nsPoint pt = getPointByDirection(getContentWindow(), direction, &forward);
+    if (NS_SUCCEEDED(PutFakeSelectionTo(getPresContext(nsnull), pt.y, forward)))
+      return NS_OK;
+    ScrollWindow(direction, getContentWindow());
+    return NS_OK;
+  }
+
+  nsPresContext* presContext = getPresContext(focusedContent);
+  if(!presContext)
+    return NS_ERROR_NULL_POINTER;
+
+  nsIFrame* focusedFrame;
+  getFrameForContent(focusedContent, &focusedFrame);
+
+  if (mKeyPressedState) {
+    if (!isContentInsideWindow(focusedContent, mTopWindow)) {
+      mKeyPressedState = 0;
+      PRBool forward = PR_TRUE;
+      nsPoint pt = getPointByDirection(getContentWindow(), direction, &forward);
+      PutFakeSelectionTo(getPresContext(nsnull), pt.y, forward);
+      return NS_OK;
+    }
+  }
+  mKeyPressedState = 0;
+
+  nsRect focusedRect;
+  PRBool isAREA = isArea(focusedContent);
+  if (!isAREA)
+  {
+    // RECT !!
+    if (focusedFrame)
+    {
+      focusedRect = makeRectRelativeToGlobalView(focusedFrame);
+      nsRect size (focusedFrame->GetRect());
+
+      // until I track down exactly why "makeRectRelativeToGlobalView" is giving
+      // us negative heights let's get the height directly --pete
+      // focusedRect.height = NS_TWIPS_TO_POINTS(size.height);
+      focusedRect.height = abs(focusedRect.height);
+      focusedRect.width = abs(focusedRect.width);
+    }
+
+    // deflate the rect to avoid overlapping with other
+    // rects.
+    focusedRect.Deflate(gRectFudge, gRectFudgeY);
+  }
+  else
+  {
+    nsCOMPtr<nsIDOMHTMLAreaElement> e = do_QueryInterface(focusedContent);
+    getRectOfAreaElement(focusedFrame, e, &focusedRect);
+  }
+
+  nsCOMPtr<nsIContent> c;
+  if (focusedFrame)
+  {
+    getContentInDirection(direction, presContext, focusedRect, focusedFrame, PR_FALSE, isAREA, getter_AddRefs(c));
+  }
+
+  if (c)
+  {
+    nsIDocument* doc = c->GetDocument();
+    if (!doc)
+      return NS_ERROR_FAILURE;
+
+    nsIPresShell *presShell = doc->GetPrimaryShell();
+
+    nsIFrame* cframe = presShell->GetPrimaryFrameFor(c);
+
+    PRBool b = IsPartiallyVisible(presShell, cframe);
+
+    if (b)
+      setFocusedContent(c);
+    else
+      ScrollWindow(direction, getContentWindow());
+
+    return NS_OK;
+  }
+
+  ///////////////////////////////////////////////////////////////////////////////////////////////////
+  // do it all again at the parent document
+  ///////////////////////////////////////////////////////////////////////////////////////////////////
+
+  {
+    nsCOMPtr<nsIDOMWindow> contentWindow = getContentWindow();
+    if (!contentWindow)
+      return NS_OK;
+
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    contentWindow->GetDocument(getter_AddRefs(domDoc));
+    nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
+
+    nsIPresShell *shell = doc->GetPrimaryShell();
+    if (!shell) return NS_OK;
+
+    presContext = shell->GetPresContext();
+
+    nsIFrame* parentFrame = shell->GetRootFrame();
+
+    nsCOMPtr<nsIDocument> subdoc = focusedContent->GetDocument();
+    if (!subdoc) return NS_OK;
+
+    nsCOMPtr<nsIDOMDocument> subdomdoc = do_QueryInterface(subdoc);
+
+    nsCOMPtr<nsIDOMWindowInternal> domWindowInternal;
+    GetWindowFromDocument(subdomdoc, getter_AddRefs(domWindowInternal));
+    if (!domWindowInternal) return NS_OK;
+
+    nsCOMPtr<nsIDOMWindowInternal> domWindowInternal2 = domWindowInternal;
+    domWindowInternal2->GetOpener(getter_AddRefs(domWindowInternal));
+    if (!domWindowInternal)
+      domWindowInternal = domWindowInternal2;
+
+    nsCOMPtr<nsIDOMWindow> subdocWindow = do_QueryInterface(domWindowInternal);
+    if (!subdocWindow) return NS_OK;
+
+    subdocWindow->GetDocument(getter_AddRefs(subdomdoc));
+    if (!subdoc) return NS_OK;
+
+    nsIPresShell *subdocShell = subdoc->GetPrimaryShell();
+    if (!subdocShell) return NS_OK;
+
+    nsPresContext *subdocPresContext = subdocShell->GetPresContext();
+
+    nsIFrame* subdocFrame = subdocShell->GetRootFrame();
+    NS_ENSURE_TRUE(subdocFrame, NS_ERROR_FAILURE);
+
+    nsRect subdocRect = subdocFrame->GetRect();
+
+    nsPoint frame_offset = subdocFrame->GetOffsetToExternal(parentFrame);
+
+    subdocRect.x = frame_offset.x;
+    subdocRect.y = frame_offset.y;
+
+    // printf("CALL:B getContentInDirection \n");
+    getContentInDirection(direction, presContext, subdocRect, subdocFrame, PR_TRUE, PR_FALSE, getter_AddRefs(c));
+  }
+
+  if (c) {
+    nsCOMPtr<nsIContent> subdocContent;
+    getContentFromFrame(c, getter_AddRefs(subdocContent));
+
+    if (subdocContent) {
+      mNavigationFramesState = PR_TRUE;
+    }
+
+    setFocusedContent(c);
+    return NS_OK;
+  }
+
+  // if everything fails, default is to move the focus just as if the user hit tab.
+  //  presContext->EventStateManager()->ShiftFocus(PR_TRUE, focusedContent);
+
+  // how about this, if we find anything, we just scroll the
+  // page in the direction of the navigation??
+  ScrollWindow(direction, getContentWindow());
+
+  ///////////////////////////////////////////////////////////////////////////////////////////////////
+
+  return NS_OK;
+
+}
+
+void
+nsSpatialNavigation::getFocusedContent(int direction, nsIContent** aContent)
+{
+  *aContent = nsnull;
+
+  nsCOMPtr<nsIDOMWindow> contentWindow = getContentWindow();
+  if (!contentWindow)
+    return;
+
+  nsCOMPtr<nsPIDOMWindow> privateWindow = do_QueryInterface(contentWindow);
+  nsIFocusController *focusController = privateWindow->GetRootFocusController();
+
+  if (!focusController)
+    return;
+
+  nsCOMPtr<nsIDOMElement> element;
+  focusController->GetFocusedElement(getter_AddRefs(element));
+
+  if (element)
+  {
+    nsCOMPtr<nsIContent> content = do_QueryInterface(element);
+    NS_IF_ADDREF(*aContent = content);
+    return;
+  }
+}
+
+void
+nsSpatialNavigation::setFocusedContent(nsIContent* c)
+{
+  if (!c) return;
+
+  nsCOMPtr<nsIContent> subdocContent;
+  getContentFromFrame(c, getter_AddRefs(subdocContent));
+
+  if (subdocContent) {
+    c = subdocContent;
+  }
+
+  nsIContent* currentContent = c;
+
+  // printf("**************************************************\n");
+  // debug_content(c);
+  // printf("**************************************************\n");
+
+  nsCOMPtr<nsIDOMElement> element = do_QueryInterface(currentContent);
+  nsCOMPtr<nsIDOMNode> node(do_QueryInterface(element));
+
+  nsCOMPtr<nsIDOMWindow> contentWindow;
+  if (mService->mDisableJSWhenFocusing)
+    contentWindow = getContentWindow();
+
+  DisableJSScope foopy (contentWindow);
+
+  nsPresContext* presContext = getPresContext(c);
+  nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
+
+  if (mService->mOrderLayout)
+  {
+    // Google Spreadsheets works ugly with this call
+    // presContext->EventStateManager()->SetContentState(c, NS_EVENT_STATE_FOCUS);
+
+    presShell->ScrollContentIntoView(c,
+                                     NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
+                                     NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE);
+
+    presContext->EventStateManager()->MoveCaretToFocus();
+  }
+
+  nsCOMPtr<nsIDOMNSHTMLElement> nsElement = do_QueryInterface(element);
+
+  mLastContent = do_QueryInterface(nsElement);
+
+  if (nsElement)
+    nsElement->Focus();
+
+  return;
+
+  nsIFrame* focusedFrame;
+  getFrameForContent(c, &focusedFrame);
+  nsRect rect = makeRectRelativeToGlobalView(focusedFrame);
+  nsIViewManager* viewManager = presShell->GetViewManager();
+  if (!viewManager) return;
+  nsIView* rootView = nsnull;
+  viewManager->GetRootView(rootView);
+  if (!rootView) return;
+  nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, rootView->GetWidget(), nsMouseEvent::eReal);
+  nsPoint pt(rect.x, rect.y);
+  pt.x += (PRInt32)rect.width / 2;
+  pt.y += (PRInt32)rect.height / 2;
+  event.refPoint.x = pt.x;
+  event.refPoint.y = pt.y;
+  event.time = PR_IntervalNow();
+  nsEventStatus status;
+  viewManager->DispatchEvent(&event, &status);
+}
+
+
+nsIDOMWindow*
+nsSpatialNavigation::getContentWindow()
+{
+
+  nsIDOMWindow* resultWindow = nsnull;
+
+  nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(mTopWindow);
+  nsIDOMWindowInternal *rootWindow = window->GetPrivateRoot();
+
+  nsCOMPtr<nsIDOMWindow> windowContent;
+  rootWindow->GetContent(getter_AddRefs(windowContent));
+
+  if (!windowContent)
+  return nsnull;
+
+  NS_ADDREF(resultWindow = windowContent);
+  return resultWindow;
+}
+
+
+nsPresContext*
+nsSpatialNavigation::getPresContext(nsIContent* content)
+{
+  nsCOMPtr<nsIDocument> doc;
+  if (!content) {
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    if (mTopWindow)
+      mTopWindow->GetDocument(getter_AddRefs(domDoc));
+    doc = do_QueryInterface(domDoc);
+  } else
+    doc = content->GetDocument();
+
+  if (!doc) return nsnull;
+  // the only case where there could be more shells in printpreview
+  nsIPresShell *shell = doc->GetPrimaryShell();
+  if (!shell) return nsnull;
+
+  nsPresContext *presContext = shell->GetPresContext();
+  return presContext;
+}
+
+
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigationPrivate.h
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationPrivate.h
@@ -0,0 +1,299 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Spatial Navigation
+ *
+ * The Initial Developer of the Original Code is
+ * Douglas F. Turner II  <dougt@meer.net>
+ * Portions created by the Initial Developer are Copyright (C) 2004-2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "memory.h"
+#include "stdlib.h"
+
+#include "nspr.h"
+
+#include "nsXPCOM.h"
+#include "nsCOMPtr.h"
+#include "nsMemory.h"
+
+#include "nsStringGlue.h"
+
+#include "nsISpatialNavigation.h"
+
+#include "nsDirectoryServiceDefs.h"
+#include "nsDirectoryServiceUtils.h"
+#include "nsFrameTraversal.h"
+#include "nsIArray.h"
+#include "nsIBaseWindow.h"
+#include "nsICategoryManager.h"
+#include "nsIComponentManager.h"
+#include "nsIDOM3EventTarget.h"
+#include "nsIDOMAbstractView.h"
+#include "nsIDOMCSSStyleDeclaration.h"
+#include "nsIDOMDocument.h"
+#include "nsIDOMDocument.h"
+#include "nsIDOMDocumentView.h"
+#include "nsIDOMElementCSSInlineStyle.h"
+#include "nsIDOMEvent.h"
+#include "nsIDOMEventGroup.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIDOMHTMLAnchorElement.h"
+#include "nsIDOMHTMLAreaElement.h"
+#include "nsIDOMHTMLCollection.h"
+#include "nsIDOMHTMLDocument.h"
+#include "nsIDOMHTMLFrameElement.h"
+#include "nsIDOMHTMLHtmlElement.h"
+#include "nsIDOMHTMLIFrameElement.h"
+#include "nsIDOMHTMLInputElement.h"
+#include "nsIDOMHTMLTextAreaElement.h"
+#include "nsIDOMHTMLMapElement.h"
+#include "nsIDOMHTMLOptionElement.h"
+#include "nsIDOMHTMLSelectElement.h"
+#include "nsIDOMKeyEvent.h"
+#include "nsIDOMKeyListener.h"
+#include "nsIDOMNSEvent.h"
+#include "nsIDOMNSHTMLElement.h"
+#include "nsIDOMNSUIEvent.h"
+#include "nsIDOMNSHTMLInputElement.h"
+#include "nsIDOMNSHTMLTextAreaElement.h"
+#include "nsIDOMNSHTMLDocument.h"
+#include "nsIDOMNode.h"
+#include "nsIDOMWindow.h"
+#include "nsIDOMWindowInternal.h"
+#include "nsIDocShell.h"
+#include "nsIDocShellTreeItem.h"
+#include "nsIDocShellTreeOwner.h"
+#include "nsIDocument.h"
+#include "nsIDocumentViewer.h"
+#include "nsIEventStateManager.h"
+#include "nsIFile.h"
+#include "nsIFocusController.h"
+#include "nsIFormControl.h"
+#include "nsIFrameFrame.h"
+#include "nsIFrameLoader.h"
+#include "nsIFrameTraversal.h"
+#include "nsIGenericFactory.h"
+#include "nsIHTMLDocument.h"
+#include "nsIImageFrame.h"
+#include "nsIImageMap.h"
+#include "nsIInterfaceRequestor.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "nsILineIterator.h"
+#include "nsILocalFile.h"
+#include "nsINameSpaceManager.h"
+#include "nsIObserver.h"
+#include "nsIPrefBranchInternal.h"
+#include "nsIPrefService.h"
+#include "nsIProperties.h"
+#include "nsIScriptContext.h"
+#include "nsIScriptGlobalObject.h"
+#include "nsIServiceManager.h"
+#include "nsISound.h"
+#include "nsIView.h"
+#include "nsIViewManager.h"
+#include "nsIWebBrowser.h"
+#include "nsIWebBrowserChrome.h"
+#include "nsIWindowWatcher.h"
+#include "nsLayoutCID.h"
+#include "nsPIDOMWindow.h"
+#include "nsStyleContext.h"
+#include "nsIEnumerator.h"
+
+class nsSpatialNavigationService;
+class nsSpatialNavigation;
+
+class nsSpatialNavigation : public nsISpatialNavigation, public nsIDOMKeyListener
+{
+public:
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISPATIALNAVIGATION
+
+  NS_DECL_NSIDOMEVENTLISTENER
+
+  // ----- nsIDOMKeyListener ----------------------------
+  NS_IMETHOD KeyDown(nsIDOMEvent* aKeyEvent);
+  NS_IMETHOD KeyUp(nsIDOMEvent* aKeyEvent);
+  NS_IMETHOD KeyPress(nsIDOMEvent* aKeyEvent);
+
+  nsSpatialNavigation(nsSpatialNavigationService* aService);
+
+private:
+  ~nsSpatialNavigation();
+
+  nsresult HandleKey(nsIDOMEvent* aKeyEvent, PRBool aReal);
+  nsPresContext* getPresContext(nsIContent* aContent);
+
+  PRInt64 spatialDistance(int direction, nsRect& a, nsRect& b);
+
+  nsIDOMWindow* getContentWindow();
+
+  void setFocusedContent(nsIContent* aContent);
+  void getFocusedContent(int direction, nsIContent** aContent);
+  PRBool isContentInsideWindow(nsIContent* aContent, nsIDOMWindow* aWin, PRInt32 *xpos = nsnull, PRInt32 *ypos = nsnull);
+
+  nsresult handleMove(int direction);
+  nsresult getContentInDirection(int direction, nsPresContext* presContext, nsRect& focusedRect, nsIFrame* focusedFrame, PRBool aFocusDocuments, PRBool isAREA, nsIContent** aContent);
+
+  nsCOMPtr<nsIDOMWindow> mTopWindow;
+
+  nsSpatialNavigationService* mService;
+
+  PRBool mNavigationFramesState;
+  PRUint32 mKeyPressedCount;
+  PRUint16 mKeyPressedState;
+  PRBool mKeyWasDown;
+
+  PRBool mSelectControlSelected;
+  PRBool mSelectPopup;
+  PRInt32 mSelectPopupCount;
+  PRInt32 mSelectNavCount;
+  PRInt32 mSelectMultiCount;
+  nsCOMPtr<nsIContent> mLastContent;
+};
+
+
+
+class nsSpatialNavigationService: public nsIObserver
+{
+public:
+  nsSpatialNavigationService();
+  virtual ~nsSpatialNavigationService();
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIOBSERVER
+
+  nsCOMArray<nsISpatialNavigation> mObjects;
+
+  PRBool  mEnabled;
+  PRBool  mIgnoreTextFields;
+  PRBool  mOrderLayout;
+  PRBool  mDisableJSWhenFocusing;
+
+  PRInt32 mKeyCodeLeft;
+  PRInt32 mKeyCodeRight;
+  PRInt32 mKeyCodeUp;
+  PRInt32 mKeyCodeDown;
+  PRInt32 mKeyCodeModifier;
+
+};
+
+extern PRInt32 gRectFudge;
+extern PRInt32 gDirectionalBias;
+
+enum {
+  eNavLeft = 0,
+  eNavUp,
+  eNavRight,
+  eNavDown
+};
+
+
+// Utils
+
+nscoord* lo_parse_coord_list          (char *str, PRInt32* value_cnt);
+nsresult createFrameTraversal         (nsPresContext* aPresContext,
+                                       PRInt32 aType,
+                                       PRBool aVisual,
+                                       PRBool aLockInScrollView,
+                                       PRBool aFollowOOFs,
+                                       nsIFrameEnumerator** outTraversal);
+nsresult getEventTargetFromWindow     (nsIDOMWindow* aWindow, nsIDOM3EventTarget** aEventTarget, nsIDOMEventGroup** aSystemGroup);
+void     getContentFromFrame          (nsIContent* c, nsIContent** outContent);
+nsresult getFrameForContent           (nsIContent* aContent, nsIFrame** aFrame);
+PRBool   isContentOfType              (nsIContent* content, const char* type);
+PRBool   isArea                       (nsIContent* content);
+PRBool   isMap                        (nsIFrame* frame);
+PRBool   isTargetable                 (PRBool focusDocuments, nsIFrame* frame);
+nsRect   makeRectRelativeToGlobalView (nsIFrame *aFrame);
+nsRect   makeRectRelativeToGlobalView (nsIDOMNode *aNode);
+void     poly2Rect                    (int sides, nscoord* coord, nsRect* rect);
+void     getRectOfAreaElement         (nsIFrame* f, nsIDOMHTMLAreaElement* e, nsRect* r);
+PRBool   isRectInDirection            (int direction, nsRect& focusedRect, nsRect& frameRect);
+PRBool   takesSuperPrecedence         (int direction, nsRect& c, nsRect& t);
+PRBool   takesPrecedence              (int direction, nsRect& c, nsRect& t);
+PRInt64  spatialDistance              (int direction, nsRect& a, nsRect& b);
+PRInt64  getPrecedentDistance         (int direction, nsRect& c, nsRect& t);
+void     useImageIf                   (nsIContent* aContent, nsRect& r);
+void     GetWindowFromDocument        (nsIDOMDocument* aDocument, nsIDOMWindowInternal** aWindow);
+void     displayRectProperties        (nsRect& curRect, nsRect& targetRect);
+PRBool   IsPartiallyVisible           (nsIPresShell* shell, nsIFrame* frame, PRBool aForce = PR_TRUE);
+void     ScrollWindow                 (int direction, nsIDOMWindow* window);
+
+nsresult debug_content                (nsISupports *content);
+
+
+
+class DisableJSScope
+{
+public:
+  DisableJSScope(nsIDOMWindow* window) :
+    isEnabled(PR_FALSE), scriptContext(nsnull)
+  {
+    // My passing null, we don't do a thing
+    if (!window)
+      return;
+
+    // so, we want to set the focus to the next element, but
+    // we do not want onFocus to fire.  The reason for this is
+    // that we want to have the "enter" key be able to trigger
+    // the targeted link after we have focused it.  However,
+    // we have found a popular portal has a toolbar that, on
+    // onFocus, decides to move the focus as if the targeted
+    // content was clicked.  The only way that I know how to
+    // do this is to disable javascript during this call.
+
+    nsCOMPtr<nsIScriptGlobalObject> sgo (do_QueryInterface(window));
+    if (!sgo)
+      return;
+
+    scriptContext = sgo->GetContext();
+    if (!scriptContext)
+      return;
+
+    isEnabled = scriptContext->GetScriptsEnabled();
+
+    if (isEnabled)
+      scriptContext->SetScriptsEnabled(PR_FALSE, PR_TRUE);
+  }
+
+  ~DisableJSScope()
+  {
+    if (isEnabled && scriptContext)
+    {
+      // enable javascript again..
+      scriptContext->SetScriptsEnabled(PR_TRUE, PR_TRUE);
+    }
+
+  }
+  PRBool isEnabled;
+  nsIScriptContext *scriptContext;
+};
+
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigationService.cpp
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationService.cpp
@@ -0,0 +1,332 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Spatial Navigation
+ *
+ * The Initial Developer of the Original Code is
+ * Douglas F. Turner II  <dougt@meer.net>
+ * Portions created by the Initial Developer are Copyright (C) 2004-2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSpatialNavigationPrivate.h"
+#include "nsIObserverService.h"
+
+nsSpatialNavigationService::nsSpatialNavigationService()
+{
+  mEnabled             = PR_TRUE;
+  mIgnoreTextFields    = PR_FALSE;
+  mOrderLayout         = PR_TRUE;
+  mDisableJSWhenFocusing = PR_TRUE;
+
+  mKeyCodeLeft         = nsIDOMKeyEvent::DOM_VK_LEFT;
+  mKeyCodeRight        = nsIDOMKeyEvent::DOM_VK_RIGHT;
+  mKeyCodeUp           = nsIDOMKeyEvent::DOM_VK_UP;
+  mKeyCodeDown         = nsIDOMKeyEvent::DOM_VK_DOWN;
+
+  mKeyCodeModifier     = 0x00000012 | 0x00100000; // By default ALT and SHIFT
+}
+
+nsSpatialNavigationService::~nsSpatialNavigationService()
+{
+}
+
+NS_IMPL_ISUPPORTS1(nsSpatialNavigationService, nsIObserver)
+
+NS_IMETHODIMP
+nsSpatialNavigationService::Observe(nsISupports *aSubject, const char *aTopic, const PRUnichar *aData)
+{
+  nsresult rv;
+
+  if (!strcmp(aTopic,"domwindowopened"))
+  {
+    nsCOMPtr<nsIDOMWindow> chromeWindow = do_QueryInterface(aSubject);
+
+    nsSpatialNavigation* sn = new nsSpatialNavigation(this);
+
+    if (!sn)
+      return NS_ERROR_OUT_OF_MEMORY;
+
+    sn->Init(chromeWindow);
+
+    mObjects.AppendObject(sn);  // the array owns the only reference to sn.
+
+    return NS_OK;
+  }
+
+  if (!strcmp(aTopic,"domwindowclosed"))
+  {
+    nsCOMPtr<nsIDOMWindow> chromeWindow = do_QueryInterface(aSubject);
+    // need to find it in our array
+
+    PRInt32 count = mObjects.Count();
+    for (PRInt32 i = 0; i < count; i++)
+    {
+      nsISpatialNavigation* sn = mObjects[i];
+      nsCOMPtr<nsIDOMWindow> attachedWindow;
+      sn->GetAttachedWindow(getter_AddRefs(attachedWindow));
+
+      if (attachedWindow == chromeWindow)
+      {
+        sn->Shutdown();
+        mObjects.RemoveObjectAt(i);
+        return NS_OK;
+      }
+    }
+    return NS_OK;
+  }
+
+
+  if (!strcmp(aTopic,"app-startup"))
+  {
+    nsCOMPtr<nsIWindowWatcher> windowWatcher = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    windowWatcher->RegisterNotification(this);
+
+    nsCOMPtr<nsIPrefBranch2> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    prefBranch->AddObserver("snav.", this, PR_FALSE);
+
+    nsCOMPtr<nsIObserverService> observerService =
+             do_GetService(NS_OBSERVERSERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = observerService->AddObserver(this, "profile-after-change", PR_FALSE);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
+  }
+
+  if (!strcmp(aTopic,"profile-after-change"))
+  {
+    // the profile has loaded, read in the preferences
+    nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    PRBool tempBool;
+    PRInt32 tempInt32;
+
+    // note that if Get*Pref fails, the pref may not exist, so we fallback to
+    // the defaults as defined in the constructor
+
+    rv = prefBranch->GetBoolPref("snav.enabled", &tempBool);
+    if (NS_SUCCEEDED(rv))
+      mEnabled = tempBool;
+    rv = prefBranch->GetBoolPref("snav.ignoreTextFields", &tempBool);
+    if (NS_SUCCEEDED(rv))
+      mIgnoreTextFields = tempBool;
+    rv = prefBranch->GetBoolPref("snav.orderLayout", &tempBool);
+    if (NS_SUCCEEDED(rv))
+      mOrderLayout = tempBool;
+    rv = prefBranch->GetIntPref("snav.directionalBias", &tempInt32);
+    if (NS_SUCCEEDED(rv))
+    {
+      gDirectionalBias = tempInt32;
+      if (gDirectionalBias == 0)
+        gDirectionalBias = 1;
+    }
+    rv = prefBranch->GetBoolPref("snav.disableJS", &tempBool);
+    if (NS_SUCCEEDED(rv))
+      mDisableJSWhenFocusing = tempBool;
+    rv = prefBranch->GetIntPref("snav.rectFudge", &tempInt32);
+    if (NS_SUCCEEDED(rv))
+      gRectFudge = tempInt32;
+    rv = prefBranch->GetIntPref("snav.keyCode.left", &tempInt32);
+    if (NS_SUCCEEDED(rv))
+      mKeyCodeLeft = tempInt32;
+    rv = prefBranch->GetIntPref("snav.keyCode.right", &tempInt32);
+    if (NS_SUCCEEDED(rv))
+      mKeyCodeRight = tempInt32;
+    rv = prefBranch->GetIntPref("snav.keyCode.up", &tempInt32);
+    if (NS_SUCCEEDED(rv))
+      mKeyCodeUp = tempInt32;
+    rv = prefBranch->GetIntPref("snav.keyCode.down", &tempInt32);
+    if (NS_SUCCEEDED(rv))
+      mKeyCodeDown = tempInt32;
+    rv = prefBranch->GetIntPref("snav.keyCode.modifier", &tempInt32);
+    if (NS_SUCCEEDED(rv))
+      mKeyCodeModifier = tempInt32;
+
+    return NS_OK;
+  }
+
+  if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID))
+  {
+    nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(aSubject);
+
+    nsCString prefc(NS_ConvertUTF16toUTF8(aData).get());
+    nsString prefs(aData);
+
+    if (prefs.EqualsLiteral("snav.enabled"))
+    {
+      prefBranch->GetBoolPref(prefc.get(), &mEnabled);
+    }
+    else if (prefs.EqualsLiteral("snav.ignoreTextFields"))
+    {
+      prefBranch->GetBoolPref(prefc.get(), &mIgnoreTextFields);
+    }
+    else if (prefs.EqualsLiteral("snav.orderLayout"))
+    {
+      prefBranch->GetBoolPref(prefc.get(), &mOrderLayout);
+    }
+    else if (prefs.EqualsLiteral("snav.directionalBias"))
+    {
+      prefBranch->GetIntPref(prefc.get(), &gDirectionalBias);
+      if (gDirectionalBias == 0)
+        gDirectionalBias = 1;
+    }
+    else if (prefs.EqualsLiteral("snav.disableJS"))
+    {
+      prefBranch->GetBoolPref(prefc.get(), &mDisableJSWhenFocusing);
+    }
+    else if (prefs.EqualsLiteral("snav.rectFudge"))
+    {
+      prefBranch->GetIntPref(prefc.get(), &gRectFudge);
+    }
+    else if (prefs.EqualsLiteral("snav.keyCode.left"))
+    {
+      prefBranch->GetIntPref(prefc.get(), &mKeyCodeLeft);
+    }
+    else if (prefs.EqualsLiteral("snav.keyCode.right"))
+    {
+      prefBranch->GetIntPref(prefc.get(), &mKeyCodeRight);
+    }
+    else if (prefs.EqualsLiteral("snav.keyCode.up"))
+    {
+      prefBranch->GetIntPref(prefc.get(), &mKeyCodeUp);
+    }
+    else if (prefs.EqualsLiteral("snav.keyCode.down"))
+    {
+      prefBranch->GetIntPref(prefc.get(), &mKeyCodeDown);
+    }
+    else if (prefs.EqualsLiteral("snav.keyCode.modifier"))
+    {
+      prefBranch->GetIntPref(prefc.get(), &mKeyCodeModifier);
+    }
+
+    return NS_OK;
+  }
+
+  return NS_OK;
+}
+
+
+//------------------------------------------------------------------------------
+//  XPCOM REGISTRATION BELOW
+//------------------------------------------------------------------------------
+
+#define SpatialNavigation_CID \
+{ 0xd1b91385, 0xe1c1, 0x46ec, \
+{0x8d, 0x15, 0x88, 0x0c, 0x45, 0xbe, 0x8e, 0x0e} }
+
+#define SpatialNavigation_ContractID "@mozilla.org/spatialNavigation/service;1"
+
+#define SpatialNavigationService_CID \
+{ 0x4125624b, 0xaf22, 0x4d50, \
+{ 0x87, 0xf6, 0x40, 0x19, 0xc9, 0x85, 0x7b, 0x58} }
+
+#define SpatialNavigationService_ContractID "@mozilla.org/spatialnavigation/service"
+
+static NS_METHOD SpatialNavigationServiceRegistration(nsIComponentManager *aCompMgr,
+                                                      nsIFile *aPath,
+                                                      const char *registryLocation,
+                                                      const char *componentType,
+                                                      const nsModuleComponentInfo *info)
+{
+  nsresult rv;
+
+  nsCOMPtr<nsIServiceManager> servman = do_QueryInterface((nsISupports*)aCompMgr, &rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+
+  nsCOMPtr<nsICategoryManager> catman;
+  servman->GetServiceByContractID(NS_CATEGORYMANAGER_CONTRACTID,
+                                  NS_GET_IID(nsICategoryManager),
+                                  getter_AddRefs(catman));
+
+  if (NS_FAILED(rv))
+    return rv;
+
+  char* previous = nsnull;
+  rv = catman->AddCategoryEntry("app-startup",
+                                "SpatialNavigationService",
+                                SpatialNavigationService_ContractID,
+                                PR_TRUE,
+                                PR_TRUE,
+                                &previous);
+  if (previous)
+    nsMemory::Free(previous);
+
+  return rv;
+}
+
+static NS_METHOD SpatialNavigationServiceUnregistration(nsIComponentManager *aCompMgr,
+                                                        nsIFile *aPath,
+                                                        const char *registryLocation,
+                                                        const nsModuleComponentInfo *info)
+{
+  nsresult rv;
+
+  nsCOMPtr<nsIServiceManager> servman = do_QueryInterface((nsISupports*)aCompMgr, &rv);
+  if (NS_FAILED(rv))
+    return rv;
+
+  nsCOMPtr<nsICategoryManager> catman;
+  servman->GetServiceByContractID(NS_CATEGORYMANAGER_CONTRACTID,
+                                  NS_GET_IID(nsICategoryManager),
+                                  getter_AddRefs(catman));
+
+  if (NS_FAILED(rv))
+    return rv;
+
+  rv = catman->DeleteCategoryEntry("app-startup",
+                                   "SpatialNavigationService",
+                                   PR_TRUE);
+
+  return rv;
+}
+
+
+
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsSpatialNavigationService)
+
+
+static const nsModuleComponentInfo components[] =
+{
+  { "SpatialNavigationService",
+    SpatialNavigationService_CID,
+    SpatialNavigationService_ContractID,
+    nsSpatialNavigationServiceConstructor,
+    SpatialNavigationServiceRegistration,
+    SpatialNavigationServiceUnregistration
+  }
+
+};
+
+NS_IMPL_NSGETMODULE(SpatialNavigationModule, components)
Index: mozilla/extensions/spatialnavigation/src/nsSpatialNavigationUtils.cpp
===================================================================
--- /dev/null
+++ mozilla/extensions/spatialnavigation/src/nsSpatialNavigationUtils.cpp
@@ -0,0 +1,1146 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Spatial Navigation
+ *
+ * The Initial Developer of the Original Code is
+ * Douglas F. Turner II  <dougt@meer.net>
+ * Portions created by the Initial Developer are Copyright (C) 2004-2005
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsSpatialNavigationPrivate.h"
+#include "nsIDOMNSElement.h"
+#include "nsIDOMClientRect.h"
+#include "nsIDOMHTMLImageElement.h"
+
+#include "nsComponentManagerUtils.h"
+#include "nsRect.h"
+
+void displayRectProperties (nsRect& curRect, nsRect& targetRect)
+{
+  printf("######## CURRENT RECT ########\n");
+  printf("TOP(%d), LEFT(%d)\n", curRect.y, curRect.x);
+  printf("HEIGHT(%d), WIDTH(%d)\n", curRect.height, curRect.width);
+  printf("MIDDLE LEFT(%d), MIDDLE TOP(%d)\n", (curRect.y + curRect.height/2), (curRect.x + curRect.width/2));
+  printf("BOTTOM(%d), RIGHT(%d)\n", (curRect.y + curRect.height), (curRect.x + curRect.width));
+  printf("##############################\n");
+
+  printf("######## TARGET  RECT ########\n");
+  printf("TOP(%d), LEFT(%d)\n", targetRect.y, targetRect.x);
+  printf("HEIGHT(%d), WIDTH(%d)\n", targetRect.height, targetRect.width);
+  printf("MIDDLE LEFT(%d), MIDDLE TOP(%d)\n", (targetRect.y + targetRect.height/2), (targetRect.x + targetRect.width/2));
+  printf("BOTTOM(%d), RIGHT(%d)\n", (targetRect.y + targetRect.height), (targetRect.x + targetRect.width));
+  printf("##############################\n");
+}
+
+static PRBool is_space(char c)
+{
+  return (c == ' '  || c == '\f' || c == '\n' ||
+          c == '\r' || c == '\t' || c == '\v');
+}
+
+nscoord* lo_parse_coord_list(char *str, PRInt32* value_cnt)
+{
+  char *tptr;
+  char *n_str;
+  PRInt32 i, cnt;
+  PRInt32 *value_list;
+
+  /*
+   * Nothing in an empty list
+   */
+  *value_cnt = 0;
+  if (!str || *str == '\0')
+  {
+    return nsnull;
+  }
+
+  /*
+   * Skip beginning whitespace, all whitespace is empty list.
+   */
+  n_str = str;
+  while (is_space(*n_str))
+  {
+    n_str++;
+  }
+  if (*n_str == '\0')
+  {
+    return nsnull;
+  }
+
+  /*
+   * Make a pass where any two numbers separated by just whitespace
+   * are given a comma separator.  Count entries while passing.
+   */
+  cnt = 0;
+  while (*n_str != '\0')
+  {
+    PRBool has_comma;
+
+    /*
+     * Skip to a separator
+     */
+    tptr = n_str;
+    while (!is_space(*tptr) && *tptr != ',' && *tptr != '\0')
+    {
+      tptr++;
+    }
+    n_str = tptr;
+
+    /*
+     * If no more entries, break out here
+     */
+    if (*n_str == '\0')
+    {
+      break;
+    }
+
+    /*
+     * Skip to the end of the separator, noting if we have a
+     * comma.
+     */
+    has_comma = PR_FALSE;
+    while (is_space(*tptr) || *tptr == ',')
+    {
+      if (*tptr == ',')
+      {
+        if (has_comma == PR_FALSE)
+        {
+          has_comma = PR_TRUE;
+        }
+        else
+        {
+          break;
+        }
+      }
+      tptr++;
+    }
+    /*
+     * If this was trailing whitespace we skipped, we are done.
+     */
+    if ((*tptr == '\0')&&(has_comma == PR_FALSE))
+    {
+      break;
+    }
+    /*
+     * Else if the separator is all whitespace, and this is not the
+     * end of the string, add a comma to the separator.
+     */
+    else if (has_comma == PR_FALSE)
+    {
+      *n_str = ',';
+    }
+
+    /*
+     * count the entry skipped.
+     */
+    cnt++;
+
+    n_str = tptr;
+  }
+  /*
+   * count the last entry in the list.
+   */
+  cnt++;
+
+  /*
+   * Allocate space for the coordinate array.
+   */
+  value_list = new nscoord[cnt];
+  if (!value_list)
+  {
+    return nsnull;
+  }
+
+  /*
+   * Second pass to copy integer values into list.
+   */
+  tptr = str;
+  for (i=0; i<cnt; i++)
+  {
+    char *ptr;
+
+    ptr = strchr(tptr, ',');
+    if (ptr)
+    {
+      *ptr = '\0';
+    }
+    /*
+     * Strip whitespace in front of number because I don't
+     * trust atoi to do it on all platforms.
+     */
+    while (is_space(*tptr))
+    {
+      tptr++;
+    }
+    if (*tptr == '\0')
+    {
+      value_list[i] = 0;
+    }
+    else
+    {
+      value_list[i] = (nscoord) ::atoi(tptr);
+    }
+    if (ptr)
+    {
+      *ptr = ',';
+      tptr = ptr + 1;
+    }
+  }
+
+  *value_cnt = cnt;
+  return value_list;
+}
+
+nsresult createFrameTraversal(nsPresContext* aPresContext,
+                              PRInt32 aType,
+                              PRBool aVisual,
+                              PRBool aLockInScrollView,
+                              PRBool aFollowOOFs,
+                              nsIFrameEnumerator** outTraversal)
+{
+  nsresult result;
+  if (!aPresContext)
+    return NS_ERROR_FAILURE;
+
+  nsIPresShell* presShell = aPresContext->PresShell();
+  if (!presShell)
+    return NS_ERROR_FAILURE;
+
+  nsIFrame* frame = presShell->GetRootFrame();
+
+  if (!frame)
+    return NS_ERROR_FAILURE;
+
+#ifdef DEBUG_outputframes
+  nsIFrameDebug* fd;
+  frame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**) &fd);
+  if (fd)
+    fd->List(frame->GetPresContext(), stdout, 0);
+#endif
+
+  nsCOMPtr<nsIFrameEnumerator> frameTraversal;
+
+  static NS_DEFINE_CID(kFrameTraversalCID, NS_FRAMETRAVERSAL_CID);
+  nsCOMPtr<nsIFrameTraversal> trav(do_CreateInstance(kFrameTraversalCID,&result));
+  if (NS_FAILED(result))
+    return result;
+
+  result = trav->NewFrameTraversal(getter_AddRefs(frameTraversal),
+                                   aPresContext, frame,
+                                   aType, aVisual, aLockInScrollView, aFollowOOFs);
+  if (NS_FAILED(result))
+    return result;
+
+  NS_IF_ADDREF(*outTraversal = frameTraversal);
+  return NS_OK;
+}
+
+nsresult getEventTargetFromWindow(nsIDOMWindow* aWindow, nsIDOM3EventTarget** aEventTarget, nsIDOMEventGroup** aSystemGroup)
+{
+  *aEventTarget = nsnull;
+  nsCOMPtr<nsPIDOMWindow> privateWindow = do_QueryInterface(aWindow);
+
+  if (!privateWindow)
+    return NS_ERROR_UNEXPECTED; // assert
+
+  nsPIDOMEventTarget *chromeEventHandler = privateWindow->GetChromeEventHandler();
+
+  if (!chromeEventHandler)
+    return NS_ERROR_UNEXPECTED; // assert
+
+  nsCOMPtr<nsIDOMEventGroup> systemGroup;
+  chromeEventHandler->GetSystemEventGroup(getter_AddRefs(systemGroup));
+  nsCOMPtr<nsIDOM3EventTarget> target(do_QueryInterface(chromeEventHandler));
+
+  if (!target || !systemGroup)
+    return NS_ERROR_FAILURE;
+
+  NS_ADDREF(*aEventTarget = target);
+  NS_ADDREF(*aSystemGroup = systemGroup);
+  return NS_OK;
+}
+
+void getContentFromFrame(nsIContent* c, nsIContent** outContent)
+{
+  *outContent = nsnull;
+
+  nsCOMPtr<nsIContent> result;
+  nsCOMPtr<nsIDOMDocument> contentDocument;
+
+  nsCOMPtr<nsIDOMHTMLFrameElement> domFrameElement = do_QueryInterface(c);
+
+  if (domFrameElement) {
+    domFrameElement->GetContentDocument(getter_AddRefs(contentDocument));
+  }
+  else {
+    nsCOMPtr<nsIDOMHTMLIFrameElement> domIFrameElement = do_QueryInterface(c);
+	if (domIFrameElement)
+      domIFrameElement->GetContentDocument(getter_AddRefs(contentDocument));
+  }
+
+  if (contentDocument) {
+    nsCOMPtr<nsIDOMElement> documentElement;
+    contentDocument->GetDocumentElement(getter_AddRefs(documentElement));
+    result = do_QueryInterface(documentElement);
+  }
+  NS_IF_ADDREF(*outContent = result);
+}
+
+nsresult getFrameForContent(nsIContent* aContent, nsIFrame** aFrame)
+{
+  *aFrame = nsnull;
+
+  if (!aContent)
+    return NS_ERROR_FAILURE;
+
+  nsIDocument* doc = aContent->GetDocument();
+  if (!doc)
+    return NS_ERROR_FAILURE;
+
+  nsIPresShell *presShell = doc->GetPrimaryShell();
+  nsIFrame* frame = presShell->GetPrimaryFrameFor(aContent);
+
+  if (!frame) return NS_ERROR_FAILURE;
+
+  *aFrame = frame;
+  return NS_OK;
+}
+
+PRBool
+isContentOfType(nsIContent* content, const char* type)
+{
+  if (!content)
+	return PR_FALSE;
+
+  if (content->IsNodeOfType(nsINode::eELEMENT))
+  {
+    nsIAtom* atom =  content->NodeInfo()->NameAtom();
+    if (atom)
+      return atom->EqualsUTF8(nsDependentCString(type));
+  }
+  return PR_FALSE;
+}
+
+PRBool
+isArea(nsIContent* content)
+{
+  if (!content || !content->IsNodeOfType(nsINode::eHTML))
+      return PR_FALSE;
+
+  return isContentOfType(content, "area");
+}
+
+PRBool
+isMap(nsIFrame* frame)
+{
+  nsIContent* content = frame->GetContent();
+
+  if (!content || !content->IsNodeOfType(nsINode::eHTML))
+      return PR_FALSE;
+
+  return isContentOfType(content, "map");
+}
+
+PRBool
+isTargetable(PRBool focusDocuments, nsIFrame* frame)
+{
+  nsIContent* currentContent = frame->GetContent();
+
+  if (!currentContent)
+    return PR_FALSE;
+
+  if (!currentContent->IsNodeOfType(nsINode::eHTML))
+      return PR_FALSE;
+
+  if (isContentOfType(currentContent, "map"))
+    return PR_TRUE;
+
+  if (isContentOfType(currentContent, "button"))
+    return PR_TRUE;
+
+  if (isContentOfType(currentContent, "a"))
+  {
+    // an anchor isn't targetable unless it has a non-null href.
+    nsCOMPtr<nsIDOMHTMLAnchorElement> anchorElement = do_QueryInterface(currentContent);
+    nsAutoString uri;
+    anchorElement->GetHref(uri);
+    if (uri.IsEmpty()) {
+      return PR_FALSE;
+    }
+    return PR_TRUE;
+  }
+
+  nsCOMPtr<nsIFrameFrame> frameFrame(do_QueryFrame(frame));
+  if (frameFrame)
+    return PR_TRUE;
+
+  nsCOMPtr<nsIDOMHTMLIFrameElement> iFrameElement = do_QueryInterface(currentContent);
+  if (iFrameElement)
+    return PR_TRUE;
+
+  if (focusDocuments) {
+    nsCOMPtr<nsIDOMHTMLHtmlElement> hhElement(do_QueryInterface(currentContent));
+    if (hhElement)
+      return PR_TRUE;
+  }
+
+  // need to figure out how to determine if a element is
+  // either disabled, hidden, or it is inaccessible due to
+  // its parent being one of these.
+
+  PRBool disabled = PR_FALSE;
+
+  nsCOMPtr<nsIDOMNode> node;
+  node = do_QueryInterface(currentContent);
+  if (node)
+  {
+    nsAutoString str;
+    node->GetNodeName(str);
+
+    if (str.LowerCaseEqualsLiteral("option")) return PR_FALSE;
+  }
+
+  nsCOMPtr<nsIDOMHTMLSelectElement> selectElement = do_QueryInterface(currentContent);
+  if (selectElement && NS_SUCCEEDED(selectElement->GetDisabled(&disabled)))
+    return !disabled;
+
+  nsCOMPtr<nsIDOMHTMLOptionElement> optionElement = do_QueryInterface(currentContent);
+  if (optionElement && NS_SUCCEEDED(optionElement->GetDisabled(&disabled)))
+    return !disabled;
+
+  nsAutoString inputType;
+  nsCOMPtr<nsIDOMHTMLInputElement> inputElement = do_QueryInterface(currentContent);
+  if (inputElement && NS_SUCCEEDED(inputElement->GetDisabled(&disabled)) && NS_SUCCEEDED(inputElement->GetType(inputType)))
+  {
+    if (inputType.LowerCaseEqualsLiteral("button"))
+    {
+      nsCOMPtr<nsIDOMNode> pn;
+      inputElement->GetParentNode(getter_AddRefs(pn));
+
+      nsCOMPtr<nsIDOMHTMLSelectElement> selectElement = do_QueryInterface(pn);
+
+      if (selectElement) return PR_FALSE;
+    }
+
+    return !disabled && (! inputType.LowerCaseEqualsLiteral("hidden")) && (!inputType.LowerCaseEqualsLiteral("file"));
+  }
+
+  nsAutoString textareaType;
+  nsCOMPtr<nsIDOMHTMLTextAreaElement> textareaElement = do_QueryInterface(currentContent);
+  if (textareaElement && NS_SUCCEEDED(textareaElement->GetDisabled(&disabled)) && NS_SUCCEEDED(textareaElement->GetType(textareaType)))
+    return !disabled && (! textareaType.LowerCaseEqualsLiteral("hidden"));
+
+  return PR_FALSE;
+}
+
+
+nsRect makeRectRelativeToGlobalView(nsIFrame *aFrame)
+{
+  NS_ENSURE_TRUE(aFrame, nsRect(0,0,0,0));
+  nsCOMPtr<nsIDOMNode> nsNode = do_QueryInterface(aFrame->GetContent());
+  return makeRectRelativeToGlobalView(nsNode);
+}
+
+nsRect makeRectRelativeToGlobalView(nsIDOMNode *aNode)
+{
+  nsRect result(0,0,0,0);
+  if (!aNode) return result; nsCOMPtr<nsIDOMNSElement> nsElem = do_QueryInterface(aNode);
+  NS_ENSURE_TRUE(nsElem, result);
+  nsCOMPtr<nsIDOMClientRect> domrect;
+  nsElem->GetBoundingClientRect(getter_AddRefs(domrect));
+  float pleft,pright,ptop,pbottom;
+  domrect->GetLeft(&pleft);
+  domrect->GetRight(&pright);
+  domrect->GetTop(&ptop);
+  domrect->GetBottom(&pbottom);
+
+  result = nsRect(pleft, ptop, abs(pright - pleft), abs(pbottom - ptop));
+
+  if (result.width && result.height) return result;
+  // Some <a> links (ex: google.com 1 2 3 4 5 ...) have size 0
+  // Check their parent
+  nsCOMPtr<nsIDOMNode> node = do_QueryInterface(nsElem);
+  if (!node) return result; nsCOMPtr<nsIDOMNode> child;
+  node->GetFirstChild(getter_AddRefs(child));
+  if (!child) return result;
+
+  return makeRectRelativeToGlobalView(child);
+}
+
+
+void poly2Rect(int sides, nscoord* coord, nsRect* rect)
+{
+  nscoord x1, x2, y1, y2, xtmp, ytmp;
+  x1 = x2 = coord[0];
+  y1 = y2 = coord[1];
+  for (PRInt32 i = 2; i < sides; i += 2)
+  {
+    xtmp = coord[i];
+    ytmp = coord[i+1];
+    x1 = x1 < xtmp ? x1 : xtmp;
+    y1 = y1 < ytmp ? y1 : ytmp;
+    x2 = x2 > xtmp ? x2 : xtmp;
+    y2 = y2 > ytmp ? y2 : ytmp;
+  }
+  rect->SetRect(x1, y1, x2, y2);
+}
+
+void getRectOfAreaElement(nsIFrame* f, nsIDOMHTMLAreaElement* e, nsRect* r)
+{
+  if (!f || !e || !r)
+    return;
+
+  // RECT !!
+  nsRect frameRect = makeRectRelativeToGlobalView(f);
+
+  if (frameRect.width == 0)
+    frameRect.width = 1;
+  if (frameRect.height == 0)
+    frameRect.height = 1;
+
+  nsPoint offset;
+  offset.x = frameRect.x;
+  offset.y = frameRect.y;
+
+
+  nsAutoString coordstr;
+  e->GetCoords(coordstr);
+
+  NS_ConvertUTF16toUTF8 cp (coordstr);
+
+  PRInt32 count;
+  nscoord* coords = lo_parse_coord_list((char*) cp.get(), &count);
+
+  // FIX what about other shapes?
+
+  if (count == 4)
+  {
+    //                x          y          width                  height
+    frameRect.SetRect(coords[0], coords[1], coords[2] - coords[0], coords[3] - coords[1]);
+
+    frameRect.x += offset.x;
+    frameRect.y += offset.y;
+  }
+  else if (count >=6)
+    poly2Rect(count, coords, &frameRect);
+#ifdef DEBUG_dougt
+  else
+    printf("area count not supported!! %d\n", count);
+#endif
+
+  // find the center of the rect.
+
+  frameRect.x = frameRect.x + (frameRect.width / 2) - 1;
+  frameRect.width = 2;
+  frameRect.y = frameRect.y + (frameRect.height / 2) - 1;
+  frameRect.height = 2;
+
+  *r = frameRect;
+}
+
+// we want to determine if going in the |direction|
+// direction from focusedRect will intercept the frameRect
+
+PRBool isRectInDirection(int direction, nsRect& focusedRect, nsRect& frameRect)
+{
+  if (direction == eNavLeft)
+  {
+    int middle = frameRect.x + abs(frameRect.width)/2;
+    return (middle < focusedRect.x);
+  }
+
+  if (direction == eNavRight)
+  {
+    int middle = frameRect.x + abs(frameRect.width)/2;
+    return (middle  > focusedRect.x + abs(focusedRect.width));
+  }
+
+  if (direction == eNavUp)
+  {
+    int middle = frameRect.y + abs(frameRect.height)/2;
+    // return (middle < focusedRect.y);
+    return (frameRect.y < focusedRect.y);
+  }
+
+  if (direction == eNavDown)
+  {
+    int middle = frameRect.y + abs(frameRect.height)/2;
+    // return (middle > focusedRect.y + abs(focusedRect.height));
+    // displayRectProperties(focusedRect, frameRect);
+    return (frameRect.y > focusedRect.y);
+  }
+  return PR_FALSE;
+}
+
+// takesSuperPrecedence means that is is a very preferable target
+// where the middle falls between the top or bottom of the current rect
+PRBool takesSuperPrecedence(int direction, nsRect& c, nsRect& t)
+{
+  PRBool rv = PR_FALSE;
+
+  if (direction == eNavLeft || direction == eNavRight)
+  {
+    int tMiddle = t.y + abs(t.height)/2;
+    int tBottom = t.y + abs(t.height);
+    int tEnd    = t.x + abs(t.width);
+
+    int cBottom = c.y + abs(c.height);
+    int cEnd    = c.x + abs(c.width);
+
+    if (direction == eNavLeft && tEnd > c.x) return PR_FALSE;
+
+    if (direction == eNavRight && t.x < cEnd) return PR_FALSE;
+
+    if (t.y >= c.y && t.y <= cBottom             ||
+        tMiddle >= c.y && tMiddle <= cBottom     ||
+        tBottom >= c.y && tBottom <= cBottom     ||
+        t.y == c.y                               ||
+        tBottom == cBottom                       ||
+        t.y <= c.y && tBottom >= cBottom)
+      rv = PR_TRUE;
+  }
+
+  if (direction == eNavUp || direction == eNavDown)
+  {
+    int tMiddle = t.x + abs(t.width)/2;
+    int tEnd    = t.x + abs(t.width);
+    int tBottom = t.y + abs(t.height);
+
+    int cEnd    = c.x + abs(c.width);
+    int cBottom = c.y + abs(c.height);
+
+    if (direction == eNavUp && t.y > c.y) return PR_FALSE;
+
+    if (direction == eNavDown && t.y < c.y) return PR_FALSE;
+
+    if (tMiddle >= c.x && tMiddle <= cEnd ||
+        t.x >= c.x && t.x <= cEnd         ||
+        c.x == t.x                        ||
+        cEnd == tEnd                      ||
+        tEnd >= c.x && tEnd <= cEnd       ||
+        t.x <= c.x && tEnd >= cEnd)
+      rv = PR_TRUE;
+  }
+
+  return rv;
+}
+
+PRBool takesPrecedence(int direction, nsRect& c, nsRect& t)
+{
+  PRBool rv = PR_FALSE;
+
+  if (direction == eNavLeft || direction == eNavRight)
+  {
+    int half = abs(c.height)/2;
+    int minY(c.y/* - half*/);
+    int maxY(c.y + abs(c.height)/* + half*/);
+
+    int tMiddle = t.y + abs(t.height)/2;
+    int tBottom = t.y + abs(t.height);
+
+    int cBottom = c.y + abs(c.height);
+
+    if (t.y >= minY && t.y <=  maxY              ||
+        tBottom >= minY && tBottom <= maxY       ||
+        tMiddle >= c.y && tMiddle <= cBottom     ||
+        t.y >= c.y && t.y <= cBottom             ||
+        tBottom >= c.y && tBottom <= cBottom     ||
+        t.y <= c.y && tBottom >= cBottom)
+      rv = PR_TRUE;
+  }
+
+  if (direction == eNavUp || direction == eNavDown)
+  {
+    int half = abs(c.width)/2;
+    int minX(c.x /*- half*/);
+    int maxX(c.x + abs(c.width)/* + half*/);
+
+    int cEnd = c.x + abs(c.width);
+    int tEnd = t.x + abs(t.width);
+
+    if (t.x >= minX && t.x <=  maxX  || tEnd >= minX && tEnd <= maxX)
+      rv = PR_TRUE;
+  }
+
+  return rv;
+}
+
+PRInt64 spatialDistance(int direction, nsRect& a, nsRect& b)
+{
+  PRBool inlineNavigation = PR_FALSE;
+  nsPoint m, n;
+
+  if (direction == eNavLeft)
+  {
+    //  |---|
+    //  |---|
+    //
+    //  |---|  |---|
+    //  |---|  |---|
+    //
+    //  |---|
+    //  |---|
+    //
+
+    if (a.y > b.y + b.height)
+    {
+      // the b rect is above a.
+      m.x = a.x;
+      m.y = a.y;
+      n.x = b.x + b.width;
+      n.y = b.y + b.height;
+    }
+    else if (a.y + a.height < b.y)
+    {
+      // the b rect is below a.
+      m.x = a.x;
+      m.y = a.y + a.height;
+      n.x = b.x + b.width;
+      n.y = b.y;
+    }
+    else
+    {
+      m.x = a.x;
+      m.y = 0;
+      n.x = b.x + b.width;
+      n.y = 0;
+
+      //      m.x = (a.x + (a.width / 2));
+      //      m.y = (a.y + (a.height / 2));
+      //      n.x = (b.x + (b.width / 2));
+      //      n.y = (b.y + (b.height / 2));
+
+    }
+  }
+  else if (direction == eNavRight)
+  {
+
+    //         |---|
+    //         |---|
+    //
+    //  |---|  |---|
+    //  |---|  |---|
+    //
+    //         |---|
+    //         |---|
+    //
+
+    // printf("   CUR: a.y (%d), a.x (%d), a.width (%d), a.height (%d)\n", a.y, a.x, a.width, a.height);
+    // printf("TARGET: b.y (%d), b.x (%d), b.width (%d), b.height (%d)\n", b.y, b.x, b.width, b.height);
+
+    if (a.y > b.y + b.height)
+    {
+      // the b rect is above a.
+      m.x = a.x + a.width;
+      m.y = a.y;
+      n.x = b.x;
+      n.y = b.y + b.height;
+    }
+    else if (a.y + a.height < b.y)
+    {
+      // the b rect is below a.
+      m.x = a.x + a.width;
+      m.y = a.y + a.height;
+      n.x = b.x;
+      n.y = b.y;
+    }
+    else
+    {
+      m.x = a.x + a.width;
+      m.y = 0;
+      n.x = b.x;
+      n.y = 0;
+
+      //      m.x = (a.x + (a.width / 2));
+      //      m.y = (a.y + (a.height / 2));
+      //      n.x = (b.x + (b.width / 2));
+      //      n.y = (b.y + (b.height / 2));
+    }
+  }
+  else if (direction == eNavUp)
+  {
+
+    //  |---|  |---|  |---|
+    //  |---|  |---|  |---|
+    //
+    //         |---|
+    //         |---|
+    //
+
+    if (a.x > b.x + b.width)
+    {
+      // the b rect is to the left of a.
+      m.x = a.x;
+      m.y = a.y;
+      n.x = b.x + b.width;
+      n.y = b.y + b.height;
+    }
+    else if (a.x + a.width < b.x)
+    {
+      // the b rect is to the right of a
+      m.x = a.x + a.width;
+      m.y = a.y;
+      n.x = b.x;
+      n.y = b.y + b.height;
+    }
+    else
+    {
+      // both b and a share some common x's.
+      m.x = 0;
+      m.y = a.y;
+      n.x = 0;
+      n.y = b.y + b.height;
+
+      //      m.x = (a.x + (a.width / 2));
+      //      m.y = (a.y + (a.height / 2));
+      //      n.x = (b.x + (b.width / 2));
+      //      n.y = (b.y + (b.height / 2));
+    }
+  }
+  else if (direction == eNavDown)
+  {
+    //         |---|
+    //         |---|
+    //
+    //  |---|  |---|  |---|
+    //  |---|  |---|  |---|
+    //
+
+    if (a.x > b.x + b.width)
+    {
+      // the b rect is to the left of a.
+      m.x = a.x;
+      m.y = a.y + a.height;
+      n.x = b.x + b.width;
+      n.y = b.y;
+    }
+    else if (a.x + a.width < b.x)
+    {
+      // the b rect is to the right of a
+      m.x = a.x + a.width;
+      m.y = a.y + a.height;
+      n.x = b.x;
+      n.y = b.y;
+    }
+    else
+    {
+      // both b and a share some common x's.
+      m.x = 0;
+      m.y = a.y + a.height;
+      n.x = 0;
+      n.y = b.y;
+
+      //      m.x = (a.x + (a.width / 2));
+      //      m.y = (a.y + (a.height / 2));
+      //      n.x = (b.x + (b.width / 2));
+      //      n.y = (b.y + (b.height / 2));
+    }
+  }
+
+  // a is always the currently focused rect.
+
+  nsRect scopedRect = a;
+  scopedRect.Inflate(gRectFudge, gRectFudge);
+
+  if (direction == eNavLeft)
+  {
+    scopedRect.x = 0;
+    scopedRect.width = nscoord_MAX;
+    if (scopedRect.Intersects(b))
+      inlineNavigation = PR_TRUE;
+  }
+  else if (direction == eNavRight)
+  {
+    scopedRect.width = nscoord_MAX;
+    if (scopedRect.Intersects(b))
+      inlineNavigation = PR_TRUE;
+  }
+  else if (direction == eNavUp)
+  {
+    scopedRect.y = 0;
+    scopedRect.height = nscoord_MAX;
+    if (scopedRect.Intersects(b))
+      inlineNavigation = PR_TRUE;
+  }
+  else if (direction == eNavDown)
+  {
+    scopedRect.height = nscoord_MAX;
+    if (scopedRect.Intersects(b))
+      inlineNavigation = PR_TRUE;
+  }
+
+  PRInt64 d = ((m.x-n.x)*(m.x-n.x)) + ((m.y-n.y)*(m.y-n.y));
+
+  if(d<0)
+    d=d*(-1);
+
+  if (inlineNavigation)
+	d /= gDirectionalBias;
+
+  return d;
+}
+
+// sqrt( (x1 - x2)2 + (y1 - y2)2 )
+PRInt64 getPrecedentDistance(int direction, nsRect& c, nsRect& t)
+{
+  PRInt64 rv = LL_MaxInt();
+  PRInt64 sec = LL_MaxInt();
+
+  if (direction == eNavLeft)
+  {
+    int cY(c.y + abs(c.height)/2), tY(t.y + abs(t.height)/2);
+    int cX(c.x), tX(t.x + abs(t.width));
+
+    int p = ((cX - tX)*(cX - tX)) + ((cY - tY)*(cY - tY));
+
+    sec = sqrt(p);
+
+    p = ((c.x - t.x)*(c.x - t.x)) + ((c.y - t.y)*(c.y - t.y));
+
+    rv = sqrt(p);
+
+    if (sec < rv && c.y == t.y) rv = sec;
+  }
+
+  if (direction == eNavRight)
+  {
+    int cY(c.y + abs(c.height)/2), tY(t.y + abs(t.height)/2);
+    int cX(c.x + abs(c.width)), tX(t.x);
+
+    int p = ((tX - cX)*(tX - cX)) + ((tY - cY)*(tY - cY));
+
+    sec = sqrt(p);
+
+    p = ((t.x - c.x)*(t.x - c.x)) + ((t.y - c.y)*(t.y - c.y));
+
+    rv = sqrt(p);
+
+    if (sec < rv && c.y == t.y) rv = sec;
+  }
+
+  if (direction == eNavUp)
+  {
+    int cX(c.x + abs(c.width)/2), tX(t.x + abs(t.width)/2);
+    int cY(c.y), tY(t.y + abs(t.height));
+
+    int p = ((cX - tX)*(cX - tX)) + ((cY - tY)*(cY - tY));
+
+    sec = sqrt(p);
+
+    p = ((c.x - t.x)*(c.x - t.x)) + ((c.y - t.y)*(c.y - t.y));
+
+    rv = sqrt(p);
+
+    if (sec < rv && c.x == t.x) rv = sec;
+
+    sec = (c.y - t.y);
+
+    if (sec < rv) rv = sec;
+  }
+
+  if (direction == eNavDown)
+  {
+    // get middle X for current and target rects
+    int cX(c.x + abs(c.width)/2), tX(t.x + abs(t.width)/2);
+    int cY(c.y + abs(c.height)/2), tY(t.y + abs(t.height)/2);
+
+    int p = ((tX - cX)*(tX - cX)) + ((tY - cY)*(tY - cY));
+
+    sec = sqrt(p);
+
+    p = ((t.x - c.x)*(t.x - c.x)) + ((t.y - c.y)*(t.y - c.y));
+
+    rv = sqrt(p);
+
+    if (sec < rv && c.x == t.x) rv = sec;
+
+    sec = (t.y - c.y);
+
+    if (sec < rv) rv = sec;
+  }
+
+  return abs(rv);
+}
+
+void useImageIf (nsIContent* aContent, nsRect& r)
+{
+  nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aContent);
+  if (node)
+  {
+    nsCOMPtr<nsIDOMNodeList> children;
+    node->GetChildNodes(getter_AddRefs(children));
+
+    if (!children) return;
+
+    PRUint32 childCount = 0;
+    children->GetLength(&childCount);
+
+    for (PRUint32 i=0; i<childCount; ++i)
+    {
+      nsCOMPtr<nsIDOMNode> child;
+      children->Item(i, getter_AddRefs(child));
+
+      if (child)
+      {
+        nsString str;
+        child->GetNodeName(str);
+
+        nsCOMPtr<nsIDOMHTMLImageElement> img(do_QueryInterface(child));
+
+        if (img)
+        {
+          PRInt32 width, height;
+
+          img->GetWidth(&width);
+          img->GetHeight(&height);
+
+          nsAutoString src, alt;
+          img->GetSrc(src);
+          img->GetAlt(alt);
+
+          /********************************************
+          printf("<img src=\"%s\" alt=\"%s\" width=\"%d\" height=\"%d\">\n",
+                     NS_ConvertUTF16toUTF8(src).get(), NS_ConvertUTF16toUTF8(alt).get(),
+                     width, height);
+          ********************************************/
+
+          r.width = width;
+          r.height = height;
+
+          nsRect nr = makeRectRelativeToGlobalView(img);
+
+          r.x = nr.x;
+          r.y = nr.y;
+        }
+      }
+    }
+  }
+}
+
+void GetWindowFromDocument(nsIDOMDocument* aDocument, nsIDOMWindowInternal** aWindow)
+{
+  nsCOMPtr<nsIDOMDocumentView> docview = do_QueryInterface(aDocument);
+
+  nsCOMPtr<nsIDOMAbstractView> view;
+  docview->GetDefaultView(getter_AddRefs(view));
+  if (!view) return;
+
+  nsCOMPtr<nsIDOMWindowInternal> window = do_QueryInterface(view);
+  NS_IF_ADDREF(*aWindow = window);
+}
+
+PRBool IsPartiallyVisible(nsIPresShell* shell, nsIFrame* frame, PRBool aForce)
+{
+   // We need to know if at least a kMinPixels around the object is visible
+   // Otherwise it will be marked STATE_OFFSCREEN and STATE_INVISIBLE
+
+   const PRUint16 kMinPixels  = 12;
+    // Set up the variables we need, return false if we can't get at them all
+
+   nsIViewManager* viewManager = shell->GetViewManager();
+   if (!viewManager)
+     return PR_FALSE;
+   if (!frame)
+     return PR_FALSE;
+   // If visibility:hidden or visibility:collapsed then mark with STATE_INVISIBLE
+   if (!frame->GetStyleVisibility()->IsVisible())
+   {
+       return PR_FALSE;
+   }
+
+   nsPresContext *presContext = shell->GetPresContext();
+   if (!presContext)
+     return PR_FALSE;
+
+   // Get the bounds of the current frame, relative to the current view.
+   // We don't use the more accurate GetBoundsRect, because that is more expensive
+   // and the STATE_OFFSCREEN flag that this is used for only needs to be a rough indicator
+
+   nsRect relFrameRect = frame->GetRect();
+   nsPoint frameOffset;
+   nsIView *containingView = frame->GetViewExternal();
+   if (!containingView) {
+     frame->GetOffsetFromView(frameOffset, &containingView);
+     if (!containingView)
+       return PR_FALSE;  // no view -- not visible
+     relFrameRect.x = frameOffset.x;
+     relFrameRect.y = frameOffset.y;
+   }
+   relFrameRect.width +=1;
+   relFrameRect.height +=1;
+
+   PRUint16 minPixels = PRUint16(nsPresContext::CSSPixelsToAppUnits(kMinPixels));
+   nsRectVisibility rectVisibility;
+   viewManager->GetRectVisibility(containingView, relFrameRect,
+                                  minPixels,
+                                  &rectVisibility);
+
+   if (rectVisibility == nsRectVisibility_kVisible
+      ||(aForce &&
+      (
+        rectVisibility == nsRectVisibility_kAboveViewport
+        || rectVisibility == nsRectVisibility_kBelowViewport
+        || rectVisibility == nsRectVisibility_kLeftOfViewport
+        || rectVisibility == nsRectVisibility_kRightOfViewport
+      )) ||
+      (rectVisibility == nsRectVisibility_kZeroAreaRect && frame->GetNextInFlow())) {
+     // This view says it is visible, but we need to check the parent view chain :(
+     // Note: zero area rects can occur in the first frame of a multi-frame text flow,
+     //       in which case the next frame exists because the text flow is visible
+     while ((containingView = containingView->GetParent()) != nsnull) {
+       if (containingView->GetVisibility() == nsViewVisibility_kHide) {
+         return PR_FALSE;
+       }
+     }
+     return PR_TRUE;
+   }
+
+   return PR_FALSE;
+ }
+
+
+const static PRInt32 gScrollOffset = (26*3);
+
+
+void ScrollWindow(int direction, nsIDOMWindow* contentWindow)
+{
+  printf("ScrollWindow ...\n");
+
+  if (!contentWindow) return;
+
+  if (direction == eNavLeft)
+    contentWindow->ScrollBy(-1* gScrollOffset, 0);
+  else if (direction == eNavRight)
+    contentWindow->ScrollBy(gScrollOffset, 0);
+  else if (direction == eNavUp)
+    contentWindow->ScrollBy(0, -1 * gScrollOffset);
+  else
+    contentWindow->ScrollBy(0, gScrollOffset);
+}
