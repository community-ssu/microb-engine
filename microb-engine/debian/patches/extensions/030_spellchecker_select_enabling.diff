# Spellchecker: Enabling SELECT dialog
# Allow to use spellchecker by using standart prompt select interface
Index: mozilla/extensions/spellcheck/src/mozInlineSpellChecker.cpp
===================================================================
--- mozilla.orig/extensions/spellcheck/src/mozInlineSpellChecker.cpp
+++ mozilla/extensions/spellcheck/src/mozInlineSpellChecker.cpp
@@ -59,16 +59,20 @@
  * true when we get any change, and false once there is no possibility
  * something changed that we need to check on navigation. Navigation events
  * tend to be a little tricky because we want to check the current word on
  * exit if something has changed. If we navigate inside the word, we don't want
  * to do anything. As a result, this flag is cleared in FinishNavigationEvent
  * when we know that we are checking as a result of navigation.
  */
 
+#include "nsIPrompt.h"
+#include "nsIDOMWindow.h"
+#include "nsIDOMWindowInternal.h"
+#include "nsIWindowWatcher.h"
 #include "mozInlineSpellChecker.h"
 #include "mozInlineSpellWordUtil.h"
 #include "mozISpellI18NManager.h"
 #include "nsCOMPtr.h"
 #include "nsCRT.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMDocumentRange.h"
@@ -115,22 +119,41 @@
 
 // This number is the number of checked words a misspelled word counts for
 // when we're checking the time to see if the alloted time is up for
 // spellchecking. Misspelled words take longer to process since we have to
 // create a range, so they count more. The exact number isn't very important
 // since this just controls how often we check the current time.
 #define MISSPELLED_WORD_COUNT_PENALTY 4
 
+// This is the max number of correct words to be suggested to the user
+#define MAX_SUGGESTIONS 15
+
+// This is the max number of dictionaries to be suggested to the user
+#define MAX_DICTIONARIES 50
+
+// The preferences strin for spellchecker dictionary
+#define PREF_SPELLCHECKER_DICTIONARY "spellchecker.dictionary"
 
 static PRBool ContentIsDescendantOf(nsINode* aPossibleDescendant,
                                     nsINode* aPossibleAncestor);
 
 static const char kMaxSpellCheckSelectionSize[] = "extensions.spellcheck.inline.max-misspellings";
 
+/** Suggestion dialog options
+  */
+enum
+{
+  DIALOG_NONE = -1,
+  DIALOG_ADD,
+  DIALOG_IGNORE,
+  DIALOG_DICTIONARY,
+  DIALOG_OTHER
+};
+
 mozInlineSpellStatus::mozInlineSpellStatus(mozInlineSpellChecker* aSpellChecker)
     : mSpellChecker(aSpellChecker), mWordCount(0)
 {
 }
 
 // mozInlineSpellStatus::InitForEditorChange
 //
 //    This is the most complicated case. For changes, we need to compute the
@@ -1663,16 +1686,264 @@
   if (shouldPost) {
     rv = ScheduleSpellCheck(status);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return NS_OK;
 }
 
+nsresult
+FreeOptionList(PRUnichar **list, PRInt32 counter)
+{
+  for(PRInt32 i = 0; i < counter; i++) {
+    if (list[i])
+      NS_Free(list[i]);
+  }
+  return NS_OK;
+}
+
+nsresult
+ShowSuggestionsDialog(PRUnichar *currentWord, PRInt32 suggestionsCount, const PRUnichar **selectList, PRInt32 *outSelection, PRBool *retval)
+{
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIDOMWindow> DOMWindow;
+
+  nsCOMPtr<nsIWindowWatcher> watcher = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  watcher->GetActiveWindow(getter_AddRefs(DOMWindow));
+  nsCOMPtr<nsIDOMWindowInternal> winint = do_QueryInterface(DOMWindow, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIPrompt> prompt;
+  winint->GetPrompter(getter_AddRefs(prompt));
+  if (!prompt)
+    return NS_ERROR_FAILURE;
+
+  prompt->Select(NS_LITERAL_STRING("Spellcheck suggestions").get(),
+                 nsnull, suggestionsCount, selectList, outSelection, retval);
+  return NS_OK;
+}
+
+nsresult
+SetDictionaryPreference(const PRUnichar *aDictionaryString)
+{
+    nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
+    NS_ENSURE_STATE(prefs);
+
+    nsresult rv = prefs->SetCharPref(PREF_SPELLCHECKER_DICTIONARY,
+                            NS_ConvertUTF16toUTF8(aDictionaryString).get());
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIPrefService> prefService = do_QueryInterface(prefs);
+    NS_ENSURE_STATE(prefService);
+
+    rv = prefService->SavePrefFile(nsnull);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
+}
+
+nsresult
+ShowDictionaryDialog(nsIEditorSpellCheck *aSpellCheck, PRBool *retval)
+{
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIDOMWindow> DOMWindow;
+
+  nsCOMPtr<nsIWindowWatcher> watcher = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  watcher->GetActiveWindow(getter_AddRefs(DOMWindow));
+  nsCOMPtr<nsIDOMWindowInternal> winint = do_QueryInterface(DOMWindow, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIPrompt> prompt;
+  winint->GetPrompter(getter_AddRefs(prompt));
+  if (!prompt)
+    return NS_ERROR_FAILURE;
+
+  PRUint32 count;
+  PRInt32 outSelection = DIALOG_NONE;
+  PRUnichar **selectList;
+
+  aSpellCheck->GetDictionaryList(&selectList, &count);
+  prompt->Select(NS_LITERAL_STRING("Dictionary chooser").get(),
+                 NS_LITERAL_STRING("Choose the default dictionary:").get(),
+                count, (const PRUnichar**)selectList, &outSelection, retval);
+
+  if (*retval == PR_TRUE) {
+    // user pressed the ok button
+    PRUnichar *currentDict;
+    aSpellCheck->GetCurrentDictionary(&currentDict);
+    if (!NS_strcmp(currentDict, selectList[outSelection])) {
+      *retval = PR_FALSE;
+      return NS_OK;
+    }
+    if (currentDict)
+      NS_Free(currentDict);
+    aSpellCheck->SetCurrentDictionary(selectList[outSelection]);
+    aSpellCheck->SaveDefaultDictionary();
+
+    SetDictionaryPreference(selectList[outSelection]);
+  }
+  NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(count, selectList);
+  return NS_OK;
+}
+
+PRBool
+IsValidAlpha(PRUnichar alpha)
+{
+    /* FIXME */
+    return ((alpha >= 128 && alpha <= 165)
+            || (alpha >= 181 && alpha <= 183)
+            || (alpha >= 189 && alpha <= 190)
+            || (alpha >= 198 && alpha <= 199)
+            || (alpha >= 207 && alpha <= 216)
+            || (alpha == 222)
+            || (alpha >= 224 && alpha <= 237)
+            || (alpha >= 244 && alpha <= 245));
+}
+
+// verify if the current word contents non-alphanumeric characters
+// and ignores any trailing character different than alphanumeric characters
+PRBool
+FixCurrentSelection(PRUnichar **currentWord, nsISelectionController *aSelectionController)
+{
+  nsString aTempString(*currentWord);
+  PRInt32 stringLength = aTempString.Length();
+  PRInt32 i = stringLength-1;
+  PRBool foundWord = PR_FALSE;
+  while (i >= 0) {
+    // a word containing numbers is not valid a word
+    if (nsCRT::IsAsciiDigit((*currentWord)[i])) return PR_FALSE;
+    if (nsCRT::IsAsciiAlpha((*currentWord)[i])
+        || IsValidAlpha((*currentWord)[i]))
+        foundWord = PR_TRUE;
+    // ignore any trailing character different than alphanumeric characters
+    if (!foundWord) {
+      aSelectionController->CharacterMove(PR_FALSE, PR_TRUE);
+      stringLength--;
+    }
+    i--;
+  }
+  i = aTempString.Length();
+  // remove trailing invalid characters
+  if(stringLength != i) {
+    aTempString.Replace(stringLength, i-1, (PRUnichar)'\0');
+    // update the current word
+    NS_Free(*currentWord);
+    *currentWord = ToNewUnicode(aTempString);
+  }
+  return PR_TRUE;
+}
+
+nsresult
+HandleMisspelledWord(nsIEditor *aEditor, PRBool *isChanged)
+{
+  if (!aEditor)
+    return NS_ERROR_FAILURE;
+  nsresult rv = NS_OK;
+
+  nsCOMPtr<nsIPlaintextEditor> aTextEditor(do_QueryInterface(aEditor, &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // get the current spell checker
+  nsCOMPtr<nsIInlineSpellChecker> aInlineSpellChecker;
+  PRBool retval = PR_TRUE;
+  aEditor->GetInlineSpellChecker(retval, getter_AddRefs(aInlineSpellChecker));
+  nsCOMPtr<nsIEditorSpellCheck> aSpellCheck;
+  aInlineSpellChecker->GetSpellChecker(getter_AddRefs(aSpellCheck));
+
+  // get the selection controller
+  nsCOMPtr<nsISelectionController> aSelectionController;
+  aEditor->GetSelectionController(getter_AddRefs(aSelectionController));
+
+  // get the text selected
+  PRUnichar *currentWord;
+  nsCOMPtr<nsISelection> aSpellCheckSelection;
+  aSelectionController->GetSelection(nsISelectionController::SELECTION_NORMAL,
+                                     getter_AddRefs(aSpellCheckSelection));
+  aSpellCheckSelection->ToString(&currentWord);
+
+  // remove invalid trailing characters and verify is the word is valid
+  PRBool isWord = FixCurrentSelection(&currentWord, aSelectionController);
+
+  // verify the current word
+  PRBool isMisspelled = PR_TRUE;
+  aSpellCheck->CheckCurrentWord(currentWord, &isMisspelled);
+
+  if (isWord && isMisspelled) {
+    // the word is misspelled: give some options to the user
+    PRUnichar *aSuggestionList[MAX_SUGGESTIONS+DIALOG_OTHER];
+    aSuggestionList[DIALOG_ADD] = ToNewUnicode(NS_ConvertUTF8toUTF16("Add to dictionary"));
+    aSuggestionList[DIALOG_IGNORE] = ToNewUnicode(NS_ConvertUTF8toUTF16("Ignore this word"));
+    aSuggestionList[DIALOG_DICTIONARY] = ToNewUnicode(NS_ConvertUTF8toUTF16("Change dictionary..."));
+
+    PRUint32 aSuggestionCount = DIALOG_OTHER;
+    do {
+      // get some suggestions
+      aSpellCheck->GetSuggestedWord(&aSuggestionList[aSuggestionCount]);
+      if (!NS_strcmp(aSuggestionList[aSuggestionCount], NS_LITERAL_STRING("").get()))
+        break;
+      aSuggestionCount++;
+    } while(aSuggestionCount < MAX_SUGGESTIONS+DIALOG_OTHER);
+
+    // show a dialog containing the options
+    PRBool retval = PR_TRUE;
+    PRInt32 outSelection = DIALOG_IGNORE;
+    ShowSuggestionsDialog(currentWord, aSuggestionCount,
+                          (const PRUnichar**) aSuggestionList, &outSelection,
+                           &retval);
+
+    if (retval == PR_FALSE) {
+      // user pressed the cancel button
+      *isChanged = PR_FALSE;
+      return NS_OK;
+    }
+    nsString aTempString(currentWord);
+    switch(outSelection) {
+    case DIALOG_ADD:
+      // add the current word to the dictionary
+      aInlineSpellChecker->AddWordToDictionary(aTempString);
+      // word added to dictionary
+      *isChanged = PR_TRUE;
+      break;
+    case DIALOG_IGNORE:
+      // ignore the current word
+      aInlineSpellChecker->IgnoreWord(aTempString);
+      // word ignored by user
+      *isChanged = PR_TRUE;
+      break;
+    case DIALOG_DICTIONARY:
+      // change default dictionary
+      ShowDictionaryDialog(aSpellCheck, &retval);
+      if (retval) {
+        // user changed default dictionary
+        *isChanged = PR_TRUE;
+      }
+      break;
+    default:
+      // replace the misspelled word
+      aEditor->DeleteSelection(nsIEditor::eNone);
+      nsString newword(aSuggestionList[outSelection]);
+      aTextEditor->InsertText(newword);
+      aSpellCheck->ReplaceWord(currentWord, aSuggestionList[outSelection], PR_FALSE);
+      // user fixed the misspelled word
+      *isChanged = PR_FALSE;
+      break;
+    }
+    // Free the suggestion list
+    FreeOptionList(aSuggestionList, aSuggestionCount);
+  }
+  if (currentWord)
+    NS_Free(currentWord);
+  return NS_OK;
+}
+
 NS_IMETHODIMP mozInlineSpellChecker::HandleEvent(nsIDOMEvent* aEvent)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP mozInlineSpellChecker::Focus(nsIDOMEvent* aEvent)
 {
   return NS_OK;
@@ -1708,16 +1979,36 @@
 
 NS_IMETHODIMP mozInlineSpellChecker::MouseUp(nsIDOMEvent* aMouseEvent)
 {
   return NS_OK;
 }
 
 NS_IMETHODIMP mozInlineSpellChecker::MouseDblClick(nsIDOMEvent* aMouseEvent)
 {
+  nsresult rv = NS_OK;
+  PRBool checkAgain = PR_FALSE;
+
+  // get the current editor
+  nsCOMPtr<nsIEditor> aEditor = do_QueryReferent(mEditor, &rv);
+  NS_ENSURE_TRUE(aEditor, NS_ERROR_NULL_POINTER);
+
+  rv = HandleMisspelledWord(aEditor, &checkAgain);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // the user changed the default dictionary
+  // or added the current word to it
+  if (checkAgain) {
+    mozInlineSpellStatus status(this);
+
+    rv = status.InitForSelection();
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return ScheduleSpellCheck(status);
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP mozInlineSpellChecker::MouseOver(nsIDOMEvent* aMouseEvent)
 {
   return NS_OK;
 }
 
