Index: mozilla/gfx/cairo/cairo/src/cairo-analysis-surface.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-analysis-surface.c
+++ mozilla/gfx/cairo/cairo/src/cairo-analysis-surface.c
@@ -112,17 +112,17 @@ _cairo_analysis_surface_stroke (void			*
     cairo_status_t	     status;
 
     if (!surface->target->backend->stroke)
 	status = CAIRO_INT_STATUS_UNSUPPORTED;
     else
 	status = (*surface->target->backend->stroke) (surface->target, op,
 						      source, path, style,
 						      ctm, ctm_inverse,
-						      tolerance, antialias);
+						      tolerance, CAIRO_ANTIALIAS_NONE);
     if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
 	surface->fallback = TRUE;
 	status = CAIRO_STATUS_SUCCESS;
     }
     return status;
 }
 
 static cairo_int_status_t
@@ -137,17 +137,17 @@ _cairo_analysis_surface_fill (void			*ab
     cairo_analysis_surface_t *surface = abstract_surface;
     cairo_status_t	     status;
 
     if (!surface->target->backend->fill)
 	status = CAIRO_INT_STATUS_UNSUPPORTED;
     else
 	status = (*surface->target->backend->fill) (surface->target, op,
 						    source, path, fill_rule,
-						    tolerance, antialias);
+						    tolerance, CAIRO_ANTIALIAS_NONE);
     if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
 	surface->fallback = TRUE;
 	status = CAIRO_STATUS_SUCCESS;
     }
     return status;
 }
 
 static cairo_int_status_t
Index: mozilla/gfx/cairo/cairo/src/cairo-clip.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-clip.c
+++ mozilla/gfx/cairo/cairo/src/cairo-clip.c
@@ -288,17 +288,17 @@ _cairo_clip_intersect_path (cairo_clip_t
     if (status) {
 	free (clip_path);
 	return status;
     }
 
     clip_path->ref_count = 1;
     clip_path->fill_rule = fill_rule;
     clip_path->tolerance = tolerance;
-    clip_path->antialias = antialias;
+    clip_path->antialias = CAIRO_ANTIALIAS_NONE;
     clip_path->prev = clip->path;
     clip->path = clip_path;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 static cairo_clip_path_t *
 _cairo_clip_path_reference (cairo_clip_path_t *clip_path)
@@ -406,17 +406,17 @@ _cairo_clip_intersect_mask (cairo_clip_t
     /* Render the new clipping path into the new mask surface. */
 
     _cairo_traps_translate (traps, -surface_rect.x, -surface_rect.y);
     _cairo_pattern_init_solid (&pattern.solid, CAIRO_COLOR_WHITE);
 
     status = _cairo_surface_composite_trapezoids (CAIRO_OPERATOR_IN,
 						  &pattern.base,
 						  surface,
-						  antialias,
+						  CAIRO_ANTIALIAS_NONE,
 						  0, 0,
 						  0, 0,
 						  surface_rect.width,
 						  surface_rect.height,
 						  traps->traps,
 						  traps->num_traps);
 
     _cairo_pattern_fini (&pattern.base);
@@ -469,17 +469,17 @@ _cairo_clip_clip (cairo_clip_t       *cl
 		  cairo_antialias_t   antialias,
 		  cairo_surface_t    *target)
 {
     cairo_status_t status;
     cairo_traps_t traps;
 
     status = _cairo_clip_intersect_path (clip,
 					 path, fill_rule, tolerance,
-					 antialias);
+					 CAIRO_ANTIALIAS_NONE);
     if (status == CAIRO_STATUS_SUCCESS)
         clip->serial = _cairo_surface_allocate_clip_serial (target);
 
     if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 	return status;
 
     _cairo_traps_init (&traps);
     status = _cairo_path_fixed_fill_to_traps (path,
@@ -488,17 +488,17 @@ _cairo_clip_clip (cairo_clip_t       *cl
 					      &traps);
     if (status)
 	goto bail;
 
     status = _cairo_clip_intersect_region (clip, &traps, target);
     if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 	goto bail;
 
-    status = _cairo_clip_intersect_mask (clip, &traps, antialias, target);
+    status = _cairo_clip_intersect_mask (clip, &traps, CAIRO_ANTIALIAS_NONE, target);
 
  bail:
     _cairo_traps_fini (&traps);
 
     return status;
 }
 
 void
@@ -538,17 +538,17 @@ _cairo_clip_path_reapply_clip_path (cair
 {
     if (clip_path->prev)
         _cairo_clip_path_reapply_clip_path (clip, clip_path->prev);
 
     _cairo_clip_intersect_path (clip,
                                 &clip_path->path,
                                 clip_path->fill_rule,
                                 clip_path->tolerance,
-                                clip_path->antialias);
+                                CAIRO_ANTIALIAS_NONE);
 }
 
 void
 _cairo_clip_init_deep_copy (cairo_clip_t    *clip,
                             cairo_clip_t    *other,
                             cairo_surface_t *target)
 {
     _cairo_clip_init (clip, target);
Index: mozilla/gfx/cairo/cairo/src/cairo-gstate.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-gstate.c
+++ mozilla/gfx/cairo/cairo/src/cairo-gstate.c
@@ -102,17 +102,17 @@ _cairo_gstate_create (cairo_surface_t *t
 
 static cairo_status_t
 _cairo_gstate_init (cairo_gstate_t  *gstate,
 		    cairo_surface_t *target)
 {
     gstate->op = CAIRO_GSTATE_OPERATOR_DEFAULT;
 
     gstate->tolerance = CAIRO_GSTATE_TOLERANCE_DEFAULT;
-    gstate->antialias = CAIRO_ANTIALIAS_DEFAULT;
+    gstate->antialias = CAIRO_ANTIALIAS_NONE;
 
     _cairo_stroke_style_init (&gstate->stroke_style);
 
     gstate->fill_rule = CAIRO_GSTATE_FILL_RULE_DEFAULT;
 
     gstate->font_face = NULL;
     gstate->scaled_font = NULL;
 
@@ -150,17 +150,17 @@ _cairo_gstate_init (cairo_gstate_t  *gst
 static cairo_status_t
 _cairo_gstate_init_copy (cairo_gstate_t *gstate, cairo_gstate_t *other)
 {
     cairo_status_t status;
 
     gstate->op = other->op;
 
     gstate->tolerance = other->tolerance;
-    gstate->antialias = other->antialias;
+    gstate->antialias = CAIRO_ANTIALIAS_NONE;
 
     status = _cairo_stroke_style_init_copy (&gstate->stroke_style,
 					    &other->stroke_style);
     if (status)
 	return status;
 
     gstate->fill_rule = other->fill_rule;
 
@@ -270,17 +270,17 @@ _cairo_gstate_recursive_apply_clip_path 
     status = _cairo_gstate_recursive_apply_clip_path (gstate, cpath->prev);
     if (status)
 	return status;
 
     return _cairo_clip_clip (&gstate->clip,
 			     &cpath->path,
 			     cpath->fill_rule,
 			     cpath->tolerance,
-			     cpath->antialias,
+			     CAIRO_ANTIALIAS_NONE,
 			     gstate->target);
 }
 
 /**
  * _cairo_gstate_redirect_target:
  * @gstate: a #cairo_gstate_t
  * @child: the new child target
  *
@@ -1140,17 +1140,17 @@ _cairo_gstate_reset_clip (cairo_gstate_t
     return _cairo_clip_reset (&gstate->clip);
 }
 
 cairo_status_t
 _cairo_gstate_clip (cairo_gstate_t *gstate, cairo_path_fixed_t *path)
 {
     return _cairo_clip_clip (&gstate->clip,
 			     path, gstate->fill_rule, gstate->tolerance,
-			     gstate->antialias, gstate->target);
+			     CAIRO_ANTIALIAS_NONE, gstate->target);
 }
 
 cairo_status_t
 _cairo_gstate_clip_extents (cairo_gstate_t *gstate,
 		            double         *x1,
 		            double         *y1,
         		    double         *x2,
         		    double         *y2)
@@ -1564,17 +1564,17 @@ _cairo_gstate_glyph_path (cairo_gstate_t
     return status;
 }
 #undef STACK_GLYPHS_LEN
 
 cairo_status_t
 _cairo_gstate_set_antialias (cairo_gstate_t *gstate,
 			     cairo_antialias_t antialias)
 {
-    gstate->antialias = antialias;
+    gstate->antialias = CAIRO_ANTIALIAS_NONE;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 cairo_antialias_t
 _cairo_gstate_get_antialias (cairo_gstate_t *gstate)
 {
     return gstate->antialias;
Index: mozilla/gfx/cairo/cairo/src/cairo-meta-surface.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-meta-surface.c
+++ mozilla/gfx/cairo/cairo/src/cairo-meta-surface.c
@@ -341,17 +341,17 @@ _cairo_meta_surface_stroke (void			*abst
 
     status = _cairo_stroke_style_init_copy (&command->style, style);
     if (status)
 	goto CLEANUP_PATH;
 
     command->ctm = *ctm;
     command->ctm_inverse = *ctm_inverse;
     command->tolerance = tolerance;
-    command->antialias = antialias;
+    command->antialias = CAIRO_ANTIALIAS_NONE;
 
     status = _cairo_array_append (&meta->commands, &command);
     if (status)
 	goto CLEANUP_STYLE;
 
     return CAIRO_STATUS_SUCCESS;
 
   CLEANUP_STYLE:
@@ -390,17 +390,17 @@ _cairo_meta_surface_fill (void			*abstra
 	goto CLEANUP_COMMAND;
 
     status = _cairo_path_fixed_init_copy (&command->path, path);
     if (status)
 	goto CLEANUP_SOURCE;
 
     command->fill_rule = fill_rule;
     command->tolerance = tolerance;
-    command->antialias = antialias;
+    command->antialias = CAIRO_ANTIALIAS_NONE;
 
     status = _cairo_array_append (&meta->commands, &command);
     if (status)
 	goto CLEANUP_PATH;
 
     return CAIRO_STATUS_SUCCESS;
 
   CLEANUP_PATH:
@@ -528,17 +528,17 @@ _cairo_meta_surface_intersect_clip_path 
 	command->path_pointer = &command->path;
 	meta->is_clipped = TRUE;
     } else {
 	command->path_pointer = NULL;
 	meta->is_clipped = FALSE;
     }
     command->fill_rule = fill_rule;
     command->tolerance = tolerance;
-    command->antialias = antialias;
+    command->antialias = CAIRO_ANTIALIAS_NONE;
 
     status = _cairo_array_append (&meta->commands, &command);
     if (status) {
 	if (path)
 	    _cairo_path_fixed_fini (&command->path);
 	free (command);
 	return status;
     }
@@ -702,27 +702,27 @@ _cairo_meta_surface_replay (cairo_surfac
 	    status = _cairo_surface_stroke (target,
 					    command->stroke.op,
 					    &command->stroke.source.base,
 					    dev_path,
 					    &command->stroke.style,
 					    &dev_ctm,
 					    &dev_ctm_inverse,
 					    command->stroke.tolerance,
-					    command->stroke.antialias);
+					    CAIRO_ANTIALIAS_NONE);
 	    break;
 	}
 	case CAIRO_COMMAND_FILL:
 	    status = _cairo_surface_fill (target,
 					  command->fill.op,
 					  &command->fill.source.base,
 					  dev_path,
 					  command->fill.fill_rule,
 					  command->fill.tolerance,
-					  command->fill.antialias);
+					  CAIRO_ANTIALIAS_NONE);
 	    break;
 	case CAIRO_COMMAND_SHOW_GLYPHS:
 	{
 	    cairo_glyph_t *glyphs = command->show_glyphs.glyphs;
 	    cairo_glyph_t *dev_glyphs = glyphs;
 	    int i, num_glyphs = command->show_glyphs.num_glyphs;
 
 	    if (has_device_transform) {
@@ -754,17 +754,17 @@ _cairo_meta_surface_replay (cairo_surfac
 	    /* XXX Meta surface clipping is broken and requires some
 	     * cairo-gstate.c rewriting.  Work around it for now. */
 	    if (dev_path == NULL)
 		status = _cairo_clip_reset (&clip);
 	    else
 		status = _cairo_clip_clip (&clip, dev_path,
 					   command->intersect_clip_path.fill_rule,
 					   command->intersect_clip_path.tolerance,
-					   command->intersect_clip_path.antialias,
+					   CAIRO_ANTIALIAS_NONE,
 					   target);
 	    break;
 	default:
 	    ASSERT_NOT_REACHED;
 	}
 
 	if (dev_path == &path_copy)
 	    _cairo_path_fixed_fini (&path_copy);
Index: mozilla/gfx/cairo/cairo/src/cairo-surface-fallback.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-surface-fallback.c
+++ mozilla/gfx/cairo/cairo/src/cairo-surface-fallback.c
@@ -485,17 +485,17 @@ _composite_traps_draw_func (void        
     if (dst_x != 0 || dst_y != 0)
 	_cairo_traps_translate (info->traps, - dst_x, - dst_y);
 
     _cairo_pattern_init_solid (&pattern.solid, CAIRO_COLOR_WHITE);
     if (!src)
 	src = &pattern.base;
 
     status = _cairo_surface_composite_trapezoids (op,
-						  src, dst, info->antialias,
+						  src, dst, CAIRO_ANTIALIAS_NONE,
 						  extents->x,         extents->y,
 						  extents->x - dst_x, extents->y - dst_y,
 						  extents->width,     extents->height,
 						  info->traps->traps,
 						  info->traps->num_traps);
     _cairo_pattern_fini (&pattern.base);
 
     return status;
@@ -634,17 +634,17 @@ _clip_and_composite_trapezoids (cairo_pa
 							 CAIRO_COLOR_TRANSPARENT,
 							 clear_region);
 		goto out;
 	    }
 	}
     }
 
     traps_info.traps = traps;
-    traps_info.antialias = antialias;
+    traps_info.antialias = CAIRO_ANTIALIAS_NONE;
 
     status = _clip_and_composite (clip, op, src,
 				  _composite_traps_draw_func, &traps_info,
 				  dst, &extents);
 
  out:
     if (trap_region)
 	pixman_region_destroy (trap_region);
@@ -798,17 +798,17 @@ _cairo_surface_fallback_stroke (cairo_su
 	return status;
     }
 
     _clip_and_composite_trapezoids (source,
 				    op,
 				    surface,
 				    &traps,
 				    surface->clip,
-				    antialias);
+				    CAIRO_ANTIALIAS_NONE);
 
     _cairo_traps_fini (&traps);
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 cairo_status_t
 _cairo_surface_fallback_fill (cairo_surface_t		*surface,
@@ -833,17 +833,17 @@ _cairo_surface_fallback_fill (cairo_surf
 	return status;
     }
 
     status = _clip_and_composite_trapezoids (source,
 					     op,
 					     surface,
 					     &traps,
 					     surface->clip,
-					     antialias);
+					     CAIRO_ANTIALIAS_NONE);
 
     _cairo_traps_fini (&traps);
 
     return status;
 }
 
 typedef struct {
     cairo_scaled_font_t *font;
@@ -1155,17 +1155,17 @@ _cairo_surface_fallback_composite_trapez
 	_cairo_trapezoid_array_translate_and_scale (offset_traps, traps, num_traps,
                                                     - state.image_rect.x, - state.image_rect.y,
                                                     1.0, 1.0);
 	traps = offset_traps;
     }
 
     _cairo_surface_composite_trapezoids (op, pattern,
 					 &state.image->base,
-					 antialias,
+					 CAIRO_ANTIALIAS_NONE,
 					 src_x, src_y,
 					 dst_x - state.image_rect.x,
 					 dst_y - state.image_rect.y,
 					 width, height, traps, num_traps);
     if (offset_traps)
 	free (offset_traps);
 
  DONE:
Index: mozilla/gfx/cairo/cairo/src/cairo-surface.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-surface.c
+++ mozilla/gfx/cairo/cairo/src/cairo-surface.c
@@ -1316,26 +1316,26 @@ _cairo_surface_stroke (cairo_surface_t		
     assert (! surface->is_snapshot);
 
     _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
 
     if (surface->backend->stroke) {
 	status = surface->backend->stroke (surface, op, &dev_source.base,
 					   path, stroke_style,
 					   &dev_ctm, &dev_ctm_inverse,
-					   tolerance, antialias);
+					   tolerance, CAIRO_ANTIALIAS_NONE);
 
 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
             goto FINISH;
     }
 
     status = _cairo_surface_fallback_stroke (surface, op, &dev_source.base,
                                              path, stroke_style,
                                              &dev_ctm, &dev_ctm_inverse,
-                                             tolerance, antialias);
+                                             tolerance, CAIRO_ANTIALIAS_NONE);
 
  FINISH:
     if (dev_path == &real_dev_path)
         _cairo_path_fixed_fini (&real_dev_path);
     _cairo_pattern_fini (&dev_source.base);
 
     return status;
 }
@@ -1354,25 +1354,25 @@ _cairo_surface_fill (cairo_surface_t	*su
 
     assert (! surface->is_snapshot);
 
     _cairo_surface_copy_pattern_for_destination (source, surface, &dev_source.base);
 
     if (surface->backend->fill) {
 	status = surface->backend->fill (surface, op, &dev_source.base,
 					 path, fill_rule,
-					 tolerance, antialias);
+					 tolerance, CAIRO_ANTIALIAS_NONE);
 
 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
             goto FINISH;
     }
 
     status = _cairo_surface_fallback_fill (surface, op, &dev_source.base,
                                            path, fill_rule,
-                                           tolerance, antialias);
+                                           tolerance, CAIRO_ANTIALIAS_NONE);
 
  FINISH:
     _cairo_pattern_fini (&dev_source.base);
 
     return status;
 }
 
 cairo_status_t
@@ -1402,27 +1402,27 @@ _cairo_surface_composite_trapezoids (cai
 	return dst->status;
 
     if (dst->finished)
 	return CAIRO_STATUS_SURFACE_FINISHED;
 
     if (dst->backend->composite_trapezoids) {
 	status = dst->backend->composite_trapezoids (op,
 						     pattern, dst,
-						     antialias,
+						     CAIRO_ANTIALIAS_NONE,
 						     src_x, src_y,
                                                      dst_x, dst_y,
 						     width, height,
 						     traps, num_traps);
 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 	    return status;
     }
 
     return  _cairo_surface_fallback_composite_trapezoids (op, pattern, dst,
-							  antialias,
+							  CAIRO_ANTIALIAS_NONE,
 							  src_x, src_y,
 							  dst_x, dst_y,
 							  width, height,
 							  traps, num_traps);
 }
 
 /* _copy_page and _show_page are unique among _cairo_surface functions
  * in that they will actually return CAIRO_INT_STATUS_UNSUPPORTED
@@ -1592,17 +1592,17 @@ _cairo_surface_intersect_clip_path (cair
 	return CAIRO_STATUS_SURFACE_FINISHED;
 
     assert (surface->backend->intersect_clip_path != NULL);
 
     status = surface->backend->intersect_clip_path (surface,
 						    dev_path,
 						    fill_rule,
 						    tolerance,
-						    antialias);
+						    CAIRO_ANTIALIAS_NONE);
 
     return status;
 }
 
 static cairo_status_t
 _cairo_surface_set_clip_path_recursive (cairo_surface_t *surface,
 					cairo_clip_path_t *clip_path)
 {
@@ -1614,17 +1614,17 @@ _cairo_surface_set_clip_path_recursive (
     status = _cairo_surface_set_clip_path_recursive (surface, clip_path->prev);
     if (status)
 	return status;
 
     return _cairo_surface_intersect_clip_path (surface,
 					       &clip_path->path,
 					       clip_path->fill_rule,
 					       clip_path->tolerance,
-					       clip_path->antialias);
+					       CAIRO_ANTIALIAS_NONE);
 }
 
 /**
  * _cairo_surface_set_clip_path:
  * @surface: the #cairo_surface_t to set the clip on
  * @clip_path: the clip path to set
  * @serial: the clip serial number associated with the clip path
  *
Index: mozilla/gfx/cairo/cairo/src/cairo-xlib-screen.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-xlib-screen.c
+++ mozilla/gfx/cairo/cairo/src/cairo-xlib-screen.c
@@ -229,22 +229,22 @@ _cairo_xlib_init_screen_font_options (ca
     }
 
     if (xft_antialias) {
 	if (subpixel_order == CAIRO_SUBPIXEL_ORDER_DEFAULT)
 	    antialias = CAIRO_ANTIALIAS_GRAY;
 	else
 	    antialias = CAIRO_ANTIALIAS_SUBPIXEL;
     } else {
-	antialias = CAIRO_ANTIALIAS_NONE;
+	antialias = CAIRO_ANTIALIAS_NONE; // ROMAXA CAIRO_ANTIALIAS_NONE
     }
 
     _cairo_font_options_init_default (&info->font_options);
     cairo_font_options_set_hint_style (&info->font_options, hint_style);
-    cairo_font_options_set_antialias (&info->font_options, antialias);
+    cairo_font_options_set_antialias (&info->font_options, antialias); // ROMAXA CAIRO_ANTIALIAS_NONE
     cairo_font_options_set_subpixel_order (&info->font_options, subpixel_order);
 }
 
 CAIRO_MUTEX_DECLARE(_xlib_screen_mutex);
 
 static cairo_xlib_screen_info_t *_cairo_xlib_screen_list = NULL;
 
 /* XXX: From this function we should also run through and cleanup
Index: mozilla/gfx/cairo/cairo/src/cairo.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo.c
+++ mozilla/gfx/cairo/cairo/src/cairo.c
@@ -865,17 +865,17 @@ cairo_set_tolerance (cairo_t *cr, double
  * cairo_font_options_set_antialias().
  **/
 void
 cairo_set_antialias (cairo_t *cr, cairo_antialias_t antialias)
 {
     if (cr->status)
 	return;
 
-    cr->status = _cairo_gstate_set_antialias (cr->gstate, antialias);
+    cr->status = _cairo_gstate_set_antialias (cr->gstate, CAIRO_ANTIALIAS_NONE);
     if (cr->status)
 	_cairo_set_error (cr, cr->status);
 }
 
 /**
  * cairo_set_fill_rule:
  * @cr: a #cairo_t
  * @fill_rule: a fill rule, specified as a #cairo_fill_rule_t
Index: mozilla/gfx/cairo/cairo/src/cairo-pattern.c
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairo-pattern.c
+++ mozilla/gfx/cairo/cairo/src/cairo-pattern.c
@@ -1024,17 +1024,17 @@ _cairo_pattern_acquire_surface_for_gradi
 	{
 	    pixman_image_destroy (pixman_image);
 	    return CAIRO_STATUS_NO_MEMORY;
 	}
 
 	attr->x_offset = attr->y_offset = 0;
 	attr->matrix = pattern->base.matrix;
 	attr->extend = pattern->base.extend;
-	attr->filter = CAIRO_FILTER_NEAREST;
+	attr->filter = CAIRO_FILTER_FAST;
 	attr->acquired = FALSE;
 
 	*out = &image->base;
 
 	return CAIRO_STATUS_SUCCESS;
     }
 
     if (pattern->base.type == CAIRO_PATTERN_TYPE_LINEAR) {
@@ -1103,43 +1103,43 @@ _cairo_pattern_acquire_surface_for_gradi
 					   0, 0, width, height, out);
 
     cairo_surface_destroy (&image->base);
 
     attr->x_offset = -x;
     attr->y_offset = -y;
     cairo_matrix_init_identity (&attr->matrix);
     attr->extend = repeat ? CAIRO_EXTEND_REPEAT : CAIRO_EXTEND_NONE;
-    attr->filter = CAIRO_FILTER_NEAREST;
+    attr->filter = CAIRO_FILTER_FAST;
     attr->acquired = FALSE;
 
     return status;
 }
 
 static cairo_int_status_t
 _cairo_pattern_acquire_surface_for_solid (cairo_solid_pattern_t	     *pattern,
 					  cairo_surface_t	     *dst,
 					  int			     x,
 					  int			     y,
 					  unsigned int		     width,
 					  unsigned int		     height,
 					  cairo_surface_t	     **out,
 					  cairo_surface_attributes_t *attribs)
 {
     *out = _cairo_surface_create_similar_solid (dst,
-						CAIRO_CONTENT_COLOR_ALPHA,
+						CAIRO_CONTENT_COLOR_ALPHA,
 						1, 1,
 						&pattern->color);
     if ((*out)->status)
 	return CAIRO_STATUS_NO_MEMORY;
 
     attribs->x_offset = attribs->y_offset = 0;
     cairo_matrix_init_identity (&attribs->matrix);
     attribs->extend = CAIRO_EXTEND_REPEAT;
-    attribs->filter = CAIRO_FILTER_NEAREST;
+    attribs->filter = CAIRO_FILTER_FAST;
     attribs->acquired = FALSE;
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 /**
  * _cairo_pattern_is_opaque_solid
  *
@@ -1223,17 +1223,17 @@ _cairo_pattern_acquire_surface_for_surfa
     attr->extend = pattern->base.extend;
     attr->filter = pattern->base.filter;
     if (_cairo_matrix_is_integer_translation (&pattern->base.matrix,
 					      &tx, &ty))
     {
 	cairo_matrix_init_identity (&attr->matrix);
 	attr->x_offset = tx;
 	attr->y_offset = ty;
-	attr->filter = CAIRO_FILTER_NEAREST;
+	attr->filter = CAIRO_FILTER_FAST;
     }
     else
     {
 	attr->matrix = pattern->base.matrix;
 	attr->x_offset = attr->y_offset = 0;
 	tx = 0;
 	ty = 0;
     }
Index: mozilla/gfx/cairo/cairo/src/cairoint.h
===================================================================
--- mozilla.orig/gfx/cairo/cairo/src/cairoint.h
+++ mozilla/gfx/cairo/cairo/src/cairoint.h
@@ -1153,17 +1153,17 @@ struct _cairo_color {
 typedef enum {
     CAIRO_STOCK_WHITE,
     CAIRO_STOCK_BLACK,
     CAIRO_STOCK_TRANSPARENT
 } cairo_stock_t;
 
 #define CAIRO_EXTEND_SURFACE_DEFAULT CAIRO_EXTEND_NONE
 #define CAIRO_EXTEND_GRADIENT_DEFAULT CAIRO_EXTEND_PAD
-#define CAIRO_FILTER_DEFAULT CAIRO_FILTER_BEST
+#define CAIRO_FILTER_DEFAULT CAIRO_FILTER_FAST
 
 struct _cairo_pattern {
     cairo_pattern_type_t    type;
     unsigned int	    ref_count;
     cairo_status_t          status;
     cairo_user_data_array_t user_data;
 
     cairo_matrix_t	    matrix;
