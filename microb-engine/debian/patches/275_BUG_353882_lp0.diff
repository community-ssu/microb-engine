#353882
#performance enhancements to nsCSSFrameConstructor::ConstructFrameByDisplayType
Index: layout/base/nsCSSFrameConstructor.cpp
===================================================================
--- layout/base/nsCSSFrameConstructor.cpp.orig
+++ layout/base/nsCSSFrameConstructor.cpp
@@ -6322,16 +6322,17 @@
                                                    nsFrameItems&            aFrameItems,
                                                    PRBool                   aHasPseudoParent)
 {
   PRBool    primaryFrameSet = PR_FALSE;
   nsIFrame* newFrame = nsnull;  // the frame we construct
   PRBool    addToHashTable = PR_TRUE;
   PRBool    addedToFrameList = PR_FALSE;
   nsresult  rv = NS_OK;
+  PRUint8 tempDisplay = aDisplay->mDisplay;
 
   // The style system ensures that floated and positioned frames are
   // block-level.
   NS_ASSERTION(!(aDisplay->IsFloating() ||
                  aDisplay->IsAbsolutelyPositioned()) ||
                aDisplay->IsBlockLevel(),
                "Style system did not apply CSS2.1 section 9.7 fixups");
 
@@ -6345,16 +6346,17 @@
     propagatedScrollToViewport =
       PropagateScrollToViewport() == aContent;
   }
 
   // If the frame is a block-level frame and is scrollable, then wrap it
   // in a scroll frame.
   // XXX Ignore tables for the time being
   if (aDisplay->IsBlockInside() &&
+      tempDisplay != NS_STYLE_DISPLAY_TABLE &&
       aDisplay->IsScrollableOverflow() &&
       !propagatedScrollToViewport) {
 
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
 
     nsRefPtr<nsStyleContext> scrolledContentStyle
@@ -6384,18 +6386,18 @@
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     addedToFrameList = PR_TRUE;
   }
   // See if the frame is absolute or fixed positioned
   else if (aDisplay->IsAbsolutelyPositioned() &&
-           (NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay ||
-            NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
+           (NS_STYLE_DISPLAY_BLOCK == tempDisplay ||
+            NS_STYLE_DISPLAY_LIST_ITEM == tempDisplay)) {
 
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
 
     // Create a frame to wrap up the absolute positioned item
     // pass a temporary stylecontext, the correct one will be set later
     newFrame = NS_NewAbsoluteItemWrapperFrame(mPresShell, aStyleContext);
@@ -6406,18 +6408,18 @@
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     addedToFrameList = PR_TRUE;
   }
   // See if the frame is floated and it's a block frame
   else if (aDisplay->IsFloating() &&
-           (NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay ||
-            NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
+           (NS_STYLE_DISPLAY_BLOCK == tempDisplay ||
+            NS_STYLE_DISPLAY_LIST_ITEM == tempDisplay)) {
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
     // Create an area frame
     // pass a temporary stylecontext, the correct one will be set later
     newFrame = NS_NewFloatingItemWrapperFrame(mPresShell, aStyleContext);
 
     rv = ConstructBlock(aState, aDisplay, aContent, 
@@ -6427,25 +6429,25 @@
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     addedToFrameList = PR_TRUE;
   }
   // See if it's relatively positioned
   else if ((NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition) &&
-           ((NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay) ||
-            (NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay) ||
-            (NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay))) {
+           ((NS_STYLE_DISPLAY_BLOCK == tempDisplay) ||
+            (NS_STYLE_DISPLAY_INLINE == tempDisplay) ||
+            (NS_STYLE_DISPLAY_LIST_ITEM == tempDisplay))) {
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
     // Is it block-level or inline-level?
-    if ((NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay) ||
-        (NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay)) {
+    if ((NS_STYLE_DISPLAY_BLOCK == tempDisplay) ||
+        (NS_STYLE_DISPLAY_LIST_ITEM == tempDisplay)) {
       // Create a wrapper frame. No space manager, though
       newFrame = NS_NewRelativeItemWrapperFrame(mPresShell, aStyleContext);
       // XXXbz should we be passing in a non-null aContentParentFrame?
       ConstructBlock(aState, aDisplay, aContent,
                      aParentFrame, nsnull, aStyleContext, &newFrame,
                      aFrameItems, PR_TRUE);
       addedToFrameList = PR_TRUE;
     } else {
@@ -6453,21 +6455,21 @@
       newFrame = NS_NewPositionedInlineFrame(mPresShell, aStyleContext);
       // Note that we want to insert the inline after processing kids, since
       // processing of kids may split the inline.
       ConstructInline(aState, aDisplay, aContent,
                       aParentFrame, aStyleContext, PR_TRUE, newFrame);
     }
   }
   // See if it's a block frame of some sort
-  else if ((NS_STYLE_DISPLAY_BLOCK == aDisplay->mDisplay) ||
-           (NS_STYLE_DISPLAY_LIST_ITEM == aDisplay->mDisplay) ||
-           (NS_STYLE_DISPLAY_RUN_IN == aDisplay->mDisplay) ||
-           (NS_STYLE_DISPLAY_COMPACT == aDisplay->mDisplay) ||
-           (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay)) {
+  else if ((NS_STYLE_DISPLAY_BLOCK == tempDisplay) ||
+           (NS_STYLE_DISPLAY_LIST_ITEM == tempDisplay) ||
+           (NS_STYLE_DISPLAY_RUN_IN == tempDisplay) ||
+           (NS_STYLE_DISPLAY_COMPACT == tempDisplay) ||
+           (NS_STYLE_DISPLAY_INLINE_BLOCK == tempDisplay)) {
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
     PRUint32 flags = 0;
     if (NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay) {
       flags = NS_BLOCK_SPACE_MGR | NS_BLOCK_MARGIN_ROOT;
     }
     // Create the block frame
@@ -6479,18 +6481,18 @@
                           aFrameItems, PR_FALSE);
       addedToFrameList = PR_TRUE;
     }
     else {
       rv = NS_ERROR_OUT_OF_MEMORY;
     }
   }
   // See if it's an inline frame of some sort
-  else if ((NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay) ||
-           (NS_STYLE_DISPLAY_MARKER == aDisplay->mDisplay)) {
+  else if ((NS_STYLE_DISPLAY_INLINE == tempDisplay) ||
+           (NS_STYLE_DISPLAY_MARKER == tempDisplay)) {
     if (!aHasPseudoParent && !aState.mPseudoFrames.IsEmpty()) {
       ProcessPseudoFrames(aState, aFrameItems); 
     }
     // Create the inline frame
     newFrame = NS_NewInlineFrame(mPresShell, aStyleContext);
     if (newFrame) { // That worked so construct the inline and its children
       // Note that we want to insert the inline after processing kids, since
       // processing of kids may split the inline.
@@ -6507,17 +6509,17 @@
     addToHashTable = PR_FALSE;
   }
   // otherwise let the display property influence the frame type to create
   else {
     // XXX This section now only handles table frames; should be
     // factored out probably
 
     // Use the 'display' property to choose a frame type
-    switch (aDisplay->mDisplay) {
+    switch (tempDisplay) {
     case NS_STYLE_DISPLAY_TABLE:
     case NS_STYLE_DISPLAY_INLINE_TABLE:
     {
       nsIFrame* innerTable;
       rv = ConstructTableFrame(aState, aContent, 
                                aParentFrame, aStyleContext,
                                aNameSpaceID, PR_FALSE, aFrameItems, PR_TRUE,
                                newFrame, innerTable);
Index: layout/style/nsStyleStruct.h
===================================================================
--- layout/style/nsStyleStruct.h.orig
+++ layout/style/nsStyleStruct.h
@@ -820,36 +820,36 @@
            NS_STYLE_DISPLAY_INLINE_GRID == mDisplay ||
            NS_STYLE_DISPLAY_INLINE_STACK == mDisplay ||
            // Are these really inlines? :
            NS_STYLE_DISPLAY_DECK == mDisplay ||
            NS_STYLE_DISPLAY_POPUP == mDisplay ||
            NS_STYLE_DISPLAY_GROUPBOX == mDisplay;
   }
 
-  PRBool IsFloating() const {
+  inline PRBool IsFloating() const {
     return NS_STYLE_FLOAT_NONE != mFloats;
   }
 
-  PRBool IsAbsolutelyPositioned() const {return (NS_STYLE_POSITION_ABSOLUTE == mPosition) ||
+  inline PRBool IsAbsolutelyPositioned() const {return (NS_STYLE_POSITION_ABSOLUTE == mPosition) ||
                                                 (NS_STYLE_POSITION_FIXED == mPosition);}
 
-  PRBool IsPositioned() const {return IsAbsolutelyPositioned() ||
+  inline PRBool IsPositioned() const {return IsAbsolutelyPositioned() ||
                                       (NS_STYLE_POSITION_RELATIVE == mPosition);}
 
-  PRBool IsScrollableOverflow() const {
+  inline PRBool IsScrollableOverflow() const {
     // mOverflowX and mOverflowY always match when one of them is
     // NS_STYLE_OVERFLOW_VISIBLE or NS_STYLE_OVERFLOW_CLIP.
     return mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
            mOverflowX != NS_STYLE_OVERFLOW_CLIP;
   }
 
   // For table elements that don't support scroll frame creation, we
   // support 'overflow: hidden' to mean 'overflow: -moz-hidden-unscrollable'.
-  PRBool IsTableClip() const {
+  inline PRBool IsTableClip() const {
     return mOverflowX == NS_STYLE_OVERFLOW_CLIP ||
            (mOverflowX == NS_STYLE_OVERFLOW_HIDDEN &&
             mOverflowY == NS_STYLE_OVERFLOW_HIDDEN);
   }
 };
 
 struct nsStyleTable: public nsStyleStruct {
   nsStyleTable(void);
