diff -r 5b1fe1bf3872 browser/app/Makefile.in
--- a/browser/app/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/app/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -109,14 +109,14 @@ STATIC_COMPONENTS_LINKER_PATH = -L$(DEPT
 endif
 LIBS += $(DEPTH)/toolkit/xre/$(LIB_PREFIX)xulapp_s.$(LIB_SUFFIX)
 else
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LIBS += $(DIST)/bin/XUL
 else
 EXTRA_DSO_LIBS += xul
 endif
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 TK_LIBS := $(TK_LIBS)
 endif
 
@@ -313,7 +313,7 @@ libs:: $(srcdir)/profile/prefs.js
 libs:: $(srcdir)/blocklist.xml
 	$(INSTALL) $(IFLAGS1) $^ $(DIST)/bin
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 
 APP_NAME = $(MOZ_APP_DISPLAYNAME)
 
diff -r 5b1fe1bf3872 browser/base/Makefile.in
--- a/browser/base/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/base/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -69,7 +69,7 @@ DEFINES += \
 	-DPRE_RELEASE_SUFFIX="$(PRE_RELEASE_SUFFIX)" \
 	$(NULL)
 
-ifneq (,$(filter windows gtk2 mac cocoa, $(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter windows gtk2 cocoa, $(MOZ_WIDGET_TOOLKIT)))
 DEFINES += -DHAVE_SHELL_SERVICE=1
 endif
 
@@ -77,7 +77,7 @@ ifdef MOZ_UPDATER
 DEFINES += -DMOZ_UPDATER=1
 endif
 
-ifneq (,$(filter windows mac cocoa gtk2, $(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter windows cocoa gtk2, $(MOZ_WIDGET_TOOLKIT)))
 ifneq ($(OS_ARCH),WINCE)
 DEFINES += -DCONTEXT_COPY_IMAGE_CONTENTS=1
 endif
diff -r 5b1fe1bf3872 browser/base/content/test/Makefile.in
--- a/browser/base/content/test/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/base/content/test/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -145,7 +145,7 @@ _BROWSER_FILES = \
                  browser_NetworkPrioritizer.js \
     $(NULL)
 
-ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 _BROWSER_FILES += browser_bug462289.js
 else
 _BROWSER_FILES += browser_customize.js
diff -r 5b1fe1bf3872 browser/components/build/Makefile.in
--- a/browser/components/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/components/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -64,7 +64,7 @@ SHARED_LIBRARY_LIBS = \
 	../about/$(LIB_PREFIX)browserabout_s.$(LIB_SUFFIX) \
 	$(NULL)
 
-ifneq (,$(filter windows mac cocoa gtk2, $(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter windows cocoa gtk2, $(MOZ_WIDGET_TOOLKIT)))
 SHARED_LIBRARY_LIBS += ../shell/src/$(LIB_PREFIX)shellservice_s.$(LIB_SUFFIX)
 endif
 
@@ -88,7 +88,7 @@ EXTRA_DSO_LDOPTS += \
 
 # Mac: Need to link with CoreFoundation for Mac Migrators (PList reading code)
 # GTK2: Need to link with glib for GNOME shell service
-ifneq (,$(filter mac cocoa gtk2,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter cocoa gtk2,$(MOZ_WIDGET_TOOLKIT)))
 EXTRA_DSO_LDOPTS += \
   $(TK_LIBS) \
   $(NULL)
diff -r 5b1fe1bf3872 browser/components/migration/src/Makefile.in
--- a/browser/components/migration/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/components/migration/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -92,7 +92,7 @@ CPPSRCS += nsIEProfileMigrator.cpp \
            $(NULL)
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CPPSRCS += nsSafariProfileMigrator.cpp \
            nsMacIEProfileMigrator.cpp \
            nsOmniWebProfileMigrator.cpp \
diff -r 5b1fe1bf3872 browser/components/preferences/Makefile.in
--- a/browser/components/preferences/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/components/preferences/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -54,7 +54,7 @@ DEFINES += \
 	-DMOZ_APP_DISPLAYNAME=$(MOZ_APP_DISPLAYNAME) \
 	$(NULL)
 
-ifneq (,$(filter windows gtk2 mac cocoa, $(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter windows gtk2 cocoa, $(MOZ_WIDGET_TOOLKIT)))
 DEFINES += -DHAVE_SHELL_SERVICE=1
 endif
 
diff -r 5b1fe1bf3872 browser/components/safebrowsing/content/test/Makefile.in
--- a/browser/components/safebrowsing/content/test/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/components/safebrowsing/content/test/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -47,7 +47,7 @@ include $(topsrcdir)/config/rules.mk
 
 # The browser chrome test for bug 415846 doesn't run on Mac because of its
 # bizarre special-and-unique snowflake of a help menu.
-ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (cocoa,$(MOZ_WIDGET_TOOLKIT)))
 _NON_MAC_BROWSER_TESTS = browser_bug415846.js
 endif
 
diff -r 5b1fe1bf3872 browser/components/shell/public/Makefile.in
--- a/browser/components/shell/public/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/components/shell/public/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -51,7 +51,7 @@ ifneq (,$(filter WINCE WINNT,$(OS_ARCH))
 XPIDLSRCS += nsIWindowsShellService.idl
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 XPIDLSRCS += nsIMacShellService.idl
 endif
 
diff -r 5b1fe1bf3872 browser/components/shell/src/Makefile.in
--- a/browser/components/shell/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/components/shell/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -71,7 +71,7 @@ REQUIRES	+= \
 		browsercomps \
 		$(NULL)
 else
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CPPSRCS = nsMacShellService.cpp
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT), gtk2)
diff -r 5b1fe1bf3872 browser/installer/Makefile.in
--- a/browser/installer/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/installer/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -107,7 +107,7 @@ MOZ_PKG_MANIFEST = package-manifest
 GARBAGE += $(MOZ_PKG_MANIFEST)
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 MOZ_PKG_MAC_DSSTORE=branding/dsstore
 MOZ_PKG_MAC_BACKGROUND=branding/background.png
 MOZ_PKG_MAC_ICON=branding/disk.icns
diff -r 5b1fe1bf3872 browser/themes/Makefile.in
--- a/browser/themes/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/browser/themes/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -50,7 +50,7 @@ include $(DEPTH)/config/autoconf.mk
 # MacOS X                 Pinstripe
 #
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 DIRS = pinstripe
 else
 DIRS = winstripe
diff -r 5b1fe1bf3872 chrome/src/Makefile.in
--- a/chrome/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/chrome/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -88,7 +88,7 @@ ifneq (,$(filter gtk2,$(MOZ_WIDGET_TOOLK
 EXTRA_DSO_LDOPTS += $(MOZ_GTK2_LIBS)
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
diff -r 5b1fe1bf3872 config/autoconf.mk.in
--- a/config/autoconf.mk.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/config/autoconf.mk.in	Fri Dec 11 07:09:00 2009 +0200
@@ -179,6 +179,7 @@ NS_PRINTING = @NS_PRINTING@
 MOZ_CRASHREPORTER = @MOZ_CRASHREPORTER@
 MOZ_HELP_VIEWER = @MOZ_HELP_VIEWER@
 MOC= @MOC@
+MOZ_WEBGL = @MOZ_WEBGL@
 
 MOZ_JAVAXPCOM = @MOZ_JAVAXPCOM@
 JAVA_INCLUDE_PATH="@JAVA_INCLUDE_PATH@"
@@ -246,8 +247,6 @@ MOZ_PERMISSIONS = @MOZ_PERMISSIONS@
 MOZ_XTF = @MOZ_XTF@
 MOZ_NO_INSPECTOR_APIS = @MOZ_NO_INSPECTOR_APIS@
 MOZ_SVG = @MOZ_SVG@
-MOZ_ENABLE_CANVAS = @MOZ_ENABLE_CANVAS@
-MOZ_ENABLE_CANVAS3D = @MOZ_ENABLE_CANVAS3D@
 MOZ_CAIRO_CFLAGS = @MOZ_CAIRO_CFLAGS@
 MOZ_SMIL = @MOZ_SMIL@
 MOZ_XSLT_STANDALONE = @MOZ_XSLT_STANDALONE@
diff -r 5b1fe1bf3872 config/static-rules.mk
--- a/config/static-rules.mk	Fri Dec 11 07:02:35 2009 +0200
+++ b/config/static-rules.mk	Fri Dec 11 07:09:00 2009 +0200
@@ -20,6 +20,6 @@ ifeq ($(OS_ARCH),IRIX)
 LDFLAGS	+= -Wl,-LD_LAYOUT:lgot_buffer=80
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LIBS	+= -framework QuickTime -framework IOKit -lcrypto
 endif
diff -r 5b1fe1bf3872 configure.in
--- a/configure.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/configure.in	Fri Dec 11 07:09:00 2009 +0200
@@ -4498,8 +4498,6 @@ MOZ_ACTIVEX_SCRIPTING_SUPPORT=
 MOZ_BRANDING_DIRECTORY=
 MOZ_OFFICIAL_BRANDING=
 MOZ_DBGRINFO_MODULES=
-MOZ_ENABLE_CANVAS=1
-MOZ_ENABLE_CANVAS3D=
 MOZ_FEEDS=1
 MOZ_IMG_DECODERS_DEFAULT="png gif jpeg bmp icon"
 MOZ_IMG_ENCODERS_DEFAULT="png jpeg"
@@ -4831,6 +4829,7 @@ photon)
 cairo-windows)
     MOZ_WIDGET_TOOLKIT=windows
     MOZ_GFX_TOOLKIT=cairo
+    MOZ_WEBGL=1
     ;;
 
 cairo-gtk2|cairo-gtk2-x11)
@@ -4838,6 +4837,8 @@ cairo-gtk2|cairo-gtk2-x11)
     MOZ_GFX_TOOLKIT=cairo
     MOZ_ENABLE_GTK2=1
     MOZ_ENABLE_XREMOTE=1
+    MOZ_WEBGL=1
+    MOZ_WEBGL_GLX=1
 
     AC_DEFINE(MOZ_X11)
     MOZ_X11=1
@@ -4852,6 +4853,7 @@ cairo-gtk2-dfb)
     MOZ_WIDGET_TOOLKIT=gtk2
     MOZ_GFX_TOOLKIT=cairo
     MOZ_ENABLE_GTK2=1
+    MOZ_WEBGL=
 
     AC_DEFINE(MOZ_DFB)
     MOZ_DFB=1
@@ -4914,6 +4916,7 @@ cairo-cocoa)
     CXXFLAGS="$CXXFLAGS $TK_CFLAGS"
     LIBXUL_LIBS='$(XPCOM_FROZEN_LDOPTS) $(LIBXUL_DIST)/bin/XUL -lobjc'
     MOZ_FS_LAYOUT=bundle
+    MOZ_WEBGL=1
     ;;
 esac
 
@@ -5973,27 +5976,6 @@ if test "$MOZ_MATHML"; then
 fi
 
 dnl ========================================================
-dnl Canvas
-dnl ========================================================
-MOZ_ARG_DISABLE_BOOL(canvas,
-[  --disable-canvas          Disable html:canvas feature],
-    MOZ_ENABLE_CANVAS=,
-    MOZ_ENABLE_CANVAS=1 )
-if test -n "$MOZ_ENABLE_CANVAS"; then
-    AC_DEFINE(MOZ_ENABLE_CANVAS)
-fi
-AC_SUBST(MOZ_ENABLE_CANVAS)
-
-MOZ_ARG_ENABLE_BOOL(canvas3d,
-[  --enable-canvas3d        Enable canvas 3D context],
-    MOZ_ENABLE_CANVAS3D=1,
-    MOZ_ENABLE_CANVAS3D= )
-if test -n "$MOZ_ENABLE_CANVAS3D"; then
-    AC_DEFINE(MOZ_ENABLE_CANVAS3D)
-fi
-AC_SUBST(MOZ_ENABLE_CANVAS3D)
-
-dnl ========================================================
 dnl SVG
 dnl ========================================================
 MOZ_ARG_DISABLE_BOOL(svg,
@@ -6468,6 +6450,7 @@ if test $NS_OSSO; then
     fi
     AC_DEFINE(NS_OSSO)
     MOZ_GFX_OPTIMIZE_MOBILE=1
+    MOZ_WEBGL_GLX=
 fi
 AC_SUBST(LIBOSSO_CFLAGS)
 AC_SUBST(LIBOSSO_LIBS)
@@ -7781,7 +7764,7 @@ if test "$MOZ_TREE_CAIRO"; then
     if test "$MOZ_WIDGET_TOOLKIT" = "qt"; then
         QPAINTER_SURFACE_FEATURE="#define CAIRO_HAS_QPAINTER_SURFACE 1"
     fi
-    if test "$MOZ_WIDGET_TOOLKIT" = "mac" -o "$MOZ_WIDGET_TOOLKIT" = "cocoa"; then
+    if test "$MOZ_WIDGET_TOOLKIT" = "cocoa"; then
         QUARTZ_SURFACE_FEATURE="#define CAIRO_HAS_QUARTZ_SURFACE 1"
         QUARTZ_IMAGE_SURFACE_FEATURE="#define CAIRO_HAS_QUARTZ_IMAGE_SURFACE 1"
         QUARTZ_FONT_FEATURE="#define CAIRO_HAS_QUARTZ_FONT 1"
@@ -8159,6 +8142,7 @@ AC_SUBST(MOZ_PLACES_BOOKMARKS)
 AC_SUBST(MOZ_STORAGE)
 AC_SUBST(MOZ_FEEDS)
 AC_SUBST(NS_PRINTING)
+AC_SUBST(MOZ_WEBGL)
 
 AC_SUBST(MOZ_JAVAXPCOM)
 AC_SUBST(JAVA_INCLUDE_PATH)
@@ -8394,6 +8378,14 @@ if test "$MOZ_X11"; then
     fi
 
 fi # MOZ_X11
+
+dnl Check for headers, etc. needed by WebGL.
+if test -n "$MOZ_WEBGL_GLX"; then
+    AC_CHECK_HEADER(GL/glx.h)
+    if test "$ac_cv_header_GL_glx_h" != "yes"; then
+        AC_MSG_ERROR([Can't find header GL/glx.h for WebGL (install mesa-common-dev (Ubuntu), mesa-libGL-devel (Fedora), or Mesa (SuSE))])
+    fi
+fi # MOZ_WEBGL_GLX
 fi # COMPILE_ENVIRONMENT
 
 if test "$USE_FC_FREETYPE"; then
diff -r 5b1fe1bf3872 content/canvas/public/Makefile.in
--- a/content/canvas/public/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/public/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -43,20 +43,16 @@ VPATH		= @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 MODULE		= content
+XPIDL_MODULE = content_canvas
 
 EXPORTS		= \
 		nsICanvasRenderingContextInternal.h \
 		nsICanvasElement.h \
+		WebGLArray.h \
 		$(NULL)
 
-ifdef MOZ_ENABLE_CANVAS3D
-
-XPIDL_MODULE = content_canvas
-
 XPIDLSRCS	= \
 		nsICanvasGLPrivate.idl \
 		$(NULL)
 
-endif
-
 include $(topsrcdir)/config/rules.mk
diff -r 5b1fe1bf3872 content/canvas/public/WebGLArray.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/public/WebGLArray.h	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef WEBGLARRAY_H_
+#define WEBGLARRAY_H_
+
+nsresult NS_NewWebGLArrayBuffer(nsISupports **aNewObject);
+nsresult NS_NewWebGLFloatArray(nsISupports **aNewObject);
+nsresult NS_NewWebGLByteArray(nsISupports **aNewObject);
+nsresult NS_NewWebGLUnsignedByteArray(nsISupports **aNewObject);
+nsresult NS_NewWebGLShortArray(nsISupports **aNewObject);
+nsresult NS_NewWebGLUnsignedShortArray(nsISupports **aNewObject);
+nsresult NS_NewWebGLIntArray(nsISupports **aNewObject);
+nsresult NS_NewWebGLUnsignedIntArray(nsISupports **aNewObject);
+
+#endif
diff -r 5b1fe1bf3872 content/canvas/src/CanvasUtils.cpp
--- a/content/canvas/src/CanvasUtils.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/CanvasUtils.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -35,10 +35,15 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#include <stdlib.h>
+#include <stdarg.h>
+
 #include "prmem.h"
+#include "prprf.h"
 
 #include "nsIServiceManager.h"
 
+#include "nsIConsoleService.h"
 #include "nsIDOMDocument.h"
 #include "nsIDocument.h"
 #include "nsIDOMCanvasRenderingContext2D.h"
@@ -92,3 +97,31 @@ CanvasUtils::DoDrawImageSecurityCheck(ns
 
     aCanvasElement->SetWriteOnly();
 }
+
+void
+CanvasUtils::LogMessage (const nsCString& errorString)
+{
+    nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+    if (!console)
+        return;
+
+    console->LogStringMessage(NS_ConvertUTF8toUTF16(errorString).get());
+    fprintf(stderr, "%s\n", errorString.get());
+}
+
+void
+CanvasUtils::LogMessagef (const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    char buf[256];
+
+    nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+    if (console) {
+        PR_vsnprintf(buf, 256, fmt, ap);
+        console->LogStringMessage(NS_ConvertUTF8toUTF16(nsDependentCString(buf)).get());
+        fprintf(stderr, "%s\n", buf);
+    }
+
+    va_end(ap);
+}
diff -r 5b1fe1bf3872 content/canvas/src/CanvasUtils.h
--- a/content/canvas/src/CanvasUtils.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/CanvasUtils.h	Fri Dec 11 07:09:00 2009 +0200
@@ -69,6 +69,9 @@ public:
                                          nsIPrincipal *aPrincipal,
                                          PRBool forceWriteOnly);
 
+    static void LogMessage (const nsCString& errorString);
+    static void LogMessagef (const char *fmt, ...);
+
 private:
     // this can't be instantiated
     CanvasUtils() { }
diff -r 5b1fe1bf3872 content/canvas/src/Makefile.in
--- a/content/canvas/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -76,31 +76,51 @@ CPPSRCS	= \
 
 # Canvas 3D Pieces
 
-ifdef MOZ_ENABLE_CANVAS3D
+ifdef MOZ_WEBGL
+
+ifeq (1_1,$(MOZ_X11)_$(NS_OSSO))
+WEBGL_PLATFORM = EGL
+DEFINES += -DUSE_GLES2
+endif
+
+ifeq (1_,$(MOZ_X11)_$(NS_OSSO))
+WEBGL_PLATFORM = GLX
+EXTRA_DSO_LIBS += X11
+endif
+
+
+ifeq (windows,$(MOZ_WIDGET_TOOLKIT))
+ifdef WINCE
+WEBGL_PLATFORM = EGL
+DEFINES += -DUSE_GLES2
+else
+WEBGL_PLATFORM = WGL
+endif
+endif
+
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
+WEBGL_PLATFORM = CGL
+endif
 
 CPPSRCS += \
-	nsCanvasRenderingContextGL.cpp \
-	nsCanvasRenderingContextGLWeb20.cpp \
+	WebGLArrays.cpp \
+	WebGLContext.cpp \
+	WebGLContextGL.cpp \
+	WebGLContextUtils.cpp \
+	WebGLContextValidate.cpp \
+	NativeJSContext.cpp \
 	glwrap.cpp \
 	nsGLPbuffer.cpp \
 	nsGLPbufferOSMesa.cpp \
+	SimpleBuffer.cpp \
 	$(NULL)
 
-ifdef MOZ_X11
-EXTRA_DSO_LIBS += X11
-CPPSRCS += nsGLPbufferGLX.cpp
-DEFINES += -DUSE_GLX
-endif
+CPPSRCS += nsGLPbuffer$(WEBGL_PLATFORM).cpp
+DEFINES += -DUSE_$(WEBGL_PLATFORM)
 
-ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
-CPPSRCS += nsGLPbufferWGL.cpp
-DEFINES += -DUSE_WGL
-endif
+else
 
-ifneq (,$(filter $(MOZ_WIDGET_TOOLKIT),mac cocoa))
-CPPSRCS += nsGLPbufferCGL.cpp
-DEFINES += -DUSE_CGL
-endif
+CPPSRCS += WebGLContextNotSupported.cpp
 
 endif
 
diff -r 5b1fe1bf3872 content/canvas/src/NativeJSContext.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/NativeJSContext.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,37 @@
+#include "NativeJSContext.h"
+#include "nsServiceManagerUtils.h"
+#include "nsIJSRuntimeService.h"
+
+nsIJSRuntimeService* NativeJSContext::sJSRuntimeService = 0;
+JSRuntime* NativeJSContext::sJSScriptRuntime = 0;
+
+PRBool
+NativeJSContext::AddGCRoot(void *aPtr, const char *aName)
+{
+  if (!sJSScriptRuntime) {
+    nsresult rv = CallGetService("@mozilla.org/js/xpc/RuntimeService;1",
+                                 &sJSRuntimeService);
+    NS_ENSURE_TRUE(sJSRuntimeService, PR_FALSE);
+
+    sJSRuntimeService->GetRuntime(&sJSScriptRuntime);
+    if (!sJSScriptRuntime) {
+      NS_RELEASE(sJSRuntimeService);
+      NS_WARNING("Unable to get JS runtime from JS runtime service");
+      return PR_FALSE;
+    }
+  }
+
+  PRBool ok;
+  return ok = ::JS_AddNamedRootRT(sJSScriptRuntime, aPtr, aName);
+}
+
+void
+NativeJSContext::ReleaseGCRoot(void *aPtr)
+{
+  if (!sJSScriptRuntime) {
+    NS_NOTREACHED("Trying to remove a JS GC root when none were added");
+    return;
+  }
+
+  ::JS_RemoveRootRT(sJSScriptRuntime, aPtr);
+}
diff -r 5b1fe1bf3872 content/canvas/src/NativeJSContext.h
--- a/content/canvas/src/NativeJSContext.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/NativeJSContext.h	Fri Dec 11 07:09:00 2009 +0200
@@ -1,12 +1,23 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 #ifndef _NATIVEJSCONTEXT_H_
 #define _NATIVEJSCONTEXT_H_
 
+#include "nsDOMError.h"
+
+#include "nsIXPConnect.h"
+#include "nsContentUtils.h"
+
+#include "nsTArray.h"
+#include "nsAutoPtr.h"
+#include "jsapi.h"
+
 class JSObjectHelper;
+class nsIJSRuntimeService;
 
 class NativeJSContext {
 public:
     NativeJSContext() {
-        error = gXPConnect->GetCurrentNativeCallContext(&ncc);
+        error = nsContentUtils::XPConnect()->GetCurrentNativeCallContext(&ncc);
         if (NS_FAILED(error))
             return;
 
@@ -48,13 +59,8 @@ public:
         return PR_FALSE;
     }
 
-    PRBool AddGCRoot (void *aPtr, const char *aName) {
-        return JS_AddNamedRootRT(gScriptRuntime, aPtr, aName);
-    }
-
-    void ReleaseGCRoot (void *aPtr) {
-        JS_RemoveRootRT(gScriptRuntime, aPtr);
-    }
+    PRBool AddGCRoot (void *aPtr, const char *aName);
+    void ReleaseGCRoot (void *aPtr);
 
     void SetRetVal (PRInt32 val) {
         if (INT_FITS_IN_JSVAL(val))
@@ -167,6 +173,9 @@ public:
     PRUint32 argc;
     jsval *argv;
 
+    static nsIJSRuntimeService* sJSRuntimeService;
+    static JSRuntime* sJSScriptRuntime;
+
 public:
     // static JS helpers
 
@@ -251,9 +260,9 @@ public:
             return NS_ERROR_DOM_SYNTAX_ERR;
 
         nsCOMPtr<nsISupports> isup;
-        nsresult rv = gXPConnect->WrapJS(ctx, JSVAL_TO_OBJECT(val),
-                                         NS_GET_IID(nsISupports),
-                                         getter_AddRefs(isup));
+        nsresult rv = nsContentUtils::XPConnect()->WrapJS(ctx, JSVAL_TO_OBJECT(val),
+                                                          NS_GET_IID(nsISupports),
+                                                          getter_AddRefs(isup));
         if (NS_FAILED(rv))
             return NS_ERROR_DOM_SYNTAX_ERR;
 
diff -r 5b1fe1bf3872 content/canvas/src/SimpleBuffer.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/SimpleBuffer.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,144 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "SimpleBuffer.h"
+
+using namespace mozilla;
+
+#define FOO(_x,_y) JSBool _x (JSContext *cx, JSObject *obj, jsuint offset, jsuint count, _y *dest) { return 0; }
+
+FOO(js_ArrayToJSUint8Buffer, JSUint8)
+FOO(js_ArrayToJSUint16Buffer, JSUint16)
+FOO(js_ArrayToJSUint32Buffer, JSUint32)
+FOO(js_ArrayToJSInt8Buffer, JSInt8)
+FOO(js_ArrayToJSInt16Buffer, JSInt16)
+FOO(js_ArrayToJSInt32Buffer, JSInt32)
+FOO(js_ArrayToJSDoubleBuffer, jsdouble)
+
+PRBool
+SimpleBuffer::InitFromJSArray(PRUint32 typeParam,
+                              PRUint32 sizeParam,
+                              JSContext *ctx,
+                              JSObject *arrayObj,
+                              jsuint arrayLen)
+{
+    if (typeParam == LOCAL_GL_SHORT) {
+        Prepare(typeParam, sizeParam, arrayLen);
+        short *ptr = (short*) data;
+
+        if (!js_ArrayToJSInt16Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
+            for (PRUint32 i = 0; i < arrayLen; i++) {
+                jsval jv;
+                int32 iv;
+                ::JS_GetElement(ctx, arrayObj, i, &jv);
+                ::JS_ValueToECMAInt32(ctx, jv, &iv);
+                *ptr++ = (short) iv;
+            }
+        }
+    } else if (typeParam == LOCAL_GL_FLOAT) {
+        Prepare(typeParam, sizeParam, arrayLen);
+        float *ptr = (float*) data;
+        double *tmpd = new double[arrayLen];
+        if (js_ArrayToJSDoubleBuffer(ctx, arrayObj, 0, arrayLen, tmpd)) {
+            for (PRUint32 i = 0; i < arrayLen; i++)
+                ptr[i] = (float) tmpd[i];
+        } else {
+            for (PRUint32 i = 0; i < arrayLen; i++) {
+                jsval jv;
+                jsdouble dv;
+                ::JS_GetElement(ctx, arrayObj, i, &jv);
+                ::JS_ValueToNumber(ctx, jv, &dv);
+                *ptr++ = (float) dv;
+            }
+        }
+        delete [] tmpd;
+    } else if (typeParam == LOCAL_GL_UNSIGNED_BYTE) {
+        Prepare(typeParam, sizeParam, arrayLen);
+        unsigned char *ptr = (unsigned char*) data;
+        if (!js_ArrayToJSUint8Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
+            for (PRUint32 i = 0; i < arrayLen; i++) {
+                jsval jv;
+                uint32 iv;
+                ::JS_GetElement(ctx, arrayObj, i, &jv);
+                ::JS_ValueToECMAUint32(ctx, jv, &iv);
+                *ptr++ = (unsigned char) iv;
+            }
+        }
+    } else if (typeParam == LOCAL_GL_UNSIGNED_SHORT) {
+        Prepare(typeParam, sizeParam, arrayLen);
+        PRUint16 *ptr = (PRUint16*) data;
+        if (!js_ArrayToJSUint16Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
+            for (PRUint32 i = 0; i < arrayLen; i++) {
+                jsval jv;
+                uint32 iv;
+                ::JS_GetElement(ctx, arrayObj, i, &jv);
+                ::JS_ValueToECMAUint32(ctx, jv, &iv);
+                *ptr++ = (unsigned short) iv;
+            }
+        }
+    } else if (typeParam == LOCAL_GL_UNSIGNED_INT) {
+        Prepare(typeParam, sizeParam, arrayLen);
+        PRUint32 *ptr = (PRUint32*) data;
+        if (!js_ArrayToJSUint32Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
+            for (PRUint32 i = 0; i < arrayLen; i++) {
+                jsval jv;
+                uint32 iv;
+                ::JS_GetElement(ctx, arrayObj, i, &jv);
+                ::JS_ValueToECMAUint32(ctx, jv, &iv);
+                *ptr++ = iv;
+            }
+        }
+    } else if (typeParam == LOCAL_GL_INT) {
+        Prepare(typeParam, sizeParam, arrayLen);
+        PRInt32 *ptr = (PRInt32*) data;
+        if (!js_ArrayToJSInt32Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
+            for (PRUint32 i = 0; i < arrayLen; i++) {
+                jsval jv;
+                int32 iv;
+                ::JS_GetElement(ctx, arrayObj, i, &jv);
+                ::JS_ValueToECMAInt32(ctx, jv, &iv);
+                *ptr++ = iv;
+            }
+        }
+    } else {
+        return PR_FALSE;
+    }
+
+    return PR_TRUE;
+}
+
diff -r 5b1fe1bf3872 content/canvas/src/SimpleBuffer.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/SimpleBuffer.h	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,146 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef SIMPLEBUFFER_H_
+#define SIMPLEBUFFER_H_
+
+#include "nsICanvasRenderingContextWebGL.h"
+#include "localgl.h"
+
+#include "jsapi.h"
+
+namespace mozilla {
+
+class SimpleBuffer {
+public:
+    SimpleBuffer()
+      : type(LOCAL_GL_FLOAT), data(nsnull), length(0), capacity(0), sizePerVertex(0)
+    { }
+
+    SimpleBuffer(PRUint32 typeParam,
+                 PRUint32 sizeParam,
+                 JSContext *ctx,
+                 JSObject *arrayObj,
+                 jsuint arrayLen)
+      : type(LOCAL_GL_FLOAT), data(nsnull), length(0), capacity(0), sizePerVertex(0)
+    {
+        InitFromJSArray(typeParam, sizeParam, ctx, arrayObj, arrayLen);
+    }
+
+    PRBool InitFromJSArray(PRUint32 typeParam,
+                           PRUint32 sizeParam,
+                           JSContext *ctx,
+                           JSObject *arrayObj,
+                           jsuint arrayLen);
+
+    ~SimpleBuffer() {
+        Release();
+    }
+
+    inline PRBool Valid() {
+        return data != nsnull;
+    }
+
+    inline PRUint32 ElementSize() {
+        if (type == LOCAL_GL_FLOAT) return sizeof(float);
+        if (type == LOCAL_GL_SHORT) return sizeof(short);
+        if (type == LOCAL_GL_UNSIGNED_SHORT) return sizeof(unsigned short);
+        if (type == LOCAL_GL_BYTE) return 1;
+        if (type == LOCAL_GL_UNSIGNED_BYTE) return 1;
+        if (type == LOCAL_GL_INT) return sizeof(int);
+        if (type == LOCAL_GL_UNSIGNED_INT) return sizeof(unsigned int);
+        if (type == LOCAL_GL_DOUBLE) return sizeof(double);
+        return 1;
+    }
+
+    void Clear() {
+        Release();
+    }
+
+    void Set(PRUint32 t, PRUint32 spv, PRUint32 count, void* vals) {
+        Prepare(t, spv, count);
+
+        if (count)
+            memcpy(data, vals, count*ElementSize());
+    }
+
+    void Prepare(PRUint32 t, PRUint32 spv, PRUint32 count) {
+        if (count == 0) {
+            Release();
+        } else {
+            type = t;
+            EnsureCapacity(PR_FALSE, count*ElementSize());
+            length = count;
+            sizePerVertex = spv;
+        }
+    }
+
+    void Release() {
+        if (data)
+            free(data);
+        length = 0;
+        capacity = 0;
+        data = nsnull;
+    }
+
+    void Zero() {
+        memset(data, 0, capacity);
+    }
+
+    void EnsureCapacity(PRBool preserve, PRUint32 cap) {
+        if (capacity >= cap)
+            return;
+
+        void* newdata = malloc(cap);
+        if (preserve && length)
+            memcpy(newdata, data, length*ElementSize());
+        free(data);
+        data = newdata;
+        capacity = cap;
+    }
+
+    PRUint32 type;
+    void* data;
+    PRUint32 length;        // # of elements
+    PRUint32 capacity;      // bytes!
+    PRUint32 sizePerVertex; // OpenGL "size" param; num coordinates per vertex
+};
+
+}
+
+#endif
diff -r 5b1fe1bf3872 content/canvas/src/WebGLArrays.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLArrays.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,2421 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mark Steele <mwsteele@gmail.com>
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "WebGLArrays.h"
+
+#include "NativeJSContext.h"
+
+// TODO:
+// XXX: fix overflow in integer mult in ::Set!
+// XXX: get rid of code duplication, use inline helpers, templates, or macros
+// XXX: Prepare/Zero in initializers is inefficient, we should really
+//      just be doing calloc
+// XXX: array Set() shouldn't call into the inner Set(), because that
+//      repeats the length check and is probably not getting inlined
+// write benchmarks
+
+using namespace mozilla;
+
+nsresult
+NS_NewWebGLArrayBuffer(nsISupports **aResult)
+{
+    nsIWebGLArrayBuffer *wgab = new WebGLArrayBuffer();
+    if (!wgab)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wgab);
+    return NS_OK;
+}
+
+WebGLArrayBuffer::WebGLArrayBuffer(PRUint32 length)
+{
+    EnsureCapacity(PR_FALSE, length);
+}
+
+NS_IMETHODIMP
+WebGLArrayBuffer::Initialize(nsISupports *owner,
+                             JSContext *cx,
+                             JSObject *obj,
+                             PRUint32 argc,
+                             jsval *argv)
+{
+    /* Constructor: WebGLArrayBuffer(n) */
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        if (length == 0)
+            return NS_ERROR_FAILURE;
+
+        EnsureCapacity(PR_FALSE, length);
+
+        return NS_OK;
+    }
+
+    return NS_ERROR_DOM_SYNTAX_ERR;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLArrayBuffer::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = capacity;
+    return NS_OK;
+}
+
+/* [noscript, notxpcom] voidPtr GetNativeArrayBuffer (); */
+NS_IMETHODIMP_(WebGLArrayBuffer *) WebGLArrayBuffer::GetNativeArrayBuffer()
+{
+    return this;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLArrayBuffer::NativePointer()
+{
+    return data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLArrayBuffer::NativeSize()
+{
+    return capacity;
+}
+
+/*
+ * WebGLFloatArray
+ */
+
+nsresult
+NS_NewWebGLFloatArray(nsISupports **aResult)
+{
+    nsIWebGLFloatArray *wgfa = new WebGLFloatArray();
+    if (!wgfa)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wgfa);
+    return NS_OK;
+}
+
+WebGLFloatArray::WebGLFloatArray(PRUint32 length)
+    : mOffset(0), mLength(length)
+{
+    mBuffer = new WebGLArrayBuffer(length * sizeof(float));
+}
+
+WebGLFloatArray::WebGLFloatArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length)
+    : mBuffer(buffer), mOffset(offset), mLength(length)
+{
+}
+
+WebGLFloatArray::WebGLFloatArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen)
+    : mOffset(0), mLength(arrayLen)
+{
+    mBuffer = new WebGLArrayBuffer();
+    mBuffer->InitFromJSArray(LOCAL_GL_FLOAT, 1, cx, arrayObj, arrayLen);
+}
+
+NS_IMETHODIMP
+WebGLFloatArray::Initialize(nsISupports *owner,
+                            JSContext *cx,
+                            JSObject *obj,
+                            PRUint32 argc,
+                            jsval *argv)
+{
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        mBuffer = new WebGLArrayBuffer();
+        mBuffer->Prepare(LOCAL_GL_FLOAT, 1, length);
+        mBuffer->Zero();
+        mLength = length;
+    } else {
+        JSObject *arrayObj;
+        jsuint arrayLen;
+        jsuint byteOffset = 0;
+        jsuint length = 0;
+
+        if (!::JS_ConvertArguments(cx, argc, argv, "o/uu", &arrayObj, &byteOffset, &length) ||
+            arrayObj == NULL)
+        {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (::JS_IsArrayObject(cx, arrayObj) &&
+            ::JS_GetArrayLength(cx, arrayObj, &arrayLen))
+        {
+            mBuffer = new WebGLArrayBuffer();
+            mBuffer->InitFromJSArray(LOCAL_GL_FLOAT, 1, cx, arrayObj, arrayLen);
+            mLength = arrayLen;
+        } else {
+            nsCOMPtr<nsIWebGLArrayBuffer> canvasObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(cx, arrayObj, NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(canvasObj));
+            if (NS_FAILED(rv) || !canvasObj) {
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            mBuffer = canvasObj->GetNativeArrayBuffer();
+
+            if (byteOffset % sizeof(float))
+                return NS_ERROR_FAILURE;
+
+            if ((byteOffset + (length * sizeof(float))) > mBuffer->capacity)
+                return NS_ERROR_FAILURE;
+
+            if (length > 0) {
+                mLength = length;
+            } else {
+                if ((mBuffer->capacity - byteOffset) % sizeof(float))
+                    return NS_ERROR_FAILURE;
+
+                mLength = (mBuffer->capacity - byteOffset) / sizeof(float);
+            }
+        }
+    }
+
+    return NS_OK;
+}
+
+/* readonly attribute nsIWebGLArrayBuffer buffer; */
+NS_IMETHODIMP WebGLFloatArray::GetBuffer(nsIWebGLArrayBuffer **aBuffer)
+{
+    NS_ADDREF(*aBuffer = mBuffer);
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteOffset; */
+NS_IMETHODIMP WebGLFloatArray::GetByteOffset(PRUint32 *aByteOffset)
+{
+    *aByteOffset = mOffset;
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLFloatArray::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = mLength * sizeof(float);
+    return NS_OK;
+}
+
+/* attribute unsigned long length; */
+NS_IMETHODIMP WebGLFloatArray::GetLength(PRUint32 *aLength)
+{
+    *aLength = mLength;
+    return NS_OK;
+}
+
+/* unsigned long alignedSizeInBytes (); */
+NS_IMETHODIMP WebGLFloatArray::AlignedSizeInBytes(PRUint32 *retval)
+{
+    *retval = mBuffer->capacity;
+    return NS_OK;
+}
+
+/* nsIWebGLArray slice (in unsigned long offset, in unsigned long length); */
+NS_IMETHODIMP WebGLFloatArray::Slice(PRUint32 offset, PRUint32 length, nsIWebGLArray **retval)
+{
+    if (length == 0) 
+        return NS_ERROR_FAILURE;
+
+    if (offset + length > mBuffer->capacity)
+        return NS_ERROR_FAILURE;
+
+    nsIWebGLArray *wga = new WebGLFloatArray(mBuffer, offset, length);
+    NS_ADDREF(*retval = wga);
+    return NS_OK;
+}
+
+/* [IndexGetter] float get (in unsigned long index); */
+NS_IMETHODIMP WebGLFloatArray::Get(PRUint32 index, float *retval)
+{
+    if (index >= mLength)
+        return NS_ERROR_FAILURE;
+
+    float *values = static_cast<float*>(mBuffer->data);
+    *retval = values[index];
+
+    return NS_OK;
+}
+
+void
+WebGLFloatArray::Set(PRUint32 index, float value)
+{
+    if (index >= mLength)
+        return;
+
+    float *values = static_cast<float*>(mBuffer->data);
+    values[index] = value;
+}
+
+/* void set (); */
+NS_IMETHODIMP WebGLFloatArray::Set()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 1 || js.argc > 2)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (JSVAL_IS_NUMBER(js.argv[0])) {
+        if (js.argc != 2)
+            return NS_ERROR_DOM_SYNTAX_ERR;
+
+        uint32 index;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index);
+
+        jsdouble value;
+        ::JS_ValueToNumber(js.ctx, js.argv[1], &value);
+
+        if (index >= mLength)
+            return NS_ERROR_FAILURE;
+
+        Set(index, (float) value);
+    } else {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(PRUint32) WebGLFloatArray::NativeType()
+{
+    return mBuffer->type;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLFloatArray::NativePointer()
+{
+    return mBuffer->data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLFloatArray::NativeSize()
+{
+    return mBuffer->capacity;
+}
+
+/* [noscript, notxpcom] unsigned long nativeElementSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLFloatArray::NativeElementSize()
+{
+    return mBuffer->ElementSize();
+}
+
+/* [noscript, notxpcom] unsigned long nativeCount (); */
+NS_IMETHODIMP_(PRUint32) WebGLFloatArray::NativeCount()
+{
+    return mBuffer->length;
+}
+
+// nsIXPCScriptable
+#define XPC_MAP_CLASSNAME WebGLFloatArray
+#define XPC_MAP_QUOTED_CLASSNAME "WebGLFloatArray"
+#define XPC_MAP_WANT_SETPROPERTY
+#define XPC_MAP_WANT_GETPROPERTY
+#define XPC_MAP_WANT_NEWRESOLVE
+#define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY
+#include "xpc_map_end.h"
+
+PRBool WebGLFloatArray::JSValToIndex(JSContext *cx, jsval id, uint32 *retval) {
+    PRBool ok = PR_FALSE;
+    uint32 index;
+
+    if (JSVAL_IS_INT(id)) {
+        index = JSVAL_TO_INT(id);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, id, &index);
+    }
+
+    if (!ok || index >= mLength)
+        return PR_FALSE;
+
+    *retval = index;
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP WebGLFloatArray::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                           JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    float val;
+    Get(index, &val);
+    *_retval = JS_NewNumberValue(cx, val, vp);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLFloatArray::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                       JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    float val;
+
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRBool ok = PR_FALSE;
+
+    if (JSVAL_IS_INT(*vp)) {
+        val = (float) JSVAL_TO_INT(*vp);
+        ok = PR_TRUE;
+    } else {
+        jsdouble dval;
+        ok = JS_ValueToNumber(cx, *vp, &dval);
+        val = (float) dval;
+    }
+
+    if (!ok) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    Set(index, val);
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLFloatArray::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                      JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp,
+                      PRBool *_retval)
+{
+    uint32 index;
+    PRBool ok = JSValToIndex(cx, id, &index);
+
+    if (ok) {
+        *_retval = PR_TRUE;
+        *objp = obj;
+    } else {
+        *_retval = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+/*
+ * WebGLByteArray
+ */
+
+nsresult
+NS_NewWebGLByteArray(nsISupports **aResult)
+{
+    nsIWebGLByteArray *wgba = new WebGLByteArray();
+    if (!wgba)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wgba);
+    return NS_OK;
+}
+
+WebGLByteArray::WebGLByteArray(PRUint32 length)
+    : mOffset(0), mLength(length)
+{
+    mBuffer = new WebGLArrayBuffer(length);
+}
+
+WebGLByteArray::WebGLByteArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length)
+    : mBuffer(buffer), mOffset(offset), mLength(length)
+{
+}
+
+WebGLByteArray::WebGLByteArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen)
+    : mOffset(0), mLength(arrayLen)
+{
+    mBuffer = new WebGLArrayBuffer();
+    mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_BYTE, 1, cx, arrayObj, arrayLen);
+}
+
+NS_IMETHODIMP
+WebGLByteArray::Initialize(nsISupports *owner,
+                           JSContext *cx,
+                           JSObject *obj,
+                           PRUint32 argc,
+                           jsval *argv)
+{
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        mBuffer = new WebGLArrayBuffer();
+        mBuffer->Prepare(LOCAL_GL_BYTE, 1, length);
+        mBuffer->Zero();
+        mLength = length;
+    } else {
+        JSObject *arrayObj;
+        jsuint arrayLen;
+        jsuint byteOffset = 0;
+        jsuint length = 0;
+
+        if (!::JS_ConvertArguments(cx, argc, argv, "o/uu", &arrayObj, &byteOffset, &length) ||
+            arrayObj == NULL)
+        {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (::JS_IsArrayObject(cx, arrayObj) &&
+            ::JS_GetArrayLength(cx, arrayObj, &arrayLen))
+        {
+            mBuffer = new WebGLArrayBuffer();
+            mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_BYTE, 1, cx, arrayObj, arrayLen);
+            mLength = arrayLen;
+        } else {
+            nsCOMPtr<nsIWebGLArrayBuffer> canvasObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(cx, arrayObj, NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(canvasObj));
+            if (NS_FAILED(rv) || !canvasObj) {
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            mBuffer = canvasObj->GetNativeArrayBuffer();
+
+            if ((byteOffset + length) > mBuffer->capacity)
+                return NS_ERROR_FAILURE;
+
+            if (length > 0)
+                mLength = length;
+            else
+                mLength = (mBuffer->capacity - byteOffset);
+        }
+    }
+
+    return NS_OK;
+}
+
+/* readonly attribute nsIWebGLArrayBuffer buffer; */
+NS_IMETHODIMP WebGLByteArray::GetBuffer(nsIWebGLArrayBuffer **aBuffer)
+{
+    NS_ADDREF(*aBuffer = mBuffer);
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteOffset; */
+NS_IMETHODIMP WebGLByteArray::GetByteOffset(PRUint32 *aByteOffset)
+{
+    *aByteOffset = mOffset;
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLByteArray::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = mLength;
+    return NS_OK;
+}
+
+/* attribute unsigned long length; */
+NS_IMETHODIMP WebGLByteArray::GetLength(PRUint32 *aLength)
+{
+    *aLength = mLength;
+    return NS_OK;
+}
+
+/* unsigned long alignedSizeInBytes (); */
+NS_IMETHODIMP WebGLByteArray::AlignedSizeInBytes(PRUint32 *retval)
+{
+    *retval = mBuffer->capacity;
+    return NS_OK;
+}
+
+/* nsIWebGLArray slice (in unsigned long offset, in unsigned long length); */
+NS_IMETHODIMP WebGLByteArray::Slice(PRUint32 offset, PRUint32 length, nsIWebGLArray **retval)
+{
+    if (length == 0) 
+        return NS_ERROR_FAILURE;
+
+    if (offset + length > mBuffer->capacity)
+        return NS_ERROR_FAILURE;
+
+    nsIWebGLArray *wga = new WebGLByteArray(mBuffer, offset, length);
+    NS_ADDREF(*retval = wga);
+    return NS_OK;
+}
+
+/* [IndexGetter] long get (in unsigned long index); */
+NS_IMETHODIMP WebGLByteArray::Get(PRUint32 index, PRInt32 *retval)
+{
+    if (index >= mLength)
+        return NS_ERROR_FAILURE;
+
+    char *values = static_cast<char*>(mBuffer->data);
+    *retval = values[index];
+
+    return NS_OK;
+}
+
+void
+WebGLByteArray::Set(PRUint32 index, char value)
+{
+    if (index >= mLength)
+        return;
+
+    char *values = static_cast<char*>(mBuffer->data);
+    values[index] = value;
+}
+
+/* void set (); */
+NS_IMETHODIMP WebGLByteArray::Set()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 1 || js.argc > 2)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (JSVAL_IS_NUMBER(js.argv[0])) {
+        if (js.argc != 2)
+            return NS_ERROR_DOM_SYNTAX_ERR;
+
+        uint32 index;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index);
+
+        int32 value;
+        ::JS_ValueToECMAInt32(js.ctx, js.argv[1], &value);
+
+        if (index >= mLength)
+            return NS_ERROR_FAILURE;
+
+        Set(index, (char) value);
+    } else {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(PRUint32) WebGLByteArray::NativeType()
+{
+    return mBuffer->type;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLByteArray::NativePointer()
+{
+    return mBuffer->data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLByteArray::NativeSize()
+{
+    return mBuffer->capacity;
+}
+
+/* [noscript, notxpcom] unsigned long nativeElementSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLByteArray::NativeElementSize()
+{
+    return mBuffer->ElementSize();
+}
+
+/* [noscript, notxpcom] unsigned long nativeCount (); */
+NS_IMETHODIMP_(PRUint32) WebGLByteArray::NativeCount()
+{
+    return mBuffer->length;
+}
+
+// nsIXPCScriptable
+#define XPC_MAP_CLASSNAME WebGLByteArray
+#define XPC_MAP_QUOTED_CLASSNAME "WebGLByteArray"
+#define XPC_MAP_WANT_SETPROPERTY
+#define XPC_MAP_WANT_GETPROPERTY
+#define XPC_MAP_WANT_NEWRESOLVE
+#define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY
+#include "xpc_map_end.h"
+
+PRBool WebGLByteArray::JSValToIndex(JSContext *cx, jsval id, uint32 *retval) {
+    PRBool ok = PR_FALSE;
+    uint32 index;
+
+    if (JSVAL_IS_INT(id)) {
+        index = JSVAL_TO_INT(id);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, id, &index);
+    }
+
+    if (!ok || index >= mLength)
+        return PR_FALSE;
+
+    *retval = index;
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP WebGLByteArray::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                          JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRInt32 val;
+    Get(index, &val);
+    *_retval = JS_NewNumberValue(cx, val, vp);
+
+    return NS_SUCCESS_I_DID_SOMETHING;
+}
+
+NS_IMETHODIMP WebGLByteArray::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                          JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    int32 val;
+
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRBool ok = PR_FALSE;
+
+    if (JSVAL_IS_INT(*vp)) {
+        val = JSVAL_TO_INT(*vp);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAInt32(cx, *vp, &val);
+    }
+
+    if (!ok) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    Set(index, (char) val);
+    return NS_SUCCESS_I_DID_SOMETHING;
+}
+
+NS_IMETHODIMP WebGLByteArray::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                         JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp,
+                                         PRBool *_retval)
+{
+    uint32 index;
+    PRBool ok = JSValToIndex(cx, id, &index);
+
+    if (ok) {
+        *_retval = PR_TRUE;
+        *objp = obj;
+    } else {
+        *_retval = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+/*
+ * WebGLUnsignedByteArray
+ */
+
+nsresult
+NS_NewWebGLUnsignedByteArray(nsISupports **aResult)
+{
+    nsIWebGLUnsignedByteArray *wguba = new WebGLUnsignedByteArray();
+    if (!wguba)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wguba);
+    return NS_OK;
+}
+
+WebGLUnsignedByteArray::WebGLUnsignedByteArray(PRUint32 length)
+    : mOffset(0), mLength(length)
+{
+    mBuffer = new WebGLArrayBuffer(length);
+}
+
+WebGLUnsignedByteArray::WebGLUnsignedByteArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length)
+    : mBuffer(buffer), mOffset(offset), mLength(length)
+{
+}
+
+WebGLUnsignedByteArray::WebGLUnsignedByteArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen)
+    : mOffset(0), mLength(arrayLen)
+{
+    mBuffer = new WebGLArrayBuffer();
+    mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_BYTE, 1, cx, arrayObj, arrayLen);
+}
+
+NS_IMETHODIMP
+WebGLUnsignedByteArray::Initialize(nsISupports *owner,
+                                   JSContext *cx,
+                                   JSObject *obj,
+                                   PRUint32 argc,
+                                   jsval *argv)
+{
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        mBuffer = new WebGLArrayBuffer();
+        mBuffer->Prepare(LOCAL_GL_UNSIGNED_BYTE, 1, length);
+        mBuffer->Zero();
+        mLength = length;
+    } else {
+        JSObject *arrayObj;
+        jsuint arrayLen;
+        jsuint byteOffset = 0;
+        jsuint length = 0;
+
+        if (!::JS_ConvertArguments(cx, argc, argv, "o/uu", &arrayObj, &byteOffset, &length) ||
+            arrayObj == NULL)
+        {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (::JS_IsArrayObject(cx, arrayObj) &&
+            ::JS_GetArrayLength(cx, arrayObj, &arrayLen))
+        {
+            mBuffer = new WebGLArrayBuffer();
+            mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_BYTE, 1, cx, arrayObj, arrayLen);
+            mLength = arrayLen;
+        } else {
+            nsCOMPtr<nsIWebGLArrayBuffer> canvasObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(cx, arrayObj, NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(canvasObj));
+            if (NS_FAILED(rv) || !canvasObj) {
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            mBuffer = canvasObj->GetNativeArrayBuffer();
+
+            if ((byteOffset + length) > mBuffer->capacity)
+                return NS_ERROR_FAILURE;
+
+            if (length > 0)
+                mLength = length;
+            else
+                mLength = (mBuffer->capacity - byteOffset);
+        }
+    }
+
+    return NS_OK;
+}
+
+/* readonly attribute nsIWebGLArrayBuffer buffer; */
+NS_IMETHODIMP WebGLUnsignedByteArray::GetBuffer(nsIWebGLArrayBuffer **aBuffer)
+{
+    NS_ADDREF(*aBuffer = mBuffer);
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteOffset; */
+NS_IMETHODIMP WebGLUnsignedByteArray::GetByteOffset(PRUint32 *aByteOffset)
+{
+    *aByteOffset = mOffset;
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLUnsignedByteArray::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = mLength;
+    return NS_OK;
+}
+
+/* attribute unsigned long length; */
+NS_IMETHODIMP WebGLUnsignedByteArray::GetLength(PRUint32 *aLength)
+{
+    *aLength = mLength;
+    return NS_OK;
+}
+
+/* unsigned long alignedSizeInBytes (); */
+NS_IMETHODIMP WebGLUnsignedByteArray::AlignedSizeInBytes(PRUint32 *retval)
+{
+    *retval = mBuffer->capacity;
+    return NS_OK;
+}
+
+/* nsIWebGLArray slice (in unsigned long offset, in unsigned long length); */
+NS_IMETHODIMP WebGLUnsignedByteArray::Slice(PRUint32 offset, PRUint32 length, nsIWebGLArray **retval)
+{
+    if (length == 0) 
+        return NS_ERROR_FAILURE;
+
+    if (offset + length > mBuffer->capacity)
+        return NS_ERROR_FAILURE;
+
+    nsIWebGLArray *wga = new WebGLUnsignedByteArray(mBuffer, offset, length);
+    NS_ADDREF(*retval = wga);
+    return NS_OK;
+}
+
+/* [IndexGetter] unsigned long get (in unsigned long index); */
+NS_IMETHODIMP WebGLUnsignedByteArray::Get(PRUint32 index, PRUint32 *retval)
+{
+    if (index >= mLength)
+        return NS_ERROR_FAILURE;
+
+    unsigned char *values = static_cast<unsigned char*>(mBuffer->data);
+    *retval = values[index];
+
+    return NS_OK;
+}
+
+void
+WebGLUnsignedByteArray::Set(PRUint32 index, unsigned char value)
+{
+    if (index >= mLength)
+        return;
+
+    unsigned char *values = static_cast<unsigned char*>(mBuffer->data);
+    values[index] = value;
+}
+
+/* void set (); */
+NS_IMETHODIMP WebGLUnsignedByteArray::Set()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 1 || js.argc > 2)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (JSVAL_IS_NUMBER(js.argv[0])) {
+        if (js.argc != 2)
+            return NS_ERROR_DOM_SYNTAX_ERR;
+
+        uint32 index;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index);
+
+        uint32 value;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[1], &value);
+
+        if (index >= mLength)
+            return NS_ERROR_FAILURE;
+
+        Set(index, (unsigned char) value);
+    } else {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedByteArray::NativeType()
+{
+    return mBuffer->type;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLUnsignedByteArray::NativePointer()
+{
+    return mBuffer->data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedByteArray::NativeSize()
+{
+    return mBuffer->capacity;
+}
+
+/* [noscript, notxpcom] unsigned long nativeElementSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedByteArray::NativeElementSize()
+{
+    return mBuffer->ElementSize();
+}
+
+/* [noscript, notxpcom] unsigned long nativeCount (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedByteArray::NativeCount()
+{
+    return mBuffer->length;
+}
+
+// nsIXPCScriptable
+#define XPC_MAP_CLASSNAME WebGLUnsignedByteArray
+#define XPC_MAP_QUOTED_CLASSNAME "WebGLUnsignedByteArray"
+#define XPC_MAP_WANT_SETPROPERTY
+#define XPC_MAP_WANT_GETPROPERTY
+#define XPC_MAP_WANT_NEWRESOLVE
+#define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY
+#include "xpc_map_end.h"
+
+PRBool WebGLUnsignedByteArray::JSValToIndex(JSContext *cx, jsval id, uint32 *retval) {
+    PRBool ok = PR_FALSE;
+    uint32 index;
+
+    if (JSVAL_IS_INT(id)) {
+        index = JSVAL_TO_INT(id);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, id, &index);
+    }
+
+    if (!ok || index >= mLength)
+        return PR_FALSE;
+
+    *retval = index;
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP WebGLUnsignedByteArray::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                  JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRUint32 val;
+    Get(index, &val);
+    *_retval = JS_NewNumberValue(cx, val, vp);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLUnsignedByteArray::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                  JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    uint32 val;
+
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRBool ok = PR_FALSE;
+
+    if (JSVAL_IS_INT(*vp)) {
+        val = JSVAL_TO_INT(*vp);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, *vp, &val);
+    }
+
+    if (!ok) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    Set(index, (unsigned char) val);
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLUnsignedByteArray::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                 JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp,
+                                                 PRBool *_retval)
+{
+    uint32 index;
+    PRBool ok = JSValToIndex(cx, id, &index);
+
+    if (ok) {
+        *_retval = PR_TRUE;
+        *objp = obj;
+    } else {
+        *_retval = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+/*
+ * WebGLShortArray
+ */
+
+nsresult
+NS_NewWebGLShortArray(nsISupports **aResult)
+{
+    nsIWebGLShortArray *wgsa = new WebGLShortArray();
+    if (!wgsa)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wgsa);
+    return NS_OK;
+}
+
+WebGLShortArray::WebGLShortArray(PRUint32 length)
+    : mOffset(0), mLength(length)
+{
+    mBuffer = new WebGLArrayBuffer(length * sizeof(short));
+}
+
+WebGLShortArray::WebGLShortArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length)
+    : mBuffer(buffer), mOffset(offset), mLength(length)
+{
+}
+
+WebGLShortArray::WebGLShortArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen)
+    : mOffset(0), mLength(arrayLen)
+{
+    mBuffer = new WebGLArrayBuffer();
+    mBuffer->InitFromJSArray(LOCAL_GL_SHORT, 1, cx, arrayObj, arrayLen);
+}
+
+NS_IMETHODIMP
+WebGLShortArray::Initialize(nsISupports *owner,
+                            JSContext *cx,
+                            JSObject *obj,
+                            PRUint32 argc,
+                            jsval *argv)
+{
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        mBuffer = new WebGLArrayBuffer();
+        mBuffer->Prepare(LOCAL_GL_SHORT, 1, length);
+        mBuffer->Zero();
+        mLength = length;
+    } else {
+        JSObject *arrayObj;
+        jsuint arrayLen;
+        jsuint byteOffset = 0;
+        jsuint length = 0;
+
+        if (!::JS_ConvertArguments(cx, argc, argv, "o/uu", &arrayObj, &byteOffset, &length) ||
+            arrayObj == NULL)
+        {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (::JS_IsArrayObject(cx, arrayObj) &&
+            ::JS_GetArrayLength(cx, arrayObj, &arrayLen))
+        {
+            mBuffer = new WebGLArrayBuffer();
+            mBuffer->InitFromJSArray(LOCAL_GL_SHORT, 1, cx, arrayObj, arrayLen);
+            mLength = arrayLen;
+        } else {
+            nsCOMPtr<nsIWebGLArrayBuffer> canvasObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(cx, arrayObj, NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(canvasObj));
+            if (NS_FAILED(rv) || !canvasObj) {
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            mBuffer = canvasObj->GetNativeArrayBuffer();
+
+            if (byteOffset % sizeof(short))
+                return NS_ERROR_FAILURE;
+
+            if ((byteOffset + (length * sizeof(short))) > mBuffer->capacity)
+                return NS_ERROR_FAILURE;
+
+            if (length > 0) {
+                mLength = length;
+            } else {
+                if ((mBuffer->capacity - byteOffset) % sizeof(short))
+                    return NS_ERROR_FAILURE;
+
+                mLength = (mBuffer->capacity - byteOffset) / sizeof(short);
+            }
+        }
+    }
+
+    return NS_OK;
+}
+
+/* readonly attribute nsIWebGLArrayBuffer buffer; */
+NS_IMETHODIMP WebGLShortArray::GetBuffer(nsIWebGLArrayBuffer * *aBuffer)
+{
+    NS_ADDREF(*aBuffer = mBuffer);
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteOffset; */
+NS_IMETHODIMP WebGLShortArray::GetByteOffset(PRUint32 *aByteOffset)
+{
+    *aByteOffset = mOffset;
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLShortArray::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = mLength * sizeof(short);
+    return NS_OK;
+}
+
+/* attribute unsigned long length; */
+NS_IMETHODIMP WebGLShortArray::GetLength(PRUint32 *aLength)
+{
+    *aLength = mLength;
+    return NS_OK;
+}
+
+/* unsigned long alignedSizeInBytes (); */
+NS_IMETHODIMP WebGLShortArray::AlignedSizeInBytes(PRUint32 *retval)
+{
+    *retval = mBuffer->capacity;
+    return NS_OK;
+}
+
+/* nsIWebGLArray slice (in unsigned long offset, in unsigned long length); */
+NS_IMETHODIMP WebGLShortArray::Slice(PRUint32 offset, PRUint32 length, nsIWebGLArray **retval)
+{
+    if (length == 0) 
+        return NS_ERROR_FAILURE;
+
+    if (offset + length > mBuffer->capacity)
+        return NS_ERROR_FAILURE;
+
+    nsIWebGLArray *wga = new WebGLShortArray(mBuffer, offset, length);
+    NS_ADDREF(*retval = wga);
+    return NS_OK;
+}
+
+/* [IndexGetter] long get (in unsigned long index); */
+NS_IMETHODIMP WebGLShortArray::Get(PRUint32 index, PRInt32 *retval)
+{
+    if (index >= mLength)
+        return NS_ERROR_FAILURE;
+
+    short *values = static_cast<short*>(mBuffer->data);
+    *retval = values[index];
+
+    return NS_OK;
+}
+
+void
+WebGLShortArray::Set(PRUint32 index, short value)
+{
+    if (index >= mLength)
+        return;
+
+    short *values = static_cast<short*>(mBuffer->data);
+    values[index] = value;
+}
+
+/* void set (); */
+NS_IMETHODIMP WebGLShortArray::Set()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 1 || js.argc > 2)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (JSVAL_IS_NUMBER(js.argv[0])) {
+        if (js.argc != 2)
+            return NS_ERROR_DOM_SYNTAX_ERR;
+
+        uint32 index;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index);
+
+        int32 value;
+        ::JS_ValueToECMAInt32(js.ctx, js.argv[1], &value);
+
+        if (index >= mLength)
+            return NS_ERROR_FAILURE;
+
+        Set(index, (short) value);
+    } else {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(PRUint32) WebGLShortArray::NativeType()
+{
+    return mBuffer->type;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLShortArray::NativePointer()
+{
+    return mBuffer->data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLShortArray::NativeSize()
+{
+    return mBuffer->capacity;
+}
+
+/* [noscript, notxpcom] unsigned long nativeElementSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLShortArray::NativeElementSize()
+{
+    return mBuffer->ElementSize();
+}
+
+/* [noscript, notxpcom] unsigned long nativeCount (); */
+NS_IMETHODIMP_(PRUint32) WebGLShortArray::NativeCount()
+{
+    return mBuffer->length;
+}
+
+// nsIXPCScriptable
+#define XPC_MAP_CLASSNAME WebGLShortArray
+#define XPC_MAP_QUOTED_CLASSNAME "WebGLShortArray"
+#define XPC_MAP_WANT_SETPROPERTY
+#define XPC_MAP_WANT_GETPROPERTY
+#define XPC_MAP_WANT_NEWRESOLVE
+#define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY
+#include "xpc_map_end.h"
+
+PRBool WebGLShortArray::JSValToIndex(JSContext *cx, jsval id, uint32 *retval) {
+    PRBool ok = PR_FALSE;
+    uint32 index;
+
+    if (JSVAL_IS_INT(id)) {
+        index = JSVAL_TO_INT(id);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, id, &index);
+    }
+
+    if (!ok || index >= mLength)
+        return PR_FALSE;
+
+    *retval = index;
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP WebGLShortArray::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                           JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRInt32 val;
+    Get(index, &val);
+    *_retval = JS_NewNumberValue(cx, val, vp);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLShortArray::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                           JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    int32 val;
+
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRBool ok = PR_FALSE;
+
+    if (JSVAL_IS_INT(*vp)) {
+        val = JSVAL_TO_INT(*vp);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAInt32(cx, *vp, &val);
+    }
+
+    if (!ok) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    Set(index, (short) val);
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLShortArray::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                          JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp,
+                                          PRBool *_retval)
+{
+    uint32 index;
+    PRBool ok = JSValToIndex(cx, id, &index);
+
+    if (ok) {
+        *_retval = PR_TRUE;
+        *objp = obj;
+    } else {
+        *_retval = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+/*
+ * WebGLUnsignedShortArray
+ */
+
+nsresult
+NS_NewWebGLUnsignedShortArray(nsISupports **aResult)
+{
+    nsIWebGLUnsignedShortArray *wgusa = new WebGLUnsignedShortArray();
+    if (!wgusa)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wgusa);
+    return NS_OK;
+}
+
+WebGLUnsignedShortArray::WebGLUnsignedShortArray(PRUint32 length)
+    : mOffset(0), mLength(length)
+{
+    mBuffer = new WebGLArrayBuffer(length * sizeof(short));
+}
+
+WebGLUnsignedShortArray::WebGLUnsignedShortArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length)
+    : mBuffer(buffer), mOffset(offset), mLength(length)
+{
+}
+
+WebGLUnsignedShortArray::WebGLUnsignedShortArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen)
+    : mOffset(0), mLength(arrayLen)
+{
+    mBuffer = new WebGLArrayBuffer();
+    mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_SHORT, 1, cx, arrayObj, arrayLen);
+}
+
+NS_IMETHODIMP
+WebGLUnsignedShortArray::Initialize(nsISupports *owner,
+                                   JSContext *cx,
+                                   JSObject *obj,
+                                   PRUint32 argc,
+                                   jsval *argv)
+{
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        mBuffer = new WebGLArrayBuffer();
+        mBuffer->Prepare(LOCAL_GL_UNSIGNED_SHORT, 1, length);
+        mBuffer->Zero();
+        mLength = length;
+    } else {
+        JSObject *arrayObj;
+        jsuint arrayLen;
+        jsuint byteOffset = 0;
+        jsuint length = 0;
+
+        if (!::JS_ConvertArguments(cx, argc, argv, "o/uu", &arrayObj, &byteOffset, &length) ||
+            arrayObj == NULL)
+        {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (::JS_IsArrayObject(cx, arrayObj) &&
+            ::JS_GetArrayLength(cx, arrayObj, &arrayLen))
+        {
+            mBuffer = new WebGLArrayBuffer();
+            mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_SHORT, 1, cx, arrayObj, arrayLen);
+            mLength = arrayLen;
+        } else {
+            nsCOMPtr<nsIWebGLArrayBuffer> canvasObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(cx, arrayObj, NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(canvasObj));
+            if (NS_FAILED(rv) || !canvasObj) {
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            mBuffer = canvasObj->GetNativeArrayBuffer();
+
+            if (byteOffset % sizeof(short))
+                return NS_ERROR_FAILURE;
+
+            if ((byteOffset + (length * sizeof(short))) > mBuffer->capacity)
+                return NS_ERROR_FAILURE;
+
+            if (length > 0) {
+                mLength = length;
+            } else {
+                if ((mBuffer->capacity - byteOffset) % sizeof(short)) 
+                    return NS_ERROR_FAILURE;
+
+                mLength = (mBuffer->capacity - byteOffset) / sizeof(short);
+            }
+        }
+    }
+
+    return NS_OK;
+}
+
+/* readonly attribute nsIWebGLArrayBuffer buffer; */
+NS_IMETHODIMP WebGLUnsignedShortArray::GetBuffer(nsIWebGLArrayBuffer * *aBuffer)
+{
+    NS_ADDREF(*aBuffer = mBuffer);
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteOffset; */
+NS_IMETHODIMP WebGLUnsignedShortArray::GetByteOffset(PRUint32 *aByteOffset)
+{
+    *aByteOffset = mOffset;
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLUnsignedShortArray::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = mLength * sizeof(short);
+    return NS_OK;
+}
+
+/* attribute unsigned long length; */
+NS_IMETHODIMP WebGLUnsignedShortArray::GetLength(PRUint32 *aLength)
+{
+    *aLength = mLength;
+    return NS_OK;
+}
+
+/* unsigned long alignedSizeInBytes (); */
+NS_IMETHODIMP WebGLUnsignedShortArray::AlignedSizeInBytes(PRUint32 *retval)
+{
+    *retval = mBuffer->capacity;
+    return NS_OK;
+}
+
+/* nsIWebGLArray slice (in unsigned long offset, in unsigned long length); */
+NS_IMETHODIMP WebGLUnsignedShortArray::Slice(PRUint32 offset, PRUint32 length, nsIWebGLArray **retval)
+{
+    if (length == 0) 
+        return NS_ERROR_FAILURE;
+
+    if (offset + length > mBuffer->capacity)
+        return NS_ERROR_FAILURE;
+
+    nsIWebGLArray *wga = new WebGLUnsignedShortArray(mBuffer, offset, length);
+    NS_ADDREF(*retval = wga);
+    return NS_OK;
+}
+
+/* [IndexGetter] unsigned long get (in unsigned long index); */
+NS_IMETHODIMP WebGLUnsignedShortArray::Get(PRUint32 index, PRUint32 *retval)
+{
+    if (index >= mLength)
+        return NS_ERROR_FAILURE;
+
+    unsigned short *values = static_cast<unsigned short*>(mBuffer->data);
+    *retval = values[index];
+
+    return NS_OK;
+}
+
+void
+WebGLUnsignedShortArray::Set(PRUint32 index, unsigned short value)
+{
+    if (index >= mLength)
+        return;
+
+    unsigned short *values = static_cast<unsigned short*>(mBuffer->data);
+    values[index] = value;
+}
+
+/* void set (); */
+NS_IMETHODIMP WebGLUnsignedShortArray::Set()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 1 || js.argc > 2)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (JSVAL_IS_NUMBER(js.argv[0])) {
+        if (js.argc != 2)
+            return NS_ERROR_DOM_SYNTAX_ERR;
+
+        uint32 index;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index);
+
+        uint32 value;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[1], &value);
+
+        if (index >= mLength)
+            return NS_ERROR_FAILURE;
+
+        Set(index, (unsigned short) value);
+    } else {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedShortArray::NativeType()
+{
+    return mBuffer->type;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLUnsignedShortArray::NativePointer()
+{
+    return mBuffer->data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedShortArray::NativeSize()
+{
+    return mBuffer->capacity;
+}
+
+/* [noscript, notxpcom] unsigned long nativeElementSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedShortArray::NativeElementSize()
+{
+    return mBuffer->ElementSize();
+}
+
+/* [noscript, notxpcom] unsigned long nativeCount (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedShortArray::NativeCount()
+{
+    return mBuffer->length;
+}
+
+// nsIXPCScriptable
+#define XPC_MAP_CLASSNAME WebGLUnsignedShortArray
+#define XPC_MAP_QUOTED_CLASSNAME "WebGLUnsignedShortArray"
+#define XPC_MAP_WANT_SETPROPERTY
+#define XPC_MAP_WANT_GETPROPERTY
+#define XPC_MAP_WANT_NEWRESOLVE
+#define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY
+#include "xpc_map_end.h"
+
+PRBool WebGLUnsignedShortArray::JSValToIndex(JSContext *cx, jsval id, uint32 *retval) {
+    PRBool ok = PR_FALSE;
+    uint32 index;
+
+    if (JSVAL_IS_INT(id)) {
+        index = JSVAL_TO_INT(id);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, id, &index);
+    }
+
+    if (!ok || index >= mLength)
+        return PR_FALSE;
+
+    *retval = index;
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP WebGLUnsignedShortArray::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                   JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRUint32 val;
+    Get(index, &val);
+    *_retval = JS_NewNumberValue(cx, val, vp);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLUnsignedShortArray::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                   JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    uint32 val;
+
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRBool ok = PR_FALSE;
+
+    if (JSVAL_IS_INT(*vp)) {
+        val = JSVAL_TO_INT(*vp);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, *vp, &val);
+    }
+
+    if (!ok) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    Set(index, (unsigned short) val);
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLUnsignedShortArray::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                  JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp,
+                                                  PRBool *_retval)
+{
+    uint32 index;
+    PRBool ok = JSValToIndex(cx, id, &index);
+
+    if (ok) {
+        *_retval = PR_TRUE;
+        *objp = obj;
+    } else {
+        *_retval = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+/*
+ * WebGLIntArray
+ */
+
+nsresult
+NS_NewWebGLIntArray(nsISupports **aResult)
+{
+    nsIWebGLIntArray *wgia = new WebGLIntArray();
+    if (!wgia)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wgia);
+    return NS_OK;
+}
+
+WebGLIntArray::WebGLIntArray(PRUint32 length)
+    : mOffset(0), mLength(length)
+{
+    mBuffer = new WebGLArrayBuffer(length * sizeof(int));
+}
+
+WebGLIntArray::WebGLIntArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length)
+    : mBuffer(buffer), mOffset(offset), mLength(length)
+{
+}
+
+WebGLIntArray::WebGLIntArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen)
+    : mOffset(0), mLength(arrayLen)
+{
+    mBuffer = new WebGLArrayBuffer();
+    mBuffer->InitFromJSArray(LOCAL_GL_INT, 1, cx, arrayObj, arrayLen);
+}
+
+NS_IMETHODIMP
+WebGLIntArray::Initialize(nsISupports *owner,
+                          JSContext *cx,
+                          JSObject *obj,
+                          PRUint32 argc,
+                          jsval *argv)
+{
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        mBuffer = new WebGLArrayBuffer();
+        mBuffer->Prepare(LOCAL_GL_INT, 1, length);
+        mBuffer->Zero();
+        mLength = length;
+    } else {
+        JSObject *arrayObj;
+        jsuint arrayLen;
+        jsuint byteOffset = 0;
+        jsuint length = 0;
+
+        if (!::JS_ConvertArguments(cx, argc, argv, "o/uu", &arrayObj, &byteOffset, &length) ||
+            arrayObj == NULL)
+        {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (::JS_IsArrayObject(cx, arrayObj) &&
+            ::JS_GetArrayLength(cx, arrayObj, &arrayLen))
+        {
+            mBuffer = new WebGLArrayBuffer();
+            mBuffer->InitFromJSArray(LOCAL_GL_INT, 1, cx, arrayObj, arrayLen);
+            mLength = arrayLen;
+        } else {
+            nsCOMPtr<nsIWebGLArrayBuffer> canvasObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(cx, arrayObj, NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(canvasObj));
+            if (NS_FAILED(rv) || !canvasObj) {
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            mBuffer = canvasObj->GetNativeArrayBuffer();
+
+            if (byteOffset % sizeof(int))
+                return NS_ERROR_FAILURE;
+
+            if ((byteOffset + (length * sizeof(int))) > mBuffer->capacity)
+                return NS_ERROR_FAILURE;
+
+            if (length > 0) {
+                mLength = length;
+            } else {
+                if ((mBuffer->capacity - byteOffset) % sizeof(int))
+                    return NS_ERROR_FAILURE;
+
+                mLength = (mBuffer->capacity - byteOffset) / sizeof(int);
+            }
+        }
+    }
+
+    return NS_OK;
+}
+
+/* readonly attribute nsIWebGLArrayBuffer buffer; */
+NS_IMETHODIMP WebGLIntArray::GetBuffer(nsIWebGLArrayBuffer * *aBuffer)
+{
+    NS_ADDREF(*aBuffer = mBuffer);
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteOffset; */
+NS_IMETHODIMP WebGLIntArray::GetByteOffset(PRUint32 *aByteOffset)
+{
+    *aByteOffset = mOffset;
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLIntArray::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = mLength * sizeof(int);
+    return NS_OK;
+}
+
+/* attribute unsigned long length; */
+NS_IMETHODIMP WebGLIntArray::GetLength(PRUint32 *aLength)
+{
+    *aLength = mLength;
+    return NS_OK;
+}
+
+/* unsigned long alignedSizeInBytes (); */
+NS_IMETHODIMP WebGLIntArray::AlignedSizeInBytes(PRUint32 *retval)
+{
+    *retval = mBuffer->capacity;
+    return NS_OK;
+}
+
+/* nsIWebGLArray slice (in unsigned long offset, in unsigned long length); */
+NS_IMETHODIMP WebGLIntArray::Slice(PRUint32 offset, PRUint32 length, nsIWebGLArray **retval)
+{
+    if (length == 0) 
+        return NS_ERROR_FAILURE;
+
+    if (offset + length > mBuffer->capacity)
+        return NS_ERROR_FAILURE;
+
+    nsIWebGLArray *wga = new WebGLIntArray(mBuffer, offset, length);
+    NS_ADDREF(*retval = wga);
+    return NS_OK;
+}
+
+/* [IndexGetter] long get (in unsigned long index); */
+NS_IMETHODIMP WebGLIntArray::Get(PRUint32 index, PRInt32 *retval)
+{
+    if (index >= mLength)
+        return NS_ERROR_FAILURE;
+
+    int *values = static_cast<int*>(mBuffer->data);
+    *retval = values[index];
+
+    return NS_OK;
+}
+
+void
+WebGLIntArray::Set(PRUint32 index, int value)
+{
+    if (index >= mLength)
+        return;
+
+    int *values = static_cast<int*>(mBuffer->data);
+    values[index] = value;
+}
+
+/* void set (); */
+NS_IMETHODIMP WebGLIntArray::Set()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 1 || js.argc > 2)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (JSVAL_IS_NUMBER(js.argv[0])) {
+        if (js.argc != 2)
+            return NS_ERROR_DOM_SYNTAX_ERR;
+
+        uint32 index;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index);
+
+        int32 value;
+        ::JS_ValueToECMAInt32(js.ctx, js.argv[1], &value);
+
+        if (index >= mLength)
+            return NS_ERROR_FAILURE;
+
+        Set(index, value);
+    } else {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(PRUint32) WebGLIntArray::NativeType()
+{
+    return mBuffer->type;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLIntArray::NativePointer()
+{
+    return mBuffer->data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLIntArray::NativeSize()
+{
+    return mBuffer->capacity;
+}
+
+/* [noscript, notxpcom] unsigned long nativeElementSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLIntArray::NativeElementSize()
+{
+    return mBuffer->ElementSize();
+}
+
+/* [noscript, notxpcom] unsigned long nativeCount (); */
+NS_IMETHODIMP_(PRUint32) WebGLIntArray::NativeCount()
+{
+    return mBuffer->length;
+}
+
+// nsIXPCScriptable
+#define XPC_MAP_CLASSNAME WebGLIntArray
+#define XPC_MAP_QUOTED_CLASSNAME "WebGLIntArray"
+#define XPC_MAP_WANT_SETPROPERTY
+#define XPC_MAP_WANT_GETPROPERTY
+#define XPC_MAP_WANT_NEWRESOLVE
+#define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY
+#include "xpc_map_end.h"
+
+PRBool WebGLIntArray::JSValToIndex(JSContext *cx, jsval id, uint32 *retval) {
+    PRBool ok = PR_FALSE;
+    uint32 index;
+
+    if (JSVAL_IS_INT(id)) {
+        index = JSVAL_TO_INT(id);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, id, &index);
+    }
+
+    if (!ok || index >= mLength)
+        return PR_FALSE;
+
+    *retval = index;
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP WebGLIntArray::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                         JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRInt32 val;
+    Get(index, &val);
+    *_retval = JS_NewNumberValue(cx, val, vp);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLIntArray::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                         JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    int32 val;
+
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRBool ok = PR_FALSE;
+
+    if (JSVAL_IS_INT(*vp)) {
+        val = JSVAL_TO_INT(*vp);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAInt32(cx, *vp, &val);
+    }
+
+    if (!ok) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    Set(index, val);
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLIntArray::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                        JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp,
+                                        PRBool *_retval)
+{
+    uint32 index;
+    PRBool ok = JSValToIndex(cx, id, &index);
+
+    if (ok) {
+        *_retval = PR_TRUE;
+        *objp = obj;
+    } else {
+        *_retval = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+/*
+ * WebGLUnsignedIntArray
+ */
+
+nsresult
+NS_NewWebGLUnsignedIntArray(nsISupports **aResult)
+{
+    nsIWebGLUnsignedIntArray *wguia = new WebGLUnsignedIntArray();
+    if (!wguia)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = wguia);
+    return NS_OK;
+}
+
+WebGLUnsignedIntArray::WebGLUnsignedIntArray(PRUint32 length)
+    : mOffset(0), mLength(length)
+{
+    mBuffer = new WebGLArrayBuffer(length * sizeof(int));
+}
+
+WebGLUnsignedIntArray::WebGLUnsignedIntArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length)
+    : mBuffer(buffer), mOffset(offset), mLength(length)
+{
+}
+
+WebGLUnsignedIntArray::WebGLUnsignedIntArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen)
+    : mOffset(0), mLength(arrayLen)
+{
+    mBuffer = new WebGLArrayBuffer();
+    mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_INT, 1, cx, arrayObj, arrayLen);
+}
+
+NS_IMETHODIMP
+WebGLUnsignedIntArray::Initialize(nsISupports *owner,
+                                  JSContext *cx,
+                                  JSObject *obj,
+                                  PRUint32 argc,
+                                  jsval *argv)
+{
+    if (JSVAL_IS_NUMBER(argv[0])) {
+        uint32 length;
+        ::JS_ValueToECMAUint32(cx, argv[0], &length);
+        mBuffer = new WebGLArrayBuffer();
+        mBuffer->Prepare(LOCAL_GL_UNSIGNED_INT, 1, length);
+        mBuffer->Zero();
+        mLength = length;
+    } else {
+        JSObject *arrayObj;
+        jsuint arrayLen;
+        jsuint byteOffset = 0;
+        jsuint length = 0;
+
+        if (!::JS_ConvertArguments(cx, argc, argv, "o/uu", &arrayObj, &byteOffset, &length) ||
+            arrayObj == NULL)
+        {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (::JS_IsArrayObject(cx, arrayObj) &&
+            ::JS_GetArrayLength(cx, arrayObj, &arrayLen))
+        {
+            mBuffer = new WebGLArrayBuffer();
+            mBuffer->InitFromJSArray(LOCAL_GL_UNSIGNED_INT, 1, cx, arrayObj, arrayLen);
+            mLength = arrayLen;
+        } else {
+            nsCOMPtr<nsIWebGLArrayBuffer> canvasObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(cx, arrayObj, NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(canvasObj));
+            if (NS_FAILED(rv) || !canvasObj) {
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            mBuffer = canvasObj->GetNativeArrayBuffer();
+
+            if (byteOffset % sizeof(int))
+                return NS_ERROR_FAILURE;
+
+            if ((byteOffset + (length * sizeof(int))) > mBuffer->capacity)
+                return NS_ERROR_FAILURE;
+
+            if (length > 0) {
+                mLength = length;
+            } else {
+                if ((mBuffer->capacity - byteOffset) % sizeof(int))
+                    return NS_ERROR_FAILURE;
+
+                mLength = (mBuffer->capacity - byteOffset) / sizeof(int);
+            }
+        }
+    }
+
+    return NS_OK;
+}
+
+/* readonly attribute nsIWebGLArrayBuffer buffer; */
+NS_IMETHODIMP WebGLUnsignedIntArray::GetBuffer(nsIWebGLArrayBuffer * *aBuffer)
+{
+    NS_ADDREF(*aBuffer = mBuffer);
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteOffset; */
+NS_IMETHODIMP WebGLUnsignedIntArray::GetByteOffset(PRUint32 *aByteOffset)
+{
+    *aByteOffset = mOffset;
+    return NS_OK;
+}
+
+/* readonly attribute unsigned long byteLength; */
+NS_IMETHODIMP WebGLUnsignedIntArray::GetByteLength(PRUint32 *aByteLength)
+{
+    *aByteLength = mLength * sizeof(int);
+    return NS_OK;
+}
+
+/* attribute unsigned long length; */
+NS_IMETHODIMP WebGLUnsignedIntArray::GetLength(PRUint32 *aLength)
+{
+    *aLength = mLength;
+    return NS_OK;
+}
+
+/* unsigned long alignedSizeInBytes (); */
+NS_IMETHODIMP WebGLUnsignedIntArray::AlignedSizeInBytes(PRUint32 *retval)
+{
+    *retval = mBuffer->capacity;
+    return NS_OK;
+}
+
+/* nsIWebGLArray slice (in unsigned long offset, in unsigned long length); */
+NS_IMETHODIMP WebGLUnsignedIntArray::Slice(PRUint32 offset, PRUint32 length, nsIWebGLArray **retval)
+{
+    if (length == 0) 
+        return NS_ERROR_FAILURE;
+
+    if (offset + length > mBuffer->capacity)
+        return NS_ERROR_FAILURE;
+
+    nsIWebGLArray *wga = new WebGLUnsignedIntArray(mBuffer, offset, length);
+    NS_ADDREF(*retval = wga);
+    return NS_OK;
+}
+
+/* [IndexGetter] unsigned long get (in unsigned long index); */
+NS_IMETHODIMP WebGLUnsignedIntArray::Get(PRUint32 index, PRUint32 *retval)
+{
+    if (index >= mLength)
+        return NS_ERROR_FAILURE;
+
+    unsigned int *values = static_cast<unsigned int*>(mBuffer->data);
+    *retval = values[index];
+
+    return NS_OK;
+}
+
+void
+WebGLUnsignedIntArray::Set(PRUint32 index, unsigned int value)
+{
+    if (index >= mLength)
+        return;
+
+    unsigned int *values = static_cast<unsigned int*>(mBuffer->data);
+    values[index] = value;
+}
+
+/* void set (); */
+NS_IMETHODIMP WebGLUnsignedIntArray::Set()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 1 || js.argc > 2)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (JSVAL_IS_NUMBER(js.argv[0])) {
+        if (js.argc != 2)
+            return NS_ERROR_DOM_SYNTAX_ERR;
+
+        uint32 index;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index);
+
+        uint32 value;
+        ::JS_ValueToECMAUint32(js.ctx, js.argv[1], &value);
+
+        if (index >= mLength)
+            return NS_ERROR_FAILURE;
+
+        Set(index, value);
+    } else {
+        return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedIntArray::NativeType()
+{
+    return mBuffer->type;
+}
+
+/* [noscript, notxpcom] voidPtr nativePointer (); */
+NS_IMETHODIMP_(void *) WebGLUnsignedIntArray::NativePointer()
+{
+    return mBuffer->data;
+}
+
+/* [noscript, notxpcom] unsigned long nativeSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedIntArray::NativeSize()
+{
+    return mBuffer->capacity;
+}
+
+/* [noscript, notxpcom] unsigned long nativeElementSize (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedIntArray::NativeElementSize()
+{
+    return mBuffer->ElementSize();
+}
+
+/* [noscript, notxpcom] unsigned long nativeCount (); */
+NS_IMETHODIMP_(PRUint32) WebGLUnsignedIntArray::NativeCount()
+{
+    return mBuffer->length;
+}
+
+// nsIXPCScriptable
+#define XPC_MAP_CLASSNAME WebGLUnsignedIntArray
+#define XPC_MAP_QUOTED_CLASSNAME "WebGLUnsignedIntArray"
+#define XPC_MAP_WANT_SETPROPERTY
+#define XPC_MAP_WANT_GETPROPERTY
+#define XPC_MAP_WANT_NEWRESOLVE
+#define XPC_MAP_FLAGS nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY
+#include "xpc_map_end.h"
+
+PRBool WebGLUnsignedIntArray::JSValToIndex(JSContext *cx, jsval id, uint32 *retval) {
+    PRBool ok = PR_FALSE;
+    uint32 index;
+
+    if (JSVAL_IS_INT(id)) {
+        index = JSVAL_TO_INT(id);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, id, &index);
+    }
+
+    if (!ok || index >= mLength)
+        return PR_FALSE;
+
+    *retval = index;
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP WebGLUnsignedIntArray::GetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                 JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRUint32 val;
+    Get(index, &val);
+    *_retval = JS_NewNumberValue(cx, val, vp);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLUnsignedIntArray::SetProperty(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                 JSObject * obj, jsval id, jsval * vp, PRBool *_retval)
+{
+    uint32 index;
+    uint32 val;
+
+    if (!JSValToIndex(cx, id, &index)) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    PRBool ok = PR_FALSE;
+
+    if (JSVAL_IS_INT(*vp)) {
+        val = JSVAL_TO_INT(*vp);
+        ok = PR_TRUE;
+    } else {
+        ok = JS_ValueToECMAUint32(cx, *vp, &val);
+    }
+
+    if (!ok) {
+        *_retval = PR_FALSE;
+        return NS_ERROR_INVALID_ARG;
+    }
+
+    Set(index, val);
+    return NS_OK;
+}
+
+NS_IMETHODIMP WebGLUnsignedIntArray::NewResolve(nsIXPConnectWrappedNative *wrapper, JSContext * cx,
+                                                JSObject * obj, jsval id, PRUint32 flags, JSObject * *objp,
+                                                PRBool *_retval)
+{
+    uint32 index;
+    PRBool ok = JSValToIndex(cx, id, &index);
+
+    if (ok) {
+        *_retval = PR_TRUE;
+        *objp = obj;
+    } else {
+        *_retval = PR_FALSE;
+        return NS_ERROR_FAILURE;
+    }
+
+    return NS_OK;
+}
+
+
+/*
+ * XPCOM AddRef/Release/QI
+ */
+NS_IMPL_ADDREF(WebGLArrayBuffer)
+NS_IMPL_RELEASE(WebGLArrayBuffer)
+
+NS_INTERFACE_MAP_BEGIN(WebGLArrayBuffer)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArrayBuffer)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLArrayBuffer)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLArrayBuffer)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLFloatArray)
+NS_IMPL_RELEASE(WebGLFloatArray)
+
+NS_INTERFACE_MAP_BEGIN(WebGLFloatArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLFloatArray)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLFloatArray)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLFloatArray)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLByteArray)
+NS_IMPL_RELEASE(WebGLByteArray)
+
+NS_INTERFACE_MAP_BEGIN(WebGLByteArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLByteArray)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLByteArray)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLByteArray)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLUnsignedByteArray)
+NS_IMPL_RELEASE(WebGLUnsignedByteArray)
+
+NS_INTERFACE_MAP_BEGIN(WebGLUnsignedByteArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLUnsignedByteArray)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLUnsignedByteArray)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLUnsignedByteArray)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLShortArray)
+NS_IMPL_RELEASE(WebGLShortArray)
+
+NS_INTERFACE_MAP_BEGIN(WebGLShortArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLShortArray)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLShortArray)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLShortArray)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLUnsignedShortArray)
+NS_IMPL_RELEASE(WebGLUnsignedShortArray)
+
+NS_INTERFACE_MAP_BEGIN(WebGLUnsignedShortArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLUnsignedShortArray)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLUnsignedShortArray)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLUnsignedShortArray)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLIntArray)
+NS_IMPL_RELEASE(WebGLIntArray)
+
+NS_INTERFACE_MAP_BEGIN(WebGLIntArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLIntArray)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLIntArray)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLIntArray)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLUnsignedIntArray)
+NS_IMPL_RELEASE(WebGLUnsignedIntArray)
+
+NS_INTERFACE_MAP_BEGIN(WebGLUnsignedIntArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLArray)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLUnsignedIntArray)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebGLUnsignedIntArray)
+  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
+  NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLUnsignedIntArray)
+NS_INTERFACE_MAP_END
diff -r 5b1fe1bf3872 content/canvas/src/WebGLArrays.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLArrays.h	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,344 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mark Steele <mwsteele@gmail.com>
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef WEBGLARRAYS_H_
+#define WEBGLARRAYS_H_
+
+#include <stdarg.h>
+
+#include "nsTArray.h"
+#include "nsDataHashtable.h"
+#include "nsRefPtrHashtable.h"
+#include "nsHashKeys.h"
+
+#include "nsICanvasRenderingContextWebGL.h"
+#include "nsICanvasRenderingContextInternal.h"
+#include "nsIJSNativeInitializer.h"
+#include "nsIXPCScriptable.h"
+
+#include "SimpleBuffer.h"
+
+namespace mozilla {
+
+//
+// array wrapper classes
+//
+
+// XXX refactor buffer stuff
+class WebGLArrayBuffer :
+    public nsIWebGLArrayBuffer,
+    public nsIJSNativeInitializer,
+    public SimpleBuffer
+{
+public:
+
+    WebGLArrayBuffer() { }
+    WebGLArrayBuffer(PRUint32 length);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAYBUFFER
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+};
+
+class WebGLArray
+{
+    
+};
+
+class WebGLFloatArray :
+    public nsIXPCScriptable,
+    public nsIWebGLFloatArray,
+    public nsIJSNativeInitializer
+{
+public:
+    WebGLFloatArray() :
+        mOffset(0), mLength(0) { }
+
+    WebGLFloatArray(PRUint32 length);
+    WebGLFloatArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length);
+    WebGLFloatArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAY
+    NS_DECL_NSIWEBGLFLOATARRAY
+    NS_DECL_NSIXPCSCRIPTABLE
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+
+    void Set(PRUint32 index, float value);
+    PRBool JSValToIndex(JSContext *cx, jsval id, uint32 *retval);
+
+protected:
+    nsRefPtr<WebGLArrayBuffer> mBuffer;
+    PRUint32 mOffset;
+    PRUint32 mLength;
+    PRUint32 mSize;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+class WebGLByteArray :
+    public nsIXPCScriptable,
+    public nsIWebGLByteArray,
+    public nsIJSNativeInitializer
+{
+public:
+    WebGLByteArray() :
+        mOffset(0), mLength(0) { }
+
+    WebGLByteArray(PRUint32 length);
+    WebGLByteArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length);
+    WebGLByteArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAY
+    NS_DECL_NSIWEBGLBYTEARRAY
+    NS_DECL_NSIXPCSCRIPTABLE
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+
+    void Set(PRUint32 index, char value);
+    PRBool JSValToIndex(JSContext *cx, jsval id, uint32 *retval);
+
+protected:
+    nsRefPtr<WebGLArrayBuffer> mBuffer;
+    PRUint32 mOffset;
+    PRUint32 mLength;
+    PRUint32 mSize;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+class WebGLUnsignedByteArray :
+    public nsIXPCScriptable,
+    public nsIWebGLUnsignedByteArray,
+    public nsIJSNativeInitializer
+{
+public:
+    WebGLUnsignedByteArray() :
+        mOffset(0), mLength(0) { }
+
+    WebGLUnsignedByteArray(PRUint32 length);
+    WebGLUnsignedByteArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length);
+    WebGLUnsignedByteArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAY
+    NS_DECL_NSIWEBGLUNSIGNEDBYTEARRAY
+    NS_DECL_NSIXPCSCRIPTABLE
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+
+    void Set(PRUint32 index, unsigned char value);
+    PRBool JSValToIndex(JSContext *cx, jsval id, uint32 *retval);
+
+protected:
+    nsRefPtr<WebGLArrayBuffer> mBuffer;
+    PRUint32 mOffset;
+    PRUint32 mLength;
+    PRUint32 mSize;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+class WebGLShortArray :
+    public nsIXPCScriptable,
+    public nsIWebGLShortArray,
+    public nsIJSNativeInitializer
+{
+public:
+    WebGLShortArray() :
+        mOffset(0), mLength(0) { }
+
+    WebGLShortArray(PRUint32 length);
+    WebGLShortArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length);
+    WebGLShortArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAY
+    NS_DECL_NSIWEBGLSHORTARRAY
+    NS_DECL_NSIXPCSCRIPTABLE
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+
+    void Set(PRUint32 index, short value);
+    PRBool JSValToIndex(JSContext *cx, jsval id, uint32 *retval);
+
+protected:
+    nsRefPtr<WebGLArrayBuffer> mBuffer;
+    PRUint32 mOffset;
+    PRUint32 mLength;
+    PRUint32 mSize;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+class WebGLUnsignedShortArray :
+    public nsIXPCScriptable,
+    public nsIWebGLUnsignedShortArray,
+    public nsIJSNativeInitializer
+{
+public:
+    WebGLUnsignedShortArray() :
+        mOffset(0), mLength(0) { }
+
+    WebGLUnsignedShortArray(PRUint32 length);
+    WebGLUnsignedShortArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length);
+    WebGLUnsignedShortArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAY
+    NS_DECL_NSIWEBGLUNSIGNEDSHORTARRAY
+    NS_DECL_NSIXPCSCRIPTABLE
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+
+    void Set(PRUint32 index, unsigned short value);
+    PRBool JSValToIndex(JSContext *cx, jsval id, uint32 *retval);
+
+protected:
+    nsRefPtr<WebGLArrayBuffer> mBuffer;
+    PRUint32 mOffset;
+    PRUint32 mLength;
+    PRUint32 mSize;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+class WebGLIntArray :
+    public nsIXPCScriptable,
+    public nsIWebGLIntArray,
+    public nsIJSNativeInitializer
+{
+public:
+    WebGLIntArray() :
+        mOffset(0), mLength(0) { }
+
+    WebGLIntArray(PRUint32 length);
+    WebGLIntArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length);
+    WebGLIntArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAY
+    NS_DECL_NSIWEBGLINTARRAY
+    NS_DECL_NSIXPCSCRIPTABLE
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+
+    void Set(PRUint32 index, int value);
+    PRBool JSValToIndex(JSContext *cx, jsval id, uint32 *retval);
+
+protected:
+    nsRefPtr<WebGLArrayBuffer> mBuffer;
+    PRUint32 mOffset;
+    PRUint32 mLength;
+    PRUint32 mSize;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+class WebGLUnsignedIntArray :
+    public nsIXPCScriptable,
+    public nsIWebGLUnsignedIntArray,
+    public nsIJSNativeInitializer
+{
+public:
+    WebGLUnsignedIntArray() :
+        mOffset(0), mLength(0) { }
+
+    WebGLUnsignedIntArray(PRUint32 length);
+    WebGLUnsignedIntArray(WebGLArrayBuffer *buffer, PRUint32 offset, PRUint32 length);
+    WebGLUnsignedIntArray(JSContext *cx, JSObject *arrayObj, jsuint arrayLen);
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLARRAY
+    NS_DECL_NSIWEBGLUNSIGNEDINTARRAY
+    NS_DECL_NSIXPCSCRIPTABLE
+
+    NS_IMETHOD Initialize(nsISupports* aOwner,
+                          JSContext* aCx,
+                          JSObject* aObj,
+                          PRUint32 aArgc,
+                          jsval* aArgv);
+
+    void Set(PRUint32 index, unsigned int value);
+    PRBool JSValToIndex(JSContext *cx, jsval id, uint32 *retval);
+
+protected:
+    nsRefPtr<WebGLArrayBuffer> mBuffer;
+    PRUint32 mOffset;
+    PRUint32 mLength;
+    PRUint32 mSize;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+} /* namespace mozilla */
+
+
+#endif /* WEBGLARRAYS_H_ */
diff -r 5b1fe1bf3872 content/canvas/src/WebGLContext.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLContext.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,490 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+#include "WebGLContext.h"
+
+#include "nsIConsoleService.h"
+#include "nsIPrefService.h"
+#include "nsServiceManagerUtils.h"
+#include "nsIClassInfoImpl.h"
+#include "nsContentUtils.h"
+#include "nsIXPConnect.h"
+#include "nsDOMError.h"
+
+#include "gfxContext.h"
+#include "gfxPattern.h"
+
+#include "CanvasUtils.h"
+#include "NativeJSContext.h"
+
+#include "WebGLArray.h"
+
+using namespace mozilla;
+
+nsresult NS_NewCanvasRenderingContextWebGL(nsICanvasRenderingContextWebGL** aResult);
+
+nsresult
+NS_NewCanvasRenderingContextWebGL(nsICanvasRenderingContextWebGL** aResult)
+{
+    nsICanvasRenderingContextWebGL* ctx = new WebGLContext();
+    if (!ctx)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    NS_ADDREF(*aResult = ctx);
+    return NS_OK;
+}
+
+WebGLContext::WebGLContext()
+    : gl(nsnull), mCanvasElement(nsnull), mGLPbuffer(nsnull), mWidth(0), mHeight(0),
+      mInvalidated(PR_FALSE), mActiveTexture(0)
+{
+    mMapBuffers.Init();
+    mMapTextures.Init();
+    mMapPrograms.Init();
+    mMapShaders.Init();
+    mMapFramebuffers.Init();
+    mMapRenderbuffers.Init();
+}
+
+WebGLContext::~WebGLContext()
+{
+}
+
+void
+WebGLContext::Invalidate()
+{
+    if (!mCanvasElement)
+        return;
+
+    if (mInvalidated)
+        return;
+
+    mInvalidated = true;
+    mCanvasElement->InvalidateFrame();
+}
+
+//
+// nsICanvasRenderingContextInternal
+//
+
+NS_IMETHODIMP
+WebGLContext::SetCanvasElement(nsICanvasElement* aParentCanvas)
+{
+    nsresult rv;
+
+    if (aParentCanvas == nsnull) {
+        // we get this on shutdown; we should do some more cleanup here,
+        // but instead we just let our destructor do it.
+        return NS_OK;
+    }
+
+    if (!SafeToCreateCanvas3DContext(aParentCanvas))
+        return NS_ERROR_FAILURE;
+
+    //
+    // Let's find our prefs
+    //
+    nsCOMPtr<nsIPrefService> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    PRBool forceSoftware = PR_FALSE;
+
+    nsCOMPtr<nsIPrefBranch> prefBranch;
+    rv = prefService->GetBranch("webgl.", getter_AddRefs(prefBranch));
+    if (NS_SUCCEEDED(rv)) {
+        PRBool val;
+
+        rv = prefBranch->GetBoolPref("software_render", &val);
+        if (NS_SUCCEEDED(rv))
+            forceSoftware = val;
+    }
+
+    LogMessage("Canvas 3D: creating PBuffer...");
+
+    if (!forceSoftware) {
+#if defined(USE_EGL)
+        mGLPbuffer = new nsGLPbufferEGL();
+#elif defined(USE_WGL)
+        mGLPbuffer = new nsGLPbufferWGL();
+#elif defined(USE_GLX)
+        mGLPbuffer = new nsGLPbufferGLX();
+#elif defined(USE_CGL)
+        mGLPbuffer = new nsGLPbufferCGL();
+#else
+        mGLPbuffer = nsnull;
+#endif
+
+        if (mGLPbuffer && !mGLPbuffer->Init(this))
+            mGLPbuffer = nsnull;
+    }
+
+    if (!mGLPbuffer) {
+        mGLPbuffer = new nsGLPbufferOSMESA();
+        if (!mGLPbuffer->Init(this))
+            mGLPbuffer = nsnull;
+    }
+
+    if (!mGLPbuffer)
+        return NS_ERROR_FAILURE;
+
+    gl = mGLPbuffer->GL();
+
+    if (!ValidateGL()) {
+        // XXX over here we need to destroy mGLPbuffer and create a mesa buffer
+
+        LogMessage("Canvas 3D: Couldn't validate OpenGL implementation; is everything needed present?");
+        return NS_ERROR_FAILURE;
+    }
+
+    mCanvasElement = aParentCanvas;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::SetDimensions(PRInt32 width, PRInt32 height)
+{
+    if (mWidth == width && mHeight == height)
+        return NS_OK;
+
+    if (!mGLPbuffer->Resize(width, height)) {
+        LogMessage("mGLPbuffer->Resize failed");
+        return NS_ERROR_FAILURE;
+    }
+
+    LogMessage("Canvas 3D: ready");
+
+    mWidth = width;
+    mHeight = height;
+
+    // Make sure that we clear this out, otherwise
+    // we'll end up displaying random memory
+#if 0
+    int err = glGetError();
+    if (err) {
+        printf ("error before MakeContextCurrent! 0x%04x\n", err);
+    }
+#endif
+
+    MakeContextCurrent();
+    gl->fViewport(0, 0, mWidth, mHeight);
+    gl->fClearColor(0, 0, 0, 0);
+    gl->fClear(LOCAL_GL_COLOR_BUFFER_BIT | LOCAL_GL_DEPTH_BUFFER_BIT | LOCAL_GL_STENCIL_BUFFER_BIT);
+
+#if 0
+    err = glGetError();
+    if (err) {
+        printf ("error after MakeContextCurrent! 0x%04x\n", err);
+    }
+#endif
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::Render(gfxContext *ctx, gfxPattern::GraphicsFilter f)
+{
+    nsresult rv = NS_OK;
+
+    if (mInvalidated) {
+        mGLPbuffer->SwapBuffers();
+        mInvalidated = PR_FALSE;
+    }
+
+    if (!mGLPbuffer)
+        return NS_OK;
+
+    // use GL Drawing if we can get a target GL context; otherwise
+    // go through the fallback path.
+#ifdef HAVE_GL_DRAWING
+    if (mCanvasElement->GLWidgetBeginDrawing()) {
+        glClearColor(0.0, 0.0, 0.0, 0.0);
+        glClear(GL_COLOR_BUFFER_BIT);
+
+        int bwidth = mGLPbuffer->Width();
+        int bheight = mGLPbuffer->Height();
+
+        GLuint tex = 0;
+        glGenTextures(1, &tex);
+        glBindTexture(GL_TEXTURE_RECTANGLE_EXT, tex);
+
+        CGLError err =
+            CGLTexImagePBuffer(CGLGetCurrentContext(),
+                               ((nsGLPbufferCGL*)mGLPbuffer)->GetCGLPbuffer(),
+                               GL_BACK);
+        if (err) {
+            fprintf (stderr, "CGLTexImagePBuffer failed: %d\n", err);
+            glDeleteTextures(1, &tex);
+            return NS_OK;
+        }
+
+        glEnable(GL_TEXTURE_RECTANGLE_EXT);
+
+        glMatrixMode(GL_PROJECTION);
+        glLoadIdentity();
+        //glFrustum(-halfWidth, halfWidth, halfHeight, -halfHeight, 1.0, 100000.0);
+        glOrtho(0, bwidth, bheight, 0, -0.5, 10.0);
+
+        glMatrixMode(GL_MODELVIEW);
+        glLoadIdentity();
+
+        glBegin(GL_QUADS);
+
+        /* Note that the texture needs a y-flip */
+        glTexCoord2f(0.0, bheight);
+        glVertex3f(0.0, 0.0, 0.0);
+
+        glTexCoord2f(bwidth, bheight);
+        glVertex3f(bwidth, 0.0, 0.0);
+
+        glTexCoord2f(bwidth, 0);
+        glVertex3f(bwidth, bheight, 0.0);
+
+        glTexCoord2f(0.0, 0);
+        glVertex3f(0.0, bheight, 0.0);
+
+        glEnd();
+
+        glDisable(GL_TEXTURE_RECTANGLE_EXT);
+        glDeleteTextures(1, &tex);
+
+        mCanvasElement->GLWidgetSwapBuffers();
+        mCanvasElement->GLWidgetEndDrawing();
+    } else
+#endif
+    {
+        nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
+        if (!surf)
+            return NS_OK;
+        // XXX we can optimize this on win32 at least, by creating an upside-down
+        // DIB.
+        nsRefPtr<gfxPattern> pat = new gfxPattern(surf);
+
+#if defined(USE_EGL) && defined(MOZ_X11)
+        if (getenv("IMAGE")) {
+#endif
+        gfxMatrix m;
+        m.Translate(gfxPoint(0.0, mGLPbuffer->Height()));
+        m.Scale(1.0, -1.0);
+        pat->SetMatrix(m);
+#if defined(USE_EGL) && defined(MOZ_X11)
+        }
+#endif
+
+        // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
+        // pixel alignment for this stuff!
+        ctx->NewPath();
+        ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
+        ctx->Fill();
+    }
+
+    return rv;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetInputStream(const char* aMimeType,
+                             const PRUnichar* aEncoderOptions,
+                             nsIInputStream **aStream)
+{
+    return NS_ERROR_FAILURE;
+
+    // XXX fix this
+#if 0
+    if (!mGLPbuffer ||
+        !mGLPbuffer->ThebesSurface())
+        return NS_ERROR_FAILURE;
+
+    nsresult rv;
+    const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
+    nsAutoArrayPtr<char> conid(new (std::nothrow) char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
+
+    if (!conid)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    strcpy(conid, encoderPrefix);
+    strcat(conid, aMimeType);
+
+    nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
+    if (!encoder)
+        return NS_ERROR_FAILURE;
+
+    nsAutoArrayPtr<PRUint8> imageBuffer(new (std::nothrow) PRUint8[mWidth * mHeight * 4]);
+    if (!imageBuffer)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(imageBuffer.get(),
+                                                            gfxIntSize(mWidth, mHeight),
+                                                            mWidth * 4,
+                                                            gfxASurface::ImageFormatARGB32);
+
+    if (!imgsurf || imgsurf->CairoStatus())
+        return NS_ERROR_FAILURE;
+
+    nsRefPtr<gfxContext> ctx = new gfxContext(imgsurf);
+
+    if (!ctx || ctx->HasError())
+        return NS_ERROR_FAILURE;
+
+    nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
+    nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
+    gfxMatrix m;
+    m.Translate(gfxPoint(0.0, mGLPbuffer->Height()));
+    m.Scale(1.0, -1.0);
+    pat->SetMatrix(m);
+
+    // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
+    // pixel alignment for this stuff!
+    ctx->NewPath();
+    ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
+    ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
+    ctx->Fill();
+
+    rv = encoder->InitFromData(imageBuffer.get(),
+                               mWidth * mHeight * 4, mWidth, mHeight, mWidth * 4,
+                               imgIEncoder::INPUT_FORMAT_HOSTARGB,
+                               nsDependentString(aEncoderOptions));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return CallQueryInterface(encoder, aStream);
+#endif
+}
+
+NS_IMETHODIMP
+WebGLContext::GetThebesSurface(gfxASurface **surface)
+{
+    if (!mGLPbuffer) {
+        *surface = nsnull;
+        return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    *surface = mGLPbuffer->ThebesSurface();
+    NS_IF_ADDREF(*surface);
+    return NS_OK;
+}
+
+
+//
+// XPCOM goop
+//
+
+NS_IMPL_ADDREF(WebGLContext)
+NS_IMPL_RELEASE(WebGLContext)
+
+NS_INTERFACE_MAP_BEGIN(WebGLContext)
+  NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextWebGL)
+  NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
+  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICanvasRenderingContextWebGL)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CanvasRenderingContextWebGL)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLBuffer)
+NS_IMPL_RELEASE(WebGLBuffer)
+
+NS_INTERFACE_MAP_BEGIN(WebGLBuffer)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLBuffer)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLBuffer)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLTexture)
+NS_IMPL_RELEASE(WebGLTexture)
+
+NS_INTERFACE_MAP_BEGIN(WebGLTexture)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLTexture)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLTexture)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLProgram)
+NS_IMPL_RELEASE(WebGLProgram)
+
+NS_INTERFACE_MAP_BEGIN(WebGLProgram)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLProgram)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLProgram)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLShader)
+NS_IMPL_RELEASE(WebGLShader)
+
+NS_INTERFACE_MAP_BEGIN(WebGLShader)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLShader)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLShader)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLFramebuffer)
+NS_IMPL_RELEASE(WebGLFramebuffer)
+
+NS_INTERFACE_MAP_BEGIN(WebGLFramebuffer)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLFramebuffer)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLFramebuffer)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_ADDREF(WebGLRenderbuffer)
+NS_IMPL_RELEASE(WebGLRenderbuffer)
+
+NS_INTERFACE_MAP_BEGIN(WebGLRenderbuffer)
+  NS_INTERFACE_MAP_ENTRY(nsIWebGLRenderbuffer)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(WebGLRenderbuffer)
+NS_INTERFACE_MAP_END
+
+/* [noscript] attribute GLuint name; */
+NS_IMETHODIMP WebGLTexture::GetName(GLuint *aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP WebGLTexture::SetName(GLuint aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* [noscript] attribute GLuint name; */
+NS_IMETHODIMP WebGLBuffer::GetName(GLuint *aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP WebGLBuffer::SetName(GLuint aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* [noscript] attribute GLuint name; */
+NS_IMETHODIMP WebGLProgram::GetName(GLuint *aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP WebGLProgram::SetName(GLuint aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* [noscript] attribute GLuint name; */
+NS_IMETHODIMP WebGLShader::GetName(GLuint *aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP WebGLShader::SetName(GLuint aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* [noscript] attribute GLuint name; */
+NS_IMETHODIMP WebGLFramebuffer::GetName(GLuint *aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP WebGLFramebuffer::SetName(GLuint aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* [noscript] attribute GLuint name; */
+NS_IMETHODIMP WebGLRenderbuffer::GetName(GLuint *aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP WebGLRenderbuffer::SetName(GLuint aName)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
diff -r 5b1fe1bf3872 content/canvas/src/WebGLContext.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLContext.h	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,507 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *   Mark Steele <mwsteele@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef WEBGLCONTEXT_H_
+#define WEBGLCONTEXT_H_
+
+#include <stdarg.h>
+
+#include "nsTArray.h"
+#include "nsDataHashtable.h"
+#include "nsRefPtrHashtable.h"
+#include "nsHashKeys.h"
+
+#include "nsIDocShell.h"
+
+#include "nsICanvasRenderingContextWebGL.h"
+#include "nsICanvasRenderingContextInternal.h"
+#include "nsWeakReference.h"
+#include "nsIDOMHTMLElement.h"
+#include "nsIJSNativeInitializer.h"
+
+#include "SimpleBuffer.h"
+#include "nsGLPbuffer.h"
+
+#include "WebGLArrays.h"
+
+class nsIDocShell;
+
+namespace mozilla {
+
+class WebGLArray;
+class WebGLTexture;
+class WebGLBuffer;
+class WebGLProgram;
+class WebGLShader;
+class WebGLFramebuffer;
+class WebGLRenderbuffer;
+
+class WebGLZeroingObject;
+
+class WebGLObjectBaseRefPtr
+{
+protected:
+    friend class WebGLZeroingObject;
+
+    WebGLObjectBaseRefPtr()
+        : mRawPtr(0)
+    {
+    }
+
+    WebGLObjectBaseRefPtr(nsISupports *rawPtr)
+        : mRawPtr(rawPtr)
+    {
+    }
+
+    void Zero() {
+        if (mRawPtr) {
+            // Note: RemoveRefOwner isn't called here, because
+            // the entire owner array will be cleared.
+            mRawPtr->Release();
+            mRawPtr = 0;
+        }
+    }
+
+protected:
+    nsISupports *mRawPtr;
+};
+
+template <class T>
+class WebGLObjectRefPtr
+    : public WebGLObjectBaseRefPtr
+{
+public:
+    typedef T element_type;
+
+    WebGLObjectRefPtr()
+    { }
+
+    WebGLObjectRefPtr(const WebGLObjectRefPtr<T>& aSmartPtr)
+        : WebGLObjectBaseRefPtr(aSmartPtr.mRawPtr)
+    {
+        if (mRawPtr) {
+            RawPtr()->AddRef();
+            RawPtr()->AddRefOwner(this);
+        }
+    }
+
+    WebGLObjectRefPtr(T *aRawPtr)
+        : WebGLObjectBaseRefPtr(aRawPtr)
+    {
+        if (mRawPtr) {
+            RawPtr()->AddRef();
+            RawPtr()->AddRefOwner(this);
+        }
+    }
+
+    WebGLObjectRefPtr(const already_AddRefed<T>& aSmartPtr)
+        : WebGLObjectBaseRefPtr(aSmartPtr.mRawPtr)
+          // construct from |dont_AddRef(expr)|
+    {
+        if (mRawPtr) {
+            RawPtr()->AddRef();
+            RawPtr()->AddRefOwner(this);
+        }
+    }
+
+    ~WebGLObjectRefPtr() {
+        if (mRawPtr) {
+            RawPtr()->RemoveRefOwner(this);
+            RawPtr()->Release();
+        }
+    }
+
+    WebGLObjectRefPtr<T>&
+    operator=(const WebGLObjectRefPtr<T>& rhs)
+    {
+        assign_with_AddRef(static_cast<T*>(rhs.mRawPtr));
+        return *this;
+    }
+
+    WebGLObjectRefPtr<T>&
+    operator=(T* rhs)
+    {
+        assign_with_AddRef(rhs);
+        return *this;
+    }
+
+    WebGLObjectRefPtr<T>&
+    operator=(const already_AddRefed<T>& rhs)
+    {
+        assign_assuming_AddRef(static_cast<T*>(rhs.mRawPtr));
+        return *this;
+    }
+
+    T* get() const {
+        return const_cast<T*>(static_cast<T*>(mRawPtr));
+    }
+
+    operator T*() const {
+        return get();
+    }
+
+    T* operator->() const {
+        NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL WebGLObjectRefPtr with operator->()!");
+        return get();
+    }
+
+    T& operator*() const {
+        NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL WebGLObjectRefPtr with operator*()!");
+        return *get();
+    }
+
+private:
+    T* RawPtr() { return static_cast<T*>(mRawPtr); }
+
+    void assign_with_AddRef(T* rawPtr) {
+        if (rawPtr) {
+            rawPtr->AddRef();
+            rawPtr->AddRefOwner(this);
+        }
+
+        assign_assuming_AddRef(rawPtr);
+    }
+
+    void assign_assuming_AddRef(T* newPtr) {
+        T* oldPtr = RawPtr();
+        mRawPtr = newPtr;
+        if (oldPtr) {
+            oldPtr->RemoveRefOwner(this);
+            oldPtr->Release();
+        }
+    }
+};
+
+class WebGLBuffer;
+
+struct WebGLVertexAttribData {
+    WebGLVertexAttribData()
+        : buf(0), stride(0), size(0), offset(0), enabled(PR_FALSE)
+    { }
+
+    WebGLObjectRefPtr<WebGLBuffer> buf;
+    GLuint stride;
+    GLuint size;
+    GLuint offset;
+    PRBool enabled;
+};
+
+class WebGLContext :
+    public nsICanvasRenderingContextWebGL,
+    public nsICanvasRenderingContextInternal,
+    public nsSupportsWeakReference
+{
+public:
+    WebGLContext();
+    virtual ~WebGLContext();
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSICANVASRENDERINGCONTEXTWEBGL
+
+    // nsICanvasRenderingContextInternal
+    NS_IMETHOD SetCanvasElement(nsICanvasElement* aParentCanvas);
+    NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);
+    NS_IMETHOD InitializeWithSurface(nsIDocShell *docShell, gfxASurface *surface, PRInt32 width, PRInt32 height)
+        { return NS_ERROR_NOT_IMPLEMENTED; }
+    NS_IMETHOD Render(gfxContext *ctx, gfxPattern::GraphicsFilter f);
+    NS_IMETHOD GetInputStream(const char* aMimeType,
+                              const PRUnichar* aEncoderOptions,
+                              nsIInputStream **aStream);
+    NS_IMETHOD GetThebesSurface(gfxASurface **surface);
+    NS_IMETHOD SetIsOpaque(PRBool b) { return NS_OK; };
+
+protected:
+    GLES20Wrap *gl;
+
+    nsICanvasElement* mCanvasElement;
+
+    nsGLPbuffer *mGLPbuffer;
+    PRInt32 mWidth, mHeight;
+
+    PRBool mInvalidated;
+
+    PRBool SafeToCreateCanvas3DContext(nsICanvasElement *canvasElement);
+    PRBool ValidateGL();
+    PRBool ValidateBuffers(PRUint32 count);
+
+    void Invalidate();
+
+    void MakeContextCurrent() { mGLPbuffer->MakeContextCurrent(); }
+
+    nsresult TexImageElementBase(nsIDOMHTMLElement *imageOrCanvas,
+                                 gfxImageSurface **imageOut,
+                                 PRBool flipY, PRBool premultiplyAlpha);
+
+    GLuint mActiveTexture;
+
+    // the buffers bound to the current program's attribs
+    nsTArray<WebGLVertexAttribData> mAttribBuffers;
+
+    // the textures bound to any sampler uniforms
+    nsTArray<WebGLObjectRefPtr<WebGLTexture> > mUniformTextures;
+
+    // textures bound to 
+    nsTArray<WebGLObjectRefPtr<WebGLTexture> > mBound2DTextures;
+    nsTArray<WebGLObjectRefPtr<WebGLTexture> > mBoundCubeMapTextures;
+
+    WebGLObjectRefPtr<WebGLBuffer> mBoundArrayBuffer;
+    WebGLObjectRefPtr<WebGLBuffer> mBoundElementArrayBuffer;
+    WebGLObjectRefPtr<WebGLProgram> mCurrentProgram;
+
+    // XXX these 3 are wrong types, and aren't used atm (except for the length of the attachments)
+    nsTArray<WebGLObjectRefPtr<WebGLTexture> > mFramebufferColorAttachments;
+    nsRefPtr<WebGLFramebuffer> mFramebufferDepthAttachment;
+    nsRefPtr<WebGLFramebuffer> mFramebufferStencilAttachment;
+
+    nsRefPtr<WebGLFramebuffer> mBoundFramebuffer;
+    nsRefPtr<WebGLRenderbuffer> mBoundRenderbuffer;
+
+    // lookup tables for GL name -> object wrapper
+    nsRefPtrHashtable<nsUint32HashKey, WebGLTexture> mMapTextures;
+    nsRefPtrHashtable<nsUint32HashKey, WebGLBuffer> mMapBuffers;
+    nsRefPtrHashtable<nsUint32HashKey, WebGLProgram> mMapPrograms;
+    nsRefPtrHashtable<nsUint32HashKey, WebGLShader> mMapShaders;
+    nsRefPtrHashtable<nsUint32HashKey, WebGLFramebuffer> mMapFramebuffers;
+    nsRefPtrHashtable<nsUint32HashKey, WebGLRenderbuffer> mMapRenderbuffers;
+
+    // console logging helpers
+    void LogMessage (const char *fmt, ...);
+    nsresult ErrorMessage (const char *fmt, ...);
+};
+
+// this class is a mixin for the named type wrappers, and is used
+// by WebGLObjectRefPtr to tell the object who holds references, so that
+// we can zero them out appropriately when the object is deleted, because
+// it will be unbound in the GL.
+class WebGLZeroingObject
+{
+public:
+    WebGLZeroingObject()
+    { }
+
+    void AddRefOwner(WebGLObjectBaseRefPtr *owner) {
+        mRefOwners.AppendElement(owner);
+    }
+
+    void RemoveRefOwner(WebGLObjectBaseRefPtr *owner) {
+        mRefOwners.RemoveElement(owner);
+    }
+
+    void ZeroOwners() {
+        WebGLObjectBaseRefPtr **owners = mRefOwners.Elements();
+        
+        for (PRUint32 i = 0; i < mRefOwners.Length(); i++) {
+            owners[i]->Zero();
+        }
+
+        mRefOwners.Clear();
+    }
+
+protected:
+    nsTArray<WebGLObjectBaseRefPtr *> mRefOwners;
+};
+
+class WebGLBuffer :
+    public nsIWebGLBuffer,
+    public WebGLZeroingObject
+{
+public:
+    WebGLBuffer(GLuint name)
+        : mName(name), mDeleted(PR_FALSE), mGLType(0)
+    { }
+
+    void Delete() {
+        if (mDeleted)
+            return;
+        ZeroOwners();
+        mDeleted = PR_TRUE;
+    }
+    PRBool Deleted() { return mDeleted; }
+    GLuint GLName() { return mName; }
+
+    void Set(nsIWebGLArray *na) {
+        mGLType = na->NativeType();
+        mElementSize = na->NativeElementSize();
+        mCount = na->NativeCount();
+    }
+
+    void SetCount(GLuint count) {
+        mCount = count;
+    }
+
+    GLenum GLType() { return mGLType; }
+    PRUint32 ByteCount() { return mElementSize * mCount; }
+    PRUint32 Count() { return mCount; }
+    PRUint32 ElementSize() { return mElementSize; }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLBUFFER
+protected:
+    GLuint mName;
+    PRBool mDeleted;
+
+    GLenum mGLType;
+    PRUint32 mElementSize;
+    PRUint32 mCount;
+};
+
+class WebGLTexture :
+    public nsIWebGLTexture,
+    public WebGLZeroingObject
+{
+public:
+    WebGLTexture(GLuint name) :
+        mName(name), mDeleted(PR_FALSE) { }
+
+    void Delete() {
+        if (mDeleted)
+            return;
+        ZeroOwners();
+        mDeleted = PR_TRUE;
+    }
+
+    PRBool Deleted() { return mDeleted; }
+    GLuint GLName() { return mName; }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLTEXTURE
+protected:
+    GLuint mName;
+    PRBool mDeleted;
+};
+
+class WebGLProgram :
+    public nsIWebGLProgram,
+    public WebGLZeroingObject
+{
+public:
+    WebGLProgram(GLuint name) :
+        mName(name), mDeleted(PR_FALSE) { }
+
+    void Delete() {
+        if (mDeleted)
+            return;
+        ZeroOwners();
+        mDeleted = PR_TRUE;
+    }
+    PRBool Deleted() { return mDeleted; }
+    GLuint GLName() { return mName; }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLPROGRAM
+protected:
+    GLuint mName;
+    PRBool mDeleted;
+};
+
+class WebGLShader :
+    public nsIWebGLShader,
+    public WebGLZeroingObject
+{
+public:
+    WebGLShader(GLuint name) :
+        mName(name), mDeleted(PR_FALSE) { }
+
+    void Delete() {
+        if (mDeleted)
+            return;
+        ZeroOwners();
+        mDeleted = PR_TRUE;
+    }
+    PRBool Deleted() { return mDeleted; }
+    GLuint GLName() { return mName; }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLSHADER
+protected:
+    GLuint mName;
+    PRBool mDeleted;
+};
+
+class WebGLFramebuffer :
+    public nsIWebGLFramebuffer,
+    public WebGLZeroingObject
+{
+public:
+    WebGLFramebuffer(GLuint name) :
+        mName(name), mDeleted(PR_FALSE) { }
+
+    void Delete() {
+        if (mDeleted)
+            return;
+        ZeroOwners();
+        mDeleted = PR_TRUE;
+    }
+    PRBool Deleted() { return mDeleted; }
+    GLuint GLName() { return mName; }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLFRAMEBUFFER
+protected:
+    GLuint mName;
+    PRBool mDeleted;
+};
+
+class WebGLRenderbuffer :
+    public nsIWebGLRenderbuffer,
+    public WebGLZeroingObject
+{
+public:
+    WebGLRenderbuffer(GLuint name) :
+        mName(name), mDeleted(PR_FALSE) { }
+
+    void Delete() {
+        if (mDeleted)
+            return;
+        ZeroOwners();
+        mDeleted = PR_TRUE;
+    }
+    PRBool Deleted() { return mDeleted; }
+    GLuint GLName() { return mName; }
+
+    NS_DECL_ISUPPORTS
+    NS_DECL_NSIWEBGLRENDERBUFFER
+protected:
+    GLuint mName;
+    PRBool mDeleted;
+};
+
+}
+
+#endif
diff -r 5b1fe1bf3872 content/canvas/src/WebGLContextGL.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLContextGL.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,3484 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *   Mark Steele <mwsteele@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "WebGLContext.h"
+
+#include "nsString.h"
+
+#include "gfxImageSurface.h"
+#include "gfxContext.h"
+#include "gfxPlatform.h"
+//#include "nsIDOMHTMLCanvasElement.h"
+
+#include "nsContentUtils.h"
+#include "nsDOMError.h"
+#include "nsLayoutUtils.h"
+
+#include "CanvasUtils.h"
+#include "NativeJSContext.h"
+#include "SimpleBuffer.h"
+
+using namespace mozilla;
+
+// XXX why is this broken?
+#ifndef GL_BLEND_EQUATION
+#define GL_BLEND_EQUATION 0x8009
+#endif
+
+static PRBool BaseTypeAndSizeFromUniformType(GLenum uType, GLenum *baseType, GLint *unitSize);
+
+/* Helper macros for when we're just wrapping a gl method, so that
+ * we can avoid having to type this 500 times.  Note that these MUST
+ * NOT BE USED if we need to check any of the parameters.
+ */
+
+#define GL_SAME_METHOD_0(glname, name)                          \
+NS_IMETHODIMP WebGLContext::name() {                            \
+    MakeContextCurrent(); gl->f##glname(); return NS_OK;        \
+}
+
+#define GL_SAME_METHOD_1(glname, name, t1)          \
+NS_IMETHODIMP WebGLContext::name(t1 a1) {           \
+    MakeContextCurrent(); gl->f##glname(a1); return NS_OK;  \
+}
+
+#define GL_SAME_METHOD_2(glname, name, t1, t2)        \
+NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2) {      \
+    MakeContextCurrent(); gl->f##glname(a1,a2); return NS_OK;           \
+}
+
+#define GL_SAME_METHOD_3(glname, name, t1, t2, t3)      \
+NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3) { \
+    MakeContextCurrent(); gl->f##glname(a1,a2,a3); return NS_OK;        \
+}
+
+#define GL_SAME_METHOD_4(glname, name, t1, t2, t3, t4)         \
+NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4) { \
+    MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4); return NS_OK;     \
+}
+
+#define GL_SAME_METHOD_5(glname, name, t1, t2, t3, t4, t5)            \
+NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5) { \
+    MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5); return NS_OK;  \
+}
+
+#define GL_SAME_METHOD_6(glname, name, t1, t2, t3, t4, t5, t6)          \
+NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6) { \
+    MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5,a6); return NS_OK; \
+}
+
+//
+//  WebGL API
+//
+
+/* nsIWebGLFloatArray createFloatArray (); */
+NS_IMETHODIMP
+WebGLContext::CreateFloatArray(nsIWebGLFloatArray **retval)
+{
+    NativeJSContext js;
+
+    if (js.argc != 1)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    JSObject *arrayObj;
+    jsuint arrayLen;
+
+    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "o", &arrayObj) ||
+        arrayObj == NULL ||
+        !::JS_IsArrayObject(js.ctx, arrayObj) ||
+        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
+    {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    WebGLFloatArray *wgfa = new WebGLFloatArray(js.ctx, arrayObj, arrayLen);
+    if (wgfa)
+        NS_ADDREF(*retval = wgfa);
+
+    return NS_OK;
+}
+
+/* nsIWebGLByteArray createByteArray (); */
+NS_IMETHODIMP
+WebGLContext::CreateByteArray(nsIWebGLByteArray **retval)
+{
+    NativeJSContext js;
+
+    if (js.argc != 1)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    JSObject *arrayObj;
+    jsuint arrayLen;
+
+    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "o", &arrayObj) ||
+        arrayObj == NULL ||
+        !::JS_IsArrayObject(js.ctx, arrayObj) ||
+        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
+    {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    WebGLByteArray *wgba = new WebGLByteArray(js.ctx, arrayObj, arrayLen);
+    if (wgba)
+        NS_ADDREF(*retval = wgba);
+    return NS_OK;
+}
+
+/* nsIWebGLUnsignedByteArray createUnsignedByteArray (); */
+NS_IMETHODIMP
+WebGLContext::CreateUnsignedByteArray(nsIWebGLUnsignedByteArray **retval)
+{
+    NativeJSContext js;
+
+    if (js.argc != 1)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    JSObject *arrayObj;
+    jsuint arrayLen;
+
+    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "o", &arrayObj) ||
+        arrayObj == NULL ||
+        !::JS_IsArrayObject(js.ctx, arrayObj) ||
+        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
+    {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    WebGLUnsignedByteArray *wguba = new WebGLUnsignedByteArray(js.ctx, arrayObj, arrayLen);
+    if (wguba)
+        NS_ADDREF(*retval = wguba);
+    return NS_OK;
+}
+
+/* nsIWebGLShortArray createShortArray (); */
+NS_IMETHODIMP
+WebGLContext::CreateShortArray(nsIWebGLShortArray **retval)
+{
+    NativeJSContext js;
+
+    if (js.argc != 1)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    JSObject *arrayObj;
+    jsuint arrayLen;
+
+    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "o", &arrayObj) ||
+        arrayObj == NULL ||
+        !::JS_IsArrayObject(js.ctx, arrayObj) ||
+        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
+    {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    WebGLShortArray *wgsa = new WebGLShortArray(js.ctx, arrayObj, arrayLen);
+    if (wgsa)
+        NS_ADDREF(*retval = wgsa);
+    return NS_OK;
+}
+
+/* nsIWebGLUnsignedShortArray createUnsignedShortArray (); */
+NS_IMETHODIMP
+WebGLContext::CreateUnsignedShortArray(nsIWebGLUnsignedShortArray **retval)
+{
+    NativeJSContext js;
+
+    if (js.argc != 1)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    JSObject *arrayObj;
+    jsuint arrayLen;
+
+    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "o", &arrayObj) ||
+        arrayObj == NULL ||
+        !::JS_IsArrayObject(js.ctx, arrayObj) ||
+        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
+    {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    WebGLUnsignedShortArray *wgusa = new WebGLUnsignedShortArray(js.ctx, arrayObj, arrayLen);
+    if (wgusa)
+        NS_ADDREF(*retval = wgusa);
+    return NS_OK;
+}
+
+
+/* nsIWebGLUnsignedIntArray createUnsignedIntArray (); */
+NS_IMETHODIMP
+WebGLContext::CreateIntArray(nsIWebGLIntArray **retval)
+{
+    NativeJSContext js;
+
+    if (js.argc != 1)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    JSObject *arrayObj;
+    jsuint arrayLen;
+
+    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "o", &arrayObj) ||
+        arrayObj == NULL ||
+        !::JS_IsArrayObject(js.ctx, arrayObj) ||
+        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
+    {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    WebGLIntArray *wgia = new WebGLIntArray(js.ctx, arrayObj, arrayLen);
+    if (wgia)
+        NS_ADDREF(*retval = wgia);
+    return NS_OK;
+}
+
+/* nsIWebGLUnsignedIntArray createUnsignedIntArray (); */
+NS_IMETHODIMP
+WebGLContext::CreateUnsignedIntArray(nsIWebGLUnsignedIntArray **retval)
+{
+    NativeJSContext js;
+
+    if (js.argc != 1)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    JSObject *arrayObj;
+    jsuint arrayLen;
+
+    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "o", &arrayObj) ||
+        arrayObj == NULL ||
+        !::JS_IsArrayObject(js.ctx, arrayObj) ||
+        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
+    {
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    WebGLUnsignedIntArray *wguia = new WebGLUnsignedIntArray(js.ctx, arrayObj, arrayLen);
+    if (wguia)
+        NS_ADDREF(*retval = wguia);
+    return NS_OK;
+}
+
+/* readonly attribute nsIDOMHTMLCanvasElement canvas; */
+NS_IMETHODIMP
+WebGLContext::GetCanvas(nsIDOMHTMLCanvasElement **aCanvas)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+
+/* void present (); */
+NS_IMETHODIMP
+WebGLContext::Present()
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* long sizeInBytes (in GLenum type); */
+NS_IMETHODIMP
+WebGLContext::SizeInBytes(GLenum type, PRInt32 *retval)
+{
+    if (type == LOCAL_GL_FLOAT) *retval = sizeof(float);
+    if (type == LOCAL_GL_SHORT) *retval = sizeof(short);
+    if (type == LOCAL_GL_UNSIGNED_SHORT) *retval = sizeof(unsigned short);
+    if (type == LOCAL_GL_BYTE) *retval = 1;
+    if (type == LOCAL_GL_UNSIGNED_BYTE) *retval = 1;
+    if (type == LOCAL_GL_INT) *retval = sizeof(int);
+    if (type == LOCAL_GL_UNSIGNED_INT) *retval = sizeof(unsigned int);
+    if (type == LOCAL_GL_DOUBLE) *retval = sizeof(double);
+    return NS_OK;
+}
+
+/* void GlActiveTexture (in PRUint32 texture); */
+NS_IMETHODIMP
+WebGLContext::ActiveTexture(PRUint32 texture)
+{
+    if (texture < LOCAL_GL_TEXTURE0 || texture >= LOCAL_GL_TEXTURE0+mBound2DTextures.Length())
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    MakeContextCurrent();
+    mActiveTexture = texture - LOCAL_GL_TEXTURE0;
+    gl->fActiveTexture(texture);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::AttachShader(nsIWebGLProgram *prog, nsIWebGLShader *sh)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    if (!sh || static_cast<WebGLShader*>(sh)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+    GLuint shader = static_cast<WebGLShader*>(sh)->GLName();
+
+    MakeContextCurrent();
+
+    gl->fAttachShader(program, shader);
+
+    return NS_OK;
+}
+
+
+NS_IMETHODIMP
+WebGLContext::BindAttribLocation(nsIWebGLProgram *prog, GLuint location, const nsAString& name)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    if (name.IsEmpty())
+        return ErrorMessage("glBindAttribLocation: name can't be null or empty!");
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    MakeContextCurrent();
+
+    gl->fBindAttribLocation(program, location, NS_LossyConvertUTF16toASCII(name).get());
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::BindBuffer(GLenum target, nsIWebGLBuffer *buffer)
+{
+    WebGLBuffer *wbuf = static_cast<WebGLBuffer*>(buffer);
+
+    if (wbuf && wbuf->Deleted())
+        return ErrorMessage("glBindBuffer: buffer has already been deleted!");
+
+    MakeContextCurrent();
+
+    //printf ("BindBuffer0: %04x\n", gl->fGetError());
+
+    if (target == LOCAL_GL_ARRAY_BUFFER) {
+        mBoundArrayBuffer = wbuf;
+    } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
+        mBoundElementArrayBuffer = wbuf;
+    } else {
+        return ErrorMessage("glBindBuffer: invalid target!");
+    }
+
+    gl->fBindBuffer(target, wbuf ? wbuf->GLName() : 0);
+
+    //printf ("BindBuffer: %04x\n", gl->fGetError());
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::BindFramebuffer(GLenum target, nsIWebGLFramebuffer *fb)
+{
+    WebGLFramebuffer *wfb = static_cast<WebGLFramebuffer*>(fb);
+
+    if (wfb && wfb->Deleted())
+        return ErrorMessage("glBindFramebuffer: framebuffer has already been deleted!");
+
+    MakeContextCurrent();
+
+    if (target != LOCAL_GL_FRAMEBUFFER) {
+        return ErrorMessage("glBindFramebuffer: target must be GL_FRAMEBUFFER");
+    }
+
+    gl->fBindFramebuffer(target, wfb ? wfb->GLName() : 0);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::BindRenderbuffer(GLenum target, nsIWebGLRenderbuffer *rb)
+{
+    WebGLRenderbuffer *wrb = static_cast<WebGLRenderbuffer*>(rb);
+
+    if (wrb && wrb->Deleted())
+        return ErrorMessage("glBindRenderbuffer: renderbuffer has already been deleted!");
+
+    if (target != LOCAL_GL_RENDERBUFFER)
+        return ErrorMessage("glBindRenderbuffer: target must be GL_RENDERBUFFER");
+
+    MakeContextCurrent();
+
+    gl->fBindRenderbuffer(target, wrb ? wrb->GLName() : 0);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::BindTexture(GLenum target, nsIWebGLTexture *tex)
+{
+    WebGLTexture *wtex = static_cast<WebGLTexture*>(tex);
+
+    if (wtex && wtex->Deleted())
+        return ErrorMessage("glBindTexture: texture has already been deleted!");
+
+    MakeContextCurrent();
+
+    if (target == LOCAL_GL_TEXTURE_2D) {
+        mBound2DTextures[mActiveTexture] = wtex;
+    } else if (target == LOCAL_GL_TEXTURE_CUBE_MAP) {
+        mBoundCubeMapTextures[mActiveTexture] = wtex;
+    } else {
+        return ErrorMessage("glBindTexture: invalid target");
+    }
+
+    gl->fBindTexture(target, wtex ? wtex->GLName() : 0);
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_4(BlendColor, BlendColor, float, float, float, float)
+
+GL_SAME_METHOD_1(BlendEquation, BlendEquation, PRUint32)
+
+GL_SAME_METHOD_2(BlendEquationSeparate, BlendEquationSeparate, PRUint32, PRUint32)
+
+GL_SAME_METHOD_2(BlendFunc, BlendFunc, PRUint32, PRUint32)
+
+GL_SAME_METHOD_4(BlendFuncSeparate, BlendFuncSeparate, PRUint32, PRUint32, PRUint32, PRUint32)
+
+NS_IMETHODIMP
+WebGLContext::BufferData(GLenum target)
+{
+    // overloaded:
+    // void bufferData (in GLenum target, in GLsizei size, in GLenum usage);
+    // void bufferData (in GLenum target, in nsIWebGLArray data, in GLenum usage);
+    // void bufferData (in GLenum target, in nsIWebGLArrayBuffer data, in GLenum usage)
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc != 3)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    WebGLBuffer *boundBuffer = NULL;
+
+    if (target == LOCAL_GL_ARRAY_BUFFER) {
+        boundBuffer = mBoundArrayBuffer;
+    } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
+        // XXX fix type check
+        //if (na->NativeType() != LOCAL_GL_UNSIGNED_SHORT)
+        //    return ErrorMessage("glBufferData: %x - GL_ELEMENT_ARRAY_BUFFER target must be used with UnsignedShortBuffer", na->NativeType());
+
+        boundBuffer = mBoundElementArrayBuffer;
+    } else {
+        return ErrorMessage("glBufferData: invalid target");
+    }
+
+    if (boundBuffer == NULL) {
+        return ErrorMessage("glBufferData: no buffer bound!");
+    }
+
+
+    MakeContextCurrent();
+
+    uint32 usage;
+
+    if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &usage)) {
+        return ErrorMessage("bufferData: invalid usage parameter");
+    }
+
+    if (JSVAL_IS_NUMBER(js.argv[1])) {
+        int32 size;
+        if (!::JS_ValueToECMAInt32(js.ctx, js.argv[1], &size)) {
+            return ErrorMessage("bufferData: invalid size parameter");
+        }
+        boundBuffer->SetCount(size);
+        gl->fBufferData(target, size, 0, usage);
+    } else if (JSVAL_IS_OBJECT(js.argv[1])) {
+        nsCOMPtr<nsIWebGLArray> canvasArrayObj;
+        nsresult rv;
+
+        rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, JSVAL_TO_OBJECT(js.argv[1]),
+                                                 NS_GET_IID(nsIWebGLArray), getter_AddRefs(canvasArrayObj));
+        if (NS_FAILED(rv) || !canvasArrayObj) {
+            nsCOMPtr<nsIWebGLArrayBuffer> arrayBuf;
+            rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, JSVAL_TO_OBJECT(js.argv[1]),
+                                                     NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(arrayBuf));
+            if (NS_FAILED(rv) || !arrayBuf)
+                return ErrorMessage("bufferData: need CanvasArray or CanvasArrayBuffer");
+
+            boundBuffer->SetCount(arrayBuf->NativeSize());
+            gl->fBufferData(target, arrayBuf->NativeSize(), arrayBuf->NativePointer(), usage);
+        } else {
+            boundBuffer->Set(canvasArrayObj);
+            gl->fBufferData(target, canvasArrayObj->NativeSize(), canvasArrayObj->NativePointer(), usage);
+        }
+    } else {
+        return ErrorMessage("bufferData: invalid data");
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::BufferSubData(GLenum target, GLsizeiptr offset)
+{
+    // overloaded:
+    // void bufferSubData(in GLenum target, in GLsizeiptr offset, in CanvasArray data) 
+    // void bufferSubData(in GLenum target, in GLsizeiptr offset, in CanvasArrayBuffer data) 
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc != 3)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    WebGLBuffer *boundBuffer = NULL;
+
+    if (target == LOCAL_GL_ARRAY_BUFFER) {
+        boundBuffer = mBoundArrayBuffer;
+    } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
+        boundBuffer = mBoundElementArrayBuffer;
+    } else {
+        return ErrorMessage("glBufferSubData: invalid target");
+    }
+
+    if (boundBuffer == NULL) {
+        return ErrorMessage("glBufferSubData: no buffer bound!");
+    }
+
+    /* XXX FIXME 
+    // check type
+    if (na->NativeType() != boundBuffer->GLType()) {
+        return ErrorMessage("glBufferSubData: existing buffer has different base type (0x%04x) the sub data (0x%04x)!", boundBuffer->GLType(), na->NativeType());
+        return NS_ERROR_FAILURE;
+    }
+    */
+
+    if (JSVAL_IS_OBJECT(js.argv[2])) {
+        nsCOMPtr<nsIWebGLArray> canvasArrayObj;
+        nsresult rv;
+
+        rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, JSVAL_TO_OBJECT(js.argv[2]),
+                                                 NS_GET_IID(nsIWebGLArray), getter_AddRefs(canvasArrayObj));
+        if (NS_FAILED(rv) || !canvasArrayObj) {
+            nsCOMPtr<nsIWebGLArrayBuffer> arrayBuf;
+            rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, JSVAL_TO_OBJECT(js.argv[2]),
+                                                     NS_GET_IID(nsIWebGLArrayBuffer), getter_AddRefs(arrayBuf));
+            if (NS_FAILED(rv) || !arrayBuf)
+                return ErrorMessage("bufferData: need CanvasArray or CanvasArrayBuffer");
+
+            // check size
+            // XXX should be bytes
+            if ((offset + arrayBuf->NativeSize()) > boundBuffer->Count()) {
+                return ErrorMessage("glBufferSubData: existing buffer is too small (%d) for data at offset (%d+%d)",
+                                    boundBuffer->Count(), offset, arrayBuf->NativeSize());
+                return NS_ERROR_FAILURE;
+            }
+#ifdef DEBUG_mwsteele
+            LogMessage("bufferSubData: buffer (%d) for data at offset (%d+%d)", boundBuffer->Count(), offset, arrayBuf->NativeSize());
+#endif
+            // all good
+
+            MakeContextCurrent();
+
+            gl->fBufferSubData(target, offset, arrayBuf->NativeSize(), arrayBuf->NativePointer());
+        } else {
+            // check size
+            // XXX should be bytes
+            if ((offset + canvasArrayObj->NativeCount()) > boundBuffer->Count()) {
+                return ErrorMessage("glBufferSubData: existing buffer is too small (%d) for data at offset (%d+%d)",
+                                    boundBuffer->Count(), offset, canvasArrayObj->NativeCount());
+                return NS_ERROR_FAILURE;
+            }
+#ifdef DEBUG_mwsteele
+            LogMessage("bufferSubData: buffer (%d) for data at offset (%d+%d)", boundBuffer->Count(), offset, canvasArrayObj->NativeSize());
+#endif
+            // all good
+
+            MakeContextCurrent();
+
+            gl->fBufferSubData(target, offset, canvasArrayObj->NativeSize(), canvasArrayObj->NativePointer());
+        }
+    } else {
+        return ErrorMessage("bufferData: invalid data");
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::CheckFramebufferStatus(GLenum target, GLenum *retval)
+{
+    MakeContextCurrent();
+    // XXX check target
+    *retval = gl->fCheckFramebufferStatus(target);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::Clear(PRUint32 mask)
+{
+    MakeContextCurrent();
+    gl->fClear(mask);
+    Invalidate();
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_4(ClearColor, ClearColor, float, float, float, float)
+
+#ifdef USE_GLES2
+GL_SAME_METHOD_1(ClearDepthf, ClearDepth, float)
+#else
+GL_SAME_METHOD_1(ClearDepth, ClearDepth, float)
+#endif
+
+GL_SAME_METHOD_1(ClearStencil, ClearStencil, PRInt32)
+
+GL_SAME_METHOD_4(ColorMask, ColorMask, GLboolean, GLboolean, GLboolean, GLboolean)
+
+NS_IMETHODIMP
+WebGLContext::CopyTexImage2D(GLenum target,
+                               GLint level,
+                               GLenum internalformat,
+                               GLint x,
+                               GLint y,
+                               GLsizei width,
+                               GLsizei height,
+                               GLint border)
+{
+    switch (target) {
+        case LOCAL_GL_TEXTURE_2D:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
+            break;
+        default:
+            return ErrorMessage("copyTexImage2D: unsupported target");
+    }
+
+    switch (internalformat) {
+        case LOCAL_GL_RGB:
+        case LOCAL_GL_RGBA:
+        case LOCAL_GL_ALPHA:
+        case LOCAL_GL_LUMINANCE:
+        case LOCAL_GL_LUMINANCE_ALPHA:
+            break;
+        default:
+            return ErrorMessage("copyTexImage2D: internal format not supported");
+    }
+
+    if (border != 0) {
+        return ErrorMessage("copyTexImage2D: border != 0");
+    }
+
+    if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight)) {
+        return ErrorMessage("copyTexImage2D: copied rectangle out of bounds");
+    }
+
+    MakeContextCurrent();
+
+    gl->fCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::CopyTexSubImage2D(GLenum target,
+                                  GLint level,
+                                  GLint xoffset,
+                                  GLint yoffset,
+                                  GLint x,
+                                  GLint y,
+                                  GLsizei width,
+                                  GLsizei height)
+{
+    switch (target) {
+        case LOCAL_GL_TEXTURE_2D:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
+            break;
+        default:
+            return ErrorMessage("copyTexSubImage2D: unsupported target");
+    }
+
+    if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight)) {
+        return ErrorMessage("copyTexSubImage2D: copied rectangle out of bounds");
+    }
+
+    MakeContextCurrent();
+
+    gl->fCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
+
+    return NS_OK;
+}
+
+
+NS_IMETHODIMP
+WebGLContext::CreateProgram(nsIWebGLProgram **retval)
+{
+    MakeContextCurrent();
+
+    GLuint name = gl->fCreateProgram();
+
+    WebGLProgram *prog = new WebGLProgram(name);
+    if (prog) {
+        NS_ADDREF(*retval = prog);
+        mMapPrograms.Put(name, prog);
+    } else {
+        gl->fDeleteProgram(name);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::CreateShader(GLenum type, nsIWebGLShader **retval)
+{
+    MakeContextCurrent();
+
+    GLuint name = gl->fCreateShader(type);
+
+    WebGLShader *shader = new WebGLShader(name);
+    if (shader) {
+        NS_ADDREF(*retval = shader);
+        mMapShaders.Put(name, shader);
+    } else {
+        gl->fDeleteShader(name);
+    }
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_1(CullFace, CullFace, GLenum)
+
+NS_IMETHODIMP
+WebGLContext::DeleteBuffer(nsIWebGLBuffer *globj)
+{
+    WebGLBuffer *obj = static_cast<WebGLBuffer*>(globj);
+    if (!obj || obj->Deleted()) {
+        return NS_OK;
+    }
+
+    MakeContextCurrent();
+
+    GLuint name = obj->GLName();
+    gl->fDeleteBuffers(1, &name);
+    obj->Delete();
+    mMapBuffers.Remove(name);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DeleteFramebuffer(nsIWebGLFramebuffer *globj)
+{
+    WebGLFramebuffer *obj = static_cast<WebGLFramebuffer*>(globj);
+    if (!obj || obj->Deleted()) {
+        return NS_OK;
+    }
+
+    MakeContextCurrent();
+
+    GLuint name = obj->GLName();
+    gl->fDeleteFramebuffers(1, &name);
+    obj->Delete();
+    mMapFramebuffers.Remove(name);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DeleteRenderbuffer(nsIWebGLRenderbuffer *globj)
+{
+    WebGLRenderbuffer *obj = static_cast<WebGLRenderbuffer*>(globj);
+    if (!obj || obj->Deleted()) {
+        return NS_OK;
+    }
+
+    MakeContextCurrent();
+
+    // XXX we need to track renderbuffer attachments; from glDeleteRenderbuffers man page:
+
+    /*
+            If a renderbuffer object that is currently bound is deleted, the binding reverts
+            to 0 (the absence of any renderbuffer object). Additionally, special care
+            must be taken when deleting a renderbuffer object if the image of the renderbuffer
+            is attached to a framebuffer object. In this case, if the deleted renderbuffer object is
+            attached to the currently bound framebuffer object, it is 
+            automatically detached.  However, attachments to any other framebuffer objects are the
+            responsibility of the application.
+    */  
+
+    GLuint name = obj->GLName();
+    gl->fDeleteRenderbuffers(1, &name);
+    obj->Delete();
+    mMapRenderbuffers.Remove(name);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DeleteTexture(nsIWebGLTexture *globj)
+{
+    WebGLTexture *obj = static_cast<WebGLTexture*>(globj);
+    if (!obj || obj->Deleted()) {
+        return NS_OK;
+    }
+
+    MakeContextCurrent();
+
+    GLuint name = obj->GLName();
+    gl->fDeleteTextures(1, &name);
+    obj->Delete();
+    mMapTextures.Remove(name);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DeleteProgram(nsIWebGLProgram *globj)
+{
+    WebGLProgram *obj = static_cast<WebGLProgram*>(globj);
+    if (!obj || obj->Deleted()) {
+        return NS_OK;
+    }
+
+    MakeContextCurrent();
+
+    GLuint name = obj->GLName();
+    gl->fDeleteProgram(name);
+    obj->Delete();
+    mMapPrograms.Remove(name);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DeleteShader(nsIWebGLShader *globj)
+{
+    WebGLShader *obj = static_cast<WebGLShader*>(globj);
+    if (!obj || obj->Deleted()) {
+        return NS_OK;
+    }
+
+    MakeContextCurrent();
+
+    GLuint name = obj->GLName();
+    gl->fDeleteShader(name);
+    obj->Delete();
+    mMapShaders.Remove(name);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DetachShader(nsIWebGLProgram *prog, nsIWebGLShader *sh)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    if (!sh || static_cast<WebGLShader*>(sh)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+    GLuint shader = static_cast<WebGLShader*>(sh)->GLName();
+
+    MakeContextCurrent();
+
+    gl->fDetachShader(program, shader);
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_1(DepthFunc, DepthFunc, GLenum)
+
+GL_SAME_METHOD_1(DepthMask, DepthMask, GLboolean)
+
+#ifdef USE_GLES2
+GL_SAME_METHOD_2(DepthRangef, DepthRange, float, float)
+#else
+GL_SAME_METHOD_2(DepthRange, DepthRange, float, float)
+#endif
+
+// XXX arg check!
+GL_SAME_METHOD_1(Disable, Disable, GLenum)
+
+NS_IMETHODIMP
+WebGLContext::DisableVertexAttribArray(GLuint index)
+{
+    if (index > mAttribBuffers.Length())
+        return ErrorMessage("glDisableVertexAttribArray: index out of range");
+
+    MakeContextCurrent();
+
+    gl->fDisableVertexAttribArray(index);
+    mAttribBuffers[index].enabled = PR_FALSE;
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DrawArrays(GLenum mode, GLint offset, GLsizei count)
+{
+    switch (mode) {
+        case LOCAL_GL_TRIANGLES:
+        case LOCAL_GL_TRIANGLE_STRIP:
+        case LOCAL_GL_TRIANGLE_FAN:
+        case LOCAL_GL_POINTS:
+        case LOCAL_GL_LINE_STRIP:
+        case LOCAL_GL_LINE_LOOP:
+        case LOCAL_GL_LINES:
+            break;
+        default:
+            return ErrorMessage("drawArrays: invalid mode");
+    }
+
+    if (offset+count < offset || offset+count < count) {
+        return ErrorMessage("drawArrays: overflow in offset+count");
+    }
+
+    if (!ValidateBuffers(offset+count))
+        return NS_ERROR_INVALID_ARG;
+
+    MakeContextCurrent();
+
+    //printf ("DrawArrays0: %04x\n", gl->fGetError());
+
+    gl->fDrawArrays(mode, offset, count);
+
+    //printf ("DrawArrays: %04x\n", gl->fGetError());
+
+    Invalidate();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::DrawElements(GLenum mode, GLuint count, GLenum type, GLuint offset)
+{
+    int elementSize = 0;
+
+    switch (mode) {
+        case LOCAL_GL_TRIANGLES:
+        case LOCAL_GL_TRIANGLE_STRIP:
+        case LOCAL_GL_TRIANGLE_FAN:
+        case LOCAL_GL_POINTS:
+        case LOCAL_GL_LINE_STRIP:
+        case LOCAL_GL_LINE_LOOP:
+        case LOCAL_GL_LINES:
+            break;
+        default:
+            return ErrorMessage("drawElements: invalid mode");
+    }
+
+    switch (type) {
+        case LOCAL_GL_UNSIGNED_SHORT:
+            elementSize = 2;
+            if (offset % 2 != 0)
+                return ErrorMessage("drawElements: invalid offset (must be a multiple of 2) for UNSIGNED_SHORT");
+            break;
+
+        case LOCAL_GL_UNSIGNED_BYTE:
+            elementSize = 1;
+            break;
+
+        default:
+            return ErrorMessage("drawElements: type must be UNSIGNED_SHORT or UNSIGNED_BYTE");
+    }
+
+    if (!mBoundElementArrayBuffer)
+        return ErrorMessage("glDrawElements: must have element array buffer binding!");
+
+    if (offset+count < offset || offset+count < count)
+        return ErrorMessage("glDrawElements: overflow in offset+count");
+
+    if (count*elementSize + offset > mBoundElementArrayBuffer->ByteCount())
+        return ErrorMessage("glDrawElements: bound element array buffer is too small for given count and offset");
+
+    MakeContextCurrent();
+
+    // XXXmark fix validation
+    // XXX either GLushort or GLubyte; just put this calculation as a method on the array object
+#if 0
+    GLuint maxindex = 0;
+    GLushort *ubuf = (GLushort*) gl->fMapBuffer(LOCAL_GL_ELEMENT_ARRAY_BUFFER, LOCAL_GL_READ_ONLY);
+    if (!ubuf)
+        return ErrorMessage("glDrawElements: failed to map ELEMENT_ARRAY_BUFFER for validation!");
+
+    ubuf += offset;
+
+    // XXX cache results for this count,offset pair!
+    for (PRUint32 i = 0; i < count; ++i)
+        maxindex = PR_MAX(maxindex, *ubuf++);
+
+    gl->fUnmapBuffer(LOCAL_GL_ELEMENT_ARRAY_BUFFER);
+
+    if (!ValidateBuffers(maxindex))
+        return ErrorMessage("glDrawElements: ValidateBuffers failed");
+#endif
+
+    gl->fDrawElements(mode, count, type, (GLvoid*) (offset));
+
+    Invalidate();
+
+    return NS_OK;
+}
+
+// XXX definitely need to validate this
+GL_SAME_METHOD_1(Enable, Enable, PRUint32)
+
+NS_IMETHODIMP
+WebGLContext::EnableVertexAttribArray(GLuint index)
+{
+    if (index > mAttribBuffers.Length())
+        return ErrorMessage("glEnableVertexAttribArray: index out of range");
+
+    MakeContextCurrent();
+
+    gl->fEnableVertexAttribArray(index);
+    mAttribBuffers[index].enabled = PR_TRUE;
+
+    return NS_OK;
+}
+
+// XXX need to track this -- see glDeleteRenderbuffer above and man page for DeleteRenderbuffers
+NS_IMETHODIMP
+WebGLContext::FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum rbtarget, nsIWebGLRenderbuffer *wrb)
+{
+    WebGLRenderbuffer *rb = static_cast<WebGLRenderbuffer*>(wrb);
+
+    if (rb && rb->Deleted())
+        return ErrorMessage("glFramebufferRenderbuffer: renderbuffer has already been deleted!");
+
+    if (target != LOCAL_GL_FRAMEBUFFER)
+        return ErrorMessage("glFramebufferRenderbuffer: target must be GL_FRAMEBUFFER");
+
+    if ((attachment < LOCAL_GL_COLOR_ATTACHMENT0 || attachment >= LOCAL_GL_COLOR_ATTACHMENT0 + mFramebufferColorAttachments.Length()) &&
+        attachment != LOCAL_GL_DEPTH_ATTACHMENT &&
+        attachment != LOCAL_GL_STENCIL_ATTACHMENT)
+        return ErrorMessage("glFramebufferRenderbuffer: invalid attachment");
+
+    if (rbtarget != LOCAL_GL_RENDERBUFFER)
+        return ErrorMessage("glFramebufferRenderbuffer: rbtarget must be GL_RENDERBUFFER");
+
+    GLuint name = rb ? rb->GLName() : 0;
+
+    MakeContextCurrent();
+
+    gl->fFramebufferRenderbuffer(target, attachment, rbtarget, name);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::FramebufferTexture2D(GLenum target,
+                                   GLenum attachment,
+                                   GLenum textarget,
+                                   nsIWebGLTexture *wtex,
+                                   GLint level)
+{
+    WebGLTexture *tex = static_cast<WebGLTexture*>(wtex);
+
+    if (tex && tex->Deleted())
+        return ErrorMessage("glFramebufferTexture2D: texture has already been deleted!");
+
+    if (target != LOCAL_GL_FRAMEBUFFER)
+        return ErrorMessage("glFramebufferTexture2D: target must be GL_FRAMEBUFFER");
+
+    if ((attachment < LOCAL_GL_COLOR_ATTACHMENT0 || attachment >= LOCAL_GL_COLOR_ATTACHMENT0 + mFramebufferColorAttachments.Length()) &&
+        attachment != LOCAL_GL_DEPTH_ATTACHMENT &&
+        attachment != LOCAL_GL_STENCIL_ATTACHMENT)
+        return ErrorMessage("glFramebufferTexture2D: invalid attachment");
+
+    if (textarget != LOCAL_GL_TEXTURE_2D &&
+        (textarget < LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X ||
+         textarget > LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))
+        return ErrorMessage("glFramebufferTexture2D: invalid textarget (only 2D or cube face)");
+
+    if (level != 0)
+        return ErrorMessage("glFramebufferTexture2D: level must be 0");
+
+    // XXXXX we need to store/reference this attachment!
+
+    MakeContextCurrent();
+
+    gl->fFramebufferTexture2D(target, attachment, textarget, tex->GLName(), level);
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_0(Flush, Flush)
+
+GL_SAME_METHOD_0(Finish, Finish)
+
+GL_SAME_METHOD_1(FrontFace, FrontFace, GLenum)
+
+GL_SAME_METHOD_1(GenerateMipmap, GenerateMipmap, GLenum)
+
+// returns an object: { size: ..., type: ..., name: ... }
+NS_IMETHODIMP
+WebGLContext::GetActiveAttrib(nsIWebGLProgram *prog, PRUint32 index, nsIWebGLActiveInfo **retval)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    GLint len = 0;
+    gl->fGetProgramiv(program, LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
+    if (len == 0)
+        return NS_ERROR_FAILURE;
+
+    nsAutoArrayPtr<char> name(new char[len+1]);
+    PRInt32 attrsize = 0;
+    PRUint32 attrtype = 0;
+
+    gl->fGetActiveAttrib(program, index, len+1, &len, (GLint*) &attrsize, (GLuint*) &attrtype, name);
+    if (attrsize == 0 || attrtype == 0)
+        return NS_ERROR_FAILURE;
+
+    JSObjectHelper retobj(&js);
+    retobj.DefineProperty("size", attrsize);
+    retobj.DefineProperty("type", attrtype);
+    retobj.DefineProperty("name", name, len);
+
+    js.SetRetVal(retobj);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetActiveUniform(nsIWebGLProgram *prog, PRUint32 index, nsIWebGLActiveInfo **retval)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    GLint len = 0;
+    gl->fGetProgramiv(program, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
+    if (len == 0)
+        return NS_ERROR_FAILURE;
+
+    nsAutoArrayPtr<char> name(new char[len+1]);
+    PRInt32 attrsize = 0;
+    PRUint32 attrtype = 0;
+
+    gl->fGetActiveUniform(program, index, len+1, &len, (GLint*) &attrsize, (GLenum*) &attrtype, name);
+    if (attrsize == 0 || attrtype == 0)
+        return NS_ERROR_FAILURE;
+
+    JSObjectHelper retobj(&js);
+    retobj.DefineProperty("size", attrsize);
+    retobj.DefineProperty("type", attrtype);
+    retobj.DefineProperty("name", name, len);
+
+    js.SetRetVal(retobj.Object());
+
+    return NS_OK;
+}
+
+// XXX fixme to return a IntArray
+#if 0
+NS_IMETHODIMP
+WebGLContext::GetAttachedShaders(nsIWebGLProgram *prog)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    GLint count = 0;
+    gl->fGetProgramiv(program, LOCAL_GL_ATTACHED_SHADERS, &count);
+    if (count == 0) {
+        JSObject *empty = JS_NewArrayObject(js.ctx, 0, NULL);
+        js.SetRetVal(empty);
+        return NS_OK;
+    }
+
+    nsAutoArrayPtr<PRUint32> shaders(new PRUint32[count]);
+
+    gl->fGetAttachedShaders(program, count, NULL, (GLuint*) shaders.get());
+
+    JSObject *obj = NativeJSContext::ArrayToJSArray(js.ctx, shaders, count);
+
+    js.AddGCRoot(obj, "GetAttachedShaders");
+    js.SetRetVal(obj);
+    js.ReleaseGCRoot(obj);
+
+    return NS_OK;
+}
+#endif
+
+NS_IMETHODIMP
+WebGLContext::GetAttribLocation(nsIWebGLProgram *prog,
+                                  const nsAString& name,
+                                  PRInt32 *retval)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    MakeContextCurrent();
+    *retval = gl->fGetAttribLocation(program, NS_LossyConvertUTF16toASCII(name).get());
+    return NS_OK;
+}
+
+// XXX fixme to return objects correctly for programs/etc.
+NS_IMETHODIMP
+WebGLContext::GetParameter(PRUint32 pname)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        //
+        // String params
+        //
+
+        // XXX do we want to fake these?  Could be a problem to reveal this to web content
+        case LOCAL_GL_VENDOR:
+        case LOCAL_GL_RENDERER:
+        case LOCAL_GL_VERSION:
+        case LOCAL_GL_SHADING_LANGUAGE_VERSION:
+        //case LOCAL_GL_EXTENSIONS:  // Not going to expose this
+
+            break;
+
+        //
+        // Single-value params
+        //
+
+// int
+        case LOCAL_GL_ARRAY_BUFFER_BINDING:
+        case LOCAL_GL_ELEMENT_ARRAY_BUFFER_BINDING: // XXX really?
+        case LOCAL_GL_CULL_FACE_MODE:
+        case LOCAL_GL_FRONT_FACE:
+        case LOCAL_GL_TEXTURE_BINDING_2D:
+        case LOCAL_GL_TEXTURE_BINDING_CUBE_MAP:
+        case LOCAL_GL_ACTIVE_TEXTURE:
+        case LOCAL_GL_STENCIL_WRITEMASK:
+        case LOCAL_GL_STENCIL_BACK_WRITEMASK:
+        case LOCAL_GL_DEPTH_CLEAR_VALUE:
+        case LOCAL_GL_STENCIL_CLEAR_VALUE:
+        case LOCAL_GL_STENCIL_FUNC:
+        case LOCAL_GL_STENCIL_VALUE_MASK:
+        case LOCAL_GL_STENCIL_REF:
+        case LOCAL_GL_STENCIL_FAIL:
+        case LOCAL_GL_STENCIL_PASS_DEPTH_FAIL:
+        case LOCAL_GL_STENCIL_PASS_DEPTH_PASS:
+        case LOCAL_GL_STENCIL_BACK_FUNC:
+        case LOCAL_GL_STENCIL_BACK_VALUE_MASK:
+        case LOCAL_GL_STENCIL_BACK_REF:
+        case LOCAL_GL_STENCIL_BACK_FAIL:
+        case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_FAIL:
+        case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_PASS:
+        case LOCAL_GL_DEPTH_FUNC:
+        case LOCAL_GL_BLEND_SRC_RGB:
+        case LOCAL_GL_BLEND_SRC_ALPHA:
+        case LOCAL_GL_BLEND_DST_RGB:
+        case LOCAL_GL_BLEND_DST_ALPHA:
+        case LOCAL_GL_BLEND_EQUATION_RGB:
+        case LOCAL_GL_BLEND_EQUATION_ALPHA:
+        //case LOCAL_GL_UNPACK_ALIGNMENT: // not supported
+        //case LOCAL_GL_PACK_ALIGNMENT: // not supported
+        case LOCAL_GL_CURRENT_PROGRAM:
+        case LOCAL_GL_GENERATE_MIPMAP_HINT:
+        case LOCAL_GL_SUBPIXEL_BITS:
+        case LOCAL_GL_MAX_TEXTURE_SIZE:
+        case LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE:
+        case LOCAL_GL_MAX_ELEMENTS_INDICES:
+        case LOCAL_GL_MAX_ELEMENTS_VERTICES:
+        case LOCAL_GL_SAMPLE_BUFFERS:
+        case LOCAL_GL_SAMPLES:
+        //case LOCAL_GL_COMPRESSED_TEXTURE_FORMATS:
+        //case LOCAL_GL_NUM_COMPRESSED_TEXTURE_FORMATS:
+        //case LOCAL_GL_SHADER_BINARY_FORMATS:
+        //case LOCAL_GL_NUM_SHADER_BINARY_FORMATS:
+        case LOCAL_GL_MAX_VERTEX_ATTRIBS:
+        case LOCAL_GL_MAX_VERTEX_UNIFORM_COMPONENTS:
+        case LOCAL_GL_MAX_VARYING_FLOATS:
+        case LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
+        case LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
+        case LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS:
+        case LOCAL_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
+        case LOCAL_GL_MAX_RENDERBUFFER_SIZE:
+        case LOCAL_GL_RED_BITS:
+        case LOCAL_GL_GREEN_BITS:
+        case LOCAL_GL_BLUE_BITS:
+        case LOCAL_GL_ALPHA_BITS:
+        case LOCAL_GL_DEPTH_BITS:
+        case LOCAL_GL_STENCIL_BITS:
+        //case LOCAL_GL_IMPLEMENTATION_COLOR_READ_TYPE:
+        //case LOCAL_GL_IMPLEMENTATION_COLOR_READ_FORMAT:
+        case LOCAL_GL_RENDERBUFFER_BINDING:
+        case LOCAL_GL_FRAMEBUFFER_BINDING:
+        {
+            PRInt32 iv = 0;
+            gl->fGetIntegerv(pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+// float
+        case LOCAL_GL_LINE_WIDTH:
+        case LOCAL_GL_POLYGON_OFFSET_FACTOR:
+        case LOCAL_GL_POLYGON_OFFSET_UNITS:
+        case LOCAL_GL_SAMPLE_COVERAGE_VALUE:
+        {
+            float fv = 0;
+            gl->fGetFloatv(pname, &fv);
+            js.SetRetVal((double) fv);
+        }
+            break;
+// bool
+        case LOCAL_GL_SAMPLE_COVERAGE_INVERT:
+        case LOCAL_GL_COLOR_WRITEMASK:
+        case LOCAL_GL_DEPTH_WRITEMASK:
+        ////case LOCAL_GL_SHADER_COMPILER: // pretty much must be true 
+        {
+            realGLboolean bv = 0;
+            gl->fGetBooleanv(pname, &bv);
+            js.SetBoolRetVal(bv);
+        }
+            break;
+
+        //
+        // Complex values
+        //
+        case LOCAL_GL_DEPTH_RANGE: // 2 floats
+        case LOCAL_GL_ALIASED_POINT_SIZE_RANGE: // 2 floats
+        case LOCAL_GL_ALIASED_LINE_WIDTH_RANGE: // 2 floats
+        {
+            float fv[2] = { 0 };
+            gl->fGetFloatv(pname, &fv[0]);
+            js.SetRetVal(fv, 2);
+        }
+            break;
+        
+        case LOCAL_GL_COLOR_CLEAR_VALUE: // 4 floats
+        case LOCAL_GL_BLEND_COLOR: // 4 floats
+        {
+            float fv[4] = { 0 };
+            gl->fGetFloatv(pname, &fv[0]);
+            js.SetRetVal(fv, 4);
+        }
+            break;
+
+        case LOCAL_GL_MAX_VIEWPORT_DIMS: // 2 ints
+        {
+            PRInt32 iv[2] = { 0 };
+            gl->fGetIntegerv(pname, (GLint*) &iv[0]);
+            js.SetRetVal(iv, 2);
+        }
+            break;
+
+        case LOCAL_GL_SCISSOR_BOX: // 4 ints
+        case LOCAL_GL_VIEWPORT: // 4 ints
+        {
+            PRInt32 iv[4] = { 0 };
+            gl->fGetIntegerv(pname, (GLint*) &iv[0]);
+            js.SetRetVal(iv, 4);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetBufferParameteri(GLenum target, GLenum pname, GLint *retval)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_BUFFER_SIZE:
+        case LOCAL_GL_BUFFER_USAGE:
+        case LOCAL_GL_BUFFER_ACCESS:
+        case LOCAL_GL_BUFFER_MAPPED:
+        {
+            PRInt32 iv = 0;
+            gl->fGetBufferParameteriv(target, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetBufferParameter(GLenum target, GLenum pname)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_BUFFER_SIZE:
+        case LOCAL_GL_BUFFER_USAGE:
+        case LOCAL_GL_BUFFER_ACCESS:
+        case LOCAL_GL_BUFFER_MAPPED:
+        {
+            PRInt32 iv = 0;
+            gl->fGetBufferParameteriv(target, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetFramebufferAttachmentParameteri(GLenum target, GLenum attachment, GLenum pname, GLint *retval)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (attachment) {
+        case LOCAL_GL_COLOR_ATTACHMENT0:
+        case LOCAL_GL_DEPTH_ATTACHMENT:
+        case LOCAL_GL_STENCIL_ATTACHMENT:
+            break;
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    switch (pname) {
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
+        {
+            PRInt32 iv = 0;
+            gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetFramebufferAttachmentParameter(GLenum target, GLenum attachment, GLenum pname)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (attachment) {
+        case LOCAL_GL_COLOR_ATTACHMENT0:
+        case LOCAL_GL_DEPTH_ATTACHMENT:
+        case LOCAL_GL_STENCIL_ATTACHMENT:
+            break;
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    switch (pname) {
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
+        case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
+        {
+            PRInt32 iv = 0;
+            gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetRenderbufferParameteri(GLenum target, GLenum pname, GLint *retval)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_RENDERBUFFER_WIDTH:
+        case LOCAL_GL_RENDERBUFFER_HEIGHT:
+        case LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT:
+        case LOCAL_GL_RENDERBUFFER_RED_SIZE:
+        case LOCAL_GL_RENDERBUFFER_GREEN_SIZE:
+        case LOCAL_GL_RENDERBUFFER_BLUE_SIZE:
+        case LOCAL_GL_RENDERBUFFER_ALPHA_SIZE:
+        case LOCAL_GL_RENDERBUFFER_DEPTH_SIZE:
+        case LOCAL_GL_RENDERBUFFER_STENCIL_SIZE:
+        {
+            PRInt32 iv = 0;
+            gl->fGetRenderbufferParameteriv(target, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetRenderbufferParameter(GLenum target, GLenum pname)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_RENDERBUFFER_WIDTH:
+        case LOCAL_GL_RENDERBUFFER_HEIGHT:
+        case LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT:
+        case LOCAL_GL_RENDERBUFFER_RED_SIZE:
+        case LOCAL_GL_RENDERBUFFER_GREEN_SIZE:
+        case LOCAL_GL_RENDERBUFFER_BLUE_SIZE:
+        case LOCAL_GL_RENDERBUFFER_ALPHA_SIZE:
+        case LOCAL_GL_RENDERBUFFER_DEPTH_SIZE:
+        case LOCAL_GL_RENDERBUFFER_STENCIL_SIZE:
+        {
+            PRInt32 iv = 0;
+            gl->fGetRenderbufferParameteriv(target, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::CreateBuffer(nsIWebGLBuffer **retval)
+{
+    MakeContextCurrent();
+
+    GLuint name;
+    gl->fGenBuffers(1, &name);
+
+    WebGLBuffer *globj = new WebGLBuffer(name);
+    if (globj) {
+        NS_ADDREF(*retval = globj);
+        mMapBuffers.Put(name, globj);
+    } else {
+        gl->fDeleteBuffers(1, &name);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::CreateTexture(nsIWebGLTexture **retval)
+{
+    MakeContextCurrent();
+
+    GLuint name;
+    gl->fGenTextures(1, &name);
+
+    WebGLTexture *globj = new WebGLTexture(name);
+    if (globj) {
+        NS_ADDREF(*retval = globj);
+        mMapTextures.Put(name, globj);
+    } else {
+        gl->fDeleteTextures(1, &name);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetError(GLenum *_retval)
+{
+    MakeContextCurrent();
+    *_retval = gl->fGetError();
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetProgrami(nsIWebGLProgram *prog, PRUint32 pname, GLint *retval)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_CURRENT_PROGRAM:
+        case LOCAL_GL_DELETE_STATUS:
+        case LOCAL_GL_LINK_STATUS:
+        case LOCAL_GL_VALIDATE_STATUS:
+        case LOCAL_GL_ATTACHED_SHADERS:
+        case LOCAL_GL_INFO_LOG_LENGTH:
+        case LOCAL_GL_ACTIVE_UNIFORMS:
+        case LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH:
+        case LOCAL_GL_ACTIVE_ATTRIBUTES:
+        case LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
+        {
+            PRInt32 iv = 0;
+            gl->fGetProgramiv(program, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetProgramParameter(nsIWebGLProgram *prog, PRUint32 pname)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_CURRENT_PROGRAM:
+        case LOCAL_GL_DELETE_STATUS:
+        case LOCAL_GL_LINK_STATUS:
+        case LOCAL_GL_VALIDATE_STATUS:
+        case LOCAL_GL_ATTACHED_SHADERS:
+        case LOCAL_GL_INFO_LOG_LENGTH:
+        case LOCAL_GL_ACTIVE_UNIFORMS:
+        case LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH:
+        case LOCAL_GL_ACTIVE_ATTRIBUTES:
+        case LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
+        {
+            PRInt32 iv = 0;
+            gl->fGetProgramiv(program, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetProgramInfoLog(nsIWebGLProgram *prog, nsAString& retval)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!");
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    MakeContextCurrent();
+
+    PRInt32 k = -1;
+    gl->fGetProgramiv(program, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
+    if (k == -1)
+        return NS_ERROR_FAILURE;
+
+    if (k == 0) {
+        retval.Truncate();
+        return NS_OK;
+    }
+
+    nsCAutoString log;
+    log.SetCapacity(k);
+
+    gl->fGetProgramInfoLog(program, k, (GLint*) &k, (char*) log.BeginWriting());
+
+    log.SetLength(k);
+
+    CopyASCIItoUTF16(log, retval);
+
+    return NS_OK;
+}
+
+/* DOMString glGetString (in GLenum name); */
+NS_IMETHODIMP
+WebGLContext::GetString(GLenum name, nsAString & _retval NS_OUTPARAM)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* XXX fix */
+/* void texParameter (); */
+NS_IMETHODIMP
+WebGLContext::TexParameterf(GLenum target, GLenum pname, GLfloat param)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc != 3)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    MakeContextCurrent();
+
+    gl->fTexParameterf (target, pname, param);
+
+    return NS_OK;
+}
+NS_IMETHODIMP
+WebGLContext::TexParameteri(GLenum target, GLenum pname, GLint param)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc != 3)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    MakeContextCurrent();
+
+    gl->fTexParameteri (target, pname, param);
+
+    return NS_OK;
+}
+
+#if 0
+NS_IMETHODIMP
+WebGLContext::TexParameter()
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc != 3)
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    jsuint targetVal;
+    jsuint pnameVal;
+    if (!::JS_ValueToECMAUint32(js.ctx, js.argv[0], &targetVal) ||
+        !::JS_ValueToECMAUint32(js.ctx, js.argv[1], &pnameVal))
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    if (targetVal != LOCAL_GL_TEXTURE_2D &&
+        targetVal != LOCAL_GL_TEXTURE_CUBE_MAP)
+    {
+        return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    MakeContextCurrent();
+    switch (pnameVal) {
+        case LOCAL_GL_TEXTURE_MIN_FILTER: {
+            jsuint ival;
+            if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
+                (ival != LOCAL_GL_NEAREST &&
+                 ival != LOCAL_GL_LINEAR &&
+                 ival != LOCAL_GL_NEAREST_MIPMAP_NEAREST &&
+                 ival != LOCAL_GL_LINEAR_MIPMAP_NEAREST &&
+                 ival != LOCAL_GL_NEAREST_MIPMAP_LINEAR &&
+                 ival != LOCAL_GL_LINEAR_MIPMAP_LINEAR))
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            gl->fTexParameteri (targetVal, pnameVal, ival);
+        }
+            break;
+        case LOCAL_GL_TEXTURE_MAG_FILTER: {
+            jsuint ival;
+            if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
+                (ival != LOCAL_GL_NEAREST &&
+                 ival != LOCAL_GL_LINEAR))
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            gl->fTexParameteri (targetVal, pnameVal, ival);
+        }
+            break;
+        case LOCAL_GL_TEXTURE_WRAP_S:
+        case LOCAL_GL_TEXTURE_WRAP_T: {
+            jsuint ival;
+            if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
+                (ival != LOCAL_GL_CLAMP &&
+                 ival != LOCAL_GL_CLAMP_TO_EDGE &&
+                 ival != LOCAL_GL_REPEAT))
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            gl->fTexParameteri (targetVal, pnameVal, ival);
+        }
+            break;
+        case LOCAL_GL_GENERATE_MIPMAP: {
+            jsuint ival;
+            if (js.argv[2] == JSVAL_TRUE)
+                ival = 1;
+            else if (js.argv[2] == JSVAL_FALSE)
+                ival = 0;
+            else if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
+                     (ival != 0 && ival != 1))
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            gl->fTexParameteri (targetVal, pnameVal, ival);
+        }
+            break;
+        case LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT: {
+#if 0
+            if (GLEW_EXT_texture_filter_anisotropic) {
+                jsdouble dval;
+                if (!::JS_ValueToNumber(js.ctx, js.argv[2], &dval))
+                    return NS_ERROR_DOM_SYNTAX_ERR;
+                gl->fTexParameterf (targetVal, pnameVal, (float) dval);
+            } else {
+                return NS_ERROR_NOT_IMPLEMENTED;
+            }
+#else
+            return NS_ERROR_NOT_IMPLEMENTED;
+#endif
+        }
+            break;
+        default:
+            return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    return NS_OK;
+}
+#endif
+
+/* XXX fix */
+/* void getTexParameter (); */
+
+/* GLfloat getTexParameterf (in GLenum target, in GLenum pname); */
+NS_IMETHODIMP
+WebGLContext::GetTexParameterf(GLenum target, GLenum pname, GLfloat *retval)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_TEXTURE_MIN_FILTER:
+        case LOCAL_GL_TEXTURE_MAG_FILTER:
+        case LOCAL_GL_TEXTURE_WRAP_S:
+        case LOCAL_GL_TEXTURE_WRAP_T:
+        {
+            float fv = 0;
+            gl->fGetTexParameterfv(target, pname, (GLfloat*) &fv);
+            js.SetRetVal(fv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetTexParameteri(GLenum target, GLenum pname, GLint *retval)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_TEXTURE_MIN_FILTER:
+        case LOCAL_GL_TEXTURE_MAG_FILTER:
+        case LOCAL_GL_TEXTURE_WRAP_S:
+        case LOCAL_GL_TEXTURE_WRAP_T:
+        {
+            PRInt32 iv = 0;
+            gl->fGetTexParameteriv(target, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetTexParameter(GLenum target, GLenum pname)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_TEXTURE_MIN_FILTER:
+        case LOCAL_GL_TEXTURE_MAG_FILTER:
+        case LOCAL_GL_TEXTURE_WRAP_S:
+        case LOCAL_GL_TEXTURE_WRAP_T:
+        {
+            float fv = 0;
+            gl->fGetTexParameterfv(target, pname, (GLfloat*) &fv);
+            js.SetRetVal(fv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+/* XXX fix */
+/* any getUniform(in WebGLProgram program, in WebGLUniformLocation location) raises(DOMException); */
+NS_IMETHODIMP
+WebGLContext::GetUniform(nsIWebGLProgram *prog, GLint location)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    GLint uArraySize = 0;
+    GLenum uType = 0;
+
+    gl->fGetActiveUniform(program, location, 0, NULL, &uArraySize, &uType, NULL);
+    if (uArraySize == 0)
+        return NS_ERROR_FAILURE;
+
+    // glGetUniform needs to be called for each element of an array separately, so we don't
+    // have to deal with uArraySize at all.
+
+    GLenum baseType;
+    GLint unitSize;
+    if (!BaseTypeAndSizeFromUniformType(uType, &baseType, &unitSize))
+        return NS_ERROR_FAILURE;
+
+    // this should never happen
+    if (unitSize > 16)
+        return NS_ERROR_FAILURE;
+
+    if (baseType == LOCAL_GL_FLOAT) {
+        GLfloat fv[16];
+        gl->fGetUniformfv(program, location, fv);
+        js.SetRetVal(fv, unitSize);
+    } else if (baseType == LOCAL_GL_INT) {
+        GLint iv[16];
+        gl->fGetUniformiv(program, location, iv);
+        js.SetRetVal((PRInt32*)iv, unitSize);
+    } else {
+        js.SetRetValAsJSVal(JSVAL_NULL);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetUniformLocation(nsIWebGLProgram *prog, const nsAString& name, GLint *retval)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    MakeContextCurrent();
+    *retval = gl->fGetUniformLocation(program, NS_LossyConvertUTF16toASCII(name).get());
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetVertexAttrib(GLuint index, GLenum pname)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        // int
+        case LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE:
+        case LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE:
+        case LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE:
+        case LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED:
+        case LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
+        case LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
+        {
+            PRInt32 iv = 0;
+            gl->fGetVertexAttribiv(index, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        case LOCAL_GL_CURRENT_VERTEX_ATTRIB:
+        {
+            GLfloat fv[4] = { 0 };
+            gl->fGetVertexAttribfv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, &fv[0]);
+            js.SetRetVal(fv, 4);
+        }
+            break;
+
+        // not supported; doesn't make sense to return a pointer unless we have some kind of buffer object abstraction
+        case LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER:
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+
+    }
+
+    return NS_OK;
+}
+
+/* GLuint getVertexAttribOffset (in GLuint index, in GLenum pname); */
+NS_IMETHODIMP
+WebGLContext::GetVertexAttribOffset(GLuint index, GLenum pname, GLuint *retval)
+{
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+WebGLContext::Hint(GLenum target, GLenum mode)
+{
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::IsBuffer(nsIWebGLBuffer *iobj, GLboolean *retval)
+{
+    if (!iobj)
+        return NS_ERROR_FAILURE;
+
+    *retval = ! static_cast<WebGLBuffer*>(iobj)->Deleted();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::IsFramebuffer(nsIWebGLFramebuffer *iobj, GLboolean *retval)
+{
+    if (!iobj)
+        return NS_ERROR_FAILURE;
+
+    *retval = ! static_cast<WebGLFramebuffer*>(iobj)->Deleted();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::IsProgram(nsIWebGLProgram *iobj, GLboolean *retval)
+{
+    if (!iobj)
+        return NS_ERROR_FAILURE;
+
+    *retval = ! static_cast<WebGLProgram*>(iobj)->Deleted();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::IsRenderbuffer(nsIWebGLRenderbuffer *iobj, GLboolean *retval)
+{
+    if (!iobj)
+        return NS_ERROR_FAILURE;
+
+    *retval = ! static_cast<WebGLRenderbuffer*>(iobj)->Deleted();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::IsShader(nsIWebGLShader *iobj, GLboolean *retval)
+{
+    if (!iobj)
+        return NS_ERROR_FAILURE;
+
+    *retval = ! static_cast<WebGLShader*>(iobj)->Deleted();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::IsTexture(nsIWebGLTexture *iobj, GLboolean *retval)
+{
+    if (!iobj)
+        return NS_ERROR_FAILURE;
+
+    *retval = ! static_cast<WebGLTexture*>(iobj)->Deleted();
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::IsEnabled(GLenum k, GLboolean *retval)
+{
+    MakeContextCurrent();
+    *retval = gl->fIsEnabled(k);
+    return NS_OK;
+}
+
+
+GL_SAME_METHOD_1(LineWidth, LineWidth, float)
+
+NS_IMETHODIMP
+WebGLContext::LinkProgram(nsIWebGLProgram *prog)
+{
+    if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    MakeContextCurrent();
+
+    gl->fLinkProgram(program);
+
+    return NS_OK;
+}
+
+// XXX #if 0
+NS_IMETHODIMP
+WebGLContext::PixelStorei(GLenum pname, GLint param)
+{
+    if (pname != LOCAL_GL_PACK_ALIGNMENT &&
+        pname != LOCAL_GL_UNPACK_ALIGNMENT)
+        return NS_ERROR_INVALID_ARG;
+
+    MakeContextCurrent();
+    gl->fPixelStorei(pname, param);
+
+    return NS_OK;
+}
+//#endif
+
+GL_SAME_METHOD_2(PolygonOffset, PolygonOffset, float, float)
+
+NS_IMETHODIMP
+WebGLContext::ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type)
+{
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (mCanvasElement->IsWriteOnly() && !nsContentUtils::IsCallerTrustedForRead()) {
+        LogMessage("readPixels: Not allowed");
+        return NS_ERROR_DOM_SECURITY_ERR;
+    }
+
+    MakeContextCurrent();
+
+    if (!CanvasUtils::CheckSaneSubrectSize(x,y,width,height, mWidth, mHeight))
+        return ErrorMessage("readPixels: rectangle outside canvas");
+
+    PRUint32 size = 0;
+    switch (format) {
+      case LOCAL_GL_ALPHA:
+        size = 1;
+        break;
+      case LOCAL_GL_RGB:
+        size = 3;
+        break;
+      case LOCAL_GL_RGBA:
+        size = 4;
+        break;
+      default:
+        return ErrorMessage("readPixels: unsupported pixel format");
+    }
+    switch (type) {
+//         case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
+//         case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
+//         case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
+      case LOCAL_GL_UNSIGNED_BYTE:
+        break;
+      default:
+        return ErrorMessage("readPixels: unsupported pixel type");
+    }
+
+    PRUint32 len = width*height*size;
+
+    nsAutoArrayPtr<PRUint8> data(new PRUint8[len]);
+    gl->fReadPixels((GLint)x, (GLint)y, width, height, format, type, (GLvoid *)data.get());
+
+    nsAutoArrayPtr<jsval> jsvector(new jsval[len]);
+    for (PRUint32 i = 0; i < len; i++)
+        jsvector[i] = INT_TO_JSVAL(data[i]);
+
+    JSObject *dataArray = JS_NewArrayObject(js.ctx, len, jsvector);
+    if (!dataArray)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    JSObjectHelper retobj(&js);
+    retobj.DefineProperty("width", width);
+    retobj.DefineProperty("height", height);
+    retobj.DefineProperty("data", dataArray);
+
+    js.SetRetVal(retobj);
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_4(RenderbufferStorage, RenderbufferStorage, GLenum, GLenum, GLsizei, GLsizei)
+
+GL_SAME_METHOD_2(SampleCoverage, SampleCoverage, float, GLboolean)
+
+GL_SAME_METHOD_4(Scissor, Scissor, GLint, GLint, GLsizei, GLsizei)
+
+GL_SAME_METHOD_3(StencilFunc, StencilFunc, GLenum, GLint, GLuint)
+
+GL_SAME_METHOD_4(StencilFuncSeparate, StencilFuncSeparate, GLenum, GLenum, GLint, GLuint)
+
+GL_SAME_METHOD_1(StencilMask, StencilMask, GLuint)
+
+GL_SAME_METHOD_2(StencilMaskSeparate, StencilMaskSeparate, GLenum, GLuint)
+
+GL_SAME_METHOD_3(StencilOp, StencilOp, GLenum, GLenum, GLenum)
+
+GL_SAME_METHOD_4(StencilOpSeparate, StencilOpSeparate, GLenum, GLenum, GLenum, GLenum)
+
+
+nsresult
+WebGLContext::TexImageElementBase(nsIDOMHTMLElement *imageOrCanvas,
+                                  gfxImageSurface **imageOut,
+                                  PRBool flipY, PRBool premultiplyAlpha)
+{
+    gfxImageSurface *surf = nsnull;
+
+    nsLayoutUtils::SurfaceFromElementResult res =
+        nsLayoutUtils::SurfaceFromElement(imageOrCanvas,
+                                          nsLayoutUtils::SFE_WANT_NEW_SURFACE | nsLayoutUtils::SFE_WANT_IMAGE_SURFACE);
+    if (!res.mSurface)
+        return NS_ERROR_FAILURE;
+
+    CanvasUtils::DoDrawImageSecurityCheck(mCanvasElement, res.mPrincipal, res.mIsWriteOnly);
+
+    if (res.mSurface->GetType() != gfxASurface::SurfaceTypeImage) {
+        // SurfaceFromElement lied!
+        return NS_ERROR_FAILURE;
+    }
+
+    surf = static_cast<gfxImageSurface*>(res.mSurface.get());
+
+    PRInt32 width, height;
+    width = res.mSize.width;
+    height = res.mSize.height;
+
+    if (width <= 0 || height <= 0)
+        return NS_ERROR_FAILURE;
+
+    if (surf->Format() == gfxASurface::ImageFormatARGB32) {
+        PRUint8* src = surf->Data();
+        PRUint8* dst = surf->Data();
+
+        // this wants some SSE love
+
+        for (int j = 0; j < height; j++) {
+            src = surf->Data() + j * surf->Stride();
+            // note that dst's stride is always tightly packed
+            for (int i = 0; i < width; i++) {
+#ifdef IS_LITTLE_ENDIAN
+                PRUint8 b = *src++;
+                PRUint8 g = *src++;
+                PRUint8 r = *src++;
+                PRUint8 a = *src++;
+#else
+                PRUint8 a = *src++;
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+#endif
+                // Convert to non-premultiplied color
+                if (a != 0) {
+                    r = (r * 255) / a;
+                    g = (g * 255) / a;
+                    b = (b * 255) / a;
+                }
+
+                *dst++ = r;
+                *dst++ = g;
+                *dst++ = b;
+                *dst++ = a;
+            }
+        }
+    } else if (surf->Format() == gfxASurface::ImageFormatRGB24) {
+        PRUint8* src = surf->Data();
+        PRUint8* dst = surf->Data();
+
+        // this wants some SSE love
+
+        for (int j = 0; j < height; j++) {
+            src = surf->Data() + j * surf->Stride();
+            // note that dst's stride is always tightly packed
+            for (int i = 0; i < width; i++) {
+#ifdef IS_LITTLE_ENDIAN
+                PRUint8 b = *src++;
+                PRUint8 g = *src++;
+                PRUint8 r = *src++;
+                src++;
+#else
+                src++;
+                PRUint8 r = *src++;
+                PRUint8 g = *src++;
+                PRUint8 b = *src++;
+#endif
+
+                *dst++ = r;
+                *dst++ = g;
+                *dst++ = b;
+                *dst++ = 255;
+            }
+        }
+    } else {
+        return NS_ERROR_FAILURE;
+    }
+
+    if (flipY) {
+        nsRefPtr<gfxImageSurface> tmpsurf = new gfxImageSurface(res.mSize,
+                                                                gfxASurface::ImageFormatARGB32);
+        if (!tmpsurf || tmpsurf->CairoStatus())
+            return NS_ERROR_FAILURE;
+
+        nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
+
+        if (!tmpctx || tmpctx->HasError())
+            return NS_ERROR_FAILURE;
+
+        tmpctx->Translate(gfxPoint(0, res.mSize.height));
+        tmpctx->Scale(1.0, -1.0);
+
+        tmpctx->NewPath();
+        tmpctx->Rectangle(gfxRect(0, 0, res.mSize.width, res.mSize.height));
+
+        tmpctx->SetSource(res.mSurface);
+        tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
+        tmpctx->Fill();
+
+        NS_ADDREF(surf = tmpsurf);
+        tmpctx = nsnull;
+    }
+
+    res.mSurface.forget();
+    *imageOut = surf;
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_2(Uniform1i, Uniform1i, GLint, GLint)
+GL_SAME_METHOD_3(Uniform2i, Uniform2i, GLint, GLint, GLint)
+GL_SAME_METHOD_4(Uniform3i, Uniform3i, GLint, GLint, GLint, GLint)
+GL_SAME_METHOD_5(Uniform4i, Uniform4i, GLint, GLint, GLint, GLint, GLint)
+
+GL_SAME_METHOD_2(Uniform1f, Uniform1f, GLint, GLfloat)
+GL_SAME_METHOD_3(Uniform2f, Uniform2f, GLint, GLfloat, GLfloat)
+GL_SAME_METHOD_4(Uniform3f, Uniform3f, GLint, GLfloat, GLfloat, GLfloat)
+GL_SAME_METHOD_5(Uniform4f, Uniform4f, GLint, GLfloat, GLfloat, GLfloat, GLfloat)
+
+// one uint arg followed by an array of c elements of glTypeConst.
+#define GL_SIMPLE_ARRAY_METHOD(glname, name, c, glTypeConst, ptrType)             \
+NS_IMETHODIMP                                                                     \
+WebGLContext::name(GLint idx, nsIWebGLArray *v)                                  \
+{                                                                                 \
+    NativeJSContext js;                                                           \
+    if (NS_FAILED(js.error))                                                      \
+        return js.error;                                                          \
+    JSObject *arrayObj;                                                           \
+    jsuint arrayLen;                                                              \
+    if (js.argc != 2)                                                             \
+        return NS_ERROR_INVALID_ARG;                                              \
+    if (NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[1], &arrayObj, &arrayLen)) { \
+        if (arrayLen % c != 0) {                                                  \
+            return ErrorMessage(#name ": array length not divisible by " #c);     \
+        }                                                                         \
+        SimpleBuffer sbuffer(glTypeConst, c, js.ctx, arrayObj, arrayLen);         \
+        if (!sbuffer.Valid())                                                     \
+            return NS_ERROR_FAILURE;                                              \
+        MakeContextCurrent();                                                     \
+        gl->f##glname(idx, arrayLen / c, ( ptrType *)sbuffer.data);               \
+    } else {                                                                      \
+        if (glTypeConst == LOCAL_GL_INT) {                                        \
+            if (v->NativeType() != LOCAL_GL_INT) {                                \
+                return ErrorMessage(#name ": arg not an array");                  \
+            }                                                                     \
+            if (v->NativeCount() % c != 0) {                                      \
+                return ErrorMessage(#name ": array length not divisible by " #c); \
+            }                                                                     \
+            MakeContextCurrent();                                                 \
+            gl->f##glname(idx, v->NativeCount() / c, ( ptrType *)v->NativePointer()); \
+        } else if (glTypeConst == LOCAL_GL_FLOAT) {                               \
+            if (v->NativeType() != LOCAL_GL_FLOAT) {                              \
+                return ErrorMessage(#name ": arg not an array");                  \
+            }                                                                     \
+            if (v->NativeCount() % c != 0) {                                      \
+                return ErrorMessage(#name ": array length not divisible by " #c); \
+            }                                                                     \
+            MakeContextCurrent();                                                 \
+            gl->f##glname(idx, v->NativeCount() / c, ( ptrType *)v->NativePointer()); \
+        } else {                                                                  \
+            return ErrorMessage("Unhandled glTypeConst"); /* need compiler fail */\
+        }                                                                         \
+    }                                                                             \
+    return NS_OK;                                                                 \
+}
+
+#define GL_SIMPLE_ARRAY_METHOD_NO_COUNT(glname, name, c, glTypeConst, ptrType)    \
+NS_IMETHODIMP                                                                     \
+WebGLContext::name(GLuint idx, nsIWebGLArray *v)                                 \
+{                                                                                 \
+    NativeJSContext js;                                                           \
+    if (NS_FAILED(js.error))                                                      \
+        return js.error;                                                          \
+    JSObject *arrayObj;                                                           \
+    jsuint arrayLen;                                                              \
+    if (js.argc != 2)                                                             \
+        return NS_ERROR_INVALID_ARG;                                              \
+    if (NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[1], &arrayObj, &arrayLen)) { \
+        if (arrayLen % c != 0) {                                                  \
+            return ErrorMessage(#name ": array wrong size, expected " #c);        \
+        }                                                                         \
+        SimpleBuffer sbuffer(glTypeConst, c, js.ctx, arrayObj, arrayLen);         \
+        if (!sbuffer.Valid())                                                     \
+            return NS_ERROR_FAILURE;                                              \
+        MakeContextCurrent();                                                     \
+        gl->f##glname(idx, ( ptrType *)sbuffer.data);                             \
+    } else {                                                                      \
+        if (glTypeConst == LOCAL_GL_INT) {                                        \
+            if (v->NativeType() != LOCAL_GL_INT) {                                \
+                return ErrorMessage(#name ": arg not an array");                  \
+            }                                                                     \
+            if (v->NativeCount() % c != 0) {                                      \
+                return ErrorMessage(#name ": array wrong size %d, expected " #c, v->NativeCount()); \
+            }                                                                     \
+            MakeContextCurrent();                                                 \
+            gl->f##glname(idx, ( ptrType *)v->NativePointer());                   \
+        } else if (glTypeConst == LOCAL_GL_FLOAT) {                               \
+            if (v->NativeType() != LOCAL_GL_FLOAT) {                              \
+                return ErrorMessage(#name ": arg not an array");                  \
+            }                                                                     \
+            if (v->NativeCount() % c != 0) {                                      \
+                return ErrorMessage(#name ": array wrong size %d, expected " #c, v->NativeCount()); \
+            }                                                                     \
+            MakeContextCurrent();                                                 \
+            gl->f##glname(idx, ( ptrType *)v->NativePointer());                   \
+        } else {                                                                  \
+            return ErrorMessage("Unhandled glTypeConst"); /* need compiler fail */\
+        }                                                                         \
+    }                                                                             \
+    return NS_OK;                                                                 \
+}
+
+#define GL_SIMPLE_MATRIX_METHOD(glname, name, c, glTypeConst, ptrType)            \
+NS_IMETHODIMP                                                                     \
+WebGLContext::name(GLint location, GLboolean transpose, nsIWebGLArray *value)    \
+{                                                                                 \
+    NativeJSContext js;                                                           \
+    if (NS_FAILED(js.error))                                                      \
+        return js.error;                                                          \
+    JSObject *arrayObj;                                                           \
+    jsuint arrayLen;                                                              \
+    if (js.argc != 3)                                                             \
+        return NS_ERROR_INVALID_ARG;                                              \
+    if (NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[2], &arrayObj, &arrayLen)) { \
+        if (arrayLen % c != 0) {                                                  \
+            return ErrorMessage(#name ": array wrong size, expected " #c);        \
+        }                                                                         \
+        SimpleBuffer sbuffer(glTypeConst, c, js.ctx, arrayObj, arrayLen);         \
+        if (!sbuffer.Valid())                                                     \
+            return NS_ERROR_FAILURE;                                              \
+        MakeContextCurrent();                                                     \
+        gl->f##glname(location, arrayLen / c, transpose, ( ptrType *)sbuffer.data); \
+    } else {                                                                      \
+        if (glTypeConst == LOCAL_GL_FLOAT) {                                      \
+            if (value->NativeType() != LOCAL_GL_FLOAT) {                          \
+                return ErrorMessage(#name ": arg not an array");                  \
+            }                                                                     \
+            if (value->NativeCount() % c != 0) {                                  \
+                return ErrorMessage(#name ": array wrong size %d, expected " #c, value->NativeCount());     \
+            }                                                                     \
+            MakeContextCurrent();                                                 \
+            gl->f##glname(location, value->NativeCount() / c, transpose, ( ptrType *)value->NativePointer()); \
+        } else {                                                                  \
+            return ErrorMessage("Unhandled glTypeConst"); /* need compiler fail */\
+        }                                                                         \
+    }                                                                             \
+    return NS_OK;                                                                 \
+}
+
+GL_SIMPLE_ARRAY_METHOD(Uniform1iv, Uniform1iv, 1, LOCAL_GL_INT, GLint)
+GL_SIMPLE_ARRAY_METHOD(Uniform2iv, Uniform2iv, 2, LOCAL_GL_INT, GLint)
+GL_SIMPLE_ARRAY_METHOD(Uniform3iv, Uniform3iv, 3, LOCAL_GL_INT, GLint)
+GL_SIMPLE_ARRAY_METHOD(Uniform4iv, Uniform4iv, 4, LOCAL_GL_INT, GLint)
+
+GL_SIMPLE_ARRAY_METHOD(Uniform1fv, Uniform1fv, 1, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_ARRAY_METHOD(Uniform2fv, Uniform2fv, 2, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_ARRAY_METHOD(Uniform3fv, Uniform3fv, 3, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_ARRAY_METHOD(Uniform4fv, Uniform4fv, 4, LOCAL_GL_FLOAT, GLfloat)
+
+GL_SIMPLE_MATRIX_METHOD(UniformMatrix2fv, UniformMatrix2fv, 4, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_MATRIX_METHOD(UniformMatrix3fv, UniformMatrix3fv, 9, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_MATRIX_METHOD(UniformMatrix4fv, UniformMatrix4fv, 16, LOCAL_GL_FLOAT, GLfloat)
+
+NS_IMETHODIMP
+WebGLContext::UseProgram(nsIWebGLProgram *prog)
+{
+    if (prog && static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("glUseProgram: program has already been deleted!");
+
+    GLuint program = prog ? static_cast<WebGLProgram*>(prog)->GLName() : 0;
+
+    MakeContextCurrent();
+
+    gl->fUseProgram(program);
+
+    mCurrentProgram = static_cast<WebGLProgram*>(prog);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::ValidateProgram(nsIWebGLProgram *prog)
+{
+    if (!prog && static_cast<WebGLProgram*>(prog)->Deleted())
+        return ErrorMessage("glValidateProgram: program is null or has already been deleted!");
+
+    GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
+
+    MakeContextCurrent();
+
+    gl->fValidateProgram(program);
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_2(VertexAttrib1f, VertexAttrib1f, PRUint32, float)
+GL_SAME_METHOD_3(VertexAttrib2f, VertexAttrib2f, PRUint32, float, float)
+GL_SAME_METHOD_4(VertexAttrib3f, VertexAttrib3f, PRUint32, float, float, float)
+GL_SAME_METHOD_5(VertexAttrib4f, VertexAttrib4f, PRUint32, float, float, float, float)
+
+GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib1fv, VertexAttrib1fv, 1, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib2fv, VertexAttrib2fv, 2, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib3fv, VertexAttrib3fv, 3, LOCAL_GL_FLOAT, GLfloat)
+GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib4fv, VertexAttrib4fv, 4, LOCAL_GL_FLOAT, GLfloat)
+
+NS_IMETHODIMP
+WebGLContext::CreateFramebuffer(nsIWebGLFramebuffer **retval)
+{
+    MakeContextCurrent();
+
+    GLuint name;
+    gl->fGenFramebuffers(1, &name);
+
+    WebGLFramebuffer *globj = new WebGLFramebuffer(name);
+    if (globj) {
+        NS_ADDREF(*retval = globj);
+        mMapFramebuffers.Put(name, globj);
+    } else {
+        gl->fDeleteFramebuffers(1, &name);
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::CreateRenderbuffer(nsIWebGLRenderbuffer **retval)
+{
+    MakeContextCurrent();
+
+    GLuint name;
+    gl->fGenRenderbuffers(1, &name);
+
+    WebGLRenderbuffer *globj = new WebGLRenderbuffer(name);
+    if (globj) {
+        NS_ADDREF(*retval = globj);
+        mMapRenderbuffers.Put(name, globj);
+    } else {
+        gl->fDeleteRenderbuffers(1, &name);
+    }
+
+    return NS_OK;
+}
+
+GL_SAME_METHOD_4(Viewport, Viewport, PRInt32, PRInt32, PRInt32, PRInt32)
+
+NS_IMETHODIMP
+WebGLContext::CompileShader(nsIWebGLShader *shobj)
+{
+    if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
+    
+    MakeContextCurrent();
+
+    gl->fCompileShader(shader);
+
+    return NS_OK;
+}
+
+
+NS_IMETHODIMP
+WebGLContext::GetShaderi(nsIWebGLShader *shobj, GLenum pname, GLint *_retval)
+{
+    if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
+    
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_SHADER_TYPE:
+        case LOCAL_GL_DELETE_STATUS:
+        case LOCAL_GL_COMPILE_STATUS:
+        case LOCAL_GL_INFO_LOG_LENGTH:
+        case LOCAL_GL_SHADER_SOURCE_LENGTH:
+        {
+            PRInt32 iv = 0;
+            gl->fGetShaderiv(shader, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetShaderParameter(nsIWebGLShader *shobj, GLenum pname)
+{
+    if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
+    
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    MakeContextCurrent();
+
+    switch (pname) {
+        case LOCAL_GL_SHADER_TYPE:
+        case LOCAL_GL_DELETE_STATUS:
+        case LOCAL_GL_COMPILE_STATUS:
+        case LOCAL_GL_INFO_LOG_LENGTH:
+        case LOCAL_GL_SHADER_SOURCE_LENGTH:
+        {
+            PRInt32 iv = 0;
+            gl->fGetShaderiv(shader, pname, (GLint*) &iv);
+            js.SetRetVal(iv);
+        }
+            break;
+
+        default:
+            return NS_ERROR_NOT_IMPLEMENTED;
+    }
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetShaderInfoLog(nsIWebGLShader *shobj, nsAString& retval)
+{
+    if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();    
+
+    MakeContextCurrent();
+
+    PRInt32 k = -1;
+    gl->fGetShaderiv(shader, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
+    if (k == -1)
+        return NS_ERROR_FAILURE;
+
+    if (k == 0) {
+        retval.Truncate();
+        return NS_OK;
+    }
+
+    nsCAutoString log;
+    log.SetCapacity(k);
+
+    gl->fGetShaderInfoLog(shader, k, (GLint*) &k, (char*) log.BeginWriting());
+
+    log.SetLength(k);
+
+    CopyASCIItoUTF16(log, retval);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::GetShaderSource(nsIWebGLShader *shobj, nsAString& retval)
+{
+    if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
+    
+    MakeContextCurrent();
+
+    GLint slen = -1;
+    gl->fGetShaderiv (shader, LOCAL_GL_SHADER_SOURCE_LENGTH, &slen);
+    if (slen == -1)
+        return NS_ERROR_FAILURE;
+
+    if (slen == 0) {
+        retval.Truncate();
+        return NS_OK;
+    }
+
+    nsCAutoString src;
+    src.SetCapacity(slen);
+
+    gl->fGetShaderSource (shader, slen, NULL, (char*) src.BeginWriting());
+
+    src.SetLength(slen);
+
+    CopyASCIItoUTF16(src, retval);
+
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::ShaderSource(nsIWebGLShader *shobj, const nsAString& source)
+{
+    if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
+        return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
+
+    GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
+    
+    MakeContextCurrent();
+
+    NS_LossyConvertUTF16toASCII asciisrc(source);
+    const char *p = asciisrc.get();
+
+    gl->fShaderSource(shader, 1, &p, NULL);
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::VertexAttribPointer(GLuint index, GLint size, GLenum type,
+                                    GLboolean normalized, GLuint stride,
+                                    GLuint offset)
+{
+    if (mBoundArrayBuffer == nsnull)
+        return ErrorMessage("glvertexattribpointer: must have GL_ARRAY_BUFFER binding!");
+
+    if (index >= mAttribBuffers.Length())
+        return ErrorMessage("glVertexAttribPointer: index out of range - %d >= %d", index, mAttribBuffers.Length());
+
+    if (size < 1 || size > 4)
+        return ErrorMessage("glVertexAttribPointer: invalid element size");
+
+    /* XXX make work with bufferSubData & heterogeneous types 
+    if (type != mBoundArrayBuffer->GLType())
+        return ErrorMessage("glVertexAttribPointer: type must match bound VBO type: %d != %d", type, mBoundArrayBuffer->GLType());
+    */
+
+    // XXX 0 stride?
+    //if (stride < (GLuint) size)
+    //    return ErrorMessage("glVertexAttribPointer: stride must be >= size!");
+
+    WebGLVertexAttribData &vd = mAttribBuffers[index];
+
+    vd.buf = mBoundArrayBuffer;
+    vd.stride = stride;
+    vd.size = size;
+    vd.offset = offset;
+
+    MakeContextCurrent();
+
+    gl->fVertexAttribPointer(index, size, type, normalized,
+                             stride,
+                             (void*) (offset));
+
+    return NS_OK;
+}
+
+PRBool
+WebGLContext::ValidateGL()
+{
+    // make sure that the opengl stuff that we need is supported
+    GLint val = 0;
+
+    // XXX this exposes some strange latent bug; what's going on?
+    //MakeContextCurrent();
+
+    gl->fGetIntegerv(LOCAL_GL_MAX_VERTEX_ATTRIBS, &val);
+    if (val == 0) {
+        LogMessage("GL_MAX_VERTEX_ATTRIBS is 0!");
+        return PR_FALSE;
+    }
+
+    mAttribBuffers.SetLength(val);
+
+    //fprintf(stderr, "GL_MAX_VERTEX_ATTRIBS: %d\n", val);
+
+    gl->fGetIntegerv(LOCAL_GL_MAX_TEXTURE_UNITS, &val);
+    if (val == 0) {
+        LogMessage("GL_MAX_TEXTURE_UNITS is 0!");
+        return PR_FALSE;
+    }
+
+    mBound2DTextures.SetLength(val);
+    mBoundCubeMapTextures.SetLength(val);
+
+    //fprintf(stderr, "GL_MAX_TEXTURE_UNITS: %d\n", val);
+
+    gl->fGetIntegerv(LOCAL_GL_MAX_COLOR_ATTACHMENTS, &val);
+    mFramebufferColorAttachments.SetLength(val);
+
+#ifdef DEBUG_vladimir
+    gl->fGetIntegerv(LOCAL_GL_IMPLEMENTATION_COLOR_READ_FORMAT, &val);
+    fprintf(stderr, "GL_IMPLEMENTATION_COLOR_READ_FORMAT: 0x%04x\n", val);
+
+    gl->fGetIntegerv(LOCAL_GL_IMPLEMENTATION_COLOR_READ_TYPE, &val);
+    fprintf(stderr, "GL_IMPLEMENTATION_COLOR_READ_TYPE: 0x%04x\n", val);
+#endif
+
+#ifndef USE_GLES2
+    // gl_PointSize is always available in ES2 GLSL
+    gl->fEnable(LOCAL_GL_VERTEX_PROGRAM_POINT_SIZE);
+#endif
+
+    return PR_TRUE;
+}
+
+NS_IMETHODIMP
+WebGLContext::TexSubImage2D()
+{
+    // void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset,
+    //                    in GLsizei width, in GLsizei height,
+    //                    in GLenum format, in GLenum type, in CanvasArray pixels)
+    // void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
+    //                    in ImageData pixels,
+    //                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+    // void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
+    //                    in HTMLImageElement image,
+    //                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+    // void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
+    //                    in HTMLCanvasElement image,
+    //                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+    // void texSubImage2D(in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset,
+    //                    in HTMLVideoElement image,
+    //                    [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+
+    // XXX TODO
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 5 || js.argc > 9) {
+        return ErrorMessage("texSubImage2D: expected 5 to 9 arguments");
+        return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    if (js.argc < 8) {
+        jsuint argTarget, argLevel, argX, argY;
+        JSObject *argPixelsObj;
+        JSBool flipY = JS_FALSE;
+        JSBool premultiplyAlpha = JS_TRUE;
+
+        if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuuuo/bb",
+                                   &argTarget, &argLevel, &argX, &argY,
+                                   &argPixelsObj, &flipY, &premultiplyAlpha) ||
+            !argPixelsObj)
+            {
+                return ErrorMessage("texSubImage2D: argument error");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+        nsCOMPtr<nsIDOMHTMLElement> imgElt;
+        nsresult rv;
+        rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, argPixelsObj, NS_GET_IID(nsIDOMHTMLElement), getter_AddRefs(imgElt));
+
+        nsRefPtr<gfxImageSurface> isurf;
+
+        rv = TexImageElementBase(imgElt, getter_AddRefs(isurf), flipY, premultiplyAlpha);
+
+        if (NS_FAILED(rv))
+            return ErrorMessage("texImage2D: failed to get image for element");
+
+        MakeContextCurrent();
+
+        gl->fTexSubImage2D (argTarget, argLevel, argX, argY, isurf->Width(), isurf->Height(), LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, isurf->Data());
+    } else {
+        jsuint argTarget, argLevel, argX, argY, argWidth, argHeight, argFormat, argType;
+        JSObject *argPixelsObj;
+        if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuuuuuuuo",
+                                   &argTarget, &argLevel, &argX, &argY,
+                                   &argWidth, &argHeight, &argFormat, &argType,
+                                   &argPixelsObj) ||
+            !argPixelsObj)
+            {
+                return ErrorMessage("texSubImage2D: argument error");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+        switch (argTarget) {
+            case LOCAL_GL_TEXTURE_2D:
+            case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
+            case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+            case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
+            case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+            case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
+            case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
+                break;
+            default:
+                return ErrorMessage("texSubImage2D: unsupported target");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        PRUint32 bufferType, bufferSize;
+        switch (argFormat) {
+            case LOCAL_GL_RED:
+            case LOCAL_GL_GREEN:
+            case LOCAL_GL_BLUE:
+            case LOCAL_GL_ALPHA:
+            case LOCAL_GL_LUMINANCE:
+                bufferSize = 1;
+                break;
+            case LOCAL_GL_LUMINANCE_ALPHA:
+                bufferSize = 2;
+                break;
+            case LOCAL_GL_RGB:
+                bufferSize = 3;
+                break;
+            case LOCAL_GL_RGBA:
+                bufferSize = 4;
+                break;
+            default:
+                return ErrorMessage("texSubImage2D: pixel format not supported");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        switch (argType) {
+            case LOCAL_GL_SHORT:
+            case LOCAL_GL_UNSIGNED_SHORT:
+            case LOCAL_GL_BYTE:
+            case LOCAL_GL_UNSIGNED_BYTE:
+            case LOCAL_GL_INT:
+            case LOCAL_GL_UNSIGNED_INT:
+            case LOCAL_GL_FLOAT:
+                bufferType = argType;
+                break;
+            case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
+            case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
+            case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
+                bufferType = LOCAL_GL_UNSIGNED_SHORT;
+                break;
+            default:
+                return ErrorMessage("texSubImage2D: pixel packing not supported");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        // make sure the size is valid
+        PRInt32 tmp = argWidth * argHeight;
+        if (tmp && tmp / argHeight != argWidth) {
+            return ErrorMessage("texSubImage2D: too large width or height");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        tmp = tmp * bufferSize;
+        if (tmp && tmp / bufferSize != (argWidth * argHeight)) {
+            return ErrorMessage("texSubImage2D: too large width or height (after multiplying with pixel size)");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        nsCOMPtr<nsIWebGLArray> arrayObj;
+        nsresult rv;
+        rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, argPixelsObj, NS_GET_IID(nsISupports), getter_AddRefs(arrayObj));
+        arrayObj = do_QueryInterface(arrayObj, &rv);
+
+        if (NS_FAILED(rv) || !arrayObj) {
+            return ErrorMessage("texSubImage2D: pixels arg is not a WebGL array");
+        }
+
+        if ((PRUint32) tmp > arrayObj->NativeSize()) {
+            return ErrorMessage("texSubImage2D: array dimensions too small for width, height and pixel format");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        MakeContextCurrent();
+        gl->fTexSubImage2D (argTarget, argLevel, argX, argY, argWidth, argHeight, argFormat, argType, arrayObj->NativePointer());
+    }
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+WebGLContext::TexImage2D()
+{
+    // void texImage2D(in GLenum target, in GLint level, in GLenum internalformat,
+    //                 in GLsizei width, in GLsizei height, in GLint border, in GLenum format,
+    //                 in GLenum type, in CanvasArray pixels)
+    // void texImage2D(in GLenum target, in GLint level, in ImageData pixels,
+    //                 [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+    // void texImage2D(in GLenum target, in GLint level, in HTMLImageElement image,
+    //                 [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+    // void texImage2D(in GLenum target, in GLint level, in HTMLCanvasElement image,
+    //                 [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+    // void texImage2D(in GLenum target, in GLint level, in HTMLVideoElement image,
+    //                 [Optional] GLboolean flipY, [Optional] in asPremultipliedAlpha)
+
+    // XXX TODO
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc < 3 || js.argc > 9) {
+        return ErrorMessage("texImage2D: expected 3-5 or 9 arguments, got %d", js.argc);
+        return NS_ERROR_DOM_SYNTAX_ERR;
+    }
+
+    jsuint argTarget, argLevel, argInternalFormat, argWidth, argHeight, argBorder, argFormat, argType;
+
+    if (js.argc > 2 && js.argc < 6) {
+        JSObject *argPixelsObj;
+        JSBool flipY = JS_FALSE;
+        JSBool premultiplyAlpha = JS_TRUE;
+
+        if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuo/bb",
+                                   &argTarget, &argLevel,
+                                   &argPixelsObj, &flipY, &premultiplyAlpha) ||
+            !argPixelsObj)
+            {
+                return ErrorMessage("texImage2D: argument error");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+        nsCOMPtr<nsIDOMHTMLElement> imgElt;
+        nsresult rv;
+        rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, argPixelsObj, NS_GET_IID(nsIDOMHTMLElement), getter_AddRefs(imgElt));
+
+        nsRefPtr<gfxImageSurface> isurf;
+
+        rv = TexImageElementBase(imgElt, getter_AddRefs(isurf), flipY, premultiplyAlpha);
+
+        if (NS_FAILED(rv))
+            return ErrorMessage("texImage2D: failed to get image for element");
+
+        MakeContextCurrent();
+
+        gl->fTexImage2D (argTarget, argLevel, LOCAL_GL_RGBA, isurf->Width(), isurf->Height(), 0, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, isurf->Data());
+
+    } else if (js.argc == 9) {
+        JSObject *argPixelsObj;
+        if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuuuuuuuo",
+                                   &argTarget, &argLevel, &argInternalFormat, &argWidth,
+                                   &argHeight, &argBorder, &argFormat, &argType,
+                                   &argPixelsObj) ||
+            !argPixelsObj)
+            {
+                return ErrorMessage("texImage2D: argument error");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+        if (argWidth == 0 || argHeight == 0) {
+            return ErrorMessage("texImage2D: width or height is zero");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        switch (argTarget) {
+        case LOCAL_GL_TEXTURE_2D:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
+        case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
+            break;
+        default:
+            return ErrorMessage("texImage2D: unsupported target");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        if (argBorder != 0) {
+            return ErrorMessage("texImage2D: non-zero border given");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        switch (argInternalFormat) {
+        case LOCAL_GL_RGB:
+        case LOCAL_GL_RGBA:
+        case LOCAL_GL_ALPHA:
+        case LOCAL_GL_LUMINANCE:
+        case LOCAL_GL_LUMINANCE_ALPHA:
+            break;
+        default:
+            return ErrorMessage("texImage2D: internal format not supported");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        PRUint32 bufferType, bufferSize;
+        switch (argFormat) {
+        case LOCAL_GL_RED:
+        case LOCAL_GL_GREEN:
+        case LOCAL_GL_BLUE:
+        case LOCAL_GL_ALPHA:
+        case LOCAL_GL_LUMINANCE:
+            bufferSize = 1;
+            break;
+        case LOCAL_GL_LUMINANCE_ALPHA:
+            bufferSize = 2;
+            break;
+        case LOCAL_GL_RGB:
+            bufferSize = 3;
+            break;
+        case LOCAL_GL_RGBA:
+            bufferSize = 4;
+            break;
+        default:
+            return ErrorMessage("texImage2D: pixel format not supported");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        switch (argType) {
+        case LOCAL_GL_SHORT:
+        case LOCAL_GL_UNSIGNED_SHORT:
+        case LOCAL_GL_BYTE:
+        case LOCAL_GL_UNSIGNED_BYTE:
+        case LOCAL_GL_INT:
+        case LOCAL_GL_UNSIGNED_INT:
+        case LOCAL_GL_FLOAT:
+            bufferType = argType;
+            break;
+        case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
+        case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
+        case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
+            bufferType = LOCAL_GL_UNSIGNED_SHORT;
+            break;
+        default:
+            return ErrorMessage("texImage2D: pixel packing not supported");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        // make sure the size is valid
+        PRInt32 tmp = argWidth * argHeight;
+        if (tmp && tmp / argHeight != argWidth) {
+            return ErrorMessage("texImage2D: too large width or height");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        tmp = tmp * bufferSize;
+        if (tmp && tmp / bufferSize != (argWidth * argHeight)) {
+            return ErrorMessage("texImage2D: too large width or height (after multiplying with pixel size)");
+            return NS_ERROR_DOM_SYNTAX_ERR;
+        }
+
+        // XXX handle LOCAL_GL_UNPACK_ALIGNMENT !
+
+        if (argPixelsObj == NULL) {
+            MakeContextCurrent();
+            gl->fTexImage2D (argTarget, argLevel, argInternalFormat, argWidth, argHeight, argBorder, argFormat, argType, NULL);
+        } else {
+            nsCOMPtr<nsIWebGLArray> arrayObj;
+            nsresult rv;
+            rv = nsContentUtils::XPConnect()->WrapJS(js.ctx, argPixelsObj, NS_GET_IID(nsISupports), getter_AddRefs(arrayObj));
+            arrayObj = do_QueryInterface(arrayObj, &rv);
+
+            if (NS_FAILED(rv) || !arrayObj) {
+                return ErrorMessage("texImage2D: pixels arg is not a WebGL array");
+            }
+
+            if ((PRUint32) tmp > arrayObj->NativeSize()) {
+                return ErrorMessage("texImage2D: array dimensions too small for width, height and pixel format");
+                return NS_ERROR_DOM_SYNTAX_ERR;
+            }
+
+            MakeContextCurrent();
+            gl->fTexImage2D (argTarget, argLevel, argInternalFormat, argWidth, argHeight, argBorder, argFormat, argType, arrayObj->NativePointer());
+        }
+    }
+    return NS_OK;
+}
+
+#if 0
+// ImageData getImageData (in float x, in float y, in float width, in float height);
+NS_IMETHODIMP
+WebGLContext::GetImageData(PRUint32 x, PRUint32 y, PRUint32 w, PRUint32 h)
+{
+    // disabled due to win32 linkage issues with thebes symbols and NS_RELEASE
+    return NS_ERROR_FAILURE;
+
+#if 0
+    NativeJSContext js;
+    if (NS_FAILED(js.error))
+        return js.error;
+
+    if (js.argc != 4) return NS_ERROR_INVALID_ARG;
+    
+    if (!mGLPbuffer ||
+        !mGLPbuffer->ThebesSurface())
+        return NS_ERROR_FAILURE;
+
+    if (!mCanvasElement)
+        return NS_ERROR_FAILURE;
+
+    if (mCanvasElement->IsWriteOnly() && !IsCallerTrustedForRead()) {
+        // XXX ERRMSG we need to report an error to developers here! (bug 329026)
+        return NS_ERROR_DOM_SECURITY_ERR;
+    }
+
+    JSContext *ctx = js.ctx;
+
+    if (!CanvasUtils::CheckSaneSubrectSize (x, y, w, h, mWidth, mHeight))
+        return NS_ERROR_DOM_SYNTAX_ERR;
+
+    nsAutoArrayPtr<PRUint8> surfaceData (new (std::nothrow) PRUint8[w * h * 4]);
+    int surfaceDataStride = w*4;
+    int surfaceDataOffset = 0;
+
+    if (!surfaceData)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    nsRefPtr<gfxImageSurface> tmpsurf = new gfxImageSurface(surfaceData,
+                                                            gfxIntSize(w, h),
+                                                            w * 4,
+                                                            gfxASurface::ImageFormatARGB32);
+    if (!tmpsurf || tmpsurf->CairoStatus())
+        return NS_ERROR_FAILURE;
+
+    nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
+
+    if (!tmpctx || tmpctx->HasError())
+        return NS_ERROR_FAILURE;
+
+    nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
+    nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
+    gfxMatrix m;
+    m.Translate(gfxPoint(x, mGLPbuffer->Height()-y));
+    m.Scale(1.0, -1.0);
+    pat->SetMatrix(m);
+
+    // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
+    // pixel alignment for this stuff!
+    tmpctx->NewPath();
+    tmpctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, w, h), pat);
+    tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
+    tmpctx->Fill();
+
+    tmpctx = nsnull;
+    tmpsurf = nsnull;
+
+    PRUint32 len = w * h * 4;
+    if (len > (((PRUint32)0xfff00000)/sizeof(jsval)))
+        return NS_ERROR_INVALID_ARG;
+
+    nsAutoArrayPtr<jsval> jsvector(new (std::nothrow) jsval[w * h * 4]);
+    if (!jsvector)
+        return NS_ERROR_OUT_OF_MEMORY;
+    jsval *dest = jsvector.get();
+    PRUint8 *row;
+    for (PRUint32 j = 0; j < h; j++) {
+        row = surfaceData + surfaceDataOffset + (surfaceDataStride * j);
+        for (PRUint32 i = 0; i < w; i++) {
+            // XXX Is there some useful swizzle MMX we can use here?
+            // I guess we have to INT_TO_JSVAL still
+#ifdef IS_LITTLE_ENDIAN
+            PRUint8 b = *row++;
+            PRUint8 g = *row++;
+            PRUint8 r = *row++;
+            PRUint8 a = *row++;
+#else
+            PRUint8 a = *row++;
+            PRUint8 r = *row++;
+            PRUint8 g = *row++;
+            PRUint8 b = *row++;
+#endif
+            // Convert to non-premultiplied color
+            if (a != 0) {
+                r = (r * 255) / a;
+                g = (g * 255) / a;
+                b = (b * 255) / a;
+            }
+
+            *dest++ = INT_TO_JSVAL(r);
+            *dest++ = INT_TO_JSVAL(g);
+            *dest++ = INT_TO_JSVAL(b);
+            *dest++ = INT_TO_JSVAL(a);
+        }
+    }
+
+    JSObject *dataArray = JS_NewArrayObject(ctx, w*h*4, jsvector);
+    if (!dataArray)
+        return NS_ERROR_OUT_OF_MEMORY;
+
+    JSObjectHelper retobj(&js);
+    retobj.DefineProperty("width", w);
+    retobj.DefineProperty("height", h);
+    retobj.DefineProperty("data", dataArray);
+
+    js.SetRetVal(retobj);
+
+    return NS_OK;
+#endif
+}
+#endif
+
+PRBool
+BaseTypeAndSizeFromUniformType(GLenum uType, GLenum *baseType, GLint *unitSize)
+{
+        switch (uType) {
+        case LOCAL_GL_INT:
+        case LOCAL_GL_INT_VEC2:
+        case LOCAL_GL_INT_VEC3:
+        case LOCAL_GL_INT_VEC4:
+        case LOCAL_GL_SAMPLER_2D:
+        case LOCAL_GL_SAMPLER_CUBE:
+            *baseType = LOCAL_GL_INT;
+            break;
+        case LOCAL_GL_FLOAT:
+        case LOCAL_GL_FLOAT_VEC2:
+        case LOCAL_GL_FLOAT_VEC3:
+        case LOCAL_GL_FLOAT_VEC4:
+        case LOCAL_GL_FLOAT_MAT2:
+        case LOCAL_GL_FLOAT_MAT3:
+        case LOCAL_GL_FLOAT_MAT4:
+            *baseType = LOCAL_GL_FLOAT;
+            break;
+        case LOCAL_GL_BOOL:
+        case LOCAL_GL_BOOL_VEC2:
+        case LOCAL_GL_BOOL_VEC3:
+        case LOCAL_GL_BOOL_VEC4:
+            *baseType = LOCAL_GL_INT; // pretend these are int
+            break;
+        default:
+            return PR_FALSE;
+    }
+
+    switch (uType) {
+        case LOCAL_GL_INT:
+        case LOCAL_GL_FLOAT:
+        case LOCAL_GL_BOOL:
+        case LOCAL_GL_SAMPLER_2D:
+        case LOCAL_GL_SAMPLER_CUBE:
+            *unitSize = 1;
+            break;
+        case LOCAL_GL_INT_VEC2:
+        case LOCAL_GL_FLOAT_VEC2:
+        case LOCAL_GL_BOOL_VEC2:
+            *unitSize = 2;
+            break;
+        case LOCAL_GL_INT_VEC3:
+        case LOCAL_GL_FLOAT_VEC3:
+        case LOCAL_GL_BOOL_VEC3:
+            *unitSize = 3;
+            break;
+        case LOCAL_GL_INT_VEC4:
+        case LOCAL_GL_FLOAT_VEC4:
+        case LOCAL_GL_BOOL_VEC4:
+            *unitSize = 4;
+            break;
+        case LOCAL_GL_FLOAT_MAT2:
+            *unitSize = 4;
+            break;
+        case LOCAL_GL_FLOAT_MAT3:
+            *unitSize = 9;
+            break;
+        case LOCAL_GL_FLOAT_MAT4:
+            *unitSize = 16;
+            break;
+        default:
+            return PR_FALSE;
+    }
+
+    return PR_TRUE;
+}
diff -r 5b1fe1bf3872 content/canvas/src/WebGLContextNotSupported.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLContextNotSupported.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsICanvasRenderingContextWebGL.h"
+#include "WebGLArray.h"
+
+#define DUMMY(func,rtype)  nsresult func (rtype ** aResult) { return NS_ERROR_FAILURE; }
+
+DUMMY(NS_NewCanvasRenderingContextWebGL, nsICanvasRenderingContextWebGL)
+DUMMY(NS_NewWebGLFloatArray, nsISupports)
+DUMMY(NS_NewWebGLByteArray, nsISupports)
+DUMMY(NS_NewWebGLUnsignedByteArray, nsISupports)
+DUMMY(NS_NewWebGLShortArray, nsISupports)
+DUMMY(NS_NewWebGLUnsignedShortArray, nsISupports)
+DUMMY(NS_NewWebGLIntArray, nsISupports)
+DUMMY(NS_NewWebGLUnsignedIntArray, nsISupports)
+DUMMY(NS_NewWebGLArrayBuffer, nsISupports)
diff -r 5b1fe1bf3872 content/canvas/src/WebGLContextUtils.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLContextUtils.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,234 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *   Mark Steele <mwsteele@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "WebGLContext.h"
+
+#include "prprf.h"
+
+#include "nsIConsoleService.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsIPrefBranch.h"
+#include "nsServiceManagerUtils.h"
+#include "nsIPrefBranch.h"
+#include "nsIPrefService.h"
+#include "nsIVariant.h"
+
+#include "nsIDOMDocument.h"
+#include "nsIDOMDocumentEvent.h"
+#include "nsIDOMEvent.h"
+#include "nsIDOMEventTarget.h"
+#include "nsIPrivateDOMEvent.h"
+#include "nsIDOMDataContainerEvent.h"
+
+#include "nsContentUtils.h"
+
+#if 0
+#include "nsIContentURIGrouper.h"
+#include "nsIContentPrefService.h"
+#endif
+
+using namespace mozilla;
+
+PRBool
+WebGLContext::SafeToCreateCanvas3DContext(nsICanvasElement *canvasElement)
+{
+    nsresult rv;
+
+    // first see if we're a chrome context
+    PRBool is_caller_chrome = PR_FALSE;
+    nsCOMPtr<nsIScriptSecurityManager> ssm =
+        do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    rv = ssm->SubjectPrincipalIsSystem(&is_caller_chrome);
+    if (NS_SUCCEEDED(rv) && is_caller_chrome)
+        return PR_TRUE;
+
+    // not chrome? check pref.
+
+    // first check our global pref
+    nsCOMPtr<nsIPrefBranch> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    PRBool allSites = PR_FALSE;
+    rv = prefService->GetBoolPref("webgl.enabled_for_all_sites", &allSites);
+    if (NS_SUCCEEDED(rv) && allSites) {
+        // the all-sites pref was set, we're good to go
+        return PR_TRUE;
+    }
+
+#if 0
+    // otherwise we'll check content prefs
+    nsCOMPtr<nsIContentPrefService> cpsvc = do_GetService("@mozilla.org/content-pref/service;1", &rv);
+    if (NS_FAILED(rv)) {
+        LogMessage("Canvas 3D: Failed to get Content Pref service, can't verify that canvas3d is ok for this site!");
+        return PR_FALSE;
+    }
+
+    // grab our content URI
+    nsCOMPtr<nsIURI> contentURI;
+
+    nsCOMPtr<nsIPrincipal> principal;
+    rv = ssm->GetSubjectPrincipal(getter_AddRefs(principal));
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    if (!principal) {
+        // seriously? no script executing, but not the system principal?
+        return PR_FALSE;
+    }
+    rv = principal->GetURI(getter_AddRefs(contentURI));
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    // our pref is 'webgl.enabled'
+    nsCOMPtr<nsIVariant> val;
+    rv = cpsvc->GetPref(contentURI, NS_LITERAL_STRING("webgl.enabled"), getter_AddRefs(val));
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    PRInt32 iv;
+    rv = val->GetAsInt32(&iv);
+    if (NS_SUCCEEDED(rv)) {
+        // 1 means "yes, allowed"
+        if (iv == 1)
+            return PR_TRUE;
+
+        // -1 means "no, don't ask me again"
+        if (iv == -1)
+            return PR_FALSE;
+
+        // otherwise, we'll throw an event and maybe ask the user
+    }
+
+    // grab the document that we can use to create the event
+    nsCOMPtr<nsIDOMNode> node = do_QueryInterface(canvasElement);
+    nsCOMPtr<nsIDOMDocument> domDoc;
+    rv = node->GetOwnerDocument(getter_AddRefs(domDoc));
+
+    /*
+    // figure out where to throw the event.  we just go for the outermost
+    // document.  ideally, I want to throw the event to the <browser> if one exists,
+    // otherwise the topmost document, but that's more work than I want to deal with.
+    nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
+    while (doc->GetParentDocument())
+        doc = doc->GetParentDocument();
+    */
+
+    // set up the event
+    nsCOMPtr<nsIDOMDocumentEvent> docEvent = do_QueryInterface(domDoc);
+    NS_ENSURE_TRUE(docEvent, PR_FALSE);
+
+    nsCOMPtr<nsIDOMEvent> eventBase;
+    rv = docEvent->CreateEvent(NS_LITERAL_STRING("DataContainerEvent"), getter_AddRefs(eventBase));
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    rv = eventBase->InitEvent(NS_LITERAL_STRING("Canvas3DContextRequest"), PR_TRUE, PR_TRUE);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    nsCOMPtr<nsIDOMDataContainerEvent> event = do_QueryInterface(eventBase);
+    nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(eventBase);
+    NS_ENSURE_TRUE(event && privateEvent, PR_FALSE);
+
+    // mark it as trusted, so that it'll bubble upwards into chrome
+    privateEvent->SetTrusted(PR_TRUE);
+
+    // set some extra data on the event
+    nsCOMPtr<nsIContentURIGrouper> grouper = do_GetService("@mozilla.org/content-pref/hostname-grouper;1", &rv);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    nsAutoString group;
+    rv = grouper->Group(contentURI, group);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    nsCOMPtr<nsIWritableVariant> groupVariant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+    nsCOMPtr<nsIWritableVariant> uriVariant = do_CreateInstance(NS_VARIANT_CONTRACTID);
+
+    groupVariant->SetAsAString(group);
+    uriVariant->SetAsISupports(contentURI);
+
+    rv = event->SetData(NS_LITERAL_STRING("group"), groupVariant);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    rv = event->SetData(NS_LITERAL_STRING("uri"), uriVariant);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    // our target...
+    nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(canvasElement);
+
+    // and go.
+    PRBool defaultActionEnabled;
+    targ->DispatchEvent(event, &defaultActionEnabled);
+#endif
+
+    return PR_FALSE;
+}
+
+void
+WebGLContext::LogMessage(const char *fmt, ...)
+{
+  va_list ap;
+  va_start(ap, fmt);
+  char buf[256];
+
+  nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+  if (console) {
+    PR_vsnprintf(buf, 256, fmt, ap);
+    console->LogStringMessage(NS_ConvertUTF8toUTF16(nsDependentCString(buf)).get());
+    fprintf(stderr, "%s\n", buf);
+  }
+
+  va_end(ap);
+}
+
+nsresult
+WebGLContext::ErrorMessage(const char *fmt, ...)
+{
+  va_list ap;
+  va_start(ap, fmt);
+  char buf[256];
+
+  nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+  if (console) {
+    PR_vsnprintf(buf, 256, fmt, ap);
+    console->LogStringMessage(NS_ConvertUTF8toUTF16(nsDependentCString(buf)).get());
+    fprintf(stderr, "%s\n", buf);
+  }
+
+  va_end(ap);
+
+  return NS_ERROR_FAILURE;
+}
diff -r 5b1fe1bf3872 content/canvas/src/WebGLContextValidate.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/WebGLContextValidate.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *   Mark Steele <mwsteele@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "WebGLContext.h"
+
+using namespace mozilla;
+
+/*
+ * Verify that we can read count consecutive elements from each bound VBO.
+ */
+
+PRBool
+WebGLContext::ValidateBuffers(PRUint32 count)
+{
+    GLint len = 0;
+    GLint enabled = 0, size = 4, type = LOCAL_GL_FLOAT, binding = 0;
+    PRBool someEnabled = PR_FALSE;
+    GLint currentProgram = -1;
+    GLint numAttributes = -1;
+
+    MakeContextCurrent();
+
+    // XXX cache this per program
+    gl->fGetIntegerv(LOCAL_GL_CURRENT_PROGRAM, &currentProgram);
+    if (currentProgram == -1) {
+        // what?
+        LogMessage("glGetIntegerv GL_CURRENT_PROGRAM failed: 0x%08x", (uint) gl->fGetError());
+        return PR_FALSE;
+    }
+
+    gl->fGetProgramiv(currentProgram, LOCAL_GL_ACTIVE_ATTRIBUTES, &numAttributes);
+    if (numAttributes == -1) {
+        // what?
+        LogMessage("glGetProgramiv GL_ACTIVE_ATTRIBUTES failed: 0x%08x", (uint) gl->fGetError());
+        return PR_FALSE;
+    }
+
+    // is this valid?
+    if (numAttributes > (GLint) mAttribBuffers.Length()) {
+        // what?
+        LogMessage("GL_ACTIVE_ATTRIBUTES > GL_MAX_VERTEX_ATTRIBS");
+        return PR_FALSE;
+    }
+    PRUint32 maxAttribs = numAttributes;
+
+    for (PRUint32 i = 0; i < maxAttribs; ++i) {
+      WebGLVertexAttribData& vd = mAttribBuffers[i];
+
+      // is this a problem?
+      if (!vd.enabled)
+	continue;
+
+      if (vd.buf == nsnull) {
+	LogMessage("No VBO bound to index %d (or it's been deleted)!", i);
+	return PR_FALSE;
+      }
+
+      GLuint needed = vd.offset + (vd.stride ? vd.stride : vd.size) * count;
+      if (vd.buf->Count() < needed) {
+	LogMessage("VBO too small for bound attrib index %d: need at least %d elements, but have only %d", i, needed, vd.buf->Count());
+	return PR_FALSE;
+      }
+    }
+
+    return PR_TRUE;
+}
diff -r 5b1fe1bf3872 content/canvas/src/glwrap.cpp
--- a/content/canvas/src/glwrap.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/glwrap.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -1,3 +1,41 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *   Mark Steele <mwsteele@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
 #ifdef C3D_STANDALONE_BUILD
 #include "c3d-standalone.h"
 #endif
@@ -12,10 +50,6 @@
 #define MAX_SYMBOL_LENGTH 128
 #define MAX_SYMBOL_NAMES 5
 
-#ifdef MOZ_X11
-#include <GL/glx.h>
-#endif
-
 bool
 LibrarySymbolLoader::OpenLibrary(const char *library)
 {
@@ -166,7 +200,11 @@ GLES20Wrap::InitWithPrefix(const char *p
         { (PRFuncPtr*) &fBufferSubData, { "BufferSubData", NULL } },
         { (PRFuncPtr*) &fClear, { "Clear", NULL } },
         { (PRFuncPtr*) &fClearColor, { "ClearColor", NULL } },
+#ifdef USE_GLES2
+        { (PRFuncPtr*) &fClearDepthf, { "ClearDepthf", NULL } },
+#else
         { (PRFuncPtr*) &fClearDepth, { "ClearDepth", NULL } },
+#endif
         { (PRFuncPtr*) &fClearStencil, { "ClearStencil", NULL } },
         { (PRFuncPtr*) &fColorMask, { "ColorMask", NULL } },
         { (PRFuncPtr*) &fCreateProgram, { "CreateProgram", "CreateProgramARB", NULL } },
@@ -179,7 +217,11 @@ GLES20Wrap::InitWithPrefix(const char *p
         { (PRFuncPtr*) &fDetachShader, { "DetachShader", "DetachShaderARB", NULL } },
         { (PRFuncPtr*) &fDepthFunc, { "DepthFunc", NULL } },
         { (PRFuncPtr*) &fDepthMask, { "DepthMask", NULL } },
+#ifdef USE_GLES2
+        { (PRFuncPtr*) &fDepthRangef, { "DepthRangef", NULL } },
+#else
         { (PRFuncPtr*) &fDepthRange, { "DepthRange", NULL } },
+#endif
         { (PRFuncPtr*) &fDisable, { "Disable", NULL } },
         { (PRFuncPtr*) &fDisableVertexAttribArray, { "DisableVertexAttribArray", "DisableVertexAttribArrayARB", NULL } },
         { (PRFuncPtr*) &fDrawArrays, { "DrawArrays", NULL } },
@@ -194,7 +236,6 @@ GLES20Wrap::InitWithPrefix(const char *p
         { (PRFuncPtr*) &fGetAttachedShaders, { "GetAttachedShaders", "GetAttachedShadersARB", NULL } },
         { (PRFuncPtr*) &fGetAttribLocation, { "GetAttribLocation", "GetAttribLocationARB", NULL } },
         { (PRFuncPtr*) &fGetIntegerv, { "GetIntegerv", NULL } },
-        { (PRFuncPtr*) &fGetDoublev, { "GetDoublev", NULL } },
         { (PRFuncPtr*) &fGetFloatv, { "GetFloatv", NULL } },
         { (PRFuncPtr*) &fGetBooleanv, { "GetBooleanv", NULL } },
         { (PRFuncPtr*) &fGetBufferParameteriv, { "GetBufferParameteriv", "GetBufferParameterivARB", NULL } },
@@ -205,11 +246,11 @@ GLES20Wrap::InitWithPrefix(const char *p
         { (PRFuncPtr*) &fGetProgramInfoLog, { "GetProgramInfoLog", "GetProgramInfoLogARB", NULL } },
         { (PRFuncPtr*) &fTexParameteri, { "TexParameteri", NULL } },
         { (PRFuncPtr*) &fTexParameterf, { "TexParameterf", NULL } },
+        { (PRFuncPtr*) &fGetTexParameterfv, { "GetTexParameterfv", NULL } },
         { (PRFuncPtr*) &fGetTexParameteriv, { "GetTexParameteriv", NULL } },
         { (PRFuncPtr*) &fGetUniformfv, { "GetUniformfv", "GetUniformfvARB", NULL } },
         { (PRFuncPtr*) &fGetUniformiv, { "GetUniformiv", "GetUniformivARB", NULL } },
         { (PRFuncPtr*) &fGetUniformLocation, { "GetUniformLocation", "GetUniformLocationARB", NULL } },
-        { (PRFuncPtr*) &fGetVertexAttribdv, { "GetVertexAttribdv", "GetVertexAttribdvARB", NULL } },
         { (PRFuncPtr*) &fGetVertexAttribfv, { "GetVertexAttribfv", "GetVertexAttribfvARB", NULL } },
         { (PRFuncPtr*) &fGetVertexAttribiv, { "GetVertexAttribiv", "GetVertexAttribivARB", NULL } },
         { (PRFuncPtr*) &fHint, { "Hint", NULL } },
@@ -287,6 +328,10 @@ GLES20Wrap::InitWithPrefix(const char *p
         { (PRFuncPtr*) &fIsFramebuffer, { "IsFramebuffer", "IsFramebufferEXT", NULL } },
         { (PRFuncPtr*) &fIsRenderbuffer, { "IsRenderbuffer", "IsRenderbufferEXT", NULL } },
         { (PRFuncPtr*) &fRenderbufferStorage, { "RenderbufferStorage", "RenderbufferStorageEXT", NULL } },
+#if 0
+	{ (PRFuncPtr*) &fMapBuffer, { "MapBuffer", NULL } },
+	{ (PRFuncPtr*) &fUnmapBuffer, { "UnmapBuffer", NULL } },
+#endif
 
         { NULL, { NULL } },
 
diff -r 5b1fe1bf3872 content/canvas/src/glwrap.h
--- a/content/canvas/src/glwrap.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/glwrap.h	Fri Dec 11 07:09:00 2009 +0200
@@ -1,3 +1,40 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *   Mark Steele <mwsteele@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
 
 #ifndef GLWRAP_H_
 #define GLWRAP_H_
@@ -19,6 +56,8 @@
 #define GLAPI
 #endif
 
+typedef char realGLboolean;
+
 class LibrarySymbolLoader
 {
 public:
@@ -70,7 +109,7 @@ protected:
 public:
     typedef PrivateOSMesaContext (GLAPIENTRY * PFNOSMESACREATECONTEXTEXT) (GLenum, GLint, GLint, GLint, PrivateOSMesaContext);
     typedef void (GLAPIENTRY * PFNOSMESADESTROYCONTEXT) (PrivateOSMesaContext);
-    typedef GLboolean (GLAPIENTRY * PFNOSMESAMAKECURRENT) (PrivateOSMesaContext, void *, GLenum, GLsizei, GLsizei);
+    typedef bool (GLAPIENTRY * PFNOSMESAMAKECURRENT) (PrivateOSMesaContext, void *, GLenum, GLsizei, GLsizei);
     typedef PrivateOSMesaContext (GLAPIENTRY * PFNOSMESAGETCURRENTCONTEXT) (void);
     typedef void (GLAPIENTRY * PFNOSMESAPIXELSTORE) (GLint, GLint);
     typedef PRFuncPtr (GLAPIENTRY * PFNOSMESAGETPROCADDRESS) (const char*);
@@ -140,11 +179,16 @@ public:
     PFNGLCLEARPROC fClear;
     typedef void (GLAPIENTRY * PFNGLCLEARCOLORPROC) (GLclampf, GLclampf, GLclampf, GLclampf);
     PFNGLCLEARCOLORPROC fClearColor;
+#ifdef USE_GLES2
+    typedef void (GLAPIENTRY * PFNGLCLEARDEPTHFPROC) (GLclampf);
+    PFNGLCLEARDEPTHFPROC fClearDepthf;
+#else
     typedef void (GLAPIENTRY * PFNGLCLEARDEPTHPROC) (GLclampd);
     PFNGLCLEARDEPTHPROC fClearDepth;
+#endif
     typedef void (GLAPIENTRY * PFNGLCLEARSTENCILPROC) (GLint);
     PFNGLCLEARSTENCILPROC fClearStencil;
-    typedef void (GLAPIENTRY * PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+    typedef void (GLAPIENTRY * PFNGLCOLORMASKPROC) (realGLboolean red, realGLboolean green, realGLboolean blue, realGLboolean alpha);
     PFNGLCOLORMASKPROC fColorMask;
     typedef GLuint (GLAPIENTRY * PFNGLCREATEPROGRAMPROC) (void);
     PFNGLCREATEPROGRAMPROC fCreateProgram;
@@ -164,10 +208,15 @@ public:
     PFNGLDETACHSHADERPROC fDetachShader;
     typedef void (GLAPIENTRY * PFNGLDEPTHFUNCPROC) (GLenum);
     PFNGLDEPTHFUNCPROC fDepthFunc;
-    typedef void (GLAPIENTRY * PFNGLDEPTHMASKPROC) (GLboolean);
+    typedef void (GLAPIENTRY * PFNGLDEPTHMASKPROC) (realGLboolean);
     PFNGLDEPTHMASKPROC fDepthMask;
+#ifdef USE_GLES2
+    typedef void (GLAPIENTRY * PFNGLDEPTHRANGEFPROC) (GLclampf, GLclampf);
+    PFNGLDEPTHRANGEFPROC fDepthRangef;
+#else
     typedef void (GLAPIENTRY * PFNGLDEPTHRANGEPROC) (GLclampd, GLclampd);
     PFNGLDEPTHRANGEPROC fDepthRange;
+#endif
     typedef void (GLAPIENTRY * PFNGLDISABLEPROC) (GLenum);
     PFNGLDISABLEPROC fDisable;
     typedef void (GLAPIENTRY * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint);
@@ -196,11 +245,9 @@ public:
     PFNGLGETATTRIBLOCATIONPROC fGetAttribLocation;
     typedef void (GLAPIENTRY * PFNGLGETINTEGERVPROC) (GLenum pname, GLint *params);
     PFNGLGETINTEGERVPROC fGetIntegerv;
-    typedef void (GLAPIENTRY * PFNGLGETDOUBLEVPROC) (GLenum pname, GLdouble *params);
-    PFNGLGETDOUBLEVPROC fGetDoublev;
     typedef void (GLAPIENTRY * PFNGLGETFLOATVPROC) (GLenum pname, GLfloat *params);
     PFNGLGETFLOATVPROC fGetFloatv;
-    typedef void (GLAPIENTRY * PFNGLGETBOOLEANBPROC) (GLenum pname, GLboolean *params);
+    typedef void (GLAPIENTRY * PFNGLGETBOOLEANBPROC) (GLenum pname, realGLboolean *params);
     PFNGLGETBOOLEANBPROC fGetBooleanv;
     typedef void (GLAPIENTRY * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
     PFNGLGETBUFFERPARAMETERIVPROC fGetBufferParameteriv;
@@ -220,43 +267,49 @@ public:
     PFNGLTEXPARAMETERIPROC fTexParameteri;
     typedef void (GLAPIENTRY * PFNGLTEXPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat param);
     PFNGLTEXPARAMETERFPROC fTexParameterf;
-    typedef void (GLAPIENTRY * PFNGLTEXPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
-    PFNGLTEXPARAMETERIVPROC fGetTexParameteriv;
+    typedef void (GLAPIENTRY * PFNGLGETTEXPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
+    PFNGLGETTEXPARAMETERFVPROC fGetTexParameterfv;
+    typedef void (GLAPIENTRY * PFNGLGETTEXPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
+    PFNGLGETTEXPARAMETERIVPROC fGetTexParameteriv;
     typedef void (GLAPIENTRY * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
     PFNGLGETUNIFORMFVPROC fGetUniformfv;
     typedef void (GLAPIENTRY * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
     PFNGLGETUNIFORMIVPROC fGetUniformiv;
     typedef GLint (GLAPIENTRY * PFNGLGETUNIFORMLOCATIONPROC) (GLint programObj, const GLchar* name);
     PFNGLGETUNIFORMLOCATIONPROC fGetUniformLocation;
-    typedef void (GLAPIENTRY * PFNGLGETVERTEXATTRIBDVPROC) (GLuint, GLenum, GLdouble*);
-    PFNGLGETVERTEXATTRIBDVPROC fGetVertexAttribdv;
     typedef void (GLAPIENTRY * PFNGLGETVERTEXATTRIBFVPROC) (GLuint, GLenum, GLfloat*);
     PFNGLGETVERTEXATTRIBFVPROC fGetVertexAttribfv;
     typedef void (GLAPIENTRY * PFNGLGETVERTEXATTRIBIVPROC) (GLuint, GLenum, GLint*);
     PFNGLGETVERTEXATTRIBIVPROC fGetVertexAttribiv;
     typedef void (GLAPIENTRY * PFNGLHINTPROC) (GLenum target, GLenum mode);
     PFNGLHINTPROC fHint;
-    typedef GLboolean (GLAPIENTRY * PFNGLISBUFFERPROC) (GLuint buffer);
+    typedef realGLboolean (GLAPIENTRY * PFNGLISBUFFERPROC) (GLuint buffer);
     PFNGLISBUFFERPROC fIsBuffer;
-    typedef GLboolean (GLAPIENTRY * PFNGLISENABLEDPROC) (GLenum cap);
+    typedef realGLboolean (GLAPIENTRY * PFNGLISENABLEDPROC) (GLenum cap);
     PFNGLISENABLEDPROC fIsEnabled;
-    typedef GLboolean (GLAPIENTRY * PFNGLISPROGRAMPROC) (GLuint program);
+    typedef realGLboolean (GLAPIENTRY * PFNGLISPROGRAMPROC) (GLuint program);
     PFNGLISPROGRAMPROC fIsProgram;
-    typedef GLboolean (GLAPIENTRY * PFNGLISSHADERPROC) (GLuint shader);
+    typedef realGLboolean (GLAPIENTRY * PFNGLISSHADERPROC) (GLuint shader);
     PFNGLISSHADERPROC fIsShader;
-    typedef GLboolean (GLAPIENTRY * PFNGLISTEXTUREPROC) (GLuint texture);
+    typedef realGLboolean (GLAPIENTRY * PFNGLISTEXTUREPROC) (GLuint texture);
     PFNGLISTEXTUREPROC fIsTexture;
     typedef void (GLAPIENTRY * PFNGLLINEWIDTHPROC) (GLfloat width);
     PFNGLLINEWIDTHPROC fLineWidth;
     typedef void (GLAPIENTRY * PFNGLLINKPROGRAMPROC) (GLuint program);
     PFNGLLINKPROGRAMPROC fLinkProgram;
+#if 0
+    typedef void * (GLAPIENTRY * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
+    PFNGLMAPBUFFERPROC fMapBuffer;
+    typedef realGLboolean (GLAPIENTRY * PFNGLUNAMPBUFFERPROC) (GLenum target);
+    PFNGLUNAMPBUFFERPROC fUnmapBuffer;
+#endif
     typedef void (GLAPIENTRY * PFNGLPIXELSTOREIPROC) (GLenum pname, GLint param);
     PFNGLPIXELSTOREIPROC fPixelStorei;
     typedef void (GLAPIENTRY * PFNGLPOLYGONOFFSETPROC) (GLfloat factor, GLfloat bias);
     PFNGLPOLYGONOFFSETPROC fPolygonOffset;
     typedef void (GLAPIENTRY * PFNGLREADPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
     PFNGLREADPIXELSPROC fReadPixels;
-    typedef void (GLAPIENTRY * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
+    typedef void (GLAPIENTRY * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, realGLboolean invert);
     PFNGLSAMPLECOVERAGEPROC fSampleCoverage;
     typedef void (GLAPIENTRY * PFNGLSCISSORPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
     PFNGLSCISSORPROC fScissor;
@@ -308,17 +361,17 @@ public:
     PFNGLUNIFORM4IPROC fUniform4i;
     typedef void (GLAPIENTRY * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
     PFNGLUNIFORM4IVPROC fUniform4iv;
-    typedef void (GLAPIENTRY * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+    typedef void (GLAPIENTRY * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, realGLboolean transpose, const GLfloat* value);
     PFNGLUNIFORMMATRIX2FVPROC fUniformMatrix2fv;
-    typedef void (GLAPIENTRY * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+    typedef void (GLAPIENTRY * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, realGLboolean transpose, const GLfloat* value);
     PFNGLUNIFORMMATRIX3FVPROC fUniformMatrix3fv;
-    typedef void (GLAPIENTRY * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
+    typedef void (GLAPIENTRY * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, realGLboolean transpose, const GLfloat* value);
     PFNGLUNIFORMMATRIX4FVPROC fUniformMatrix4fv;
     typedef void (GLAPIENTRY * PFNGLUSEPROGRAMPROC) (GLuint program);
     PFNGLUSEPROGRAMPROC fUseProgram;
     typedef void (GLAPIENTRY * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
     PFNGLVALIDATEPROGRAMPROC fValidateProgram;
-    typedef void (GLAPIENTRY * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer);
+    typedef void (GLAPIENTRY * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, realGLboolean normalized, GLsizei stride, const GLvoid* pointer);
     PFNGLVERTEXATTRIBPOINTERPROC fVertexAttribPointer;
     typedef void (GLAPIENTRY * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
     PFNGLVERTEXATTRIB1FPROC fVertexAttrib1f;
@@ -375,9 +428,9 @@ public:
     PFNGLGENFRAMEBUFFERS fGenFramebuffers;
     typedef void (GLAPIENTRY * PFNGLGENRENDERBUFFERS) (GLsizei n, GLuint* ids);
     PFNGLGENRENDERBUFFERS fGenRenderbuffers;
-    typedef GLboolean (GLAPIENTRY * PFNGLISFRAMEBUFFER) (GLuint framebuffer);
+    typedef realGLboolean (GLAPIENTRY * PFNGLISFRAMEBUFFER) (GLuint framebuffer);
     PFNGLISFRAMEBUFFER fIsFramebuffer;
-    typedef GLboolean (GLAPIENTRY * PFNGLISRENDERBUFFER) (GLuint renderbuffer);
+    typedef realGLboolean (GLAPIENTRY * PFNGLISRENDERBUFFER) (GLuint renderbuffer);
     PFNGLISRENDERBUFFER fIsRenderbuffer;
     typedef void (GLAPIENTRY * PFNGLRENDERBUFFERSTORAGE) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height);
     PFNGLRENDERBUFFERSTORAGE fRenderbufferStorage;
diff -r 5b1fe1bf3872 content/canvas/src/localgl.h
--- a/content/canvas/src/localgl.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/localgl.h	Fri Dec 11 07:09:00 2009 +0200
@@ -1,10 +1,47 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *   Mark Steele <mwsteele@gmail.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
 
 #if !defined(LOCALGL_H_) && !defined(__gl_h_)
 
 #define LOCALGL_H_
 #define __gl_h_
 
-#if defined(__APPLE__)
+#if defined(__APPLE__XXX)
 typedef unsigned long GLenum;
 typedef unsigned long GLbitfield;
 typedef unsigned long GLuint;
@@ -17,7 +54,7 @@ typedef unsigned int GLuint;
 typedef int GLint;
 typedef int GLsizei;
 #endif
-typedef unsigned char GLboolean;
+typedef char realGLboolean;
 typedef signed char GLbyte;
 typedef short GLshort;
 typedef unsigned char GLubyte;
@@ -29,8 +66,8 @@ typedef double GLclampd;
 typedef void GLvoid;
 
 typedef char GLchar;
-typedef ptrdiff_t GLsizeiptr;
-typedef ptrdiff_t GLintptr;
+typedef PRInt32 GLsizeiptr;
+typedef PRInt32 GLintptr;
 
 #ifndef GLAPIENTRY
 # ifdef WIN32
@@ -42,2949 +79,2954 @@ typedef ptrdiff_t GLintptr;
 # endif
 #endif
 
-#define GL_VERSION_1_1 1
-#define GL_ACCUM 0x0100
-#define GL_LOAD 0x0101
-#define GL_RETURN 0x0102
-#define GL_MULT 0x0103
-#define GL_ADD 0x0104
-#define GL_NEVER 0x0200
-#define GL_LESS 0x0201
-#define GL_EQUAL 0x0202
-#define GL_LEQUAL 0x0203
-#define GL_GREATER 0x0204
-#define GL_NOTEQUAL 0x0205
-#define GL_GEQUAL 0x0206
-#define GL_ALWAYS 0x0207
-#define GL_CURRENT_BIT 0x00000001
-#define GL_POINT_BIT 0x00000002
-#define GL_LINE_BIT 0x00000004
-#define GL_POLYGON_BIT 0x00000008
-#define GL_POLYGON_STIPPLE_BIT 0x00000010
-#define GL_PIXEL_MODE_BIT 0x00000020
-#define GL_LIGHTING_BIT 0x00000040
-#define GL_FOG_BIT 0x00000080
-#define GL_DEPTH_BUFFER_BIT 0x00000100
-#define GL_ACCUM_BUFFER_BIT 0x00000200
-#define GL_STENCIL_BUFFER_BIT 0x00000400
-#define GL_VIEWPORT_BIT 0x00000800
-#define GL_TRANSFORM_BIT 0x00001000
-#define GL_ENABLE_BIT 0x00002000
-#define GL_COLOR_BUFFER_BIT 0x00004000
-#define GL_HINT_BIT 0x00008000
-#define GL_EVAL_BIT 0x00010000
-#define GL_LIST_BIT 0x00020000
-#define GL_TEXTURE_BIT 0x00040000
-#define GL_SCISSOR_BIT 0x00080000
-#define GL_ALL_ATTRIB_BITS 0x000fffff
-#define GL_POINTS 0x0000
-#define GL_LINES 0x0001
-#define GL_LINE_LOOP 0x0002
-#define GL_LINE_STRIP 0x0003
-#define GL_TRIANGLES 0x0004
-#define GL_TRIANGLE_STRIP 0x0005
-#define GL_TRIANGLE_FAN 0x0006
-#define GL_QUADS 0x0007
-#define GL_QUAD_STRIP 0x0008
-#define GL_POLYGON 0x0009
-#define GL_ZERO 0
-#define GL_ONE 1
-#define GL_SRC_COLOR 0x0300
-#define GL_ONE_MINUS_SRC_COLOR 0x0301
-#define GL_SRC_ALPHA 0x0302
-#define GL_ONE_MINUS_SRC_ALPHA 0x0303
-#define GL_DST_ALPHA 0x0304
-#define GL_ONE_MINUS_DST_ALPHA 0x0305
-#define GL_DST_COLOR 0x0306
-#define GL_ONE_MINUS_DST_COLOR 0x0307
-#define GL_SRC_ALPHA_SATURATE 0x0308
-#define GL_TRUE 1
-#define GL_FALSE 0
-#define GL_CLIP_PLANE0 0x3000
-#define GL_CLIP_PLANE1 0x3001
-#define GL_CLIP_PLANE2 0x3002
-#define GL_CLIP_PLANE3 0x3003
-#define GL_CLIP_PLANE4 0x3004
-#define GL_CLIP_PLANE5 0x3005
-#define GL_BYTE 0x1400
-#define GL_UNSIGNED_BYTE 0x1401
-#define GL_SHORT 0x1402
-#define GL_UNSIGNED_SHORT 0x1403
-#define GL_INT 0x1404
-#define GL_UNSIGNED_INT 0x1405
-#define GL_FLOAT 0x1406
-#define GL_2_BYTES 0x1407
-#define GL_3_BYTES 0x1408
-#define GL_4_BYTES 0x1409
-#define GL_DOUBLE 0x140A
-#define GL_NONE 0
-#define GL_FRONT_LEFT 0x0400
-#define GL_FRONT_RIGHT 0x0401
-#define GL_BACK_LEFT 0x0402
-#define GL_BACK_RIGHT 0x0403
-#define GL_FRONT 0x0404
-#define GL_BACK 0x0405
-#define GL_LEFT 0x0406
-#define GL_RIGHT 0x0407
-#define GL_FRONT_AND_BACK 0x0408
-#define GL_AUX0 0x0409
-#define GL_AUX1 0x040A
-#define GL_AUX2 0x040B
-#define GL_AUX3 0x040C
-#define GL_NO_ERROR 0
-#define GL_INVALID_ENUM 0x0500
-#define GL_INVALID_VALUE 0x0501
-#define GL_INVALID_OPERATION 0x0502
-#define GL_STACK_OVERFLOW 0x0503
-#define GL_STACK_UNDERFLOW 0x0504
-#define GL_OUT_OF_MEMORY 0x0505
-#define GL_2D 0x0600
-#define GL_3D 0x0601
-#define GL_3D_COLOR 0x0602
-#define GL_3D_COLOR_TEXTURE 0x0603
-#define GL_4D_COLOR_TEXTURE 0x0604
-#define GL_PASS_THROUGH_TOKEN 0x0700
-#define GL_POINT_TOKEN 0x0701
-#define GL_LINE_TOKEN 0x0702
-#define GL_POLYGON_TOKEN 0x0703
-#define GL_BITMAP_TOKEN 0x0704
-#define GL_DRAW_PIXEL_TOKEN 0x0705
-#define GL_COPY_PIXEL_TOKEN 0x0706
-#define GL_LINE_RESET_TOKEN 0x0707
-#define GL_EXP 0x0800
-#define GL_EXP2 0x0801
-#define GL_CW 0x0900
-#define GL_CCW 0x0901
-#define GL_COEFF 0x0A00
-#define GL_ORDER 0x0A01
-#define GL_DOMAIN 0x0A02
-#define GL_CURRENT_COLOR 0x0B00
-#define GL_CURRENT_INDEX 0x0B01
-#define GL_CURRENT_NORMAL 0x0B02
-#define GL_CURRENT_TEXTURE_COORDS 0x0B03
-#define GL_CURRENT_RASTER_COLOR 0x0B04
-#define GL_CURRENT_RASTER_INDEX 0x0B05
-#define GL_CURRENT_RASTER_TEXTURE_COORDS 0x0B06
-#define GL_CURRENT_RASTER_POSITION 0x0B07
-#define GL_CURRENT_RASTER_POSITION_VALID 0x0B08
-#define GL_CURRENT_RASTER_DISTANCE 0x0B09
-#define GL_POINT_SMOOTH 0x0B10
-#define GL_POINT_SIZE 0x0B11
-#define GL_POINT_SIZE_RANGE 0x0B12
-#define GL_POINT_SIZE_GRANULARITY 0x0B13
-#define GL_LINE_SMOOTH 0x0B20
-#define GL_LINE_WIDTH 0x0B21
-#define GL_LINE_WIDTH_RANGE 0x0B22
-#define GL_LINE_WIDTH_GRANULARITY 0x0B23
-#define GL_LINE_STIPPLE 0x0B24
-#define GL_LINE_STIPPLE_PATTERN 0x0B25
-#define GL_LINE_STIPPLE_REPEAT 0x0B26
-#define GL_LIST_MODE 0x0B30
-#define GL_MAX_LIST_NESTING 0x0B31
-#define GL_LIST_BASE 0x0B32
-#define GL_LIST_INDEX 0x0B33
-#define GL_POLYGON_MODE 0x0B40
-#define GL_POLYGON_SMOOTH 0x0B41
-#define GL_POLYGON_STIPPLE 0x0B42
-#define GL_EDGE_FLAG 0x0B43
-#define GL_CULL_FACE 0x0B44
-#define GL_CULL_FACE_MODE 0x0B45
-#define GL_FRONT_FACE 0x0B46
-#define GL_LIGHTING 0x0B50
-#define GL_LIGHT_MODEL_LOCAL_VIEWER 0x0B51
-#define GL_LIGHT_MODEL_TWO_SIDE 0x0B52
-#define GL_LIGHT_MODEL_AMBIENT 0x0B53
-#define GL_SHADE_MODEL 0x0B54
-#define GL_COLOR_MATERIAL_FACE 0x0B55
-#define GL_COLOR_MATERIAL_PARAMETER 0x0B56
-#define GL_COLOR_MATERIAL 0x0B57
-#define GL_FOG 0x0B60
-#define GL_FOG_INDEX 0x0B61
-#define GL_FOG_DENSITY 0x0B62
-#define GL_FOG_START 0x0B63
-#define GL_FOG_END 0x0B64
-#define GL_FOG_MODE 0x0B65
-#define GL_FOG_COLOR 0x0B66
-#define GL_DEPTH_RANGE 0x0B70
-#define GL_DEPTH_TEST 0x0B71
-#define GL_DEPTH_WRITEMASK 0x0B72
-#define GL_DEPTH_CLEAR_VALUE 0x0B73
-#define GL_DEPTH_FUNC 0x0B74
-#define GL_ACCUM_CLEAR_VALUE 0x0B80
-#define GL_STENCIL_TEST 0x0B90
-#define GL_STENCIL_CLEAR_VALUE 0x0B91
-#define GL_STENCIL_FUNC 0x0B92
-#define GL_STENCIL_VALUE_MASK 0x0B93
-#define GL_STENCIL_FAIL 0x0B94
-#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
-#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
-#define GL_STENCIL_REF 0x0B97
-#define GL_STENCIL_WRITEMASK 0x0B98
-#define GL_MATRIX_MODE 0x0BA0
-#define GL_NORMALIZE 0x0BA1
-#define GL_VIEWPORT 0x0BA2
-#define GL_MODELVIEW_STACK_DEPTH 0x0BA3
-#define GL_PROJECTION_STACK_DEPTH 0x0BA4
-#define GL_TEXTURE_STACK_DEPTH 0x0BA5
-#define GL_MODELVIEW_MATRIX 0x0BA6
-#define GL_PROJECTION_MATRIX 0x0BA7
-#define GL_TEXTURE_MATRIX 0x0BA8
-#define GL_ATTRIB_STACK_DEPTH 0x0BB0
-#define GL_CLIENT_ATTRIB_STACK_DEPTH 0x0BB1
-#define GL_ALPHA_TEST 0x0BC0
-#define GL_ALPHA_TEST_FUNC 0x0BC1
-#define GL_ALPHA_TEST_REF 0x0BC2
-#define GL_DITHER 0x0BD0
-#define GL_BLEND_DST 0x0BE0
-#define GL_BLEND_SRC 0x0BE1
-#define GL_BLEND 0x0BE2
-#define GL_LOGIC_OP_MODE 0x0BF0
-#define GL_INDEX_LOGIC_OP 0x0BF1
-#define GL_COLOR_LOGIC_OP 0x0BF2
-#define GL_AUX_BUFFERS 0x0C00
-#define GL_DRAW_BUFFER 0x0C01
-#define GL_READ_BUFFER 0x0C02
-#define GL_SCISSOR_BOX 0x0C10
-#define GL_SCISSOR_TEST 0x0C11
-#define GL_INDEX_CLEAR_VALUE 0x0C20
-#define GL_INDEX_WRITEMASK 0x0C21
-#define GL_COLOR_CLEAR_VALUE 0x0C22
-#define GL_COLOR_WRITEMASK 0x0C23
-#define GL_INDEX_MODE 0x0C30
-#define GL_RGBA_MODE 0x0C31
-#define GL_DOUBLEBUFFER 0x0C32
-#define GL_STEREO 0x0C33
-#define GL_RENDER_MODE 0x0C40
-#define GL_PERSPECTIVE_CORRECTION_HINT 0x0C50
-#define GL_POINT_SMOOTH_HINT 0x0C51
-#define GL_LINE_SMOOTH_HINT 0x0C52
-#define GL_POLYGON_SMOOTH_HINT 0x0C53
-#define GL_FOG_HINT 0x0C54
-#define GL_TEXTURE_GEN_S 0x0C60
-#define GL_TEXTURE_GEN_T 0x0C61
-#define GL_TEXTURE_GEN_R 0x0C62
-#define GL_TEXTURE_GEN_Q 0x0C63
-#define GL_PIXEL_MAP_I_TO_I 0x0C70
-#define GL_PIXEL_MAP_S_TO_S 0x0C71
-#define GL_PIXEL_MAP_I_TO_R 0x0C72
-#define GL_PIXEL_MAP_I_TO_G 0x0C73
-#define GL_PIXEL_MAP_I_TO_B 0x0C74
-#define GL_PIXEL_MAP_I_TO_A 0x0C75
-#define GL_PIXEL_MAP_R_TO_R 0x0C76
-#define GL_PIXEL_MAP_G_TO_G 0x0C77
-#define GL_PIXEL_MAP_B_TO_B 0x0C78
-#define GL_PIXEL_MAP_A_TO_A 0x0C79
-#define GL_PIXEL_MAP_I_TO_I_SIZE 0x0CB0
-#define GL_PIXEL_MAP_S_TO_S_SIZE 0x0CB1
-#define GL_PIXEL_MAP_I_TO_R_SIZE 0x0CB2
-#define GL_PIXEL_MAP_I_TO_G_SIZE 0x0CB3
-#define GL_PIXEL_MAP_I_TO_B_SIZE 0x0CB4
-#define GL_PIXEL_MAP_I_TO_A_SIZE 0x0CB5
-#define GL_PIXEL_MAP_R_TO_R_SIZE 0x0CB6
-#define GL_PIXEL_MAP_G_TO_G_SIZE 0x0CB7
-#define GL_PIXEL_MAP_B_TO_B_SIZE 0x0CB8
-#define GL_PIXEL_MAP_A_TO_A_SIZE 0x0CB9
-#define GL_UNPACK_SWAP_BYTES 0x0CF0
-#define GL_UNPACK_LSB_FIRST 0x0CF1
-#define GL_UNPACK_ROW_LENGTH 0x0CF2
-#define GL_UNPACK_SKIP_ROWS 0x0CF3
-#define GL_UNPACK_SKIP_PIXELS 0x0CF4
-#define GL_UNPACK_ALIGNMENT 0x0CF5
-#define GL_PACK_SWAP_BYTES 0x0D00
-#define GL_PACK_LSB_FIRST 0x0D01
-#define GL_PACK_ROW_LENGTH 0x0D02
-#define GL_PACK_SKIP_ROWS 0x0D03
-#define GL_PACK_SKIP_PIXELS 0x0D04
-#define GL_PACK_ALIGNMENT 0x0D05
-#define GL_MAP_COLOR 0x0D10
-#define GL_MAP_STENCIL 0x0D11
-#define GL_INDEX_SHIFT 0x0D12
-#define GL_INDEX_OFFSET 0x0D13
-#define GL_RED_SCALE 0x0D14
-#define GL_RED_BIAS 0x0D15
-#define GL_ZOOM_X 0x0D16
-#define GL_ZOOM_Y 0x0D17
-#define GL_GREEN_SCALE 0x0D18
-#define GL_GREEN_BIAS 0x0D19
-#define GL_BLUE_SCALE 0x0D1A
-#define GL_BLUE_BIAS 0x0D1B
-#define GL_ALPHA_SCALE 0x0D1C
-#define GL_ALPHA_BIAS 0x0D1D
-#define GL_DEPTH_SCALE 0x0D1E
-#define GL_DEPTH_BIAS 0x0D1F
-#define GL_MAX_EVAL_ORDER 0x0D30
-#define GL_MAX_LIGHTS 0x0D31
-#define GL_MAX_CLIP_PLANES 0x0D32
-#define GL_MAX_TEXTURE_SIZE 0x0D33
-#define GL_MAX_PIXEL_MAP_TABLE 0x0D34
-#define GL_MAX_ATTRIB_STACK_DEPTH 0x0D35
-#define GL_MAX_MODELVIEW_STACK_DEPTH 0x0D36
-#define GL_MAX_NAME_STACK_DEPTH 0x0D37
-#define GL_MAX_PROJECTION_STACK_DEPTH 0x0D38
-#define GL_MAX_TEXTURE_STACK_DEPTH 0x0D39
-#define GL_MAX_VIEWPORT_DIMS 0x0D3A
-#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH 0x0D3B
-#define GL_SUBPIXEL_BITS 0x0D50
-#define GL_INDEX_BITS 0x0D51
-#define GL_RED_BITS 0x0D52
-#define GL_GREEN_BITS 0x0D53
-#define GL_BLUE_BITS 0x0D54
-#define GL_ALPHA_BITS 0x0D55
-#define GL_DEPTH_BITS 0x0D56
-#define GL_STENCIL_BITS 0x0D57
-#define GL_ACCUM_RED_BITS 0x0D58
-#define GL_ACCUM_GREEN_BITS 0x0D59
-#define GL_ACCUM_BLUE_BITS 0x0D5A
-#define GL_ACCUM_ALPHA_BITS 0x0D5B
-#define GL_NAME_STACK_DEPTH 0x0D70
-#define GL_AUTO_NORMAL 0x0D80
-#define GL_MAP1_COLOR_4 0x0D90
-#define GL_MAP1_INDEX 0x0D91
-#define GL_MAP1_NORMAL 0x0D92
-#define GL_MAP1_TEXTURE_COORD_1 0x0D93
-#define GL_MAP1_TEXTURE_COORD_2 0x0D94
-#define GL_MAP1_TEXTURE_COORD_3 0x0D95
-#define GL_MAP1_TEXTURE_COORD_4 0x0D96
-#define GL_MAP1_VERTEX_3 0x0D97
-#define GL_MAP1_VERTEX_4 0x0D98
-#define GL_MAP2_COLOR_4 0x0DB0
-#define GL_MAP2_INDEX 0x0DB1
-#define GL_MAP2_NORMAL 0x0DB2
-#define GL_MAP2_TEXTURE_COORD_1 0x0DB3
-#define GL_MAP2_TEXTURE_COORD_2 0x0DB4
-#define GL_MAP2_TEXTURE_COORD_3 0x0DB5
-#define GL_MAP2_TEXTURE_COORD_4 0x0DB6
-#define GL_MAP2_VERTEX_3 0x0DB7
-#define GL_MAP2_VERTEX_4 0x0DB8
-#define GL_MAP1_GRID_DOMAIN 0x0DD0
-#define GL_MAP1_GRID_SEGMENTS 0x0DD1
-#define GL_MAP2_GRID_DOMAIN 0x0DD2
-#define GL_MAP2_GRID_SEGMENTS 0x0DD3
-#define GL_TEXTURE_1D 0x0DE0
-#define GL_TEXTURE_2D 0x0DE1
-#define GL_FEEDBACK_BUFFER_POINTER 0x0DF0
-#define GL_FEEDBACK_BUFFER_SIZE 0x0DF1
-#define GL_FEEDBACK_BUFFER_TYPE 0x0DF2
-#define GL_SELECTION_BUFFER_POINTER 0x0DF3
-#define GL_SELECTION_BUFFER_SIZE 0x0DF4
-#define GL_TEXTURE_WIDTH 0x1000
-#define GL_TEXTURE_HEIGHT 0x1001
-#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
-#define GL_TEXTURE_BORDER_COLOR 0x1004
-#define GL_TEXTURE_BORDER 0x1005
-#define GL_DONT_CARE 0x1100
-#define GL_FASTEST 0x1101
-#define GL_NICEST 0x1102
-#define GL_LIGHT0 0x4000
-#define GL_LIGHT1 0x4001
-#define GL_LIGHT2 0x4002
-#define GL_LIGHT3 0x4003
-#define GL_LIGHT4 0x4004
-#define GL_LIGHT5 0x4005
-#define GL_LIGHT6 0x4006
-#define GL_LIGHT7 0x4007
-#define GL_AMBIENT 0x1200
-#define GL_DIFFUSE 0x1201
-#define GL_SPECULAR 0x1202
-#define GL_POSITION 0x1203
-#define GL_SPOT_DIRECTION 0x1204
-#define GL_SPOT_EXPONENT 0x1205
-#define GL_SPOT_CUTOFF 0x1206
-#define GL_CONSTANT_ATTENUATION 0x1207
-#define GL_LINEAR_ATTENUATION 0x1208
-#define GL_QUADRATIC_ATTENUATION 0x1209
-#define GL_COMPILE 0x1300
-#define GL_COMPILE_AND_EXECUTE 0x1301
-#define GL_CLEAR 0x1500
-#define GL_AND 0x1501
-#define GL_AND_REVERSE 0x1502
-#define GL_COPY 0x1503
-#define GL_AND_INVERTED 0x1504
-#define GL_NOOP 0x1505
-#define GL_XOR 0x1506
-#define GL_OR 0x1507
-#define GL_NOR 0x1508
-#define GL_EQUIV 0x1509
-#define GL_INVERT 0x150A
-#define GL_OR_REVERSE 0x150B
-#define GL_COPY_INVERTED 0x150C
-#define GL_OR_INVERTED 0x150D
-#define GL_NAND 0x150E
-#define GL_SET 0x150F
-#define GL_EMISSION 0x1600
-#define GL_SHININESS 0x1601
-#define GL_AMBIENT_AND_DIFFUSE 0x1602
-#define GL_COLOR_INDEXES 0x1603
-#define GL_MODELVIEW 0x1700
-#define GL_PROJECTION 0x1701
-#define GL_TEXTURE 0x1702
-#define GL_COLOR 0x1800
-#define GL_DEPTH 0x1801
-#define GL_STENCIL 0x1802
-#define GL_COLOR_INDEX 0x1900
-#define GL_STENCIL_INDEX 0x1901
-#define GL_DEPTH_COMPONENT 0x1902
-#define GL_RED 0x1903
-#define GL_GREEN 0x1904
-#define GL_BLUE 0x1905
-#define GL_ALPHA 0x1906
-#define GL_RGB 0x1907
-#define GL_RGBA 0x1908
-#define GL_LUMINANCE 0x1909
-#define GL_LUMINANCE_ALPHA 0x190A
-#define GL_BITMAP 0x1A00
-#define GL_POINT 0x1B00
-#define GL_LINE 0x1B01
-#define GL_FILL 0x1B02
-#define GL_RENDER 0x1C00
-#define GL_FEEDBACK 0x1C01
-#define GL_SELECT 0x1C02
-#define GL_FLAT 0x1D00
-#define GL_SMOOTH 0x1D01
-#define GL_KEEP 0x1E00
-#define GL_REPLACE 0x1E01
-#define GL_INCR 0x1E02
-#define GL_DECR 0x1E03
-#define GL_VENDOR 0x1F00
-#define GL_RENDERER 0x1F01
-#define GL_VERSION 0x1F02
-#define GL_EXTENSIONS 0x1F03
-#define GL_S 0x2000
-#define GL_T 0x2001
-#define GL_R 0x2002
-#define GL_Q 0x2003
-#define GL_MODULATE 0x2100
-#define GL_DECAL 0x2101
-#define GL_TEXTURE_ENV_MODE 0x2200
-#define GL_TEXTURE_ENV_COLOR 0x2201
-#define GL_TEXTURE_ENV 0x2300
-#define GL_EYE_LINEAR 0x2400
-#define GL_OBJECT_LINEAR 0x2401
-#define GL_SPHERE_MAP 0x2402
-#define GL_TEXTURE_GEN_MODE 0x2500
-#define GL_OBJECT_PLANE 0x2501
-#define GL_EYE_PLANE 0x2502
-#define GL_NEAREST 0x2600
-#define GL_LINEAR 0x2601
-#define GL_NEAREST_MIPMAP_NEAREST 0x2700
-#define GL_LINEAR_MIPMAP_NEAREST 0x2701
-#define GL_NEAREST_MIPMAP_LINEAR 0x2702
-#define GL_LINEAR_MIPMAP_LINEAR 0x2703
-#define GL_TEXTURE_MAG_FILTER 0x2800
-#define GL_TEXTURE_MIN_FILTER 0x2801
-#define GL_TEXTURE_WRAP_S 0x2802
-#define GL_TEXTURE_WRAP_T 0x2803
-#define GL_CLAMP 0x2900
-#define GL_REPEAT 0x2901
-#define GL_CLIENT_PIXEL_STORE_BIT 0x00000001
-#define GL_CLIENT_VERTEX_ARRAY_BIT 0x00000002
-#define GL_CLIENT_ALL_ATTRIB_BITS 0xffffffff
-#define GL_POLYGON_OFFSET_FACTOR 0x8038
-#define GL_POLYGON_OFFSET_UNITS 0x2A00
-#define GL_POLYGON_OFFSET_POINT 0x2A01
-#define GL_POLYGON_OFFSET_LINE 0x2A02
-#define GL_POLYGON_OFFSET_FILL 0x8037
-#define GL_ALPHA4 0x803B
-#define GL_ALPHA8 0x803C
-#define GL_ALPHA12 0x803D
-#define GL_ALPHA16 0x803E
-#define GL_LUMINANCE4 0x803F
-#define GL_LUMINANCE8 0x8040
-#define GL_LUMINANCE12 0x8041
-#define GL_LUMINANCE16 0x8042
-#define GL_LUMINANCE4_ALPHA4 0x8043
-#define GL_LUMINANCE6_ALPHA2 0x8044
-#define GL_LUMINANCE8_ALPHA8 0x8045
-#define GL_LUMINANCE12_ALPHA4 0x8046
-#define GL_LUMINANCE12_ALPHA12 0x8047
-#define GL_LUMINANCE16_ALPHA16 0x8048
-#define GL_INTENSITY 0x8049
-#define GL_INTENSITY4 0x804A
-#define GL_INTENSITY8 0x804B
-#define GL_INTENSITY12 0x804C
-#define GL_INTENSITY16 0x804D
-#define GL_R3_G3_B2 0x2A10
-#define GL_RGB4 0x804F
-#define GL_RGB5 0x8050
-#define GL_RGB8 0x8051
-#define GL_RGB10 0x8052
-#define GL_RGB12 0x8053
-#define GL_RGB16 0x8054
-#define GL_RGBA2 0x8055
-#define GL_RGBA4 0x8056
-#define GL_RGB5_A1 0x8057
-#define GL_RGBA8 0x8058
-#define GL_RGB10_A2 0x8059
-#define GL_RGBA12 0x805A
-#define GL_RGBA16 0x805B
-#define GL_TEXTURE_RED_SIZE 0x805C
-#define GL_TEXTURE_GREEN_SIZE 0x805D
-#define GL_TEXTURE_BLUE_SIZE 0x805E
-#define GL_TEXTURE_ALPHA_SIZE 0x805F
-#define GL_TEXTURE_LUMINANCE_SIZE 0x8060
-#define GL_TEXTURE_INTENSITY_SIZE 0x8061
-#define GL_PROXY_TEXTURE_1D 0x8063
-#define GL_PROXY_TEXTURE_2D 0x8064
-#define GL_TEXTURE_PRIORITY 0x8066
-#define GL_TEXTURE_RESIDENT 0x8067
-#define GL_TEXTURE_BINDING_1D 0x8068
-#define GL_TEXTURE_BINDING_2D 0x8069
-#define GL_VERTEX_ARRAY 0x8074
-#define GL_NORMAL_ARRAY 0x8075
-#define GL_COLOR_ARRAY 0x8076
-#define GL_INDEX_ARRAY 0x8077
-#define GL_TEXTURE_COORD_ARRAY 0x8078
-#define GL_EDGE_FLAG_ARRAY 0x8079
-#define GL_VERTEX_ARRAY_SIZE 0x807A
-#define GL_VERTEX_ARRAY_TYPE 0x807B
-#define GL_VERTEX_ARRAY_STRIDE 0x807C
-#define GL_NORMAL_ARRAY_TYPE 0x807E
-#define GL_NORMAL_ARRAY_STRIDE 0x807F
-#define GL_COLOR_ARRAY_SIZE 0x8081
-#define GL_COLOR_ARRAY_TYPE 0x8082
-#define GL_COLOR_ARRAY_STRIDE 0x8083
-#define GL_INDEX_ARRAY_TYPE 0x8085
-#define GL_INDEX_ARRAY_STRIDE 0x8086
-#define GL_TEXTURE_COORD_ARRAY_SIZE 0x8088
-#define GL_TEXTURE_COORD_ARRAY_TYPE 0x8089
-#define GL_TEXTURE_COORD_ARRAY_STRIDE 0x808A
-#define GL_EDGE_FLAG_ARRAY_STRIDE 0x808C
-#define GL_VERTEX_ARRAY_POINTER 0x808E
-#define GL_NORMAL_ARRAY_POINTER 0x808F
-#define GL_COLOR_ARRAY_POINTER 0x8090
-#define GL_INDEX_ARRAY_POINTER 0x8091
-#define GL_TEXTURE_COORD_ARRAY_POINTER 0x8092
-#define GL_EDGE_FLAG_ARRAY_POINTER 0x8093
-#define GL_V2F 0x2A20
-#define GL_V3F 0x2A21
-#define GL_C4UB_V2F 0x2A22
-#define GL_C4UB_V3F 0x2A23
-#define GL_C3F_V3F 0x2A24
-#define GL_N3F_V3F 0x2A25
-#define GL_C4F_N3F_V3F 0x2A26
-#define GL_T2F_V3F 0x2A27
-#define GL_T4F_V4F 0x2A28
-#define GL_T2F_C4UB_V3F 0x2A29
-#define GL_T2F_C3F_V3F 0x2A2A
-#define GL_T2F_N3F_V3F 0x2A2B
-#define GL_T2F_C4F_N3F_V3F 0x2A2C
-#define GL_T4F_C4F_N3F_V4F 0x2A2D
-#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
-#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT
-#define GL_COLOR_INDEX1_EXT 0x80E2
-#define GL_COLOR_INDEX2_EXT 0x80E3
-#define GL_COLOR_INDEX4_EXT 0x80E4
-#define GL_COLOR_INDEX8_EXT 0x80E5
-#define GL_COLOR_INDEX12_EXT 0x80E6
-#define GL_COLOR_INDEX16_EXT 0x80E7
-#define GL_VERSION_1_2 1
-#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
-#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
-#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
-#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
-#define GL_UNSIGNED_BYTE_3_3_2 0x8032
-#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
-#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
-#define GL_UNSIGNED_INT_8_8_8_8 0x8035
-#define GL_UNSIGNED_INT_10_10_10_2 0x8036
-#define GL_RESCALE_NORMAL 0x803A
-#define GL_TEXTURE_BINDING_3D 0x806A
-#define GL_PACK_SKIP_IMAGES 0x806B
-#define GL_PACK_IMAGE_HEIGHT 0x806C
-#define GL_UNPACK_SKIP_IMAGES 0x806D
-#define GL_UNPACK_IMAGE_HEIGHT 0x806E
-#define GL_TEXTURE_3D 0x806F
-#define GL_PROXY_TEXTURE_3D 0x8070
-#define GL_TEXTURE_DEPTH 0x8071
-#define GL_TEXTURE_WRAP_R 0x8072
-#define GL_MAX_3D_TEXTURE_SIZE 0x8073
-#define GL_BGR 0x80E0
-#define GL_BGRA 0x80E1
-#define GL_MAX_ELEMENTS_VERTICES 0x80E8
-#define GL_MAX_ELEMENTS_INDICES 0x80E9
-#define GL_CLAMP_TO_EDGE 0x812F
-#define GL_TEXTURE_MIN_LOD 0x813A
-#define GL_TEXTURE_MAX_LOD 0x813B
-#define GL_TEXTURE_BASE_LEVEL 0x813C
-#define GL_TEXTURE_MAX_LEVEL 0x813D
-#define GL_LIGHT_MODEL_COLOR_CONTROL 0x81F8
-#define GL_SINGLE_COLOR 0x81F9
-#define GL_SEPARATE_SPECULAR_COLOR 0x81FA
-#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
-#define GL_UNSIGNED_SHORT_5_6_5 0x8363
-#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
-#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
-#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
-#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
-#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
-#define GL_ALIASED_POINT_SIZE_RANGE 0x846D
-#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
-#define GL_VERSION_1_3 1
-#define GL_MULTISAMPLE 0x809D
-#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
-#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
-#define GL_SAMPLE_COVERAGE 0x80A0
-#define GL_SAMPLE_BUFFERS 0x80A8
-#define GL_SAMPLES 0x80A9
-#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
-#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
-#define GL_CLAMP_TO_BORDER 0x812D
-#define GL_TEXTURE0 0x84C0
-#define GL_TEXTURE1 0x84C1
-#define GL_TEXTURE2 0x84C2
-#define GL_TEXTURE3 0x84C3
-#define GL_TEXTURE4 0x84C4
-#define GL_TEXTURE5 0x84C5
-#define GL_TEXTURE6 0x84C6
-#define GL_TEXTURE7 0x84C7
-#define GL_TEXTURE8 0x84C8
-#define GL_TEXTURE9 0x84C9
-#define GL_TEXTURE10 0x84CA
-#define GL_TEXTURE11 0x84CB
-#define GL_TEXTURE12 0x84CC
-#define GL_TEXTURE13 0x84CD
-#define GL_TEXTURE14 0x84CE
-#define GL_TEXTURE15 0x84CF
-#define GL_TEXTURE16 0x84D0
-#define GL_TEXTURE17 0x84D1
-#define GL_TEXTURE18 0x84D2
-#define GL_TEXTURE19 0x84D3
-#define GL_TEXTURE20 0x84D4
-#define GL_TEXTURE21 0x84D5
-#define GL_TEXTURE22 0x84D6
-#define GL_TEXTURE23 0x84D7
-#define GL_TEXTURE24 0x84D8
-#define GL_TEXTURE25 0x84D9
-#define GL_TEXTURE26 0x84DA
-#define GL_TEXTURE27 0x84DB
-#define GL_TEXTURE28 0x84DC
-#define GL_TEXTURE29 0x84DD
-#define GL_TEXTURE30 0x84DE
-#define GL_TEXTURE31 0x84DF
-#define GL_ACTIVE_TEXTURE 0x84E0
-#define GL_CLIENT_ACTIVE_TEXTURE 0x84E1
-#define GL_MAX_TEXTURE_UNITS 0x84E2
-#define GL_TRANSPOSE_MODELVIEW_MATRIX 0x84E3
-#define GL_TRANSPOSE_PROJECTION_MATRIX 0x84E4
-#define GL_TRANSPOSE_TEXTURE_MATRIX 0x84E5
-#define GL_TRANSPOSE_COLOR_MATRIX 0x84E6
-#define GL_SUBTRACT 0x84E7
-#define GL_COMPRESSED_ALPHA 0x84E9
-#define GL_COMPRESSED_LUMINANCE 0x84EA
-#define GL_COMPRESSED_LUMINANCE_ALPHA 0x84EB
-#define GL_COMPRESSED_INTENSITY 0x84EC
-#define GL_COMPRESSED_RGB 0x84ED
-#define GL_COMPRESSED_RGBA 0x84EE
-#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
-#define GL_NORMAL_MAP 0x8511
-#define GL_REFLECTION_MAP 0x8512
-#define GL_TEXTURE_CUBE_MAP 0x8513
-#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
-#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
-#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
-#define GL_COMBINE 0x8570
-#define GL_COMBINE_RGB 0x8571
-#define GL_COMBINE_ALPHA 0x8572
-#define GL_RGB_SCALE 0x8573
-#define GL_ADD_SIGNED 0x8574
-#define GL_INTERPOLATE 0x8575
-#define GL_CONSTANT 0x8576
-#define GL_PRIMARY_COLOR 0x8577
-#define GL_PREVIOUS 0x8578
-#define GL_SOURCE0_RGB 0x8580
-#define GL_SOURCE1_RGB 0x8581
-#define GL_SOURCE2_RGB 0x8582
-#define GL_SOURCE0_ALPHA 0x8588
-#define GL_SOURCE1_ALPHA 0x8589
-#define GL_SOURCE2_ALPHA 0x858A
-#define GL_OPERAND0_RGB 0x8590
-#define GL_OPERAND1_RGB 0x8591
-#define GL_OPERAND2_RGB 0x8592
-#define GL_OPERAND0_ALPHA 0x8598
-#define GL_OPERAND1_ALPHA 0x8599
-#define GL_OPERAND2_ALPHA 0x859A
-#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
-#define GL_TEXTURE_COMPRESSED 0x86A1
-#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
-#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
-#define GL_DOT3_RGB 0x86AE
-#define GL_DOT3_RGBA 0x86AF
-#define GL_MULTISAMPLE_BIT 0x20000000
-#define GL_VERSION_1_4 1
-#define GL_BLEND_DST_RGB 0x80C8
-#define GL_BLEND_SRC_RGB 0x80C9
-#define GL_BLEND_DST_ALPHA 0x80CA
-#define GL_BLEND_SRC_ALPHA 0x80CB
-#define GL_POINT_SIZE_MIN 0x8126
-#define GL_POINT_SIZE_MAX 0x8127
-#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
-#define GL_POINT_DISTANCE_ATTENUATION 0x8129
-#define GL_GENERATE_MIPMAP 0x8191
-#define GL_GENERATE_MIPMAP_HINT 0x8192
-#define GL_DEPTH_COMPONENT16 0x81A5
-#define GL_DEPTH_COMPONENT24 0x81A6
-#define GL_DEPTH_COMPONENT32 0x81A7
-#define GL_MIRRORED_REPEAT 0x8370
-#define GL_FOG_COORDINATE_SOURCE 0x8450
-#define GL_FOG_COORDINATE 0x8451
-#define GL_FRAGMENT_DEPTH 0x8452
-#define GL_CURRENT_FOG_COORDINATE 0x8453
-#define GL_FOG_COORDINATE_ARRAY_TYPE 0x8454
-#define GL_FOG_COORDINATE_ARRAY_STRIDE 0x8455
-#define GL_FOG_COORDINATE_ARRAY_POINTER 0x8456
-#define GL_FOG_COORDINATE_ARRAY 0x8457
-#define GL_COLOR_SUM 0x8458
-#define GL_CURRENT_SECONDARY_COLOR 0x8459
-#define GL_SECONDARY_COLOR_ARRAY_SIZE 0x845A
-#define GL_SECONDARY_COLOR_ARRAY_TYPE 0x845B
-#define GL_SECONDARY_COLOR_ARRAY_STRIDE 0x845C
-#define GL_SECONDARY_COLOR_ARRAY_POINTER 0x845D
-#define GL_SECONDARY_COLOR_ARRAY 0x845E
-#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
-#define GL_TEXTURE_FILTER_CONTROL 0x8500
-#define GL_TEXTURE_LOD_BIAS 0x8501
-#define GL_INCR_WRAP 0x8507
-#define GL_DECR_WRAP 0x8508
-#define GL_TEXTURE_DEPTH_SIZE 0x884A
-#define GL_DEPTH_TEXTURE_MODE 0x884B
-#define GL_TEXTURE_COMPARE_MODE 0x884C
-#define GL_TEXTURE_COMPARE_FUNC 0x884D
-#define GL_COMPARE_R_TO_TEXTURE 0x884E
-#define GL_VERSION_1_5 1
-#define GL_FOG_COORD_SRC GL_FOG_COORDINATE_SOURCE
-#define GL_FOG_COORD GL_FOG_COORDINATE
-#define GL_FOG_COORD_ARRAY GL_FOG_COORDINATE_ARRAY
-#define GL_SRC0_RGB GL_SOURCE0_RGB
-#define GL_FOG_COORD_ARRAY_POINTER GL_FOG_COORDINATE_ARRAY_POINTER
-#define GL_FOG_COORD_ARRAY_TYPE GL_FOG_COORDINATE_ARRAY_TYPE
-#define GL_SRC1_ALPHA GL_SOURCE1_ALPHA
-#define GL_CURRENT_FOG_COORD GL_CURRENT_FOG_COORDINATE
-#define GL_FOG_COORD_ARRAY_STRIDE GL_FOG_COORDINATE_ARRAY_STRIDE
-#define GL_SRC0_ALPHA GL_SOURCE0_ALPHA
-#define GL_SRC1_RGB GL_SOURCE1_RGB
-#define GL_FOG_COORD_ARRAY_BUFFER_BINDING GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING
-#define GL_SRC2_ALPHA GL_SOURCE2_ALPHA
-#define GL_SRC2_RGB GL_SOURCE2_RGB
-#define GL_BUFFER_SIZE 0x8764
-#define GL_BUFFER_USAGE 0x8765
-#define GL_QUERY_COUNTER_BITS 0x8864
-#define GL_CURRENT_QUERY 0x8865
-#define GL_QUERY_RESULT 0x8866
-#define GL_QUERY_RESULT_AVAILABLE 0x8867
-#define GL_ARRAY_BUFFER 0x8892
-#define GL_ELEMENT_ARRAY_BUFFER 0x8893
-#define GL_ARRAY_BUFFER_BINDING 0x8894
-#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
-#define GL_VERTEX_ARRAY_BUFFER_BINDING 0x8896
-#define GL_NORMAL_ARRAY_BUFFER_BINDING 0x8897
-#define GL_COLOR_ARRAY_BUFFER_BINDING 0x8898
-#define GL_INDEX_ARRAY_BUFFER_BINDING 0x8899
-#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING 0x889A
-#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING 0x889B
-#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING 0x889C
-#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING 0x889D
-#define GL_WEIGHT_ARRAY_BUFFER_BINDING 0x889E
-#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
-#define GL_READ_ONLY 0x88B8
-#define GL_WRITE_ONLY 0x88B9
-#define GL_READ_WRITE 0x88BA
-#define GL_BUFFER_ACCESS 0x88BB
-#define GL_BUFFER_MAPPED 0x88BC
-#define GL_BUFFER_MAP_POINTER 0x88BD
-#define GL_STREAM_DRAW 0x88E0
-#define GL_STREAM_READ 0x88E1
-#define GL_STREAM_COPY 0x88E2
-#define GL_STATIC_DRAW 0x88E4
-#define GL_STATIC_READ 0x88E5
-#define GL_STATIC_COPY 0x88E6
-#define GL_DYNAMIC_DRAW 0x88E8
-#define GL_DYNAMIC_READ 0x88E9
-#define GL_DYNAMIC_COPY 0x88EA
-#define GL_SAMPLES_PASSED 0x8914
-#define GL_VERSION_2_0 1
-#define GL_BLEND_EQUATION_RGB GL_BLEND_EQUATION
-#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
-#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
-#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
-#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
-#define GL_CURRENT_VERTEX_ATTRIB 0x8626
-#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
-#define GL_VERTEX_PROGRAM_TWO_SIDE 0x8643
-#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
-#define GL_STENCIL_BACK_FUNC 0x8800
-#define GL_STENCIL_BACK_FAIL 0x8801
-#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
-#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
-#define GL_MAX_DRAW_BUFFERS 0x8824
-#define GL_DRAW_BUFFER0 0x8825
-#define GL_DRAW_BUFFER1 0x8826
-#define GL_DRAW_BUFFER2 0x8827
-#define GL_DRAW_BUFFER3 0x8828
-#define GL_DRAW_BUFFER4 0x8829
-#define GL_DRAW_BUFFER5 0x882A
-#define GL_DRAW_BUFFER6 0x882B
-#define GL_DRAW_BUFFER7 0x882C
-#define GL_DRAW_BUFFER8 0x882D
-#define GL_DRAW_BUFFER9 0x882E
-#define GL_DRAW_BUFFER10 0x882F
-#define GL_DRAW_BUFFER11 0x8830
-#define GL_DRAW_BUFFER12 0x8831
-#define GL_DRAW_BUFFER13 0x8832
-#define GL_DRAW_BUFFER14 0x8833
-#define GL_DRAW_BUFFER15 0x8834
-#define GL_BLEND_EQUATION_ALPHA 0x883D
-#define GL_POINT_SPRITE 0x8861
-#define GL_COORD_REPLACE 0x8862
-#define GL_MAX_VERTEX_ATTRIBS 0x8869
-#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
-#define GL_MAX_TEXTURE_COORDS 0x8871
-#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
-#define GL_FRAGMENT_SHADER 0x8B30
-#define GL_VERTEX_SHADER 0x8B31
-#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
-#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
-#define GL_MAX_VARYING_FLOATS 0x8B4B
-#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
-#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
-#define GL_SHADER_TYPE 0x8B4F
-#define GL_FLOAT_VEC2 0x8B50
-#define GL_FLOAT_VEC3 0x8B51
-#define GL_FLOAT_VEC4 0x8B52
-#define GL_INT_VEC2 0x8B53
-#define GL_INT_VEC3 0x8B54
-#define GL_INT_VEC4 0x8B55
-#define GL_BOOL 0x8B56
-#define GL_BOOL_VEC2 0x8B57
-#define GL_BOOL_VEC3 0x8B58
-#define GL_BOOL_VEC4 0x8B59
-#define GL_FLOAT_MAT2 0x8B5A
-#define GL_FLOAT_MAT3 0x8B5B
-#define GL_FLOAT_MAT4 0x8B5C
-#define GL_SAMPLER_1D 0x8B5D
-#define GL_SAMPLER_2D 0x8B5E
-#define GL_SAMPLER_3D 0x8B5F
-#define GL_SAMPLER_CUBE 0x8B60
-#define GL_SAMPLER_1D_SHADOW 0x8B61
-#define GL_SAMPLER_2D_SHADOW 0x8B62
-#define GL_DELETE_STATUS 0x8B80
-#define GL_COMPILE_STATUS 0x8B81
-#define GL_LINK_STATUS 0x8B82
-#define GL_VALIDATE_STATUS 0x8B83
-#define GL_INFO_LOG_LENGTH 0x8B84
-#define GL_ATTACHED_SHADERS 0x8B85
-#define GL_ACTIVE_UNIFORMS 0x8B86
-#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
-#define GL_SHADER_SOURCE_LENGTH 0x8B88
-#define GL_ACTIVE_ATTRIBUTES 0x8B89
-#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
-#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
-#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
-#define GL_CURRENT_PROGRAM 0x8B8D
-#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
-#define GL_LOWER_LEFT 0x8CA1
-#define GL_UPPER_LEFT 0x8CA2
-#define GL_STENCIL_BACK_REF 0x8CA3
-#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
-#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
-#define GL_3DFX_multisample 1
-#define GL_MULTISAMPLE_3DFX 0x86B2
-#define GL_SAMPLE_BUFFERS_3DFX 0x86B3
-#define GL_SAMPLES_3DFX 0x86B4
-#define GL_MULTISAMPLE_BIT_3DFX 0x20000000
-#define GL_3DFX_tbuffer 1
-#define GL_3DFX_texture_compression_FXT1 1
-#define GL_COMPRESSED_RGB_FXT1_3DFX 0x86B0
-#define GL_COMPRESSED_RGBA_FXT1_3DFX 0x86B1
-#define GL_APPLE_client_storage 1
-#define GL_UNPACK_CLIENT_STORAGE_APPLE 0x85B2
-#define GL_APPLE_element_array 1
-#define GL_ELEMENT_ARRAY_APPLE 0x8768
-#define GL_ELEMENT_ARRAY_TYPE_APPLE 0x8769
-#define GL_ELEMENT_ARRAY_POINTER_APPLE 0x876A
-#define GL_APPLE_fence 1
-#define GL_DRAW_PIXELS_APPLE 0x8A0A
-#define GL_FENCE_APPLE 0x8A0B
-#define GL_APPLE_float_pixels 1
-#define GL_HALF_APPLE 0x140B
-#define GL_RGBA_FLOAT32_APPLE 0x8814
-#define GL_RGB_FLOAT32_APPLE 0x8815
-#define GL_ALPHA_FLOAT32_APPLE 0x8816
-#define GL_INTENSITY_FLOAT32_APPLE 0x8817
-#define GL_LUMINANCE_FLOAT32_APPLE 0x8818
-#define GL_LUMINANCE_ALPHA_FLOAT32_APPLE 0x8819
-#define GL_RGBA_FLOAT16_APPLE 0x881A
-#define GL_RGB_FLOAT16_APPLE 0x881B
-#define GL_ALPHA_FLOAT16_APPLE 0x881C
-#define GL_INTENSITY_FLOAT16_APPLE 0x881D
-#define GL_LUMINANCE_FLOAT16_APPLE 0x881E
-#define GL_LUMINANCE_ALPHA_FLOAT16_APPLE 0x881F
-#define GL_COLOR_FLOAT_APPLE 0x8A0F
-#define GL_APPLE_pixel_buffer 1
-#define GL_MIN_PBUFFER_VIEWPORT_DIMS_APPLE 0x8A10
-#define GL_APPLE_specular_vector 1
-#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE 0x85B0
-#define GL_APPLE_texture_range 1
-#define GL_TEXTURE_RANGE_LENGTH_APPLE 0x85B7
-#define GL_TEXTURE_RANGE_POINTER_APPLE 0x85B8
-#define GL_TEXTURE_STORAGE_HINT_APPLE 0x85BC
-#define GL_STORAGE_PRIVATE_APPLE 0x85BD
-#define GL_STORAGE_CACHED_APPLE 0x85BE
-#define GL_STORAGE_SHARED_APPLE 0x85BF
-#define GL_APPLE_transform_hint 1
-#define GL_TRANSFORM_HINT_APPLE 0x85B1
-#define GL_APPLE_vertex_array_object 1
-#define GL_VERTEX_ARRAY_BINDING_APPLE 0x85B5
-#define GL_APPLE_vertex_array_range 1
-#define GL_VERTEX_ARRAY_RANGE_APPLE 0x851D
-#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE 0x851E
-#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
-#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_APPLE 0x8520
-#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
-#define GL_STORAGE_CACHED_APPLE 0x85BE
-#define GL_STORAGE_SHARED_APPLE 0x85BF
-#define GL_APPLE_ycbcr_422 1
-#define GL_YCBCR_422_APPLE 0x85B9
-#define GL_UNSIGNED_SHORT_8_8_APPLE 0x85BA
-#define GL_UNSIGNED_SHORT_8_8_REV_APPLE 0x85BB
-#define GL_ARB_color_buffer_float 1
-#define GL_RGBA_FLOAT_MODE_ARB 0x8820
-#define GL_CLAMP_VERTEX_COLOR_ARB 0x891A
-#define GL_CLAMP_FRAGMENT_COLOR_ARB 0x891B
-#define GL_CLAMP_READ_COLOR_ARB 0x891C
-#define GL_FIXED_ONLY_ARB 0x891D
-#define GL_ARB_depth_texture 1
-#define GL_DEPTH_COMPONENT16_ARB 0x81A5
-#define GL_DEPTH_COMPONENT24_ARB 0x81A6
-#define GL_DEPTH_COMPONENT32_ARB 0x81A7
-#define GL_TEXTURE_DEPTH_SIZE_ARB 0x884A
-#define GL_DEPTH_TEXTURE_MODE_ARB 0x884B
-#define GL_ARB_draw_buffers 1
-#define GL_MAX_DRAW_BUFFERS_ARB 0x8824
-#define GL_DRAW_BUFFER0_ARB 0x8825
-#define GL_DRAW_BUFFER1_ARB 0x8826
-#define GL_DRAW_BUFFER2_ARB 0x8827
-#define GL_DRAW_BUFFER3_ARB 0x8828
-#define GL_DRAW_BUFFER4_ARB 0x8829
-#define GL_DRAW_BUFFER5_ARB 0x882A
-#define GL_DRAW_BUFFER6_ARB 0x882B
-#define GL_DRAW_BUFFER7_ARB 0x882C
-#define GL_DRAW_BUFFER8_ARB 0x882D
-#define GL_DRAW_BUFFER9_ARB 0x882E
-#define GL_DRAW_BUFFER10_ARB 0x882F
-#define GL_DRAW_BUFFER11_ARB 0x8830
-#define GL_DRAW_BUFFER12_ARB 0x8831
-#define GL_DRAW_BUFFER13_ARB 0x8832
-#define GL_DRAW_BUFFER14_ARB 0x8833
-#define GL_DRAW_BUFFER15_ARB 0x8834
-#define GL_ARB_fragment_program 1
-#define GL_FRAGMENT_PROGRAM_ARB 0x8804
-#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB 0x8805
-#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB 0x8806
-#define GL_PROGRAM_TEX_INDIRECTIONS_ARB 0x8807
-#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
-#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
-#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
-#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
-#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
-#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
-#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
-#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
-#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
-#define GL_MAX_TEXTURE_COORDS_ARB 0x8871
-#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB 0x8872
-#define GL_ARB_fragment_program_shadow 1
-#define GL_ARB_fragment_shader 1
-#define GL_FRAGMENT_SHADER_ARB 0x8B30
-#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB 0x8B49
-#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB 0x8B8B
-#define GL_ARB_half_float_pixel 1
-#define GL_HALF_FLOAT_ARB 0x140B
-#define GL_ARB_imaging 1
-#define GL_CONSTANT_COLOR 0x8001
-#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
-#define GL_CONSTANT_ALPHA 0x8003
-#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
-#define GL_BLEND_COLOR 0x8005
-#define GL_FUNC_ADD 0x8006
-#define GL_MIN 0x8007
-#define GL_MAX 0x8008
-#define GL_BLEND_EQUATION 0x8009
-#define GL_FUNC_SUBTRACT 0x800A
-#define GL_FUNC_REVERSE_SUBTRACT 0x800B
-#define GL_CONVOLUTION_1D 0x8010
-#define GL_CONVOLUTION_2D 0x8011
-#define GL_SEPARABLE_2D 0x8012
-#define GL_CONVOLUTION_BORDER_MODE 0x8013
-#define GL_CONVOLUTION_FILTER_SCALE 0x8014
-#define GL_CONVOLUTION_FILTER_BIAS 0x8015
-#define GL_REDUCE 0x8016
-#define GL_CONVOLUTION_FORMAT 0x8017
-#define GL_CONVOLUTION_WIDTH 0x8018
-#define GL_CONVOLUTION_HEIGHT 0x8019
-#define GL_MAX_CONVOLUTION_WIDTH 0x801A
-#define GL_MAX_CONVOLUTION_HEIGHT 0x801B
-#define GL_POST_CONVOLUTION_RED_SCALE 0x801C
-#define GL_POST_CONVOLUTION_GREEN_SCALE 0x801D
-#define GL_POST_CONVOLUTION_BLUE_SCALE 0x801E
-#define GL_POST_CONVOLUTION_ALPHA_SCALE 0x801F
-#define GL_POST_CONVOLUTION_RED_BIAS 0x8020
-#define GL_POST_CONVOLUTION_GREEN_BIAS 0x8021
-#define GL_POST_CONVOLUTION_BLUE_BIAS 0x8022
-#define GL_POST_CONVOLUTION_ALPHA_BIAS 0x8023
-#define GL_HISTOGRAM 0x8024
-#define GL_PROXY_HISTOGRAM 0x8025
-#define GL_HISTOGRAM_WIDTH 0x8026
-#define GL_HISTOGRAM_FORMAT 0x8027
-#define GL_HISTOGRAM_RED_SIZE 0x8028
-#define GL_HISTOGRAM_GREEN_SIZE 0x8029
-#define GL_HISTOGRAM_BLUE_SIZE 0x802A
-#define GL_HISTOGRAM_ALPHA_SIZE 0x802B
-#define GL_HISTOGRAM_LUMINANCE_SIZE 0x802C
-#define GL_HISTOGRAM_SINK 0x802D
-#define GL_MINMAX 0x802E
-#define GL_MINMAX_FORMAT 0x802F
-#define GL_MINMAX_SINK 0x8030
-#define GL_TABLE_TOO_LARGE 0x8031
-#define GL_COLOR_MATRIX 0x80B1
-#define GL_COLOR_MATRIX_STACK_DEPTH 0x80B2
-#define GL_MAX_COLOR_MATRIX_STACK_DEPTH 0x80B3
-#define GL_POST_COLOR_MATRIX_RED_SCALE 0x80B4
-#define GL_POST_COLOR_MATRIX_GREEN_SCALE 0x80B5
-#define GL_POST_COLOR_MATRIX_BLUE_SCALE 0x80B6
-#define GL_POST_COLOR_MATRIX_ALPHA_SCALE 0x80B7
-#define GL_POST_COLOR_MATRIX_RED_BIAS 0x80B8
-#define GL_POST_COLOR_MATRIX_GREEN_BIAS 0x80B9
-#define GL_POST_COLOR_MATRIX_BLUE_BIAS 0x80BA
-#define GL_POST_COLOR_MATRIX_ALPHA_BIAS 0x80BB
-#define GL_COLOR_TABLE 0x80D0
-#define GL_POST_CONVOLUTION_COLOR_TABLE 0x80D1
-#define GL_POST_COLOR_MATRIX_COLOR_TABLE 0x80D2
-#define GL_PROXY_COLOR_TABLE 0x80D3
-#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE 0x80D4
-#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE 0x80D5
-#define GL_COLOR_TABLE_SCALE 0x80D6
-#define GL_COLOR_TABLE_BIAS 0x80D7
-#define GL_COLOR_TABLE_FORMAT 0x80D8
-#define GL_COLOR_TABLE_WIDTH 0x80D9
-#define GL_COLOR_TABLE_RED_SIZE 0x80DA
-#define GL_COLOR_TABLE_GREEN_SIZE 0x80DB
-#define GL_COLOR_TABLE_BLUE_SIZE 0x80DC
-#define GL_COLOR_TABLE_ALPHA_SIZE 0x80DD
-#define GL_COLOR_TABLE_LUMINANCE_SIZE 0x80DE
-#define GL_COLOR_TABLE_INTENSITY_SIZE 0x80DF
-#define GL_IGNORE_BORDER 0x8150
-#define GL_CONSTANT_BORDER 0x8151
-#define GL_WRAP_BORDER 0x8152
-#define GL_REPLICATE_BORDER 0x8153
-#define GL_CONVOLUTION_BORDER_COLOR 0x8154
-#define GL_ARB_matrix_palette 1
-#define GL_MATRIX_PALETTE_ARB 0x8840
-#define GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB 0x8841
-#define GL_MAX_PALETTE_MATRICES_ARB 0x8842
-#define GL_CURRENT_PALETTE_MATRIX_ARB 0x8843
-#define GL_MATRIX_INDEX_ARRAY_ARB 0x8844
-#define GL_CURRENT_MATRIX_INDEX_ARB 0x8845
-#define GL_MATRIX_INDEX_ARRAY_SIZE_ARB 0x8846
-#define GL_MATRIX_INDEX_ARRAY_TYPE_ARB 0x8847
-#define GL_MATRIX_INDEX_ARRAY_STRIDE_ARB 0x8848
-#define GL_MATRIX_INDEX_ARRAY_POINTER_ARB 0x8849
-#define GL_ARB_multisample 1
-#define GL_MULTISAMPLE_ARB 0x809D
-#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB 0x809E
-#define GL_SAMPLE_ALPHA_TO_ONE_ARB 0x809F
-#define GL_SAMPLE_COVERAGE_ARB 0x80A0
-#define GL_SAMPLE_BUFFERS_ARB 0x80A8
-#define GL_SAMPLES_ARB 0x80A9
-#define GL_SAMPLE_COVERAGE_VALUE_ARB 0x80AA
-#define GL_SAMPLE_COVERAGE_INVERT_ARB 0x80AB
-#define GL_MULTISAMPLE_BIT_ARB 0x20000000
-#define GL_ARB_multitexture 1
-#define GL_TEXTURE0_ARB 0x84C0
-#define GL_TEXTURE1_ARB 0x84C1
-#define GL_TEXTURE2_ARB 0x84C2
-#define GL_TEXTURE3_ARB 0x84C3
-#define GL_TEXTURE4_ARB 0x84C4
-#define GL_TEXTURE5_ARB 0x84C5
-#define GL_TEXTURE6_ARB 0x84C6
-#define GL_TEXTURE7_ARB 0x84C7
-#define GL_TEXTURE8_ARB 0x84C8
-#define GL_TEXTURE9_ARB 0x84C9
-#define GL_TEXTURE10_ARB 0x84CA
-#define GL_TEXTURE11_ARB 0x84CB
-#define GL_TEXTURE12_ARB 0x84CC
-#define GL_TEXTURE13_ARB 0x84CD
-#define GL_TEXTURE14_ARB 0x84CE
-#define GL_TEXTURE15_ARB 0x84CF
-#define GL_TEXTURE16_ARB 0x84D0
-#define GL_TEXTURE17_ARB 0x84D1
-#define GL_TEXTURE18_ARB 0x84D2
-#define GL_TEXTURE19_ARB 0x84D3
-#define GL_TEXTURE20_ARB 0x84D4
-#define GL_TEXTURE21_ARB 0x84D5
-#define GL_TEXTURE22_ARB 0x84D6
-#define GL_TEXTURE23_ARB 0x84D7
-#define GL_TEXTURE24_ARB 0x84D8
-#define GL_TEXTURE25_ARB 0x84D9
-#define GL_TEXTURE26_ARB 0x84DA
-#define GL_TEXTURE27_ARB 0x84DB
-#define GL_TEXTURE28_ARB 0x84DC
-#define GL_TEXTURE29_ARB 0x84DD
-#define GL_TEXTURE30_ARB 0x84DE
-#define GL_TEXTURE31_ARB 0x84DF
-#define GL_ACTIVE_TEXTURE_ARB 0x84E0
-#define GL_CLIENT_ACTIVE_TEXTURE_ARB 0x84E1
-#define GL_MAX_TEXTURE_UNITS_ARB 0x84E2
-#define GL_ARB_occlusion_query 1
-#define GL_QUERY_COUNTER_BITS_ARB 0x8864
-#define GL_CURRENT_QUERY_ARB 0x8865
-#define GL_QUERY_RESULT_ARB 0x8866
-#define GL_QUERY_RESULT_AVAILABLE_ARB 0x8867
-#define GL_SAMPLES_PASSED_ARB 0x8914
-#define GL_ARB_pixel_buffer_object 1
-#define GL_PIXEL_PACK_BUFFER_ARB 0x88EB
-#define GL_PIXEL_UNPACK_BUFFER_ARB 0x88EC
-#define GL_PIXEL_PACK_BUFFER_BINDING_ARB 0x88ED
-#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB 0x88EF
-#define GL_ARB_point_parameters 1
-#define GL_POINT_SIZE_MIN_ARB 0x8126
-#define GL_POINT_SIZE_MAX_ARB 0x8127
-#define GL_POINT_FADE_THRESHOLD_SIZE_ARB 0x8128
-#define GL_POINT_DISTANCE_ATTENUATION_ARB 0x8129
-#define GL_ARB_point_sprite 1
-#define GL_POINT_SPRITE_ARB 0x8861
-#define GL_COORD_REPLACE_ARB 0x8862
-#define GL_ARB_shader_objects 1
-#define GL_PROGRAM_OBJECT_ARB 0x8B40
-#define GL_SHADER_OBJECT_ARB 0x8B48
-#define GL_OBJECT_TYPE_ARB 0x8B4E
-#define GL_OBJECT_SUBTYPE_ARB 0x8B4F
-#define GL_FLOAT_VEC2_ARB 0x8B50
-#define GL_FLOAT_VEC3_ARB 0x8B51
-#define GL_FLOAT_VEC4_ARB 0x8B52
-#define GL_INT_VEC2_ARB 0x8B53
-#define GL_INT_VEC3_ARB 0x8B54
-#define GL_INT_VEC4_ARB 0x8B55
-#define GL_BOOL_ARB 0x8B56
-#define GL_BOOL_VEC2_ARB 0x8B57
-#define GL_BOOL_VEC3_ARB 0x8B58
-#define GL_BOOL_VEC4_ARB 0x8B59
-#define GL_FLOAT_MAT2_ARB 0x8B5A
-#define GL_FLOAT_MAT3_ARB 0x8B5B
-#define GL_FLOAT_MAT4_ARB 0x8B5C
-#define GL_SAMPLER_1D_ARB 0x8B5D
-#define GL_SAMPLER_2D_ARB 0x8B5E
-#define GL_SAMPLER_3D_ARB 0x8B5F
-#define GL_SAMPLER_CUBE_ARB 0x8B60
-#define GL_SAMPLER_1D_SHADOW_ARB 0x8B61
-#define GL_SAMPLER_2D_SHADOW_ARB 0x8B62
-#define GL_SAMPLER_2D_RECT_ARB 0x8B63
-#define GL_SAMPLER_2D_RECT_SHADOW_ARB 0x8B64
-#define GL_OBJECT_DELETE_STATUS_ARB 0x8B80
-#define GL_OBJECT_COMPILE_STATUS_ARB 0x8B81
-#define GL_OBJECT_LINK_STATUS_ARB 0x8B82
-#define GL_OBJECT_VALIDATE_STATUS_ARB 0x8B83
-#define GL_OBJECT_INFO_LOG_LENGTH_ARB 0x8B84
-#define GL_OBJECT_ATTACHED_OBJECTS_ARB 0x8B85
-#define GL_OBJECT_ACTIVE_UNIFORMS_ARB 0x8B86
-#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB 0x8B87
-#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB 0x8B88
-#define GL_ARB_shading_language_100 1
-#define GL_SHADING_LANGUAGE_VERSION_ARB 0x8B8C
-#define GL_ARB_shadow 1
-#define GL_TEXTURE_COMPARE_MODE_ARB 0x884C
-#define GL_TEXTURE_COMPARE_FUNC_ARB 0x884D
-#define GL_COMPARE_R_TO_TEXTURE_ARB 0x884E
-#define GL_ARB_shadow_ambient 1
-#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
-#define GL_ARB_texture_border_clamp 1
-#define GL_CLAMP_TO_BORDER_ARB 0x812D
-#define GL_ARB_texture_compression 1
-#define GL_COMPRESSED_ALPHA_ARB 0x84E9
-#define GL_COMPRESSED_LUMINANCE_ARB 0x84EA
-#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB 0x84EB
-#define GL_COMPRESSED_INTENSITY_ARB 0x84EC
-#define GL_COMPRESSED_RGB_ARB 0x84ED
-#define GL_COMPRESSED_RGBA_ARB 0x84EE
-#define GL_TEXTURE_COMPRESSION_HINT_ARB 0x84EF
-#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB 0x86A0
-#define GL_TEXTURE_COMPRESSED_ARB 0x86A1
-#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
-#define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
-#define GL_ARB_texture_cube_map 1
-#define GL_NORMAL_MAP_ARB 0x8511
-#define GL_REFLECTION_MAP_ARB 0x8512
-#define GL_TEXTURE_CUBE_MAP_ARB 0x8513
-#define GL_TEXTURE_BINDING_CUBE_MAP_ARB 0x8514
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
-#define GL_PROXY_TEXTURE_CUBE_MAP_ARB 0x851B
-#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB 0x851C
-#define GL_ARB_texture_env_add 1
-#define GL_ARB_texture_env_combine 1
-#define GL_SUBTRACT_ARB 0x84E7
-#define GL_COMBINE_ARB 0x8570
-#define GL_COMBINE_RGB_ARB 0x8571
-#define GL_COMBINE_ALPHA_ARB 0x8572
-#define GL_RGB_SCALE_ARB 0x8573
-#define GL_ADD_SIGNED_ARB 0x8574
-#define GL_INTERPOLATE_ARB 0x8575
-#define GL_CONSTANT_ARB 0x8576
-#define GL_PRIMARY_COLOR_ARB 0x8577
-#define GL_PREVIOUS_ARB 0x8578
-#define GL_SOURCE0_RGB_ARB 0x8580
-#define GL_SOURCE1_RGB_ARB 0x8581
-#define GL_SOURCE2_RGB_ARB 0x8582
-#define GL_SOURCE0_ALPHA_ARB 0x8588
-#define GL_SOURCE1_ALPHA_ARB 0x8589
-#define GL_SOURCE2_ALPHA_ARB 0x858A
-#define GL_OPERAND0_RGB_ARB 0x8590
-#define GL_OPERAND1_RGB_ARB 0x8591
-#define GL_OPERAND2_RGB_ARB 0x8592
-#define GL_OPERAND0_ALPHA_ARB 0x8598
-#define GL_OPERAND1_ALPHA_ARB 0x8599
-#define GL_OPERAND2_ALPHA_ARB 0x859A
-#define GL_ARB_texture_env_crossbar 1
-#define GL_ARB_texture_env_dot3 1
-#define GL_DOT3_RGB_ARB 0x86AE
-#define GL_DOT3_RGBA_ARB 0x86AF
-#define GL_ARB_texture_float 1
-#define GL_RGBA32F_ARB 0x8814
-#define GL_RGB32F_ARB 0x8815
-#define GL_ALPHA32F_ARB 0x8816
-#define GL_INTENSITY32F_ARB 0x8817
-#define GL_LUMINANCE32F_ARB 0x8818
-#define GL_LUMINANCE_ALPHA32F_ARB 0x8819
-#define GL_RGBA16F_ARB 0x881A
-#define GL_RGB16F_ARB 0x881B
-#define GL_ALPHA16F_ARB 0x881C
-#define GL_INTENSITY16F_ARB 0x881D
-#define GL_LUMINANCE16F_ARB 0x881E
-#define GL_LUMINANCE_ALPHA16F_ARB 0x881F
-#define GL_TEXTURE_RED_TYPE_ARB 0x8C10
-#define GL_TEXTURE_GREEN_TYPE_ARB 0x8C11
-#define GL_TEXTURE_BLUE_TYPE_ARB 0x8C12
-#define GL_TEXTURE_ALPHA_TYPE_ARB 0x8C13
-#define GL_TEXTURE_LUMINANCE_TYPE_ARB 0x8C14
-#define GL_TEXTURE_INTENSITY_TYPE_ARB 0x8C15
-#define GL_TEXTURE_DEPTH_TYPE_ARB 0x8C16
-#define GL_UNSIGNED_NORMALIZED_ARB 0x8C17
-#define GL_ARB_texture_mirrored_repeat 1
-#define GL_MIRRORED_REPEAT_ARB 0x8370
-#define GL_ARB_texture_non_power_of_two 1
-#define GL_ARB_texture_rectangle 1
-#define GL_TEXTURE_RECTANGLE_ARB 0x84F5
-#define GL_TEXTURE_BINDING_RECTANGLE_ARB 0x84F6
-#define GL_PROXY_TEXTURE_RECTANGLE_ARB 0x84F7
-#define GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB 0x84F8
-#define GL_SAMPLER_2D_RECT_ARB 0x8B63
-#define GL_SAMPLER_2D_RECT_SHADOW_ARB 0x8B64
-#define GL_ARB_transpose_matrix 1
-#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB 0x84E3
-#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB 0x84E4
-#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB 0x84E5
-#define GL_TRANSPOSE_COLOR_MATRIX_ARB 0x84E6
-#define GL_ARB_vertex_blend 1
-#define GL_MODELVIEW0_ARB 0x1700
-#define GL_MODELVIEW1_ARB 0x850A
-#define GL_MAX_VERTEX_UNITS_ARB 0x86A4
-#define GL_ACTIVE_VERTEX_UNITS_ARB 0x86A5
-#define GL_WEIGHT_SUM_UNITY_ARB 0x86A6
-#define GL_VERTEX_BLEND_ARB 0x86A7
-#define GL_CURRENT_WEIGHT_ARB 0x86A8
-#define GL_WEIGHT_ARRAY_TYPE_ARB 0x86A9
-#define GL_WEIGHT_ARRAY_STRIDE_ARB 0x86AA
-#define GL_WEIGHT_ARRAY_SIZE_ARB 0x86AB
-#define GL_WEIGHT_ARRAY_POINTER_ARB 0x86AC
-#define GL_WEIGHT_ARRAY_ARB 0x86AD
-#define GL_MODELVIEW2_ARB 0x8722
-#define GL_MODELVIEW3_ARB 0x8723
-#define GL_MODELVIEW4_ARB 0x8724
-#define GL_MODELVIEW5_ARB 0x8725
-#define GL_MODELVIEW6_ARB 0x8726
-#define GL_MODELVIEW7_ARB 0x8727
-#define GL_MODELVIEW8_ARB 0x8728
-#define GL_MODELVIEW9_ARB 0x8729
-#define GL_MODELVIEW10_ARB 0x872A
-#define GL_MODELVIEW11_ARB 0x872B
-#define GL_MODELVIEW12_ARB 0x872C
-#define GL_MODELVIEW13_ARB 0x872D
-#define GL_MODELVIEW14_ARB 0x872E
-#define GL_MODELVIEW15_ARB 0x872F
-#define GL_MODELVIEW16_ARB 0x8730
-#define GL_MODELVIEW17_ARB 0x8731
-#define GL_MODELVIEW18_ARB 0x8732
-#define GL_MODELVIEW19_ARB 0x8733
-#define GL_MODELVIEW20_ARB 0x8734
-#define GL_MODELVIEW21_ARB 0x8735
-#define GL_MODELVIEW22_ARB 0x8736
-#define GL_MODELVIEW23_ARB 0x8737
-#define GL_MODELVIEW24_ARB 0x8738
-#define GL_MODELVIEW25_ARB 0x8739
-#define GL_MODELVIEW26_ARB 0x873A
-#define GL_MODELVIEW27_ARB 0x873B
-#define GL_MODELVIEW28_ARB 0x873C
-#define GL_MODELVIEW29_ARB 0x873D
-#define GL_MODELVIEW30_ARB 0x873E
-#define GL_MODELVIEW31_ARB 0x873F
-#define GL_ARB_vertex_buffer_object 1
-#define GL_BUFFER_SIZE_ARB 0x8764
-#define GL_BUFFER_USAGE_ARB 0x8765
-#define GL_ARRAY_BUFFER_ARB 0x8892
-#define GL_ELEMENT_ARRAY_BUFFER_ARB 0x8893
-#define GL_ARRAY_BUFFER_BINDING_ARB 0x8894
-#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
-#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
-#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
-#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
-#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
-#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
-#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
-#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
-#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
-#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
-#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
-#define GL_READ_ONLY_ARB 0x88B8
-#define GL_WRITE_ONLY_ARB 0x88B9
-#define GL_READ_WRITE_ARB 0x88BA
-#define GL_BUFFER_ACCESS_ARB 0x88BB
-#define GL_BUFFER_MAPPED_ARB 0x88BC
-#define GL_BUFFER_MAP_POINTER_ARB 0x88BD
-#define GL_STREAM_DRAW_ARB 0x88E0
-#define GL_STREAM_READ_ARB 0x88E1
-#define GL_STREAM_COPY_ARB 0x88E2
-#define GL_STATIC_DRAW_ARB 0x88E4
-#define GL_STATIC_READ_ARB 0x88E5
-#define GL_STATIC_COPY_ARB 0x88E6
-#define GL_DYNAMIC_DRAW_ARB 0x88E8
-#define GL_DYNAMIC_READ_ARB 0x88E9
-#define GL_DYNAMIC_COPY_ARB 0x88EA
-#define GL_ARB_vertex_program 1
-#define GL_COLOR_SUM_ARB 0x8458
-#define GL_VERTEX_PROGRAM_ARB 0x8620
-#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
-#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB 0x8623
-#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
-#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB 0x8625
-#define GL_CURRENT_VERTEX_ATTRIB_ARB 0x8626
-#define GL_PROGRAM_LENGTH_ARB 0x8627
-#define GL_PROGRAM_STRING_ARB 0x8628
-#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
-#define GL_MAX_PROGRAM_MATRICES_ARB 0x862F
-#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
-#define GL_CURRENT_MATRIX_ARB 0x8641
-#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB 0x8642
-#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB 0x8643
-#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
-#define GL_PROGRAM_ERROR_POSITION_ARB 0x864B
-#define GL_PROGRAM_BINDING_ARB 0x8677
-#define GL_MAX_VERTEX_ATTRIBS_ARB 0x8869
-#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
-#define GL_PROGRAM_ERROR_STRING_ARB 0x8874
-#define GL_PROGRAM_FORMAT_ASCII_ARB 0x8875
-#define GL_PROGRAM_FORMAT_ARB 0x8876
-#define GL_PROGRAM_INSTRUCTIONS_ARB 0x88A0
-#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB 0x88A1
-#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
-#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
-#define GL_PROGRAM_TEMPORARIES_ARB 0x88A4
-#define GL_MAX_PROGRAM_TEMPORARIES_ARB 0x88A5
-#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
-#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
-#define GL_PROGRAM_PARAMETERS_ARB 0x88A8
-#define GL_MAX_PROGRAM_PARAMETERS_ARB 0x88A9
-#define GL_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AA
-#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
-#define GL_PROGRAM_ATTRIBS_ARB 0x88AC
-#define GL_MAX_PROGRAM_ATTRIBS_ARB 0x88AD
-#define GL_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AE
-#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
-#define GL_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B0
-#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
-#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
-#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
-#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
-#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
-#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
-#define GL_TRANSPOSE_CURRENT_MATRIX_ARB 0x88B7
-#define GL_MATRIX0_ARB 0x88C0
-#define GL_MATRIX1_ARB 0x88C1
-#define GL_MATRIX2_ARB 0x88C2
-#define GL_MATRIX3_ARB 0x88C3
-#define GL_MATRIX4_ARB 0x88C4
-#define GL_MATRIX5_ARB 0x88C5
-#define GL_MATRIX6_ARB 0x88C6
-#define GL_MATRIX7_ARB 0x88C7
-#define GL_MATRIX8_ARB 0x88C8
-#define GL_MATRIX9_ARB 0x88C9
-#define GL_MATRIX10_ARB 0x88CA
-#define GL_MATRIX11_ARB 0x88CB
-#define GL_MATRIX12_ARB 0x88CC
-#define GL_MATRIX13_ARB 0x88CD
-#define GL_MATRIX14_ARB 0x88CE
-#define GL_MATRIX15_ARB 0x88CF
-#define GL_MATRIX16_ARB 0x88D0
-#define GL_MATRIX17_ARB 0x88D1
-#define GL_MATRIX18_ARB 0x88D2
-#define GL_MATRIX19_ARB 0x88D3
-#define GL_MATRIX20_ARB 0x88D4
-#define GL_MATRIX21_ARB 0x88D5
-#define GL_MATRIX22_ARB 0x88D6
-#define GL_MATRIX23_ARB 0x88D7
-#define GL_MATRIX24_ARB 0x88D8
-#define GL_MATRIX25_ARB 0x88D9
-#define GL_MATRIX26_ARB 0x88DA
-#define GL_MATRIX27_ARB 0x88DB
-#define GL_MATRIX28_ARB 0x88DC
-#define GL_MATRIX29_ARB 0x88DD
-#define GL_MATRIX30_ARB 0x88DE
-#define GL_MATRIX31_ARB 0x88DF
-#define GL_ARB_vertex_shader 1
-#define GL_VERTEX_SHADER_ARB 0x8B31
-#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB 0x8B4A
-#define GL_MAX_VARYING_FLOATS_ARB 0x8B4B
-#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
-#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB 0x8B4D
-#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB 0x8B89
-#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB 0x8B8A
-#define GL_ARB_window_pos 1
-#define GL_ATIX_point_sprites 1
-#define GL_ATIX_texture_env_combine3 1
-#define GL_MODULATE_ADD_ATIX 0x8744
-#define GL_MODULATE_SIGNED_ADD_ATIX 0x8745
-#define GL_MODULATE_SUBTRACT_ATIX 0x8746
-#define GL_ATIX_texture_env_route 1
-#define GL_SECONDARY_COLOR_ATIX 0x8747
-#define GL_TEXTURE_OUTPUT_RGB_ATIX 0x8748
-#define GL_TEXTURE_OUTPUT_ALPHA_ATIX 0x8749
-#define GL_ATIX_vertex_shader_output_point_size 1
-#define GL_OUTPUT_POINT_SIZE_ATIX 0x610E
-#define GL_ATI_draw_buffers 1
-#define GL_MAX_DRAW_BUFFERS_ATI 0x8824
-#define GL_DRAW_BUFFER0_ATI 0x8825
-#define GL_DRAW_BUFFER1_ATI 0x8826
-#define GL_DRAW_BUFFER2_ATI 0x8827
-#define GL_DRAW_BUFFER3_ATI 0x8828
-#define GL_DRAW_BUFFER4_ATI 0x8829
-#define GL_DRAW_BUFFER5_ATI 0x882A
-#define GL_DRAW_BUFFER6_ATI 0x882B
-#define GL_DRAW_BUFFER7_ATI 0x882C
-#define GL_DRAW_BUFFER8_ATI 0x882D
-#define GL_DRAW_BUFFER9_ATI 0x882E
-#define GL_DRAW_BUFFER10_ATI 0x882F
-#define GL_DRAW_BUFFER11_ATI 0x8830
-#define GL_DRAW_BUFFER12_ATI 0x8831
-#define GL_DRAW_BUFFER13_ATI 0x8832
-#define GL_DRAW_BUFFER14_ATI 0x8833
-#define GL_DRAW_BUFFER15_ATI 0x8834
-#define GL_ATI_element_array 1
-#define GL_ELEMENT_ARRAY_ATI 0x8768
-#define GL_ELEMENT_ARRAY_TYPE_ATI 0x8769
-#define GL_ELEMENT_ARRAY_POINTER_ATI 0x876A
-#define GL_ATI_envmap_bumpmap 1
-#define GL_BUMP_ROT_MATRIX_ATI 0x8775
-#define GL_BUMP_ROT_MATRIX_SIZE_ATI 0x8776
-#define GL_BUMP_NUM_TEX_UNITS_ATI 0x8777
-#define GL_BUMP_TEX_UNITS_ATI 0x8778
-#define GL_DUDV_ATI 0x8779
-#define GL_DU8DV8_ATI 0x877A
-#define GL_BUMP_ENVMAP_ATI 0x877B
-#define GL_BUMP_TARGET_ATI 0x877C
-#define GL_ATI_fragment_shader 1
-#define GL_RED_BIT_ATI 0x00000001
-#define GL_2X_BIT_ATI 0x00000001
-#define GL_4X_BIT_ATI 0x00000002
-#define GL_GREEN_BIT_ATI 0x00000002
-#define GL_COMP_BIT_ATI 0x00000002
-#define GL_BLUE_BIT_ATI 0x00000004
-#define GL_8X_BIT_ATI 0x00000004
-#define GL_NEGATE_BIT_ATI 0x00000004
-#define GL_BIAS_BIT_ATI 0x00000008
-#define GL_HALF_BIT_ATI 0x00000008
-#define GL_QUARTER_BIT_ATI 0x00000010
-#define GL_EIGHTH_BIT_ATI 0x00000020
-#define GL_SATURATE_BIT_ATI 0x00000040
-#define GL_FRAGMENT_SHADER_ATI 0x8920
-#define GL_REG_0_ATI 0x8921
-#define GL_REG_1_ATI 0x8922
-#define GL_REG_2_ATI 0x8923
-#define GL_REG_3_ATI 0x8924
-#define GL_REG_4_ATI 0x8925
-#define GL_REG_5_ATI 0x8926
-#define GL_CON_0_ATI 0x8941
-#define GL_CON_1_ATI 0x8942
-#define GL_CON_2_ATI 0x8943
-#define GL_CON_3_ATI 0x8944
-#define GL_CON_4_ATI 0x8945
-#define GL_CON_5_ATI 0x8946
-#define GL_CON_6_ATI 0x8947
-#define GL_CON_7_ATI 0x8948
-#define GL_MOV_ATI 0x8961
-#define GL_ADD_ATI 0x8963
-#define GL_MUL_ATI 0x8964
-#define GL_SUB_ATI 0x8965
-#define GL_DOT3_ATI 0x8966
-#define GL_DOT4_ATI 0x8967
-#define GL_MAD_ATI 0x8968
-#define GL_LERP_ATI 0x8969
-#define GL_CND_ATI 0x896A
-#define GL_CND0_ATI 0x896B
-#define GL_DOT2_ADD_ATI 0x896C
-#define GL_SECONDARY_INTERPOLATOR_ATI 0x896D
-#define GL_NUM_FRAGMENT_REGISTERS_ATI 0x896E
-#define GL_NUM_FRAGMENT_CONSTANTS_ATI 0x896F
-#define GL_NUM_PASSES_ATI 0x8970
-#define GL_NUM_INSTRUCTIONS_PER_PASS_ATI 0x8971
-#define GL_NUM_INSTRUCTIONS_TOTAL_ATI 0x8972
-#define GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI 0x8973
-#define GL_NUM_LOOPBACK_COMPONENTS_ATI 0x8974
-#define GL_COLOR_ALPHA_PAIRING_ATI 0x8975
-#define GL_SWIZZLE_STR_ATI 0x8976
-#define GL_SWIZZLE_STQ_ATI 0x8977
-#define GL_SWIZZLE_STR_DR_ATI 0x8978
-#define GL_SWIZZLE_STQ_DQ_ATI 0x8979
-#define GL_SWIZZLE_STRQ_ATI 0x897A
-#define GL_SWIZZLE_STRQ_DQ_ATI 0x897B
-#define GL_ATI_map_object_buffer 1
-#define GL_ATI_pn_triangles 1
-#define GL_PN_TRIANGLES_ATI 0x87F0
-#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F1
-#define GL_PN_TRIANGLES_POINT_MODE_ATI 0x87F2
-#define GL_PN_TRIANGLES_NORMAL_MODE_ATI 0x87F3
-#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F4
-#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI 0x87F5
-#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI 0x87F6
-#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI 0x87F7
-#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI 0x87F8
-#define GL_ATI_separate_stencil 1
-#define GL_STENCIL_BACK_FUNC_ATI 0x8800
-#define GL_STENCIL_BACK_FAIL_ATI 0x8801
-#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI 0x8802
-#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI 0x8803
-#define GL_ATI_text_fragment_shader 1
-#define GL_TEXT_FRAGMENT_SHADER_ATI 0x8200
-#define GL_ATI_texture_compression_3dc 1
-#define GL_COMPRESSED_RGB_3DC_ATI 0x8837
-#define GL_ATI_texture_env_combine3 1
-#define GL_MODULATE_ADD_ATI 0x8744
-#define GL_MODULATE_SIGNED_ADD_ATI 0x8745
-#define GL_MODULATE_SUBTRACT_ATI 0x8746
-#define GL_ATI_texture_float 1
-#define GL_RGBA_FLOAT32_ATI 0x8814
-#define GL_RGB_FLOAT32_ATI 0x8815
-#define GL_ALPHA_FLOAT32_ATI 0x8816
-#define GL_INTENSITY_FLOAT32_ATI 0x8817
-#define GL_LUMINANCE_FLOAT32_ATI 0x8818
-#define GL_LUMINANCE_ALPHA_FLOAT32_ATI 0x8819
-#define GL_RGBA_FLOAT16_ATI 0x881A
-#define GL_RGB_FLOAT16_ATI 0x881B
-#define GL_ALPHA_FLOAT16_ATI 0x881C
-#define GL_INTENSITY_FLOAT16_ATI 0x881D
-#define GL_LUMINANCE_FLOAT16_ATI 0x881E
-#define GL_LUMINANCE_ALPHA_FLOAT16_ATI 0x881F
-#define GL_ATI_texture_mirror_once 1
-#define GL_MIRROR_CLAMP_ATI 0x8742
-#define GL_MIRROR_CLAMP_TO_EDGE_ATI 0x8743
-#define GL_ATI_vertex_array_object 1
-#define GL_STATIC_ATI 0x8760
-#define GL_DYNAMIC_ATI 0x8761
-#define GL_PRESERVE_ATI 0x8762
-#define GL_DISCARD_ATI 0x8763
-#define GL_OBJECT_BUFFER_SIZE_ATI 0x8764
-#define GL_OBJECT_BUFFER_USAGE_ATI 0x8765
-#define GL_ARRAY_OBJECT_BUFFER_ATI 0x8766
-#define GL_ARRAY_OBJECT_OFFSET_ATI 0x8767
-#define GL_ATI_vertex_attrib_array_object 1
-#define GL_ATI_vertex_streams 1
-#define GL_MAX_VERTEX_STREAMS_ATI 0x876B
-#define GL_VERTEX_SOURCE_ATI 0x876C
-#define GL_VERTEX_STREAM0_ATI 0x876D
-#define GL_VERTEX_STREAM1_ATI 0x876E
-#define GL_VERTEX_STREAM2_ATI 0x876F
-#define GL_VERTEX_STREAM3_ATI 0x8770
-#define GL_VERTEX_STREAM4_ATI 0x8771
-#define GL_VERTEX_STREAM5_ATI 0x8772
-#define GL_VERTEX_STREAM6_ATI 0x8773
-#define GL_VERTEX_STREAM7_ATI 0x8774
-#define GL_EXT_422_pixels 1
-#define GL_422_EXT 0x80CC
-#define GL_422_REV_EXT 0x80CD
-#define GL_422_AVERAGE_EXT 0x80CE
-#define GL_422_REV_AVERAGE_EXT 0x80CF
-#define GL_EXT_Cg_shader 1
-#define GL_CG_VERTEX_SHADER_EXT 0x890E
-#define GL_CG_FRAGMENT_SHADER_EXT 0x890F
-#define GL_EXT_abgr 1
-#define GL_ABGR_EXT 0x8000
-#define GL_EXT_bgra 1
-#define GL_BGR_EXT 0x80E0
-#define GL_BGRA_EXT 0x80E1
-#define GL_EXT_blend_color 1
-#define GL_CONSTANT_COLOR_EXT 0x8001
-#define GL_ONE_MINUS_CONSTANT_COLOR_EXT 0x8002
-#define GL_CONSTANT_ALPHA_EXT 0x8003
-#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT 0x8004
-#define GL_BLEND_COLOR_EXT 0x8005
-#define GL_EXT_blend_equation_separate 1
-#define GL_BLEND_EQUATION_RGB_EXT 0x8009
-#define GL_BLEND_EQUATION_ALPHA_EXT 0x883D
-#define GL_EXT_blend_func_separate 1
-#define GL_BLEND_DST_RGB_EXT 0x80C8
-#define GL_BLEND_SRC_RGB_EXT 0x80C9
-#define GL_BLEND_DST_ALPHA_EXT 0x80CA
-#define GL_BLEND_SRC_ALPHA_EXT 0x80CB
-#define GL_EXT_blend_logic_op 1
-#define GL_EXT_blend_minmax 1
-#define GL_FUNC_ADD_EXT 0x8006
-#define GL_MIN_EXT 0x8007
-#define GL_MAX_EXT 0x8008
-#define GL_BLEND_EQUATION_EXT 0x8009
-#define GL_EXT_blend_subtract 1
-#define GL_FUNC_SUBTRACT_EXT 0x800A
-#define GL_FUNC_REVERSE_SUBTRACT_EXT 0x800B
-#define GL_EXT_clip_volume_hint 1
-#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT 0x80F0
-#define GL_EXT_cmyka 1
-#define GL_CMYK_EXT 0x800C
-#define GL_CMYKA_EXT 0x800D
-#define GL_PACK_CMYK_HINT_EXT 0x800E
-#define GL_UNPACK_CMYK_HINT_EXT 0x800F
-#define GL_EXT_color_subtable 1
-#define GL_EXT_compiled_vertex_array 1
-#define GL_EXT_convolution 1
-#define GL_CONVOLUTION_1D_EXT 0x8010
-#define GL_CONVOLUTION_2D_EXT 0x8011
-#define GL_SEPARABLE_2D_EXT 0x8012
-#define GL_CONVOLUTION_BORDER_MODE_EXT 0x8013
-#define GL_CONVOLUTION_FILTER_SCALE_EXT 0x8014
-#define GL_CONVOLUTION_FILTER_BIAS_EXT 0x8015
-#define GL_REDUCE_EXT 0x8016
-#define GL_CONVOLUTION_FORMAT_EXT 0x8017
-#define GL_CONVOLUTION_WIDTH_EXT 0x8018
-#define GL_CONVOLUTION_HEIGHT_EXT 0x8019
-#define GL_MAX_CONVOLUTION_WIDTH_EXT 0x801A
-#define GL_MAX_CONVOLUTION_HEIGHT_EXT 0x801B
-#define GL_POST_CONVOLUTION_RED_SCALE_EXT 0x801C
-#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
-#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT 0x801E
-#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
-#define GL_POST_CONVOLUTION_RED_BIAS_EXT 0x8020
-#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
-#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
-#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
-#define GL_EXT_coordinate_frame 1
-#define GL_TANGENT_ARRAY_EXT 0x8439
-#define GL_BINORMAL_ARRAY_EXT 0x843A
-#define GL_CURRENT_TANGENT_EXT 0x843B
-#define GL_CURRENT_BINORMAL_EXT 0x843C
-#define GL_TANGENT_ARRAY_TYPE_EXT 0x843E
-#define GL_TANGENT_ARRAY_STRIDE_EXT 0x843F
-#define GL_BINORMAL_ARRAY_TYPE_EXT 0x8440
-#define GL_BINORMAL_ARRAY_STRIDE_EXT 0x8441
-#define GL_TANGENT_ARRAY_POINTER_EXT 0x8442
-#define GL_BINORMAL_ARRAY_POINTER_EXT 0x8443
-#define GL_MAP1_TANGENT_EXT 0x8444
-#define GL_MAP2_TANGENT_EXT 0x8445
-#define GL_MAP1_BINORMAL_EXT 0x8446
-#define GL_MAP2_BINORMAL_EXT 0x8447
-#define GL_EXT_copy_texture 1
-#define GL_EXT_cull_vertex 1
-#define GL_EXT_depth_bounds_test 1
-#define GL_DEPTH_BOUNDS_TEST_EXT 0x8890
-#define GL_DEPTH_BOUNDS_EXT 0x8891
-#define GL_EXT_draw_range_elements 1
-#define GL_MAX_ELEMENTS_VERTICES 0x80E8
-#define GL_MAX_ELEMENTS_INDICES 0x80E9
-#define GL_EXT_fog_coord 1
-#define GL_FOG_COORDINATE_SOURCE_EXT 0x8450
-#define GL_FOG_COORDINATE_EXT 0x8451
-#define GL_FRAGMENT_DEPTH_EXT 0x8452
-#define GL_CURRENT_FOG_COORDINATE_EXT 0x8453
-#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT 0x8454
-#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT 0x8455
-#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT 0x8456
-#define GL_FOG_COORDINATE_ARRAY_EXT 0x8457
-#define GL_EXT_fragment_lighting 1
-#define GL_FRAGMENT_LIGHTING_EXT 0x8400
-#define GL_FRAGMENT_COLOR_MATERIAL_EXT 0x8401
-#define GL_FRAGMENT_COLOR_MATERIAL_FACE_EXT 0x8402
-#define GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_EXT 0x8403
-#define GL_MAX_FRAGMENT_LIGHTS_EXT 0x8404
-#define GL_MAX_ACTIVE_LIGHTS_EXT 0x8405
-#define GL_CURRENT_RASTER_NORMAL_EXT 0x8406
-#define GL_LIGHT_ENV_MODE_EXT 0x8407
-#define GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_EXT 0x8408
-#define GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_EXT 0x8409
-#define GL_FRAGMENT_LIGHT_MODEL_AMBIENT_EXT 0x840A
-#define GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_EXT 0x840B
-#define GL_FRAGMENT_LIGHT0_EXT 0x840C
-#define GL_FRAGMENT_LIGHT7_EXT 0x8413
-#define GL_EXT_framebuffer_blit 1
-#define GL_DRAW_FRAMEBUFFER_BINDING_EXT 0x8CA6
-#define GL_READ_FRAMEBUFFER_EXT 0x8CA8
-#define GL_DRAW_FRAMEBUFFER_EXT 0x8CA9
-#define GL_READ_FRAMEBUFFER_BINDING_EXT 0x8CAA
-#define GL_EXT_framebuffer_multisample 1
-#define GL_RENDERBUFFER_SAMPLES_EXT 0x8CAB
-#define GL_EXT_framebuffer_object 1
-#define GL_INVALID_FRAMEBUFFER_OPERATION_EXT 0x0506
-#define GL_MAX_RENDERBUFFER_SIZE_EXT 0x84E8
-#define GL_FRAMEBUFFER_BINDING_EXT 0x8CA6
-#define GL_RENDERBUFFER_BINDING_EXT 0x8CA7
-#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT 0x8CD0
-#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT 0x8CD1
-#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT 0x8CD2
-#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT 0x8CD3
-#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT 0x8CD4
-#define GL_FRAMEBUFFER_COMPLETE_EXT 0x8CD5
-#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT 0x8CD6
-#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT 0x8CD7
-#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT 0x8CD9
-#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT 0x8CDA
-#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT 0x8CDB
-#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT 0x8CDC
-#define GL_FRAMEBUFFER_UNSUPPORTED_EXT 0x8CDD
-#define GL_MAX_COLOR_ATTACHMENTS_EXT 0x8CDF
-#define GL_COLOR_ATTACHMENT0_EXT 0x8CE0
-#define GL_COLOR_ATTACHMENT1_EXT 0x8CE1
-#define GL_COLOR_ATTACHMENT2_EXT 0x8CE2
-#define GL_COLOR_ATTACHMENT3_EXT 0x8CE3
-#define GL_COLOR_ATTACHMENT4_EXT 0x8CE4
-#define GL_COLOR_ATTACHMENT5_EXT 0x8CE5
-#define GL_COLOR_ATTACHMENT6_EXT 0x8CE6
-#define GL_COLOR_ATTACHMENT7_EXT 0x8CE7
-#define GL_COLOR_ATTACHMENT8_EXT 0x8CE8
-#define GL_COLOR_ATTACHMENT9_EXT 0x8CE9
-#define GL_COLOR_ATTACHMENT10_EXT 0x8CEA
-#define GL_COLOR_ATTACHMENT11_EXT 0x8CEB
-#define GL_COLOR_ATTACHMENT12_EXT 0x8CEC
-#define GL_COLOR_ATTACHMENT13_EXT 0x8CED
-#define GL_COLOR_ATTACHMENT14_EXT 0x8CEE
-#define GL_COLOR_ATTACHMENT15_EXT 0x8CEF
-#define GL_DEPTH_ATTACHMENT_EXT 0x8D00
-#define GL_STENCIL_ATTACHMENT_EXT 0x8D20
-#define GL_FRAMEBUFFER_EXT 0x8D40
-#define GL_RENDERBUFFER_EXT 0x8D41
-#define GL_RENDERBUFFER_WIDTH_EXT 0x8D42
-#define GL_RENDERBUFFER_HEIGHT_EXT 0x8D43
-#define GL_RENDERBUFFER_INTERNAL_FORMAT_EXT 0x8D44
-#define GL_STENCIL_INDEX1_EXT 0x8D46
-#define GL_STENCIL_INDEX4_EXT 0x8D47
-#define GL_STENCIL_INDEX8_EXT 0x8D48
-#define GL_STENCIL_INDEX16_EXT 0x8D49
-#define GL_RENDERBUFFER_RED_SIZE_EXT 0x8D50
-#define GL_RENDERBUFFER_GREEN_SIZE_EXT 0x8D51
-#define GL_RENDERBUFFER_BLUE_SIZE_EXT 0x8D52
-#define GL_RENDERBUFFER_ALPHA_SIZE_EXT 0x8D53
-#define GL_RENDERBUFFER_DEPTH_SIZE_EXT 0x8D54
-#define GL_RENDERBUFFER_STENCIL_SIZE_EXT 0x8D55
-#define GL_EXT_histogram 1
-#define GL_HISTOGRAM_EXT 0x8024
-#define GL_PROXY_HISTOGRAM_EXT 0x8025
-#define GL_HISTOGRAM_WIDTH_EXT 0x8026
-#define GL_HISTOGRAM_FORMAT_EXT 0x8027
-#define GL_HISTOGRAM_RED_SIZE_EXT 0x8028
-#define GL_HISTOGRAM_GREEN_SIZE_EXT 0x8029
-#define GL_HISTOGRAM_BLUE_SIZE_EXT 0x802A
-#define GL_HISTOGRAM_ALPHA_SIZE_EXT 0x802B
-#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT 0x802C
-#define GL_HISTOGRAM_SINK_EXT 0x802D
-#define GL_MINMAX_EXT 0x802E
-#define GL_MINMAX_FORMAT_EXT 0x802F
-#define GL_MINMAX_SINK_EXT 0x8030
-#define GL_EXT_index_array_formats 1
-#define GL_EXT_index_func 1
-#define GL_EXT_index_material 1
-#define GL_EXT_index_texture 1
-#define GL_EXT_light_texture 1
-#define GL_FRAGMENT_MATERIAL_EXT 0x8349
-#define GL_FRAGMENT_NORMAL_EXT 0x834A
-#define GL_FRAGMENT_COLOR_EXT 0x834C
-#define GL_ATTENUATION_EXT 0x834D
-#define GL_SHADOW_ATTENUATION_EXT 0x834E
-#define GL_TEXTURE_APPLICATION_MODE_EXT 0x834F
-#define GL_TEXTURE_LIGHT_EXT 0x8350
-#define GL_TEXTURE_MATERIAL_FACE_EXT 0x8351
-#define GL_TEXTURE_MATERIAL_PARAMETER_EXT 0x8352
-#define GL_FRAGMENT_DEPTH_EXT 0x8452
-#define GL_EXT_misc_attribute 1
-#define GL_EXT_multi_draw_arrays 1
-#define GL_EXT_multisample 1
-#define GL_MULTISAMPLE_EXT 0x809D
-#define GL_SAMPLE_ALPHA_TO_MASK_EXT 0x809E
-#define GL_SAMPLE_ALPHA_TO_ONE_EXT 0x809F
-#define GL_SAMPLE_MASK_EXT 0x80A0
-#define GL_1PASS_EXT 0x80A1
-#define GL_2PASS_0_EXT 0x80A2
-#define GL_2PASS_1_EXT 0x80A3
-#define GL_4PASS_0_EXT 0x80A4
-#define GL_4PASS_1_EXT 0x80A5
-#define GL_4PASS_2_EXT 0x80A6
-#define GL_4PASS_3_EXT 0x80A7
-#define GL_SAMPLE_BUFFERS_EXT 0x80A8
-#define GL_SAMPLES_EXT 0x80A9
-#define GL_SAMPLE_MASK_VALUE_EXT 0x80AA
-#define GL_SAMPLE_MASK_INVERT_EXT 0x80AB
-#define GL_SAMPLE_PATTERN_EXT 0x80AC
-#define GL_MULTISAMPLE_BIT_EXT 0x20000000
-#define GL_EXT_packed_depth_stencil 1
-#define GL_DEPTH_STENCIL_EXT 0x84F9
-#define GL_UNSIGNED_INT_24_8_EXT 0x84FA
-#define GL_DEPTH24_STENCIL8_EXT 0x88F0
-#define GL_TEXTURE_STENCIL_SIZE_EXT 0x88F1
-#define GL_EXT_packed_pixels 1
-#define GL_UNSIGNED_BYTE_3_3_2_EXT 0x8032
-#define GL_UNSIGNED_SHORT_4_4_4_4_EXT 0x8033
-#define GL_UNSIGNED_SHORT_5_5_5_1_EXT 0x8034
-#define GL_UNSIGNED_INT_8_8_8_8_EXT 0x8035
-#define GL_UNSIGNED_INT_10_10_10_2_EXT 0x8036
-#define GL_EXT_paletted_texture 1
-#define GL_TEXTURE_1D 0x0DE0
-#define GL_TEXTURE_2D 0x0DE1
-#define GL_PROXY_TEXTURE_1D 0x8063
-#define GL_PROXY_TEXTURE_2D 0x8064
-#define GL_TEXTURE_3D_EXT 0x806F
-#define GL_PROXY_TEXTURE_3D_EXT 0x8070
-#define GL_COLOR_TABLE_FORMAT_EXT 0x80D8
-#define GL_COLOR_TABLE_WIDTH_EXT 0x80D9
-#define GL_COLOR_TABLE_RED_SIZE_EXT 0x80DA
-#define GL_COLOR_TABLE_GREEN_SIZE_EXT 0x80DB
-#define GL_COLOR_TABLE_BLUE_SIZE_EXT 0x80DC
-#define GL_COLOR_TABLE_ALPHA_SIZE_EXT 0x80DD
-#define GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
-#define GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF
-#define GL_COLOR_INDEX1_EXT 0x80E2
-#define GL_COLOR_INDEX2_EXT 0x80E3
-#define GL_COLOR_INDEX4_EXT 0x80E4
-#define GL_COLOR_INDEX8_EXT 0x80E5
-#define GL_COLOR_INDEX12_EXT 0x80E6
-#define GL_COLOR_INDEX16_EXT 0x80E7
-#define GL_TEXTURE_INDEX_SIZE_EXT 0x80ED
-#define GL_TEXTURE_CUBE_MAP_ARB 0x8513
-#define GL_PROXY_TEXTURE_CUBE_MAP_ARB 0x851B
-#define GL_EXT_pixel_buffer_object 1
-#define GL_PIXEL_PACK_BUFFER_EXT 0x88EB
-#define GL_PIXEL_UNPACK_BUFFER_EXT 0x88EC
-#define GL_PIXEL_PACK_BUFFER_BINDING_EXT 0x88ED
-#define GL_PIXEL_UNPACK_BUFFER_BINDING_EXT 0x88EF
-#define GL_EXT_pixel_transform 1
-#define GL_PIXEL_TRANSFORM_2D_EXT 0x8330
-#define GL_PIXEL_MAG_FILTER_EXT 0x8331
-#define GL_PIXEL_MIN_FILTER_EXT 0x8332
-#define GL_PIXEL_CUBIC_WEIGHT_EXT 0x8333
-#define GL_CUBIC_EXT 0x8334
-#define GL_AVERAGE_EXT 0x8335
-#define GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8336
-#define GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8337
-#define GL_PIXEL_TRANSFORM_2D_MATRIX_EXT 0x8338
-#define GL_EXT_pixel_transform_color_table 1
-#define GL_EXT_point_parameters 1
-#define GL_POINT_SIZE_MIN_EXT 0x8126
-#define GL_POINT_SIZE_MAX_EXT 0x8127
-#define GL_POINT_FADE_THRESHOLD_SIZE_EXT 0x8128
-#define GL_DISTANCE_ATTENUATION_EXT 0x8129
-#define GL_EXT_polygon_offset 1
-#define GL_POLYGON_OFFSET_EXT 0x8037
-#define GL_POLYGON_OFFSET_FACTOR_EXT 0x8038
-#define GL_POLYGON_OFFSET_BIAS_EXT 0x8039
-#define GL_EXT_rescale_normal 1
-#define GL_EXT_scene_marker 1
-#define GL_EXT_secondary_color 1
-#define GL_COLOR_SUM_EXT 0x8458
-#define GL_CURRENT_SECONDARY_COLOR_EXT 0x8459
-#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT 0x845A
-#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT 0x845B
-#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT 0x845C
-#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
-#define GL_SECONDARY_COLOR_ARRAY_EXT 0x845E
-#define GL_EXT_separate_specular_color 1
-#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT 0x81F8
-#define GL_SINGLE_COLOR_EXT 0x81F9
-#define GL_SEPARATE_SPECULAR_COLOR_EXT 0x81FA
-#define GL_EXT_shadow_funcs 1
-#define GL_EXT_shared_texture_palette 1
-#define GL_SHARED_TEXTURE_PALETTE_EXT 0x81FB
-#define GL_EXT_stencil_clear_tag 1
-#define GL_STENCIL_TAG_BITS_EXT 0x88F2
-#define GL_STENCIL_CLEAR_TAG_VALUE_EXT 0x88F3
-#define GL_EXT_stencil_two_side 1
-#define GL_STENCIL_TEST_TWO_SIDE_EXT 0x8910
-#define GL_ACTIVE_STENCIL_FACE_EXT 0x8911
-#define GL_EXT_stencil_wrap 1
-#define GL_INCR_WRAP_EXT 0x8507
-#define GL_DECR_WRAP_EXT 0x8508
-#define GL_EXT_subtexture 1
-#define GL_EXT_texture 1
-#define GL_ALPHA4_EXT 0x803B
-#define GL_ALPHA8_EXT 0x803C
-#define GL_ALPHA12_EXT 0x803D
-#define GL_ALPHA16_EXT 0x803E
-#define GL_LUMINANCE4_EXT 0x803F
-#define GL_LUMINANCE8_EXT 0x8040
-#define GL_LUMINANCE12_EXT 0x8041
-#define GL_LUMINANCE16_EXT 0x8042
-#define GL_LUMINANCE4_ALPHA4_EXT 0x8043
-#define GL_LUMINANCE6_ALPHA2_EXT 0x8044
-#define GL_LUMINANCE8_ALPHA8_EXT 0x8045
-#define GL_LUMINANCE12_ALPHA4_EXT 0x8046
-#define GL_LUMINANCE12_ALPHA12_EXT 0x8047
-#define GL_LUMINANCE16_ALPHA16_EXT 0x8048
-#define GL_INTENSITY_EXT 0x8049
-#define GL_INTENSITY4_EXT 0x804A
-#define GL_INTENSITY8_EXT 0x804B
-#define GL_INTENSITY12_EXT 0x804C
-#define GL_INTENSITY16_EXT 0x804D
-#define GL_RGB2_EXT 0x804E
-#define GL_RGB4_EXT 0x804F
-#define GL_RGB5_EXT 0x8050
-#define GL_RGB8_EXT 0x8051
-#define GL_RGB10_EXT 0x8052
-#define GL_RGB12_EXT 0x8053
-#define GL_RGB16_EXT 0x8054
-#define GL_RGBA2_EXT 0x8055
-#define GL_RGBA4_EXT 0x8056
-#define GL_RGB5_A1_EXT 0x8057
-#define GL_RGBA8_EXT 0x8058
-#define GL_RGB10_A2_EXT 0x8059
-#define GL_RGBA12_EXT 0x805A
-#define GL_RGBA16_EXT 0x805B
-#define GL_TEXTURE_RED_SIZE_EXT 0x805C
-#define GL_TEXTURE_GREEN_SIZE_EXT 0x805D
-#define GL_TEXTURE_BLUE_SIZE_EXT 0x805E
-#define GL_TEXTURE_ALPHA_SIZE_EXT 0x805F
-#define GL_TEXTURE_LUMINANCE_SIZE_EXT 0x8060
-#define GL_TEXTURE_INTENSITY_SIZE_EXT 0x8061
-#define GL_REPLACE_EXT 0x8062
-#define GL_PROXY_TEXTURE_1D_EXT 0x8063
-#define GL_PROXY_TEXTURE_2D_EXT 0x8064
-#define GL_EXT_texture3D 1
-#define GL_PACK_SKIP_IMAGES_EXT 0x806B
-#define GL_PACK_IMAGE_HEIGHT_EXT 0x806C
-#define GL_UNPACK_SKIP_IMAGES_EXT 0x806D
-#define GL_UNPACK_IMAGE_HEIGHT_EXT 0x806E
-#define GL_TEXTURE_3D_EXT 0x806F
-#define GL_PROXY_TEXTURE_3D_EXT 0x8070
-#define GL_TEXTURE_DEPTH_EXT 0x8071
-#define GL_TEXTURE_WRAP_R_EXT 0x8072
-#define GL_MAX_3D_TEXTURE_SIZE_EXT 0x8073
-#define GL_EXT_texture_compression_dxt1 1
-#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
-#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1
-#define GL_EXT_texture_compression_s3tc 1
-#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
-#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1
-#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT 0x83F2
-#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT 0x83F3
-#define GL_EXT_texture_cube_map 1
-#define GL_NORMAL_MAP_EXT 0x8511
-#define GL_REFLECTION_MAP_EXT 0x8512
-#define GL_TEXTURE_CUBE_MAP_EXT 0x8513
-#define GL_TEXTURE_BINDING_CUBE_MAP_EXT 0x8514
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT 0x8515
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT 0x8516
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT 0x8517
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT 0x8518
-#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT 0x8519
-#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT 0x851A
-#define GL_PROXY_TEXTURE_CUBE_MAP_EXT 0x851B
-#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT 0x851C
-#define GL_EXT_texture_edge_clamp 1
-#define GL_CLAMP_TO_EDGE_EXT 0x812F
-#define GL_EXT_texture_env 1
-#define GL_TEXTURE_ENV0_EXT 0
-#define GL_ENV_BLEND_EXT 0
-#define GL_TEXTURE_ENV_SHIFT_EXT 0
-#define GL_ENV_REPLACE_EXT 0
-#define GL_ENV_ADD_EXT 0
-#define GL_ENV_SUBTRACT_EXT 0
-#define GL_TEXTURE_ENV_MODE_ALPHA_EXT 0
-#define GL_ENV_REVERSE_SUBTRACT_EXT 0
-#define GL_ENV_REVERSE_BLEND_EXT 0
-#define GL_ENV_COPY_EXT 0
-#define GL_ENV_MODULATE_EXT 0
-#define GL_EXT_texture_env_add 1
-#define GL_EXT_texture_env_combine 1
-#define GL_COMBINE_EXT 0x8570
-#define GL_COMBINE_RGB_EXT 0x8571
-#define GL_COMBINE_ALPHA_EXT 0x8572
-#define GL_RGB_SCALE_EXT 0x8573
-#define GL_ADD_SIGNED_EXT 0x8574
-#define GL_INTERPOLATE_EXT 0x8575
-#define GL_CONSTANT_EXT 0x8576
-#define GL_PRIMARY_COLOR_EXT 0x8577
-#define GL_PREVIOUS_EXT 0x8578
-#define GL_SOURCE0_RGB_EXT 0x8580
-#define GL_SOURCE1_RGB_EXT 0x8581
-#define GL_SOURCE2_RGB_EXT 0x8582
-#define GL_SOURCE0_ALPHA_EXT 0x8588
-#define GL_SOURCE1_ALPHA_EXT 0x8589
-#define GL_SOURCE2_ALPHA_EXT 0x858A
-#define GL_OPERAND0_RGB_EXT 0x8590
-#define GL_OPERAND1_RGB_EXT 0x8591
-#define GL_OPERAND2_RGB_EXT 0x8592
-#define GL_OPERAND0_ALPHA_EXT 0x8598
-#define GL_OPERAND1_ALPHA_EXT 0x8599
-#define GL_OPERAND2_ALPHA_EXT 0x859A
-#define GL_EXT_texture_env_dot3 1
-#define GL_DOT3_RGB_EXT 0x8740
-#define GL_DOT3_RGBA_EXT 0x8741
-#define GL_EXT_texture_filter_anisotropic 1
-#define GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
-#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
-#define GL_EXT_texture_lod_bias 1
-#define GL_MAX_TEXTURE_LOD_BIAS_EXT 0x84FD
-#define GL_TEXTURE_FILTER_CONTROL_EXT 0x8500
-#define GL_TEXTURE_LOD_BIAS_EXT 0x8501
-#define GL_EXT_texture_mirror_clamp 1
-#define GL_MIRROR_CLAMP_EXT 0x8742
-#define GL_MIRROR_CLAMP_TO_EDGE_EXT 0x8743
-#define GL_MIRROR_CLAMP_TO_BORDER_EXT 0x8912
-#define GL_EXT_texture_object 1
-#define GL_TEXTURE_PRIORITY_EXT 0x8066
-#define GL_TEXTURE_RESIDENT_EXT 0x8067
-#define GL_TEXTURE_1D_BINDING_EXT 0x8068
-#define GL_TEXTURE_2D_BINDING_EXT 0x8069
-#define GL_TEXTURE_3D_BINDING_EXT 0x806A
-#define GL_EXT_texture_perturb_normal 1
-#define GL_PERTURB_EXT 0x85AE
-#define GL_TEXTURE_NORMAL_EXT 0x85AF
-#define GL_EXT_texture_rectangle 1
-#define GL_TEXTURE_RECTANGLE_EXT 0x84F5
-#define GL_TEXTURE_BINDING_RECTANGLE_EXT 0x84F6
-#define GL_PROXY_TEXTURE_RECTANGLE_EXT 0x84F7
-#define GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT 0x84F8
-#define GL_EXT_texture_sRGB 1
-#define GL_SRGB_EXT 0x8C40
-#define GL_SRGB8_EXT 0x8C41
-#define GL_SRGB_ALPHA_EXT 0x8C42
-#define GL_SRGB8_ALPHA8_EXT 0x8C43
-#define GL_SLUMINANCE_ALPHA_EXT 0x8C44
-#define GL_SLUMINANCE8_ALPHA8_EXT 0x8C45
-#define GL_SLUMINANCE_EXT 0x8C46
-#define GL_SLUMINANCE8_EXT 0x8C47
-#define GL_COMPRESSED_SRGB_EXT 0x8C48
-#define GL_COMPRESSED_SRGB_ALPHA_EXT 0x8C49
-#define GL_COMPRESSED_SLUMINANCE_EXT 0x8C4A
-#define GL_COMPRESSED_SLUMINANCE_ALPHA_EXT 0x8C4B
-#define GL_COMPRESSED_SRGB_S3TC_DXT1_EXT 0x8C4C
-#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT 0x8C4D
-#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT 0x8C4E
-#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT 0x8C4F
-#define GL_EXT_vertex_array 1
-#define GL_DOUBLE_EXT 0x140A
-#define GL_VERTEX_ARRAY_EXT 0x8074
-#define GL_NORMAL_ARRAY_EXT 0x8075
-#define GL_COLOR_ARRAY_EXT 0x8076
-#define GL_INDEX_ARRAY_EXT 0x8077
-#define GL_TEXTURE_COORD_ARRAY_EXT 0x8078
-#define GL_EDGE_FLAG_ARRAY_EXT 0x8079
-#define GL_VERTEX_ARRAY_SIZE_EXT 0x807A
-#define GL_VERTEX_ARRAY_TYPE_EXT 0x807B
-#define GL_VERTEX_ARRAY_STRIDE_EXT 0x807C
-#define GL_VERTEX_ARRAY_COUNT_EXT 0x807D
-#define GL_NORMAL_ARRAY_TYPE_EXT 0x807E
-#define GL_NORMAL_ARRAY_STRIDE_EXT 0x807F
-#define GL_NORMAL_ARRAY_COUNT_EXT 0x8080
-#define GL_COLOR_ARRAY_SIZE_EXT 0x8081
-#define GL_COLOR_ARRAY_TYPE_EXT 0x8082
-#define GL_COLOR_ARRAY_STRIDE_EXT 0x8083
-#define GL_COLOR_ARRAY_COUNT_EXT 0x8084
-#define GL_INDEX_ARRAY_TYPE_EXT 0x8085
-#define GL_INDEX_ARRAY_STRIDE_EXT 0x8086
-#define GL_INDEX_ARRAY_COUNT_EXT 0x8087
-#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT 0x8088
-#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT 0x8089
-#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
-#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT 0x808B
-#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT 0x808C
-#define GL_EDGE_FLAG_ARRAY_COUNT_EXT 0x808D
-#define GL_VERTEX_ARRAY_POINTER_EXT 0x808E
-#define GL_NORMAL_ARRAY_POINTER_EXT 0x808F
-#define GL_COLOR_ARRAY_POINTER_EXT 0x8090
-#define GL_INDEX_ARRAY_POINTER_EXT 0x8091
-#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
-#define GL_EDGE_FLAG_ARRAY_POINTER_EXT 0x8093
-#define GL_EXT_vertex_shader 1
-#define GL_VERTEX_SHADER_EXT 0x8780
-#define GL_VERTEX_SHADER_BINDING_EXT 0x8781
-#define GL_OP_INDEX_EXT 0x8782
-#define GL_OP_NEGATE_EXT 0x8783
-#define GL_OP_DOT3_EXT 0x8784
-#define GL_OP_DOT4_EXT 0x8785
-#define GL_OP_MUL_EXT 0x8786
-#define GL_OP_ADD_EXT 0x8787
-#define GL_OP_MADD_EXT 0x8788
-#define GL_OP_FRAC_EXT 0x8789
-#define GL_OP_MAX_EXT 0x878A
-#define GL_OP_MIN_EXT 0x878B
-#define GL_OP_SET_GE_EXT 0x878C
-#define GL_OP_SET_LT_EXT 0x878D
-#define GL_OP_CLAMP_EXT 0x878E
-#define GL_OP_FLOOR_EXT 0x878F
-#define GL_OP_ROUND_EXT 0x8790
-#define GL_OP_EXP_BASE_2_EXT 0x8791
-#define GL_OP_LOG_BASE_2_EXT 0x8792
-#define GL_OP_POWER_EXT 0x8793
-#define GL_OP_RECIP_EXT 0x8794
-#define GL_OP_RECIP_SQRT_EXT 0x8795
-#define GL_OP_SUB_EXT 0x8796
-#define GL_OP_CROSS_PRODUCT_EXT 0x8797
-#define GL_OP_MULTIPLY_MATRIX_EXT 0x8798
-#define GL_OP_MOV_EXT 0x8799
-#define GL_OUTPUT_VERTEX_EXT 0x879A
-#define GL_OUTPUT_COLOR0_EXT 0x879B
-#define GL_OUTPUT_COLOR1_EXT 0x879C
-#define GL_OUTPUT_TEXTURE_COORD0_EXT 0x879D
-#define GL_OUTPUT_TEXTURE_COORD1_EXT 0x879E
-#define GL_OUTPUT_TEXTURE_COORD2_EXT 0x879F
-#define GL_OUTPUT_TEXTURE_COORD3_EXT 0x87A0
-#define GL_OUTPUT_TEXTURE_COORD4_EXT 0x87A1
-#define GL_OUTPUT_TEXTURE_COORD5_EXT 0x87A2
-#define GL_OUTPUT_TEXTURE_COORD6_EXT 0x87A3
-#define GL_OUTPUT_TEXTURE_COORD7_EXT 0x87A4
-#define GL_OUTPUT_TEXTURE_COORD8_EXT 0x87A5
-#define GL_OUTPUT_TEXTURE_COORD9_EXT 0x87A6
-#define GL_OUTPUT_TEXTURE_COORD10_EXT 0x87A7
-#define GL_OUTPUT_TEXTURE_COORD11_EXT 0x87A8
-#define GL_OUTPUT_TEXTURE_COORD12_EXT 0x87A9
-#define GL_OUTPUT_TEXTURE_COORD13_EXT 0x87AA
-#define GL_OUTPUT_TEXTURE_COORD14_EXT 0x87AB
-#define GL_OUTPUT_TEXTURE_COORD15_EXT 0x87AC
-#define GL_OUTPUT_TEXTURE_COORD16_EXT 0x87AD
-#define GL_OUTPUT_TEXTURE_COORD17_EXT 0x87AE
-#define GL_OUTPUT_TEXTURE_COORD18_EXT 0x87AF
-#define GL_OUTPUT_TEXTURE_COORD19_EXT 0x87B0
-#define GL_OUTPUT_TEXTURE_COORD20_EXT 0x87B1
-#define GL_OUTPUT_TEXTURE_COORD21_EXT 0x87B2
-#define GL_OUTPUT_TEXTURE_COORD22_EXT 0x87B3
-#define GL_OUTPUT_TEXTURE_COORD23_EXT 0x87B4
-#define GL_OUTPUT_TEXTURE_COORD24_EXT 0x87B5
-#define GL_OUTPUT_TEXTURE_COORD25_EXT 0x87B6
-#define GL_OUTPUT_TEXTURE_COORD26_EXT 0x87B7
-#define GL_OUTPUT_TEXTURE_COORD27_EXT 0x87B8
-#define GL_OUTPUT_TEXTURE_COORD28_EXT 0x87B9
-#define GL_OUTPUT_TEXTURE_COORD29_EXT 0x87BA
-#define GL_OUTPUT_TEXTURE_COORD30_EXT 0x87BB
-#define GL_OUTPUT_TEXTURE_COORD31_EXT 0x87BC
-#define GL_OUTPUT_FOG_EXT 0x87BD
-#define GL_SCALAR_EXT 0x87BE
-#define GL_VECTOR_EXT 0x87BF
-#define GL_MATRIX_EXT 0x87C0
-#define GL_VARIANT_EXT 0x87C1
-#define GL_INVARIANT_EXT 0x87C2
-#define GL_LOCAL_CONSTANT_EXT 0x87C3
-#define GL_LOCAL_EXT 0x87C4
-#define GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87C5
-#define GL_MAX_VERTEX_SHADER_VARIANTS_EXT 0x87C6
-#define GL_MAX_VERTEX_SHADER_INVARIANTS_EXT 0x87C7
-#define GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87C8
-#define GL_MAX_VERTEX_SHADER_LOCALS_EXT 0x87C9
-#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CA
-#define GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT 0x87CB
-#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT 0x87CC
-#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87CD
-#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT 0x87CE
-#define GL_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CF
-#define GL_VERTEX_SHADER_VARIANTS_EXT 0x87D0
-#define GL_VERTEX_SHADER_INVARIANTS_EXT 0x87D1
-#define GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87D2
-#define GL_VERTEX_SHADER_LOCALS_EXT 0x87D3
-#define GL_VERTEX_SHADER_OPTIMIZED_EXT 0x87D4
-#define GL_X_EXT 0x87D5
-#define GL_Y_EXT 0x87D6
-#define GL_Z_EXT 0x87D7
-#define GL_W_EXT 0x87D8
-#define GL_NEGATIVE_X_EXT 0x87D9
-#define GL_NEGATIVE_Y_EXT 0x87DA
-#define GL_NEGATIVE_Z_EXT 0x87DB
-#define GL_NEGATIVE_W_EXT 0x87DC
-#define GL_ZERO_EXT 0x87DD
-#define GL_ONE_EXT 0x87DE
-#define GL_NEGATIVE_ONE_EXT 0x87DF
-#define GL_NORMALIZED_RANGE_EXT 0x87E0
-#define GL_FULL_RANGE_EXT 0x87E1
-#define GL_CURRENT_VERTEX_EXT 0x87E2
-#define GL_MVP_MATRIX_EXT 0x87E3
-#define GL_VARIANT_VALUE_EXT 0x87E4
-#define GL_VARIANT_DATATYPE_EXT 0x87E5
-#define GL_VARIANT_ARRAY_STRIDE_EXT 0x87E6
-#define GL_VARIANT_ARRAY_TYPE_EXT 0x87E7
-#define GL_VARIANT_ARRAY_EXT 0x87E8
-#define GL_VARIANT_ARRAY_POINTER_EXT 0x87E9
-#define GL_INVARIANT_VALUE_EXT 0x87EA
-#define GL_INVARIANT_DATATYPE_EXT 0x87EB
-#define GL_LOCAL_CONSTANT_VALUE_EXT 0x87EC
-#define GL_LOCAL_CONSTANT_DATATYPE_EXT 0x87ED
-#define GL_EXT_vertex_weighting 1
-#define GL_MODELVIEW0_STACK_DEPTH_EXT 0x0BA3
-#define GL_MODELVIEW0_MATRIX_EXT 0x0BA6
-#define GL_MODELVIEW0_EXT 0x1700
-#define GL_MODELVIEW1_STACK_DEPTH_EXT 0x8502
-#define GL_MODELVIEW1_MATRIX_EXT 0x8506
-#define GL_VERTEX_WEIGHTING_EXT 0x8509
-#define GL_MODELVIEW1_EXT 0x850A
-#define GL_CURRENT_VERTEX_WEIGHT_EXT 0x850B
-#define GL_VERTEX_WEIGHT_ARRAY_EXT 0x850C
-#define GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT 0x850D
-#define GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT 0x850E
-#define GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT 0x850F
-#define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
-#define GL_GREMEDY_string_marker 1
-#define GL_HP_convolution_border_modes 1
-#define GL_HP_image_transform 1
-#define GL_HP_occlusion_test 1
-#define GL_OCCLUSION_TEST_HP 0x8165
-#define GL_OCCLUSION_TEST_RESULT_HP 0x8166
-#define GL_HP_texture_lighting 1
-#define GL_IBM_cull_vertex 1
-#define GL_CULL_VERTEX_IBM 103050
-#define GL_IBM_multimode_draw_arrays 1
-#define GL_IBM_rasterpos_clip 1
-#define GL_RASTER_POSITION_UNCLIPPED_IBM 103010
-#define GL_IBM_static_data 1
-#define GL_ALL_STATIC_DATA_IBM 103060
-#define GL_STATIC_VERTEX_ARRAY_IBM 103061
-#define GL_IBM_texture_mirrored_repeat 1
-#define GL_MIRRORED_REPEAT_IBM 0x8370
-#define GL_IBM_vertex_array_lists 1
-#define GL_VERTEX_ARRAY_LIST_IBM 103070
-#define GL_NORMAL_ARRAY_LIST_IBM 103071
-#define GL_COLOR_ARRAY_LIST_IBM 103072
-#define GL_INDEX_ARRAY_LIST_IBM 103073
-#define GL_TEXTURE_COORD_ARRAY_LIST_IBM 103074
-#define GL_EDGE_FLAG_ARRAY_LIST_IBM 103075
-#define GL_FOG_COORDINATE_ARRAY_LIST_IBM 103076
-#define GL_SECONDARY_COLOR_ARRAY_LIST_IBM 103077
-#define GL_VERTEX_ARRAY_LIST_STRIDE_IBM 103080
-#define GL_NORMAL_ARRAY_LIST_STRIDE_IBM 103081
-#define GL_COLOR_ARRAY_LIST_STRIDE_IBM 103082
-#define GL_INDEX_ARRAY_LIST_STRIDE_IBM 103083
-#define GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM 103084
-#define GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM 103085
-#define GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM 103086
-#define GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM 103087
-#define GL_INGR_color_clamp 1
-#define GL_RED_MIN_CLAMP_INGR 0x8560
-#define GL_GREEN_MIN_CLAMP_INGR 0x8561
-#define GL_BLUE_MIN_CLAMP_INGR 0x8562
-#define GL_ALPHA_MIN_CLAMP_INGR 0x8563
-#define GL_RED_MAX_CLAMP_INGR 0x8564
-#define GL_GREEN_MAX_CLAMP_INGR 0x8565
-#define GL_BLUE_MAX_CLAMP_INGR 0x8566
-#define GL_ALPHA_MAX_CLAMP_INGR 0x8567
-#define GL_INGR_interlace_read 1
-#define GL_INTERLACE_READ_INGR 0x8568
-#define GL_INTEL_parallel_arrays 1
-#define GL_PARALLEL_ARRAYS_INTEL 0x83F4
-#define GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL 0x83F5
-#define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
-#define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
-#define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
-#define GL_INTEL_texture_scissor 1
-#define GL_KTX_buffer_region 1
-#define GL_KTX_FRONT_REGION 0x0
-#define GL_KTX_BACK_REGION 0x1
-#define GL_KTX_Z_REGION 0x2
-#define GL_KTX_STENCIL_REGION 0x3
-#define GL_MESAX_texture_stack 1
-#define GL_TEXTURE_1D_STACK_MESAX 0x8759
-#define GL_TEXTURE_2D_STACK_MESAX 0x875A
-#define GL_PROXY_TEXTURE_1D_STACK_MESAX 0x875B
-#define GL_PROXY_TEXTURE_2D_STACK_MESAX 0x875C
-#define GL_TEXTURE_1D_STACK_BINDING_MESAX 0x875D
-#define GL_TEXTURE_2D_STACK_BINDING_MESAX 0x875E
-#define GL_MESA_pack_invert 1
-#define GL_PACK_INVERT_MESA 0x8758
-#define GL_MESA_resize_buffers 1
-#define GL_MESA_window_pos 1
-#define GL_MESA_ycbcr_texture 1
-#define GL_UNSIGNED_SHORT_8_8_MESA 0x85BA
-#define GL_UNSIGNED_SHORT_8_8_REV_MESA 0x85BB
-#define GL_YCBCR_MESA 0x8757
-#define GL_NV_blend_square 1
-#define GL_NV_copy_depth_to_color 1
-#define GL_DEPTH_STENCIL_TO_RGBA_NV 0x886E
-#define GL_DEPTH_STENCIL_TO_BGRA_NV 0x886F
-#define GL_NV_depth_clamp 1
-#define GL_DEPTH_CLAMP_NV 0x864F
-#define GL_NV_evaluators 1
-#define GL_EVAL_2D_NV 0x86C0
-#define GL_EVAL_TRIANGULAR_2D_NV 0x86C1
-#define GL_MAP_TESSELLATION_NV 0x86C2
-#define GL_MAP_ATTRIB_U_ORDER_NV 0x86C3
-#define GL_MAP_ATTRIB_V_ORDER_NV 0x86C4
-#define GL_EVAL_FRACTIONAL_TESSELLATION_NV 0x86C5
-#define GL_EVAL_VERTEX_ATTRIB0_NV 0x86C6
-#define GL_EVAL_VERTEX_ATTRIB1_NV 0x86C7
-#define GL_EVAL_VERTEX_ATTRIB2_NV 0x86C8
-#define GL_EVAL_VERTEX_ATTRIB3_NV 0x86C9
-#define GL_EVAL_VERTEX_ATTRIB4_NV 0x86CA
-#define GL_EVAL_VERTEX_ATTRIB5_NV 0x86CB
-#define GL_EVAL_VERTEX_ATTRIB6_NV 0x86CC
-#define GL_EVAL_VERTEX_ATTRIB7_NV 0x86CD
-#define GL_EVAL_VERTEX_ATTRIB8_NV 0x86CE
-#define GL_EVAL_VERTEX_ATTRIB9_NV 0x86CF
-#define GL_EVAL_VERTEX_ATTRIB10_NV 0x86D0
-#define GL_EVAL_VERTEX_ATTRIB11_NV 0x86D1
-#define GL_EVAL_VERTEX_ATTRIB12_NV 0x86D2
-#define GL_EVAL_VERTEX_ATTRIB13_NV 0x86D3
-#define GL_EVAL_VERTEX_ATTRIB14_NV 0x86D4
-#define GL_EVAL_VERTEX_ATTRIB15_NV 0x86D5
-#define GL_MAX_MAP_TESSELLATION_NV 0x86D6
-#define GL_MAX_RATIONAL_EVAL_ORDER_NV 0x86D7
-#define GL_NV_fence 1
-#define GL_ALL_COMPLETED_NV 0x84F2
-#define GL_FENCE_STATUS_NV 0x84F3
-#define GL_FENCE_CONDITION_NV 0x84F4
-#define GL_NV_float_buffer 1
-#define GL_FLOAT_R_NV 0x8880
-#define GL_FLOAT_RG_NV 0x8881
-#define GL_FLOAT_RGB_NV 0x8882
-#define GL_FLOAT_RGBA_NV 0x8883
-#define GL_FLOAT_R16_NV 0x8884
-#define GL_FLOAT_R32_NV 0x8885
-#define GL_FLOAT_RG16_NV 0x8886
-#define GL_FLOAT_RG32_NV 0x8887
-#define GL_FLOAT_RGB16_NV 0x8888
-#define GL_FLOAT_RGB32_NV 0x8889
-#define GL_FLOAT_RGBA16_NV 0x888A
-#define GL_FLOAT_RGBA32_NV 0x888B
-#define GL_TEXTURE_FLOAT_COMPONENTS_NV 0x888C
-#define GL_FLOAT_CLEAR_COLOR_VALUE_NV 0x888D
-#define GL_FLOAT_RGBA_MODE_NV 0x888E
-#define GL_NV_fog_distance 1
-#define GL_FOG_DISTANCE_MODE_NV 0x855A
-#define GL_EYE_RADIAL_NV 0x855B
-#define GL_EYE_PLANE_ABSOLUTE_NV 0x855C
-#define GL_NV_fragment_program 1
-#define GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV 0x8868
-#define GL_FRAGMENT_PROGRAM_NV 0x8870
-#define GL_MAX_TEXTURE_COORDS_NV 0x8871
-#define GL_MAX_TEXTURE_IMAGE_UNITS_NV 0x8872
-#define GL_FRAGMENT_PROGRAM_BINDING_NV 0x8873
-#define GL_PROGRAM_ERROR_STRING_NV 0x8874
-#define GL_NV_fragment_program2 1
-#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
-#define GL_MAX_PROGRAM_CALL_DEPTH_NV 0x88F5
-#define GL_MAX_PROGRAM_IF_DEPTH_NV 0x88F6
-#define GL_MAX_PROGRAM_LOOP_DEPTH_NV 0x88F7
-#define GL_MAX_PROGRAM_LOOP_COUNT_NV 0x88F8
-#define GL_NV_fragment_program_option 1
-#define GL_NV_half_float 1
-#define GL_HALF_FLOAT_NV 0x140B
-#define GL_NV_light_max_exponent 1
-#define GL_MAX_SHININESS_NV 0x8504
-#define GL_MAX_SPOT_EXPONENT_NV 0x8505
-#define GL_NV_multisample_filter_hint 1
-#define GL_MULTISAMPLE_FILTER_HINT_NV 0x8534
-#define GL_NV_occlusion_query 1
-#define GL_PIXEL_COUNTER_BITS_NV 0x8864
-#define GL_CURRENT_OCCLUSION_QUERY_ID_NV 0x8865
-#define GL_PIXEL_COUNT_NV 0x8866
-#define GL_PIXEL_COUNT_AVAILABLE_NV 0x8867
-#define GL_NV_packed_depth_stencil 1
-#define GL_DEPTH_STENCIL_NV 0x84F9
-#define GL_UNSIGNED_INT_24_8_NV 0x84FA
-#define GL_NV_pixel_data_range 1
-#define GL_WRITE_PIXEL_DATA_RANGE_NV 0x8878
-#define GL_READ_PIXEL_DATA_RANGE_NV 0x8879
-#define GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV 0x887A
-#define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
-#define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
-#define GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
-#define GL_NV_point_sprite 1
-#define GL_POINT_SPRITE_NV 0x8861
-#define GL_COORD_REPLACE_NV 0x8862
-#define GL_POINT_SPRITE_R_MODE_NV 0x8863
-#define GL_NV_primitive_restart 1
-#define GL_PRIMITIVE_RESTART_NV 0x8558
-#define GL_PRIMITIVE_RESTART_INDEX_NV 0x8559
-#define GL_NV_register_combiners 1
-#define GL_REGISTER_COMBINERS_NV 0x8522
-#define GL_VARIABLE_A_NV 0x8523
-#define GL_VARIABLE_B_NV 0x8524
-#define GL_VARIABLE_C_NV 0x8525
-#define GL_VARIABLE_D_NV 0x8526
-#define GL_VARIABLE_E_NV 0x8527
-#define GL_VARIABLE_F_NV 0x8528
-#define GL_VARIABLE_G_NV 0x8529
-#define GL_CONSTANT_COLOR0_NV 0x852A
-#define GL_CONSTANT_COLOR1_NV 0x852B
-#define GL_PRIMARY_COLOR_NV 0x852C
-#define GL_SECONDARY_COLOR_NV 0x852D
-#define GL_SPARE0_NV 0x852E
-#define GL_SPARE1_NV 0x852F
-#define GL_DISCARD_NV 0x8530
-#define GL_E_TIMES_F_NV 0x8531
-#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
-#define GL_UNSIGNED_IDENTITY_NV 0x8536
-#define GL_UNSIGNED_INVERT_NV 0x8537
-#define GL_EXPAND_NORMAL_NV 0x8538
-#define GL_EXPAND_NEGATE_NV 0x8539
-#define GL_HALF_BIAS_NORMAL_NV 0x853A
-#define GL_HALF_BIAS_NEGATE_NV 0x853B
-#define GL_SIGNED_IDENTITY_NV 0x853C
-#define GL_SIGNED_NEGATE_NV 0x853D
-#define GL_SCALE_BY_TWO_NV 0x853E
-#define GL_SCALE_BY_FOUR_NV 0x853F
-#define GL_SCALE_BY_ONE_HALF_NV 0x8540
-#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV 0x8541
-#define GL_COMBINER_INPUT_NV 0x8542
-#define GL_COMBINER_MAPPING_NV 0x8543
-#define GL_COMBINER_COMPONENT_USAGE_NV 0x8544
-#define GL_COMBINER_AB_DOT_PRODUCT_NV 0x8545
-#define GL_COMBINER_CD_DOT_PRODUCT_NV 0x8546
-#define GL_COMBINER_MUX_SUM_NV 0x8547
-#define GL_COMBINER_SCALE_NV 0x8548
-#define GL_COMBINER_BIAS_NV 0x8549
-#define GL_COMBINER_AB_OUTPUT_NV 0x854A
-#define GL_COMBINER_CD_OUTPUT_NV 0x854B
-#define GL_COMBINER_SUM_OUTPUT_NV 0x854C
-#define GL_MAX_GENERAL_COMBINERS_NV 0x854D
-#define GL_NUM_GENERAL_COMBINERS_NV 0x854E
-#define GL_COLOR_SUM_CLAMP_NV 0x854F
-#define GL_COMBINER0_NV 0x8550
-#define GL_COMBINER1_NV 0x8551
-#define GL_COMBINER2_NV 0x8552
-#define GL_COMBINER3_NV 0x8553
-#define GL_COMBINER4_NV 0x8554
-#define GL_COMBINER5_NV 0x8555
-#define GL_COMBINER6_NV 0x8556
-#define GL_COMBINER7_NV 0x8557
-#define GL_NV_register_combiners2 1
-#define GL_PER_STAGE_CONSTANTS_NV 0x8535
-#define GL_NV_texgen_emboss 1
-#define GL_EMBOSS_LIGHT_NV 0x855D
-#define GL_EMBOSS_CONSTANT_NV 0x855E
-#define GL_EMBOSS_MAP_NV 0x855F
-#define GL_NV_texgen_reflection 1
-#define GL_NORMAL_MAP_NV 0x8511
-#define GL_REFLECTION_MAP_NV 0x8512
-#define GL_NV_texture_compression_vtc 1
-#define GL_NV_texture_env_combine4 1
-#define GL_COMBINE4_NV 0x8503
-#define GL_SOURCE3_RGB_NV 0x8583
-#define GL_SOURCE3_ALPHA_NV 0x858B
-#define GL_OPERAND3_RGB_NV 0x8593
-#define GL_OPERAND3_ALPHA_NV 0x859B
-#define GL_NV_texture_expand_normal 1
-#define GL_TEXTURE_UNSIGNED_REMAP_MODE_NV 0x888F
-#define GL_NV_texture_rectangle 1
-#define GL_TEXTURE_RECTANGLE_NV 0x84F5
-#define GL_TEXTURE_BINDING_RECTANGLE_NV 0x84F6
-#define GL_PROXY_TEXTURE_RECTANGLE_NV 0x84F7
-#define GL_MAX_RECTANGLE_TEXTURE_SIZE_NV 0x84F8
-#define GL_NV_texture_shader 1
-#define GL_OFFSET_TEXTURE_RECTANGLE_NV 0x864C
-#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
-#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
-#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
-#define GL_UNSIGNED_INT_S8_S8_8_8_NV 0x86DA
-#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV 0x86DB
-#define GL_DSDT_MAG_INTENSITY_NV 0x86DC
-#define GL_SHADER_CONSISTENT_NV 0x86DD
-#define GL_TEXTURE_SHADER_NV 0x86DE
-#define GL_SHADER_OPERATION_NV 0x86DF
-#define GL_CULL_MODES_NV 0x86E0
-#define GL_OFFSET_TEXTURE_MATRIX_NV 0x86E1
-#define GL_OFFSET_TEXTURE_SCALE_NV 0x86E2
-#define GL_OFFSET_TEXTURE_BIAS_NV 0x86E3
-#define GL_PREVIOUS_TEXTURE_INPUT_NV 0x86E4
-#define GL_CONST_EYE_NV 0x86E5
-#define GL_PASS_THROUGH_NV 0x86E6
-#define GL_CULL_FRAGMENT_NV 0x86E7
-#define GL_OFFSET_TEXTURE_2D_NV 0x86E8
-#define GL_DEPENDENT_AR_TEXTURE_2D_NV 0x86E9
-#define GL_DEPENDENT_GB_TEXTURE_2D_NV 0x86EA
-#define GL_DOT_PRODUCT_NV 0x86EC
-#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV 0x86ED
-#define GL_DOT_PRODUCT_TEXTURE_2D_NV 0x86EE
-#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
-#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
-#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
-#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
-#define GL_HILO_NV 0x86F4
-#define GL_DSDT_NV 0x86F5
-#define GL_DSDT_MAG_NV 0x86F6
-#define GL_DSDT_MAG_VIB_NV 0x86F7
-#define GL_HILO16_NV 0x86F8
-#define GL_SIGNED_HILO_NV 0x86F9
-#define GL_SIGNED_HILO16_NV 0x86FA
-#define GL_SIGNED_RGBA_NV 0x86FB
-#define GL_SIGNED_RGBA8_NV 0x86FC
-#define GL_SIGNED_RGB_NV 0x86FE
-#define GL_SIGNED_RGB8_NV 0x86FF
-#define GL_SIGNED_LUMINANCE_NV 0x8701
-#define GL_SIGNED_LUMINANCE8_NV 0x8702
-#define GL_SIGNED_LUMINANCE_ALPHA_NV 0x8703
-#define GL_SIGNED_LUMINANCE8_ALPHA8_NV 0x8704
-#define GL_SIGNED_ALPHA_NV 0x8705
-#define GL_SIGNED_ALPHA8_NV 0x8706
-#define GL_SIGNED_INTENSITY_NV 0x8707
-#define GL_SIGNED_INTENSITY8_NV 0x8708
-#define GL_DSDT8_NV 0x8709
-#define GL_DSDT8_MAG8_NV 0x870A
-#define GL_DSDT8_MAG8_INTENSITY8_NV 0x870B
-#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV 0x870C
-#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
-#define GL_HI_SCALE_NV 0x870E
-#define GL_LO_SCALE_NV 0x870F
-#define GL_DS_SCALE_NV 0x8710
-#define GL_DT_SCALE_NV 0x8711
-#define GL_MAGNITUDE_SCALE_NV 0x8712
-#define GL_VIBRANCE_SCALE_NV 0x8713
-#define GL_HI_BIAS_NV 0x8714
-#define GL_LO_BIAS_NV 0x8715
-#define GL_DS_BIAS_NV 0x8716
-#define GL_DT_BIAS_NV 0x8717
-#define GL_MAGNITUDE_BIAS_NV 0x8718
-#define GL_VIBRANCE_BIAS_NV 0x8719
-#define GL_TEXTURE_BORDER_VALUES_NV 0x871A
-#define GL_TEXTURE_HI_SIZE_NV 0x871B
-#define GL_TEXTURE_LO_SIZE_NV 0x871C
-#define GL_TEXTURE_DS_SIZE_NV 0x871D
-#define GL_TEXTURE_DT_SIZE_NV 0x871E
-#define GL_TEXTURE_MAG_SIZE_NV 0x871F
-#define GL_NV_texture_shader2 1
-#define GL_UNSIGNED_INT_S8_S8_8_8_NV 0x86DA
-#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV 0x86DB
-#define GL_DSDT_MAG_INTENSITY_NV 0x86DC
-#define GL_DOT_PRODUCT_TEXTURE_3D_NV 0x86EF
-#define GL_HILO_NV 0x86F4
-#define GL_DSDT_NV 0x86F5
-#define GL_DSDT_MAG_NV 0x86F6
-#define GL_DSDT_MAG_VIB_NV 0x86F7
-#define GL_HILO16_NV 0x86F8
-#define GL_SIGNED_HILO_NV 0x86F9
-#define GL_SIGNED_HILO16_NV 0x86FA
-#define GL_SIGNED_RGBA_NV 0x86FB
-#define GL_SIGNED_RGBA8_NV 0x86FC
-#define GL_SIGNED_RGB_NV 0x86FE
-#define GL_SIGNED_RGB8_NV 0x86FF
-#define GL_SIGNED_LUMINANCE_NV 0x8701
-#define GL_SIGNED_LUMINANCE8_NV 0x8702
-#define GL_SIGNED_LUMINANCE_ALPHA_NV 0x8703
-#define GL_SIGNED_LUMINANCE8_ALPHA8_NV 0x8704
-#define GL_SIGNED_ALPHA_NV 0x8705
-#define GL_SIGNED_ALPHA8_NV 0x8706
-#define GL_SIGNED_INTENSITY_NV 0x8707
-#define GL_SIGNED_INTENSITY8_NV 0x8708
-#define GL_DSDT8_NV 0x8709
-#define GL_DSDT8_MAG8_NV 0x870A
-#define GL_DSDT8_MAG8_INTENSITY8_NV 0x870B
-#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV 0x870C
-#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
-#define GL_NV_texture_shader3 1
-#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
-#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
-#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
-#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
-#define GL_OFFSET_HILO_TEXTURE_2D_NV 0x8854
-#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
-#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
-#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
-#define GL_DEPENDENT_HILO_TEXTURE_2D_NV 0x8858
-#define GL_DEPENDENT_RGB_TEXTURE_3D_NV 0x8859
-#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
-#define GL_DOT_PRODUCT_PASS_THROUGH_NV 0x885B
-#define GL_DOT_PRODUCT_TEXTURE_1D_NV 0x885C
-#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
-#define GL_HILO8_NV 0x885E
-#define GL_SIGNED_HILO8_NV 0x885F
-#define GL_FORCE_BLUE_TO_ONE_NV 0x8860
-#define GL_NV_vertex_array_range 1
-#define GL_VERTEX_ARRAY_RANGE_NV 0x851D
-#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV 0x851E
-#define GL_VERTEX_ARRAY_RANGE_VALID_NV 0x851F
-#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
-#define GL_VERTEX_ARRAY_RANGE_POINTER_NV 0x8521
-#define GL_NV_vertex_array_range2 1
-#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV 0x8533
-#define GL_NV_vertex_program 1
-#define GL_VERTEX_PROGRAM_NV 0x8620
-#define GL_VERTEX_STATE_PROGRAM_NV 0x8621
-#define GL_ATTRIB_ARRAY_SIZE_NV 0x8623
-#define GL_ATTRIB_ARRAY_STRIDE_NV 0x8624
-#define GL_ATTRIB_ARRAY_TYPE_NV 0x8625
-#define GL_CURRENT_ATTRIB_NV 0x8626
-#define GL_PROGRAM_LENGTH_NV 0x8627
-#define GL_PROGRAM_STRING_NV 0x8628
-#define GL_MODELVIEW_PROJECTION_NV 0x8629
-#define GL_IDENTITY_NV 0x862A
-#define GL_INVERSE_NV 0x862B
-#define GL_TRANSPOSE_NV 0x862C
-#define GL_INVERSE_TRANSPOSE_NV 0x862D
-#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
-#define GL_MAX_TRACK_MATRICES_NV 0x862F
-#define GL_MATRIX0_NV 0x8630
-#define GL_MATRIX1_NV 0x8631
-#define GL_MATRIX2_NV 0x8632
-#define GL_MATRIX3_NV 0x8633
-#define GL_MATRIX4_NV 0x8634
-#define GL_MATRIX5_NV 0x8635
-#define GL_MATRIX6_NV 0x8636
-#define GL_MATRIX7_NV 0x8637
-#define GL_CURRENT_MATRIX_STACK_DEPTH_NV 0x8640
-#define GL_CURRENT_MATRIX_NV 0x8641
-#define GL_VERTEX_PROGRAM_POINT_SIZE_NV 0x8642
-#define GL_VERTEX_PROGRAM_TWO_SIDE_NV 0x8643
-#define GL_PROGRAM_PARAMETER_NV 0x8644
-#define GL_ATTRIB_ARRAY_POINTER_NV 0x8645
-#define GL_PROGRAM_TARGET_NV 0x8646
-#define GL_PROGRAM_RESIDENT_NV 0x8647
-#define GL_TRACK_MATRIX_NV 0x8648
-#define GL_TRACK_MATRIX_TRANSFORM_NV 0x8649
-#define GL_VERTEX_PROGRAM_BINDING_NV 0x864A
-#define GL_PROGRAM_ERROR_POSITION_NV 0x864B
-#define GL_VERTEX_ATTRIB_ARRAY0_NV 0x8650
-#define GL_VERTEX_ATTRIB_ARRAY1_NV 0x8651
-#define GL_VERTEX_ATTRIB_ARRAY2_NV 0x8652
-#define GL_VERTEX_ATTRIB_ARRAY3_NV 0x8653
-#define GL_VERTEX_ATTRIB_ARRAY4_NV 0x8654
-#define GL_VERTEX_ATTRIB_ARRAY5_NV 0x8655
-#define GL_VERTEX_ATTRIB_ARRAY6_NV 0x8656
-#define GL_VERTEX_ATTRIB_ARRAY7_NV 0x8657
-#define GL_VERTEX_ATTRIB_ARRAY8_NV 0x8658
-#define GL_VERTEX_ATTRIB_ARRAY9_NV 0x8659
-#define GL_VERTEX_ATTRIB_ARRAY10_NV 0x865A
-#define GL_VERTEX_ATTRIB_ARRAY11_NV 0x865B
-#define GL_VERTEX_ATTRIB_ARRAY12_NV 0x865C
-#define GL_VERTEX_ATTRIB_ARRAY13_NV 0x865D
-#define GL_VERTEX_ATTRIB_ARRAY14_NV 0x865E
-#define GL_VERTEX_ATTRIB_ARRAY15_NV 0x865F
-#define GL_MAP1_VERTEX_ATTRIB0_4_NV 0x8660
-#define GL_MAP1_VERTEX_ATTRIB1_4_NV 0x8661
-#define GL_MAP1_VERTEX_ATTRIB2_4_NV 0x8662
-#define GL_MAP1_VERTEX_ATTRIB3_4_NV 0x8663
-#define GL_MAP1_VERTEX_ATTRIB4_4_NV 0x8664
-#define GL_MAP1_VERTEX_ATTRIB5_4_NV 0x8665
-#define GL_MAP1_VERTEX_ATTRIB6_4_NV 0x8666
-#define GL_MAP1_VERTEX_ATTRIB7_4_NV 0x8667
-#define GL_MAP1_VERTEX_ATTRIB8_4_NV 0x8668
-#define GL_MAP1_VERTEX_ATTRIB9_4_NV 0x8669
-#define GL_MAP1_VERTEX_ATTRIB10_4_NV 0x866A
-#define GL_MAP1_VERTEX_ATTRIB11_4_NV 0x866B
-#define GL_MAP1_VERTEX_ATTRIB12_4_NV 0x866C
-#define GL_MAP1_VERTEX_ATTRIB13_4_NV 0x866D
-#define GL_MAP1_VERTEX_ATTRIB14_4_NV 0x866E
-#define GL_MAP1_VERTEX_ATTRIB15_4_NV 0x866F
-#define GL_MAP2_VERTEX_ATTRIB0_4_NV 0x8670
-#define GL_MAP2_VERTEX_ATTRIB1_4_NV 0x8671
-#define GL_MAP2_VERTEX_ATTRIB2_4_NV 0x8672
-#define GL_MAP2_VERTEX_ATTRIB3_4_NV 0x8673
-#define GL_MAP2_VERTEX_ATTRIB4_4_NV 0x8674
-#define GL_MAP2_VERTEX_ATTRIB5_4_NV 0x8675
-#define GL_MAP2_VERTEX_ATTRIB6_4_NV 0x8676
-#define GL_MAP2_VERTEX_ATTRIB7_4_NV 0x8677
-#define GL_MAP2_VERTEX_ATTRIB8_4_NV 0x8678
-#define GL_MAP2_VERTEX_ATTRIB9_4_NV 0x8679
-#define GL_MAP2_VERTEX_ATTRIB10_4_NV 0x867A
-#define GL_MAP2_VERTEX_ATTRIB11_4_NV 0x867B
-#define GL_MAP2_VERTEX_ATTRIB12_4_NV 0x867C
-#define GL_MAP2_VERTEX_ATTRIB13_4_NV 0x867D
-#define GL_MAP2_VERTEX_ATTRIB14_4_NV 0x867E
-#define GL_MAP2_VERTEX_ATTRIB15_4_NV 0x867F
-#define GL_NV_vertex_program1_1 1
-#define GL_NV_vertex_program2 1
-#define GL_NV_vertex_program2_option 1
-#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
-#define GL_MAX_PROGRAM_CALL_DEPTH_NV 0x88F5
-#define GL_NV_vertex_program3 1
-#define GL_OML_interlace 1
-#define GL_INTERLACE_OML 0x8980
-#define GL_INTERLACE_READ_OML 0x8981
-#define GL_OML_resample 1
-#define GL_PACK_RESAMPLE_OML 0x8984
-#define GL_UNPACK_RESAMPLE_OML 0x8985
-#define GL_RESAMPLE_REPLICATE_OML 0x8986
-#define GL_RESAMPLE_ZERO_FILL_OML 0x8987
-#define GL_RESAMPLE_AVERAGE_OML 0x8988
-#define GL_RESAMPLE_DECIMATE_OML 0x8989
-#define GL_OML_subsample 1
-#define GL_FORMAT_SUBSAMPLE_24_24_OML 0x8982
-#define GL_FORMAT_SUBSAMPLE_244_244_OML 0x8983
-#define GL_PGI_misc_hints 1
-#define GL_PREFER_DOUBLEBUFFER_HINT_PGI 107000
-#define GL_CONSERVE_MEMORY_HINT_PGI 107005
-#define GL_RECLAIM_MEMORY_HINT_PGI 107006
-#define GL_NATIVE_GRAPHICS_HANDLE_PGI 107010
-#define GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI 107011
-#define GL_NATIVE_GRAPHICS_END_HINT_PGI 107012
-#define GL_ALWAYS_FAST_HINT_PGI 107020
-#define GL_ALWAYS_SOFT_HINT_PGI 107021
-#define GL_ALLOW_DRAW_OBJ_HINT_PGI 107022
-#define GL_ALLOW_DRAW_WIN_HINT_PGI 107023
-#define GL_ALLOW_DRAW_FRG_HINT_PGI 107024
-#define GL_ALLOW_DRAW_MEM_HINT_PGI 107025
-#define GL_STRICT_DEPTHFUNC_HINT_PGI 107030
-#define GL_STRICT_LIGHTING_HINT_PGI 107031
-#define GL_STRICT_SCISSOR_HINT_PGI 107032
-#define GL_FULL_STIPPLE_HINT_PGI 107033
-#define GL_CLIP_NEAR_HINT_PGI 107040
-#define GL_CLIP_FAR_HINT_PGI 107041
-#define GL_WIDE_LINE_HINT_PGI 107042
-#define GL_BACK_NORMALS_HINT_PGI 107043
-#define GL_PGI_vertex_hints 1
-#define GL_VERTEX23_BIT_PGI 0x00000004
-#define GL_VERTEX4_BIT_PGI 0x00000008
-#define GL_COLOR3_BIT_PGI 0x00010000
-#define GL_COLOR4_BIT_PGI 0x00020000
-#define GL_EDGEFLAG_BIT_PGI 0x00040000
-#define GL_INDEX_BIT_PGI 0x00080000
-#define GL_MAT_AMBIENT_BIT_PGI 0x00100000
-#define GL_VERTEX_DATA_HINT_PGI 107050
-#define GL_VERTEX_CONSISTENT_HINT_PGI 107051
-#define GL_MATERIAL_SIDE_HINT_PGI 107052
-#define GL_MAX_VERTEX_HINT_PGI 107053
-#define GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI 0x00200000
-#define GL_MAT_DIFFUSE_BIT_PGI 0x00400000
-#define GL_MAT_EMISSION_BIT_PGI 0x00800000
-#define GL_MAT_COLOR_INDEXES_BIT_PGI 0x01000000
-#define GL_MAT_SHININESS_BIT_PGI 0x02000000
-#define GL_MAT_SPECULAR_BIT_PGI 0x04000000
-#define GL_NORMAL_BIT_PGI 0x08000000
-#define GL_TEXCOORD1_BIT_PGI 0x10000000
-#define GL_TEXCOORD2_BIT_PGI 0x20000000
-#define GL_TEXCOORD3_BIT_PGI 0x40000000
-#define GL_TEXCOORD4_BIT_PGI 0x80000000
-#define GL_REND_screen_coordinates 1
-#define GL_SCREEN_COORDINATES_REND 0x8490
-#define GL_INVERTED_SCREEN_W_REND 0x8491
-#define GL_S3_s3tc 1
-#define GL_RGB_S3TC 0x83A0
-#define GL_RGB4_S3TC 0x83A1
-#define GL_RGBA_S3TC 0x83A2
-#define GL_RGBA4_S3TC 0x83A3
-#define GL_RGBA_DXT5_S3TC 0x83A4
-#define GL_RGBA4_DXT5_S3TC 0x83A5
-#define GL_SGIS_color_range 1
-#define GL_EXTENDED_RANGE_SGIS 0x85A5
-#define GL_MIN_RED_SGIS 0x85A6
-#define GL_MAX_RED_SGIS 0x85A7
-#define GL_MIN_GREEN_SGIS 0x85A8
-#define GL_MAX_GREEN_SGIS 0x85A9
-#define GL_MIN_BLUE_SGIS 0x85AA
-#define GL_MAX_BLUE_SGIS 0x85AB
-#define GL_MIN_ALPHA_SGIS 0x85AC
-#define GL_MAX_ALPHA_SGIS 0x85AD
-#define GL_SGIS_detail_texture 1
-#define GL_SGIS_fog_function 1
-#define GL_SGIS_generate_mipmap 1
-#define GL_GENERATE_MIPMAP_SGIS 0x8191
-#define GL_GENERATE_MIPMAP_HINT_SGIS 0x8192
-#define GL_SGIS_multisample 1
-#define GL_MULTISAMPLE_SGIS 0x809D
-#define GL_SAMPLE_ALPHA_TO_MASK_SGIS 0x809E
-#define GL_SAMPLE_ALPHA_TO_ONE_SGIS 0x809F
-#define GL_SAMPLE_MASK_SGIS 0x80A0
-#define GL_1PASS_SGIS 0x80A1
-#define GL_2PASS_0_SGIS 0x80A2
-#define GL_2PASS_1_SGIS 0x80A3
-#define GL_4PASS_0_SGIS 0x80A4
-#define GL_4PASS_1_SGIS 0x80A5
-#define GL_4PASS_2_SGIS 0x80A6
-#define GL_4PASS_3_SGIS 0x80A7
-#define GL_SAMPLE_BUFFERS_SGIS 0x80A8
-#define GL_SAMPLES_SGIS 0x80A9
-#define GL_SAMPLE_MASK_VALUE_SGIS 0x80AA
-#define GL_SAMPLE_MASK_INVERT_SGIS 0x80AB
-#define GL_SAMPLE_PATTERN_SGIS 0x80AC
-#define GL_MULTISAMPLE_BIT_EXT 0x20000000
-#define GL_SGIS_pixel_texture 1
-#define GL_SGIS_sharpen_texture 1
-#define GL_SGIS_texture4D 1
-#define GL_SGIS_texture_border_clamp 1
-#define GL_CLAMP_TO_BORDER_SGIS 0x812D
-#define GL_SGIS_texture_edge_clamp 1
-#define GL_CLAMP_TO_EDGE_SGIS 0x812F
-#define GL_SGIS_texture_filter4 1
-#define GL_SGIS_texture_lod 1
-#define GL_TEXTURE_MIN_LOD_SGIS 0x813A
-#define GL_TEXTURE_MAX_LOD_SGIS 0x813B
-#define GL_TEXTURE_BASE_LEVEL_SGIS 0x813C
-#define GL_TEXTURE_MAX_LEVEL_SGIS 0x813D
-#define GL_SGIS_texture_select 1
-#define GL_SGIX_async 1
-#define GL_ASYNC_MARKER_SGIX 0x8329
-#define GL_SGIX_async_histogram 1
-#define GL_ASYNC_HISTOGRAM_SGIX 0x832C
-#define GL_MAX_ASYNC_HISTOGRAM_SGIX 0x832D
-#define GL_SGIX_async_pixel 1
-#define GL_ASYNC_TEX_IMAGE_SGIX 0x835C
-#define GL_ASYNC_DRAW_PIXELS_SGIX 0x835D
-#define GL_ASYNC_READ_PIXELS_SGIX 0x835E
-#define GL_MAX_ASYNC_TEX_IMAGE_SGIX 0x835F
-#define GL_MAX_ASYNC_DRAW_PIXELS_SGIX 0x8360
-#define GL_MAX_ASYNC_READ_PIXELS_SGIX 0x8361
-#define GL_SGIX_blend_alpha_minmax 1
-#define GL_ALPHA_MIN_SGIX 0x8320
-#define GL_ALPHA_MAX_SGIX 0x8321
-#define GL_SGIX_clipmap 1
-#define GL_SGIX_depth_texture 1
-#define GL_DEPTH_COMPONENT16_SGIX 0x81A5
-#define GL_DEPTH_COMPONENT24_SGIX 0x81A6
-#define GL_DEPTH_COMPONENT32_SGIX 0x81A7
-#define GL_SGIX_flush_raster 1
-#define GL_SGIX_fog_offset 1
-#define GL_FOG_OFFSET_SGIX 0x8198
-#define GL_FOG_OFFSET_VALUE_SGIX 0x8199
-#define GL_SGIX_fog_texture 1
-#define GL_TEXTURE_FOG_SGIX 0
-#define GL_FOG_PATCHY_FACTOR_SGIX 0
-#define GL_FRAGMENT_FOG_SGIX 0
-#define GL_SGIX_fragment_specular_lighting 1
-#define GL_SGIX_framezoom 1
-#define GL_SGIX_interlace 1
-#define GL_INTERLACE_SGIX 0x8094
-#define GL_SGIX_ir_instrument1 1
-#define GL_SGIX_list_priority 1
-#define GL_SGIX_pixel_texture 1
-#define GL_SGIX_pixel_texture_bits 1
-#define GL_SGIX_reference_plane 1
-#define GL_SGIX_resample 1
-#define GL_PACK_RESAMPLE_SGIX 0x842E
-#define GL_UNPACK_RESAMPLE_SGIX 0x842F
-#define GL_RESAMPLE_DECIMATE_SGIX 0x8430
-#define GL_RESAMPLE_REPLICATE_SGIX 0x8433
-#define GL_RESAMPLE_ZERO_FILL_SGIX 0x8434
-#define GL_SGIX_shadow 1
-#define GL_TEXTURE_COMPARE_SGIX 0x819A
-#define GL_TEXTURE_COMPARE_OPERATOR_SGIX 0x819B
-#define GL_TEXTURE_LEQUAL_R_SGIX 0x819C
-#define GL_TEXTURE_GEQUAL_R_SGIX 0x819D
-#define GL_SGIX_shadow_ambient 1
-#define GL_SHADOW_AMBIENT_SGIX 0x80BF
-#define GL_SGIX_sprite 1
-#define GL_SGIX_tag_sample_buffer 1
-#define GL_SGIX_texture_add_env 1
-#define GL_SGIX_texture_coordinate_clamp 1
-#define GL_TEXTURE_MAX_CLAMP_S_SGIX 0x8369
-#define GL_TEXTURE_MAX_CLAMP_T_SGIX 0x836A
-#define GL_TEXTURE_MAX_CLAMP_R_SGIX 0x836B
-#define GL_SGIX_texture_lod_bias 1
-#define GL_SGIX_texture_multi_buffer 1
-#define GL_TEXTURE_MULTI_BUFFER_HINT_SGIX 0x812E
-#define GL_SGIX_texture_range 1
-#define GL_RGB_SIGNED_SGIX 0x85E0
-#define GL_RGBA_SIGNED_SGIX 0x85E1
-#define GL_ALPHA_SIGNED_SGIX 0x85E2
-#define GL_LUMINANCE_SIGNED_SGIX 0x85E3
-#define GL_INTENSITY_SIGNED_SGIX 0x85E4
-#define GL_LUMINANCE_ALPHA_SIGNED_SGIX 0x85E5
-#define GL_RGB16_SIGNED_SGIX 0x85E6
-#define GL_RGBA16_SIGNED_SGIX 0x85E7
-#define GL_ALPHA16_SIGNED_SGIX 0x85E8
-#define GL_LUMINANCE16_SIGNED_SGIX 0x85E9
-#define GL_INTENSITY16_SIGNED_SGIX 0x85EA
-#define GL_LUMINANCE16_ALPHA16_SIGNED_SGIX 0x85EB
-#define GL_RGB_EXTENDED_RANGE_SGIX 0x85EC
-#define GL_RGBA_EXTENDED_RANGE_SGIX 0x85ED
-#define GL_ALPHA_EXTENDED_RANGE_SGIX 0x85EE
-#define GL_LUMINANCE_EXTENDED_RANGE_SGIX 0x85EF
-#define GL_INTENSITY_EXTENDED_RANGE_SGIX 0x85F0
-#define GL_LUMINANCE_ALPHA_EXTENDED_RANGE_SGIX 0x85F1
-#define GL_RGB16_EXTENDED_RANGE_SGIX 0x85F2
-#define GL_RGBA16_EXTENDED_RANGE_SGIX 0x85F3
-#define GL_ALPHA16_EXTENDED_RANGE_SGIX 0x85F4
-#define GL_LUMINANCE16_EXTENDED_RANGE_SGIX 0x85F5
-#define GL_INTENSITY16_EXTENDED_RANGE_SGIX 0x85F6
-#define GL_LUMINANCE16_ALPHA16_EXTENDED_RANGE_SGIX 0x85F7
-#define GL_MIN_LUMINANCE_SGIS 0x85F8
-#define GL_MAX_LUMINANCE_SGIS 0x85F9
-#define GL_MIN_INTENSITY_SGIS 0x85FA
-#define GL_MAX_INTENSITY_SGIS 0x85FB
-#define GL_SGIX_texture_scale_bias 1
-#define GL_POST_TEXTURE_FILTER_BIAS_SGIX 0x8179
-#define GL_POST_TEXTURE_FILTER_SCALE_SGIX 0x817A
-#define GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX 0x817B
-#define GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX 0x817C
-#define GL_SGIX_vertex_preclip 1
-#define GL_VERTEX_PRECLIP_SGIX 0x83EE
-#define GL_VERTEX_PRECLIP_HINT_SGIX 0x83EF
-#define GL_SGIX_vertex_preclip_hint 1
-#define GL_VERTEX_PRECLIP_SGIX 0x83EE
-#define GL_VERTEX_PRECLIP_HINT_SGIX 0x83EF
-#define GL_SGIX_ycrcb 1
-#define GL_SGI_color_matrix 1
-#define GL_COLOR_MATRIX_SGI 0x80B1
-#define GL_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B2
-#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B3
-#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI 0x80B4
-#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0x80B5
-#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0x80B6
-#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0x80B7
-#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI 0x80B8
-#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0x80B9
-#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI 0x80BA
-#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0x80BB
-#define GL_SGI_color_table 1
-#define GL_COLOR_TABLE_SGI 0x80D0
-#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D1
-#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D2
-#define GL_PROXY_COLOR_TABLE_SGI 0x80D3
-#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D4
-#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D5
-#define GL_COLOR_TABLE_SCALE_SGI 0x80D6
-#define GL_COLOR_TABLE_BIAS_SGI 0x80D7
-#define GL_COLOR_TABLE_FORMAT_SGI 0x80D8
-#define GL_COLOR_TABLE_WIDTH_SGI 0x80D9
-#define GL_COLOR_TABLE_RED_SIZE_SGI 0x80DA
-#define GL_COLOR_TABLE_GREEN_SIZE_SGI 0x80DB
-#define GL_COLOR_TABLE_BLUE_SIZE_SGI 0x80DC
-#define GL_COLOR_TABLE_ALPHA_SIZE_SGI 0x80DD
-#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI 0x80DE
-#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI 0x80DF
-#define GL_SGI_texture_color_table 1
-#define GL_TEXTURE_COLOR_TABLE_SGI 0x80BC
-#define GL_PROXY_TEXTURE_COLOR_TABLE_SGI 0x80BD
-#define GL_SUNX_constant_data 1
-#define GL_UNPACK_CONSTANT_DATA_SUNX 0x81D5
-#define GL_TEXTURE_CONSTANT_DATA_SUNX 0x81D6
-#define GL_SUN_convolution_border_modes 1
-#define GL_WRAP_BORDER_SUN 0x81D4
-#define GL_SUN_global_alpha 1
-#define GL_GLOBAL_ALPHA_SUN 0x81D9
-#define GL_GLOBAL_ALPHA_FACTOR_SUN 0x81DA
-#define GL_SUN_mesh_array 1
-#define GL_QUAD_MESH_SUN 0x8614
-#define GL_TRIANGLE_MESH_SUN 0x8615
-#define GL_SUN_read_video_pixels 1
-#define GL_SUN_slice_accum 1
-#define GL_SLICE_ACCUM_SUN 0x85CC
-#define GL_SUN_triangle_list 1
-#define GL_RESTART_SUN 0x01
-#define GL_REPLACE_MIDDLE_SUN 0x02
-#define GL_REPLACE_OLDEST_SUN 0x03
-#define GL_TRIANGLE_LIST_SUN 0x81D7
-#define GL_REPLACEMENT_CODE_SUN 0x81D8
-#define GL_REPLACEMENT_CODE_ARRAY_SUN 0x85C0
-#define GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN 0x85C1
-#define GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN 0x85C2
-#define GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN 0x85C3
-#define GL_R1UI_V3F_SUN 0x85C4
-#define GL_R1UI_C4UB_V3F_SUN 0x85C5
-#define GL_R1UI_C3F_V3F_SUN 0x85C6
-#define GL_R1UI_N3F_V3F_SUN 0x85C7
-#define GL_R1UI_C4F_N3F_V3F_SUN 0x85C8
-#define GL_R1UI_T2F_V3F_SUN 0x85C9
-#define GL_R1UI_T2F_N3F_V3F_SUN 0x85CA
-#define GL_R1UI_T2F_C4F_N3F_V3F_SUN 0x85CB
-#define GL_SUN_vertex 1
-#define GL_WIN_phong_shading 1
-#define GL_PHONG_WIN 0x80EA
-#define GL_PHONG_HINT_WIN 0x80EB
-#define GL_WIN_specular_fog 1
-#define GL_FOG_SPECULAR_TEXTURE_WIN 0x80EC
-#define GL_WIN_swap_hint 1
+#define LOCAL_GL_VERSION_1_1 1
+#define LOCAL_GL_ACCUM 0x0100
+#define LOCAL_GL_LOAD 0x0101
+#define LOCAL_GL_RETURN 0x0102
+#define LOCAL_GL_MULT 0x0103
+#define LOCAL_GL_ADD 0x0104
+#define LOCAL_GL_NEVER 0x0200
+#define LOCAL_GL_LESS 0x0201
+#define LOCAL_GL_EQUAL 0x0202
+#define LOCAL_GL_LEQUAL 0x0203
+#define LOCAL_GL_GREATER 0x0204
+#define LOCAL_GL_NOTEQUAL 0x0205
+#define LOCAL_GL_GEQUAL 0x0206
+#define LOCAL_GL_ALWAYS 0x0207
+#define LOCAL_GL_CURRENT_BIT 0x00000001
+#define LOCAL_GL_POINT_BIT 0x00000002
+#define LOCAL_GL_LINE_BIT 0x00000004
+#define LOCAL_GL_POLYGON_BIT 0x00000008
+#define LOCAL_GL_POLYGON_STIPPLE_BIT 0x00000010
+#define LOCAL_GL_PIXEL_MODE_BIT 0x00000020
+#define LOCAL_GL_LIGHTING_BIT 0x00000040
+#define LOCAL_GL_FOG_BIT 0x00000080
+#define LOCAL_GL_DEPTH_BUFFER_BIT 0x00000100
+#define LOCAL_GL_ACCUM_BUFFER_BIT 0x00000200
+#define LOCAL_GL_STENCIL_BUFFER_BIT 0x00000400
+#define LOCAL_GL_VIEWPORT_BIT 0x00000800
+#define LOCAL_GL_TRANSFORM_BIT 0x00001000
+#define LOCAL_GL_ENABLE_BIT 0x00002000
+#define LOCAL_GL_COLOR_BUFFER_BIT 0x00004000
+#define LOCAL_GL_HINT_BIT 0x00008000
+#define LOCAL_GL_EVAL_BIT 0x00010000
+#define LOCAL_GL_LIST_BIT 0x00020000
+#define LOCAL_GL_TEXTURE_BIT 0x00040000
+#define LOCAL_GL_SCISSOR_BIT 0x00080000
+#define LOCAL_GL_ALL_ATTRIB_BITS 0x000fffff
+#define LOCAL_GL_POINTS 0x0000
+#define LOCAL_GL_LINES 0x0001
+#define LOCAL_GL_LINE_LOOP 0x0002
+#define LOCAL_GL_LINE_STRIP 0x0003
+#define LOCAL_GL_TRIANGLES 0x0004
+#define LOCAL_GL_TRIANGLE_STRIP 0x0005
+#define LOCAL_GL_TRIANGLE_FAN 0x0006
+#define LOCAL_GL_QUADS 0x0007
+#define LOCAL_GL_QUAD_STRIP 0x0008
+#define LOCAL_GL_POLYGON 0x0009
+#define LOCAL_GL_ZERO 0
+#define LOCAL_GL_ONE 1
+#define LOCAL_GL_SRC_COLOR 0x0300
+#define LOCAL_GL_ONE_MINUS_SRC_COLOR 0x0301
+#define LOCAL_GL_SRC_ALPHA 0x0302
+#define LOCAL_GL_ONE_MINUS_SRC_ALPHA 0x0303
+#define LOCAL_GL_DST_ALPHA 0x0304
+#define LOCAL_GL_ONE_MINUS_DST_ALPHA 0x0305
+#define LOCAL_GL_DST_COLOR 0x0306
+#define LOCAL_GL_ONE_MINUS_DST_COLOR 0x0307
+#define LOCAL_GL_SRC_ALPHA_SATURATE 0x0308
+#define LOCAL_GL_TRUE 1
+#define LOCAL_GL_FALSE 0
+#define LOCAL_GL_CLIP_PLANE0 0x3000
+#define LOCAL_GL_CLIP_PLANE1 0x3001
+#define LOCAL_GL_CLIP_PLANE2 0x3002
+#define LOCAL_GL_CLIP_PLANE3 0x3003
+#define LOCAL_GL_CLIP_PLANE4 0x3004
+#define LOCAL_GL_CLIP_PLANE5 0x3005
+#define LOCAL_GL_BYTE 0x1400
+#define LOCAL_GL_UNSIGNED_BYTE 0x1401
+#define LOCAL_GL_SHORT 0x1402
+#define LOCAL_GL_UNSIGNED_SHORT 0x1403
+#define LOCAL_GL_INT 0x1404
+#define LOCAL_GL_UNSIGNED_INT 0x1405
+#define LOCAL_GL_FLOAT 0x1406
+#define LOCAL_GL_2_BYTES 0x1407
+#define LOCAL_GL_3_BYTES 0x1408
+#define LOCAL_GL_4_BYTES 0x1409
+#define LOCAL_GL_DOUBLE 0x140A
+#define LOCAL_GL_NONE 0
+#define LOCAL_GL_FRONT_LEFT 0x0400
+#define LOCAL_GL_FRONT_RIGHT 0x0401
+#define LOCAL_GL_BACK_LEFT 0x0402
+#define LOCAL_GL_BACK_RIGHT 0x0403
+#define LOCAL_GL_FRONT 0x0404
+#define LOCAL_GL_BACK 0x0405
+#define LOCAL_GL_LEFT 0x0406
+#define LOCAL_GL_RIGHT 0x0407
+#define LOCAL_GL_FRONT_AND_BACK 0x0408
+#define LOCAL_GL_AUX0 0x0409
+#define LOCAL_GL_AUX1 0x040A
+#define LOCAL_GL_AUX2 0x040B
+#define LOCAL_GL_AUX3 0x040C
+#define LOCAL_GL_NO_ERROR 0
+#define LOCAL_GL_INVALID_ENUM 0x0500
+#define LOCAL_GL_INVALID_VALUE 0x0501
+#define LOCAL_GL_INVALID_OPERATION 0x0502
+#define LOCAL_GL_STACK_OVERFLOW 0x0503
+#define LOCAL_GL_STACK_UNDERFLOW 0x0504
+#define LOCAL_GL_OUT_OF_MEMORY 0x0505
+#define LOCAL_GL_2D 0x0600
+#define LOCAL_GL_3D 0x0601
+#define LOCAL_GL_3D_COLOR 0x0602
+#define LOCAL_GL_3D_COLOR_TEXTURE 0x0603
+#define LOCAL_GL_4D_COLOR_TEXTURE 0x0604
+#define LOCAL_GL_PASS_THROUGH_TOKEN 0x0700
+#define LOCAL_GL_POINT_TOKEN 0x0701
+#define LOCAL_GL_LINE_TOKEN 0x0702
+#define LOCAL_GL_POLYGON_TOKEN 0x0703
+#define LOCAL_GL_BITMAP_TOKEN 0x0704
+#define LOCAL_GL_DRAW_PIXEL_TOKEN 0x0705
+#define LOCAL_GL_COPY_PIXEL_TOKEN 0x0706
+#define LOCAL_GL_LINE_RESET_TOKEN 0x0707
+#define LOCAL_GL_EXP 0x0800
+#define LOCAL_GL_EXP2 0x0801
+#define LOCAL_GL_CW 0x0900
+#define LOCAL_GL_CCW 0x0901
+#define LOCAL_GL_COEFF 0x0A00
+#define LOCAL_GL_ORDER 0x0A01
+#define LOCAL_GL_DOMAIN 0x0A02
+#define LOCAL_GL_CURRENT_COLOR 0x0B00
+#define LOCAL_GL_CURRENT_INDEX 0x0B01
+#define LOCAL_GL_CURRENT_NORMAL 0x0B02
+#define LOCAL_GL_CURRENT_TEXTURE_COORDS 0x0B03
+#define LOCAL_GL_CURRENT_RASTER_COLOR 0x0B04
+#define LOCAL_GL_CURRENT_RASTER_INDEX 0x0B05
+#define LOCAL_GL_CURRENT_RASTER_TEXTURE_COORDS 0x0B06
+#define LOCAL_GL_CURRENT_RASTER_POSITION 0x0B07
+#define LOCAL_GL_CURRENT_RASTER_POSITION_VALID 0x0B08
+#define LOCAL_GL_CURRENT_RASTER_DISTANCE 0x0B09
+#define LOCAL_GL_POINT_SMOOTH 0x0B10
+#define LOCAL_GL_POINT_SIZE 0x0B11
+#define LOCAL_GL_POINT_SIZE_RANGE 0x0B12
+#define LOCAL_GL_POINT_SIZE_GRANULARITY 0x0B13
+#define LOCAL_GL_LINE_SMOOTH 0x0B20
+#define LOCAL_GL_LINE_WIDTH 0x0B21
+#define LOCAL_GL_LINE_WIDTH_RANGE 0x0B22
+#define LOCAL_GL_LINE_WIDTH_GRANULARITY 0x0B23
+#define LOCAL_GL_LINE_STIPPLE 0x0B24
+#define LOCAL_GL_LINE_STIPPLE_PATTERN 0x0B25
+#define LOCAL_GL_LINE_STIPPLE_REPEAT 0x0B26
+#define LOCAL_GL_LIST_MODE 0x0B30
+#define LOCAL_GL_MAX_LIST_NESTING 0x0B31
+#define LOCAL_GL_LIST_BASE 0x0B32
+#define LOCAL_GL_LIST_INDEX 0x0B33
+#define LOCAL_GL_POLYGON_MODE 0x0B40
+#define LOCAL_GL_POLYGON_SMOOTH 0x0B41
+#define LOCAL_GL_POLYGON_STIPPLE 0x0B42
+#define LOCAL_GL_EDGE_FLAG 0x0B43
+#define LOCAL_GL_CULL_FACE 0x0B44
+#define LOCAL_GL_CULL_FACE_MODE 0x0B45
+#define LOCAL_GL_FRONT_FACE 0x0B46
+#define LOCAL_GL_LIGHTING 0x0B50
+#define LOCAL_GL_LIGHT_MODEL_LOCAL_VIEWER 0x0B51
+#define LOCAL_GL_LIGHT_MODEL_TWO_SIDE 0x0B52
+#define LOCAL_GL_LIGHT_MODEL_AMBIENT 0x0B53
+#define LOCAL_GL_SHADE_MODEL 0x0B54
+#define LOCAL_GL_COLOR_MATERIAL_FACE 0x0B55
+#define LOCAL_GL_COLOR_MATERIAL_PARAMETER 0x0B56
+#define LOCAL_GL_COLOR_MATERIAL 0x0B57
+#define LOCAL_GL_FOG 0x0B60
+#define LOCAL_GL_FOG_INDEX 0x0B61
+#define LOCAL_GL_FOG_DENSITY 0x0B62
+#define LOCAL_GL_FOG_START 0x0B63
+#define LOCAL_GL_FOG_END 0x0B64
+#define LOCAL_GL_FOG_MODE 0x0B65
+#define LOCAL_GL_FOG_COLOR 0x0B66
+#define LOCAL_GL_DEPTH_RANGE 0x0B70
+#define LOCAL_GL_DEPTH_TEST 0x0B71
+#define LOCAL_GL_DEPTH_WRITEMASK 0x0B72
+#define LOCAL_GL_DEPTH_CLEAR_VALUE 0x0B73
+#define LOCAL_GL_DEPTH_FUNC 0x0B74
+#define LOCAL_GL_ACCUM_CLEAR_VALUE 0x0B80
+#define LOCAL_GL_STENCIL_TEST 0x0B90
+#define LOCAL_GL_STENCIL_CLEAR_VALUE 0x0B91
+#define LOCAL_GL_STENCIL_FUNC 0x0B92
+#define LOCAL_GL_STENCIL_VALUE_MASK 0x0B93
+#define LOCAL_GL_STENCIL_FAIL 0x0B94
+#define LOCAL_GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
+#define LOCAL_GL_STENCIL_PASS_DEPTH_PASS 0x0B96
+#define LOCAL_GL_STENCIL_REF 0x0B97
+#define LOCAL_GL_STENCIL_WRITEMASK 0x0B98
+#define LOCAL_GL_MATRIX_MODE 0x0BA0
+#define LOCAL_GL_NORMALIZE 0x0BA1
+#define LOCAL_GL_VIEWPORT 0x0BA2
+#define LOCAL_GL_MODELVIEW_STACK_DEPTH 0x0BA3
+#define LOCAL_GL_PROJECTION_STACK_DEPTH 0x0BA4
+#define LOCAL_GL_TEXTURE_STACK_DEPTH 0x0BA5
+#define LOCAL_GL_MODELVIEW_MATRIX 0x0BA6
+#define LOCAL_GL_PROJECTION_MATRIX 0x0BA7
+#define LOCAL_GL_TEXTURE_MATRIX 0x0BA8
+#define LOCAL_GL_ATTRIB_STACK_DEPTH 0x0BB0
+#define LOCAL_GL_CLIENT_ATTRIB_STACK_DEPTH 0x0BB1
+#define LOCAL_GL_ALPHA_TEST 0x0BC0
+#define LOCAL_GL_ALPHA_TEST_FUNC 0x0BC1
+#define LOCAL_GL_ALPHA_TEST_REF 0x0BC2
+#define LOCAL_GL_DITHER 0x0BD0
+#define LOCAL_GL_BLEND_DST 0x0BE0
+#define LOCAL_GL_BLEND_SRC 0x0BE1
+#define LOCAL_GL_BLEND 0x0BE2
+#define LOCAL_GL_LOGIC_OP_MODE 0x0BF0
+#define LOCAL_GL_INDEX_LOGIC_OP 0x0BF1
+#define LOCAL_GL_COLOR_LOGIC_OP 0x0BF2
+#define LOCAL_GL_AUX_BUFFERS 0x0C00
+#define LOCAL_GL_DRAW_BUFFER 0x0C01
+#define LOCAL_GL_READ_BUFFER 0x0C02
+#define LOCAL_GL_SCISSOR_BOX 0x0C10
+#define LOCAL_GL_SCISSOR_TEST 0x0C11
+#define LOCAL_GL_INDEX_CLEAR_VALUE 0x0C20
+#define LOCAL_GL_INDEX_WRITEMASK 0x0C21
+#define LOCAL_GL_COLOR_CLEAR_VALUE 0x0C22
+#define LOCAL_GL_COLOR_WRITEMASK 0x0C23
+#define LOCAL_GL_INDEX_MODE 0x0C30
+#define LOCAL_GL_RGBA_MODE 0x0C31
+#define LOCAL_GL_DOUBLEBUFFER 0x0C32
+#define LOCAL_GL_STEREO 0x0C33
+#define LOCAL_GL_RENDER_MODE 0x0C40
+#define LOCAL_GL_PERSPECTIVE_CORRECTION_HINT 0x0C50
+#define LOCAL_GL_POINT_SMOOTH_HINT 0x0C51
+#define LOCAL_GL_LINE_SMOOTH_HINT 0x0C52
+#define LOCAL_GL_POLYGON_SMOOTH_HINT 0x0C53
+#define LOCAL_GL_FOG_HINT 0x0C54
+#define LOCAL_GL_TEXTURE_GEN_S 0x0C60
+#define LOCAL_GL_TEXTURE_GEN_T 0x0C61
+#define LOCAL_GL_TEXTURE_GEN_R 0x0C62
+#define LOCAL_GL_TEXTURE_GEN_Q 0x0C63
+#define LOCAL_GL_PIXEL_MAP_I_TO_I 0x0C70
+#define LOCAL_GL_PIXEL_MAP_S_TO_S 0x0C71
+#define LOCAL_GL_PIXEL_MAP_I_TO_R 0x0C72
+#define LOCAL_GL_PIXEL_MAP_I_TO_G 0x0C73
+#define LOCAL_GL_PIXEL_MAP_I_TO_B 0x0C74
+#define LOCAL_GL_PIXEL_MAP_I_TO_A 0x0C75
+#define LOCAL_GL_PIXEL_MAP_R_TO_R 0x0C76
+#define LOCAL_GL_PIXEL_MAP_G_TO_G 0x0C77
+#define LOCAL_GL_PIXEL_MAP_B_TO_B 0x0C78
+#define LOCAL_GL_PIXEL_MAP_A_TO_A 0x0C79
+#define LOCAL_GL_PIXEL_MAP_I_TO_I_SIZE 0x0CB0
+#define LOCAL_GL_PIXEL_MAP_S_TO_S_SIZE 0x0CB1
+#define LOCAL_GL_PIXEL_MAP_I_TO_R_SIZE 0x0CB2
+#define LOCAL_GL_PIXEL_MAP_I_TO_G_SIZE 0x0CB3
+#define LOCAL_GL_PIXEL_MAP_I_TO_B_SIZE 0x0CB4
+#define LOCAL_GL_PIXEL_MAP_I_TO_A_SIZE 0x0CB5
+#define LOCAL_GL_PIXEL_MAP_R_TO_R_SIZE 0x0CB6
+#define LOCAL_GL_PIXEL_MAP_G_TO_G_SIZE 0x0CB7
+#define LOCAL_GL_PIXEL_MAP_B_TO_B_SIZE 0x0CB8
+#define LOCAL_GL_PIXEL_MAP_A_TO_A_SIZE 0x0CB9
+#define LOCAL_GL_UNPACK_SWAP_BYTES 0x0CF0
+#define LOCAL_GL_UNPACK_LSB_FIRST 0x0CF1
+#define LOCAL_GL_UNPACK_ROW_LENGTH 0x0CF2
+#define LOCAL_GL_UNPACK_SKIP_ROWS 0x0CF3
+#define LOCAL_GL_UNPACK_SKIP_PIXELS 0x0CF4
+#define LOCAL_GL_UNPACK_ALIGNMENT 0x0CF5
+#define LOCAL_GL_PACK_SWAP_BYTES 0x0D00
+#define LOCAL_GL_PACK_LSB_FIRST 0x0D01
+#define LOCAL_GL_PACK_ROW_LENGTH 0x0D02
+#define LOCAL_GL_PACK_SKIP_ROWS 0x0D03
+#define LOCAL_GL_PACK_SKIP_PIXELS 0x0D04
+#define LOCAL_GL_PACK_ALIGNMENT 0x0D05
+#define LOCAL_GL_MAP_COLOR 0x0D10
+#define LOCAL_GL_MAP_STENCIL 0x0D11
+#define LOCAL_GL_INDEX_SHIFT 0x0D12
+#define LOCAL_GL_INDEX_OFFSET 0x0D13
+#define LOCAL_GL_RED_SCALE 0x0D14
+#define LOCAL_GL_RED_BIAS 0x0D15
+#define LOCAL_GL_ZOOM_X 0x0D16
+#define LOCAL_GL_ZOOM_Y 0x0D17
+#define LOCAL_GL_GREEN_SCALE 0x0D18
+#define LOCAL_GL_GREEN_BIAS 0x0D19
+#define LOCAL_GL_BLUE_SCALE 0x0D1A
+#define LOCAL_GL_BLUE_BIAS 0x0D1B
+#define LOCAL_GL_ALPHA_SCALE 0x0D1C
+#define LOCAL_GL_ALPHA_BIAS 0x0D1D
+#define LOCAL_GL_DEPTH_SCALE 0x0D1E
+#define LOCAL_GL_DEPTH_BIAS 0x0D1F
+#define LOCAL_GL_MAX_EVAL_ORDER 0x0D30
+#define LOCAL_GL_MAX_LIGHTS 0x0D31
+#define LOCAL_GL_MAX_CLIP_PLANES 0x0D32
+#define LOCAL_GL_MAX_TEXTURE_SIZE 0x0D33
+#define LOCAL_GL_MAX_PIXEL_MAP_TABLE 0x0D34
+#define LOCAL_GL_MAX_ATTRIB_STACK_DEPTH 0x0D35
+#define LOCAL_GL_MAX_MODELVIEW_STACK_DEPTH 0x0D36
+#define LOCAL_GL_MAX_NAME_STACK_DEPTH 0x0D37
+#define LOCAL_GL_MAX_PROJECTION_STACK_DEPTH 0x0D38
+#define LOCAL_GL_MAX_TEXTURE_STACK_DEPTH 0x0D39
+#define LOCAL_GL_MAX_VIEWPORT_DIMS 0x0D3A
+#define LOCAL_GL_MAX_CLIENT_ATTRIB_STACK_DEPTH 0x0D3B
+#define LOCAL_GL_SUBPIXEL_BITS 0x0D50
+#define LOCAL_GL_INDEX_BITS 0x0D51
+#define LOCAL_GL_RED_BITS 0x0D52
+#define LOCAL_GL_GREEN_BITS 0x0D53
+#define LOCAL_GL_BLUE_BITS 0x0D54
+#define LOCAL_GL_ALPHA_BITS 0x0D55
+#define LOCAL_GL_DEPTH_BITS 0x0D56
+#define LOCAL_GL_STENCIL_BITS 0x0D57
+#define LOCAL_GL_ACCUM_RED_BITS 0x0D58
+#define LOCAL_GL_ACCUM_GREEN_BITS 0x0D59
+#define LOCAL_GL_ACCUM_BLUE_BITS 0x0D5A
+#define LOCAL_GL_ACCUM_ALPHA_BITS 0x0D5B
+#define LOCAL_GL_NAME_STACK_DEPTH 0x0D70
+#define LOCAL_GL_AUTO_NORMAL 0x0D80
+#define LOCAL_GL_MAP1_COLOR_4 0x0D90
+#define LOCAL_GL_MAP1_INDEX 0x0D91
+#define LOCAL_GL_MAP1_NORMAL 0x0D92
+#define LOCAL_GL_MAP1_TEXTURE_COORD_1 0x0D93
+#define LOCAL_GL_MAP1_TEXTURE_COORD_2 0x0D94
+#define LOCAL_GL_MAP1_TEXTURE_COORD_3 0x0D95
+#define LOCAL_GL_MAP1_TEXTURE_COORD_4 0x0D96
+#define LOCAL_GL_MAP1_VERTEX_3 0x0D97
+#define LOCAL_GL_MAP1_VERTEX_4 0x0D98
+#define LOCAL_GL_MAP2_COLOR_4 0x0DB0
+#define LOCAL_GL_MAP2_INDEX 0x0DB1
+#define LOCAL_GL_MAP2_NORMAL 0x0DB2
+#define LOCAL_GL_MAP2_TEXTURE_COORD_1 0x0DB3
+#define LOCAL_GL_MAP2_TEXTURE_COORD_2 0x0DB4
+#define LOCAL_GL_MAP2_TEXTURE_COORD_3 0x0DB5
+#define LOCAL_GL_MAP2_TEXTURE_COORD_4 0x0DB6
+#define LOCAL_GL_MAP2_VERTEX_3 0x0DB7
+#define LOCAL_GL_MAP2_VERTEX_4 0x0DB8
+#define LOCAL_GL_MAP1_GRID_DOMAIN 0x0DD0
+#define LOCAL_GL_MAP1_GRID_SEGMENTS 0x0DD1
+#define LOCAL_GL_MAP2_GRID_DOMAIN 0x0DD2
+#define LOCAL_GL_MAP2_GRID_SEGMENTS 0x0DD3
+#define LOCAL_GL_TEXTURE_1D 0x0DE0
+#define LOCAL_GL_TEXTURE_2D 0x0DE1
+#define LOCAL_GL_FEEDBACK_BUFFER_POINTER 0x0DF0
+#define LOCAL_GL_FEEDBACK_BUFFER_SIZE 0x0DF1
+#define LOCAL_GL_FEEDBACK_BUFFER_TYPE 0x0DF2
+#define LOCAL_GL_SELECTION_BUFFER_POINTER 0x0DF3
+#define LOCAL_GL_SELECTION_BUFFER_SIZE 0x0DF4
+#define LOCAL_GL_TEXTURE_WIDTH 0x1000
+#define LOCAL_GL_TEXTURE_HEIGHT 0x1001
+#define LOCAL_GL_TEXTURE_INTERNAL_FORMAT 0x1003
+#define LOCAL_GL_TEXTURE_BORDER_COLOR 0x1004
+#define LOCAL_GL_TEXTURE_BORDER 0x1005
+#define LOCAL_GL_DONT_CARE 0x1100
+#define LOCAL_GL_FASTEST 0x1101
+#define LOCAL_GL_NICEST 0x1102
+#define LOCAL_GL_LIGHT0 0x4000
+#define LOCAL_GL_LIGHT1 0x4001
+#define LOCAL_GL_LIGHT2 0x4002
+#define LOCAL_GL_LIGHT3 0x4003
+#define LOCAL_GL_LIGHT4 0x4004
+#define LOCAL_GL_LIGHT5 0x4005
+#define LOCAL_GL_LIGHT6 0x4006
+#define LOCAL_GL_LIGHT7 0x4007
+#define LOCAL_GL_AMBIENT 0x1200
+#define LOCAL_GL_DIFFUSE 0x1201
+#define LOCAL_GL_SPECULAR 0x1202
+#define LOCAL_GL_POSITION 0x1203
+#define LOCAL_GL_SPOT_DIRECTION 0x1204
+#define LOCAL_GL_SPOT_EXPONENT 0x1205
+#define LOCAL_GL_SPOT_CUTOFF 0x1206
+#define LOCAL_GL_CONSTANT_ATTENUATION 0x1207
+#define LOCAL_GL_LINEAR_ATTENUATION 0x1208
+#define LOCAL_GL_QUADRATIC_ATTENUATION 0x1209
+#define LOCAL_GL_COMPILE 0x1300
+#define LOCAL_GL_COMPILE_AND_EXECUTE 0x1301
+#define LOCAL_GL_CLEAR 0x1500
+#define LOCAL_GL_AND 0x1501
+#define LOCAL_GL_AND_REVERSE 0x1502
+#define LOCAL_GL_COPY 0x1503
+#define LOCAL_GL_AND_INVERTED 0x1504
+#define LOCAL_GL_NOOP 0x1505
+#define LOCAL_GL_XOR 0x1506
+#define LOCAL_GL_OR 0x1507
+#define LOCAL_GL_NOR 0x1508
+#define LOCAL_GL_EQUIV 0x1509
+#define LOCAL_GL_INVERT 0x150A
+#define LOCAL_GL_OR_REVERSE 0x150B
+#define LOCAL_GL_COPY_INVERTED 0x150C
+#define LOCAL_GL_OR_INVERTED 0x150D
+#define LOCAL_GL_NAND 0x150E
+#define LOCAL_GL_SET 0x150F
+#define LOCAL_GL_EMISSION 0x1600
+#define LOCAL_GL_SHININESS 0x1601
+#define LOCAL_GL_AMBIENT_AND_DIFFUSE 0x1602
+#define LOCAL_GL_COLOR_INDEXES 0x1603
+#define LOCAL_GL_MODELVIEW 0x1700
+#define LOCAL_GL_PROJECTION 0x1701
+#define LOCAL_GL_TEXTURE 0x1702
+#define LOCAL_GL_COLOR 0x1800
+#define LOCAL_GL_DEPTH 0x1801
+#define LOCAL_GL_STENCIL 0x1802
+#define LOCAL_GL_COLOR_INDEX 0x1900
+#define LOCAL_GL_STENCIL_INDEX 0x1901
+#define LOCAL_GL_DEPTH_COMPONENT 0x1902
+#define LOCAL_GL_RED 0x1903
+#define LOCAL_GL_GREEN 0x1904
+#define LOCAL_GL_BLUE 0x1905
+#define LOCAL_GL_ALPHA 0x1906
+#define LOCAL_GL_RGB 0x1907
+#define LOCAL_GL_RGBA 0x1908
+#define LOCAL_GL_LUMINANCE 0x1909
+#define LOCAL_GL_LUMINANCE_ALPHA 0x190A
+#define LOCAL_GL_BITMAP 0x1A00
+#define LOCAL_GL_POINT 0x1B00
+#define LOCAL_GL_LINE 0x1B01
+#define LOCAL_GL_FILL 0x1B02
+#define LOCAL_GL_RENDER 0x1C00
+#define LOCAL_GL_FEEDBACK 0x1C01
+#define LOCAL_GL_SELECT 0x1C02
+#define LOCAL_GL_FLAT 0x1D00
+#define LOCAL_GL_SMOOTH 0x1D01
+#define LOCAL_GL_KEEP 0x1E00
+#define LOCAL_GL_REPLACE 0x1E01
+#define LOCAL_GL_INCR 0x1E02
+#define LOCAL_GL_DECR 0x1E03
+#define LOCAL_GL_VENDOR 0x1F00
+#define LOCAL_GL_RENDERER 0x1F01
+#define LOCAL_GL_VERSION 0x1F02
+#define LOCAL_GL_EXTENSIONS 0x1F03
+#define LOCAL_GL_S 0x2000
+#define LOCAL_GL_T 0x2001
+#define LOCAL_GL_R 0x2002
+#define LOCAL_GL_Q 0x2003
+#define LOCAL_GL_MODULATE 0x2100
+#define LOCAL_GL_DECAL 0x2101
+#define LOCAL_GL_TEXTURE_ENV_MODE 0x2200
+#define LOCAL_GL_TEXTURE_ENV_COLOR 0x2201
+#define LOCAL_GL_TEXTURE_ENV 0x2300
+#define LOCAL_GL_EYE_LINEAR 0x2400
+#define LOCAL_GL_OBJECT_LINEAR 0x2401
+#define LOCAL_GL_SPHERE_MAP 0x2402
+#define LOCAL_GL_TEXTURE_GEN_MODE 0x2500
+#define LOCAL_GL_OBJECT_PLANE 0x2501
+#define LOCAL_GL_EYE_PLANE 0x2502
+#define LOCAL_GL_NEAREST 0x2600
+#define LOCAL_GL_LINEAR 0x2601
+#define LOCAL_GL_NEAREST_MIPMAP_NEAREST 0x2700
+#define LOCAL_GL_LINEAR_MIPMAP_NEAREST 0x2701
+#define LOCAL_GL_NEAREST_MIPMAP_LINEAR 0x2702
+#define LOCAL_GL_LINEAR_MIPMAP_LINEAR 0x2703
+#define LOCAL_GL_TEXTURE_MAG_FILTER 0x2800
+#define LOCAL_GL_TEXTURE_MIN_FILTER 0x2801
+#define LOCAL_GL_TEXTURE_WRAP_S 0x2802
+#define LOCAL_GL_TEXTURE_WRAP_T 0x2803
+#define LOCAL_GL_CLAMP 0x2900
+#define LOCAL_GL_REPEAT 0x2901
+#define LOCAL_GL_CLIENT_PIXEL_STORE_BIT 0x00000001
+#define LOCAL_GL_CLIENT_VERTEX_ARRAY_BIT 0x00000002
+#define LOCAL_GL_CLIENT_ALL_ATTRIB_BITS 0xffffffff
+#define LOCAL_GL_POLYGON_OFFSET_FACTOR 0x8038
+#define LOCAL_GL_POLYGON_OFFSET_UNITS 0x2A00
+#define LOCAL_GL_POLYGON_OFFSET_POINT 0x2A01
+#define LOCAL_GL_POLYGON_OFFSET_LINE 0x2A02
+#define LOCAL_GL_POLYGON_OFFSET_FILL 0x8037
+#define LOCAL_GL_ALPHA4 0x803B
+#define LOCAL_GL_ALPHA8 0x803C
+#define LOCAL_GL_ALPHA12 0x803D
+#define LOCAL_GL_ALPHA16 0x803E
+#define LOCAL_GL_LUMINANCE4 0x803F
+#define LOCAL_GL_LUMINANCE8 0x8040
+#define LOCAL_GL_LUMINANCE12 0x8041
+#define LOCAL_GL_LUMINANCE16 0x8042
+#define LOCAL_GL_LUMINANCE4_ALPHA4 0x8043
+#define LOCAL_GL_LUMINANCE6_ALPHA2 0x8044
+#define LOCAL_GL_LUMINANCE8_ALPHA8 0x8045
+#define LOCAL_GL_LUMINANCE12_ALPHA4 0x8046
+#define LOCAL_GL_LUMINANCE12_ALPHA12 0x8047
+#define LOCAL_GL_LUMINANCE16_ALPHA16 0x8048
+#define LOCAL_GL_INTENSITY 0x8049
+#define LOCAL_GL_INTENSITY4 0x804A
+#define LOCAL_GL_INTENSITY8 0x804B
+#define LOCAL_GL_INTENSITY12 0x804C
+#define LOCAL_GL_INTENSITY16 0x804D
+#define LOCAL_GL_R3_G3_B2 0x2A10
+#define LOCAL_GL_RGB4 0x804F
+#define LOCAL_GL_RGB5 0x8050
+#define LOCAL_GL_RGB8 0x8051
+#define LOCAL_GL_RGB10 0x8052
+#define LOCAL_GL_RGB12 0x8053
+#define LOCAL_GL_RGB16 0x8054
+#define LOCAL_GL_RGBA2 0x8055
+#define LOCAL_GL_RGBA4 0x8056
+#define LOCAL_GL_RGB5_A1 0x8057
+#define LOCAL_GL_RGBA8 0x8058
+#define LOCAL_GL_RGB10_A2 0x8059
+#define LOCAL_GL_RGBA12 0x805A
+#define LOCAL_GL_RGBA16 0x805B
+#define LOCAL_GL_TEXTURE_RED_SIZE 0x805C
+#define LOCAL_GL_TEXTURE_GREEN_SIZE 0x805D
+#define LOCAL_GL_TEXTURE_BLUE_SIZE 0x805E
+#define LOCAL_GL_TEXTURE_ALPHA_SIZE 0x805F
+#define LOCAL_GL_TEXTURE_LUMINANCE_SIZE 0x8060
+#define LOCAL_GL_TEXTURE_INTENSITY_SIZE 0x8061
+#define LOCAL_GL_PROXY_TEXTURE_1D 0x8063
+#define LOCAL_GL_PROXY_TEXTURE_2D 0x8064
+#define LOCAL_GL_TEXTURE_PRIORITY 0x8066
+#define LOCAL_GL_TEXTURE_RESIDENT 0x8067
+#define LOCAL_GL_TEXTURE_BINDING_1D 0x8068
+#define LOCAL_GL_TEXTURE_BINDING_2D 0x8069
+#define LOCAL_GL_VERTEX_ARRAY 0x8074
+#define LOCAL_GL_NORMAL_ARRAY 0x8075
+#define LOCAL_GL_COLOR_ARRAY 0x8076
+#define LOCAL_GL_INDEX_ARRAY 0x8077
+#define LOCAL_GL_TEXTURE_COORD_ARRAY 0x8078
+#define LOCAL_GL_EDGE_FLAG_ARRAY 0x8079
+#define LOCAL_GL_VERTEX_ARRAY_SIZE 0x807A
+#define LOCAL_GL_VERTEX_ARRAY_TYPE 0x807B
+#define LOCAL_GL_VERTEX_ARRAY_STRIDE 0x807C
+#define LOCAL_GL_NORMAL_ARRAY_TYPE 0x807E
+#define LOCAL_GL_NORMAL_ARRAY_STRIDE 0x807F
+#define LOCAL_GL_COLOR_ARRAY_SIZE 0x8081
+#define LOCAL_GL_COLOR_ARRAY_TYPE 0x8082
+#define LOCAL_GL_COLOR_ARRAY_STRIDE 0x8083
+#define LOCAL_GL_INDEX_ARRAY_TYPE 0x8085
+#define LOCAL_GL_INDEX_ARRAY_STRIDE 0x8086
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_SIZE 0x8088
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_TYPE 0x8089
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_STRIDE 0x808A
+#define LOCAL_GL_EDGE_FLAG_ARRAY_STRIDE 0x808C
+#define LOCAL_GL_VERTEX_ARRAY_POINTER 0x808E
+#define LOCAL_GL_NORMAL_ARRAY_POINTER 0x808F
+#define LOCAL_GL_COLOR_ARRAY_POINTER 0x8090
+#define LOCAL_GL_INDEX_ARRAY_POINTER 0x8091
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_POINTER 0x8092
+#define LOCAL_GL_EDGE_FLAG_ARRAY_POINTER 0x8093
+#define LOCAL_GL_V2F 0x2A20
+#define LOCAL_GL_V3F 0x2A21
+#define LOCAL_GL_C4UB_V2F 0x2A22
+#define LOCAL_GL_C4UB_V3F 0x2A23
+#define LOCAL_GL_C3F_V3F 0x2A24
+#define LOCAL_GL_N3F_V3F 0x2A25
+#define LOCAL_GL_C4F_N3F_V3F 0x2A26
+#define LOCAL_GL_T2F_V3F 0x2A27
+#define LOCAL_GL_T4F_V4F 0x2A28
+#define LOCAL_GL_T2F_C4UB_V3F 0x2A29
+#define LOCAL_GL_T2F_C3F_V3F 0x2A2A
+#define LOCAL_GL_T2F_N3F_V3F 0x2A2B
+#define LOCAL_GL_T2F_C4F_N3F_V3F 0x2A2C
+#define LOCAL_GL_T4F_C4F_N3F_V4F 0x2A2D
+#define LOCAL_GL_LOGIC_OP GL_INDEX_LOGIC_OP
+#define LOCAL_GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT
+#define LOCAL_GL_COLOR_INDEX1_EXT 0x80E2
+#define LOCAL_GL_COLOR_INDEX2_EXT 0x80E3
+#define LOCAL_GL_COLOR_INDEX4_EXT 0x80E4
+#define LOCAL_GL_COLOR_INDEX8_EXT 0x80E5
+#define LOCAL_GL_COLOR_INDEX12_EXT 0x80E6
+#define LOCAL_GL_COLOR_INDEX16_EXT 0x80E7
+#define LOCAL_GL_VERSION_1_2 1
+#define LOCAL_GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
+#define LOCAL_GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
+#define LOCAL_GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
+#define LOCAL_GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
+#define LOCAL_GL_UNSIGNED_BYTE_3_3_2 0x8032
+#define LOCAL_GL_UNSIGNED_SHORT_4_4_4_4 0x8033
+#define LOCAL_GL_UNSIGNED_SHORT_5_5_5_1 0x8034
+#define LOCAL_GL_UNSIGNED_INT_8_8_8_8 0x8035
+#define LOCAL_GL_UNSIGNED_INT_10_10_10_2 0x8036
+#define LOCAL_GL_RESCALE_NORMAL 0x803A
+#define LOCAL_GL_TEXTURE_BINDING_3D 0x806A
+#define LOCAL_GL_PACK_SKIP_IMAGES 0x806B
+#define LOCAL_GL_PACK_IMAGE_HEIGHT 0x806C
+#define LOCAL_GL_UNPACK_SKIP_IMAGES 0x806D
+#define LOCAL_GL_UNPACK_IMAGE_HEIGHT 0x806E
+#define LOCAL_GL_TEXTURE_3D 0x806F
+#define LOCAL_GL_PROXY_TEXTURE_3D 0x8070
+#define LOCAL_GL_TEXTURE_DEPTH 0x8071
+#define LOCAL_GL_TEXTURE_WRAP_R 0x8072
+#define LOCAL_GL_MAX_3D_TEXTURE_SIZE 0x8073
+#define LOCAL_GL_BGR 0x80E0
+#define LOCAL_GL_BGRA 0x80E1
+#define LOCAL_GL_MAX_ELEMENTS_VERTICES 0x80E8
+#define LOCAL_GL_MAX_ELEMENTS_INDICES 0x80E9
+#define LOCAL_GL_CLAMP_TO_EDGE 0x812F
+#define LOCAL_GL_TEXTURE_MIN_LOD 0x813A
+#define LOCAL_GL_TEXTURE_MAX_LOD 0x813B
+#define LOCAL_GL_TEXTURE_BASE_LEVEL 0x813C
+#define LOCAL_GL_TEXTURE_MAX_LEVEL 0x813D
+#define LOCAL_GL_LIGHT_MODEL_COLOR_CONTROL 0x81F8
+#define LOCAL_GL_SINGLE_COLOR 0x81F9
+#define LOCAL_GL_SEPARATE_SPECULAR_COLOR 0x81FA
+#define LOCAL_GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
+#define LOCAL_GL_UNSIGNED_SHORT_5_6_5 0x8363
+#define LOCAL_GL_UNSIGNED_SHORT_5_6_5_REV 0x8364
+#define LOCAL_GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
+#define LOCAL_GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
+#define LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
+#define LOCAL_GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
+#define LOCAL_GL_ALIASED_POINT_SIZE_RANGE 0x846D
+#define LOCAL_GL_ALIASED_LINE_WIDTH_RANGE 0x846E
+#define LOCAL_GL_VERSION_1_3 1
+#define LOCAL_GL_MULTISAMPLE 0x809D
+#define LOCAL_GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
+#define LOCAL_GL_SAMPLE_ALPHA_TO_ONE 0x809F
+#define LOCAL_GL_SAMPLE_COVERAGE 0x80A0
+#define LOCAL_GL_SAMPLE_BUFFERS 0x80A8
+#define LOCAL_GL_SAMPLES 0x80A9
+#define LOCAL_GL_SAMPLE_COVERAGE_VALUE 0x80AA
+#define LOCAL_GL_SAMPLE_COVERAGE_INVERT 0x80AB
+#define LOCAL_GL_CLAMP_TO_BORDER 0x812D
+#define LOCAL_GL_TEXTURE0 0x84C0
+#define LOCAL_GL_TEXTURE1 0x84C1
+#define LOCAL_GL_TEXTURE2 0x84C2
+#define LOCAL_GL_TEXTURE3 0x84C3
+#define LOCAL_GL_TEXTURE4 0x84C4
+#define LOCAL_GL_TEXTURE5 0x84C5
+#define LOCAL_GL_TEXTURE6 0x84C6
+#define LOCAL_GL_TEXTURE7 0x84C7
+#define LOCAL_GL_TEXTURE8 0x84C8
+#define LOCAL_GL_TEXTURE9 0x84C9
+#define LOCAL_GL_TEXTURE10 0x84CA
+#define LOCAL_GL_TEXTURE11 0x84CB
+#define LOCAL_GL_TEXTURE12 0x84CC
+#define LOCAL_GL_TEXTURE13 0x84CD
+#define LOCAL_GL_TEXTURE14 0x84CE
+#define LOCAL_GL_TEXTURE15 0x84CF
+#define LOCAL_GL_TEXTURE16 0x84D0
+#define LOCAL_GL_TEXTURE17 0x84D1
+#define LOCAL_GL_TEXTURE18 0x84D2
+#define LOCAL_GL_TEXTURE19 0x84D3
+#define LOCAL_GL_TEXTURE20 0x84D4
+#define LOCAL_GL_TEXTURE21 0x84D5
+#define LOCAL_GL_TEXTURE22 0x84D6
+#define LOCAL_GL_TEXTURE23 0x84D7
+#define LOCAL_GL_TEXTURE24 0x84D8
+#define LOCAL_GL_TEXTURE25 0x84D9
+#define LOCAL_GL_TEXTURE26 0x84DA
+#define LOCAL_GL_TEXTURE27 0x84DB
+#define LOCAL_GL_TEXTURE28 0x84DC
+#define LOCAL_GL_TEXTURE29 0x84DD
+#define LOCAL_GL_TEXTURE30 0x84DE
+#define LOCAL_GL_TEXTURE31 0x84DF
+#define LOCAL_GL_ACTIVE_TEXTURE 0x84E0
+#define LOCAL_GL_CLIENT_ACTIVE_TEXTURE 0x84E1
+#define LOCAL_GL_MAX_TEXTURE_UNITS 0x84E2
+#define LOCAL_GL_TRANSPOSE_MODELVIEW_MATRIX 0x84E3
+#define LOCAL_GL_TRANSPOSE_PROJECTION_MATRIX 0x84E4
+#define LOCAL_GL_TRANSPOSE_TEXTURE_MATRIX 0x84E5
+#define LOCAL_GL_TRANSPOSE_COLOR_MATRIX 0x84E6
+#define LOCAL_GL_SUBTRACT 0x84E7
+#define LOCAL_GL_COMPRESSED_ALPHA 0x84E9
+#define LOCAL_GL_COMPRESSED_LUMINANCE 0x84EA
+#define LOCAL_GL_COMPRESSED_LUMINANCE_ALPHA 0x84EB
+#define LOCAL_GL_COMPRESSED_INTENSITY 0x84EC
+#define LOCAL_GL_COMPRESSED_RGB 0x84ED
+#define LOCAL_GL_COMPRESSED_RGBA 0x84EE
+#define LOCAL_GL_TEXTURE_COMPRESSION_HINT 0x84EF
+#define LOCAL_GL_NORMAL_MAP 0x8511
+#define LOCAL_GL_REFLECTION_MAP 0x8512
+#define LOCAL_GL_TEXTURE_CUBE_MAP 0x8513
+#define LOCAL_GL_TEXTURE_BINDING_CUBE_MAP 0x8514
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
+#define LOCAL_GL_PROXY_TEXTURE_CUBE_MAP 0x851B
+#define LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
+#define LOCAL_GL_COMBINE 0x8570
+#define LOCAL_GL_COMBINE_RGB 0x8571
+#define LOCAL_GL_COMBINE_ALPHA 0x8572
+#define LOCAL_GL_RGB_SCALE 0x8573
+#define LOCAL_GL_ADD_SIGNED 0x8574
+#define LOCAL_GL_INTERPOLATE 0x8575
+#define LOCAL_GL_CONSTANT 0x8576
+#define LOCAL_GL_PRIMARY_COLOR 0x8577
+#define LOCAL_GL_PREVIOUS 0x8578
+#define LOCAL_GL_SOURCE0_RGB 0x8580
+#define LOCAL_GL_SOURCE1_RGB 0x8581
+#define LOCAL_GL_SOURCE2_RGB 0x8582
+#define LOCAL_GL_SOURCE0_ALPHA 0x8588
+#define LOCAL_GL_SOURCE1_ALPHA 0x8589
+#define LOCAL_GL_SOURCE2_ALPHA 0x858A
+#define LOCAL_GL_OPERAND0_RGB 0x8590
+#define LOCAL_GL_OPERAND1_RGB 0x8591
+#define LOCAL_GL_OPERAND2_RGB 0x8592
+#define LOCAL_GL_OPERAND0_ALPHA 0x8598
+#define LOCAL_GL_OPERAND1_ALPHA 0x8599
+#define LOCAL_GL_OPERAND2_ALPHA 0x859A
+#define LOCAL_GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
+#define LOCAL_GL_TEXTURE_COMPRESSED 0x86A1
+#define LOCAL_GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
+#define LOCAL_GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
+#define LOCAL_GL_DOT3_RGB 0x86AE
+#define LOCAL_GL_DOT3_RGBA 0x86AF
+#define LOCAL_GL_MULTISAMPLE_BIT 0x20000000
+#define LOCAL_GL_VERSION_1_4 1
+#define LOCAL_GL_BLEND_DST_RGB 0x80C8
+#define LOCAL_GL_BLEND_SRC_RGB 0x80C9
+#define LOCAL_GL_BLEND_DST_ALPHA 0x80CA
+#define LOCAL_GL_BLEND_SRC_ALPHA 0x80CB
+#define LOCAL_GL_POINT_SIZE_MIN 0x8126
+#define LOCAL_GL_POINT_SIZE_MAX 0x8127
+#define LOCAL_GL_POINT_FADE_THRESHOLD_SIZE 0x8128
+#define LOCAL_GL_POINT_DISTANCE_ATTENUATION 0x8129
+#define LOCAL_GL_GENERATE_MIPMAP 0x8191
+#define LOCAL_GL_GENERATE_MIPMAP_HINT 0x8192
+#define LOCAL_GL_DEPTH_COMPONENT16 0x81A5
+#define LOCAL_GL_DEPTH_COMPONENT24 0x81A6
+#define LOCAL_GL_DEPTH_COMPONENT32 0x81A7
+#define LOCAL_GL_MIRRORED_REPEAT 0x8370
+#define LOCAL_GL_FOG_COORDINATE_SOURCE 0x8450
+#define LOCAL_GL_FOG_COORDINATE 0x8451
+#define LOCAL_GL_FRAGMENT_DEPTH 0x8452
+#define LOCAL_GL_CURRENT_FOG_COORDINATE 0x8453
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_TYPE 0x8454
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_STRIDE 0x8455
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_POINTER 0x8456
+#define LOCAL_GL_FOG_COORDINATE_ARRAY 0x8457
+#define LOCAL_GL_COLOR_SUM 0x8458
+#define LOCAL_GL_CURRENT_SECONDARY_COLOR 0x8459
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_SIZE 0x845A
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_TYPE 0x845B
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_STRIDE 0x845C
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_POINTER 0x845D
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY 0x845E
+#define LOCAL_GL_MAX_TEXTURE_LOD_BIAS 0x84FD
+#define LOCAL_GL_TEXTURE_FILTER_CONTROL 0x8500
+#define LOCAL_GL_TEXTURE_LOD_BIAS 0x8501
+#define LOCAL_GL_INCR_WRAP 0x8507
+#define LOCAL_GL_DECR_WRAP 0x8508
+#define LOCAL_GL_TEXTURE_DEPTH_SIZE 0x884A
+#define LOCAL_GL_DEPTH_TEXTURE_MODE 0x884B
+#define LOCAL_GL_TEXTURE_COMPARE_MODE 0x884C
+#define LOCAL_GL_TEXTURE_COMPARE_FUNC 0x884D
+#define LOCAL_GL_COMPARE_R_TO_TEXTURE 0x884E
+#define LOCAL_GL_VERSION_1_5 1
+#define LOCAL_GL_FOG_COORD_SRC GL_FOG_COORDINATE_SOURCE
+#define LOCAL_GL_FOG_COORD GL_FOG_COORDINATE
+#define LOCAL_GL_FOG_COORD_ARRAY GL_FOG_COORDINATE_ARRAY
+#define LOCAL_GL_SRC0_RGB GL_SOURCE0_RGB
+#define LOCAL_GL_FOG_COORD_ARRAY_POINTER GL_FOG_COORDINATE_ARRAY_POINTER
+#define LOCAL_GL_FOG_COORD_ARRAY_TYPE GL_FOG_COORDINATE_ARRAY_TYPE
+#define LOCAL_GL_SRC1_ALPHA GL_SOURCE1_ALPHA
+#define LOCAL_GL_CURRENT_FOG_COORD GL_CURRENT_FOG_COORDINATE
+#define LOCAL_GL_FOG_COORD_ARRAY_STRIDE GL_FOG_COORDINATE_ARRAY_STRIDE
+#define LOCAL_GL_SRC0_ALPHA GL_SOURCE0_ALPHA
+#define LOCAL_GL_SRC1_RGB GL_SOURCE1_RGB
+#define LOCAL_GL_FOG_COORD_ARRAY_BUFFER_BINDING GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING
+#define LOCAL_GL_SRC2_ALPHA GL_SOURCE2_ALPHA
+#define LOCAL_GL_SRC2_RGB GL_SOURCE2_RGB
+#define LOCAL_GL_BUFFER_SIZE 0x8764
+#define LOCAL_GL_BUFFER_USAGE 0x8765
+#define LOCAL_GL_QUERY_COUNTER_BITS 0x8864
+#define LOCAL_GL_CURRENT_QUERY 0x8865
+#define LOCAL_GL_QUERY_RESULT 0x8866
+#define LOCAL_GL_QUERY_RESULT_AVAILABLE 0x8867
+#define LOCAL_GL_ARRAY_BUFFER 0x8892
+#define LOCAL_GL_ELEMENT_ARRAY_BUFFER 0x8893
+#define LOCAL_GL_ARRAY_BUFFER_BINDING 0x8894
+#define LOCAL_GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
+#define LOCAL_GL_VERTEX_ARRAY_BUFFER_BINDING 0x8896
+#define LOCAL_GL_NORMAL_ARRAY_BUFFER_BINDING 0x8897
+#define LOCAL_GL_COLOR_ARRAY_BUFFER_BINDING 0x8898
+#define LOCAL_GL_INDEX_ARRAY_BUFFER_BINDING 0x8899
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING 0x889A
+#define LOCAL_GL_EDGE_FLAG_ARRAY_BUFFER_BINDING 0x889B
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING 0x889C
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING 0x889D
+#define LOCAL_GL_WEIGHT_ARRAY_BUFFER_BINDING 0x889E
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
+#define LOCAL_GL_READ_ONLY 0x88B8
+#define LOCAL_GL_WRITE_ONLY 0x88B9
+#define LOCAL_GL_READ_WRITE 0x88BA
+#define LOCAL_GL_BUFFER_ACCESS 0x88BB
+#define LOCAL_GL_BUFFER_MAPPED 0x88BC
+#define LOCAL_GL_BUFFER_MAP_POINTER 0x88BD
+#define LOCAL_GL_STREAM_DRAW 0x88E0
+#define LOCAL_GL_STREAM_READ 0x88E1
+#define LOCAL_GL_STREAM_COPY 0x88E2
+#define LOCAL_GL_STATIC_DRAW 0x88E4
+#define LOCAL_GL_STATIC_READ 0x88E5
+#define LOCAL_GL_STATIC_COPY 0x88E6
+#define LOCAL_GL_DYNAMIC_DRAW 0x88E8
+#define LOCAL_GL_DYNAMIC_READ 0x88E9
+#define LOCAL_GL_DYNAMIC_COPY 0x88EA
+#define LOCAL_GL_SAMPLES_PASSED 0x8914
+#define LOCAL_GL_VERSION_2_0 1
+#ifndef GL_BLEND_EQUATION_RGB
+#define LOCAL_GL_BLEND_EQUATION_RGB GL_BLEND_EQUATION
+#endif
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
+#define LOCAL_GL_CURRENT_VERTEX_ATTRIB 0x8626
+#define LOCAL_GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
+#define LOCAL_GL_VERTEX_PROGRAM_TWO_SIDE 0x8643
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
+#define LOCAL_GL_STENCIL_BACK_FUNC 0x8800
+#define LOCAL_GL_STENCIL_BACK_FAIL 0x8801
+#define LOCAL_GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
+#define LOCAL_GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
+#define LOCAL_GL_MAX_DRAW_BUFFERS 0x8824
+#define LOCAL_GL_DRAW_BUFFER0 0x8825
+#define LOCAL_GL_DRAW_BUFFER1 0x8826
+#define LOCAL_GL_DRAW_BUFFER2 0x8827
+#define LOCAL_GL_DRAW_BUFFER3 0x8828
+#define LOCAL_GL_DRAW_BUFFER4 0x8829
+#define LOCAL_GL_DRAW_BUFFER5 0x882A
+#define LOCAL_GL_DRAW_BUFFER6 0x882B
+#define LOCAL_GL_DRAW_BUFFER7 0x882C
+#define LOCAL_GL_DRAW_BUFFER8 0x882D
+#define LOCAL_GL_DRAW_BUFFER9 0x882E
+#define LOCAL_GL_DRAW_BUFFER10 0x882F
+#define LOCAL_GL_DRAW_BUFFER11 0x8830
+#define LOCAL_GL_DRAW_BUFFER12 0x8831
+#define LOCAL_GL_DRAW_BUFFER13 0x8832
+#define LOCAL_GL_DRAW_BUFFER14 0x8833
+#define LOCAL_GL_DRAW_BUFFER15 0x8834
+#define LOCAL_GL_BLEND_EQUATION_ALPHA 0x883D
+#define LOCAL_GL_POINT_SPRITE 0x8861
+#define LOCAL_GL_COORD_REPLACE 0x8862
+#define LOCAL_GL_MAX_VERTEX_ATTRIBS 0x8869
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
+#define LOCAL_GL_MAX_TEXTURE_COORDS 0x8871
+#define LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
+#define LOCAL_GL_FRAGMENT_SHADER 0x8B30
+#define LOCAL_GL_VERTEX_SHADER 0x8B31
+#define LOCAL_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
+#define LOCAL_GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
+#define LOCAL_GL_MAX_VARYING_FLOATS 0x8B4B
+#define LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
+#define LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
+#define LOCAL_GL_SHADER_TYPE 0x8B4F
+#define LOCAL_GL_FLOAT_VEC2 0x8B50
+#define LOCAL_GL_FLOAT_VEC3 0x8B51
+#define LOCAL_GL_FLOAT_VEC4 0x8B52
+#define LOCAL_GL_INT_VEC2 0x8B53
+#define LOCAL_GL_INT_VEC3 0x8B54
+#define LOCAL_GL_INT_VEC4 0x8B55
+#define LOCAL_GL_BOOL 0x8B56
+#define LOCAL_GL_BOOL_VEC2 0x8B57
+#define LOCAL_GL_BOOL_VEC3 0x8B58
+#define LOCAL_GL_BOOL_VEC4 0x8B59
+#define LOCAL_GL_FLOAT_MAT2 0x8B5A
+#define LOCAL_GL_FLOAT_MAT3 0x8B5B
+#define LOCAL_GL_FLOAT_MAT4 0x8B5C
+#define LOCAL_GL_SAMPLER_1D 0x8B5D
+#define LOCAL_GL_SAMPLER_2D 0x8B5E
+#define LOCAL_GL_SAMPLER_3D 0x8B5F
+#define LOCAL_GL_SAMPLER_CUBE 0x8B60
+#define LOCAL_GL_SAMPLER_1D_SHADOW 0x8B61
+#define LOCAL_GL_SAMPLER_2D_SHADOW 0x8B62
+#define LOCAL_GL_DELETE_STATUS 0x8B80
+#define LOCAL_GL_COMPILE_STATUS 0x8B81
+#define LOCAL_GL_LINK_STATUS 0x8B82
+#define LOCAL_GL_VALIDATE_STATUS 0x8B83
+#define LOCAL_GL_INFO_LOG_LENGTH 0x8B84
+#define LOCAL_GL_ATTACHED_SHADERS 0x8B85
+#define LOCAL_GL_ACTIVE_UNIFORMS 0x8B86
+#define LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
+#define LOCAL_GL_SHADER_SOURCE_LENGTH 0x8B88
+#define LOCAL_GL_ACTIVE_ATTRIBUTES 0x8B89
+#define LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
+#define LOCAL_GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
+#define LOCAL_GL_SHADING_LANGUAGE_VERSION 0x8B8C
+#define LOCAL_GL_CURRENT_PROGRAM 0x8B8D
+#define LOCAL_GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
+#define LOCAL_GL_LOWER_LEFT 0x8CA1
+#define LOCAL_GL_UPPER_LEFT 0x8CA2
+#define LOCAL_GL_STENCIL_BACK_REF 0x8CA3
+#define LOCAL_GL_STENCIL_BACK_VALUE_MASK 0x8CA4
+#define LOCAL_GL_STENCIL_BACK_WRITEMASK 0x8CA5
+#define LOCAL_GL_3DFX_multisample 1
+#define LOCAL_GL_MULTISAMPLE_3DFX 0x86B2
+#define LOCAL_GL_SAMPLE_BUFFERS_3DFX 0x86B3
+#define LOCAL_GL_SAMPLES_3DFX 0x86B4
+#define LOCAL_GL_MULTISAMPLE_BIT_3DFX 0x20000000
+#define LOCAL_GL_3DFX_tbuffer 1
+#define LOCAL_GL_3DFX_texture_compression_FXT1 1
+#define LOCAL_GL_COMPRESSED_RGB_FXT1_3DFX 0x86B0
+#define LOCAL_GL_COMPRESSED_RGBA_FXT1_3DFX 0x86B1
+#define LOCAL_GL_APPLE_client_storage 1
+#define LOCAL_GL_UNPACK_CLIENT_STORAGE_APPLE 0x85B2
+#define LOCAL_GL_APPLE_element_array 1
+#define LOCAL_GL_ELEMENT_ARRAY_APPLE 0x8768
+#define LOCAL_GL_ELEMENT_ARRAY_TYPE_APPLE 0x8769
+#define LOCAL_GL_ELEMENT_ARRAY_POINTER_APPLE 0x876A
+#define LOCAL_GL_APPLE_fence 1
+#define LOCAL_GL_DRAW_PIXELS_APPLE 0x8A0A
+#define LOCAL_GL_FENCE_APPLE 0x8A0B
+#define LOCAL_GL_APPLE_float_pixels 1
+#define LOCAL_GL_HALF_APPLE 0x140B
+#define LOCAL_GL_RGBA_FLOAT32_APPLE 0x8814
+#define LOCAL_GL_RGB_FLOAT32_APPLE 0x8815
+#define LOCAL_GL_ALPHA_FLOAT32_APPLE 0x8816
+#define LOCAL_GL_INTENSITY_FLOAT32_APPLE 0x8817
+#define LOCAL_GL_LUMINANCE_FLOAT32_APPLE 0x8818
+#define LOCAL_GL_LUMINANCE_ALPHA_FLOAT32_APPLE 0x8819
+#define LOCAL_GL_RGBA_FLOAT16_APPLE 0x881A
+#define LOCAL_GL_RGB_FLOAT16_APPLE 0x881B
+#define LOCAL_GL_ALPHA_FLOAT16_APPLE 0x881C
+#define LOCAL_GL_INTENSITY_FLOAT16_APPLE 0x881D
+#define LOCAL_GL_LUMINANCE_FLOAT16_APPLE 0x881E
+#define LOCAL_GL_LUMINANCE_ALPHA_FLOAT16_APPLE 0x881F
+#define LOCAL_GL_COLOR_FLOAT_APPLE 0x8A0F
+#define LOCAL_GL_APPLE_pixel_buffer 1
+#define LOCAL_GL_MIN_PBUFFER_VIEWPORT_DIMS_APPLE 0x8A10
+#define LOCAL_GL_APPLE_specular_vector 1
+#define LOCAL_GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE 0x85B0
+#define LOCAL_GL_APPLE_texture_range 1
+#define LOCAL_GL_TEXTURE_RANGE_LENGTH_APPLE 0x85B7
+#define LOCAL_GL_TEXTURE_RANGE_POINTER_APPLE 0x85B8
+#define LOCAL_GL_TEXTURE_STORAGE_HINT_APPLE 0x85BC
+#define LOCAL_GL_STORAGE_PRIVATE_APPLE 0x85BD
+#define LOCAL_GL_STORAGE_CACHED_APPLE 0x85BE
+#define LOCAL_GL_STORAGE_SHARED_APPLE 0x85BF
+#define LOCAL_GL_APPLE_transform_hint 1
+#define LOCAL_GL_TRANSFORM_HINT_APPLE 0x85B1
+#define LOCAL_GL_APPLE_vertex_array_object 1
+#define LOCAL_GL_VERTEX_ARRAY_BINDING_APPLE 0x85B5
+#define LOCAL_GL_APPLE_vertex_array_range 1
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_APPLE 0x851D
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE 0x851E
+#define LOCAL_GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
+#define LOCAL_GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_APPLE 0x8520
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
+#define LOCAL_GL_STORAGE_CACHED_APPLE 0x85BE
+#define LOCAL_GL_STORAGE_SHARED_APPLE 0x85BF
+#define LOCAL_GL_APPLE_ycbcr_422 1
+#define LOCAL_GL_YCBCR_422_APPLE 0x85B9
+#define LOCAL_GL_UNSIGNED_SHORT_8_8_APPLE 0x85BA
+#define LOCAL_GL_UNSIGNED_SHORT_8_8_REV_APPLE 0x85BB
+#define LOCAL_GL_ARB_color_buffer_float 1
+#define LOCAL_GL_RGBA_FLOAT_MODE_ARB 0x8820
+#define LOCAL_GL_CLAMP_VERTEX_COLOR_ARB 0x891A
+#define LOCAL_GL_CLAMP_FRAGMENT_COLOR_ARB 0x891B
+#define LOCAL_GL_CLAMP_READ_COLOR_ARB 0x891C
+#define LOCAL_GL_FIXED_ONLY_ARB 0x891D
+#define LOCAL_GL_ARB_depth_texture 1
+#define LOCAL_GL_DEPTH_COMPONENT16_ARB 0x81A5
+#define LOCAL_GL_DEPTH_COMPONENT24_ARB 0x81A6
+#define LOCAL_GL_DEPTH_COMPONENT32_ARB 0x81A7
+#define LOCAL_GL_TEXTURE_DEPTH_SIZE_ARB 0x884A
+#define LOCAL_GL_DEPTH_TEXTURE_MODE_ARB 0x884B
+#define LOCAL_GL_ARB_draw_buffers 1
+#define LOCAL_GL_MAX_DRAW_BUFFERS_ARB 0x8824
+#define LOCAL_GL_DRAW_BUFFER0_ARB 0x8825
+#define LOCAL_GL_DRAW_BUFFER1_ARB 0x8826
+#define LOCAL_GL_DRAW_BUFFER2_ARB 0x8827
+#define LOCAL_GL_DRAW_BUFFER3_ARB 0x8828
+#define LOCAL_GL_DRAW_BUFFER4_ARB 0x8829
+#define LOCAL_GL_DRAW_BUFFER5_ARB 0x882A
+#define LOCAL_GL_DRAW_BUFFER6_ARB 0x882B
+#define LOCAL_GL_DRAW_BUFFER7_ARB 0x882C
+#define LOCAL_GL_DRAW_BUFFER8_ARB 0x882D
+#define LOCAL_GL_DRAW_BUFFER9_ARB 0x882E
+#define LOCAL_GL_DRAW_BUFFER10_ARB 0x882F
+#define LOCAL_GL_DRAW_BUFFER11_ARB 0x8830
+#define LOCAL_GL_DRAW_BUFFER12_ARB 0x8831
+#define LOCAL_GL_DRAW_BUFFER13_ARB 0x8832
+#define LOCAL_GL_DRAW_BUFFER14_ARB 0x8833
+#define LOCAL_GL_DRAW_BUFFER15_ARB 0x8834
+#define LOCAL_GL_ARB_fragment_program 1
+#define LOCAL_GL_FRAGMENT_PROGRAM_ARB 0x8804
+#define LOCAL_GL_PROGRAM_ALU_INSTRUCTIONS_ARB 0x8805
+#define LOCAL_GL_PROGRAM_TEX_INSTRUCTIONS_ARB 0x8806
+#define LOCAL_GL_PROGRAM_TEX_INDIRECTIONS_ARB 0x8807
+#define LOCAL_GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
+#define LOCAL_GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
+#define LOCAL_GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
+#define LOCAL_GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
+#define LOCAL_GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
+#define LOCAL_GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
+#define LOCAL_GL_MAX_TEXTURE_COORDS_ARB 0x8871
+#define LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS_ARB 0x8872
+#define LOCAL_GL_ARB_fragment_program_shadow 1
+#define LOCAL_GL_ARB_fragment_shader 1
+#define LOCAL_GL_FRAGMENT_SHADER_ARB 0x8B30
+#define LOCAL_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB 0x8B49
+#define LOCAL_GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB 0x8B8B
+#define LOCAL_GL_ARB_half_float_pixel 1
+#define LOCAL_GL_HALF_FLOAT_ARB 0x140B
+#define LOCAL_GL_ARB_imaging 1
+#define LOCAL_GL_CONSTANT_COLOR 0x8001
+#define LOCAL_GL_ONE_MINUS_CONSTANT_COLOR 0x8002
+#define LOCAL_GL_CONSTANT_ALPHA 0x8003
+#define LOCAL_GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
+#define LOCAL_GL_BLEND_COLOR 0x8005
+#define LOCAL_GL_FUNC_ADD 0x8006
+#define LOCAL_GL_MIN 0x8007
+#define LOCAL_GL_MAX 0x8008
+#define LOCAL_GL_BLEND_EQUATION 0x8009
+#define LOCAL_GL_FUNC_SUBTRACT 0x800A
+#define LOCAL_GL_FUNC_REVERSE_SUBTRACT 0x800B
+#define LOCAL_GL_CONVOLUTION_1D 0x8010
+#define LOCAL_GL_CONVOLUTION_2D 0x8011
+#define LOCAL_GL_SEPARABLE_2D 0x8012
+#define LOCAL_GL_CONVOLUTION_BORDER_MODE 0x8013
+#define LOCAL_GL_CONVOLUTION_FILTER_SCALE 0x8014
+#define LOCAL_GL_CONVOLUTION_FILTER_BIAS 0x8015
+#define LOCAL_GL_REDUCE 0x8016
+#define LOCAL_GL_CONVOLUTION_FORMAT 0x8017
+#define LOCAL_GL_CONVOLUTION_WIDTH 0x8018
+#define LOCAL_GL_CONVOLUTION_HEIGHT 0x8019
+#define LOCAL_GL_MAX_CONVOLUTION_WIDTH 0x801A
+#define LOCAL_GL_MAX_CONVOLUTION_HEIGHT 0x801B
+#define LOCAL_GL_POST_CONVOLUTION_RED_SCALE 0x801C
+#define LOCAL_GL_POST_CONVOLUTION_GREEN_SCALE 0x801D
+#define LOCAL_GL_POST_CONVOLUTION_BLUE_SCALE 0x801E
+#define LOCAL_GL_POST_CONVOLUTION_ALPHA_SCALE 0x801F
+#define LOCAL_GL_POST_CONVOLUTION_RED_BIAS 0x8020
+#define LOCAL_GL_POST_CONVOLUTION_GREEN_BIAS 0x8021
+#define LOCAL_GL_POST_CONVOLUTION_BLUE_BIAS 0x8022
+#define LOCAL_GL_POST_CONVOLUTION_ALPHA_BIAS 0x8023
+#define LOCAL_GL_HISTOGRAM 0x8024
+#define LOCAL_GL_PROXY_HISTOGRAM 0x8025
+#define LOCAL_GL_HISTOGRAM_WIDTH 0x8026
+#define LOCAL_GL_HISTOGRAM_FORMAT 0x8027
+#define LOCAL_GL_HISTOGRAM_RED_SIZE 0x8028
+#define LOCAL_GL_HISTOGRAM_GREEN_SIZE 0x8029
+#define LOCAL_GL_HISTOGRAM_BLUE_SIZE 0x802A
+#define LOCAL_GL_HISTOGRAM_ALPHA_SIZE 0x802B
+#define LOCAL_GL_HISTOGRAM_LUMINANCE_SIZE 0x802C
+#define LOCAL_GL_HISTOGRAM_SINK 0x802D
+#define LOCAL_GL_MINMAX 0x802E
+#define LOCAL_GL_MINMAX_FORMAT 0x802F
+#define LOCAL_GL_MINMAX_SINK 0x8030
+#define LOCAL_GL_TABLE_TOO_LARGE 0x8031
+#define LOCAL_GL_COLOR_MATRIX 0x80B1
+#define LOCAL_GL_COLOR_MATRIX_STACK_DEPTH 0x80B2
+#define LOCAL_GL_MAX_COLOR_MATRIX_STACK_DEPTH 0x80B3
+#define LOCAL_GL_POST_COLOR_MATRIX_RED_SCALE 0x80B4
+#define LOCAL_GL_POST_COLOR_MATRIX_GREEN_SCALE 0x80B5
+#define LOCAL_GL_POST_COLOR_MATRIX_BLUE_SCALE 0x80B6
+#define LOCAL_GL_POST_COLOR_MATRIX_ALPHA_SCALE 0x80B7
+#define LOCAL_GL_POST_COLOR_MATRIX_RED_BIAS 0x80B8
+#define LOCAL_GL_POST_COLOR_MATRIX_GREEN_BIAS 0x80B9
+#define LOCAL_GL_POST_COLOR_MATRIX_BLUE_BIAS 0x80BA
+#define LOCAL_GL_POST_COLOR_MATRIX_ALPHA_BIAS 0x80BB
+#define LOCAL_GL_COLOR_TABLE 0x80D0
+#define LOCAL_GL_POST_CONVOLUTION_COLOR_TABLE 0x80D1
+#define LOCAL_GL_POST_COLOR_MATRIX_COLOR_TABLE 0x80D2
+#define LOCAL_GL_PROXY_COLOR_TABLE 0x80D3
+#define LOCAL_GL_PROXY_POST_CONVOLUTION_COLOR_TABLE 0x80D4
+#define LOCAL_GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE 0x80D5
+#define LOCAL_GL_COLOR_TABLE_SCALE 0x80D6
+#define LOCAL_GL_COLOR_TABLE_BIAS 0x80D7
+#define LOCAL_GL_COLOR_TABLE_FORMAT 0x80D8
+#define LOCAL_GL_COLOR_TABLE_WIDTH 0x80D9
+#define LOCAL_GL_COLOR_TABLE_RED_SIZE 0x80DA
+#define LOCAL_GL_COLOR_TABLE_GREEN_SIZE 0x80DB
+#define LOCAL_GL_COLOR_TABLE_BLUE_SIZE 0x80DC
+#define LOCAL_GL_COLOR_TABLE_ALPHA_SIZE 0x80DD
+#define LOCAL_GL_COLOR_TABLE_LUMINANCE_SIZE 0x80DE
+#define LOCAL_GL_COLOR_TABLE_INTENSITY_SIZE 0x80DF
+#define LOCAL_GL_IGNORE_BORDER 0x8150
+#define LOCAL_GL_CONSTANT_BORDER 0x8151
+#define LOCAL_GL_WRAP_BORDER 0x8152
+#define LOCAL_GL_REPLICATE_BORDER 0x8153
+#define LOCAL_GL_CONVOLUTION_BORDER_COLOR 0x8154
+#define LOCAL_GL_ARB_matrix_palette 1
+#define LOCAL_GL_MATRIX_PALETTE_ARB 0x8840
+#define LOCAL_GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB 0x8841
+#define LOCAL_GL_MAX_PALETTE_MATRICES_ARB 0x8842
+#define LOCAL_GL_CURRENT_PALETTE_MATRIX_ARB 0x8843
+#define LOCAL_GL_MATRIX_INDEX_ARRAY_ARB 0x8844
+#define LOCAL_GL_CURRENT_MATRIX_INDEX_ARB 0x8845
+#define LOCAL_GL_MATRIX_INDEX_ARRAY_SIZE_ARB 0x8846
+#define LOCAL_GL_MATRIX_INDEX_ARRAY_TYPE_ARB 0x8847
+#define LOCAL_GL_MATRIX_INDEX_ARRAY_STRIDE_ARB 0x8848
+#define LOCAL_GL_MATRIX_INDEX_ARRAY_POINTER_ARB 0x8849
+#define LOCAL_GL_ARB_multisample 1
+#define LOCAL_GL_MULTISAMPLE_ARB 0x809D
+#define LOCAL_GL_SAMPLE_ALPHA_TO_COVERAGE_ARB 0x809E
+#define LOCAL_GL_SAMPLE_ALPHA_TO_ONE_ARB 0x809F
+#define LOCAL_GL_SAMPLE_COVERAGE_ARB 0x80A0
+#define LOCAL_GL_SAMPLE_BUFFERS_ARB 0x80A8
+#define LOCAL_GL_SAMPLES_ARB 0x80A9
+#define LOCAL_GL_SAMPLE_COVERAGE_VALUE_ARB 0x80AA
+#define LOCAL_GL_SAMPLE_COVERAGE_INVERT_ARB 0x80AB
+#define LOCAL_GL_MULTISAMPLE_BIT_ARB 0x20000000
+#define LOCAL_GL_ARB_multitexture 1
+#define LOCAL_GL_TEXTURE0_ARB 0x84C0
+#define LOCAL_GL_TEXTURE1_ARB 0x84C1
+#define LOCAL_GL_TEXTURE2_ARB 0x84C2
+#define LOCAL_GL_TEXTURE3_ARB 0x84C3
+#define LOCAL_GL_TEXTURE4_ARB 0x84C4
+#define LOCAL_GL_TEXTURE5_ARB 0x84C5
+#define LOCAL_GL_TEXTURE6_ARB 0x84C6
+#define LOCAL_GL_TEXTURE7_ARB 0x84C7
+#define LOCAL_GL_TEXTURE8_ARB 0x84C8
+#define LOCAL_GL_TEXTURE9_ARB 0x84C9
+#define LOCAL_GL_TEXTURE10_ARB 0x84CA
+#define LOCAL_GL_TEXTURE11_ARB 0x84CB
+#define LOCAL_GL_TEXTURE12_ARB 0x84CC
+#define LOCAL_GL_TEXTURE13_ARB 0x84CD
+#define LOCAL_GL_TEXTURE14_ARB 0x84CE
+#define LOCAL_GL_TEXTURE15_ARB 0x84CF
+#define LOCAL_GL_TEXTURE16_ARB 0x84D0
+#define LOCAL_GL_TEXTURE17_ARB 0x84D1
+#define LOCAL_GL_TEXTURE18_ARB 0x84D2
+#define LOCAL_GL_TEXTURE19_ARB 0x84D3
+#define LOCAL_GL_TEXTURE20_ARB 0x84D4
+#define LOCAL_GL_TEXTURE21_ARB 0x84D5
+#define LOCAL_GL_TEXTURE22_ARB 0x84D6
+#define LOCAL_GL_TEXTURE23_ARB 0x84D7
+#define LOCAL_GL_TEXTURE24_ARB 0x84D8
+#define LOCAL_GL_TEXTURE25_ARB 0x84D9
+#define LOCAL_GL_TEXTURE26_ARB 0x84DA
+#define LOCAL_GL_TEXTURE27_ARB 0x84DB
+#define LOCAL_GL_TEXTURE28_ARB 0x84DC
+#define LOCAL_GL_TEXTURE29_ARB 0x84DD
+#define LOCAL_GL_TEXTURE30_ARB 0x84DE
+#define LOCAL_GL_TEXTURE31_ARB 0x84DF
+#define LOCAL_GL_ACTIVE_TEXTURE_ARB 0x84E0
+#define LOCAL_GL_CLIENT_ACTIVE_TEXTURE_ARB 0x84E1
+#define LOCAL_GL_MAX_TEXTURE_UNITS_ARB 0x84E2
+#define LOCAL_GL_ARB_occlusion_query 1
+#define LOCAL_GL_QUERY_COUNTER_BITS_ARB 0x8864
+#define LOCAL_GL_CURRENT_QUERY_ARB 0x8865
+#define LOCAL_GL_QUERY_RESULT_ARB 0x8866
+#define LOCAL_GL_QUERY_RESULT_AVAILABLE_ARB 0x8867
+#define LOCAL_GL_SAMPLES_PASSED_ARB 0x8914
+#define LOCAL_GL_ARB_pixel_buffer_object 1
+#define LOCAL_GL_PIXEL_PACK_BUFFER_ARB 0x88EB
+#define LOCAL_GL_PIXEL_UNPACK_BUFFER_ARB 0x88EC
+#define LOCAL_GL_PIXEL_PACK_BUFFER_BINDING_ARB 0x88ED
+#define LOCAL_GL_PIXEL_UNPACK_BUFFER_BINDING_ARB 0x88EF
+#define LOCAL_GL_ARB_point_parameters 1
+#define LOCAL_GL_POINT_SIZE_MIN_ARB 0x8126
+#define LOCAL_GL_POINT_SIZE_MAX_ARB 0x8127
+#define LOCAL_GL_POINT_FADE_THRESHOLD_SIZE_ARB 0x8128
+#define LOCAL_GL_POINT_DISTANCE_ATTENUATION_ARB 0x8129
+#define LOCAL_GL_ARB_point_sprite 1
+#define LOCAL_GL_POINT_SPRITE_ARB 0x8861
+#define LOCAL_GL_COORD_REPLACE_ARB 0x8862
+#define LOCAL_GL_ARB_shader_objects 1
+#define LOCAL_GL_PROGRAM_OBJECT_ARB 0x8B40
+#define LOCAL_GL_SHADER_OBJECT_ARB 0x8B48
+#define LOCAL_GL_OBJECT_TYPE_ARB 0x8B4E
+#define LOCAL_GL_OBJECT_SUBTYPE_ARB 0x8B4F
+#define LOCAL_GL_FLOAT_VEC2_ARB 0x8B50
+#define LOCAL_GL_FLOAT_VEC3_ARB 0x8B51
+#define LOCAL_GL_FLOAT_VEC4_ARB 0x8B52
+#define LOCAL_GL_INT_VEC2_ARB 0x8B53
+#define LOCAL_GL_INT_VEC3_ARB 0x8B54
+#define LOCAL_GL_INT_VEC4_ARB 0x8B55
+#define LOCAL_GL_BOOL_ARB 0x8B56
+#define LOCAL_GL_BOOL_VEC2_ARB 0x8B57
+#define LOCAL_GL_BOOL_VEC3_ARB 0x8B58
+#define LOCAL_GL_BOOL_VEC4_ARB 0x8B59
+#define LOCAL_GL_FLOAT_MAT2_ARB 0x8B5A
+#define LOCAL_GL_FLOAT_MAT3_ARB 0x8B5B
+#define LOCAL_GL_FLOAT_MAT4_ARB 0x8B5C
+#define LOCAL_GL_SAMPLER_1D_ARB 0x8B5D
+#define LOCAL_GL_SAMPLER_2D_ARB 0x8B5E
+#define LOCAL_GL_SAMPLER_3D_ARB 0x8B5F
+#define LOCAL_GL_SAMPLER_CUBE_ARB 0x8B60
+#define LOCAL_GL_SAMPLER_1D_SHADOW_ARB 0x8B61
+#define LOCAL_GL_SAMPLER_2D_SHADOW_ARB 0x8B62
+#define LOCAL_GL_SAMPLER_2D_RECT_ARB 0x8B63
+#define LOCAL_GL_SAMPLER_2D_RECT_SHADOW_ARB 0x8B64
+#define LOCAL_GL_OBJECT_DELETE_STATUS_ARB 0x8B80
+#define LOCAL_GL_OBJECT_COMPILE_STATUS_ARB 0x8B81
+#define LOCAL_GL_OBJECT_LINK_STATUS_ARB 0x8B82
+#define LOCAL_GL_OBJECT_VALIDATE_STATUS_ARB 0x8B83
+#define LOCAL_GL_OBJECT_INFO_LOG_LENGTH_ARB 0x8B84
+#define LOCAL_GL_OBJECT_ATTACHED_OBJECTS_ARB 0x8B85
+#define LOCAL_GL_OBJECT_ACTIVE_UNIFORMS_ARB 0x8B86
+#define LOCAL_GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB 0x8B87
+#define LOCAL_GL_OBJECT_SHADER_SOURCE_LENGTH_ARB 0x8B88
+#define LOCAL_GL_ARB_shading_language_100 1
+#define LOCAL_GL_SHADING_LANGUAGE_VERSION_ARB 0x8B8C
+#define LOCAL_GL_ARB_shadow 1
+#define LOCAL_GL_TEXTURE_COMPARE_MODE_ARB 0x884C
+#define LOCAL_GL_TEXTURE_COMPARE_FUNC_ARB 0x884D
+#define LOCAL_GL_COMPARE_R_TO_TEXTURE_ARB 0x884E
+#define LOCAL_GL_ARB_shadow_ambient 1
+#define LOCAL_GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
+#define LOCAL_GL_ARB_texture_border_clamp 1
+#define LOCAL_GL_CLAMP_TO_BORDER_ARB 0x812D
+#define LOCAL_GL_ARB_texture_compression 1
+#define LOCAL_GL_COMPRESSED_ALPHA_ARB 0x84E9
+#define LOCAL_GL_COMPRESSED_LUMINANCE_ARB 0x84EA
+#define LOCAL_GL_COMPRESSED_LUMINANCE_ALPHA_ARB 0x84EB
+#define LOCAL_GL_COMPRESSED_INTENSITY_ARB 0x84EC
+#define LOCAL_GL_COMPRESSED_RGB_ARB 0x84ED
+#define LOCAL_GL_COMPRESSED_RGBA_ARB 0x84EE
+#define LOCAL_GL_TEXTURE_COMPRESSION_HINT_ARB 0x84EF
+#define LOCAL_GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB 0x86A0
+#define LOCAL_GL_TEXTURE_COMPRESSED_ARB 0x86A1
+#define LOCAL_GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
+#define LOCAL_GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
+#define LOCAL_GL_ARB_texture_cube_map 1
+#define LOCAL_GL_NORMAL_MAP_ARB 0x8511
+#define LOCAL_GL_REFLECTION_MAP_ARB 0x8512
+#define LOCAL_GL_TEXTURE_CUBE_MAP_ARB 0x8513
+#define LOCAL_GL_TEXTURE_BINDING_CUBE_MAP_ARB 0x8514
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
+#define LOCAL_GL_PROXY_TEXTURE_CUBE_MAP_ARB 0x851B
+#define LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB 0x851C
+#define LOCAL_GL_ARB_texture_env_add 1
+#define LOCAL_GL_ARB_texture_env_combine 1
+#define LOCAL_GL_SUBTRACT_ARB 0x84E7
+#define LOCAL_GL_COMBINE_ARB 0x8570
+#define LOCAL_GL_COMBINE_RGB_ARB 0x8571
+#define LOCAL_GL_COMBINE_ALPHA_ARB 0x8572
+#define LOCAL_GL_RGB_SCALE_ARB 0x8573
+#define LOCAL_GL_ADD_SIGNED_ARB 0x8574
+#define LOCAL_GL_INTERPOLATE_ARB 0x8575
+#define LOCAL_GL_CONSTANT_ARB 0x8576
+#define LOCAL_GL_PRIMARY_COLOR_ARB 0x8577
+#define LOCAL_GL_PREVIOUS_ARB 0x8578
+#define LOCAL_GL_SOURCE0_RGB_ARB 0x8580
+#define LOCAL_GL_SOURCE1_RGB_ARB 0x8581
+#define LOCAL_GL_SOURCE2_RGB_ARB 0x8582
+#define LOCAL_GL_SOURCE0_ALPHA_ARB 0x8588
+#define LOCAL_GL_SOURCE1_ALPHA_ARB 0x8589
+#define LOCAL_GL_SOURCE2_ALPHA_ARB 0x858A
+#define LOCAL_GL_OPERAND0_RGB_ARB 0x8590
+#define LOCAL_GL_OPERAND1_RGB_ARB 0x8591
+#define LOCAL_GL_OPERAND2_RGB_ARB 0x8592
+#define LOCAL_GL_OPERAND0_ALPHA_ARB 0x8598
+#define LOCAL_GL_OPERAND1_ALPHA_ARB 0x8599
+#define LOCAL_GL_OPERAND2_ALPHA_ARB 0x859A
+#define LOCAL_GL_ARB_texture_env_crossbar 1
+#define LOCAL_GL_ARB_texture_env_dot3 1
+#define LOCAL_GL_DOT3_RGB_ARB 0x86AE
+#define LOCAL_GL_DOT3_RGBA_ARB 0x86AF
+#define LOCAL_GL_ARB_texture_float 1
+#define LOCAL_GL_RGBA32F_ARB 0x8814
+#define LOCAL_GL_RGB32F_ARB 0x8815
+#define LOCAL_GL_ALPHA32F_ARB 0x8816
+#define LOCAL_GL_INTENSITY32F_ARB 0x8817
+#define LOCAL_GL_LUMINANCE32F_ARB 0x8818
+#define LOCAL_GL_LUMINANCE_ALPHA32F_ARB 0x8819
+#define LOCAL_GL_RGBA16F_ARB 0x881A
+#define LOCAL_GL_RGB16F_ARB 0x881B
+#define LOCAL_GL_ALPHA16F_ARB 0x881C
+#define LOCAL_GL_INTENSITY16F_ARB 0x881D
+#define LOCAL_GL_LUMINANCE16F_ARB 0x881E
+#define LOCAL_GL_LUMINANCE_ALPHA16F_ARB 0x881F
+#define LOCAL_GL_TEXTURE_RED_TYPE_ARB 0x8C10
+#define LOCAL_GL_TEXTURE_GREEN_TYPE_ARB 0x8C11
+#define LOCAL_GL_TEXTURE_BLUE_TYPE_ARB 0x8C12
+#define LOCAL_GL_TEXTURE_ALPHA_TYPE_ARB 0x8C13
+#define LOCAL_GL_TEXTURE_LUMINANCE_TYPE_ARB 0x8C14
+#define LOCAL_GL_TEXTURE_INTENSITY_TYPE_ARB 0x8C15
+#define LOCAL_GL_TEXTURE_DEPTH_TYPE_ARB 0x8C16
+#define LOCAL_GL_UNSIGNED_NORMALIZED_ARB 0x8C17
+#define LOCAL_GL_ARB_texture_mirrored_repeat 1
+#define LOCAL_GL_MIRRORED_REPEAT_ARB 0x8370
+#define LOCAL_GL_ARB_texture_non_power_of_two 1
+#define LOCAL_GL_ARB_texture_rectangle 1
+#define LOCAL_GL_TEXTURE_RECTANGLE_ARB 0x84F5
+#define LOCAL_GL_TEXTURE_BINDING_RECTANGLE_ARB 0x84F6
+#define LOCAL_GL_PROXY_TEXTURE_RECTANGLE_ARB 0x84F7
+#define LOCAL_GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB 0x84F8
+#define LOCAL_GL_SAMPLER_2D_RECT_ARB 0x8B63
+#define LOCAL_GL_SAMPLER_2D_RECT_SHADOW_ARB 0x8B64
+#define LOCAL_GL_ARB_transpose_matrix 1
+#define LOCAL_GL_TRANSPOSE_MODELVIEW_MATRIX_ARB 0x84E3
+#define LOCAL_GL_TRANSPOSE_PROJECTION_MATRIX_ARB 0x84E4
+#define LOCAL_GL_TRANSPOSE_TEXTURE_MATRIX_ARB 0x84E5
+#define LOCAL_GL_TRANSPOSE_COLOR_MATRIX_ARB 0x84E6
+#define LOCAL_GL_ARB_vertex_blend 1
+#define LOCAL_GL_MODELVIEW0_ARB 0x1700
+#define LOCAL_GL_MODELVIEW1_ARB 0x850A
+#define LOCAL_GL_MAX_VERTEX_UNITS_ARB 0x86A4
+#define LOCAL_GL_ACTIVE_VERTEX_UNITS_ARB 0x86A5
+#define LOCAL_GL_WEIGHT_SUM_UNITY_ARB 0x86A6
+#define LOCAL_GL_VERTEX_BLEND_ARB 0x86A7
+#define LOCAL_GL_CURRENT_WEIGHT_ARB 0x86A8
+#define LOCAL_GL_WEIGHT_ARRAY_TYPE_ARB 0x86A9
+#define LOCAL_GL_WEIGHT_ARRAY_STRIDE_ARB 0x86AA
+#define LOCAL_GL_WEIGHT_ARRAY_SIZE_ARB 0x86AB
+#define LOCAL_GL_WEIGHT_ARRAY_POINTER_ARB 0x86AC
+#define LOCAL_GL_WEIGHT_ARRAY_ARB 0x86AD
+#define LOCAL_GL_MODELVIEW2_ARB 0x8722
+#define LOCAL_GL_MODELVIEW3_ARB 0x8723
+#define LOCAL_GL_MODELVIEW4_ARB 0x8724
+#define LOCAL_GL_MODELVIEW5_ARB 0x8725
+#define LOCAL_GL_MODELVIEW6_ARB 0x8726
+#define LOCAL_GL_MODELVIEW7_ARB 0x8727
+#define LOCAL_GL_MODELVIEW8_ARB 0x8728
+#define LOCAL_GL_MODELVIEW9_ARB 0x8729
+#define LOCAL_GL_MODELVIEW10_ARB 0x872A
+#define LOCAL_GL_MODELVIEW11_ARB 0x872B
+#define LOCAL_GL_MODELVIEW12_ARB 0x872C
+#define LOCAL_GL_MODELVIEW13_ARB 0x872D
+#define LOCAL_GL_MODELVIEW14_ARB 0x872E
+#define LOCAL_GL_MODELVIEW15_ARB 0x872F
+#define LOCAL_GL_MODELVIEW16_ARB 0x8730
+#define LOCAL_GL_MODELVIEW17_ARB 0x8731
+#define LOCAL_GL_MODELVIEW18_ARB 0x8732
+#define LOCAL_GL_MODELVIEW19_ARB 0x8733
+#define LOCAL_GL_MODELVIEW20_ARB 0x8734
+#define LOCAL_GL_MODELVIEW21_ARB 0x8735
+#define LOCAL_GL_MODELVIEW22_ARB 0x8736
+#define LOCAL_GL_MODELVIEW23_ARB 0x8737
+#define LOCAL_GL_MODELVIEW24_ARB 0x8738
+#define LOCAL_GL_MODELVIEW25_ARB 0x8739
+#define LOCAL_GL_MODELVIEW26_ARB 0x873A
+#define LOCAL_GL_MODELVIEW27_ARB 0x873B
+#define LOCAL_GL_MODELVIEW28_ARB 0x873C
+#define LOCAL_GL_MODELVIEW29_ARB 0x873D
+#define LOCAL_GL_MODELVIEW30_ARB 0x873E
+#define LOCAL_GL_MODELVIEW31_ARB 0x873F
+#define LOCAL_GL_ARB_vertex_buffer_object 1
+#define LOCAL_GL_BUFFER_SIZE_ARB 0x8764
+#define LOCAL_GL_BUFFER_USAGE_ARB 0x8765
+#define LOCAL_GL_ARRAY_BUFFER_ARB 0x8892
+#define LOCAL_GL_ELEMENT_ARRAY_BUFFER_ARB 0x8893
+#define LOCAL_GL_ARRAY_BUFFER_BINDING_ARB 0x8894
+#define LOCAL_GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
+#define LOCAL_GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
+#define LOCAL_GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
+#define LOCAL_GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
+#define LOCAL_GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
+#define LOCAL_GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
+#define LOCAL_GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
+#define LOCAL_GL_READ_ONLY_ARB 0x88B8
+#define LOCAL_GL_WRITE_ONLY_ARB 0x88B9
+#define LOCAL_GL_READ_WRITE_ARB 0x88BA
+#define LOCAL_GL_BUFFER_ACCESS_ARB 0x88BB
+#define LOCAL_GL_BUFFER_MAPPED_ARB 0x88BC
+#define LOCAL_GL_BUFFER_MAP_POINTER_ARB 0x88BD
+#define LOCAL_GL_STREAM_DRAW_ARB 0x88E0
+#define LOCAL_GL_STREAM_READ_ARB 0x88E1
+#define LOCAL_GL_STREAM_COPY_ARB 0x88E2
+#define LOCAL_GL_STATIC_DRAW_ARB 0x88E4
+#define LOCAL_GL_STATIC_READ_ARB 0x88E5
+#define LOCAL_GL_STATIC_COPY_ARB 0x88E6
+#define LOCAL_GL_DYNAMIC_DRAW_ARB 0x88E8
+#define LOCAL_GL_DYNAMIC_READ_ARB 0x88E9
+#define LOCAL_GL_DYNAMIC_COPY_ARB 0x88EA
+#define LOCAL_GL_ARB_vertex_program 1
+#define LOCAL_GL_COLOR_SUM_ARB 0x8458
+#define LOCAL_GL_VERTEX_PROGRAM_ARB 0x8620
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB 0x8623
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB 0x8625
+#define LOCAL_GL_CURRENT_VERTEX_ATTRIB_ARB 0x8626
+#define LOCAL_GL_PROGRAM_LENGTH_ARB 0x8627
+#define LOCAL_GL_PROGRAM_STRING_ARB 0x8628
+#define LOCAL_GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
+#define LOCAL_GL_MAX_PROGRAM_MATRICES_ARB 0x862F
+#define LOCAL_GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
+#define LOCAL_GL_CURRENT_MATRIX_ARB 0x8641
+#define LOCAL_GL_VERTEX_PROGRAM_POINT_SIZE_ARB 0x8642
+#define LOCAL_GL_VERTEX_PROGRAM_TWO_SIDE_ARB 0x8643
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
+#define LOCAL_GL_PROGRAM_ERROR_POSITION_ARB 0x864B
+#define LOCAL_GL_PROGRAM_BINDING_ARB 0x8677
+#define LOCAL_GL_MAX_VERTEX_ATTRIBS_ARB 0x8869
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
+#define LOCAL_GL_PROGRAM_ERROR_STRING_ARB 0x8874
+#define LOCAL_GL_PROGRAM_FORMAT_ASCII_ARB 0x8875
+#define LOCAL_GL_PROGRAM_FORMAT_ARB 0x8876
+#define LOCAL_GL_PROGRAM_INSTRUCTIONS_ARB 0x88A0
+#define LOCAL_GL_MAX_PROGRAM_INSTRUCTIONS_ARB 0x88A1
+#define LOCAL_GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
+#define LOCAL_GL_PROGRAM_TEMPORARIES_ARB 0x88A4
+#define LOCAL_GL_MAX_PROGRAM_TEMPORARIES_ARB 0x88A5
+#define LOCAL_GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
+#define LOCAL_GL_PROGRAM_PARAMETERS_ARB 0x88A8
+#define LOCAL_GL_MAX_PROGRAM_PARAMETERS_ARB 0x88A9
+#define LOCAL_GL_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AA
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
+#define LOCAL_GL_PROGRAM_ATTRIBS_ARB 0x88AC
+#define LOCAL_GL_MAX_PROGRAM_ATTRIBS_ARB 0x88AD
+#define LOCAL_GL_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AE
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
+#define LOCAL_GL_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B0
+#define LOCAL_GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
+#define LOCAL_GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
+#define LOCAL_GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
+#define LOCAL_GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
+#define LOCAL_GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
+#define LOCAL_GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
+#define LOCAL_GL_TRANSPOSE_CURRENT_MATRIX_ARB 0x88B7
+#define LOCAL_GL_MATRIX0_ARB 0x88C0
+#define LOCAL_GL_MATRIX1_ARB 0x88C1
+#define LOCAL_GL_MATRIX2_ARB 0x88C2
+#define LOCAL_GL_MATRIX3_ARB 0x88C3
+#define LOCAL_GL_MATRIX4_ARB 0x88C4
+#define LOCAL_GL_MATRIX5_ARB 0x88C5
+#define LOCAL_GL_MATRIX6_ARB 0x88C6
+#define LOCAL_GL_MATRIX7_ARB 0x88C7
+#define LOCAL_GL_MATRIX8_ARB 0x88C8
+#define LOCAL_GL_MATRIX9_ARB 0x88C9
+#define LOCAL_GL_MATRIX10_ARB 0x88CA
+#define LOCAL_GL_MATRIX11_ARB 0x88CB
+#define LOCAL_GL_MATRIX12_ARB 0x88CC
+#define LOCAL_GL_MATRIX13_ARB 0x88CD
+#define LOCAL_GL_MATRIX14_ARB 0x88CE
+#define LOCAL_GL_MATRIX15_ARB 0x88CF
+#define LOCAL_GL_MATRIX16_ARB 0x88D0
+#define LOCAL_GL_MATRIX17_ARB 0x88D1
+#define LOCAL_GL_MATRIX18_ARB 0x88D2
+#define LOCAL_GL_MATRIX19_ARB 0x88D3
+#define LOCAL_GL_MATRIX20_ARB 0x88D4
+#define LOCAL_GL_MATRIX21_ARB 0x88D5
+#define LOCAL_GL_MATRIX22_ARB 0x88D6
+#define LOCAL_GL_MATRIX23_ARB 0x88D7
+#define LOCAL_GL_MATRIX24_ARB 0x88D8
+#define LOCAL_GL_MATRIX25_ARB 0x88D9
+#define LOCAL_GL_MATRIX26_ARB 0x88DA
+#define LOCAL_GL_MATRIX27_ARB 0x88DB
+#define LOCAL_GL_MATRIX28_ARB 0x88DC
+#define LOCAL_GL_MATRIX29_ARB 0x88DD
+#define LOCAL_GL_MATRIX30_ARB 0x88DE
+#define LOCAL_GL_MATRIX31_ARB 0x88DF
+#define LOCAL_GL_ARB_vertex_shader 1
+#define LOCAL_GL_VERTEX_SHADER_ARB 0x8B31
+#define LOCAL_GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB 0x8B4A
+#define LOCAL_GL_MAX_VARYING_FLOATS_ARB 0x8B4B
+#define LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
+#define LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB 0x8B4D
+#define LOCAL_GL_OBJECT_ACTIVE_ATTRIBUTES_ARB 0x8B89
+#define LOCAL_GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB 0x8B8A
+#define LOCAL_GL_ARB_window_pos 1
+#define LOCAL_GL_ATIX_point_sprites 1
+#define LOCAL_GL_ATIX_texture_env_combine3 1
+#define LOCAL_GL_MODULATE_ADD_ATIX 0x8744
+#define LOCAL_GL_MODULATE_SIGNED_ADD_ATIX 0x8745
+#define LOCAL_GL_MODULATE_SUBTRACT_ATIX 0x8746
+#define LOCAL_GL_ATIX_texture_env_route 1
+#define LOCAL_GL_SECONDARY_COLOR_ATIX 0x8747
+#define LOCAL_GL_TEXTURE_OUTPUT_RGB_ATIX 0x8748
+#define LOCAL_GL_TEXTURE_OUTPUT_ALPHA_ATIX 0x8749
+#define LOCAL_GL_ATIX_vertex_shader_output_point_size 1
+#define LOCAL_GL_OUTPUT_POINT_SIZE_ATIX 0x610E
+#define LOCAL_GL_ATI_draw_buffers 1
+#define LOCAL_GL_MAX_DRAW_BUFFERS_ATI 0x8824
+#define LOCAL_GL_DRAW_BUFFER0_ATI 0x8825
+#define LOCAL_GL_DRAW_BUFFER1_ATI 0x8826
+#define LOCAL_GL_DRAW_BUFFER2_ATI 0x8827
+#define LOCAL_GL_DRAW_BUFFER3_ATI 0x8828
+#define LOCAL_GL_DRAW_BUFFER4_ATI 0x8829
+#define LOCAL_GL_DRAW_BUFFER5_ATI 0x882A
+#define LOCAL_GL_DRAW_BUFFER6_ATI 0x882B
+#define LOCAL_GL_DRAW_BUFFER7_ATI 0x882C
+#define LOCAL_GL_DRAW_BUFFER8_ATI 0x882D
+#define LOCAL_GL_DRAW_BUFFER9_ATI 0x882E
+#define LOCAL_GL_DRAW_BUFFER10_ATI 0x882F
+#define LOCAL_GL_DRAW_BUFFER11_ATI 0x8830
+#define LOCAL_GL_DRAW_BUFFER12_ATI 0x8831
+#define LOCAL_GL_DRAW_BUFFER13_ATI 0x8832
+#define LOCAL_GL_DRAW_BUFFER14_ATI 0x8833
+#define LOCAL_GL_DRAW_BUFFER15_ATI 0x8834
+#define LOCAL_GL_ATI_element_array 1
+#define LOCAL_GL_ELEMENT_ARRAY_ATI 0x8768
+#define LOCAL_GL_ELEMENT_ARRAY_TYPE_ATI 0x8769
+#define LOCAL_GL_ELEMENT_ARRAY_POINTER_ATI 0x876A
+#define LOCAL_GL_ATI_envmap_bumpmap 1
+#define LOCAL_GL_BUMP_ROT_MATRIX_ATI 0x8775
+#define LOCAL_GL_BUMP_ROT_MATRIX_SIZE_ATI 0x8776
+#define LOCAL_GL_BUMP_NUM_TEX_UNITS_ATI 0x8777
+#define LOCAL_GL_BUMP_TEX_UNITS_ATI 0x8778
+#define LOCAL_GL_DUDV_ATI 0x8779
+#define LOCAL_GL_DU8DV8_ATI 0x877A
+#define LOCAL_GL_BUMP_ENVMAP_ATI 0x877B
+#define LOCAL_GL_BUMP_TARGET_ATI 0x877C
+#define LOCAL_GL_ATI_fragment_shader 1
+#define LOCAL_GL_RED_BIT_ATI 0x00000001
+#define LOCAL_GL_2X_BIT_ATI 0x00000001
+#define LOCAL_GL_4X_BIT_ATI 0x00000002
+#define LOCAL_GL_GREEN_BIT_ATI 0x00000002
+#define LOCAL_GL_COMP_BIT_ATI 0x00000002
+#define LOCAL_GL_BLUE_BIT_ATI 0x00000004
+#define LOCAL_GL_8X_BIT_ATI 0x00000004
+#define LOCAL_GL_NEGATE_BIT_ATI 0x00000004
+#define LOCAL_GL_BIAS_BIT_ATI 0x00000008
+#define LOCAL_GL_HALF_BIT_ATI 0x00000008
+#define LOCAL_GL_QUARTER_BIT_ATI 0x00000010
+#define LOCAL_GL_EIGHTH_BIT_ATI 0x00000020
+#define LOCAL_GL_SATURATE_BIT_ATI 0x00000040
+#define LOCAL_GL_FRAGMENT_SHADER_ATI 0x8920
+#define LOCAL_GL_REG_0_ATI 0x8921
+#define LOCAL_GL_REG_1_ATI 0x8922
+#define LOCAL_GL_REG_2_ATI 0x8923
+#define LOCAL_GL_REG_3_ATI 0x8924
+#define LOCAL_GL_REG_4_ATI 0x8925
+#define LOCAL_GL_REG_5_ATI 0x8926
+#define LOCAL_GL_CON_0_ATI 0x8941
+#define LOCAL_GL_CON_1_ATI 0x8942
+#define LOCAL_GL_CON_2_ATI 0x8943
+#define LOCAL_GL_CON_3_ATI 0x8944
+#define LOCAL_GL_CON_4_ATI 0x8945
+#define LOCAL_GL_CON_5_ATI 0x8946
+#define LOCAL_GL_CON_6_ATI 0x8947
+#define LOCAL_GL_CON_7_ATI 0x8948
+#define LOCAL_GL_MOV_ATI 0x8961
+#define LOCAL_GL_ADD_ATI 0x8963
+#define LOCAL_GL_MUL_ATI 0x8964
+#define LOCAL_GL_SUB_ATI 0x8965
+#define LOCAL_GL_DOT3_ATI 0x8966
+#define LOCAL_GL_DOT4_ATI 0x8967
+#define LOCAL_GL_MAD_ATI 0x8968
+#define LOCAL_GL_LERP_ATI 0x8969
+#define LOCAL_GL_CND_ATI 0x896A
+#define LOCAL_GL_CND0_ATI 0x896B
+#define LOCAL_GL_DOT2_ADD_ATI 0x896C
+#define LOCAL_GL_SECONDARY_INTERPOLATOR_ATI 0x896D
+#define LOCAL_GL_NUM_FRAGMENT_REGISTERS_ATI 0x896E
+#define LOCAL_GL_NUM_FRAGMENT_CONSTANTS_ATI 0x896F
+#define LOCAL_GL_NUM_PASSES_ATI 0x8970
+#define LOCAL_GL_NUM_INSTRUCTIONS_PER_PASS_ATI 0x8971
+#define LOCAL_GL_NUM_INSTRUCTIONS_TOTAL_ATI 0x8972
+#define LOCAL_GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI 0x8973
+#define LOCAL_GL_NUM_LOOPBACK_COMPONENTS_ATI 0x8974
+#define LOCAL_GL_COLOR_ALPHA_PAIRING_ATI 0x8975
+#define LOCAL_GL_SWIZZLE_STR_ATI 0x8976
+#define LOCAL_GL_SWIZZLE_STQ_ATI 0x8977
+#define LOCAL_GL_SWIZZLE_STR_DR_ATI 0x8978
+#define LOCAL_GL_SWIZZLE_STQ_DQ_ATI 0x8979
+#define LOCAL_GL_SWIZZLE_STRQ_ATI 0x897A
+#define LOCAL_GL_SWIZZLE_STRQ_DQ_ATI 0x897B
+#define LOCAL_GL_ATI_map_object_buffer 1
+#define LOCAL_GL_ATI_pn_triangles 1
+#define LOCAL_GL_PN_TRIANGLES_ATI 0x87F0
+#define LOCAL_GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F1
+#define LOCAL_GL_PN_TRIANGLES_POINT_MODE_ATI 0x87F2
+#define LOCAL_GL_PN_TRIANGLES_NORMAL_MODE_ATI 0x87F3
+#define LOCAL_GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F4
+#define LOCAL_GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI 0x87F5
+#define LOCAL_GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI 0x87F6
+#define LOCAL_GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI 0x87F7
+#define LOCAL_GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI 0x87F8
+#define LOCAL_GL_ATI_separate_stencil 1
+#define LOCAL_GL_STENCIL_BACK_FUNC_ATI 0x8800
+#define LOCAL_GL_STENCIL_BACK_FAIL_ATI 0x8801
+#define LOCAL_GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI 0x8802
+#define LOCAL_GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI 0x8803
+#define LOCAL_GL_ATI_text_fragment_shader 1
+#define LOCAL_GL_TEXT_FRAGMENT_SHADER_ATI 0x8200
+#define LOCAL_GL_ATI_texture_compression_3dc 1
+#define LOCAL_GL_COMPRESSED_RGB_3DC_ATI 0x8837
+#define LOCAL_GL_ATI_texture_env_combine3 1
+#define LOCAL_GL_MODULATE_ADD_ATI 0x8744
+#define LOCAL_GL_MODULATE_SIGNED_ADD_ATI 0x8745
+#define LOCAL_GL_MODULATE_SUBTRACT_ATI 0x8746
+#define LOCAL_GL_ATI_texture_float 1
+#define LOCAL_GL_RGBA_FLOAT32_ATI 0x8814
+#define LOCAL_GL_RGB_FLOAT32_ATI 0x8815
+#define LOCAL_GL_ALPHA_FLOAT32_ATI 0x8816
+#define LOCAL_GL_INTENSITY_FLOAT32_ATI 0x8817
+#define LOCAL_GL_LUMINANCE_FLOAT32_ATI 0x8818
+#define LOCAL_GL_LUMINANCE_ALPHA_FLOAT32_ATI 0x8819
+#define LOCAL_GL_RGBA_FLOAT16_ATI 0x881A
+#define LOCAL_GL_RGB_FLOAT16_ATI 0x881B
+#define LOCAL_GL_ALPHA_FLOAT16_ATI 0x881C
+#define LOCAL_GL_INTENSITY_FLOAT16_ATI 0x881D
+#define LOCAL_GL_LUMINANCE_FLOAT16_ATI 0x881E
+#define LOCAL_GL_LUMINANCE_ALPHA_FLOAT16_ATI 0x881F
+#define LOCAL_GL_ATI_texture_mirror_once 1
+#define LOCAL_GL_MIRROR_CLAMP_ATI 0x8742
+#define LOCAL_GL_MIRROR_CLAMP_TO_EDGE_ATI 0x8743
+#define LOCAL_GL_ATI_vertex_array_object 1
+#define LOCAL_GL_STATIC_ATI 0x8760
+#define LOCAL_GL_DYNAMIC_ATI 0x8761
+#define LOCAL_GL_PRESERVE_ATI 0x8762
+#define LOCAL_GL_DISCARD_ATI 0x8763
+#define LOCAL_GL_OBJECT_BUFFER_SIZE_ATI 0x8764
+#define LOCAL_GL_OBJECT_BUFFER_USAGE_ATI 0x8765
+#define LOCAL_GL_ARRAY_OBJECT_BUFFER_ATI 0x8766
+#define LOCAL_GL_ARRAY_OBJECT_OFFSET_ATI 0x8767
+#define LOCAL_GL_ATI_vertex_attrib_array_object 1
+#define LOCAL_GL_ATI_vertex_streams 1
+#define LOCAL_GL_MAX_VERTEX_STREAMS_ATI 0x876B
+#define LOCAL_GL_VERTEX_SOURCE_ATI 0x876C
+#define LOCAL_GL_VERTEX_STREAM0_ATI 0x876D
+#define LOCAL_GL_VERTEX_STREAM1_ATI 0x876E
+#define LOCAL_GL_VERTEX_STREAM2_ATI 0x876F
+#define LOCAL_GL_VERTEX_STREAM3_ATI 0x8770
+#define LOCAL_GL_VERTEX_STREAM4_ATI 0x8771
+#define LOCAL_GL_VERTEX_STREAM5_ATI 0x8772
+#define LOCAL_GL_VERTEX_STREAM6_ATI 0x8773
+#define LOCAL_GL_VERTEX_STREAM7_ATI 0x8774
+#define LOCAL_GL_EXT_422_pixels 1
+#define LOCAL_GL_422_EXT 0x80CC
+#define LOCAL_GL_422_REV_EXT 0x80CD
+#define LOCAL_GL_422_AVERAGE_EXT 0x80CE
+#define LOCAL_GL_422_REV_AVERAGE_EXT 0x80CF
+#define LOCAL_GL_EXT_Cg_shader 1
+#define LOCAL_GL_CG_VERTEX_SHADER_EXT 0x890E
+#define LOCAL_GL_CG_FRAGMENT_SHADER_EXT 0x890F
+#define LOCAL_GL_EXT_abgr 1
+#define LOCAL_GL_ABGR_EXT 0x8000
+#define LOCAL_GL_EXT_bgra 1
+#define LOCAL_GL_BGR_EXT 0x80E0
+#define LOCAL_GL_BGRA_EXT 0x80E1
+#define LOCAL_GL_EXT_blend_color 1
+#define LOCAL_GL_CONSTANT_COLOR_EXT 0x8001
+#define LOCAL_GL_ONE_MINUS_CONSTANT_COLOR_EXT 0x8002
+#define LOCAL_GL_CONSTANT_ALPHA_EXT 0x8003
+#define LOCAL_GL_ONE_MINUS_CONSTANT_ALPHA_EXT 0x8004
+#define LOCAL_GL_BLEND_COLOR_EXT 0x8005
+#define LOCAL_GL_EXT_blend_equation_separate 1
+#define LOCAL_GL_BLEND_EQUATION_RGB_EXT 0x8009
+#define LOCAL_GL_BLEND_EQUATION_ALPHA_EXT 0x883D
+#define LOCAL_GL_EXT_blend_func_separate 1
+#define LOCAL_GL_BLEND_DST_RGB_EXT 0x80C8
+#define LOCAL_GL_BLEND_SRC_RGB_EXT 0x80C9
+#define LOCAL_GL_BLEND_DST_ALPHA_EXT 0x80CA
+#define LOCAL_GL_BLEND_SRC_ALPHA_EXT 0x80CB
+#define LOCAL_GL_EXT_blend_logic_op 1
+#define LOCAL_GL_EXT_blend_minmax 1
+#define LOCAL_GL_FUNC_ADD_EXT 0x8006
+#define LOCAL_GL_MIN_EXT 0x8007
+#define LOCAL_GL_MAX_EXT 0x8008
+#define LOCAL_GL_BLEND_EQUATION_EXT 0x8009
+#define LOCAL_GL_EXT_blend_subtract 1
+#define LOCAL_GL_FUNC_SUBTRACT_EXT 0x800A
+#define LOCAL_GL_FUNC_REVERSE_SUBTRACT_EXT 0x800B
+#define LOCAL_GL_EXT_clip_volume_hint 1
+#define LOCAL_GL_CLIP_VOLUME_CLIPPING_HINT_EXT 0x80F0
+#define LOCAL_GL_EXT_cmyka 1
+#define LOCAL_GL_CMYK_EXT 0x800C
+#define LOCAL_GL_CMYKA_EXT 0x800D
+#define LOCAL_GL_PACK_CMYK_HINT_EXT 0x800E
+#define LOCAL_GL_UNPACK_CMYK_HINT_EXT 0x800F
+#define LOCAL_GL_EXT_color_subtable 1
+#define LOCAL_GL_EXT_compiled_vertex_array 1
+#define LOCAL_GL_EXT_convolution 1
+#define LOCAL_GL_CONVOLUTION_1D_EXT 0x8010
+#define LOCAL_GL_CONVOLUTION_2D_EXT 0x8011
+#define LOCAL_GL_SEPARABLE_2D_EXT 0x8012
+#define LOCAL_GL_CONVOLUTION_BORDER_MODE_EXT 0x8013
+#define LOCAL_GL_CONVOLUTION_FILTER_SCALE_EXT 0x8014
+#define LOCAL_GL_CONVOLUTION_FILTER_BIAS_EXT 0x8015
+#define LOCAL_GL_REDUCE_EXT 0x8016
+#define LOCAL_GL_CONVOLUTION_FORMAT_EXT 0x8017
+#define LOCAL_GL_CONVOLUTION_WIDTH_EXT 0x8018
+#define LOCAL_GL_CONVOLUTION_HEIGHT_EXT 0x8019
+#define LOCAL_GL_MAX_CONVOLUTION_WIDTH_EXT 0x801A
+#define LOCAL_GL_MAX_CONVOLUTION_HEIGHT_EXT 0x801B
+#define LOCAL_GL_POST_CONVOLUTION_RED_SCALE_EXT 0x801C
+#define LOCAL_GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
+#define LOCAL_GL_POST_CONVOLUTION_BLUE_SCALE_EXT 0x801E
+#define LOCAL_GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
+#define LOCAL_GL_POST_CONVOLUTION_RED_BIAS_EXT 0x8020
+#define LOCAL_GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
+#define LOCAL_GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
+#define LOCAL_GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
+#define LOCAL_GL_EXT_coordinate_frame 1
+#define LOCAL_GL_TANGENT_ARRAY_EXT 0x8439
+#define LOCAL_GL_BINORMAL_ARRAY_EXT 0x843A
+#define LOCAL_GL_CURRENT_TANGENT_EXT 0x843B
+#define LOCAL_GL_CURRENT_BINORMAL_EXT 0x843C
+#define LOCAL_GL_TANGENT_ARRAY_TYPE_EXT 0x843E
+#define LOCAL_GL_TANGENT_ARRAY_STRIDE_EXT 0x843F
+#define LOCAL_GL_BINORMAL_ARRAY_TYPE_EXT 0x8440
+#define LOCAL_GL_BINORMAL_ARRAY_STRIDE_EXT 0x8441
+#define LOCAL_GL_TANGENT_ARRAY_POINTER_EXT 0x8442
+#define LOCAL_GL_BINORMAL_ARRAY_POINTER_EXT 0x8443
+#define LOCAL_GL_MAP1_TANGENT_EXT 0x8444
+#define LOCAL_GL_MAP2_TANGENT_EXT 0x8445
+#define LOCAL_GL_MAP1_BINORMAL_EXT 0x8446
+#define LOCAL_GL_MAP2_BINORMAL_EXT 0x8447
+#define LOCAL_GL_EXT_copy_texture 1
+#define LOCAL_GL_EXT_cull_vertex 1
+#define LOCAL_GL_EXT_depth_bounds_test 1
+#define LOCAL_GL_DEPTH_BOUNDS_TEST_EXT 0x8890
+#define LOCAL_GL_DEPTH_BOUNDS_EXT 0x8891
+#define LOCAL_GL_EXT_draw_range_elements 1
+#define LOCAL_GL_MAX_ELEMENTS_VERTICES 0x80E8
+#define LOCAL_GL_MAX_ELEMENTS_INDICES 0x80E9
+#define LOCAL_GL_EXT_fog_coord 1
+#define LOCAL_GL_FOG_COORDINATE_SOURCE_EXT 0x8450
+#define LOCAL_GL_FOG_COORDINATE_EXT 0x8451
+#define LOCAL_GL_FRAGMENT_DEPTH_EXT 0x8452
+#define LOCAL_GL_CURRENT_FOG_COORDINATE_EXT 0x8453
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_TYPE_EXT 0x8454
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_STRIDE_EXT 0x8455
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_POINTER_EXT 0x8456
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_EXT 0x8457
+#define LOCAL_GL_EXT_fragment_lighting 1
+#define LOCAL_GL_FRAGMENT_LIGHTING_EXT 0x8400
+#define LOCAL_GL_FRAGMENT_COLOR_MATERIAL_EXT 0x8401
+#define LOCAL_GL_FRAGMENT_COLOR_MATERIAL_FACE_EXT 0x8402
+#define LOCAL_GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_EXT 0x8403
+#define LOCAL_GL_MAX_FRAGMENT_LIGHTS_EXT 0x8404
+#define LOCAL_GL_MAX_ACTIVE_LIGHTS_EXT 0x8405
+#define LOCAL_GL_CURRENT_RASTER_NORMAL_EXT 0x8406
+#define LOCAL_GL_LIGHT_ENV_MODE_EXT 0x8407
+#define LOCAL_GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_EXT 0x8408
+#define LOCAL_GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_EXT 0x8409
+#define LOCAL_GL_FRAGMENT_LIGHT_MODEL_AMBIENT_EXT 0x840A
+#define LOCAL_GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_EXT 0x840B
+#define LOCAL_GL_FRAGMENT_LIGHT0_EXT 0x840C
+#define LOCAL_GL_FRAGMENT_LIGHT7_EXT 0x8413
+#define LOCAL_GL_EXT_framebuffer_blit 1
+#define LOCAL_GL_DRAW_FRAMEBUFFER_BINDING_EXT 0x8CA6
+#define LOCAL_GL_READ_FRAMEBUFFER_EXT 0x8CA8
+#define LOCAL_GL_DRAW_FRAMEBUFFER_EXT 0x8CA9
+#define LOCAL_GL_READ_FRAMEBUFFER_BINDING_EXT 0x8CAA
+#define LOCAL_GL_EXT_framebuffer_multisample 1
+#define LOCAL_GL_RENDERBUFFER_SAMPLES_EXT 0x8CAB
+#define LOCAL_GL_EXT_framebuffer_object 1
+#define LOCAL_GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
+#define LOCAL_GL_MAX_RENDERBUFFER_SIZE 0x84E8
+#define LOCAL_GL_FRAMEBUFFER_BINDING 0x8CA6
+#define LOCAL_GL_RENDERBUFFER_BINDING 0x8CA7
+#define LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
+#define LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
+#define LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
+#define LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
+#define LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET 0x8CD4
+#define LOCAL_GL_FRAMEBUFFER_COMPLETE 0x8CD5
+#define LOCAL_GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
+#define LOCAL_GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
+#define LOCAL_GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS 0x8CD9
+#define LOCAL_GL_FRAMEBUFFER_INCOMPLETE_FORMATS 0x8CDA
+#define LOCAL_GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
+#define LOCAL_GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
+#define LOCAL_GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
+#define LOCAL_GL_MAX_COLOR_ATTACHMENTS 0x8CDF
+#define LOCAL_GL_COLOR_ATTACHMENT0 0x8CE0
+#define LOCAL_GL_COLOR_ATTACHMENT1 0x8CE1
+#define LOCAL_GL_COLOR_ATTACHMENT2 0x8CE2
+#define LOCAL_GL_COLOR_ATTACHMENT3 0x8CE3
+#define LOCAL_GL_COLOR_ATTACHMENT4 0x8CE4
+#define LOCAL_GL_COLOR_ATTACHMENT5 0x8CE5
+#define LOCAL_GL_COLOR_ATTACHMENT6 0x8CE6
+#define LOCAL_GL_COLOR_ATTACHMENT7 0x8CE7
+#define LOCAL_GL_COLOR_ATTACHMENT8 0x8CE8
+#define LOCAL_GL_COLOR_ATTACHMENT9 0x8CE9
+#define LOCAL_GL_COLOR_ATTACHMENT10 0x8CEA
+#define LOCAL_GL_COLOR_ATTACHMENT11 0x8CEB
+#define LOCAL_GL_COLOR_ATTACHMENT12 0x8CEC
+#define LOCAL_GL_COLOR_ATTACHMENT13 0x8CED
+#define LOCAL_GL_COLOR_ATTACHMENT14 0x8CEE
+#define LOCAL_GL_COLOR_ATTACHMENT15 0x8CEF
+#define LOCAL_GL_DEPTH_ATTACHMENT 0x8D00
+#define LOCAL_GL_STENCIL_ATTACHMENT 0x8D20
+#define LOCAL_GL_FRAMEBUFFER 0x8D40
+#define LOCAL_GL_RENDERBUFFER 0x8D41
+#define LOCAL_GL_RENDERBUFFER_WIDTH 0x8D42
+#define LOCAL_GL_RENDERBUFFER_HEIGHT 0x8D43
+#define LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
+#define LOCAL_GL_STENCIL_INDEX1 0x8D46
+#define LOCAL_GL_STENCIL_INDEX4 0x8D47
+#define LOCAL_GL_STENCIL_INDEX8 0x8D48
+#define LOCAL_GL_STENCIL_INDEX16 0x8D49
+#define LOCAL_GL_RENDERBUFFER_RED_SIZE 0x8D50
+#define LOCAL_GL_RENDERBUFFER_GREEN_SIZE 0x8D51
+#define LOCAL_GL_RENDERBUFFER_BLUE_SIZE 0x8D52
+#define LOCAL_GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
+#define LOCAL_GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
+#define LOCAL_GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
+#define LOCAL_GL_EXT_histogram 1
+#define LOCAL_GL_HISTOGRAM_EXT 0x8024
+#define LOCAL_GL_PROXY_HISTOGRAM_EXT 0x8025
+#define LOCAL_GL_HISTOGRAM_WIDTH_EXT 0x8026
+#define LOCAL_GL_HISTOGRAM_FORMAT_EXT 0x8027
+#define LOCAL_GL_HISTOGRAM_RED_SIZE_EXT 0x8028
+#define LOCAL_GL_HISTOGRAM_GREEN_SIZE_EXT 0x8029
+#define LOCAL_GL_HISTOGRAM_BLUE_SIZE_EXT 0x802A
+#define LOCAL_GL_HISTOGRAM_ALPHA_SIZE_EXT 0x802B
+#define LOCAL_GL_HISTOGRAM_LUMINANCE_SIZE_EXT 0x802C
+#define LOCAL_GL_HISTOGRAM_SINK_EXT 0x802D
+#define LOCAL_GL_MINMAX_EXT 0x802E
+#define LOCAL_GL_MINMAX_FORMAT_EXT 0x802F
+#define LOCAL_GL_MINMAX_SINK_EXT 0x8030
+#define LOCAL_GL_EXT_index_array_formats 1
+#define LOCAL_GL_EXT_index_func 1
+#define LOCAL_GL_EXT_index_material 1
+#define LOCAL_GL_EXT_index_texture 1
+#define LOCAL_GL_EXT_light_texture 1
+#define LOCAL_GL_FRAGMENT_MATERIAL_EXT 0x8349
+#define LOCAL_GL_FRAGMENT_NORMAL_EXT 0x834A
+#define LOCAL_GL_FRAGMENT_COLOR_EXT 0x834C
+#define LOCAL_GL_ATTENUATION_EXT 0x834D
+#define LOCAL_GL_SHADOW_ATTENUATION_EXT 0x834E
+#define LOCAL_GL_TEXTURE_APPLICATION_MODE_EXT 0x834F
+#define LOCAL_GL_TEXTURE_LIGHT_EXT 0x8350
+#define LOCAL_GL_TEXTURE_MATERIAL_FACE_EXT 0x8351
+#define LOCAL_GL_TEXTURE_MATERIAL_PARAMETER_EXT 0x8352
+#define LOCAL_GL_FRAGMENT_DEPTH_EXT 0x8452
+#define LOCAL_GL_EXT_misc_attribute 1
+#define LOCAL_GL_EXT_multi_draw_arrays 1
+#define LOCAL_GL_EXT_multisample 1
+#define LOCAL_GL_MULTISAMPLE_EXT 0x809D
+#define LOCAL_GL_SAMPLE_ALPHA_TO_MASK_EXT 0x809E
+#define LOCAL_GL_SAMPLE_ALPHA_TO_ONE_EXT 0x809F
+#define LOCAL_GL_SAMPLE_MASK_EXT 0x80A0
+#define LOCAL_GL_1PASS_EXT 0x80A1
+#define LOCAL_GL_2PASS_0_EXT 0x80A2
+#define LOCAL_GL_2PASS_1_EXT 0x80A3
+#define LOCAL_GL_4PASS_0_EXT 0x80A4
+#define LOCAL_GL_4PASS_1_EXT 0x80A5
+#define LOCAL_GL_4PASS_2_EXT 0x80A6
+#define LOCAL_GL_4PASS_3_EXT 0x80A7
+#define LOCAL_GL_SAMPLE_BUFFERS_EXT 0x80A8
+#define LOCAL_GL_SAMPLES_EXT 0x80A9
+#define LOCAL_GL_SAMPLE_MASK_VALUE_EXT 0x80AA
+#define LOCAL_GL_SAMPLE_MASK_INVERT_EXT 0x80AB
+#define LOCAL_GL_SAMPLE_PATTERN_EXT 0x80AC
+#define LOCAL_GL_MULTISAMPLE_BIT_EXT 0x20000000
+#define LOCAL_GL_EXT_packed_depth_stencil 1
+#define LOCAL_GL_DEPTH_STENCIL_EXT 0x84F9
+#define LOCAL_GL_UNSIGNED_INT_24_8_EXT 0x84FA
+#define LOCAL_GL_DEPTH24_STENCIL8_EXT 0x88F0
+#define LOCAL_GL_TEXTURE_STENCIL_SIZE_EXT 0x88F1
+#define LOCAL_GL_EXT_packed_pixels 1
+#define LOCAL_GL_UNSIGNED_BYTE_3_3_2_EXT 0x8032
+#define LOCAL_GL_UNSIGNED_SHORT_4_4_4_4_EXT 0x8033
+#define LOCAL_GL_UNSIGNED_SHORT_5_5_5_1_EXT 0x8034
+#define LOCAL_GL_UNSIGNED_INT_8_8_8_8_EXT 0x8035
+#define LOCAL_GL_UNSIGNED_INT_10_10_10_2_EXT 0x8036
+#define LOCAL_GL_EXT_paletted_texture 1
+#define LOCAL_GL_TEXTURE_1D 0x0DE0
+#define LOCAL_GL_TEXTURE_2D 0x0DE1
+#define LOCAL_GL_PROXY_TEXTURE_1D 0x8063
+#define LOCAL_GL_PROXY_TEXTURE_2D 0x8064
+#define LOCAL_GL_TEXTURE_3D_EXT 0x806F
+#define LOCAL_GL_PROXY_TEXTURE_3D_EXT 0x8070
+#define LOCAL_GL_COLOR_TABLE_FORMAT_EXT 0x80D8
+#define LOCAL_GL_COLOR_TABLE_WIDTH_EXT 0x80D9
+#define LOCAL_GL_COLOR_TABLE_RED_SIZE_EXT 0x80DA
+#define LOCAL_GL_COLOR_TABLE_GREEN_SIZE_EXT 0x80DB
+#define LOCAL_GL_COLOR_TABLE_BLUE_SIZE_EXT 0x80DC
+#define LOCAL_GL_COLOR_TABLE_ALPHA_SIZE_EXT 0x80DD
+#define LOCAL_GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
+#define LOCAL_GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF
+#define LOCAL_GL_COLOR_INDEX1_EXT 0x80E2
+#define LOCAL_GL_COLOR_INDEX2_EXT 0x80E3
+#define LOCAL_GL_COLOR_INDEX4_EXT 0x80E4
+#define LOCAL_GL_COLOR_INDEX8_EXT 0x80E5
+#define LOCAL_GL_COLOR_INDEX12_EXT 0x80E6
+#define LOCAL_GL_COLOR_INDEX16_EXT 0x80E7
+#define LOCAL_GL_TEXTURE_INDEX_SIZE_EXT 0x80ED
+#define LOCAL_GL_TEXTURE_CUBE_MAP_ARB 0x8513
+#define LOCAL_GL_PROXY_TEXTURE_CUBE_MAP_ARB 0x851B
+#define LOCAL_GL_EXT_pixel_buffer_object 1
+#define LOCAL_GL_PIXEL_PACK_BUFFER_EXT 0x88EB
+#define LOCAL_GL_PIXEL_UNPACK_BUFFER_EXT 0x88EC
+#define LOCAL_GL_PIXEL_PACK_BUFFER_BINDING_EXT 0x88ED
+#define LOCAL_GL_PIXEL_UNPACK_BUFFER_BINDING_EXT 0x88EF
+#define LOCAL_GL_EXT_pixel_transform 1
+#define LOCAL_GL_PIXEL_TRANSFORM_2D_EXT 0x8330
+#define LOCAL_GL_PIXEL_MAG_FILTER_EXT 0x8331
+#define LOCAL_GL_PIXEL_MIN_FILTER_EXT 0x8332
+#define LOCAL_GL_PIXEL_CUBIC_WEIGHT_EXT 0x8333
+#define LOCAL_GL_CUBIC_EXT 0x8334
+#define LOCAL_GL_AVERAGE_EXT 0x8335
+#define LOCAL_GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8336
+#define LOCAL_GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8337
+#define LOCAL_GL_PIXEL_TRANSFORM_2D_MATRIX_EXT 0x8338
+#define LOCAL_GL_EXT_pixel_transform_color_table 1
+#define LOCAL_GL_EXT_point_parameters 1
+#define LOCAL_GL_POINT_SIZE_MIN_EXT 0x8126
+#define LOCAL_GL_POINT_SIZE_MAX_EXT 0x8127
+#define LOCAL_GL_POINT_FADE_THRESHOLD_SIZE_EXT 0x8128
+#define LOCAL_GL_DISTANCE_ATTENUATION_EXT 0x8129
+#define LOCAL_GL_EXT_polygon_offset 1
+#define LOCAL_GL_POLYGON_OFFSET_EXT 0x8037
+#define LOCAL_GL_POLYGON_OFFSET_FACTOR_EXT 0x8038
+#define LOCAL_GL_POLYGON_OFFSET_BIAS_EXT 0x8039
+#define LOCAL_GL_EXT_rescale_normal 1
+#define LOCAL_GL_EXT_scene_marker 1
+#define LOCAL_GL_EXT_secondary_color 1
+#define LOCAL_GL_COLOR_SUM_EXT 0x8458
+#define LOCAL_GL_CURRENT_SECONDARY_COLOR_EXT 0x8459
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_SIZE_EXT 0x845A
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_TYPE_EXT 0x845B
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT 0x845C
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_EXT 0x845E
+#define LOCAL_GL_EXT_separate_specular_color 1
+#define LOCAL_GL_LIGHT_MODEL_COLOR_CONTROL_EXT 0x81F8
+#define LOCAL_GL_SINGLE_COLOR_EXT 0x81F9
+#define LOCAL_GL_SEPARATE_SPECULAR_COLOR_EXT 0x81FA
+#define LOCAL_GL_EXT_shadow_funcs 1
+#define LOCAL_GL_EXT_shared_texture_palette 1
+#define LOCAL_GL_SHARED_TEXTURE_PALETTE_EXT 0x81FB
+#define LOCAL_GL_EXT_stencil_clear_tag 1
+#define LOCAL_GL_STENCIL_TAG_BITS_EXT 0x88F2
+#define LOCAL_GL_STENCIL_CLEAR_TAG_VALUE_EXT 0x88F3
+#define LOCAL_GL_EXT_stencil_two_side 1
+#define LOCAL_GL_STENCIL_TEST_TWO_SIDE_EXT 0x8910
+#define LOCAL_GL_ACTIVE_STENCIL_FACE_EXT 0x8911
+#define LOCAL_GL_EXT_stencil_wrap 1
+#define LOCAL_GL_INCR_WRAP_EXT 0x8507
+#define LOCAL_GL_DECR_WRAP_EXT 0x8508
+#define LOCAL_GL_EXT_subtexture 1
+#define LOCAL_GL_EXT_texture 1
+#define LOCAL_GL_ALPHA4_EXT 0x803B
+#define LOCAL_GL_ALPHA8_EXT 0x803C
+#define LOCAL_GL_ALPHA12_EXT 0x803D
+#define LOCAL_GL_ALPHA16_EXT 0x803E
+#define LOCAL_GL_LUMINANCE4_EXT 0x803F
+#define LOCAL_GL_LUMINANCE8_EXT 0x8040
+#define LOCAL_GL_LUMINANCE12_EXT 0x8041
+#define LOCAL_GL_LUMINANCE16_EXT 0x8042
+#define LOCAL_GL_LUMINANCE4_ALPHA4_EXT 0x8043
+#define LOCAL_GL_LUMINANCE6_ALPHA2_EXT 0x8044
+#define LOCAL_GL_LUMINANCE8_ALPHA8_EXT 0x8045
+#define LOCAL_GL_LUMINANCE12_ALPHA4_EXT 0x8046
+#define LOCAL_GL_LUMINANCE12_ALPHA12_EXT 0x8047
+#define LOCAL_GL_LUMINANCE16_ALPHA16_EXT 0x8048
+#define LOCAL_GL_INTENSITY_EXT 0x8049
+#define LOCAL_GL_INTENSITY4_EXT 0x804A
+#define LOCAL_GL_INTENSITY8_EXT 0x804B
+#define LOCAL_GL_INTENSITY12_EXT 0x804C
+#define LOCAL_GL_INTENSITY16_EXT 0x804D
+#define LOCAL_GL_RGB2_EXT 0x804E
+#define LOCAL_GL_RGB4_EXT 0x804F
+#define LOCAL_GL_RGB5_EXT 0x8050
+#define LOCAL_GL_RGB8_EXT 0x8051
+#define LOCAL_GL_RGB10_EXT 0x8052
+#define LOCAL_GL_RGB12_EXT 0x8053
+#define LOCAL_GL_RGB16_EXT 0x8054
+#define LOCAL_GL_RGBA2_EXT 0x8055
+#define LOCAL_GL_RGBA4_EXT 0x8056
+#define LOCAL_GL_RGB5_A1_EXT 0x8057
+#define LOCAL_GL_RGBA8_EXT 0x8058
+#define LOCAL_GL_RGB10_A2_EXT 0x8059
+#define LOCAL_GL_RGBA12_EXT 0x805A
+#define LOCAL_GL_RGBA16_EXT 0x805B
+#define LOCAL_GL_TEXTURE_RED_SIZE_EXT 0x805C
+#define LOCAL_GL_TEXTURE_GREEN_SIZE_EXT 0x805D
+#define LOCAL_GL_TEXTURE_BLUE_SIZE_EXT 0x805E
+#define LOCAL_GL_TEXTURE_ALPHA_SIZE_EXT 0x805F
+#define LOCAL_GL_TEXTURE_LUMINANCE_SIZE_EXT 0x8060
+#define LOCAL_GL_TEXTURE_INTENSITY_SIZE_EXT 0x8061
+#define LOCAL_GL_REPLACE_EXT 0x8062
+#define LOCAL_GL_PROXY_TEXTURE_1D_EXT 0x8063
+#define LOCAL_GL_PROXY_TEXTURE_2D_EXT 0x8064
+#define LOCAL_GL_EXT_texture3D 1
+#define LOCAL_GL_PACK_SKIP_IMAGES_EXT 0x806B
+#define LOCAL_GL_PACK_IMAGE_HEIGHT_EXT 0x806C
+#define LOCAL_GL_UNPACK_SKIP_IMAGES_EXT 0x806D
+#define LOCAL_GL_UNPACK_IMAGE_HEIGHT_EXT 0x806E
+#define LOCAL_GL_TEXTURE_3D_EXT 0x806F
+#define LOCAL_GL_PROXY_TEXTURE_3D_EXT 0x8070
+#define LOCAL_GL_TEXTURE_DEPTH_EXT 0x8071
+#define LOCAL_GL_TEXTURE_WRAP_R_EXT 0x8072
+#define LOCAL_GL_MAX_3D_TEXTURE_SIZE_EXT 0x8073
+#define LOCAL_GL_EXT_texture_compression_dxt1 1
+#define LOCAL_GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
+#define LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1
+#define LOCAL_GL_EXT_texture_compression_s3tc 1
+#define LOCAL_GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
+#define LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT1_EXT 0x83F1
+#define LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT3_EXT 0x83F2
+#define LOCAL_GL_COMPRESSED_RGBA_S3TC_DXT5_EXT 0x83F3
+#define LOCAL_GL_EXT_texture_cube_map 1
+#define LOCAL_GL_NORMAL_MAP_EXT 0x8511
+#define LOCAL_GL_REFLECTION_MAP_EXT 0x8512
+#define LOCAL_GL_TEXTURE_CUBE_MAP_EXT 0x8513
+#define LOCAL_GL_TEXTURE_BINDING_CUBE_MAP_EXT 0x8514
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT 0x8515
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT 0x8516
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT 0x8517
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT 0x8518
+#define LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT 0x8519
+#define LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT 0x851A
+#define LOCAL_GL_PROXY_TEXTURE_CUBE_MAP_EXT 0x851B
+#define LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT 0x851C
+#define LOCAL_GL_EXT_texture_edge_clamp 1
+#define LOCAL_GL_CLAMP_TO_EDGE_EXT 0x812F
+#define LOCAL_GL_EXT_texture_env 1
+#define LOCAL_GL_TEXTURE_ENV0_EXT 0
+#define LOCAL_GL_ENV_BLEND_EXT 0
+#define LOCAL_GL_TEXTURE_ENV_SHIFT_EXT 0
+#define LOCAL_GL_ENV_REPLACE_EXT 0
+#define LOCAL_GL_ENV_ADD_EXT 0
+#define LOCAL_GL_ENV_SUBTRACT_EXT 0
+#define LOCAL_GL_TEXTURE_ENV_MODE_ALPHA_EXT 0
+#define LOCAL_GL_ENV_REVERSE_SUBTRACT_EXT 0
+#define LOCAL_GL_ENV_REVERSE_BLEND_EXT 0
+#define LOCAL_GL_ENV_COPY_EXT 0
+#define LOCAL_GL_ENV_MODULATE_EXT 0
+#define LOCAL_GL_EXT_texture_env_add 1
+#define LOCAL_GL_EXT_texture_env_combine 1
+#define LOCAL_GL_COMBINE_EXT 0x8570
+#define LOCAL_GL_COMBINE_RGB_EXT 0x8571
+#define LOCAL_GL_COMBINE_ALPHA_EXT 0x8572
+#define LOCAL_GL_RGB_SCALE_EXT 0x8573
+#define LOCAL_GL_ADD_SIGNED_EXT 0x8574
+#define LOCAL_GL_INTERPOLATE_EXT 0x8575
+#define LOCAL_GL_CONSTANT_EXT 0x8576
+#define LOCAL_GL_PRIMARY_COLOR_EXT 0x8577
+#define LOCAL_GL_PREVIOUS_EXT 0x8578
+#define LOCAL_GL_SOURCE0_RGB_EXT 0x8580
+#define LOCAL_GL_SOURCE1_RGB_EXT 0x8581
+#define LOCAL_GL_SOURCE2_RGB_EXT 0x8582
+#define LOCAL_GL_SOURCE0_ALPHA_EXT 0x8588
+#define LOCAL_GL_SOURCE1_ALPHA_EXT 0x8589
+#define LOCAL_GL_SOURCE2_ALPHA_EXT 0x858A
+#define LOCAL_GL_OPERAND0_RGB_EXT 0x8590
+#define LOCAL_GL_OPERAND1_RGB_EXT 0x8591
+#define LOCAL_GL_OPERAND2_RGB_EXT 0x8592
+#define LOCAL_GL_OPERAND0_ALPHA_EXT 0x8598
+#define LOCAL_GL_OPERAND1_ALPHA_EXT 0x8599
+#define LOCAL_GL_OPERAND2_ALPHA_EXT 0x859A
+#define LOCAL_GL_EXT_texture_env_dot3 1
+#define LOCAL_GL_DOT3_RGB_EXT 0x8740
+#define LOCAL_GL_DOT3_RGBA_EXT 0x8741
+#define LOCAL_GL_EXT_texture_filter_anisotropic 1
+#define LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT 0x84FE
+#define LOCAL_GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+#define LOCAL_GL_EXT_texture_lod_bias 1
+#define LOCAL_GL_MAX_TEXTURE_LOD_BIAS_EXT 0x84FD
+#define LOCAL_GL_TEXTURE_FILTER_CONTROL_EXT 0x8500
+#define LOCAL_GL_TEXTURE_LOD_BIAS_EXT 0x8501
+#define LOCAL_GL_EXT_texture_mirror_clamp 1
+#define LOCAL_GL_MIRROR_CLAMP_EXT 0x8742
+#define LOCAL_GL_MIRROR_CLAMP_TO_EDGE_EXT 0x8743
+#define LOCAL_GL_MIRROR_CLAMP_TO_BORDER_EXT 0x8912
+#define LOCAL_GL_EXT_texture_object 1
+#define LOCAL_GL_TEXTURE_PRIORITY_EXT 0x8066
+#define LOCAL_GL_TEXTURE_RESIDENT_EXT 0x8067
+#define LOCAL_GL_TEXTURE_1D_BINDING_EXT 0x8068
+#define LOCAL_GL_TEXTURE_2D_BINDING_EXT 0x8069
+#define LOCAL_GL_TEXTURE_3D_BINDING_EXT 0x806A
+#define LOCAL_GL_EXT_texture_perturb_normal 1
+#define LOCAL_GL_PERTURB_EXT 0x85AE
+#define LOCAL_GL_TEXTURE_NORMAL_EXT 0x85AF
+#define LOCAL_GL_EXT_texture_rectangle 1
+#define LOCAL_GL_TEXTURE_RECTANGLE_EXT 0x84F5
+#define LOCAL_GL_TEXTURE_BINDING_RECTANGLE_EXT 0x84F6
+#define LOCAL_GL_PROXY_TEXTURE_RECTANGLE_EXT 0x84F7
+#define LOCAL_GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT 0x84F8
+#define LOCAL_GL_EXT_texture_sRGB 1
+#define LOCAL_GL_SRGB_EXT 0x8C40
+#define LOCAL_GL_SRGB8_EXT 0x8C41
+#define LOCAL_GL_SRGB_ALPHA_EXT 0x8C42
+#define LOCAL_GL_SRGB8_ALPHA8_EXT 0x8C43
+#define LOCAL_GL_SLUMINANCE_ALPHA_EXT 0x8C44
+#define LOCAL_GL_SLUMINANCE8_ALPHA8_EXT 0x8C45
+#define LOCAL_GL_SLUMINANCE_EXT 0x8C46
+#define LOCAL_GL_SLUMINANCE8_EXT 0x8C47
+#define LOCAL_GL_COMPRESSED_SRGB_EXT 0x8C48
+#define LOCAL_GL_COMPRESSED_SRGB_ALPHA_EXT 0x8C49
+#define LOCAL_GL_COMPRESSED_SLUMINANCE_EXT 0x8C4A
+#define LOCAL_GL_COMPRESSED_SLUMINANCE_ALPHA_EXT 0x8C4B
+#define LOCAL_GL_COMPRESSED_SRGB_S3TC_DXT1_EXT 0x8C4C
+#define LOCAL_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT 0x8C4D
+#define LOCAL_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT 0x8C4E
+#define LOCAL_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT 0x8C4F
+#define LOCAL_GL_EXT_vertex_array 1
+#define LOCAL_GL_DOUBLE_EXT 0x140A
+#define LOCAL_GL_VERTEX_ARRAY_EXT 0x8074
+#define LOCAL_GL_NORMAL_ARRAY_EXT 0x8075
+#define LOCAL_GL_COLOR_ARRAY_EXT 0x8076
+#define LOCAL_GL_INDEX_ARRAY_EXT 0x8077
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_EXT 0x8078
+#define LOCAL_GL_EDGE_FLAG_ARRAY_EXT 0x8079
+#define LOCAL_GL_VERTEX_ARRAY_SIZE_EXT 0x807A
+#define LOCAL_GL_VERTEX_ARRAY_TYPE_EXT 0x807B
+#define LOCAL_GL_VERTEX_ARRAY_STRIDE_EXT 0x807C
+#define LOCAL_GL_VERTEX_ARRAY_COUNT_EXT 0x807D
+#define LOCAL_GL_NORMAL_ARRAY_TYPE_EXT 0x807E
+#define LOCAL_GL_NORMAL_ARRAY_STRIDE_EXT 0x807F
+#define LOCAL_GL_NORMAL_ARRAY_COUNT_EXT 0x8080
+#define LOCAL_GL_COLOR_ARRAY_SIZE_EXT 0x8081
+#define LOCAL_GL_COLOR_ARRAY_TYPE_EXT 0x8082
+#define LOCAL_GL_COLOR_ARRAY_STRIDE_EXT 0x8083
+#define LOCAL_GL_COLOR_ARRAY_COUNT_EXT 0x8084
+#define LOCAL_GL_INDEX_ARRAY_TYPE_EXT 0x8085
+#define LOCAL_GL_INDEX_ARRAY_STRIDE_EXT 0x8086
+#define LOCAL_GL_INDEX_ARRAY_COUNT_EXT 0x8087
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_SIZE_EXT 0x8088
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_TYPE_EXT 0x8089
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_COUNT_EXT 0x808B
+#define LOCAL_GL_EDGE_FLAG_ARRAY_STRIDE_EXT 0x808C
+#define LOCAL_GL_EDGE_FLAG_ARRAY_COUNT_EXT 0x808D
+#define LOCAL_GL_VERTEX_ARRAY_POINTER_EXT 0x808E
+#define LOCAL_GL_NORMAL_ARRAY_POINTER_EXT 0x808F
+#define LOCAL_GL_COLOR_ARRAY_POINTER_EXT 0x8090
+#define LOCAL_GL_INDEX_ARRAY_POINTER_EXT 0x8091
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
+#define LOCAL_GL_EDGE_FLAG_ARRAY_POINTER_EXT 0x8093
+#define LOCAL_GL_EXT_vertex_shader 1
+#define LOCAL_GL_VERTEX_SHADER_EXT 0x8780
+#define LOCAL_GL_VERTEX_SHADER_BINDING_EXT 0x8781
+#define LOCAL_GL_OP_INDEX_EXT 0x8782
+#define LOCAL_GL_OP_NEGATE_EXT 0x8783
+#define LOCAL_GL_OP_DOT3_EXT 0x8784
+#define LOCAL_GL_OP_DOT4_EXT 0x8785
+#define LOCAL_GL_OP_MUL_EXT 0x8786
+#define LOCAL_GL_OP_ADD_EXT 0x8787
+#define LOCAL_GL_OP_MADD_EXT 0x8788
+#define LOCAL_GL_OP_FRAC_EXT 0x8789
+#define LOCAL_GL_OP_MAX_EXT 0x878A
+#define LOCAL_GL_OP_MIN_EXT 0x878B
+#define LOCAL_GL_OP_SET_GE_EXT 0x878C
+#define LOCAL_GL_OP_SET_LT_EXT 0x878D
+#define LOCAL_GL_OP_CLAMP_EXT 0x878E
+#define LOCAL_GL_OP_FLOOR_EXT 0x878F
+#define LOCAL_GL_OP_ROUND_EXT 0x8790
+#define LOCAL_GL_OP_EXP_BASE_2_EXT 0x8791
+#define LOCAL_GL_OP_LOG_BASE_2_EXT 0x8792
+#define LOCAL_GL_OP_POWER_EXT 0x8793
+#define LOCAL_GL_OP_RECIP_EXT 0x8794
+#define LOCAL_GL_OP_RECIP_SQRT_EXT 0x8795
+#define LOCAL_GL_OP_SUB_EXT 0x8796
+#define LOCAL_GL_OP_CROSS_PRODUCT_EXT 0x8797
+#define LOCAL_GL_OP_MULTIPLY_MATRIX_EXT 0x8798
+#define LOCAL_GL_OP_MOV_EXT 0x8799
+#define LOCAL_GL_OUTPUT_VERTEX_EXT 0x879A
+#define LOCAL_GL_OUTPUT_COLOR0_EXT 0x879B
+#define LOCAL_GL_OUTPUT_COLOR1_EXT 0x879C
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD0_EXT 0x879D
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD1_EXT 0x879E
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD2_EXT 0x879F
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD3_EXT 0x87A0
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD4_EXT 0x87A1
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD5_EXT 0x87A2
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD6_EXT 0x87A3
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD7_EXT 0x87A4
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD8_EXT 0x87A5
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD9_EXT 0x87A6
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD10_EXT 0x87A7
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD11_EXT 0x87A8
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD12_EXT 0x87A9
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD13_EXT 0x87AA
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD14_EXT 0x87AB
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD15_EXT 0x87AC
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD16_EXT 0x87AD
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD17_EXT 0x87AE
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD18_EXT 0x87AF
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD19_EXT 0x87B0
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD20_EXT 0x87B1
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD21_EXT 0x87B2
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD22_EXT 0x87B3
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD23_EXT 0x87B4
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD24_EXT 0x87B5
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD25_EXT 0x87B6
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD26_EXT 0x87B7
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD27_EXT 0x87B8
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD28_EXT 0x87B9
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD29_EXT 0x87BA
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD30_EXT 0x87BB
+#define LOCAL_GL_OUTPUT_TEXTURE_COORD31_EXT 0x87BC
+#define LOCAL_GL_OUTPUT_FOG_EXT 0x87BD
+#define LOCAL_GL_SCALAR_EXT 0x87BE
+#define LOCAL_GL_VECTOR_EXT 0x87BF
+#define LOCAL_GL_MATRIX_EXT 0x87C0
+#define LOCAL_GL_VARIANT_EXT 0x87C1
+#define LOCAL_GL_INVARIANT_EXT 0x87C2
+#define LOCAL_GL_LOCAL_CONSTANT_EXT 0x87C3
+#define LOCAL_GL_LOCAL_EXT 0x87C4
+#define LOCAL_GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87C5
+#define LOCAL_GL_MAX_VERTEX_SHADER_VARIANTS_EXT 0x87C6
+#define LOCAL_GL_MAX_VERTEX_SHADER_INVARIANTS_EXT 0x87C7
+#define LOCAL_GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87C8
+#define LOCAL_GL_MAX_VERTEX_SHADER_LOCALS_EXT 0x87C9
+#define LOCAL_GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CA
+#define LOCAL_GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT 0x87CB
+#define LOCAL_GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT 0x87CC
+#define LOCAL_GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87CD
+#define LOCAL_GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT 0x87CE
+#define LOCAL_GL_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CF
+#define LOCAL_GL_VERTEX_SHADER_VARIANTS_EXT 0x87D0
+#define LOCAL_GL_VERTEX_SHADER_INVARIANTS_EXT 0x87D1
+#define LOCAL_GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87D2
+#define LOCAL_GL_VERTEX_SHADER_LOCALS_EXT 0x87D3
+#define LOCAL_GL_VERTEX_SHADER_OPTIMIZED_EXT 0x87D4
+#define LOCAL_GL_X_EXT 0x87D5
+#define LOCAL_GL_Y_EXT 0x87D6
+#define LOCAL_GL_Z_EXT 0x87D7
+#define LOCAL_GL_W_EXT 0x87D8
+#define LOCAL_GL_NEGATIVE_X_EXT 0x87D9
+#define LOCAL_GL_NEGATIVE_Y_EXT 0x87DA
+#define LOCAL_GL_NEGATIVE_Z_EXT 0x87DB
+#define LOCAL_GL_NEGATIVE_W_EXT 0x87DC
+#define LOCAL_GL_ZERO_EXT 0x87DD
+#define LOCAL_GL_ONE_EXT 0x87DE
+#define LOCAL_GL_NEGATIVE_ONE_EXT 0x87DF
+#define LOCAL_GL_NORMALIZED_RANGE_EXT 0x87E0
+#define LOCAL_GL_FULL_RANGE_EXT 0x87E1
+#define LOCAL_GL_CURRENT_VERTEX_EXT 0x87E2
+#define LOCAL_GL_MVP_MATRIX_EXT 0x87E3
+#define LOCAL_GL_VARIANT_VALUE_EXT 0x87E4
+#define LOCAL_GL_VARIANT_DATATYPE_EXT 0x87E5
+#define LOCAL_GL_VARIANT_ARRAY_STRIDE_EXT 0x87E6
+#define LOCAL_GL_VARIANT_ARRAY_TYPE_EXT 0x87E7
+#define LOCAL_GL_VARIANT_ARRAY_EXT 0x87E8
+#define LOCAL_GL_VARIANT_ARRAY_POINTER_EXT 0x87E9
+#define LOCAL_GL_INVARIANT_VALUE_EXT 0x87EA
+#define LOCAL_GL_INVARIANT_DATATYPE_EXT 0x87EB
+#define LOCAL_GL_LOCAL_CONSTANT_VALUE_EXT 0x87EC
+#define LOCAL_GL_LOCAL_CONSTANT_DATATYPE_EXT 0x87ED
+#define LOCAL_GL_EXT_vertex_weighting 1
+#define LOCAL_GL_MODELVIEW0_STACK_DEPTH_EXT 0x0BA3
+#define LOCAL_GL_MODELVIEW0_MATRIX_EXT 0x0BA6
+#define LOCAL_GL_MODELVIEW0_EXT 0x1700
+#define LOCAL_GL_MODELVIEW1_STACK_DEPTH_EXT 0x8502
+#define LOCAL_GL_MODELVIEW1_MATRIX_EXT 0x8506
+#define LOCAL_GL_VERTEX_WEIGHTING_EXT 0x8509
+#define LOCAL_GL_MODELVIEW1_EXT 0x850A
+#define LOCAL_GL_CURRENT_VERTEX_WEIGHT_EXT 0x850B
+#define LOCAL_GL_VERTEX_WEIGHT_ARRAY_EXT 0x850C
+#define LOCAL_GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT 0x850D
+#define LOCAL_GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT 0x850E
+#define LOCAL_GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT 0x850F
+#define LOCAL_GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
+#define LOCAL_GL_GREMEDY_string_marker 1
+#define LOCAL_GL_HP_convolution_border_modes 1
+#define LOCAL_GL_HP_image_transform 1
+#define LOCAL_GL_HP_occlusion_test 1
+#define LOCAL_GL_OCCLUSION_TEST_HP 0x8165
+#define LOCAL_GL_OCCLUSION_TEST_RESULT_HP 0x8166
+#define LOCAL_GL_HP_texture_lighting 1
+#define LOCAL_GL_IBM_cull_vertex 1
+#define LOCAL_GL_CULL_VERTEX_IBM 103050
+#define LOCAL_GL_IBM_multimode_draw_arrays 1
+#define LOCAL_GL_IBM_rasterpos_clip 1
+#define LOCAL_GL_RASTER_POSITION_UNCLIPPED_IBM 103010
+#define LOCAL_GL_IBM_static_data 1
+#define LOCAL_GL_ALL_STATIC_DATA_IBM 103060
+#define LOCAL_GL_STATIC_VERTEX_ARRAY_IBM 103061
+#define LOCAL_GL_IBM_texture_mirrored_repeat 1
+#define LOCAL_GL_MIRRORED_REPEAT_IBM 0x8370
+#define LOCAL_GL_IBM_vertex_array_lists 1
+#define LOCAL_GL_VERTEX_ARRAY_LIST_IBM 103070
+#define LOCAL_GL_NORMAL_ARRAY_LIST_IBM 103071
+#define LOCAL_GL_COLOR_ARRAY_LIST_IBM 103072
+#define LOCAL_GL_INDEX_ARRAY_LIST_IBM 103073
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_LIST_IBM 103074
+#define LOCAL_GL_EDGE_FLAG_ARRAY_LIST_IBM 103075
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_LIST_IBM 103076
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_LIST_IBM 103077
+#define LOCAL_GL_VERTEX_ARRAY_LIST_STRIDE_IBM 103080
+#define LOCAL_GL_NORMAL_ARRAY_LIST_STRIDE_IBM 103081
+#define LOCAL_GL_COLOR_ARRAY_LIST_STRIDE_IBM 103082
+#define LOCAL_GL_INDEX_ARRAY_LIST_STRIDE_IBM 103083
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM 103084
+#define LOCAL_GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM 103085
+#define LOCAL_GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM 103086
+#define LOCAL_GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM 103087
+#define LOCAL_GL_INGR_color_clamp 1
+#define LOCAL_GL_RED_MIN_CLAMP_INGR 0x8560
+#define LOCAL_GL_GREEN_MIN_CLAMP_INGR 0x8561
+#define LOCAL_GL_BLUE_MIN_CLAMP_INGR 0x8562
+#define LOCAL_GL_ALPHA_MIN_CLAMP_INGR 0x8563
+#define LOCAL_GL_RED_MAX_CLAMP_INGR 0x8564
+#define LOCAL_GL_GREEN_MAX_CLAMP_INGR 0x8565
+#define LOCAL_GL_BLUE_MAX_CLAMP_INGR 0x8566
+#define LOCAL_GL_ALPHA_MAX_CLAMP_INGR 0x8567
+#define LOCAL_GL_INGR_interlace_read 1
+#define LOCAL_GL_INTERLACE_READ_INGR 0x8568
+#define LOCAL_GL_INTEL_parallel_arrays 1
+#define LOCAL_GL_PARALLEL_ARRAYS_INTEL 0x83F4
+#define LOCAL_GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL 0x83F5
+#define LOCAL_GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
+#define LOCAL_GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
+#define LOCAL_GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
+#define LOCAL_GL_INTEL_texture_scissor 1
+#define LOCAL_GL_KTX_buffer_region 1
+#define LOCAL_GL_KTX_FRONT_REGION 0x0
+#define LOCAL_GL_KTX_BACK_REGION 0x1
+#define LOCAL_GL_KTX_Z_REGION 0x2
+#define LOCAL_GL_KTX_STENCIL_REGION 0x3
+#define LOCAL_GL_MESAX_texture_stack 1
+#define LOCAL_GL_TEXTURE_1D_STACK_MESAX 0x8759
+#define LOCAL_GL_TEXTURE_2D_STACK_MESAX 0x875A
+#define LOCAL_GL_PROXY_TEXTURE_1D_STACK_MESAX 0x875B
+#define LOCAL_GL_PROXY_TEXTURE_2D_STACK_MESAX 0x875C
+#define LOCAL_GL_TEXTURE_1D_STACK_BINDING_MESAX 0x875D
+#define LOCAL_GL_TEXTURE_2D_STACK_BINDING_MESAX 0x875E
+#define LOCAL_GL_MESA_pack_invert 1
+#define LOCAL_GL_PACK_INVERT_MESA 0x8758
+#define LOCAL_GL_MESA_resize_buffers 1
+#define LOCAL_GL_MESA_window_pos 1
+#define LOCAL_GL_MESA_ycbcr_texture 1
+#define LOCAL_GL_UNSIGNED_SHORT_8_8_MESA 0x85BA
+#define LOCAL_GL_UNSIGNED_SHORT_8_8_REV_MESA 0x85BB
+#define LOCAL_GL_YCBCR_MESA 0x8757
+#define LOCAL_GL_NV_blend_square 1
+#define LOCAL_GL_NV_copy_depth_to_color 1
+#define LOCAL_GL_DEPTH_STENCIL_TO_RGBA_NV 0x886E
+#define LOCAL_GL_DEPTH_STENCIL_TO_BGRA_NV 0x886F
+#define LOCAL_GL_NV_depth_clamp 1
+#define LOCAL_GL_DEPTH_CLAMP_NV 0x864F
+#define LOCAL_GL_NV_evaluators 1
+#define LOCAL_GL_EVAL_2D_NV 0x86C0
+#define LOCAL_GL_EVAL_TRIANGULAR_2D_NV 0x86C1
+#define LOCAL_GL_MAP_TESSELLATION_NV 0x86C2
+#define LOCAL_GL_MAP_ATTRIB_U_ORDER_NV 0x86C3
+#define LOCAL_GL_MAP_ATTRIB_V_ORDER_NV 0x86C4
+#define LOCAL_GL_EVAL_FRACTIONAL_TESSELLATION_NV 0x86C5
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB0_NV 0x86C6
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB1_NV 0x86C7
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB2_NV 0x86C8
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB3_NV 0x86C9
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB4_NV 0x86CA
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB5_NV 0x86CB
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB6_NV 0x86CC
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB7_NV 0x86CD
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB8_NV 0x86CE
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB9_NV 0x86CF
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB10_NV 0x86D0
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB11_NV 0x86D1
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB12_NV 0x86D2
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB13_NV 0x86D3
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB14_NV 0x86D4
+#define LOCAL_GL_EVAL_VERTEX_ATTRIB15_NV 0x86D5
+#define LOCAL_GL_MAX_MAP_TESSELLATION_NV 0x86D6
+#define LOCAL_GL_MAX_RATIONAL_EVAL_ORDER_NV 0x86D7
+#define LOCAL_GL_NV_fence 1
+#define LOCAL_GL_ALL_COMPLETED_NV 0x84F2
+#define LOCAL_GL_FENCE_STATUS_NV 0x84F3
+#define LOCAL_GL_FENCE_CONDITION_NV 0x84F4
+#define LOCAL_GL_NV_float_buffer 1
+#define LOCAL_GL_FLOAT_R_NV 0x8880
+#define LOCAL_GL_FLOAT_RG_NV 0x8881
+#define LOCAL_GL_FLOAT_RGB_NV 0x8882
+#define LOCAL_GL_FLOAT_RGBA_NV 0x8883
+#define LOCAL_GL_FLOAT_R16_NV 0x8884
+#define LOCAL_GL_FLOAT_R32_NV 0x8885
+#define LOCAL_GL_FLOAT_RG16_NV 0x8886
+#define LOCAL_GL_FLOAT_RG32_NV 0x8887
+#define LOCAL_GL_FLOAT_RGB16_NV 0x8888
+#define LOCAL_GL_FLOAT_RGB32_NV 0x8889
+#define LOCAL_GL_FLOAT_RGBA16_NV 0x888A
+#define LOCAL_GL_FLOAT_RGBA32_NV 0x888B
+#define LOCAL_GL_TEXTURE_FLOAT_COMPONENTS_NV 0x888C
+#define LOCAL_GL_FLOAT_CLEAR_COLOR_VALUE_NV 0x888D
+#define LOCAL_GL_FLOAT_RGBA_MODE_NV 0x888E
+#define LOCAL_GL_NV_fog_distance 1
+#define LOCAL_GL_FOG_DISTANCE_MODE_NV 0x855A
+#define LOCAL_GL_EYE_RADIAL_NV 0x855B
+#define LOCAL_GL_EYE_PLANE_ABSOLUTE_NV 0x855C
+#define LOCAL_GL_NV_fragment_program 1
+#define LOCAL_GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV 0x8868
+#define LOCAL_GL_FRAGMENT_PROGRAM_NV 0x8870
+#define LOCAL_GL_MAX_TEXTURE_COORDS_NV 0x8871
+#define LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS_NV 0x8872
+#define LOCAL_GL_FRAGMENT_PROGRAM_BINDING_NV 0x8873
+#define LOCAL_GL_PROGRAM_ERROR_STRING_NV 0x8874
+#define LOCAL_GL_NV_fragment_program2 1
+#define LOCAL_GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
+#define LOCAL_GL_MAX_PROGRAM_CALL_DEPTH_NV 0x88F5
+#define LOCAL_GL_MAX_PROGRAM_IF_DEPTH_NV 0x88F6
+#define LOCAL_GL_MAX_PROGRAM_LOOP_DEPTH_NV 0x88F7
+#define LOCAL_GL_MAX_PROGRAM_LOOP_COUNT_NV 0x88F8
+#define LOCAL_GL_NV_fragment_program_option 1
+#define LOCAL_GL_NV_half_float 1
+#define LOCAL_GL_HALF_FLOAT_NV 0x140B
+#define LOCAL_GL_NV_light_max_exponent 1
+#define LOCAL_GL_MAX_SHININESS_NV 0x8504
+#define LOCAL_GL_MAX_SPOT_EXPONENT_NV 0x8505
+#define LOCAL_GL_NV_multisample_filter_hint 1
+#define LOCAL_GL_MULTISAMPLE_FILTER_HINT_NV 0x8534
+#define LOCAL_GL_NV_occlusion_query 1
+#define LOCAL_GL_PIXEL_COUNTER_BITS_NV 0x8864
+#define LOCAL_GL_CURRENT_OCCLUSION_QUERY_ID_NV 0x8865
+#define LOCAL_GL_PIXEL_COUNT_NV 0x8866
+#define LOCAL_GL_PIXEL_COUNT_AVAILABLE_NV 0x8867
+#define LOCAL_GL_NV_packed_depth_stencil 1
+#define LOCAL_GL_DEPTH_STENCIL_NV 0x84F9
+#define LOCAL_GL_UNSIGNED_INT_24_8_NV 0x84FA
+#define LOCAL_GL_NV_pixel_data_range 1
+#define LOCAL_GL_WRITE_PIXEL_DATA_RANGE_NV 0x8878
+#define LOCAL_GL_READ_PIXEL_DATA_RANGE_NV 0x8879
+#define LOCAL_GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV 0x887A
+#define LOCAL_GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
+#define LOCAL_GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
+#define LOCAL_GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
+#define LOCAL_GL_NV_point_sprite 1
+#define LOCAL_GL_POINT_SPRITE_NV 0x8861
+#define LOCAL_GL_COORD_REPLACE_NV 0x8862
+#define LOCAL_GL_POINT_SPRITE_R_MODE_NV 0x8863
+#define LOCAL_GL_NV_primitive_restart 1
+#define LOCAL_GL_PRIMITIVE_RESTART_NV 0x8558
+#define LOCAL_GL_PRIMITIVE_RESTART_INDEX_NV 0x8559
+#define LOCAL_GL_NV_register_combiners 1
+#define LOCAL_GL_REGISTER_COMBINERS_NV 0x8522
+#define LOCAL_GL_VARIABLE_A_NV 0x8523
+#define LOCAL_GL_VARIABLE_B_NV 0x8524
+#define LOCAL_GL_VARIABLE_C_NV 0x8525
+#define LOCAL_GL_VARIABLE_D_NV 0x8526
+#define LOCAL_GL_VARIABLE_E_NV 0x8527
+#define LOCAL_GL_VARIABLE_F_NV 0x8528
+#define LOCAL_GL_VARIABLE_G_NV 0x8529
+#define LOCAL_GL_CONSTANT_COLOR0_NV 0x852A
+#define LOCAL_GL_CONSTANT_COLOR1_NV 0x852B
+#define LOCAL_GL_PRIMARY_COLOR_NV 0x852C
+#define LOCAL_GL_SECONDARY_COLOR_NV 0x852D
+#define LOCAL_GL_SPARE0_NV 0x852E
+#define LOCAL_GL_SPARE1_NV 0x852F
+#define LOCAL_GL_DISCARD_NV 0x8530
+#define LOCAL_GL_E_TIMES_F_NV 0x8531
+#define LOCAL_GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
+#define LOCAL_GL_UNSIGNED_IDENTITY_NV 0x8536
+#define LOCAL_GL_UNSIGNED_INVERT_NV 0x8537
+#define LOCAL_GL_EXPAND_NORMAL_NV 0x8538
+#define LOCAL_GL_EXPAND_NEGATE_NV 0x8539
+#define LOCAL_GL_HALF_BIAS_NORMAL_NV 0x853A
+#define LOCAL_GL_HALF_BIAS_NEGATE_NV 0x853B
+#define LOCAL_GL_SIGNED_IDENTITY_NV 0x853C
+#define LOCAL_GL_SIGNED_NEGATE_NV 0x853D
+#define LOCAL_GL_SCALE_BY_TWO_NV 0x853E
+#define LOCAL_GL_SCALE_BY_FOUR_NV 0x853F
+#define LOCAL_GL_SCALE_BY_ONE_HALF_NV 0x8540
+#define LOCAL_GL_BIAS_BY_NEGATIVE_ONE_HALF_NV 0x8541
+#define LOCAL_GL_COMBINER_INPUT_NV 0x8542
+#define LOCAL_GL_COMBINER_MAPPING_NV 0x8543
+#define LOCAL_GL_COMBINER_COMPONENT_USAGE_NV 0x8544
+#define LOCAL_GL_COMBINER_AB_DOT_PRODUCT_NV 0x8545
+#define LOCAL_GL_COMBINER_CD_DOT_PRODUCT_NV 0x8546
+#define LOCAL_GL_COMBINER_MUX_SUM_NV 0x8547
+#define LOCAL_GL_COMBINER_SCALE_NV 0x8548
+#define LOCAL_GL_COMBINER_BIAS_NV 0x8549
+#define LOCAL_GL_COMBINER_AB_OUTPUT_NV 0x854A
+#define LOCAL_GL_COMBINER_CD_OUTPUT_NV 0x854B
+#define LOCAL_GL_COMBINER_SUM_OUTPUT_NV 0x854C
+#define LOCAL_GL_MAX_GENERAL_COMBINERS_NV 0x854D
+#define LOCAL_GL_NUM_GENERAL_COMBINERS_NV 0x854E
+#define LOCAL_GL_COLOR_SUM_CLAMP_NV 0x854F
+#define LOCAL_GL_COMBINER0_NV 0x8550
+#define LOCAL_GL_COMBINER1_NV 0x8551
+#define LOCAL_GL_COMBINER2_NV 0x8552
+#define LOCAL_GL_COMBINER3_NV 0x8553
+#define LOCAL_GL_COMBINER4_NV 0x8554
+#define LOCAL_GL_COMBINER5_NV 0x8555
+#define LOCAL_GL_COMBINER6_NV 0x8556
+#define LOCAL_GL_COMBINER7_NV 0x8557
+#define LOCAL_GL_NV_register_combiners2 1
+#define LOCAL_GL_PER_STAGE_CONSTANTS_NV 0x8535
+#define LOCAL_GL_NV_texgen_emboss 1
+#define LOCAL_GL_EMBOSS_LIGHT_NV 0x855D
+#define LOCAL_GL_EMBOSS_CONSTANT_NV 0x855E
+#define LOCAL_GL_EMBOSS_MAP_NV 0x855F
+#define LOCAL_GL_NV_texgen_reflection 1
+#define LOCAL_GL_NORMAL_MAP_NV 0x8511
+#define LOCAL_GL_REFLECTION_MAP_NV 0x8512
+#define LOCAL_GL_NV_texture_compression_vtc 1
+#define LOCAL_GL_NV_texture_env_combine4 1
+#define LOCAL_GL_COMBINE4_NV 0x8503
+#define LOCAL_GL_SOURCE3_RGB_NV 0x8583
+#define LOCAL_GL_SOURCE3_ALPHA_NV 0x858B
+#define LOCAL_GL_OPERAND3_RGB_NV 0x8593
+#define LOCAL_GL_OPERAND3_ALPHA_NV 0x859B
+#define LOCAL_GL_NV_texture_expand_normal 1
+#define LOCAL_GL_TEXTURE_UNSIGNED_REMAP_MODE_NV 0x888F
+#define LOCAL_GL_NV_texture_rectangle 1
+#define LOCAL_GL_TEXTURE_RECTANGLE_NV 0x84F5
+#define LOCAL_GL_TEXTURE_BINDING_RECTANGLE_NV 0x84F6
+#define LOCAL_GL_PROXY_TEXTURE_RECTANGLE_NV 0x84F7
+#define LOCAL_GL_MAX_RECTANGLE_TEXTURE_SIZE_NV 0x84F8
+#define LOCAL_GL_NV_texture_shader 1
+#define LOCAL_GL_OFFSET_TEXTURE_RECTANGLE_NV 0x864C
+#define LOCAL_GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
+#define LOCAL_GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
+#define LOCAL_GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
+#define LOCAL_GL_UNSIGNED_INT_S8_S8_8_8_NV 0x86DA
+#define LOCAL_GL_UNSIGNED_INT_8_8_S8_S8_REV_NV 0x86DB
+#define LOCAL_GL_DSDT_MAG_INTENSITY_NV 0x86DC
+#define LOCAL_GL_SHADER_CONSISTENT_NV 0x86DD
+#define LOCAL_GL_TEXTURE_SHADER_NV 0x86DE
+#define LOCAL_GL_SHADER_OPERATION_NV 0x86DF
+#define LOCAL_GL_CULL_MODES_NV 0x86E0
+#define LOCAL_GL_OFFSET_TEXTURE_MATRIX_NV 0x86E1
+#define LOCAL_GL_OFFSET_TEXTURE_SCALE_NV 0x86E2
+#define LOCAL_GL_OFFSET_TEXTURE_BIAS_NV 0x86E3
+#define LOCAL_GL_PREVIOUS_TEXTURE_INPUT_NV 0x86E4
+#define LOCAL_GL_CONST_EYE_NV 0x86E5
+#define LOCAL_GL_PASS_THROUGH_NV 0x86E6
+#define LOCAL_GL_CULL_FRAGMENT_NV 0x86E7
+#define LOCAL_GL_OFFSET_TEXTURE_2D_NV 0x86E8
+#define LOCAL_GL_DEPENDENT_AR_TEXTURE_2D_NV 0x86E9
+#define LOCAL_GL_DEPENDENT_GB_TEXTURE_2D_NV 0x86EA
+#define LOCAL_GL_DOT_PRODUCT_NV 0x86EC
+#define LOCAL_GL_DOT_PRODUCT_DEPTH_REPLACE_NV 0x86ED
+#define LOCAL_GL_DOT_PRODUCT_TEXTURE_2D_NV 0x86EE
+#define LOCAL_GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
+#define LOCAL_GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
+#define LOCAL_GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
+#define LOCAL_GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
+#define LOCAL_GL_HILO_NV 0x86F4
+#define LOCAL_GL_DSDT_NV 0x86F5
+#define LOCAL_GL_DSDT_MAG_NV 0x86F6
+#define LOCAL_GL_DSDT_MAG_VIB_NV 0x86F7
+#define LOCAL_GL_HILO16_NV 0x86F8
+#define LOCAL_GL_SIGNED_HILO_NV 0x86F9
+#define LOCAL_GL_SIGNED_HILO16_NV 0x86FA
+#define LOCAL_GL_SIGNED_RGBA_NV 0x86FB
+#define LOCAL_GL_SIGNED_RGBA8_NV 0x86FC
+#define LOCAL_GL_SIGNED_RGB_NV 0x86FE
+#define LOCAL_GL_SIGNED_RGB8_NV 0x86FF
+#define LOCAL_GL_SIGNED_LUMINANCE_NV 0x8701
+#define LOCAL_GL_SIGNED_LUMINANCE8_NV 0x8702
+#define LOCAL_GL_SIGNED_LUMINANCE_ALPHA_NV 0x8703
+#define LOCAL_GL_SIGNED_LUMINANCE8_ALPHA8_NV 0x8704
+#define LOCAL_GL_SIGNED_ALPHA_NV 0x8705
+#define LOCAL_GL_SIGNED_ALPHA8_NV 0x8706
+#define LOCAL_GL_SIGNED_INTENSITY_NV 0x8707
+#define LOCAL_GL_SIGNED_INTENSITY8_NV 0x8708
+#define LOCAL_GL_DSDT8_NV 0x8709
+#define LOCAL_GL_DSDT8_MAG8_NV 0x870A
+#define LOCAL_GL_DSDT8_MAG8_INTENSITY8_NV 0x870B
+#define LOCAL_GL_SIGNED_RGB_UNSIGNED_ALPHA_NV 0x870C
+#define LOCAL_GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+#define LOCAL_GL_HI_SCALE_NV 0x870E
+#define LOCAL_GL_LO_SCALE_NV 0x870F
+#define LOCAL_GL_DS_SCALE_NV 0x8710
+#define LOCAL_GL_DT_SCALE_NV 0x8711
+#define LOCAL_GL_MAGNITUDE_SCALE_NV 0x8712
+#define LOCAL_GL_VIBRANCE_SCALE_NV 0x8713
+#define LOCAL_GL_HI_BIAS_NV 0x8714
+#define LOCAL_GL_LO_BIAS_NV 0x8715
+#define LOCAL_GL_DS_BIAS_NV 0x8716
+#define LOCAL_GL_DT_BIAS_NV 0x8717
+#define LOCAL_GL_MAGNITUDE_BIAS_NV 0x8718
+#define LOCAL_GL_VIBRANCE_BIAS_NV 0x8719
+#define LOCAL_GL_TEXTURE_BORDER_VALUES_NV 0x871A
+#define LOCAL_GL_TEXTURE_HI_SIZE_NV 0x871B
+#define LOCAL_GL_TEXTURE_LO_SIZE_NV 0x871C
+#define LOCAL_GL_TEXTURE_DS_SIZE_NV 0x871D
+#define LOCAL_GL_TEXTURE_DT_SIZE_NV 0x871E
+#define LOCAL_GL_TEXTURE_MAG_SIZE_NV 0x871F
+#define LOCAL_GL_NV_texture_shader2 1
+#define LOCAL_GL_UNSIGNED_INT_S8_S8_8_8_NV 0x86DA
+#define LOCAL_GL_UNSIGNED_INT_8_8_S8_S8_REV_NV 0x86DB
+#define LOCAL_GL_DSDT_MAG_INTENSITY_NV 0x86DC
+#define LOCAL_GL_DOT_PRODUCT_TEXTURE_3D_NV 0x86EF
+#define LOCAL_GL_HILO_NV 0x86F4
+#define LOCAL_GL_DSDT_NV 0x86F5
+#define LOCAL_GL_DSDT_MAG_NV 0x86F6
+#define LOCAL_GL_DSDT_MAG_VIB_NV 0x86F7
+#define LOCAL_GL_HILO16_NV 0x86F8
+#define LOCAL_GL_SIGNED_HILO_NV 0x86F9
+#define LOCAL_GL_SIGNED_HILO16_NV 0x86FA
+#define LOCAL_GL_SIGNED_RGBA_NV 0x86FB
+#define LOCAL_GL_SIGNED_RGBA8_NV 0x86FC
+#define LOCAL_GL_SIGNED_RGB_NV 0x86FE
+#define LOCAL_GL_SIGNED_RGB8_NV 0x86FF
+#define LOCAL_GL_SIGNED_LUMINANCE_NV 0x8701
+#define LOCAL_GL_SIGNED_LUMINANCE8_NV 0x8702
+#define LOCAL_GL_SIGNED_LUMINANCE_ALPHA_NV 0x8703
+#define LOCAL_GL_SIGNED_LUMINANCE8_ALPHA8_NV 0x8704
+#define LOCAL_GL_SIGNED_ALPHA_NV 0x8705
+#define LOCAL_GL_SIGNED_ALPHA8_NV 0x8706
+#define LOCAL_GL_SIGNED_INTENSITY_NV 0x8707
+#define LOCAL_GL_SIGNED_INTENSITY8_NV 0x8708
+#define LOCAL_GL_DSDT8_NV 0x8709
+#define LOCAL_GL_DSDT8_MAG8_NV 0x870A
+#define LOCAL_GL_DSDT8_MAG8_INTENSITY8_NV 0x870B
+#define LOCAL_GL_SIGNED_RGB_UNSIGNED_ALPHA_NV 0x870C
+#define LOCAL_GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+#define LOCAL_GL_NV_texture_shader3 1
+#define LOCAL_GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
+#define LOCAL_GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
+#define LOCAL_GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
+#define LOCAL_GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
+#define LOCAL_GL_OFFSET_HILO_TEXTURE_2D_NV 0x8854
+#define LOCAL_GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
+#define LOCAL_GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
+#define LOCAL_GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
+#define LOCAL_GL_DEPENDENT_HILO_TEXTURE_2D_NV 0x8858
+#define LOCAL_GL_DEPENDENT_RGB_TEXTURE_3D_NV 0x8859
+#define LOCAL_GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
+#define LOCAL_GL_DOT_PRODUCT_PASS_THROUGH_NV 0x885B
+#define LOCAL_GL_DOT_PRODUCT_TEXTURE_1D_NV 0x885C
+#define LOCAL_GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
+#define LOCAL_GL_HILO8_NV 0x885E
+#define LOCAL_GL_SIGNED_HILO8_NV 0x885F
+#define LOCAL_GL_FORCE_BLUE_TO_ONE_NV 0x8860
+#define LOCAL_GL_NV_vertex_array_range 1
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_NV 0x851D
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_LENGTH_NV 0x851E
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_VALID_NV 0x851F
+#define LOCAL_GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_POINTER_NV 0x8521
+#define LOCAL_GL_NV_vertex_array_range2 1
+#define LOCAL_GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV 0x8533
+#define LOCAL_GL_NV_vertex_program 1
+#define LOCAL_GL_VERTEX_PROGRAM_NV 0x8620
+#define LOCAL_GL_VERTEX_STATE_PROGRAM_NV 0x8621
+#define LOCAL_GL_ATTRIB_ARRAY_SIZE_NV 0x8623
+#define LOCAL_GL_ATTRIB_ARRAY_STRIDE_NV 0x8624
+#define LOCAL_GL_ATTRIB_ARRAY_TYPE_NV 0x8625
+#define LOCAL_GL_CURRENT_ATTRIB_NV 0x8626
+#define LOCAL_GL_PROGRAM_LENGTH_NV 0x8627
+#define LOCAL_GL_PROGRAM_STRING_NV 0x8628
+#define LOCAL_GL_MODELVIEW_PROJECTION_NV 0x8629
+#define LOCAL_GL_IDENTITY_NV 0x862A
+#define LOCAL_GL_INVERSE_NV 0x862B
+#define LOCAL_GL_TRANSPOSE_NV 0x862C
+#define LOCAL_GL_INVERSE_TRANSPOSE_NV 0x862D
+#define LOCAL_GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
+#define LOCAL_GL_MAX_TRACK_MATRICES_NV 0x862F
+#define LOCAL_GL_MATRIX0_NV 0x8630
+#define LOCAL_GL_MATRIX1_NV 0x8631
+#define LOCAL_GL_MATRIX2_NV 0x8632
+#define LOCAL_GL_MATRIX3_NV 0x8633
+#define LOCAL_GL_MATRIX4_NV 0x8634
+#define LOCAL_GL_MATRIX5_NV 0x8635
+#define LOCAL_GL_MATRIX6_NV 0x8636
+#define LOCAL_GL_MATRIX7_NV 0x8637
+#define LOCAL_GL_CURRENT_MATRIX_STACK_DEPTH_NV 0x8640
+#define LOCAL_GL_CURRENT_MATRIX_NV 0x8641
+#define LOCAL_GL_VERTEX_PROGRAM_POINT_SIZE_NV 0x8642
+#define LOCAL_GL_VERTEX_PROGRAM_TWO_SIDE_NV 0x8643
+#define LOCAL_GL_PROGRAM_PARAMETER_NV 0x8644
+#define LOCAL_GL_ATTRIB_ARRAY_POINTER_NV 0x8645
+#define LOCAL_GL_PROGRAM_TARGET_NV 0x8646
+#define LOCAL_GL_PROGRAM_RESIDENT_NV 0x8647
+#define LOCAL_GL_TRACK_MATRIX_NV 0x8648
+#define LOCAL_GL_TRACK_MATRIX_TRANSFORM_NV 0x8649
+#define LOCAL_GL_VERTEX_PROGRAM_BINDING_NV 0x864A
+#define LOCAL_GL_PROGRAM_ERROR_POSITION_NV 0x864B
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY0_NV 0x8650
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY1_NV 0x8651
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY2_NV 0x8652
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY3_NV 0x8653
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY4_NV 0x8654
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY5_NV 0x8655
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY6_NV 0x8656
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY7_NV 0x8657
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY8_NV 0x8658
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY9_NV 0x8659
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY10_NV 0x865A
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY11_NV 0x865B
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY12_NV 0x865C
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY13_NV 0x865D
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY14_NV 0x865E
+#define LOCAL_GL_VERTEX_ATTRIB_ARRAY15_NV 0x865F
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB0_4_NV 0x8660
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB1_4_NV 0x8661
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB2_4_NV 0x8662
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB3_4_NV 0x8663
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB4_4_NV 0x8664
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB5_4_NV 0x8665
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB6_4_NV 0x8666
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB7_4_NV 0x8667
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB8_4_NV 0x8668
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB9_4_NV 0x8669
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB10_4_NV 0x866A
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB11_4_NV 0x866B
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB12_4_NV 0x866C
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB13_4_NV 0x866D
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB14_4_NV 0x866E
+#define LOCAL_GL_MAP1_VERTEX_ATTRIB15_4_NV 0x866F
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB0_4_NV 0x8670
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB1_4_NV 0x8671
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB2_4_NV 0x8672
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB3_4_NV 0x8673
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB4_4_NV 0x8674
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB5_4_NV 0x8675
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB6_4_NV 0x8676
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB7_4_NV 0x8677
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB8_4_NV 0x8678
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB9_4_NV 0x8679
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB10_4_NV 0x867A
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB11_4_NV 0x867B
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB12_4_NV 0x867C
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB13_4_NV 0x867D
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB14_4_NV 0x867E
+#define LOCAL_GL_MAP2_VERTEX_ATTRIB15_4_NV 0x867F
+#define LOCAL_GL_NV_vertex_program1_1 1
+#define LOCAL_GL_NV_vertex_program2 1
+#define LOCAL_GL_NV_vertex_program2_option 1
+#define LOCAL_GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV 0x88F4
+#define LOCAL_GL_MAX_PROGRAM_CALL_DEPTH_NV 0x88F5
+#define LOCAL_GL_NV_vertex_program3 1
+#define LOCAL_GL_OML_interlace 1
+#define LOCAL_GL_INTERLACE_OML 0x8980
+#define LOCAL_GL_INTERLACE_READ_OML 0x8981
+#define LOCAL_GL_OML_resample 1
+#define LOCAL_GL_PACK_RESAMPLE_OML 0x8984
+#define LOCAL_GL_UNPACK_RESAMPLE_OML 0x8985
+#define LOCAL_GL_RESAMPLE_REPLICATE_OML 0x8986
+#define LOCAL_GL_RESAMPLE_ZERO_FILL_OML 0x8987
+#define LOCAL_GL_RESAMPLE_AVERAGE_OML 0x8988
+#define LOCAL_GL_RESAMPLE_DECIMATE_OML 0x8989
+#define LOCAL_GL_OML_subsample 1
+#define LOCAL_GL_FORMAT_SUBSAMPLE_24_24_OML 0x8982
+#define LOCAL_GL_FORMAT_SUBSAMPLE_244_244_OML 0x8983
+#define LOCAL_GL_PGI_misc_hints 1
+#define LOCAL_GL_PREFER_DOUBLEBUFFER_HINT_PGI 107000
+#define LOCAL_GL_CONSERVE_MEMORY_HINT_PGI 107005
+#define LOCAL_GL_RECLAIM_MEMORY_HINT_PGI 107006
+#define LOCAL_GL_NATIVE_GRAPHICS_HANDLE_PGI 107010
+#define LOCAL_GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI 107011
+#define LOCAL_GL_NATIVE_GRAPHICS_END_HINT_PGI 107012
+#define LOCAL_GL_ALWAYS_FAST_HINT_PGI 107020
+#define LOCAL_GL_ALWAYS_SOFT_HINT_PGI 107021
+#define LOCAL_GL_ALLOW_DRAW_OBJ_HINT_PGI 107022
+#define LOCAL_GL_ALLOW_DRAW_WIN_HINT_PGI 107023
+#define LOCAL_GL_ALLOW_DRAW_FRG_HINT_PGI 107024
+#define LOCAL_GL_ALLOW_DRAW_MEM_HINT_PGI 107025
+#define LOCAL_GL_STRICT_DEPTHFUNC_HINT_PGI 107030
+#define LOCAL_GL_STRICT_LIGHTING_HINT_PGI 107031
+#define LOCAL_GL_STRICT_SCISSOR_HINT_PGI 107032
+#define LOCAL_GL_FULL_STIPPLE_HINT_PGI 107033
+#define LOCAL_GL_CLIP_NEAR_HINT_PGI 107040
+#define LOCAL_GL_CLIP_FAR_HINT_PGI 107041
+#define LOCAL_GL_WIDE_LINE_HINT_PGI 107042
+#define LOCAL_GL_BACK_NORMALS_HINT_PGI 107043
+#define LOCAL_GL_PGI_vertex_hints 1
+#define LOCAL_GL_VERTEX23_BIT_PGI 0x00000004
+#define LOCAL_GL_VERTEX4_BIT_PGI 0x00000008
+#define LOCAL_GL_COLOR3_BIT_PGI 0x00010000
+#define LOCAL_GL_COLOR4_BIT_PGI 0x00020000
+#define LOCAL_GL_EDGEFLAG_BIT_PGI 0x00040000
+#define LOCAL_GL_INDEX_BIT_PGI 0x00080000
+#define LOCAL_GL_MAT_AMBIENT_BIT_PGI 0x00100000
+#define LOCAL_GL_VERTEX_DATA_HINT_PGI 107050
+#define LOCAL_GL_VERTEX_CONSISTENT_HINT_PGI 107051
+#define LOCAL_GL_MATERIAL_SIDE_HINT_PGI 107052
+#define LOCAL_GL_MAX_VERTEX_HINT_PGI 107053
+#define LOCAL_GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI 0x00200000
+#define LOCAL_GL_MAT_DIFFUSE_BIT_PGI 0x00400000
+#define LOCAL_GL_MAT_EMISSION_BIT_PGI 0x00800000
+#define LOCAL_GL_MAT_COLOR_INDEXES_BIT_PGI 0x01000000
+#define LOCAL_GL_MAT_SHININESS_BIT_PGI 0x02000000
+#define LOCAL_GL_MAT_SPECULAR_BIT_PGI 0x04000000
+#define LOCAL_GL_NORMAL_BIT_PGI 0x08000000
+#define LOCAL_GL_TEXCOORD1_BIT_PGI 0x10000000
+#define LOCAL_GL_TEXCOORD2_BIT_PGI 0x20000000
+#define LOCAL_GL_TEXCOORD3_BIT_PGI 0x40000000
+#define LOCAL_GL_TEXCOORD4_BIT_PGI 0x80000000
+#define LOCAL_GL_REND_screen_coordinates 1
+#define LOCAL_GL_SCREEN_COORDINATES_REND 0x8490
+#define LOCAL_GL_INVERTED_SCREEN_W_REND 0x8491
+#define LOCAL_GL_S3_s3tc 1
+#define LOCAL_GL_RGB_S3TC 0x83A0
+#define LOCAL_GL_RGB4_S3TC 0x83A1
+#define LOCAL_GL_RGBA_S3TC 0x83A2
+#define LOCAL_GL_RGBA4_S3TC 0x83A3
+#define LOCAL_GL_RGBA_DXT5_S3TC 0x83A4
+#define LOCAL_GL_RGBA4_DXT5_S3TC 0x83A5
+#define LOCAL_GL_SGIS_color_range 1
+#define LOCAL_GL_EXTENDED_RANGE_SGIS 0x85A5
+#define LOCAL_GL_MIN_RED_SGIS 0x85A6
+#define LOCAL_GL_MAX_RED_SGIS 0x85A7
+#define LOCAL_GL_MIN_GREEN_SGIS 0x85A8
+#define LOCAL_GL_MAX_GREEN_SGIS 0x85A9
+#define LOCAL_GL_MIN_BLUE_SGIS 0x85AA
+#define LOCAL_GL_MAX_BLUE_SGIS 0x85AB
+#define LOCAL_GL_MIN_ALPHA_SGIS 0x85AC
+#define LOCAL_GL_MAX_ALPHA_SGIS 0x85AD
+#define LOCAL_GL_SGIS_detail_texture 1
+#define LOCAL_GL_SGIS_fog_function 1
+#define LOCAL_GL_SGIS_generate_mipmap 1
+#define LOCAL_GL_GENERATE_MIPMAP_SGIS 0x8191
+#define LOCAL_GL_GENERATE_MIPMAP_HINT_SGIS 0x8192
+#define LOCAL_GL_SGIS_multisample 1
+#define LOCAL_GL_MULTISAMPLE_SGIS 0x809D
+#define LOCAL_GL_SAMPLE_ALPHA_TO_MASK_SGIS 0x809E
+#define LOCAL_GL_SAMPLE_ALPHA_TO_ONE_SGIS 0x809F
+#define LOCAL_GL_SAMPLE_MASK_SGIS 0x80A0
+#define LOCAL_GL_1PASS_SGIS 0x80A1
+#define LOCAL_GL_2PASS_0_SGIS 0x80A2
+#define LOCAL_GL_2PASS_1_SGIS 0x80A3
+#define LOCAL_GL_4PASS_0_SGIS 0x80A4
+#define LOCAL_GL_4PASS_1_SGIS 0x80A5
+#define LOCAL_GL_4PASS_2_SGIS 0x80A6
+#define LOCAL_GL_4PASS_3_SGIS 0x80A7
+#define LOCAL_GL_SAMPLE_BUFFERS_SGIS 0x80A8
+#define LOCAL_GL_SAMPLES_SGIS 0x80A9
+#define LOCAL_GL_SAMPLE_MASK_VALUE_SGIS 0x80AA
+#define LOCAL_GL_SAMPLE_MASK_INVERT_SGIS 0x80AB
+#define LOCAL_GL_SAMPLE_PATTERN_SGIS 0x80AC
+#define LOCAL_GL_MULTISAMPLE_BIT_EXT 0x20000000
+#define LOCAL_GL_SGIS_pixel_texture 1
+#define LOCAL_GL_SGIS_sharpen_texture 1
+#define LOCAL_GL_SGIS_texture4D 1
+#define LOCAL_GL_SGIS_texture_border_clamp 1
+#define LOCAL_GL_CLAMP_TO_BORDER_SGIS 0x812D
+#define LOCAL_GL_SGIS_texture_edge_clamp 1
+#define LOCAL_GL_CLAMP_TO_EDGE_SGIS 0x812F
+#define LOCAL_GL_SGIS_texture_filter4 1
+#define LOCAL_GL_SGIS_texture_lod 1
+#define LOCAL_GL_TEXTURE_MIN_LOD_SGIS 0x813A
+#define LOCAL_GL_TEXTURE_MAX_LOD_SGIS 0x813B
+#define LOCAL_GL_TEXTURE_BASE_LEVEL_SGIS 0x813C
+#define LOCAL_GL_TEXTURE_MAX_LEVEL_SGIS 0x813D
+#define LOCAL_GL_SGIS_texture_select 1
+#define LOCAL_GL_SGIX_async 1
+#define LOCAL_GL_ASYNC_MARKER_SGIX 0x8329
+#define LOCAL_GL_SGIX_async_histogram 1
+#define LOCAL_GL_ASYNC_HISTOGRAM_SGIX 0x832C
+#define LOCAL_GL_MAX_ASYNC_HISTOGRAM_SGIX 0x832D
+#define LOCAL_GL_SGIX_async_pixel 1
+#define LOCAL_GL_ASYNC_TEX_IMAGE_SGIX 0x835C
+#define LOCAL_GL_ASYNC_DRAW_PIXELS_SGIX 0x835D
+#define LOCAL_GL_ASYNC_READ_PIXELS_SGIX 0x835E
+#define LOCAL_GL_MAX_ASYNC_TEX_IMAGE_SGIX 0x835F
+#define LOCAL_GL_MAX_ASYNC_DRAW_PIXELS_SGIX 0x8360
+#define LOCAL_GL_MAX_ASYNC_READ_PIXELS_SGIX 0x8361
+#define LOCAL_GL_SGIX_blend_alpha_minmax 1
+#define LOCAL_GL_ALPHA_MIN_SGIX 0x8320
+#define LOCAL_GL_ALPHA_MAX_SGIX 0x8321
+#define LOCAL_GL_SGIX_clipmap 1
+#define LOCAL_GL_SGIX_depth_texture 1
+#define LOCAL_GL_DEPTH_COMPONENT16_SGIX 0x81A5
+#define LOCAL_GL_DEPTH_COMPONENT24_SGIX 0x81A6
+#define LOCAL_GL_DEPTH_COMPONENT32_SGIX 0x81A7
+#define LOCAL_GL_SGIX_flush_raster 1
+#define LOCAL_GL_SGIX_fog_offset 1
+#define LOCAL_GL_FOG_OFFSET_SGIX 0x8198
+#define LOCAL_GL_FOG_OFFSET_VALUE_SGIX 0x8199
+#define LOCAL_GL_SGIX_fog_texture 1
+#define LOCAL_GL_TEXTURE_FOG_SGIX 0
+#define LOCAL_GL_FOG_PATCHY_FACTOR_SGIX 0
+#define LOCAL_GL_FRAGMENT_FOG_SGIX 0
+#define LOCAL_GL_SGIX_fragment_specular_lighting 1
+#define LOCAL_GL_SGIX_framezoom 1
+#define LOCAL_GL_SGIX_interlace 1
+#define LOCAL_GL_INTERLACE_SGIX 0x8094
+#define LOCAL_GL_SGIX_ir_instrument1 1
+#define LOCAL_GL_SGIX_list_priority 1
+#define LOCAL_GL_SGIX_pixel_texture 1
+#define LOCAL_GL_SGIX_pixel_texture_bits 1
+#define LOCAL_GL_SGIX_reference_plane 1
+#define LOCAL_GL_SGIX_resample 1
+#define LOCAL_GL_PACK_RESAMPLE_SGIX 0x842E
+#define LOCAL_GL_UNPACK_RESAMPLE_SGIX 0x842F
+#define LOCAL_GL_RESAMPLE_DECIMATE_SGIX 0x8430
+#define LOCAL_GL_RESAMPLE_REPLICATE_SGIX 0x8433
+#define LOCAL_GL_RESAMPLE_ZERO_FILL_SGIX 0x8434
+#define LOCAL_GL_SGIX_shadow 1
+#define LOCAL_GL_TEXTURE_COMPARE_SGIX 0x819A
+#define LOCAL_GL_TEXTURE_COMPARE_OPERATOR_SGIX 0x819B
+#define LOCAL_GL_TEXTURE_LEQUAL_R_SGIX 0x819C
+#define LOCAL_GL_TEXTURE_GEQUAL_R_SGIX 0x819D
+#define LOCAL_GL_SGIX_shadow_ambient 1
+#define LOCAL_GL_SHADOW_AMBIENT_SGIX 0x80BF
+#define LOCAL_GL_SGIX_sprite 1
+#define LOCAL_GL_SGIX_tag_sample_buffer 1
+#define LOCAL_GL_SGIX_texture_add_env 1
+#define LOCAL_GL_SGIX_texture_coordinate_clamp 1
+#define LOCAL_GL_TEXTURE_MAX_CLAMP_S_SGIX 0x8369
+#define LOCAL_GL_TEXTURE_MAX_CLAMP_T_SGIX 0x836A
+#define LOCAL_GL_TEXTURE_MAX_CLAMP_R_SGIX 0x836B
+#define LOCAL_GL_SGIX_texture_lod_bias 1
+#define LOCAL_GL_SGIX_texture_multi_buffer 1
+#define LOCAL_GL_TEXTURE_MULTI_BUFFER_HINT_SGIX 0x812E
+#define LOCAL_GL_SGIX_texture_range 1
+#define LOCAL_GL_RGB_SIGNED_SGIX 0x85E0
+#define LOCAL_GL_RGBA_SIGNED_SGIX 0x85E1
+#define LOCAL_GL_ALPHA_SIGNED_SGIX 0x85E2
+#define LOCAL_GL_LUMINANCE_SIGNED_SGIX 0x85E3
+#define LOCAL_GL_INTENSITY_SIGNED_SGIX 0x85E4
+#define LOCAL_GL_LUMINANCE_ALPHA_SIGNED_SGIX 0x85E5
+#define LOCAL_GL_RGB16_SIGNED_SGIX 0x85E6
+#define LOCAL_GL_RGBA16_SIGNED_SGIX 0x85E7
+#define LOCAL_GL_ALPHA16_SIGNED_SGIX 0x85E8
+#define LOCAL_GL_LUMINANCE16_SIGNED_SGIX 0x85E9
+#define LOCAL_GL_INTENSITY16_SIGNED_SGIX 0x85EA
+#define LOCAL_GL_LUMINANCE16_ALPHA16_SIGNED_SGIX 0x85EB
+#define LOCAL_GL_RGB_EXTENDED_RANGE_SGIX 0x85EC
+#define LOCAL_GL_RGBA_EXTENDED_RANGE_SGIX 0x85ED
+#define LOCAL_GL_ALPHA_EXTENDED_RANGE_SGIX 0x85EE
+#define LOCAL_GL_LUMINANCE_EXTENDED_RANGE_SGIX 0x85EF
+#define LOCAL_GL_INTENSITY_EXTENDED_RANGE_SGIX 0x85F0
+#define LOCAL_GL_LUMINANCE_ALPHA_EXTENDED_RANGE_SGIX 0x85F1
+#define LOCAL_GL_RGB16_EXTENDED_RANGE_SGIX 0x85F2
+#define LOCAL_GL_RGBA16_EXTENDED_RANGE_SGIX 0x85F3
+#define LOCAL_GL_ALPHA16_EXTENDED_RANGE_SGIX 0x85F4
+#define LOCAL_GL_LUMINANCE16_EXTENDED_RANGE_SGIX 0x85F5
+#define LOCAL_GL_INTENSITY16_EXTENDED_RANGE_SGIX 0x85F6
+#define LOCAL_GL_LUMINANCE16_ALPHA16_EXTENDED_RANGE_SGIX 0x85F7
+#define LOCAL_GL_MIN_LUMINANCE_SGIS 0x85F8
+#define LOCAL_GL_MAX_LUMINANCE_SGIS 0x85F9
+#define LOCAL_GL_MIN_INTENSITY_SGIS 0x85FA
+#define LOCAL_GL_MAX_INTENSITY_SGIS 0x85FB
+#define LOCAL_GL_SGIX_texture_scale_bias 1
+#define LOCAL_GL_POST_TEXTURE_FILTER_BIAS_SGIX 0x8179
+#define LOCAL_GL_POST_TEXTURE_FILTER_SCALE_SGIX 0x817A
+#define LOCAL_GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX 0x817B
+#define LOCAL_GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX 0x817C
+#define LOCAL_GL_SGIX_vertex_preclip 1
+#define LOCAL_GL_VERTEX_PRECLIP_SGIX 0x83EE
+#define LOCAL_GL_VERTEX_PRECLIP_HINT_SGIX 0x83EF
+#define LOCAL_GL_SGIX_vertex_preclip_hint 1
+#define LOCAL_GL_VERTEX_PRECLIP_SGIX 0x83EE
+#define LOCAL_GL_VERTEX_PRECLIP_HINT_SGIX 0x83EF
+#define LOCAL_GL_SGIX_ycrcb 1
+#define LOCAL_GL_SGI_color_matrix 1
+#define LOCAL_GL_COLOR_MATRIX_SGI 0x80B1
+#define LOCAL_GL_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B2
+#define LOCAL_GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B3
+#define LOCAL_GL_POST_COLOR_MATRIX_RED_SCALE_SGI 0x80B4
+#define LOCAL_GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0x80B5
+#define LOCAL_GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0x80B6
+#define LOCAL_GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0x80B7
+#define LOCAL_GL_POST_COLOR_MATRIX_RED_BIAS_SGI 0x80B8
+#define LOCAL_GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0x80B9
+#define LOCAL_GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI 0x80BA
+#define LOCAL_GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0x80BB
+#define LOCAL_GL_SGI_color_table 1
+#define LOCAL_GL_COLOR_TABLE_SGI 0x80D0
+#define LOCAL_GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D1
+#define LOCAL_GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D2
+#define LOCAL_GL_PROXY_COLOR_TABLE_SGI 0x80D3
+#define LOCAL_GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D4
+#define LOCAL_GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D5
+#define LOCAL_GL_COLOR_TABLE_SCALE_SGI 0x80D6
+#define LOCAL_GL_COLOR_TABLE_BIAS_SGI 0x80D7
+#define LOCAL_GL_COLOR_TABLE_FORMAT_SGI 0x80D8
+#define LOCAL_GL_COLOR_TABLE_WIDTH_SGI 0x80D9
+#define LOCAL_GL_COLOR_TABLE_RED_SIZE_SGI 0x80DA
+#define LOCAL_GL_COLOR_TABLE_GREEN_SIZE_SGI 0x80DB
+#define LOCAL_GL_COLOR_TABLE_BLUE_SIZE_SGI 0x80DC
+#define LOCAL_GL_COLOR_TABLE_ALPHA_SIZE_SGI 0x80DD
+#define LOCAL_GL_COLOR_TABLE_LUMINANCE_SIZE_SGI 0x80DE
+#define LOCAL_GL_COLOR_TABLE_INTENSITY_SIZE_SGI 0x80DF
+#define LOCAL_GL_SGI_texture_color_table 1
+#define LOCAL_GL_TEXTURE_COLOR_TABLE_SGI 0x80BC
+#define LOCAL_GL_PROXY_TEXTURE_COLOR_TABLE_SGI 0x80BD
+#define LOCAL_GL_SUNX_constant_data 1
+#define LOCAL_GL_UNPACK_CONSTANT_DATA_SUNX 0x81D5
+#define LOCAL_GL_TEXTURE_CONSTANT_DATA_SUNX 0x81D6
+#define LOCAL_GL_SUN_convolution_border_modes 1
+#define LOCAL_GL_WRAP_BORDER_SUN 0x81D4
+#define LOCAL_GL_SUN_global_alpha 1
+#define LOCAL_GL_GLOBAL_ALPHA_SUN 0x81D9
+#define LOCAL_GL_GLOBAL_ALPHA_FACTOR_SUN 0x81DA
+#define LOCAL_GL_SUN_mesh_array 1
+#define LOCAL_GL_QUAD_MESH_SUN 0x8614
+#define LOCAL_GL_TRIANGLE_MESH_SUN 0x8615
+#define LOCAL_GL_SUN_read_video_pixels 1
+#define LOCAL_GL_SUN_slice_accum 1
+#define LOCAL_GL_SLICE_ACCUM_SUN 0x85CC
+#define LOCAL_GL_SUN_triangle_list 1
+#define LOCAL_GL_RESTART_SUN 0x01
+#define LOCAL_GL_REPLACE_MIDDLE_SUN 0x02
+#define LOCAL_GL_REPLACE_OLDEST_SUN 0x03
+#define LOCAL_GL_TRIANGLE_LIST_SUN 0x81D7
+#define LOCAL_GL_REPLACEMENT_CODE_SUN 0x81D8
+#define LOCAL_GL_REPLACEMENT_CODE_ARRAY_SUN 0x85C0
+#define LOCAL_GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN 0x85C1
+#define LOCAL_GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN 0x85C2
+#define LOCAL_GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN 0x85C3
+#define LOCAL_GL_R1UI_V3F_SUN 0x85C4
+#define LOCAL_GL_R1UI_C4UB_V3F_SUN 0x85C5
+#define LOCAL_GL_R1UI_C3F_V3F_SUN 0x85C6
+#define LOCAL_GL_R1UI_N3F_V3F_SUN 0x85C7
+#define LOCAL_GL_R1UI_C4F_N3F_V3F_SUN 0x85C8
+#define LOCAL_GL_R1UI_T2F_V3F_SUN 0x85C9
+#define LOCAL_GL_R1UI_T2F_N3F_V3F_SUN 0x85CA
+#define LOCAL_GL_R1UI_T2F_C4F_N3F_V3F_SUN 0x85CB
+#define LOCAL_GL_SUN_vertex 1
+#define LOCAL_GL_WIN_phong_shading 1
+#define LOCAL_GL_PHONG_WIN 0x80EA
+#define LOCAL_GL_PHONG_HINT_WIN 0x80EB
+#define LOCAL_GL_WIN_specular_fog 1
+#define LOCAL_GL_FOG_SPECULAR_TEXTURE_WIN 0x80EC
+#define LOCAL_GL_WIN_swap_hint 1
+
+#define LOCAL_GL_IMPLEMENTATION_COLOR_READ_TYPE   0x8B9A
+#define LOCAL_GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
 
 #define WGL_NUMBER_PIXEL_FORMATS_ARB 0x2000
 #define WGL_DRAW_TO_WINDOW_ARB 0x2001
@@ -3048,4 +3090,73 @@ typedef ptrdiff_t GLintptr;
 #define WGL_SAMPLE_BUFFERS_ARB 0x2041
 #define WGL_SAMPLES_ARB 0x2042
 
+
+#define EGL_BUFFER_SIZE                 0x3020
+#define EGL_ALPHA_SIZE                  0x3021
+#define EGL_BLUE_SIZE                   0x3022
+#define EGL_GREEN_SIZE                  0x3023
+#define EGL_RED_SIZE                    0x3024
+#define EGL_DEPTH_SIZE                  0x3025
+#define EGL_STENCIL_SIZE                0x3026
+#define EGL_CONFIG_CAVEAT               0x3027
+#define EGL_CONFIG_ID                   0x3028
+#define EGL_LEVEL                       0x3029
+#define EGL_MAX_PBUFFER_HEIGHT          0x302A
+#define EGL_MAX_PBUFFER_PIXELS          0x302B
+#define EGL_MAX_PBUFFER_WIDTH           0x302C
+#define EGL_NATIVE_RENDERABLE           0x302D
+#define EGL_NATIVE_VISUAL_ID            0x302E
+#define EGL_NATIVE_VISUAL_TYPE          0x302F
+#define EGL_PRESERVED_RESOURCES         0x3030
+#define EGL_SAMPLES                     0x3031
+#define EGL_SAMPLE_BUFFERS              0x3032
+#define EGL_SURFACE_TYPE                0x3033
+#define EGL_TRANSPARENT_TYPE            0x3034
+#define EGL_TRANSPARENT_BLUE_VALUE      0x3035
+#define EGL_TRANSPARENT_GREEN_VALUE     0x3036
+#define EGL_TRANSPARENT_RED_VALUE       0x3037
+#define EGL_NONE                        0x3038
+#define EGL_BIND_TO_TEXTURE_RGB         0x3039
+#define EGL_BIND_TO_TEXTURE_RGBA        0x303A
+#define EGL_MIN_SWAP_INTERVAL           0x303B
+#define EGL_MAX_SWAP_INTERVAL           0x303C
+#define EGL_LUMINANCE_SIZE              0x303D
+#define EGL_ALPHA_MASK_SIZE             0x303E
+#define EGL_COLOR_BUFFER_TYPE           0x303F
+#define EGL_RENDERABLE_TYPE             0x3040
+#define EGL_MATCH_NATIVE_PIXMAP         0x3041
+#define EGL_CONFORMANT                  0x3042
+#define EGL_OPENGL_ES_BIT               0x0001
+#define EGL_OPENVG_BIT                  0x0002
+#define EGL_OPENGL_ES2_BIT              0x0004
+#define EGL_OPENGL_ES_API               0x30A0
+#define EGL_PBUFFER_BIT                 0x0001
+#define EGL_PIXMAP_BIT                  0x0002
+#define EGL_WINDOW_BIT                  0x0004
+#define EGL_MULTISAMPLE_RESOLVE_BOX_BIT 0x0200
+#define EGL_SWAP_BEHAVIOR_PRESERVED_BIT 0x0400
+#define EGL_VENDOR                      0x3053
+#define EGL_VERSION                     0x3054
+#define EGL_EXTENSIONS                  0x3055
+#define EGL_CLIENT_APIS                 0x308D
+#define EGL_HEIGHT                      0x3056
+#define EGL_WIDTH                       0x3057
+#define EGL_LARGEST_PBUFFER             0x3058
+#define EGL_TEXTURE_FORMAT              0x3080
+#define EGL_TEXTURE_TARGET              0x3081
+#define EGL_MIPMAP_TEXTURE              0x3082
+#define EGL_MIPMAP_LEVEL                0x3083
+#define EGL_RENDER_BUFFER               0x3086
+#define EGL_VG_COLORSPACE               0x3087
+#define EGL_VG_ALPHA_FORMAT             0x3088
+#define EGL_HORIZONTAL_RESOLUTION       0x3090
+#define EGL_VERTICAL_RESOLUTION         0x3091
+#define EGL_PIXEL_ASPECT_RATIO          0x3092
+#define EGL_SWAP_BEHAVIOR               0x3093
+#define EGL_MULTISAMPLE_RESOLVE         0x3099
+#define EGL_CONTEXT_CLIENT_TYPE         0x3097
+#define EGL_CONTEXT_CLIENT_VERSION      0x3098
+#define EGL_FALSE                       0
+#define EGL_TRUE                        1
+
 #endif
diff -r 5b1fe1bf3872 content/canvas/src/nsCanvasRenderingContextGL.cpp
--- a/content/canvas/src/nsCanvasRenderingContextGL.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1069 +0,0 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- *   Mozilla Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "prmem.h"
-#include "prlog.h"
-
-#include "nsCanvasRenderingContextGL.h"
-
-#include "nsICanvasRenderingContextGL.h"
-
-#include "nsIRenderingContext.h"
-
-#include "nsICanvasRenderingContextInternal.h"
-#include "nsIDOMHTMLCanvasElement.h"
-#include "nsIView.h"
-#include "nsIViewManager.h"
-
-#include "nsIDocument.h"
-
-#include "nsTransform2D.h"
-
-#include "nsIScriptSecurityManager.h"
-#include "nsISecurityCheckedComponent.h"
-
-#include "imgIRequest.h"
-#include "imgIContainer.h"
-#include "nsIDOMHTMLCanvasElement.h"
-#include "nsICanvasElement.h"
-#include "nsIDOMHTMLImageElement.h"
-#include "nsIImageLoadingContent.h"
-#include "nsIInterfaceRequestorUtils.h"
-#include "nsDOMError.h"
-#include "nsIJSRuntimeService.h"
-
-#include "imgIEncoder.h"
-
-#include "nsIPrefService.h"
-
-#include "nsIClassInfoImpl.h"
-
-#include "nsComponentManagerUtils.h"
-#include "nsServiceManagerUtils.h"
-
-#include "nsDOMError.h"
-
-#include "nsIXPConnect.h"
-#include "jsapi.h"
-#include "jsarray.h"
-
-#include "nsIDOMDocument.h"
-#include "nsIDOMDocumentEvent.h"
-#include "nsIDOMEvent.h"
-#include "nsIDOMEventTarget.h"
-#include "nsIPrivateDOMEvent.h"
-#include "nsIDOMDataContainerEvent.h"
-
-#include "nsLayoutUtils.h"
-
-#ifdef ARGH_NEED_SEPARATE_SERVICE
-#include "nsIContentURIGrouper.h"
-#include "nsIContentPrefService.h"
-#endif
-
-// we're hoping that something is setting us up the remap
-
-#include "gfxContext.h"
-#include "gfxASurface.h"
-
-#ifdef XP_WIN
-#include "gfxWindowsSurface.h"
-#endif
-
-#ifdef XP_MACOSX
-#include "gfxQuartzImageSurface.h"
-#endif
-
-#ifdef MOZ_X11
-#include <gdk/gdk.h>
-#include <gdk/gdkx.h>
-#include "cairo-xlib.h"
-#endif
-
-// can't do this due to linkage
-#undef MOZ_MEDIA
-
-#ifndef GL_FRAMEBUFFER
-#define GL_FRAMEBUFFER 0x8D40
-#endif
-
-nsIXPConnect *gXPConnect = nsnull;
-JSRuntime *gScriptRuntime = nsnull;
-nsIJSRuntimeService *gJSRuntimeService = nsnull;
-
-// CanvasGLBuffer
-NS_DECL_CLASSINFO(CanvasGLBuffer)
-NS_IMPL_ADDREF(CanvasGLBuffer)
-NS_IMPL_RELEASE(CanvasGLBuffer)
-
-NS_IMPL_CI_INTERFACE_GETTER1(CanvasGLBuffer, nsICanvasRenderingContextGLBuffer)
-
-NS_INTERFACE_MAP_BEGIN(CanvasGLBuffer)
-  NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextGLBuffer)
-  NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
-  NS_INTERFACE_MAP_ENTRY(nsICanvasGLBuffer)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICanvasRenderingContextGLBuffer)
-  NS_IMPL_QUERY_CLASSINFO(CanvasGLBuffer)
-NS_INTERFACE_MAP_END
-
-// CanvasGLTexture
-NS_DECL_CLASSINFO(CanvasGLTexture)
-NS_IMPL_ADDREF(CanvasGLTexture)
-NS_IMPL_RELEASE(CanvasGLTexture)
-
-NS_IMPL_CI_INTERFACE_GETTER1(CanvasGLTexture, nsICanvasRenderingContextGLTexture)
-
-NS_INTERFACE_MAP_BEGIN(CanvasGLTexture)
-  NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextGLTexture)
-  NS_INTERFACE_MAP_ENTRY(nsICanvasGLTexture)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICanvasRenderingContextGLTexture)
-  NS_IMPL_QUERY_CLASSINFO(CanvasGLTexture)
-NS_INTERFACE_MAP_END
-
-/**
- ** CanvasGLBuffer
- **/
-
-static int bufferCount = 0;
-
-CanvasGLBuffer::CanvasGLBuffer(nsCanvasRenderingContextGLPrivate *owner)
-    : mDisposed(PR_TRUE),
-      mLength(0), mSize(0), mType(0), mUsage(GL_STATIC_DRAW),
-      mBufferID(0), mMaxUShort(0), mMaxUShortComputed(false)
-{
-    owner->GetWeakReference(getter_AddRefs(mOwnerContext));
-
-    gl = owner->gl;
-
-    bufferCount++;
-    //fprintf (stderr, "VVVV Created; Buffers now: %d\n", bufferCount); fflush(stderr);
-}
-
-CanvasGLBuffer::~CanvasGLBuffer()
-{
-    Dispose();
-
-    --bufferCount;
-    //fprintf (stderr, "VVVV Released; Buffers now: %d\n", bufferCount); fflush(stderr);
-}
-
-/* nsISecurityCheckedComponent bits */
-
-static char* cloneAllAccess()
-{
-    static const char allAccess[] = "allAccess";
-    return (char*)nsMemory::Clone(allAccess, sizeof(allAccess));
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::CanCreateWrapper(const nsIID* iid, char **_retval) {
-    *_retval = cloneAllAccess();
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::CanCallMethod(const nsIID *iid, const PRUnichar *methodName, char **_retval) {
-    *_retval = cloneAllAccess();
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::CanGetProperty(const nsIID *iid, const PRUnichar *propertyName, char **_retval) {
-    *_retval = cloneAllAccess();
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::CanSetProperty(const nsIID *iid, const PRUnichar *propertyName, char **_retval) {
-    *_retval = cloneAllAccess();
-    return NS_OK;
-}
-
-nsresult
-CanvasGLBuffer::Init(PRUint32 usage,
-                     PRUint32 size,
-                     PRUint32 type,
-                     JSContext *ctx,
-                     JSObject *arrayObj,
-                     jsuint arrayLen)
-{
-    nsresult rv;
-
-    //fprintf (stderr, "VVVV CanvasGLBuffer::Init\n");
-
-    if (!mDisposed)
-        Dispose();
-
-    if (usage != GL_STATIC_DRAW &&
-        usage != GL_STREAM_DRAW &&
-        usage != GL_DYNAMIC_DRAW)
-        return NS_ERROR_INVALID_ARG;
-
-    rv = mSimpleBuffer.InitFromJSArray(type, size, ctx, arrayObj, arrayLen);
-    if (NS_FAILED(rv))
-        return rv;
-
-    mUsage = usage;
-    mSize = size;
-    mType = type;
-    mLength = arrayLen;
-
-    mMaxUShortComputed = false;
-    
-    mBufferID = 0;
-
-    mDisposed = PR_FALSE;
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::Dispose()
-{
-    if (mDisposed)
-        return NS_OK;
-
-    if (mBufferID) {
-        nsCOMPtr<nsICanvasRenderingContextInternal> ctx = do_QueryReferent(mOwnerContext);
-        if (ctx) {
-            nsCanvasRenderingContextGLPrivate *priv = (nsCanvasRenderingContextGLPrivate*) ctx.get();
-            priv->MakeContextCurrent();
-
-            gl->fDeleteBuffers(1, &mBufferID);
-            mBufferID = 0;
-        }
-    }
-
-    mSimpleBuffer.Release();
-
-    mDisposed = PR_TRUE;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::GetOwnerContext(nsICanvasRenderingContextGL **retval)
-{
-    nsCOMPtr<nsICanvasRenderingContextInternal> ctx = do_QueryReferent(mOwnerContext);
-    if (ctx) {
-        nsCanvasRenderingContextGLPrivate *priv = (nsCanvasRenderingContextGLPrivate*) ctx.get();
-        *retval = priv->GetSelf();
-    } else {
-        *retval = nsnull;
-    }
-
-    NS_IF_ADDREF(*retval);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::GetDisposed(PRBool *retval)
-{
-    *retval = mDisposed;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::GetUsage(PRUint32 *usage)
-{
-    if (mDisposed)
-        return NS_ERROR_FAILURE;
-
-    *usage = mUsage;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::GetLength(PRUint32 *retval)
-{
-    if (mDisposed)
-        return NS_ERROR_FAILURE;
-
-    *retval = mLength;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLBuffer::GetType(PRUint32 *retval)
-{
-    if (mDisposed)
-        return NS_ERROR_FAILURE;
-
-    *retval = mType;
-    return NS_OK;
-}
-
-/**
- ** CanvasGLTexture
- **/
-
-CanvasGLTexture::CanvasGLTexture(nsCanvasRenderingContextGLPrivate *owner)
-    : mDisposed(PR_FALSE),
-      //mGlitzTextureSurface(nsnull), mGlitzTextureObject(nsnull),
-      mWidth(0), mHeight(0)
-{
-    owner->GetWeakReference(getter_AddRefs(mOwnerContext));
-
-    gl = owner->gl;
-}
-
-CanvasGLTexture::~CanvasGLTexture()
-{
-    Dispose();
-}
-
-nsresult
-CanvasGLTexture::Init()
-{
-    return NS_OK;
-}
-
-nsresult
-CanvasGLTexture::Dispose()
-{
-    if (mDisposed)
-        return NS_OK;
-
-    mDisposed = PR_TRUE;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLTexture::GetDisposed(PRBool *retval)
-{
-    *retval = mDisposed;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLTexture::GetOwnerContext(nsICanvasRenderingContextGL **retval)
-{
-    nsCOMPtr<nsICanvasRenderingContextInternal> ctx = do_QueryReferent(mOwnerContext);
-    if (ctx) {
-        nsCanvasRenderingContextGLPrivate *priv = (nsCanvasRenderingContextGLPrivate*) ctx.get();
-        *retval = priv->GetSelf();
-    } else {
-        *retval = nsnull;
-    }
-
-    NS_IF_ADDREF(*retval);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLTexture::GetTarget(PRUint32 *aResult)
-{
-    //*aResult = glitz_texture_object_get_target (mGlitzTextureObject);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLTexture::GetWidth(PRUint32 *aWidth)
-{
-    *aWidth = mWidth;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLTexture::GetHeight(PRUint32 *aHeight)
-{
-    *aHeight = mHeight;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLTexture::SetFilter(PRUint32 filterType, PRUint32 filterMode)
-{
-    if (filterType < 0 || filterType > 1 ||
-        filterMode < 0 || filterMode > 1)
-    {
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    //glitz_texture_object_set_filter (mGlitzTextureObject, (glitz_texture_filter_type_t)filterType, (glitz_texture_filter_t)filterMode);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-CanvasGLTexture::SetWrap(PRUint32 wrapType, PRUint32 wrapMode)
-{
-    if (wrapType != GL_TEXTURE_WRAP_S &&
-        wrapType != GL_TEXTURE_WRAP_T)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (wrapMode != GL_CLAMP_TO_EDGE &&
-        wrapMode != GL_REPEAT &&
-        wrapMode != GL_MIRRORED_REPEAT)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    //glitz_texture_object_set_wrap (mGlitzTextureObject, (glitz_texture_wrap_type_t)wrapType, (glitz_texture_wrap_t)wrapMode);
-    return NS_OK;
-}
-
-/*
- * these got removed accidentally in bug 495499.  We make them just return false here and
- * take the slow path until we get that fixed up.
- */
-
-#define FOO(_x,_y) JSBool _x (JSContext *cx, JSObject *obj, jsuint offset, jsuint count, _y *dest) { return 0; }
-
-FOO(js_ArrayToJSUint8Buffer, JSUint8)
-FOO(js_ArrayToJSUint16Buffer, JSUint16)
-FOO(js_ArrayToJSUint32Buffer, JSUint32)
-FOO(js_ArrayToJSInt8Buffer, JSInt8)
-FOO(js_ArrayToJSInt16Buffer, JSInt16)
-FOO(js_ArrayToJSInt32Buffer, JSInt32)
-FOO(js_ArrayToJSDoubleBuffer, jsdouble)
-
-
-PRBool
-SimpleBuffer::InitFromJSArray(PRUint32 typeParam,
-                              PRUint32 sizeParam,
-                              JSContext *ctx,
-                              JSObject *arrayObj,
-                              jsuint arrayLen)
-{
-    if (typeParam == GL_SHORT) {
-        Prepare(typeParam, sizeParam, arrayLen);
-        short *ptr = (short*) data;
-
-        if (!js_ArrayToJSInt16Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
-            for (PRUint32 i = 0; i < arrayLen; i++) {
-                jsval jv;
-                int32 iv;
-                ::JS_GetElement(ctx, arrayObj, i, &jv);
-                ::JS_ValueToECMAInt32(ctx, jv, &iv);
-                *ptr++ = (short) iv;
-            }
-        }
-    } else if (typeParam == GL_FLOAT) {
-        Prepare(typeParam, sizeParam, arrayLen);
-        float *ptr = (float*) data;
-        double *tmpd = new double[arrayLen];
-        if (js_ArrayToJSDoubleBuffer(ctx, arrayObj, 0, arrayLen, tmpd)) {
-            for (PRUint32 i = 0; i < arrayLen; i++)
-                ptr[i] = (float) tmpd[i];
-        } else {
-            for (PRUint32 i = 0; i < arrayLen; i++) {
-                jsval jv;
-                jsdouble dv;
-                ::JS_GetElement(ctx, arrayObj, i, &jv);
-                ::JS_ValueToNumber(ctx, jv, &dv);
-                *ptr++ = (float) dv;
-            }
-        }
-        delete [] tmpd;
-    } else if (typeParam == GL_UNSIGNED_BYTE) {
-        Prepare(typeParam, sizeParam, arrayLen);
-        unsigned char *ptr = (unsigned char*) data;
-        if (!js_ArrayToJSUint8Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
-            for (PRUint32 i = 0; i < arrayLen; i++) {
-                jsval jv;
-                uint32 iv;
-                ::JS_GetElement(ctx, arrayObj, i, &jv);
-                ::JS_ValueToECMAUint32(ctx, jv, &iv);
-                *ptr++ = (unsigned char) iv;
-            }
-        }
-    } else if (typeParam == GL_UNSIGNED_SHORT) {
-        Prepare(typeParam, sizeParam, arrayLen);
-        PRUint16 *ptr = (PRUint16*) data;
-        if (!js_ArrayToJSUint16Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
-            for (PRUint32 i = 0; i < arrayLen; i++) {
-                jsval jv;
-                uint32 iv;
-                ::JS_GetElement(ctx, arrayObj, i, &jv);
-                ::JS_ValueToECMAUint32(ctx, jv, &iv);
-                *ptr++ = (unsigned short) iv;
-            }
-        }
-    } else if (typeParam == GL_UNSIGNED_INT) {
-        Prepare(typeParam, sizeParam, arrayLen);
-        PRUint32 *ptr = (PRUint32*) data;
-        if (!js_ArrayToJSUint32Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
-            for (PRUint32 i = 0; i < arrayLen; i++) {
-                jsval jv;
-                uint32 iv;
-                ::JS_GetElement(ctx, arrayObj, i, &jv);
-                ::JS_ValueToECMAUint32(ctx, jv, &iv);
-                *ptr++ = iv;
-            }
-        }
-    } else if (typeParam == GL_INT) {
-        Prepare(typeParam, sizeParam, arrayLen);
-        PRInt32 *ptr = (PRInt32*) data;
-        if (!js_ArrayToJSInt32Buffer(ctx, arrayObj, 0, arrayLen, ptr)) {
-            for (PRUint32 i = 0; i < arrayLen; i++) {
-                jsval jv;
-                int32 iv;
-                ::JS_GetElement(ctx, arrayObj, i, &jv);
-                ::JS_ValueToECMAInt32(ctx, jv, &iv);
-                *ptr++ = iv;
-            }
-        }
-    } else {
-        return PR_FALSE;
-    }
-
-    return PR_TRUE;
-}
-
-void
-nsCanvasRenderingContextGLPrivate::MakeContextCurrent()
-{
-    mGLPbuffer->MakeContextCurrent();
-}
-
-void
-nsCanvasRenderingContextGLPrivate::LostCurrentContext(void *closure)
-{
-    //nsCanvasRenderingContextGLPrivate* self = (nsCanvasRenderingContextGLPrivate*) closure;
-}
-
-//
-// nsICanvasRenderingContextInternal
-//
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLPrivate::SetCanvasElement(nsICanvasElement* aParentCanvas)
-{
-    nsresult rv;
-
-    if (aParentCanvas == nsnull) {
-        // we get this on shutdown; we should do some more cleanup here,
-        // but instead we just let our destructor do it.
-        return NS_OK;
-    }
-
-    if (!SafeToCreateCanvas3DContext(aParentCanvas))
-        return NS_ERROR_FAILURE;
-
-    // Let's find our prefs
-    nsCOMPtr<nsIPrefService> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    mPrefWireframe = PR_FALSE;
-    PRBool forceSoftware = PR_FALSE;
-
-    nsCOMPtr<nsIPrefBranch> prefBranch;
-    rv = prefService->GetBranch("extensions.canvas3d.", getter_AddRefs(prefBranch));
-    if (NS_SUCCEEDED(rv)) {
-        PRBool val;
-        rv = prefBranch->GetBoolPref("wireframe", &val);
-        if (NS_SUCCEEDED(rv))
-            mPrefWireframe = val;
-
-        rv = prefBranch->GetBoolPref("software_render", &val);
-        if (NS_SUCCEEDED(rv))
-            forceSoftware = val;
-    }
-
-    fprintf (stderr, "Wireframe: %d\n", mPrefWireframe);
-
-
-    LogMessage(NS_LITERAL_CSTRING("Canvas 3D: creating PBuffer..."));
-
-    if (!forceSoftware) {
-#ifdef XP_WIN
-        mGLPbuffer = new nsGLPbufferWGL();
-#elif defined(XP_UNIX) && defined(MOZ_X11)
-        mGLPbuffer = new nsGLPbufferGLX();
-#elif defined(XP_MACOSX)
-        mGLPbuffer = new nsGLPbufferCGL();
-#else
-        mGLPbuffer = nsnull;
-#endif
-
-        if (mGLPbuffer && !mGLPbuffer->Init(this))
-            mGLPbuffer = nsnull;
-    }
-
-    if (!mGLPbuffer) {
-        mGLPbuffer = new nsGLPbufferOSMESA();
-        if (!mGLPbuffer->Init(this))
-            mGLPbuffer = nsnull;
-    }
-
-    if (!mGLPbuffer)
-        return NS_ERROR_FAILURE;
-
-    gl = mGLPbuffer->GL();
-
-    if (!ValidateGL()) {
-        // XXX over here we need to destroy mGLPbuffer and create a mesa buffer
-
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Couldn't validate OpenGL implementation; is everything needed present?"));
-        return NS_ERROR_FAILURE;
-    }
-
-    mCanvasElement = aParentCanvas;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLPrivate::SetDimensions(PRInt32 width, PRInt32 height)
-{
-    if (mWidth == width && mHeight == height)
-        return NS_OK;
-
-    if (!mGLPbuffer->Resize(width, height)) {
-        LogMessage(NS_LITERAL_CSTRING("mGLPbuffer->Resize failed"));
-        return NS_ERROR_FAILURE;
-    }
-
-    LogMessage(NS_LITERAL_CSTRING("Canvas 3D: ready"));
-
-    mWidth = width;
-    mHeight = height;
-
-    // Make sure that we clear this out, otherwise
-    // we'll end up displaying random memory
-    MakeContextCurrent();
-    gl->fViewport(0, 0, mWidth, mHeight);
-    gl->fClearColor(0, 0, 0, 0);
-    gl->fClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLPrivate::Render(gfxContext *ctx, gfxPattern::GraphicsFilter f)
-{
-    nsresult rv = NS_OK;
-
-    if (!mGLPbuffer)
-        return NS_OK;
-
-    // use GL Drawing if we can get a target GL context; otherwise
-    // go through the fallback path.
-#ifdef HAVE_GL_DRAWING
-    if (mCanvasElement->GLWidgetBeginDrawing()) {
-        glClearColor(0.0, 0.0, 0.0, 0.0);
-        glClear(GL_COLOR_BUFFER_BIT);
-
-        int bwidth = mGLPbuffer->Width();
-        int bheight = mGLPbuffer->Height();
-
-        GLuint tex = 0;
-        glGenTextures(1, &tex);
-        glBindTexture(GL_TEXTURE_RECTANGLE_EXT, tex);
-
-        CGLError err =
-            CGLTexImagePBuffer(CGLGetCurrentContext(),
-                               ((nsGLPbufferCGL*)mGLPbuffer)->GetCGLPbuffer(),
-                               GL_BACK);
-        if (err) {
-            fprintf (stderr, "CGLTexImagePBuffer failed: %d\n", err);
-            glDeleteTextures(1, &tex);
-            return NS_OK;
-        }
-
-        glEnable(GL_TEXTURE_RECTANGLE_EXT);
-
-        glMatrixMode(GL_PROJECTION);
-        glLoadIdentity();
-        //glFrustum(-halfWidth, halfWidth, halfHeight, -halfHeight, 1.0, 100000.0);
-        glOrtho(0, bwidth, bheight, 0, -0.5, 10.0);
-
-        glMatrixMode(GL_MODELVIEW);
-        glLoadIdentity();
-
-        glBegin(GL_QUADS);
-
-        /* Note that the texture needs a y-flip */
-        glTexCoord2f(0.0, bheight);
-        glVertex3f(0.0, 0.0, 0.0);
-
-        glTexCoord2f(bwidth, bheight);
-        glVertex3f(bwidth, 0.0, 0.0);
-
-        glTexCoord2f(bwidth, 0);
-        glVertex3f(bwidth, bheight, 0.0);
-
-        glTexCoord2f(0.0, 0);
-        glVertex3f(0.0, bheight, 0.0);
-
-        glEnd();
-
-        glDisable(GL_TEXTURE_RECTANGLE_EXT);
-        glDeleteTextures(1, &tex);
-
-        mCanvasElement->GLWidgetSwapBuffers();
-        mCanvasElement->GLWidgetEndDrawing();
-    } else
-#endif
-    {
-        nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
-        if (!surf)
-            return NS_OK;
-
-        nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
-        gfxMatrix m;
-        m.Translate(gfxPoint(0.0, mGLPbuffer->Height()));
-        m.Scale(1.0, -1.0);
-        pat->SetMatrix(m);
-
-        // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
-        // pixel alignment for this stuff!
-        ctx->NewPath();
-        ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
-        ctx->Fill();
-    }
-    return rv;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLPrivate::GetInputStream(const char* aMimeType,
-                                                  const PRUnichar* aEncoderOptions,
-                                                  nsIInputStream **aStream)
-{
-    // XXX disabled for now due to the win32 nsRefPtr situation -- we need
-    // to manage allocations and deletions very carefully, and can't allocate
-    // an object in our dll and have xul.dll call delete on it (which
-    // Release() will do).
-    return NS_ERROR_FAILURE;
-
-#if 0
-    if (!mGLPbuffer ||
-        !mGLPbuffer->ThebesSurface())
-        return NS_ERROR_FAILURE;
-
-    nsresult rv;
-    const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
-    nsAutoArrayPtr<char> conid(new (std::nothrow) char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
-
-    if (!conid)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    strcpy(conid, encoderPrefix);
-    strcat(conid, aMimeType);
-
-    nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
-    if (!encoder)
-        return NS_ERROR_FAILURE;
-
-    nsAutoArrayPtr<PRUint8> imageBuffer(new (std::nothrow) PRUint8[mWidth * mHeight * 4]);
-    if (!imageBuffer)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(imageBuffer.get(),
-                                                            gfxIntSize(mWidth, mHeight),
-                                                            mWidth * 4,
-                                                            gfxASurface::ImageFormatARGB32);
-
-    if (!imgsurf || imgsurf->CairoStatus())
-        return NS_ERROR_FAILURE;
-
-    nsRefPtr<gfxContext> ctx = new gfxContext(imgsurf);
-
-    if (!ctx || ctx->HasError())
-        return NS_ERROR_FAILURE;
-
-    nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
-    nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
-    gfxMatrix m;
-    m.Translate(gfxPoint(0.0, mGLPbuffer->Height()));
-    m.Scale(1.0, -1.0);
-    pat->SetMatrix(m);
-
-    // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
-    // pixel alignment for this stuff!
-    ctx->NewPath();
-    ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
-    ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
-    ctx->Fill();
-
-    rv = encoder->InitFromData(imageBuffer.get(),
-                               mWidth * mHeight * 4, mWidth, mHeight, mWidth * 4,
-                               imgIEncoder::INPUT_FORMAT_HOSTARGB,
-                               nsDependentString(aEncoderOptions));
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    return CallQueryInterface(encoder, aStream);
-#endif
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLPrivate::GetThebesSurface(gfxASurface **surface)
-{
-    if (!mGLPbuffer) {
-        *surface = nsnull;
-        return NS_ERROR_NOT_AVAILABLE;
-    }
-
-    *surface = mGLPbuffer->ThebesSurface();
-    NS_IF_ADDREF(*surface);
-    return NS_OK;
-}
-
-nsCanvasRenderingContextGLPrivate::nsCanvasRenderingContextGLPrivate()
-    : mGLPbuffer(nsnull), mWidth(0), mHeight(0), mCanvasElement(nsnull)
-{
-    // grab the xpconnect service
-    if (!gXPConnect) {
-        nsresult rv = CallGetService(nsIXPConnect::GetCID(), &gXPConnect);
-        if (NS_FAILED(rv)) {
-            NS_ERROR("Failed to get XPConnect!");
-            return;
-        }
-    } else {
-        NS_ADDREF(gXPConnect);
-    }
-
-    if (!gJSRuntimeService) {
-        nsresult rv = CallGetService("@mozilla.org/js/xpc/RuntimeService;1",
-                                     &gJSRuntimeService);
-        if (NS_FAILED(rv)) {
-            // uh..
-            NS_ERROR("Failed to get JS RuntimeService!");
-            return;
-        }
-
-        gJSRuntimeService->GetRuntime(&gScriptRuntime);
-        if (!gScriptRuntime) {
-            NS_RELEASE(gJSRuntimeService);
-            gJSRuntimeService = nsnull;
-            NS_ERROR("Unable to get JS runtime from JS runtime service");
-        }
-    } else {
-        NS_ADDREF(gJSRuntimeService);
-    }
-}
-
-nsCanvasRenderingContextGLPrivate::~nsCanvasRenderingContextGLPrivate()
-{
-    delete mGLPbuffer;
-    mGLPbuffer = nsnull;
-    
-    // get rid of the context
-    if (gXPConnect && gXPConnect->Release() == 0)
-        gXPConnect = nsnull;
-    if (gJSRuntimeService && gJSRuntimeService->Release() == 0) {
-        gJSRuntimeService = nsnull;
-        gScriptRuntime = nsnull;
-    }
-}
-
-nsresult
-nsCanvasRenderingContextGLPrivate::DoSwapBuffers()
-{
-    mGLPbuffer->SwapBuffers();
-
-    // then invalidate the region and do a redraw
-    if (!mCanvasElement)
-        return NS_OK;
-
-    mCanvasElement->InvalidateFrame();
-    return NS_OK;
-}
-
-PRBool
-nsCanvasRenderingContextGLPrivate::SafeToCreateCanvas3DContext(nsICanvasElement *canvasElement)
-{
-    nsresult rv;
-
-    // first see if we're a chrome context
-    PRBool is_caller_chrome = PR_FALSE;
-    nsCOMPtr<nsIScriptSecurityManager> ssm =
-        do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    rv = ssm->SubjectPrincipalIsSystem(&is_caller_chrome);
-    if (NS_SUCCEEDED(rv) && is_caller_chrome)
-        return PR_TRUE;
-
-    // not chrome? check pref.
-
-    // first check our global pref
-    nsCOMPtr<nsIPrefBranch> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    PRBool allSites = PR_FALSE;
-    rv = prefService->GetBoolPref("extensions.canvas3d.enabled_for_all_sites", &allSites);
-    if (NS_SUCCEEDED(rv) && allSites) {
-        // the all-sites pref was set, we're good to go
-        return PR_TRUE;
-    }
-
-    // otherwise we'll check content prefs
-
-#ifdef ARGH_NEED_SEPARATE_SERVICE
-    // the content pref service IID changed after 3.1b3, so this will fail for nightly builds.
-    nsCOMPtr<nsIContentPrefService> cpsvc = do_GetService("@mozilla.org/content-pref/service;1", &rv);
-    if (NS_FAILED(rv)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Failed to get Content Pref service.  If you are running Firefox 3.1b3, as a temporary fix until 3.5b4 is released, open the Canvas 3D Addon preferences and check the \"Enabled for all sites\" checkbox."));
-        return PR_FALSE;
-    }
-
-    // grab our content URI
-    nsCOMPtr<nsIURI> contentURI;
-
-    nsCOMPtr<nsIPrincipal> principal;
-    rv = ssm->GetSubjectPrincipal(getter_AddRefs(principal));
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    if (!principal) {
-        // seriously? no script executing, but not the system principal?
-        return PR_FALSE;
-    }
-    rv = principal->GetURI(getter_AddRefs(contentURI));
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    // our pref is 'canvas3d.enabled'
-    nsCOMPtr<nsIVariant> val;
-    rv = cpsvc->GetPref(contentURI, NS_LITERAL_STRING("canvas3d.enabled"), getter_AddRefs(val));
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    PRInt32 iv;
-    rv = val->GetAsInt32(&iv);
-    if (NS_SUCCEEDED(rv)) {
-        // 1 means "yes, allowed"
-        if (iv == 1)
-            return PR_TRUE;
-
-        // -1 means "no, don't ask me again"
-        if (iv == -1)
-            return PR_FALSE;
-
-        // otherwise, we'll throw an event and maybe ask the user
-    }
-
-    // grab the document that we can use to create the event
-    nsCOMPtr<nsIDOMNode> node = do_QueryInterface(canvasElement);
-    nsCOMPtr<nsIDOMDocument> domDoc;
-    rv = node->GetOwnerDocument(getter_AddRefs(domDoc));
-
-    /*
-    // figure out where to throw the event.  we just go for the outermost
-    // document.  ideally, I want to throw the event to the <browser> if one exists,
-    // otherwise the topmost document, but that's more work than I want to deal with.
-    nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
-    while (doc->GetParentDocument())
-        doc = doc->GetParentDocument();
-    */
-
-    // set up the event
-    nsCOMPtr<nsIDOMDocumentEvent> docEvent = do_QueryInterface(domDoc);
-    NS_ENSURE_TRUE(docEvent, PR_FALSE);
-
-    nsCOMPtr<nsIDOMEvent> eventBase;
-    rv = docEvent->CreateEvent(NS_LITERAL_STRING("DataContainerEvent"), getter_AddRefs(eventBase));
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    rv = eventBase->InitEvent(NS_LITERAL_STRING("Canvas3DContextRequest"), PR_TRUE, PR_TRUE);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    nsCOMPtr<nsIDOMDataContainerEvent> event = do_QueryInterface(eventBase);
-    nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(eventBase);
-    NS_ENSURE_TRUE(event && privateEvent, PR_FALSE);
-
-    // mark it as trusted, so that it'll bubble upwards into chrome
-    privateEvent->SetTrusted(PR_TRUE);
-
-    // set some extra data on the event
-    nsCOMPtr<nsIContentURIGrouper> grouper = do_GetService("@mozilla.org/content-pref/hostname-grouper;1", &rv);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    nsAutoString group;
-    rv = grouper->Group(contentURI, group);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    nsCOMPtr<nsIWritableVariant> groupVariant = do_CreateInstance(NS_VARIANT_CONTRACTID);
-    nsCOMPtr<nsIWritableVariant> uriVariant = do_CreateInstance(NS_VARIANT_CONTRACTID);
-
-    groupVariant->SetAsAString(group);
-    uriVariant->SetAsISupports(contentURI);
-
-    rv = event->SetData(NS_LITERAL_STRING("group"), groupVariant);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    rv = event->SetData(NS_LITERAL_STRING("uri"), uriVariant);
-    NS_ENSURE_SUCCESS(rv, PR_FALSE);
-
-    // our target...
-    nsCOMPtr<nsIDOMEventTarget> targ = do_QueryInterface(canvasElement);
-
-    // and go.
-    PRBool defaultActionEnabled;
-    targ->DispatchEvent(event, &defaultActionEnabled);
-#endif
-
-    return PR_FALSE;
-}
-
-gfxImageSurface *
-CanvasGLThebes::CreateImageSurface (const gfxIntSize &isize,
-                                    gfxASurface::gfxImageFormat fmt)
-{
-    /*void *p = NS_Alloc(sizeof(gfxImageSurface));*/
-    return new /*(p)*/ gfxImageSurface (isize, fmt);
-}
-
-gfxContext *
-CanvasGLThebes::CreateContext (gfxASurface *surf)
-{
-    void *p = NS_Alloc(sizeof(gfxContext));
-    return new (p) gfxContext (surf);
-}
-
-gfxPattern *
-CanvasGLThebes::CreatePattern (gfxASurface *surf)
-{
-    /*void *p = NS_Alloc(sizeof(gfxPattern));*/
-    return new /*(p)*/ gfxPattern(surf);
-}
-
-/*
- * We need this here, because nsAString has a different type name based on whether it's
- * used internally or externally.  BeginPrinting isn't ever called, but gfxImageSurface
- * wants to inherit the default definition, and it can't find it.  So instead, we just
- * stick a stub here to shut the compiler up, because we never call this method.
- */
-
-#ifdef XP_WIN
-nsresult
-gfxWindowsSurface::BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName)
-{
-    return NS_ERROR_NOT_IMPLEMENTED;
-}
-nsresult
-gfxASurface::BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName)
-{
-    return NS_ERROR_NOT_IMPLEMENTED;
-}
-#endif
-
diff -r 5b1fe1bf3872 content/canvas/src/nsCanvasRenderingContextGL.h
--- a/content/canvas/src/nsCanvasRenderingContextGL.h	Fri Dec 11 07:02:35 2009 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,423 +0,0 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- *   Mozilla Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2007
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef _NSCANVASRENDERINGCONTEXTGL_H_
-#define _NSCANVASRENDERINGCONTEXTGL_H_
-
-#ifdef C3D_STANDALONE_BUILD
-#include "c3d-standalone.h"
-#endif
-
-#include "nsICanvasRenderingContextGL.h"
-
-#include <stdlib.h>
-#include <stdarg.h>
-
-#include "prmem.h"
-
-#include "nsStringGlue.h"
-
-#include "nsICanvasRenderingContextGLBuffer.h"
-#include "nsICanvasRenderingContextInternal.h"
-#include "nsIDOMHTMLCanvasElement.h"
-
-#include "nsICanvasGLPrivate.h"
-
-#include "nsIScriptSecurityManager.h"
-#include "nsISecurityCheckedComponent.h"
-
-#include "nsWeakReference.h"
-
-#include "imgIRequest.h"
-#include "imgIContainer.h"
-#include "nsIDOMHTMLCanvasElement.h"
-#include "nsICanvasElement.h"
-#include "nsIDOMHTMLImageElement.h"
-#include "nsIImageLoadingContent.h"
-#include "nsIInterfaceRequestorUtils.h"
-#include "nsDOMError.h"
-#include "nsIJSRuntimeService.h"
-
-#include "nsIServiceManager.h"
-#include "nsIConsoleService.h"
-
-#include "nsDOMError.h"
-
-#include "nsServiceManagerUtils.h"
-
-#include "nsIXPConnect.h"
-#include "jsapi.h"
-
-#include "gfxContext.h"
-
-#include "nsGLPbuffer.h"
-
-extern nsIXPConnect *gXPConnect;
-extern JSRuntime *gScriptRuntime;
-extern nsIJSRuntimeService *gJSRuntimeService;
-
-class nsICanvasRenderingContextGL;
-
-class nsCanvasRenderingContextGLES11;
-class nsCanvasRenderingContextGLWeb20;
-
-class CanvasGLBuffer;
-class CanvasGLTexture;
-
-class nsCanvasRenderingContextGLPrivate :
-    public nsICanvasRenderingContextInternal,
-    public nsSupportsWeakReference
-{
-    friend class nsGLPbuffer;
-    friend class CanvasGLBuffer;
-    friend class CanvasGLTexture;
-
-public:
-    nsCanvasRenderingContextGLPrivate();
-    virtual ~nsCanvasRenderingContextGLPrivate();
-
-    virtual nsICanvasRenderingContextGL *GetSelf() = 0;
-
-    virtual PRBool ValidateGL() { return PR_TRUE; }
-
-    void MakeContextCurrent();
-    static void LostCurrentContext(void *closure);
-
-    // nsICanvasRenderingContextInternal
-    NS_IMETHOD SetCanvasElement(nsICanvasElement* aParentCanvas);
-    NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);
-    NS_IMETHOD Render(gfxContext *ctx, gfxPattern::GraphicsFilter f);
-    NS_IMETHOD GetInputStream(const char* aMimeType,
-                              const PRUnichar* aEncoderOptions,
-                              nsIInputStream **aStream);
-    NS_IMETHOD GetThebesSurface(gfxASurface **surface);
-    NS_IMETHOD SetIsOpaque(PRBool b) { return NS_OK; };
-
-protected:
-    PRBool SafeToCreateCanvas3DContext(nsICanvasElement *canvasElement);
-    nsresult DoSwapBuffers();
-
-    // thebes helpers
-    nsresult ImageSurfaceFromElement(nsIDOMElement *imgElt,
-                                     gfxImageSurface **aSurface,
-                                     nsIPrincipal **prinOut,
-                                     PRBool *forceWriteOnlyOut,
-                                     PRBool *surfaceNeedsReleaseInsteadOfDelete);
-
-    void DoDrawImageSecurityCheck(nsIPrincipal* element_uri, PRBool forceWriteOnly);
-
-    GLES20Wrap *gl;
-
-    nsGLPbuffer *mGLPbuffer;
-    PRInt32 mWidth, mHeight;
-    nsICanvasElement* mCanvasElement;
-
-    PRPackedBool mPrefWireframe;
-
-    void LogMessage (const nsCString& errorString) {
-        nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
-        if (!console)
-            return;
-
-        console->LogStringMessage(NS_ConvertUTF8toUTF16(errorString).get());
-        fprintf(stderr, "%s\n", errorString.get());
-    }
-
-    void LogMessagef (const char *fmt, ...) {
-        va_list ap;
-        va_start(ap, fmt);
-        char buf[256];
-
-        nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
-        if (console) {
-            vsnprintf(buf, 256, fmt, ap);
-            console->LogStringMessage(NS_ConvertUTF8toUTF16(nsDependentCString(buf)).get());
-            fprintf(stderr, "%s\n", buf);
-        }
-
-        va_end(ap);
-    }
-
-};
-
-class SimpleBuffer {
-public:
-    SimpleBuffer()
-      : type(GL_FLOAT), data(nsnull), length(0), capacity(0), sizePerVertex(0)
-    { }
-
-    SimpleBuffer(PRUint32 typeParam,
-                 PRUint32 sizeParam,
-                 JSContext *ctx,
-                 JSObject *arrayObj,
-                 jsuint arrayLen)
-      : type(GL_FLOAT), data(nsnull), length(0), capacity(0), sizePerVertex(0)
-    {
-        InitFromJSArray(typeParam, sizeParam, ctx, arrayObj, arrayLen);
-    }
-
-    PRBool InitFromJSArray(PRUint32 typeParam,
-                           PRUint32 sizeParam,
-                           JSContext *ctx,
-                           JSObject *arrayObj,
-                           jsuint arrayLen);
-
-    ~SimpleBuffer() {
-        Release();
-    }
-
-    inline PRBool Valid() {
-        return data != nsnull;
-    }
-
-    inline PRUint32 ElementSize() {
-        if (type == GL_FLOAT) return sizeof(float);
-        if (type == GL_SHORT) return sizeof(short);
-        if (type == GL_UNSIGNED_SHORT) return sizeof(unsigned short);
-        if (type == GL_BYTE) return 1;
-        if (type == GL_UNSIGNED_BYTE) return 1;
-        if (type == GL_INT) return sizeof(int);
-        if (type == GL_UNSIGNED_INT) return sizeof(unsigned int);
-        if (type == GL_DOUBLE) return sizeof(double);
-        return 0;
-    }
-
-    void Clear() {
-        Release();
-    }
-
-    void Set(PRUint32 t, PRUint32 spv, PRUint32 count, void* vals) {
-        Prepare(t, spv, count);
-
-        if (count)
-            memcpy(data, vals, count*ElementSize());
-    }
-
-    void Prepare(PRUint32 t, PRUint32 spv, PRUint32 count) {
-        if (count == 0) {
-            Release();
-        } else {
-            type = t;
-            EnsureCapacity(PR_FALSE, count*ElementSize());
-            length = count;
-            sizePerVertex = spv;
-        }
-    }
-
-    void Release() {
-        if (data)
-            PR_Free(data);
-        length = 0;
-        capacity = 0;
-        data = nsnull;
-    }
-
-    void EnsureCapacity(PRBool preserve, PRUint32 cap) {
-        if (capacity >= cap)
-            return;
-
-        void* newdata = PR_Malloc(cap);
-        if (preserve && length)
-            memcpy(newdata, data, length*ElementSize());
-        PR_Free(data);
-        data = newdata;
-        capacity = cap;
-    }
-
-    PRUint32 type;
-    void* data;
-    PRUint32 length;        // # of elements
-    PRUint32 capacity;      // bytes!
-    PRUint32 sizePerVertex; // OpenGL "size" param; num coordinates per vertex
-};
-
-class CanvasGLTexture :
-    public nsICanvasRenderingContextGLTexture,
-    public nsICanvasGLTexture
-{
-    friend class nsCanvasRenderingContextGLES11;
-    friend class nsCanvasRenderingContextGLWeb20;
-public:
-    CanvasGLTexture(nsCanvasRenderingContextGLPrivate *owner);
-    ~CanvasGLTexture();
-
-    NS_DECL_ISUPPORTS
-
-    NS_DECL_NSICANVASRENDERINGCONTEXTGLTEXTURE
-
-    nsresult Init();
-    nsresult Dispose();
-
-protected:
-    PRBool mDisposed;
-    nsCOMPtr<nsIWeakReference> mOwnerContext;
-
-    GLES20Wrap *gl;
-
-    PRUint32 mWidth;
-    PRUint32 mHeight;
-};
-
-class CanvasGLBuffer :
-    public nsICanvasRenderingContextGLBuffer,
-    public nsISecurityCheckedComponent,
-    public nsICanvasGLBuffer
-{
-    friend class nsCanvasRenderingContextGLES11;
-    friend class nsCanvasRenderingContextGLWeb20;
-public:
-
-    CanvasGLBuffer(nsCanvasRenderingContextGLPrivate *owner);
-    ~CanvasGLBuffer();
-
-    // Init can be called multiple times to reinitialize this
-    // buffer object
-    nsresult Init (PRUint32 usage,
-                   PRUint32 size,
-                   PRUint32 type,
-                   JSContext *ctx,
-                   JSObject *arrayObj,
-                   jsuint arrayLen);
-
-    SimpleBuffer& GetSimpleBuffer() { return mSimpleBuffer; }
-    PRBool UpdateBuffer (PRUint32 offset, SimpleBuffer& sbuffer)
-    {
-        PRUint32 len = GetSimpleBuffer().capacity;
-        PRUint32 sbuflen = sbuffer.capacity;
-        if (offset < 0 || offset > len || sbuflen > len || offset > len - sbuflen)
-            return false;
-        memcpy(((char*)(GetSimpleBuffer().data)) + offset, sbuffer.data, sbuflen);
-        mMaxUShortComputed = false;
-        return true;
-    }
-    GLushort MaxUShortValue()
-    {
-        if (!mMaxUShortComputed) {
-            GLushort *data = (GLushort*)GetSimpleBuffer().data;
-            PRUint32 i, len;
-            GLushort max = 0;
-            len = GetSimpleBuffer().capacity / sizeof(GLushort);
-            for (i=0; i<len; ++i)
-                if (data[i] > max)
-                    max = data[i];
-            mMaxUShort = max;
-            mMaxUShortComputed = true;
-        }
-        return mMaxUShort;
-    }
-
-    NS_DECL_ISUPPORTS
-    NS_DECL_NSICANVASRENDERINGCONTEXTGLBUFFER
-    NS_DECL_NSISECURITYCHECKEDCOMPONENT
-
-    PRUint32 Size() { return mSize; }
-    PRUint32 Length() { return mLength; }
-    PRUint32 Type() { return mType; }
-
-protected:
-    CanvasGLBuffer() { }
-
-    nsCOMPtr<nsIWeakReference> mOwnerContext;
-
-    GLES20Wrap *gl;
-
-    PRBool mDisposed;
-
-    PRUint32 mLength;
-    PRUint32 mSize;
-    PRUint32 mType;
-    PRUint32 mUsage;
-
-    SimpleBuffer mSimpleBuffer;
-    GLuint mBufferID;
-
-    GLushort mMaxUShort;
-    PRBool mMaxUShortComputed;
-};
-
-class CanvasGLThebes {
-public:
-    static gfxImageSurface *CreateImageSurface (const gfxIntSize &isize,
-                                                gfxASurface::gfxImageFormat fmt);
-
-    static gfxContext *CreateContext (gfxASurface *surf);
-
-    static gfxPattern *CreatePattern (gfxASurface *surf);
-};
-
-/* Helper macros for when we're just wrapping a gl method, so that
- * we can avoid having to type this 500 times.  Note that these MUST
- * NOT BE USED if we need to check any of the parameters.
- */
-
-#define GL_SAME_METHOD_0(glname, name)                       \
-NS_IMETHODIMP NSGL_CONTEXT_NAME::name() {       \
-    MakeContextCurrent(); gl->f##glname(); return NS_OK;        \
-}
-
-#define GL_SAME_METHOD_1(glname, name, t1)                            \
-NS_IMETHODIMP NSGL_CONTEXT_NAME::name(t1 a1) {           \
-    MakeContextCurrent(); gl->f##glname(a1); return NS_OK;               \
-}
-
-#define GL_SAME_METHOD_2(glname, name, t1, t2)                          \
-NS_IMETHODIMP NSGL_CONTEXT_NAME::name(t1 a1, t2 a2) {      \
-    MakeContextCurrent(); gl->f##glname(a1,a2); return NS_OK;              \
-}
-
-#define GL_SAME_METHOD_3(glname, name, t1, t2, t3)                        \
-NS_IMETHODIMP NSGL_CONTEXT_NAME::name(t1 a1, t2 a2, t3 a3) { \
-    MakeContextCurrent(); gl->f##glname(a1,a2,a3); return NS_OK;             \
-}
-
-#define GL_SAME_METHOD_4(glname, name, t1, t2, t3, t4)                           \
-NS_IMETHODIMP NSGL_CONTEXT_NAME::name(t1 a1, t2 a2, t3 a3, t4 a4) { \
-    MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4); return NS_OK;                 \
-}
-
-#define GL_SAME_METHOD_5(glname, name, t1, t2, t3, t4, t5)                              \
-NS_IMETHODIMP NSGL_CONTEXT_NAME::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5) { \
-    MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5); return NS_OK;                     \
-}
-
-#define GL_SAME_METHOD_6(glname, name, t1, t2, t3, t4, t5, t6)                                 \
-NS_IMETHODIMP NSGL_CONTEXT_NAME::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6) { \
-    MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5,a6); return NS_OK;                         \
-}
-
-#endif /* _NSCANVASRENDERINGCONTEXTGL_H_ */
diff -r 5b1fe1bf3872 content/canvas/src/nsCanvasRenderingContextGLWeb20.cpp
--- a/content/canvas/src/nsCanvasRenderingContextGLWeb20.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2829 +0,0 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is
- *   Mozilla Corporation.
- * Portions created by the Initial Developer are Copyright (C) 2006
- * the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "prmem.h"
-#include "prlog.h"
-
-#include "nsIRenderingContext.h"
-
-#include "nsTArray.h"
-
-#define NSGL_CONTEXT_NAME nsCanvasRenderingContextGLWeb20
-
-#include "nsCanvasRenderingContextGL.h"
-#include "nsICanvasRenderingContextGLBuffer.h"
-#include "nsICanvasRenderingContextGLWeb20.h"
-#include "nsICanvasRenderingContextInternal.h"
-#include "nsIDOMHTMLCanvasElement.h"
-#include "nsIView.h"
-#include "nsIViewManager.h"
-
-#include "nsIDocument.h"
-
-#include "nsTransform2D.h"
-
-#include "nsIScriptSecurityManager.h"
-#include "nsISecurityCheckedComponent.h"
-
-#include "nsWeakReference.h"
-
-#include "nsIInterfaceRequestorUtils.h"
-#include "nsDOMError.h"
-#include "nsIJSRuntimeService.h"
-
-#include "nsIClassInfoImpl.h"
-
-#include "nsServiceManagerUtils.h"
-
-#include "nsLayoutUtils.h"
-
-#include "nsDOMError.h"
-
-#include "nsIXPConnect.h"
-#include "jsapi.h"
-
-#include "CanvasUtils.h"
-#include "NativeJSContext.h"
-
-#ifdef XP_WIN
-#include <windows.h>
-#endif
-
-#include <GL/gl.h>
-
-using namespace mozilla;
-
-#ifndef GL_MAX_RENDERBUFFER_SIZE
-#define GL_MAX_RENDERBUFFER_SIZE      0x84E8
-#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
-#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
-#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
-#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
-#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET 0x8CD4
-#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
-#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
-#define GL_MAX_COLOR_ATTACHMENTS      0x8CDF
-#define GL_COLOR_ATTACHMENT0          0x8CE0
-#define GL_COLOR_ATTACHMENT1          0x8CE1
-#define GL_COLOR_ATTACHMENT2          0x8CE2
-#define GL_COLOR_ATTACHMENT3          0x8CE3
-#define GL_COLOR_ATTACHMENT4          0x8CE4
-#define GL_COLOR_ATTACHMENT5          0x8CE5
-#define GL_COLOR_ATTACHMENT6          0x8CE6
-#define GL_COLOR_ATTACHMENT7          0x8CE7
-#define GL_COLOR_ATTACHMENT8          0x8CE8
-#define GL_COLOR_ATTACHMENT9          0x8CE9
-#define GL_COLOR_ATTACHMENT10         0x8CEA
-#define GL_COLOR_ATTACHMENT11         0x8CEB
-#define GL_COLOR_ATTACHMENT12         0x8CEC
-#define GL_COLOR_ATTACHMENT13         0x8CED
-#define GL_COLOR_ATTACHMENT14         0x8CEE
-#define GL_COLOR_ATTACHMENT15         0x8CEF
-#define GL_DEPTH_ATTACHMENT           0x8D00
-#define GL_STENCIL_ATTACHMENT         0x8D20
-#define GL_FRAMEBUFFER_BINDING        0x8CA6
-#define GL_RENDERBUFFER_BINDING       0x8CA7
-#endif
-
-#ifndef GL_VERTEX_PROGRAM_POINT_SIZE
-#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
-#endif
-
-// we're hoping that something is setting us up the remap
-
-#include "gfxImageSurface.h"
-#include "gfxContext.h"
-#include "gfxPlatform.h"
-
-#ifdef PR_LOGGING
-PRLogModuleInfo* gGLES20Log = nsnull;
-#endif
-
-class nsCanvasRenderingContextGLWeb20 :
-    public nsICanvasRenderingContextGLWeb20,
-    public nsCanvasRenderingContextGLPrivate
-{
-public:
-    nsCanvasRenderingContextGLWeb20();
-    virtual ~nsCanvasRenderingContextGLWeb20();
-
-    NS_DECL_ISUPPORTS
-
-    NS_DECL_NSICANVASRENDERINGCONTEXTGL
-
-    NS_DECL_NSICANVASRENDERINGCONTEXTGLWEB20
-
-    // nsICanvasRenderingContextPrivate
-    virtual nsICanvasRenderingContextGL *GetSelf() { return this; }
-    virtual PRBool ValidateGL();
-
-protected:
-    nsresult TexImageElementBase(nsIDOMHTMLElement *imageOrCanvas,
-                                 gfxImageSurface **imageOut);
-
-    PRBool ValidateBuffers(PRUint32 count);
-
-    nsTArray<nsRefPtr<CanvasGLBuffer> > mAttribBuffers;
-    nsTArray<nsRefPtr<CanvasGLBuffer> > mBuffers;
-};
-
-
-// nsCanvasRenderingContextGLWeb20
-
-NS_IMPL_ADDREF(nsCanvasRenderingContextGLWeb20)
-NS_IMPL_RELEASE(nsCanvasRenderingContextGLWeb20)
-
-NS_INTERFACE_MAP_BEGIN(nsCanvasRenderingContextGLWeb20)
-  NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextGL)
-  NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextGLWeb20)
-  NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
-  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICanvasRenderingContextGL)
-  NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(CanvasRenderingContextGLWeb20)
-NS_INTERFACE_MAP_END
-
-static PRBool BaseTypeAndSizeFromUniformType(GLenum uType, GLenum *baseType, GLint *unitSize);
-
-nsresult
-NS_NewCanvasRenderingContextGLWeb20(nsICanvasRenderingContextGLWeb20** aResult)
-{
-    nsICanvasRenderingContextGLWeb20* ctx = new nsCanvasRenderingContextGLWeb20();
-    if (!ctx)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    NS_ADDREF(*aResult = ctx);
-    return NS_OK;
-}
-
-nsCanvasRenderingContextGLWeb20::nsCanvasRenderingContextGLWeb20()
-{
-}
-
-nsCanvasRenderingContextGLWeb20::~nsCanvasRenderingContextGLWeb20()
-{
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetCanvas(nsIDOMHTMLCanvasElement **_retval)
-{
-    if (mCanvasElement == nsnull) {
-        *_retval = nsnull;
-        return NS_OK;
-    }
-
-    return CallQueryInterface(mCanvasElement, _retval);
-}
-
-/* void activeTexture (in PRUint32 texture); */
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::ActiveTexture(PRUint32 texture)
-{
-    // XXX query number of textures available
-    if (texture < GL_TEXTURE0 || texture > GL_TEXTURE0+32)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    MakeContextCurrent();
-    gl->fActiveTexture(texture);
-    return NS_OK;
-}
-
-GL_SAME_METHOD_2(AttachShader, AttachShader, PRUint32, PRUint32)
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::BindAttribLocation(PRUint32 program, PRUint32 location, const char *name)
-{
-    if (!name)
-        return NS_ERROR_INVALID_ARG;
-
-    MakeContextCurrent();
-    gl->fBindAttribLocation(program, location, name);
-    return NS_OK;
-}
-
-GL_SAME_METHOD_2(BindBuffer, BindBuffer, PRUint32, PRUint32)
-
-GL_SAME_METHOD_2(BindFramebuffer, BindFramebuffer, PRUint32, PRUint32)
-
-GL_SAME_METHOD_2(BindRenderbuffer, BindRenderbuffer, PRUint32, PRUint32)
-
-GL_SAME_METHOD_2(BindTexture, BindTexture, PRUint32, PRUint32)
-
-GL_SAME_METHOD_4(BlendColor, BlendColor, float, float, float, float)
-
-GL_SAME_METHOD_1(BlendEquation, BlendEquation, PRUint32)
-
-GL_SAME_METHOD_2(BlendEquationSeparate, BlendEquationSeparate, PRUint32, PRUint32)
-
-GL_SAME_METHOD_2(BlendFunc, BlendFunc, PRUint32, PRUint32)
-
-GL_SAME_METHOD_4(BlendFuncSeparate, BlendFuncSeparate, PRUint32, PRUint32, PRUint32, PRUint32)
-
-/* target, array, type, usage */
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::BufferData()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 4)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    nsresult rv;
-
-    JSObject *arrayObj;
-    jsuint arrayLen;
-    jsuint target;
-    jsuint type;
-    jsuint usage;
-    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uouu", &target, &arrayObj, &type, &usage) ||
-        arrayObj == NULL ||
-        !::JS_IsArrayObject(js.ctx, arrayObj) ||
-        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
-    {
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if (target != GL_ARRAY_BUFFER && target != GL_ELEMENT_ARRAY_BUFFER) {
-        LogMessagef(("bufferData: invalid target"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    if (target == GL_ELEMENT_ARRAY_BUFFER && type != GL_UNSIGNED_SHORT) {
-        LogMessagef(("bufferData: invalid type for element array"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    switch (usage) {
-        case GL_STATIC_DRAW:
-        case GL_DYNAMIC_DRAW:
-        case GL_STREAM_DRAW:
-            break;
-        default:
-            LogMessagef(("bufferData: invalid usage"));
-            return NS_ERROR_INVALID_ARG;
-    }
-
-    MakeContextCurrent();
-    GLint binding = 0;
-    GLenum binding_target = GL_ARRAY_BUFFER_BINDING;
-    if (target == GL_ELEMENT_ARRAY_BUFFER)
-        binding_target = GL_ELEMENT_ARRAY_BUFFER_BINDING;
-    gl->fGetIntegerv(binding_target, &binding);
-    if (binding <= 0) {
-        LogMessagef(("bufferData: no buffer bound"));
-        return NS_ERROR_FAILURE;
-    }
-
-    nsRefPtr<CanvasGLBuffer> newBuffer;
-    newBuffer = new CanvasGLBuffer(this);
-    if (!newBuffer)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    rv = newBuffer->Init (usage, 1, type, js.ctx, arrayObj, arrayLen);
-    if (NS_FAILED(rv))
-        return rv;
-
-    if (!mBuffers.SetCapacity(binding+1))
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    mBuffers[binding] = newBuffer;
-
-    gl->fBufferData(target,
-        newBuffer->GetSimpleBuffer().capacity,
-        newBuffer->GetSimpleBuffer().data, usage);
-
-    return NS_OK;
-}
-
-/* target, offset, array, type */
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::BufferSubData()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 4)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    JSObject *arrayObj;
-    jsuint arrayLen;
-    jsuint target;
-    jsuint offset;
-    jsuint type;
-    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuou", &target, &offset, &arrayObj, &type) ||
-        arrayObj == NULL ||
-        !::JS_IsArrayObject(js.ctx, arrayObj) ||
-        !::JS_GetArrayLength(js.ctx, arrayObj, &arrayLen))
-    {
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if (target != GL_ARRAY_BUFFER && target != GL_ELEMENT_ARRAY_BUFFER) {
-        LogMessagef(("bufferSubData: invalid target"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    if (target == GL_ELEMENT_ARRAY_BUFFER && type != GL_UNSIGNED_SHORT) {
-        LogMessagef(("bufferSubData: invalid type for element array"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    MakeContextCurrent();
-    GLint binding = 0;
-    GLenum binding_target = GL_ARRAY_BUFFER_BINDING;
-    if (target == GL_ELEMENT_ARRAY_BUFFER)
-        binding_target = GL_ELEMENT_ARRAY_BUFFER_BINDING;
-    gl->fGetIntegerv(binding_target, &binding);
-    if (binding <= 0) {
-        LogMessagef(("bufferSubData: no buffer bound"));
-        return NS_ERROR_FAILURE;
-    }
-
-    if ((GLushort)binding >= mBuffers.Length() || !mBuffers[binding]) {
-        LogMessagef(("bufferSubData: no mBuffers[binding]"));
-        return NS_ERROR_FAILURE;
-    }
-
-    SimpleBuffer sbuffer(type, 1, js.ctx, arrayObj, arrayLen);
-    if (!sbuffer.Valid())
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (!mBuffers[binding]->UpdateBuffer(offset, sbuffer)) {
-        LogMessagef(("bufferSubData: trying to write out of bounds"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    gl->fBufferSubData(target, offset, sbuffer.capacity, sbuffer.data);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::CheckFramebufferStatus(PRUint32 target, PRUint32 *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fCheckFramebufferStatus(target);
-    return NS_OK;
-}
-
-GL_SAME_METHOD_1(Clear, Clear, PRUint32)
-
-GL_SAME_METHOD_4(ClearColor, ClearColor, float, float, float, float)
-
-GL_SAME_METHOD_1(ClearDepth, ClearDepth, float)
-
-GL_SAME_METHOD_1(ClearStencil, ClearStencil, PRInt32)
-
-GL_SAME_METHOD_4(ColorMask, ColorMask, PRBool, PRBool, PRBool, PRBool)
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::CopyTexImage2D(PRUint32 target,
-                                                PRInt32 level,
-                                                PRUint32 internalformat,
-                                                PRInt32 x,
-                                                PRInt32 y,
-                                                PRUint32 width,
-                                                PRUint32 height,
-                                                PRInt32 border)
-{
-    switch (target) {
-        case GL_TEXTURE_2D:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("copyTexImage2D: unsupported target"));
-            return NS_ERROR_INVALID_ARG;
-    }
-
-    switch (internalformat) {
-        case GL_RGB:
-        case GL_RGBA:
-        case GL_ALPHA:
-        case GL_LUMINANCE:
-        case GL_LUMINANCE_ALPHA:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("copyTexImage2D: internal format not supported"));
-            return NS_ERROR_INVALID_ARG;
-    }
-
-    if (border != 0) {
-        LogMessage(NS_LITERAL_CSTRING("copyTexImage2D: border != 0"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight)) {
-        LogMessage(NS_LITERAL_CSTRING("copyTexImage2D: copied rectangle out of bounds"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    MakeContextCurrent();
-    gl->fCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::CopyTexSubImage2D(PRUint32 target,
-                                                   PRInt32 level,
-                                                   PRInt32 xoffset,
-                                                   PRInt32 yoffset,
-                                                   PRInt32 x,
-                                                   PRInt32 y,
-                                                   PRUint32 width,
-                                                   PRUint32 height)
-{
-    switch (target) {
-        case GL_TEXTURE_2D:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("copyTexSubImage2D: unsupported target"));
-            return NS_ERROR_INVALID_ARG;
-    }
-
-    if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight)) {
-        LogMessage(NS_LITERAL_CSTRING("copyTexSubImage2D: copied rectangle out of bounds"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    MakeContextCurrent();
-    gl->fCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
-
-    return NS_OK;
-}
-
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::CreateProgram(PRUint32 *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fCreateProgram();
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::CreateShader(PRUint32 type, PRUint32 *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fCreateShader(type);
-    return NS_OK;
-}
-
-GL_SAME_METHOD_1(CullFace, CullFace, PRUint32)
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::DeleteBuffers()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 1)
-        return NS_ERROR_INVALID_ARG;
-
-    JSObject *arrayObj;
-    jsuint arrayLen;
-    if (!NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[0], &arrayObj, &arrayLen))
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (arrayLen <= 0)
-        return NS_ERROR_INVALID_ARG;
-
-    SimpleBuffer sbuffer(GL_UNSIGNED_INT, 1, js.ctx, arrayObj, arrayLen);
-    if (!sbuffer.Valid())
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    PRUint32 i;
-    GLuint id;
-    PRUint32 len = mBuffers.Length();
-    PRBool doResize = PR_FALSE;
-    for (i=0; i<arrayLen; ++i) {
-        id = ((GLuint*)sbuffer.data)[i];
-        if (id < len) {
-            mBuffers[id] = NULL;
-            if (id == len-1)
-                doResize = PR_TRUE;
-        }
-    }
-    if (doResize) {
-        // find last non-null index
-        for (i=len-1; i>0; --i)
-            if (mBuffers[i]) break;
-
-        // shrink mBuffers to fit contents
-        if (mBuffers.Length() > i+1)
-            mBuffers.SetLength(i+1);
-    }
-
-    MakeContextCurrent();
-    gl->fDeleteBuffers(arrayLen, (GLuint*) sbuffer.data);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::DeleteFramebuffers()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 1)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    JSObject *arrayObj;
-    jsuint arrayLen;
-    if (!NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[0], &arrayObj, &arrayLen))
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (arrayLen == 0)
-        return NS_OK;
-
-    SimpleBuffer sbuffer(GL_UNSIGNED_INT, 1, js.ctx, arrayObj, arrayLen);
-    if (!sbuffer.Valid())
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    MakeContextCurrent();
-    gl->fDeleteFramebuffers(arrayLen, (GLuint*) sbuffer.data);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::DeleteRenderbuffers()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 1)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    JSObject *arrayObj;
-    jsuint arrayLen;
-    if (!NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[0], &arrayObj, &arrayLen))
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (arrayLen == 0)
-        return NS_OK;
-
-    SimpleBuffer sbuffer(GL_UNSIGNED_INT, 1, js.ctx, arrayObj, arrayLen);;
-    if (!sbuffer.Valid())
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    MakeContextCurrent();
-    gl->fDeleteRenderbuffers(arrayLen, (GLuint*) sbuffer.data);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::DeleteTextures()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 1)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    JSObject *arrayObj;
-    jsuint arrayLen;
-    if (!NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[0], &arrayObj, &arrayLen))
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (arrayLen == 0)
-        return NS_OK;
-
-    SimpleBuffer sbuffer(GL_UNSIGNED_INT, 1, js.ctx, arrayObj, arrayLen);
-    if (!sbuffer.Valid())
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    MakeContextCurrent();
-    gl->fDeleteTextures(arrayLen, (GLuint*) sbuffer.data);
-
-    return NS_OK;
-}
-
-GL_SAME_METHOD_1(DeleteProgram, DeleteProgram, PRUint32)
-
-GL_SAME_METHOD_1(DeleteShader, DeleteShader, PRUint32)
-
-GL_SAME_METHOD_2(DetachShader, DetachShader, PRUint32, PRUint32)
-
-GL_SAME_METHOD_1(DepthFunc, DepthFunc, PRUint32)
-
-GL_SAME_METHOD_1(DepthMask, DepthMask, PRBool)
-
-GL_SAME_METHOD_2(DepthRange, DepthRange, float, float)
-
-GL_SAME_METHOD_1(Disable, Disable, PRUint32)
-
-GL_SAME_METHOD_1(DisableVertexAttribArray, DisableVertexAttribArray, PRUint32)
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::DrawArrays(PRUint32 mode, PRUint32 offset, PRUint32 count)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    switch (mode) {
-        case GL_TRIANGLES:
-        case GL_TRIANGLE_STRIP:
-        case GL_TRIANGLE_FAN:
-        case GL_POINTS:
-        case GL_LINE_STRIP:
-        case GL_LINE_LOOP:
-        case GL_LINES:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("drawArrays: invalid mode"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if (offset+count < offset || offset+count < count) {
-        LogMessage(NS_LITERAL_CSTRING("drawArrays: overflow in offset+count"));
-        return NS_ERROR_INVALID_ARG;
-    }
-
-    if (!ValidateBuffers(offset+count))
-        return NS_ERROR_INVALID_ARG;
-
-    MakeContextCurrent();
-    gl->fDrawArrays(mode, offset, count);
-    return NS_OK;
-}
-
-// DrawElements
-/*in PRUint32 mode, in PRUint32 count, in PRUint32 type, in PRUint32[] indices*/
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::DrawElements()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 4)
-        return NS_ERROR_INVALID_ARG;
-
-    JSObject *arrayObj = NULL;
-    jsuint arrayLen = 0;
-    jsuint mode, count, type;
-    jsuint bufferOffset;
-
-    if (!::JS_ValueToECMAUint32(js.ctx, js.argv[0], &mode) ||
-        !::JS_ValueToECMAUint32(js.ctx, js.argv[1], &count) ||
-        !::JS_ValueToECMAUint32(js.ctx, js.argv[2], &type))
-    {
-        LogMessagef(("drawElements: invalid arguments"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    switch (mode) {
-        case GL_TRIANGLES:
-        case GL_TRIANGLE_STRIP:
-        case GL_TRIANGLE_FAN:
-        case GL_POINTS:
-        case GL_LINE_STRIP:
-        case GL_LINE_LOOP:
-        case GL_LINES:
-            break;
-        default:
-            LogMessagef(("drawElements: invalid mode"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    switch (type) {
-        case GL_UNSIGNED_SHORT:
-            break;
-        default:
-            LogMessagef(("drawElements: type must be UNSIGNED_SHORT"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    MakeContextCurrent();
-
-    if (NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[3], &arrayObj, &arrayLen)) {
-        // We were given an actual array
-        if (count > arrayLen) {
-            LogMessagef(("drawElements: count > arrayLen"));
-            return NS_ERROR_INVALID_ARG;
-        }
-
-        SimpleBuffer sbuffer(type, 1, js.ctx, arrayObj, arrayLen);
-        if (!sbuffer.Valid())
-            return NS_ERROR_FAILURE;
-
-        // calculate the biggest index present in the index array, for validation
-        GLushort max = 0;
-        for (jsuint i = 0; i < arrayLen; ++i) {
-            GLushort d = ((GLushort*)sbuffer.data)[i];
-            if (d > max)
-                max = d;
-        }
-
-        if (!ValidateBuffers(max))
-            return NS_ERROR_INVALID_ARG;
-
-        gl->fDrawElements(mode, count, type, sbuffer.data);
-    } else {
-        // We were given an integer offset into the currently bound VBO
-        GLint array_buf = 0;
-        gl->fGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &array_buf);
-
-        if (array_buf <= 0 ||
-            !::JS_ValueToECMAUint32(js.ctx, js.argv[3], &bufferOffset))
-        {
-            LogMessagef(("drawElements: invalid buffer argument"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-        }
-
-        int sz = 2;
-        GLint len = 0;
-        if ((GLushort)array_buf >= mBuffers.Length() || !mBuffers[array_buf]) {
-            LogMessagef(("drawElements: no mBuffers[array_buf]"));
-            return NS_ERROR_INVALID_ARG;
-        }
-
-        gl->fGetBufferParameteriv(GL_ELEMENT_ARRAY_BUFFER, GL_BUFFER_SIZE, &len);
-        if (len < 0 || (bufferOffset+count)*sz > (GLuint)len) {
-            LogMessagef(("drawElements: bufferOffset+count > buffer size"));
-            return NS_ERROR_INVALID_ARG;
-        }
-
-        GLushort max = mBuffers[array_buf]->MaxUShortValue();
-
-        if (!ValidateBuffers(max))
-            return NS_ERROR_INVALID_ARG;
-
-        gl->fDrawElements(mode, count, type, (GLvoid*)bufferOffset);
-    }
-
-    return NS_OK;
-}
-
-GL_SAME_METHOD_1(Enable, Enable, PRUint32)
-
-GL_SAME_METHOD_1(EnableVertexAttribArray, EnableVertexAttribArray, PRUint32)
-
-GL_SAME_METHOD_4(FramebufferRenderbuffer, FramebufferRenderbuffer, PRUint32, PRUint32, PRUint32, PRUint32)
-
-GL_SAME_METHOD_5(FramebufferTexture2D, FramebufferTexture2D, PRUint32, PRUint32, PRUint32, PRUint32, PRInt32)
-
-GL_SAME_METHOD_0(Flush, Flush)
-
-GL_SAME_METHOD_0(Finish, Finish)
-
-GL_SAME_METHOD_1(FrontFace, FrontFace, PRUint32)
-
-GL_SAME_METHOD_1(GenerateMipmap, GenerateMipmap, PRUint32)
-
-// returns an object: { size: ..., type: ..., name: ... }
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetActiveAttrib(PRUint32 program, PRUint32 index)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    GLint len = 0;
-    gl->fGetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
-    if (len == 0)
-        return NS_ERROR_FAILURE;
-
-    nsAutoArrayPtr<char> name(new char[len+1]);
-    PRInt32 attrsize = 0;
-    PRUint32 attrtype = 0;
-
-    gl->fGetActiveAttrib(program, index, len+1, &len, (GLint*) &attrsize, (GLuint*) &attrtype, name);
-    if (attrsize == 0 || attrtype == 0)
-        return NS_ERROR_FAILURE;
-
-    JSObjectHelper retobj(&js);
-    retobj.DefineProperty("size", attrsize);
-    retobj.DefineProperty("type", attrtype);
-    retobj.DefineProperty("name", name, len);
-
-    js.SetRetVal(retobj);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetActiveUniform(PRUint32 program, PRUint32 index)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    GLint len = 0;
-    gl->fGetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
-    if (len == 0)
-        return NS_ERROR_FAILURE;
-
-    nsAutoArrayPtr<char> name(new char[len+1]);
-    PRInt32 attrsize = 0;
-    PRUint32 attrtype = 0;
-
-    gl->fGetActiveUniform(program, index, len+1, &len, (GLint*) &attrsize, (GLenum*) &attrtype, name);
-    if (attrsize == 0 || attrtype == 0)
-        return NS_ERROR_FAILURE;
-
-    JSObjectHelper retobj(&js);
-    retobj.DefineProperty("size", attrsize);
-    retobj.DefineProperty("type", attrtype);
-    retobj.DefineProperty("name", name, len);
-
-    js.SetRetVal(retobj.Object());
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetAttachedShaders(PRUint32 program)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    GLint count = 0;
-    gl->fGetProgramiv(program, GL_ATTACHED_SHADERS, &count);
-    if (count == 0) {
-        JSObject *empty = JS_NewArrayObject(js.ctx, 0, NULL);
-        js.SetRetVal(empty);
-        return NS_OK;
-    }
-
-    nsAutoArrayPtr<PRUint32> shaders(new PRUint32[count]);
-
-    gl->fGetAttachedShaders(program, count, NULL, (GLuint*) shaders.get());
-
-    JSObject *obj = NativeJSContext::ArrayToJSArray(js.ctx, shaders, count);
-
-    js.AddGCRoot(obj, "GetAttachedShaders");
-    js.SetRetVal(obj);
-    js.ReleaseGCRoot(obj);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetAttribLocation(PRUint32 program,
-                                                   const char *name,
-                                                   PRInt32 *retval)
-{
-    if (!name) return NS_ERROR_INVALID_ARG;
-    MakeContextCurrent();
-    *retval = gl->fGetAttribLocation(program, name);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetParameter(PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (pname) {
-        //
-        // String params
-        //
-
-        // XXX do we want to fake these?  Could be a problem to reveal this to web content
-        case GL_VENDOR:
-        case GL_RENDERER:
-        case GL_VERSION:
-        case GL_SHADING_LANGUAGE_VERSION:
-        //case GL_EXTENSIONS:  // Not going to expose this
-
-            break;
-
-        //
-        // Single-value params
-        //
-
-// int
-        case GL_ARRAY_BUFFER_BINDING:
-        case GL_ELEMENT_ARRAY_BUFFER_BINDING: // XXX really?
-        case GL_CULL_FACE_MODE:
-        case GL_FRONT_FACE:
-        case GL_TEXTURE_BINDING_2D:
-        case GL_TEXTURE_BINDING_CUBE_MAP:
-        case GL_ACTIVE_TEXTURE:
-        case GL_STENCIL_WRITEMASK:
-        case GL_STENCIL_BACK_WRITEMASK:
-        case GL_DEPTH_CLEAR_VALUE:
-        case GL_STENCIL_CLEAR_VALUE:
-        case GL_STENCIL_FUNC:
-        case GL_STENCIL_VALUE_MASK:
-        case GL_STENCIL_REF:
-        case GL_STENCIL_FAIL:
-        case GL_STENCIL_PASS_DEPTH_FAIL:
-        case GL_STENCIL_PASS_DEPTH_PASS:
-        case GL_STENCIL_BACK_FUNC:
-        case GL_STENCIL_BACK_VALUE_MASK:
-        case GL_STENCIL_BACK_REF:
-        case GL_STENCIL_BACK_FAIL:
-        case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
-        case GL_STENCIL_BACK_PASS_DEPTH_PASS:
-        case GL_DEPTH_FUNC:
-        case GL_BLEND_SRC_RGB:
-        case GL_BLEND_SRC_ALPHA:
-        case GL_BLEND_DST_RGB:
-        case GL_BLEND_DST_ALPHA:
-        case GL_BLEND_EQUATION_RGB:
-        case GL_BLEND_EQUATION_ALPHA:
-        //case GL_UNPACK_ALIGNMENT: // not supported
-        //case GL_PACK_ALIGNMENT: // not supported
-        case GL_CURRENT_PROGRAM:
-        case GL_GENERATE_MIPMAP_HINT:
-        case GL_SUBPIXEL_BITS:
-        case GL_MAX_TEXTURE_SIZE:
-        case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
-        case GL_MAX_ELEMENTS_INDICES:
-        case GL_MAX_ELEMENTS_VERTICES:
-        case GL_SAMPLE_BUFFERS:
-        case GL_SAMPLES:
-        //case GL_COMPRESSED_TEXTURE_FORMATS:
-        //case GL_NUM_COMPRESSED_TEXTURE_FORMATS:
-        //case GL_SHADER_BINARY_FORMATS:
-        //case GL_NUM_SHADER_BINARY_FORMATS:
-        case GL_MAX_VERTEX_ATTRIBS:
-        case GL_MAX_VERTEX_UNIFORM_COMPONENTS:
-        case GL_MAX_VARYING_FLOATS:
-        case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
-        case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
-        case GL_MAX_TEXTURE_IMAGE_UNITS:
-        case GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
-        case GL_MAX_RENDERBUFFER_SIZE:
-        case GL_RED_BITS:
-        case GL_GREEN_BITS:
-        case GL_BLUE_BITS:
-        case GL_ALPHA_BITS:
-        case GL_DEPTH_BITS:
-        case GL_STENCIL_BITS:
-        //case GL_IMPLEMENTATION_COLOR_READ_TYPE:
-        //case GL_IMPLEMENTATION_COLOR_READ_FORMAT:
-        case GL_RENDERBUFFER_BINDING:
-        case GL_FRAMEBUFFER_BINDING:
-        {
-            PRInt32 iv = 0;
-            gl->fGetIntegerv(pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-// float
-        case GL_LINE_WIDTH:
-        case GL_POLYGON_OFFSET_FACTOR:
-        case GL_POLYGON_OFFSET_UNITS:
-        case GL_SAMPLE_COVERAGE_VALUE:
-        {
-            float fv = 0;
-            gl->fGetFloatv(pname, &fv);
-            js.SetRetVal((double) fv);
-        }
-            break;
-// bool
-        case GL_SAMPLE_COVERAGE_INVERT:
-        case GL_COLOR_WRITEMASK:
-        case GL_DEPTH_WRITEMASK:
-        ////case GL_SHADER_COMPILER: // pretty much must be true 
-        {
-            GLboolean bv = 0;
-            gl->fGetBooleanv(pname, &bv);
-            js.SetBoolRetVal(bv);
-        }
-            break;
-
-        //
-        // Complex values
-        //
-        case GL_DEPTH_RANGE: // 2 floats
-        case GL_ALIASED_POINT_SIZE_RANGE: // 2 floats
-        case GL_ALIASED_LINE_WIDTH_RANGE: // 2 floats
-        {
-            float fv[2] = { 0 };
-            gl->fGetFloatv(pname, &fv[0]);
-            js.SetRetVal(fv, 2);
-        }
-            break;
-        
-        case GL_COLOR_CLEAR_VALUE: // 4 floats
-        case GL_BLEND_COLOR: // 4 floats
-        {
-            float fv[4] = { 0 };
-            gl->fGetFloatv(pname, &fv[0]);
-            js.SetRetVal(fv, 4);
-        }
-            break;
-
-        case GL_MAX_VIEWPORT_DIMS: // 2 ints
-        {
-            PRInt32 iv[2] = { 0 };
-            gl->fGetIntegerv(pname, (GLint*) &iv[0]);
-            js.SetRetVal(iv, 2);
-        }
-            break;
-
-        case GL_SCISSOR_BOX: // 4 ints
-        case GL_VIEWPORT: // 4 ints
-        {
-            PRInt32 iv[4] = { 0 };
-            gl->fGetIntegerv(pname, (GLint*) &iv[0]);
-            js.SetRetVal(iv, 4);
-        }
-            break;
-
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetBufferParameter(PRUint32 target, PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (pname) {
-        case GL_BUFFER_SIZE:
-        case GL_BUFFER_USAGE:
-        case GL_BUFFER_ACCESS:
-        case GL_BUFFER_MAPPED:
-        {
-            PRInt32 iv = 0;
-            gl->fGetBufferParameteriv(target, pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetFramebufferAttachmentParameter(PRUint32 target, PRUint32 attachment, PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (attachment) {
-        case GL_COLOR_ATTACHMENT0:
-        case GL_DEPTH_ATTACHMENT:
-        case GL_STENCIL_ATTACHMENT:
-            break;
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    switch (pname) {
-        case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
-        case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
-        case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
-        case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
-        {
-            PRInt32 iv = 0;
-            gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetRenderbufferParameter(PRUint32 target, PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (pname) {
-        case GL_RENDERBUFFER_WIDTH_EXT:
-        case GL_RENDERBUFFER_HEIGHT_EXT:
-        case GL_RENDERBUFFER_INTERNAL_FORMAT_EXT:
-        case GL_RENDERBUFFER_RED_SIZE_EXT:
-        case GL_RENDERBUFFER_GREEN_SIZE_EXT:
-        case GL_RENDERBUFFER_BLUE_SIZE_EXT:
-        case GL_RENDERBUFFER_ALPHA_SIZE_EXT:
-        case GL_RENDERBUFFER_DEPTH_SIZE_EXT:
-        case GL_RENDERBUFFER_STENCIL_SIZE_EXT:
-        {
-            PRInt32 iv = 0;
-            gl->fGetRenderbufferParameteriv(target, pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GenBuffers(PRUint32 n)
-{
-    if (n == 0) return NS_OK;
-    if (n > 0xffffu) return NS_ERROR_INVALID_ARG;
-
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    nsAutoTArray<PRUint32, 16> ids;
-    ids.SetCapacity(n);
-
-    MakeContextCurrent();
-    gl->fGenBuffers(n, (GLuint*) ids.Elements());
-
-    js.SetRetVal(ids.Elements(), n);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GenTextures(PRUint32 n)
-{
-    if (n == 0) return NS_OK;
-    if (n > 0xffffu) return NS_ERROR_INVALID_ARG;
-
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    nsAutoTArray<PRUint32, 16> ids;
-    ids.SetCapacity(n);
-
-    MakeContextCurrent();
-    gl->fGenTextures(n, (GLuint*) ids.Elements());
-
-    js.SetRetVal(ids.Elements(), n);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetError(PRUint32 *_retval)
-{
-    MakeContextCurrent();
-    *_retval = gl->fGetError();
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetProgramParameter(PRUint32 program, PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (pname) {
-        case GL_CURRENT_PROGRAM:
-        case GL_DELETE_STATUS:
-        case GL_LINK_STATUS:
-        case GL_VALIDATE_STATUS:
-        case GL_ATTACHED_SHADERS:
-        case GL_INFO_LOG_LENGTH:
-        case GL_ACTIVE_UNIFORMS:
-        case GL_ACTIVE_UNIFORM_MAX_LENGTH:
-        case GL_ACTIVE_ATTRIBUTES:
-        case GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
-        {
-            PRInt32 iv = 0;
-            gl->fGetProgramiv(program, pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetProgramInfoLog(PRUint32 program, char **retval)
-{
-    MakeContextCurrent();
-
-    PRInt32 k = -1;
-    gl->fGetProgramiv(program, GL_INFO_LOG_LENGTH, (GLint*) &k);
-    if (k == -1)
-        return NS_ERROR_FAILURE;
-
-    if (k == 0) {
-        *retval = nsnull;
-        return NS_OK;
-    }
-
-    char *s = (char *) PR_Malloc(k);
-    if (!s)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    gl->fGetProgramInfoLog(program, k, (GLint*) &k, s);
-
-    *retval = s;
-    return NS_OK;
-}
-
-/* void texParameter (); */
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::TexParameter()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 3)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    jsuint targetVal;
-    jsuint pnameVal;
-    if (!::JS_ValueToECMAUint32(js.ctx, js.argv[0], &targetVal) ||
-        !::JS_ValueToECMAUint32(js.ctx, js.argv[1], &pnameVal))
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (targetVal != GL_TEXTURE_2D &&
-        targetVal != GL_TEXTURE_CUBE_MAP)
-    {
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    MakeContextCurrent();
-    switch (pnameVal) {
-        case GL_TEXTURE_MIN_FILTER: {
-            jsuint ival;
-            if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
-                (ival != GL_NEAREST &&
-                 ival != GL_LINEAR &&
-                 ival != GL_NEAREST_MIPMAP_NEAREST &&
-                 ival != GL_LINEAR_MIPMAP_NEAREST &&
-                 ival != GL_NEAREST_MIPMAP_LINEAR &&
-                 ival != GL_LINEAR_MIPMAP_LINEAR))
-                return NS_ERROR_DOM_SYNTAX_ERR;
-            gl->fTexParameteri (targetVal, pnameVal, ival);
-        }
-            break;
-        case GL_TEXTURE_MAG_FILTER: {
-            jsuint ival;
-            if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
-                (ival != GL_NEAREST &&
-                 ival != GL_LINEAR))
-                return NS_ERROR_DOM_SYNTAX_ERR;
-            gl->fTexParameteri (targetVal, pnameVal, ival);
-        }
-            break;
-        case GL_TEXTURE_WRAP_S:
-        case GL_TEXTURE_WRAP_T: {
-            jsuint ival;
-            if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
-                (ival != GL_CLAMP &&
-                 ival != GL_CLAMP_TO_EDGE &&
-                 ival != GL_REPEAT))
-                return NS_ERROR_DOM_SYNTAX_ERR;
-            gl->fTexParameteri (targetVal, pnameVal, ival);
-        }
-            break;
-        case GL_GENERATE_MIPMAP: {
-            jsuint ival;
-            if (js.argv[2] == JSVAL_TRUE)
-                ival = 1;
-            else if (js.argv[2] == JSVAL_FALSE)
-                ival = 0;
-            else if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
-                     (ival != 0 && ival != 1))
-                return NS_ERROR_DOM_SYNTAX_ERR;
-            gl->fTexParameteri (targetVal, pnameVal, ival);
-        }
-            break;
-        case GL_TEXTURE_MAX_ANISOTROPY_EXT: {
-#if 0
-            if (GLEW_EXT_texture_filter_anisotropic) {
-                jsdouble dval;
-                if (!::JS_ValueToNumber(js.ctx, js.argv[2], &dval))
-                    return NS_ERROR_DOM_SYNTAX_ERR;
-                gl->fTexParameterf (targetVal, pnameVal, (float) dval);
-            } else {
-                return NS_ERROR_NOT_IMPLEMENTED;
-            }
-#else
-            return NS_ERROR_NOT_IMPLEMENTED;
-#endif
-        }
-            break;
-        default:
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    return NS_OK;
-}
-
-/* void getTexParameter (); */
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetTexParameter(PRUint32 target, PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (pname) {
-        case GL_TEXTURE_MIN_FILTER:
-        case GL_TEXTURE_MAG_FILTER:
-        case GL_TEXTURE_WRAP_S:
-        case GL_TEXTURE_WRAP_T:
-        {
-            PRInt32 iv = 0;
-            gl->fGetTexParameteriv(target, pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetUniform(PRUint32 program, PRUint32 location)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    GLint uArraySize = 0;
-    GLenum uType = 0;
-
-    fprintf (stderr, "GetUniform: program: %d location: %d\n", program, location);
-    gl->fGetActiveUniform(program, location, 0, NULL, &uArraySize, &uType, NULL);
-    if (uArraySize == 0)
-        return NS_ERROR_FAILURE;
-
-    // glGetUniform needs to be called for each element of an array separately, so we don't
-    // have to deal with uArraySize at all.
-
-    GLenum baseType;
-    GLint unitSize;
-    if (!BaseTypeAndSizeFromUniformType(uType, &baseType, &unitSize))
-        return NS_ERROR_FAILURE;
-
-    // this should never happen
-    if (unitSize > 16)
-        return NS_ERROR_FAILURE;
-
-    if (baseType == GL_FLOAT) {
-        GLfloat fv[16];
-        gl->fGetUniformfv(program, location, fv);
-        js.SetRetVal(fv, unitSize);
-    } else if (baseType == GL_INT) {
-        GLint iv[16];
-        gl->fGetUniformiv(program, location, iv);
-        js.SetRetVal((PRInt32*)iv, unitSize);
-    } else {
-        js.SetRetValAsJSVal(JSVAL_NULL);
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetUniformLocation(PRUint32 program, const char *name, PRInt32 *retval)
-{
-    if (!name)
-        return NS_ERROR_INVALID_ARG;
-
-    MakeContextCurrent();
-    *retval = gl->fGetUniformLocation(program, name);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetVertexAttrib(PRUint32 index, PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (pname) {
-        // int
-        case GL_VERTEX_ATTRIB_ARRAY_SIZE:
-        case GL_VERTEX_ATTRIB_ARRAY_STRIDE:
-        case GL_VERTEX_ATTRIB_ARRAY_TYPE:
-        case GL_VERTEX_ATTRIB_ARRAY_ENABLED:
-        case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
-        case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
-        {
-            PRInt32 iv = 0;
-            gl->fGetVertexAttribiv(index, pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-        case GL_CURRENT_VERTEX_ATTRIB:
-        {
-            GLfloat fv[4] = { 0 };
-            gl->fGetVertexAttribfv(index, GL_CURRENT_VERTEX_ATTRIB, &fv[0]);
-            js.SetRetVal(fv, 4);
-        }
-            break;
-
-        // not supported; doesn't make sense to return a pointer unless we have some kind of buffer object abstraction
-        case GL_VERTEX_ATTRIB_ARRAY_POINTER:
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::Hint(PRUint32 target, PRUint32 mode)
-{
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::IsBuffer(PRUint32 k, PRBool *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fIsBuffer(k);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::IsFramebuffer(PRUint32 k, PRBool *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fIsFramebuffer(k);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::IsEnabled(PRUint32 k, PRBool *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fIsEnabled(k);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::IsProgram(PRUint32 k, PRBool *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fIsProgram(k);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::IsRenderbuffer(PRUint32 k, PRBool *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fIsRenderbuffer(k);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::IsShader(PRUint32 k, PRBool *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fIsShader(k);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::IsTexture(PRUint32 k, PRBool *retval)
-{
-    MakeContextCurrent();
-    *retval = gl->fIsTexture(k);
-    return NS_OK;
-}
-
-GL_SAME_METHOD_1(LineWidth, LineWidth, float)
-
-GL_SAME_METHOD_1(LinkProgram, LinkProgram, PRUint32)
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::PixelStore(PRUint32 pname, PRInt32 param)
-{
-    if (pname != GL_PACK_ALIGNMENT &&
-        pname != GL_UNPACK_ALIGNMENT)
-        return NS_ERROR_INVALID_ARG;
-
-    MakeContextCurrent();
-    gl->fPixelStorei(pname, param);
-
-    return NS_OK;
-}
-
-GL_SAME_METHOD_2(PolygonOffset, PolygonOffset, float, float)
-
-PRBool
-IsCallerTrustedForRead()
-{
-  // FIXME this is a copy of nsContentUtils::IsCallerTrustedForRead
-  // Figure out how to #include "nsContentUtils.h" and use that instead.
-
-  // The secman really should handle UniversalXPConnect case, since that
-  // should include UniversalBrowserRead... doesn't right now, though.
-  PRBool hasCap;
-  nsIScriptSecurityManager *sSecurityManager;
-  nsresult rv = CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID,
-                               &sSecurityManager);
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (NS_FAILED(sSecurityManager->IsCapabilityEnabled("UniversalBrowserRead", &hasCap)))
-    return PR_FALSE;
-  if (hasCap)
-    return PR_TRUE;
-
-  if (NS_FAILED(sSecurityManager->IsCapabilityEnabled("UniversalXPConnect",
-                                                      &hasCap)))
-    return PR_FALSE;
-  return hasCap;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::ReadPixels(PRUint32 x, PRUint32 y, PRUint32 width, PRUint32 height, PRUint32 format, PRUint32 type)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (mCanvasElement->IsWriteOnly() && !IsCallerTrustedForRead()) {
-        LogMessage(NS_LITERAL_CSTRING("readPixels: Not allowed"));
-        return NS_ERROR_DOM_SECURITY_ERR;
-    }
-
-    MakeContextCurrent();
-
-    if (!CanvasUtils::CheckSaneSubrectSize(x,y,width,height, mWidth, mHeight)) {
-        LogMessage(NS_LITERAL_CSTRING("readPixels: rectangle outside canvas"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    PRUint32 size = 0;
-    switch (format) {
-      case GL_ALPHA:
-        size = 1;
-        break;
-      case GL_RGB:
-        size = 3;
-        break;
-      case GL_RGBA:
-        size = 4;
-        break;
-      default:
-        LogMessage(NS_LITERAL_CSTRING("readPixels: unsupported pixel format"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-    switch (type) {
-//         case GL_UNSIGNED_SHORT_4_4_4_4:
-//         case GL_UNSIGNED_SHORT_5_5_5_1:
-//         case GL_UNSIGNED_SHORT_5_6_5:
-      case GL_UNSIGNED_BYTE:
-        break;
-      default:
-        LogMessage(NS_LITERAL_CSTRING("readPixels: unsupported pixel type"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    PRUint32 len = width*height*size;
-
-    nsAutoArrayPtr<PRUint8> data(new PRUint8[len]);
-    gl->fReadPixels((GLint)x, (GLint)y, width, height, format, type, (GLvoid *)data.get());
-
-    nsAutoArrayPtr<jsval> jsvector(new jsval[len]);
-    for (PRUint32 i = 0; i < len; i++)
-        jsvector[i] = INT_TO_JSVAL(data[i]);
-
-    JSObject *dataArray = JS_NewArrayObject(js.ctx, len, jsvector);
-    if (!dataArray)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    JSObjectHelper retobj(&js);
-    retobj.DefineProperty("width", width);
-    retobj.DefineProperty("height", height);
-    retobj.DefineProperty("data", dataArray);
-
-    js.SetRetVal(retobj);
-
-    return NS_OK;
-}
-
-GL_SAME_METHOD_4(RenderbufferStorage, RenderbufferStorage, PRUint32, PRUint32, PRUint32, PRUint32)
-
-GL_SAME_METHOD_2(SampleCoverage, SampleCoverage, float, PRBool)
-
-GL_SAME_METHOD_4(Scissor, Scissor, PRInt32, PRInt32, PRInt32, PRInt32)
-
-GL_SAME_METHOD_3(StencilFunc, StencilFunc, PRUint32, PRInt32, PRUint32)
-
-GL_SAME_METHOD_4(StencilFuncSeparate, StencilFuncSeparate, PRUint32, PRUint32, PRInt32, PRUint32)
-
-GL_SAME_METHOD_1(StencilMask, StencilMask, PRUint32)
-
-GL_SAME_METHOD_2(StencilMaskSeparate, StencilMaskSeparate, PRUint32, PRUint32)
-
-GL_SAME_METHOD_3(StencilOp, StencilOp, PRUint32, PRUint32, PRUint32)
-
-GL_SAME_METHOD_4(StencilOpSeparate, StencilOpSeparate, PRUint32, PRUint32, PRUint32, PRUint32)
-
-nsresult
-nsCanvasRenderingContextGLWeb20::TexImageElementBase(nsIDOMHTMLElement *imageOrCanvas,
-                                                     gfxImageSurface **imageOut)
-{
-    gfxImageSurface *surf = nsnull;
-
-    nsLayoutUtils::SurfaceFromElementResult res =
-        nsLayoutUtils::SurfaceFromElement(imageOrCanvas,
-                                          nsLayoutUtils::SFE_WANT_NEW_SURFACE | nsLayoutUtils::SFE_WANT_IMAGE_SURFACE);
-    if (!res.mSurface)
-        return NS_ERROR_FAILURE;
-
-    CanvasUtils::DoDrawImageSecurityCheck(mCanvasElement, res.mPrincipal, res.mIsWriteOnly);
-
-    if (res.mSurface->GetType() != gfxASurface::SurfaceTypeImage) {
-        // SurfaceFromElement lied!
-        return NS_ERROR_FAILURE;
-    }
-
-    surf = static_cast<gfxImageSurface*>(res.mSurface.get());
-
-    PRInt32 width, height;
-    width = res.mSize.width;
-    height = res.mSize.height;
-
-    if (width <= 0 || height <= 0)
-        return NS_ERROR_FAILURE;
-
-    if (surf->Format() == gfxASurface::ImageFormatARGB32) {
-        PRUint8* src = surf->Data();
-        PRUint8* dst = surf->Data();
-
-        // this wants some SSE love
-
-        for (int j = 0; j < height; j++) {
-            src = surf->Data() + j * surf->Stride();
-            // note that dst's stride is always tightly packed
-            for (int i = 0; i < width; i++) {
-#ifdef IS_LITTLE_ENDIAN
-                PRUint8 b = *src++;
-                PRUint8 g = *src++;
-                PRUint8 r = *src++;
-                PRUint8 a = *src++;
-#else
-                PRUint8 a = *src++;
-                PRUint8 r = *src++;
-                PRUint8 g = *src++;
-                PRUint8 b = *src++;
-#endif
-                // Convert to non-premultiplied color
-                if (a != 0) {
-                    r = (r * 255) / a;
-                    g = (g * 255) / a;
-                    b = (b * 255) / a;
-                }
-
-                *dst++ = r;
-                *dst++ = g;
-                *dst++ = b;
-                *dst++ = a;
-            }
-        }
-    } else if (surf->Format() == gfxASurface::ImageFormatRGB24) {
-        PRUint8* src = surf->Data();
-        PRUint8* dst = surf->Data();
-
-        // this wants some SSE love
-
-        for (int j = 0; j < height; j++) {
-            src = surf->Data() + j * surf->Stride();
-            // note that dst's stride is always tightly packed
-            for (int i = 0; i < width; i++) {
-#ifdef IS_LITTLE_ENDIAN
-                PRUint8 b = *src++;
-                PRUint8 g = *src++;
-                PRUint8 r = *src++;
-                src++;
-#else
-                src++;
-                PRUint8 r = *src++;
-                PRUint8 g = *src++;
-                PRUint8 b = *src++;
-#endif
-
-                *dst++ = r;
-                *dst++ = g;
-                *dst++ = b;
-                *dst++ = 255;
-            }
-        }
-    } else {
-        return NS_ERROR_FAILURE;
-    }
-
-    res.mSurface.forget();
-    *imageOut = surf;
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::TexSubImage2DHTML(PRUint32 target, PRUint32 level, PRInt32 x, PRInt32 y, nsIDOMHTMLElement *imageOrCanvas)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    switch (target) {
-        case GL_TEXTURE_2D:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texImage2DHTML: unsupported target"));
-            return NS_ERROR_INVALID_ARG;
-    }
-
-    nsRefPtr<gfxImageSurface> isurf;
-    nsresult rv;
-
-    rv = TexImageElementBase(imageOrCanvas,
-                             getter_AddRefs(isurf));
-    if (NS_FAILED(rv))
-        return rv;
-
-    MakeContextCurrent();
-
-    gl->fTexSubImage2D(target, level, x, y, isurf->Width(), isurf->Height(), GL_RGBA, GL_UNSIGNED_BYTE, isurf->Data());
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::TexImage2DHTML(PRUint32 target, PRUint32 level, nsIDOMHTMLElement *imageOrCanvas)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    switch (target) {
-        case GL_TEXTURE_2D:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texImage2DHTML: unsupported target"));
-            return NS_ERROR_INVALID_ARG;
-    }
-
-    nsRefPtr<gfxImageSurface> isurf;
-    nsresult rv;
-
-    rv = TexImageElementBase(imageOrCanvas,
-                             getter_AddRefs(isurf));
-    if (NS_FAILED(rv))
-        return rv;
-        
-    MakeContextCurrent();
-
-    gl->fTexImage2D(target, level, GL_RGBA, isurf->Width(), isurf->Height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, isurf->Data());
-
-    return NS_OK;
-}
-
-GL_SAME_METHOD_2(Uniform1i, Uniform1i, PRUint32, PRInt32)
-GL_SAME_METHOD_3(Uniform2i, Uniform2i, PRUint32, PRInt32, PRInt32)
-GL_SAME_METHOD_4(Uniform3i, Uniform3i, PRUint32, PRInt32, PRInt32, PRInt32)
-GL_SAME_METHOD_5(Uniform4i, Uniform4i, PRUint32, PRInt32, PRInt32, PRInt32, PRInt32)
-
-GL_SAME_METHOD_2(Uniform1f, Uniform1f, PRUint32, float)
-GL_SAME_METHOD_3(Uniform2f, Uniform2f, PRUint32, float, float)
-GL_SAME_METHOD_4(Uniform3f, Uniform3f, PRUint32, float, float, float)
-GL_SAME_METHOD_5(Uniform4f, Uniform4f, PRUint32, float, float, float, float)
-
-// one uint arg followed by an array of c elements of glTypeConst.
-#define GL_SIMPLE_ARRAY_METHOD(glname, name, c, glTypeConst, ptrType)   \
-NS_IMETHODIMP                                                           \
-NSGL_CONTEXT_NAME::name()                                               \
-{                                                                       \
-    NativeJSContext js;                                                 \
-    if (NS_FAILED(js.error))                                            \
-        return js.error;                                                \
-    jsuint index;                                                       \
-    JSObject *arrayObj;                                                 \
-    jsuint arrayLen;                                                    \
-    if (js.argc != 2 ||                                                 \
-        !::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index) ||          \
-        !NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[1], &arrayObj, &arrayLen)) \
-        return NS_ERROR_INVALID_ARG;                                    \
-    if (arrayLen % c != 0) {                                            \
-        LogMessage(NS_LITERAL_CSTRING(#name ": array length not divisible by " #c)); \
-        return NS_ERROR_INVALID_ARG;                                    \
-    }                                                                   \
-    SimpleBuffer sbuffer(glTypeConst, c, js.ctx, arrayObj, arrayLen);   \
-    if (!sbuffer.Valid())                                               \
-        return NS_ERROR_FAILURE;                                        \
-    MakeContextCurrent();                                               \
-    gl->f##glname(index, arrayLen / c, ( ptrType *)sbuffer.data);       \
-    return NS_OK;                                                       \
-}
-
-#define GL_SIMPLE_ARRAY_METHOD_NO_COUNT(glname, name, c, glTypeConst, ptrType) \
-NS_IMETHODIMP                                                           \
-NSGL_CONTEXT_NAME::name()                                               \
-{                                                                       \
-    NativeJSContext js;                                                 \
-    if (NS_FAILED(js.error))                                            \
-        return js.error;                                                \
-    jsuint index;                                                       \
-    JSObject *arrayObj;                                                 \
-    jsuint arrayLen;                                                    \
-    if (js.argc != 2 ||                                                 \
-        !::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index) ||          \
-        !NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[1], &arrayObj, &arrayLen)) \
-        return NS_ERROR_INVALID_ARG;                                    \
-    if (arrayLen != c) {                                                \
-        LogMessage(NS_LITERAL_CSTRING(#name ": array wrong size, expected " #c)); \
-        return NS_ERROR_INVALID_ARG;                                    \
-    }                                                                   \
-    SimpleBuffer sbuffer(glTypeConst, c, js.ctx, arrayObj, arrayLen);   \
-    if (!sbuffer.Valid())                                               \
-        return NS_ERROR_FAILURE;                                        \
-    MakeContextCurrent();                                               \
-    gl->f##glname(index, ( ptrType *)sbuffer.data);                     \
-    return NS_OK;                                                       \
-}
-
-#define GL_SIMPLE_MATRIX_METHOD(glname, name, c, glTypeConst, ptrType)  \
-NS_IMETHODIMP                                                           \
-NSGL_CONTEXT_NAME::name()                                               \
-{                                                                       \
-    NativeJSContext js;                                                 \
-    if (NS_FAILED(js.error))                                            \
-        return js.error;                                                \
-    jsuint index;                                                       \
-    JSObject *arrayObj;                                                 \
-    jsuint arrayLen;                                                    \
-    if (js.argc != 2 ||                                                 \
-        !::JS_ValueToECMAUint32(js.ctx, js.argv[0], &index) ||          \
-        !NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[1], &arrayObj, &arrayLen)) \
-        return NS_ERROR_INVALID_ARG;                                    \
-    if (arrayLen != c) {                                                \
-        LogMessage(NS_LITERAL_CSTRING(#name ": array wrong size, expected " #c)); \
-        return NS_ERROR_INVALID_ARG;                                    \
-    }                                                                   \
-    SimpleBuffer sbuffer(glTypeConst, c, js.ctx, arrayObj, arrayLen);   \
-    if (!sbuffer.Valid())                                               \
-        return NS_ERROR_FAILURE;                                        \
-    MakeContextCurrent();                                               \
-    gl->f##glname(index, arrayLen / c, GL_FALSE, ( ptrType *)sbuffer.data); \
-    return NS_OK;                                                       \
-}
-
-GL_SIMPLE_ARRAY_METHOD(Uniform1iv, Uniform1iv, 1, GL_INT, GLint)
-GL_SIMPLE_ARRAY_METHOD(Uniform2iv, Uniform2iv, 2, GL_INT, GLint)
-GL_SIMPLE_ARRAY_METHOD(Uniform3iv, Uniform3iv, 3, GL_INT, GLint)
-GL_SIMPLE_ARRAY_METHOD(Uniform4iv, Uniform4iv, 4, GL_INT, GLint)
-
-GL_SIMPLE_ARRAY_METHOD(Uniform1fv, Uniform1fv, 1, GL_FLOAT, GLfloat)
-GL_SIMPLE_ARRAY_METHOD(Uniform2fv, Uniform2fv, 2, GL_FLOAT, GLfloat)
-GL_SIMPLE_ARRAY_METHOD(Uniform3fv, Uniform3fv, 3, GL_FLOAT, GLfloat)
-GL_SIMPLE_ARRAY_METHOD(Uniform4fv, Uniform4fv, 4, GL_FLOAT, GLfloat)
-
-GL_SIMPLE_MATRIX_METHOD(UniformMatrix2fv, UniformMatrix2fv, 4, GL_FLOAT, GLfloat)
-GL_SIMPLE_MATRIX_METHOD(UniformMatrix3fv, UniformMatrix3fv, 9, GL_FLOAT, GLfloat)
-GL_SIMPLE_MATRIX_METHOD(UniformMatrix4fv, UniformMatrix4fv, 16, GL_FLOAT, GLfloat)
-
-GL_SAME_METHOD_1(UseProgram, UseProgram, PRUint32)
-
-GL_SAME_METHOD_1(ValidateProgram, ValidateProgram, PRUint32)
-
-GL_SAME_METHOD_2(VertexAttrib1f, VertexAttrib1f, PRUint32, float)
-GL_SAME_METHOD_3(VertexAttrib2f, VertexAttrib2f, PRUint32, float, float)
-GL_SAME_METHOD_4(VertexAttrib3f, VertexAttrib3f, PRUint32, float, float, float)
-GL_SAME_METHOD_5(VertexAttrib4f, VertexAttrib4f, PRUint32, float, float, float, float)
-
-GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib1fv, VertexAttrib1fv, 1, GL_FLOAT, GLfloat)
-GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib2fv, VertexAttrib2fv, 2, GL_FLOAT, GLfloat)
-GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib3fv, VertexAttrib3fv, 3, GL_FLOAT, GLfloat)
-GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib4fv, VertexAttrib4fv, 4, GL_FLOAT, GLfloat)
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GenFramebuffers(PRUint32 n)
-{
-    if (n == 0) return NS_OK;
-    if (n > 0xffffu) return NS_ERROR_INVALID_ARG;
-
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    nsAutoTArray<PRUint32, 16> ids;
-    ids.SetCapacity(n);
-
-    MakeContextCurrent();
-    gl->fGenFramebuffers(n, (GLuint*) ids.Elements());
-
-    js.SetRetVal(ids.Elements(), n);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GenRenderbuffers(PRUint32 n)
-{
-    if (n == 0) return NS_OK;
-    if (n > 0xffffu) return NS_ERROR_INVALID_ARG;
-
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    nsAutoTArray<PRUint32, 16> ids;
-    ids.SetCapacity(n);
-
-    MakeContextCurrent();
-    gl->fGenRenderbuffers(n, (GLuint*) ids.Elements());
-
-    js.SetRetVal(ids.Elements(), n);
-
-    return NS_OK;
-}
-
-GL_SAME_METHOD_4(Viewport, Viewport, PRInt32, PRInt32, PRInt32, PRInt32)
-
-GL_SAME_METHOD_1(CompileShader, CompileShader, PRUint32)
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetShaderParameter(PRUint32 shader, PRUint32 pname)
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    MakeContextCurrent();
-
-    switch (pname) {
-        case GL_SHADER_TYPE:
-        case GL_DELETE_STATUS:
-        case GL_COMPILE_STATUS:
-        case GL_INFO_LOG_LENGTH:
-        case GL_SHADER_SOURCE_LENGTH:
-        {
-            PRInt32 iv = 0;
-            gl->fGetShaderiv(shader, pname, (GLint*) &iv);
-            js.SetRetVal(iv);
-        }
-            break;
-
-        default:
-            return NS_ERROR_NOT_IMPLEMENTED;
-    }
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetShaderInfoLog(PRUint32 shader, char **retval)
-{
-    MakeContextCurrent();
-
-    PRInt32 k = -1;
-    gl->fGetShaderiv(shader, GL_INFO_LOG_LENGTH, (GLint*) &k);
-    if (k == -1)
-        return NS_ERROR_FAILURE;
-
-    if (k == 0) {
-        *retval = nsnull;
-        return NS_OK;
-    }
-
-    char *s = (char *) PR_Malloc(k);
-    if (!s)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    gl->fGetShaderInfoLog(shader, k, (GLint*) &k, s);
-
-    *retval = s;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetShaderSource(PRUint32 shader, char **retval)
-{
-    MakeContextCurrent();
-
-    GLint slen = -1;
-    gl->fGetShaderiv (shader, GL_SHADER_SOURCE_LENGTH, &slen);
-    if (slen == -1)
-        return NS_ERROR_FAILURE;
-
-    if (slen == 0) {
-        *retval = nsnull;
-        return NS_OK;
-    }
-
-    char *src = (char *) nsMemory::Alloc(slen + 1);
-
-    gl->fGetShaderSource (shader, slen, NULL, src);
-
-    *retval = src;
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::ShaderSource(PRUint32 shader, const char *source)
-{
-    if (!source)
-        return NS_ERROR_INVALID_ARG;
-
-    MakeContextCurrent();
-
-    gl->fShaderSource(shader, 1, &source, NULL);
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::SwapBuffers()
-{
-    return DoSwapBuffers();
-}
-
-/*in PRUint32 index, in PRInt32 size, in PRUint32 type, in PRBool normalized, in PRUint32 stride, in Object[] array*/
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::VertexAttribPointer()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    nsRefPtr<CanvasGLBuffer> newBuffer;
-    nsresult rv;
-
-    if (js.argc != 6)
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    jsuint vertexAttribIndex;
-    jsuint sizeParam;
-    jsuint typeParam;
-    JSBool normalizedParam;
-    jsuint strideParam;
-    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuubu",
-                               &vertexAttribIndex, &sizeParam, &typeParam,
-                               &normalizedParam, &strideParam))
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    if (vertexAttribIndex >= mAttribBuffers.Length())
-        return NS_ERROR_INVALID_ARG;
-
-    if (typeParam != GL_SHORT && typeParam != GL_FLOAT) {
-        LogMessage(NS_LITERAL_CSTRING("vertexAttribPointer: invalid element type"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if (sizeParam < 1 || sizeParam > 4) {
-        LogMessage(NS_LITERAL_CSTRING("vertexAttribPointer: invalid element size"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if (strideParam != 0) {
-        LogMessage(NS_LITERAL_CSTRING("vertexAttribPointer: stride must be 0 for now"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    MakeContextCurrent();
-
-    GLint array_buf = 0;
-    gl->fGetIntegerv(GL_ARRAY_BUFFER_BINDING, &array_buf);
-
-    // Are we being given a literal array, or are we being asked
-    // to use the currently bound VBO?  If we're being asked to use a VBO,
-    // then the 6th arg is an offset and not an array.
-    JSObject *arrayObj;
-    jsuint arrayLen;
-    if (NativeJSContext::JSValToJSArrayAndLength(js.ctx, js.argv[5], &arrayObj, &arrayLen)) {
-        // if we were given an array, we must not have a buffer binding
-        if (array_buf != 0) {
-            LogMessage(NS_LITERAL_CSTRING("vertexAttribPointer: called with array arg while ARRAY_BUFFER_BINDING != 0!"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-        }
-
-        newBuffer = new CanvasGLBuffer(this);
-        if (!newBuffer)
-            return NS_ERROR_OUT_OF_MEMORY;
-
-        rv = newBuffer->Init (GL_STATIC_DRAW, sizeParam, typeParam, js.ctx, arrayObj, arrayLen);
-        if (NS_FAILED(rv))
-            return rv;
-
-        mAttribBuffers[vertexAttribIndex] = newBuffer;
-
-        gl->fVertexAttribPointer(vertexAttribIndex,
-                                 newBuffer->GetSimpleBuffer().sizePerVertex,
-                                 newBuffer->GetSimpleBuffer().type,
-                                 normalizedParam ? GL_TRUE : GL_FALSE,
-                                 strideParam,
-                                 newBuffer->GetSimpleBuffer().data);
-    } else {
-        // grab the buffer offset
-        jsuint bufferOffset;
-        if (!::JS_ValueToECMAUint32(js.ctx, js.argv[3], &bufferOffset))
-            return NS_ERROR_INVALID_ARG;
-
-        int sz = (typeParam == GL_SHORT ? 2 : 4);
-
-        GLint len = 0;
-        gl->fGetBufferParameteriv(GL_ARRAY_BUFFER, GL_BUFFER_SIZE, &len);
-
-        if (len < 0 || bufferOffset*sz > (GLuint)len) {
-            LogMessage(NS_LITERAL_CSTRING("vertexAttribPointer: offset out of buffer bounds"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-        }
-
-        mAttribBuffers[vertexAttribIndex] = NULL;
-
-        gl->fVertexAttribPointer(vertexAttribIndex,
-                                 sizeParam,
-                                 typeParam,
-                                 normalizedParam ? GL_TRUE : GL_FALSE,
-                                 strideParam,
-                                 (GLvoid*)(bufferOffset*sz));
-    }
-
-    return NS_OK;
-}
-
-PRBool
-nsCanvasRenderingContextGLWeb20::ValidateGL()
-{
-    // make sure that the opengl stuff that we need is supported
-    GLint val = 0;
-    gl->fGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &val);
-    fprintf (stderr, "-- %d vertex buffers\n", (int)val);
-    mAttribBuffers.SetLength(val);
-    mBuffers.SetLength(256);
-
-    // gl_PointSize is always available in ES2 GLSL
-    gl->fEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
-
-    return PR_TRUE;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::TexSubImage2D()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 9) {
-        LogMessage(NS_LITERAL_CSTRING("texSubImage2D: expected 9 arguments"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    jsuint argTarget, argLevel, argX, argY, argWidth, argHeight, argFormat, argType;
-    JSObject *argPixelsObj;
-    jsuint argPixelsLen;
-    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuuuuuuuo",
-                               &argTarget, &argLevel, &argX, &argY,
-                               &argWidth, &argHeight, &argFormat, &argType,
-                               &argPixelsObj) ||
-        JSVAL_IS_NULL(argPixelsObj) ||
-        !::JS_IsArrayObject(js.ctx, argPixelsObj) ||
-        !::JS_GetArrayLength(js.ctx, argPixelsObj, &argPixelsLen))
-    {
-        LogMessage(NS_LITERAL_CSTRING("texSubImage2D: argument error"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    switch (argTarget) {
-        case GL_TEXTURE_2D:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texSubImage2D: unsupported target"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    PRUint32 bufferType, bufferSize;
-    switch (argFormat) {
-        case GL_RED:
-        case GL_GREEN:
-        case GL_BLUE:
-        case GL_ALPHA:
-        case GL_LUMINANCE:
-            bufferSize = 1;
-            break;
-        case GL_LUMINANCE_ALPHA:
-            bufferSize = 2;
-            break;
-        case GL_RGB:
-            bufferSize = 3;
-            break;
-        case GL_RGBA:
-            bufferSize = 4;
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texSubImage2D: pixel format not supported"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    switch (argType) {
-        case GL_SHORT:
-        case GL_UNSIGNED_SHORT:
-        case GL_BYTE:
-        case GL_UNSIGNED_BYTE:
-        case GL_INT:
-        case GL_UNSIGNED_INT:
-        case GL_FLOAT:
-            bufferType = argType;
-            break;
-        case GL_UNSIGNED_SHORT_4_4_4_4:
-        case GL_UNSIGNED_SHORT_5_5_5_1:
-        case GL_UNSIGNED_SHORT_5_6_5:
-            bufferType = GL_UNSIGNED_SHORT;
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texSubImage2D: pixel packing not supported"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    // make sure the size is valid
-    PRInt32 tmp = argWidth * argHeight;
-    if (tmp && tmp / argHeight != argWidth) {
-        LogMessage(NS_LITERAL_CSTRING("texSubImage2D: too large width or height"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    tmp = tmp * bufferSize;
-    if (tmp && tmp / bufferSize != (argWidth * argHeight)) {
-        LogMessage(NS_LITERAL_CSTRING("texSubImage2D: too large width or height (after multiplying with pixel size)"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if ((PRUint32) tmp > argPixelsLen) {
-        LogMessage(NS_LITERAL_CSTRING("texSubImage2D: array dimensions too small for width, height and pixel format"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    SimpleBuffer sbuffer(bufferType, bufferSize, js.ctx, argPixelsObj, argPixelsLen);
-    if (!sbuffer.Valid())
-        return NS_ERROR_FAILURE;
-
-    MakeContextCurrent();
-    gl->fTexSubImage2D (argTarget, argLevel, argX, argY, argWidth, argHeight, argFormat, argType, (void *) sbuffer.data);
-
-    return NS_OK;
-}
-
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::TexImage2D()
-{
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 9) {
-        LogMessage(NS_LITERAL_CSTRING("texImage2D: expected 9 arguments"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    jsuint argTarget, argLevel, argInternalFormat, argWidth, argHeight, argBorder, argFormat, argType;
-    JSObject *argPixelsObj;
-    jsuint argPixelsLen;
-    if (!::JS_ConvertArguments(js.ctx, js.argc, js.argv, "uuuuuuuuo",
-                               &argTarget, &argLevel, &argInternalFormat, &argWidth,
-                               &argHeight, &argBorder, &argFormat, &argType,
-                               &argPixelsObj) ||
-        (argPixelsObj != NULL && !JSVAL_IS_NULL(argPixelsObj) && (
-        !::JS_IsArrayObject(js.ctx, argPixelsObj) ||
-        !::JS_GetArrayLength(js.ctx, argPixelsObj, &argPixelsLen))))
-    {
-        LogMessage(NS_LITERAL_CSTRING("texImage2D: argument error"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if (argWidth == 0 || argHeight == 0) {
-        LogMessage(NS_LITERAL_CSTRING("texImage2D: width or height is zero"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    switch (argTarget) {
-        case GL_TEXTURE_2D:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
-        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
-        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texImage2D: unsupported target"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    if (argBorder != 0) {
-        LogMessage(NS_LITERAL_CSTRING("texImage2D: non-zero border given"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    switch (argInternalFormat) {
-        case GL_RGB:
-        case GL_RGBA:
-        case GL_ALPHA:
-        case GL_LUMINANCE:
-        case GL_LUMINANCE_ALPHA:
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texImage2D: internal format not supported"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    PRUint32 bufferType, bufferSize;
-    switch (argFormat) {
-        case GL_RED:
-        case GL_GREEN:
-        case GL_BLUE:
-        case GL_ALPHA:
-        case GL_LUMINANCE:
-            bufferSize = 1;
-            break;
-        case GL_LUMINANCE_ALPHA:
-            bufferSize = 2;
-            break;
-        case GL_RGB:
-            bufferSize = 3;
-            break;
-        case GL_RGBA:
-            bufferSize = 4;
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texImage2D: pixel format not supported"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    switch (argType) {
-        case GL_SHORT:
-        case GL_UNSIGNED_SHORT:
-        case GL_BYTE:
-        case GL_UNSIGNED_BYTE:
-        case GL_INT:
-        case GL_UNSIGNED_INT:
-        case GL_FLOAT:
-            bufferType = argType;
-            break;
-        case GL_UNSIGNED_SHORT_4_4_4_4:
-        case GL_UNSIGNED_SHORT_5_5_5_1:
-        case GL_UNSIGNED_SHORT_5_6_5:
-            bufferType = GL_UNSIGNED_SHORT;
-            break;
-        default:
-            LogMessage(NS_LITERAL_CSTRING("texImage2D: pixel packing not supported"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    // make sure the size is valid
-    PRInt32 tmp = argWidth * argHeight;
-    if (tmp && tmp / argHeight != argWidth) {
-        LogMessage(NS_LITERAL_CSTRING("texImage2D: too large width or height"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    tmp = tmp * bufferSize;
-    if (tmp && tmp / bufferSize != (argWidth * argHeight)) {
-        LogMessage(NS_LITERAL_CSTRING("texImage2D: too large width or height (after multiplying with pixel size)"));
-        return NS_ERROR_DOM_SYNTAX_ERR;
-    }
-
-    // XXX handle GL_UNPACK_ALIGNMENT !
-
-    if (argPixelsObj == NULL || JSVAL_IS_NULL(argPixelsObj)) {
-      MakeContextCurrent();
-      gl->fTexImage2D (argTarget, argLevel, argInternalFormat, argWidth, argHeight, argBorder, argFormat, argType, NULL);
-    } else {
-        if ((PRUint32) tmp > argPixelsLen) {
-            LogMessage(NS_LITERAL_CSTRING("texImage2D: array dimensions too small for width, height and pixel format"));
-            return NS_ERROR_DOM_SYNTAX_ERR;
-        }
-
-        SimpleBuffer sbuffer(bufferType, bufferSize, js.ctx, argPixelsObj, argPixelsLen);
-        if (!sbuffer.Valid())
-            return NS_ERROR_FAILURE;
-
-        MakeContextCurrent();
-        gl->fTexImage2D (argTarget, argLevel, argInternalFormat, argWidth, argHeight, argBorder, argFormat, argType, (void *) sbuffer.data);
-    }
-    return NS_OK;
-}
-
-PRBool
-nsCanvasRenderingContextGLWeb20::ValidateBuffers(PRUint32 count)
-{
-    GLint len = 0;
-    GLint enabled = 0, size = 4, type = GL_FLOAT, binding = 0;
-    PRBool someEnabled = PR_FALSE;
-    GLint currentProgram = -1;
-    GLint numAttributes = -1;
-
-    MakeContextCurrent();
-
-    gl->fGetIntegerv(GL_CURRENT_PROGRAM, &currentProgram);
-    if (currentProgram == -1) {
-        // what?
-        LogMessagef("glGetIntegerv GL_CURRENT_PROGRAM failed: 0x%08x", (uint) gl->fGetError());
-        return PR_FALSE;
-    }
-
-    gl->fGetProgramiv(currentProgram, GL_ACTIVE_ATTRIBUTES, &numAttributes);
-    if (numAttributes == -1) {
-        // what?
-        LogMessagef("glGetProgramiv GL_ACTIVE_ATTRIBUTES failed: 0x%08x", (uint) gl->fGetError());
-        return PR_FALSE;
-    }
-
-    // is this valid?
-    if (numAttributes > (GLint) mAttribBuffers.Length()) {
-        // what?
-        LogMessagef("GL_ACTIVE_ATTRIBUTES > GL_MAX_VERTEX_ATTRIBS");
-        return PR_FALSE;
-    }
-    PRUint32 maxAttribs = numAttributes;
-
-    for (PRUint32 i = 0; i < maxAttribs; ++i) {
-        GLsizei nameBufSz = 256;
-        GLchar nameBuf[256];
-        GLint vaSize;
-        GLenum vaType;
-        GLint attribLoc = -1;
-
-        gl->fGetActiveAttrib(currentProgram, i, nameBufSz, &nameBufSz, &vaSize, &vaType, nameBuf);
-        attribLoc = gl->fGetAttribLocation(currentProgram, nameBuf);
-
-        if (attribLoc == -1) {
-            LogMessagef(("Couldn't find an active attrib by name?"));
-            return PR_FALSE;
-        }
-
-        enabled = 0;
-        gl->fGetVertexAttribiv(attribLoc, GL_VERTEX_ATTRIB_ARRAY_ENABLED, &enabled);
-
-        if (enabled) {
-            binding = 0;
-            gl->fGetVertexAttribiv(attribLoc, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, &binding);
-
-            // figure out element size and type
-            size = -1;
-            type = GL_FLOAT;
-
-            // Note that the VERTEX_ATTRIB_ARRAY_{SIZE,TYPE} don't matter,
-            // just what the type is of the buffer since GL will convert/expand.
-
-            if (binding) {
-                if (binding < 0 || binding >= (GLint) mBuffers.Length() || !mBuffers[binding]) {
-                    LogMessagef(("ValidateBuffers: invalid buffer bound"));
-                    return PR_FALSE;
-                }
-                len = mBuffers[binding]->GetSimpleBuffer().capacity;
-                size = -1;
-                gl->fGetVertexAttribiv(attribLoc, GL_VERTEX_ATTRIB_ARRAY_SIZE, &size);
-                if (size <= 0) {
-                    LogMessagef(("ValidateBuffers: invalid VertexAttribPointer size"));
-                    return PR_FALSE;
-                }
-                type = mBuffers[binding]->Type();
-            } else {
-                if (!mAttribBuffers[attribLoc]) {
-                    LogMessagef(("ValidateBuffers: invalid VertexAttribPointer"));
-                    return PR_FALSE;
-                }
-                len = mAttribBuffers[attribLoc]->GetSimpleBuffer().capacity;
-                size = mAttribBuffers[attribLoc]->Size();
-                type = mAttribBuffers[attribLoc]->Type();
-            }
-
-            switch (type) {
-                case GL_FLOAT:
-                    size *= 4;
-                    break;
-                case GL_SHORT:
-                case GL_UNSIGNED_SHORT:
-                // case GL_FIXED:
-                    size *= 2;
-                    break;
-                case GL_UNSIGNED_BYTE:
-                case GL_BYTE:
-                    break;
-                default:
-                    LogMessagef("ValidateBuffers: bad GL_VERTEX_ATTRIB_ARRAY_TYPE %d", type);
-                    return PR_FALSE;
-            }
-
-            if (len <= 0 || size <= 0 || count > (PRUint32)(len / size)) {
-                LogMessagef(("ValidateBuffers: trying to draw out of bounds"));
-                return PR_FALSE;
-            }
-
-            someEnabled = PR_TRUE;
-        }
-    }
-
-    if (!someEnabled) {
-        LogMessagef(("ValidateBuffers: no vertex attribs enabled"));
-        return PR_FALSE;
-    }
-
-    return PR_TRUE;
-}
-
-PRBool
-BaseTypeAndSizeFromUniformType(GLenum uType, GLenum *baseType, GLint *unitSize)
-{
-        switch (uType) {
-        case GL_INT:
-        case GL_INT_VEC2:
-        case GL_INT_VEC3:
-        case GL_INT_VEC4:
-        case GL_SAMPLER_2D:
-        case GL_SAMPLER_CUBE:
-            *baseType = GL_INT;
-            break;
-        case GL_FLOAT:
-        case GL_FLOAT_VEC2:
-        case GL_FLOAT_VEC3:
-        case GL_FLOAT_VEC4:
-        case GL_FLOAT_MAT2:
-        case GL_FLOAT_MAT3:
-        case GL_FLOAT_MAT4:
-            *baseType = GL_FLOAT;
-            break;
-        case GL_BOOL:
-        case GL_BOOL_VEC2:
-        case GL_BOOL_VEC3:
-        case GL_BOOL_VEC4:
-            *baseType = GL_INT; // pretend these are int
-            break;
-        default:
-            return PR_FALSE;
-    }
-
-    switch (uType) {
-        case GL_INT:
-        case GL_FLOAT:
-        case GL_BOOL:
-        case GL_SAMPLER_2D:
-        case GL_SAMPLER_CUBE:
-            *unitSize = 1;
-            break;
-        case GL_INT_VEC2:
-        case GL_FLOAT_VEC2:
-        case GL_BOOL_VEC2:
-            *unitSize = 2;
-            break;
-        case GL_INT_VEC3:
-        case GL_FLOAT_VEC3:
-        case GL_BOOL_VEC3:
-            *unitSize = 3;
-            break;
-        case GL_INT_VEC4:
-        case GL_FLOAT_VEC4:
-        case GL_BOOL_VEC4:
-            *unitSize = 4;
-            break;
-        case GL_FLOAT_MAT2:
-            *unitSize = 4;
-            break;
-        case GL_FLOAT_MAT3:
-            *unitSize = 9;
-            break;
-        case GL_FLOAT_MAT4:
-            *unitSize = 16;
-            break;
-        default:
-            return PR_FALSE;
-    }
-
-    return PR_TRUE;
-}
-
-// ImageData getImageData (in float x, in float y, in float width, in float height);
-NS_IMETHODIMP
-nsCanvasRenderingContextGLWeb20::GetImageData(PRUint32 x, PRUint32 y, PRUint32 w, PRUint32 h)
-{
-    // disabled due to win32 linkage issues with thebes symbols and NS_RELEASE
-    return NS_ERROR_FAILURE;
-
-#if 0
-    NativeJSContext js;
-    if (NS_FAILED(js.error))
-        return js.error;
-
-    if (js.argc != 4) return NS_ERROR_INVALID_ARG;
-    
-    if (!mGLPbuffer ||
-        !mGLPbuffer->ThebesSurface())
-        return NS_ERROR_FAILURE;
-
-    if (!mCanvasElement)
-        return NS_ERROR_FAILURE;
-
-    if (mCanvasElement->IsWriteOnly() && !IsCallerTrustedForRead()) {
-        // XXX ERRMSG we need to report an error to developers here! (bug 329026)
-        return NS_ERROR_DOM_SECURITY_ERR;
-    }
-
-    JSContext *ctx = js.ctx;
-
-    if (!CanvasUtils::CheckSaneSubrectSize (x, y, w, h, mWidth, mHeight))
-        return NS_ERROR_DOM_SYNTAX_ERR;
-
-    nsAutoArrayPtr<PRUint8> surfaceData (new (std::nothrow) PRUint8[w * h * 4]);
-    int surfaceDataStride = w*4;
-    int surfaceDataOffset = 0;
-
-    if (!surfaceData)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    nsRefPtr<gfxImageSurface> tmpsurf = new gfxImageSurface(surfaceData,
-                                                            gfxIntSize(w, h),
-                                                            w * 4,
-                                                            gfxASurface::ImageFormatARGB32);
-    if (!tmpsurf || tmpsurf->CairoStatus())
-        return NS_ERROR_FAILURE;
-
-    nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
-
-    if (!tmpctx || tmpctx->HasError())
-        return NS_ERROR_FAILURE;
-
-    nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
-    nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
-    gfxMatrix m;
-    m.Translate(gfxPoint(x, mGLPbuffer->Height()-y));
-    m.Scale(1.0, -1.0);
-    pat->SetMatrix(m);
-
-    // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
-    // pixel alignment for this stuff!
-    tmpctx->NewPath();
-    tmpctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, w, h), pat);
-    tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
-    tmpctx->Fill();
-
-    tmpctx = nsnull;
-    tmpsurf = nsnull;
-
-    PRUint32 len = w * h * 4;
-    if (len > (((PRUint32)0xfff00000)/sizeof(jsval)))
-        return NS_ERROR_INVALID_ARG;
-
-    nsAutoArrayPtr<jsval> jsvector(new (std::nothrow) jsval[w * h * 4]);
-    if (!jsvector)
-        return NS_ERROR_OUT_OF_MEMORY;
-    jsval *dest = jsvector.get();
-    PRUint8 *row;
-    for (PRUint32 j = 0; j < h; j++) {
-        row = surfaceData + surfaceDataOffset + (surfaceDataStride * j);
-        for (PRUint32 i = 0; i < w; i++) {
-            // XXX Is there some useful swizzle MMX we can use here?
-            // I guess we have to INT_TO_JSVAL still
-#ifdef IS_LITTLE_ENDIAN
-            PRUint8 b = *row++;
-            PRUint8 g = *row++;
-            PRUint8 r = *row++;
-            PRUint8 a = *row++;
-#else
-            PRUint8 a = *row++;
-            PRUint8 r = *row++;
-            PRUint8 g = *row++;
-            PRUint8 b = *row++;
-#endif
-            // Convert to non-premultiplied color
-            if (a != 0) {
-                r = (r * 255) / a;
-                g = (g * 255) / a;
-                b = (b * 255) / a;
-            }
-
-            *dest++ = INT_TO_JSVAL(r);
-            *dest++ = INT_TO_JSVAL(g);
-            *dest++ = INT_TO_JSVAL(b);
-            *dest++ = INT_TO_JSVAL(a);
-        }
-    }
-
-    JSObject *dataArray = JS_NewArrayObject(ctx, w*h*4, jsvector);
-    if (!dataArray)
-        return NS_ERROR_OUT_OF_MEMORY;
-
-    JSObjectHelper retobj(&js);
-    retobj.DefineProperty("width", w);
-    retobj.DefineProperty("height", h);
-    retobj.DefineProperty("data", dataArray);
-
-    js.SetRetVal(retobj);
-
-    return NS_OK;
-#endif
-}
diff -r 5b1fe1bf3872 content/canvas/src/nsGLPbuffer.cpp
--- a/content/canvas/src/nsGLPbuffer.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/nsGLPbuffer.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -38,10 +38,13 @@
 
 #include <stdarg.h>
 
-#include "nsCanvasRenderingContextGL.h"
+#include "prprf.h"
 
 #include "nsGLPbuffer.h"
 
+#include "nsIConsoleService.h"
+#include "nsServiceManagerUtils.h"
+
 #if 0
 #include <xmmintrin.h>
 #endif
@@ -49,27 +52,18 @@
 void *nsGLPbuffer::sCurrentContextToken = nsnull;
 
 void
-nsGLPbuffer::LogMessage (const nsCString& errorString)
-{
-    if (mPriv)
-        mPriv->LogMessage(errorString);
-    else
-        fprintf(stderr, "nsGLPbuffer: %s\n", errorString.get());
-}
-
-void
-nsGLPbuffer::LogMessagef (const char *fmt, ...)
+nsGLPbuffer::LogMessage(const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
     char buf[256];
 
-    vsnprintf(buf, 256, fmt, ap);
-
-    if (mPriv)
-        mPriv->LogMessage(nsDependentCString(buf));
-    else
-        fprintf(stderr, "nsGLPbuffer: %s\n", buf);
+    nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
+    if (console) {
+        PR_vsnprintf(buf, 256, fmt, ap);
+        console->LogStringMessage(NS_ConvertUTF8toUTF16(nsDependentCString(buf)).get());
+        fprintf(stderr, "%s\n", buf);
+    }
 
     va_end(ap);
 }
diff -r 5b1fe1bf3872 content/canvas/src/nsGLPbuffer.h
--- a/content/canvas/src/nsGLPbuffer.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/nsGLPbuffer.h	Fri Dec 11 07:09:00 2009 +0200
@@ -48,29 +48,51 @@
 #include "gfxASurface.h"
 #include "gfxImageSurface.h"
 
+#ifdef USE_EGL
+typedef int EGLint;
+typedef unsigned int EGLBoolean;
+typedef unsigned int EGLenum;
+typedef void *EGLConfig;
+typedef void *EGLContext;
+typedef void *EGLDisplay;
+typedef void *EGLSurface;
+typedef void *EGLClientBuffer;
+#endif
+
 #ifdef XP_WIN
 #include "gfxWindowsSurface.h"
 #endif
 
-#if defined(XP_UNIX) && defined(MOZ_X11)
+#ifdef MOZ_X11
+#include "gfxXlibSurface.h"
+#endif
+
+#if defined(WINCE) && defined(CAIRO_HAS_DDRAW_SURFACE)
+#include "gfxDDrawSurface.h"
+#endif
+
+#ifdef USE_GLX
+#define GLX_GLXEXT_LEGACY
 #include "GL/glx.h"
 #endif
 
-#ifdef XP_MACOSX
+#ifdef USE_CGL
 #include "gfxQuartzImageSurface.h"
 #include <OpenGL/CGLTypes.h>
 #endif
 
 #include "glwrap.h"
 
-class nsCanvasRenderingContextGLPrivate;
+namespace mozilla {
+class WebGLContext;
+}
 
 class nsGLPbuffer {
 public:
     nsGLPbuffer() : mWidth(0), mHeight(0), mPriv(0) { }
     virtual ~nsGLPbuffer() { }
 
-    virtual PRBool Init(nsCanvasRenderingContextGLPrivate *priv) = 0;
+    virtual PRBool Init(mozilla::WebGLContext *priv) = 0;
     virtual PRBool Resize(PRInt32 width, PRInt32 height) = 0;
     virtual void Destroy() = 0;
 
@@ -90,12 +112,11 @@ protected:
     GLES20Wrap mGLWrap;
 
     static void *sCurrentContextToken;
-    nsCanvasRenderingContextGLPrivate *mPriv;
+    mozilla::WebGLContext *mPriv;
 
     void Premultiply(unsigned char *src, unsigned int len);
 
-    void LogMessage (const nsCString& errorString);
-    void LogMessagef (const char *fmt, ...);
+    void LogMessage (const char *fmt, ...);
 };
 
 class nsGLPbufferOSMESA :
@@ -105,7 +126,7 @@ public:
     nsGLPbufferOSMESA();
     virtual ~nsGLPbufferOSMESA();
 
-    virtual PRBool Init(nsCanvasRenderingContextGLPrivate *priv);
+    virtual PRBool Init(mozilla::WebGLContext *priv);
     virtual PRBool Resize(PRInt32 width, PRInt32 height);
     virtual void Destroy();
 
@@ -119,7 +140,7 @@ protected:
     PrivateOSMesaContext mMesaContext;
 };
 
-#ifdef XP_MACOSX
+#ifdef USE_CGL
 class nsGLPbufferCGL :
     public nsGLPbuffer
 {
@@ -127,7 +148,7 @@ public:
     nsGLPbufferCGL();
     virtual ~nsGLPbufferCGL();
 
-    virtual PRBool Init(nsCanvasRenderingContextGLPrivate *priv);
+    virtual PRBool Init(mozilla::WebGLContext *priv);
     virtual PRBool Resize(PRInt32 width, PRInt32 height);
     virtual void Destroy();
 
@@ -154,7 +175,7 @@ protected:
 };
 #endif
 
-#if defined(XP_UNIX) && defined(MOZ_X11)
+#ifdef USE_GLX
 class nsGLPbufferGLX :
     public nsGLPbuffer
 {
@@ -162,7 +183,7 @@ public:
     nsGLPbufferGLX();
     virtual ~nsGLPbufferGLX();
 
-    virtual PRBool Init(nsCanvasRenderingContextGLPrivate *priv);
+    virtual PRBool Init(mozilla::WebGLContext *priv);
     virtual PRBool Resize(PRInt32 width, PRInt32 height);
     virtual void Destroy();
 
@@ -181,7 +202,41 @@ protected:
 };
 #endif
 
-#ifdef XP_WIN
+#ifdef USE_EGL
+class nsGLPbufferEGL :
+    public nsGLPbuffer
+{
+public:
+    nsGLPbufferEGL();
+    virtual ~nsGLPbufferEGL();
+
+    virtual PRBool Init(mozilla::WebGLContext *priv);
+    virtual PRBool Resize(PRInt32 width, PRInt32 height);
+    virtual void Destroy();
+
+    virtual void MakeContextCurrent();
+    virtual void SwapBuffers();
+
+    virtual gfxASurface* ThebesSurface();
+
+protected:
+    EGLDisplay mDisplay;
+    EGLConfig mConfig;
+    EGLSurface mSurface;
+    EGLContext mContext;
+
+#if defined(XP_WIN)
+    nsRefPtr<gfxImageSurface> mThebesSurface;
+    nsRefPtr<gfxWindowsSurface> mWindowsSurface;
+#elif defined(MOZ_X11)
+    nsRefPtr<gfxImageSurface> mThebesSurface;
+    nsRefPtr<gfxXlibSurface> mXlibSurface;
+    Visual *mVisual;
+#endif
+};
+#endif
+
+#ifdef USE_WGL
 class nsGLPbufferWGL :
     public nsGLPbuffer
 {
@@ -189,7 +244,7 @@ public:
     nsGLPbufferWGL();
     virtual ~nsGLPbufferWGL();
 
-    virtual PRBool Init(nsCanvasRenderingContextGLPrivate *priv);
+    virtual PRBool Init(mozilla::WebGLContext *priv);
     virtual PRBool Resize(PRInt32 width, PRInt32 height);
     virtual void Destroy();
 
diff -r 5b1fe1bf3872 content/canvas/src/nsGLPbufferCGL.cpp
--- a/content/canvas/src/nsGLPbufferCGL.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/nsGLPbufferCGL.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -36,16 +36,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
+#include "nsIPrefService.h"
+#include "nsServiceManagerUtils.h"
+
+#include "nsGLPbuffer.h"
+#include "WebGLContext.h"
+
 #include <OpenGL/OpenGL.h>
 
-#include "nsICanvasRenderingContextGL.h"
+#include "gfxContext.h"
 
-#include "nsIPrefService.h"
-
-#include "nsGLPbuffer.h"
-#include "nsCanvasRenderingContextGL.h"
-
-#include "gfxContext.h"
+using namespace mozilla;
 
 static PRUint32 gActiveBuffers = 0;
 
@@ -57,7 +58,7 @@ nsGLPbufferCGL::nsGLPbufferCGL()
 }
 
 PRBool
-nsGLPbufferCGL::Init(nsCanvasRenderingContextGLPrivate *priv)
+nsGLPbufferCGL::Init(WebGLContext *priv)
 {
     mPriv = priv;
     nsresult rv;
@@ -108,12 +109,12 @@ nsGLPbufferCGL::Init(nsCanvasRenderingCo
     MakeContextCurrent();
 
     if (!mGLWrap.OpenLibrary("/System/Library/Frameworks/OpenGL.framework/Libraries/libGL.dylib")) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Failed to open LibGL.dylib (tried system OpenGL.framework)"));
+        LogMessage("Canvas 3D: Failed to open LibGL.dylib (tried system OpenGL.framework)");
         return PR_FALSE;
     }
 
     if (!mGLWrap.Init(GLES20Wrap::TRY_NATIVE_GL)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GLWrap init failed"));
+        LogMessage("Canvas 3D: GLWrap init failed");
         return PR_FALSE;
     }
 
@@ -144,7 +145,7 @@ nsGLPbufferCGL::Resize(PRInt32 width, PR
         return PR_FALSE;
     }
 
-    err = CGLCreatePBuffer(width, height, GL_TEXTURE_RECTANGLE_EXT, GL_RGBA, 0, &mPbuffer);
+    err = CGLCreatePBuffer(width, height, LOCAL_GL_TEXTURE_RECTANGLE_EXT, LOCAL_GL_RGBA, 0, &mPbuffer);
     if (err) {
         fprintf (stderr, "CGLCreatePBuffer failed: %d\n", err);
         return PR_FALSE;
@@ -225,7 +226,7 @@ gfxASurface*
 nsGLPbufferCGL::ThebesSurface()
 {
     if (!mThebesSurface) {
-        mThebesSurface = CanvasGLThebes::CreateImageSurface(gfxIntSize(mWidth, mHeight), gfxASurface::ImageFormatARGB32);
+        mThebesSurface = new gfxImageSurface(gfxIntSize(mWidth, mHeight), gfxASurface::ImageFormatARGB32);
         if (mThebesSurface->CairoStatus() != 0) {
             fprintf (stderr, "image surface failed\n");
             return nsnull;
@@ -238,7 +239,7 @@ nsGLPbufferCGL::ThebesSurface()
 
     if (mImageNeedsUpdate) {
         MakeContextCurrent();
-        mGLWrap.fReadPixels (0, 0, mWidth, mHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, mThebesSurface->Data());
+        mGLWrap.fReadPixels (0, 0, mWidth, mHeight, LOCAL_GL_BGRA, LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV, mThebesSurface->Data());
 
         mQuartzSurface->Flush();
 
diff -r 5b1fe1bf3872 content/canvas/src/nsGLPbufferEGL.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/content/canvas/src/nsGLPbufferEGL.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,487 @@
+/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+// this must be first, else windows.h breaks us
+#include "WebGLContext.h"
+#include "nsGLPbuffer.h"
+
+#include "nsDirectoryServiceUtils.h"
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsIPrefService.h"
+
+#include "gfxContext.h"
+
+#include "glwrap.h"
+
+#ifdef MOZ_X11
+#include <gdk/gdkx.h>
+
+typedef Display* EGLNativeDisplayType;
+typedef Window EGLNativeWindowType;
+typedef Pixmap EGLNativePixmapType;
+#endif
+
+#ifdef WINCE
+typedef HDC EGLNativeDisplayType;
+typedef HWND EGLNativeWindowType;
+typedef HDC EGLNativePixmapType;
+#endif
+
+// some EGL defines
+#define EGL_DEFAULT_DISPLAY             ((EGLNativeDisplayType)0)
+#define EGL_NO_CONTEXT                  ((EGLContext)0)
+#define EGL_NO_DISPLAY                  ((EGLDisplay)0)
+#define EGL_NO_SURFACE                  ((EGLSurface)0)
+
+using namespace mozilla;
+
+static PRUint32 gActiveBuffers = 0;
+
+class EGLWrap
+    : public LibrarySymbolLoader
+{
+public:
+    EGLWrap() : fGetCurrentContext(0) { }
+
+    bool Init();
+
+public:
+    typedef EGLDisplay (*pfnGetDisplay)(void *display_id);
+    pfnGetDisplay fGetDisplay;
+    typedef EGLContext (*pfnGetCurrentContext)(void);
+    pfnGetCurrentContext fGetCurrentContext;
+    typedef EGLBoolean (*pfnMakeCurrent)(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
+    pfnMakeCurrent fMakeCurrent;
+    typedef EGLBoolean (*pfnDestroyContext)(EGLDisplay dpy, EGLContext ctx);
+    pfnDestroyContext fDestroyContext;
+    typedef EGLContext (*pfnCreateContext)(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list);
+    pfnCreateContext fCreateContext;
+    typedef EGLBoolean (*pfnDestroySurface)(EGLDisplay dpy, EGLSurface surface);
+    pfnDestroySurface fDestroySurface;
+    typedef EGLSurface (*pfnCreatePbufferSurface)(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list);
+    pfnCreatePbufferSurface fCreatePbufferSurface;
+    typedef EGLSurface (*pfnCreatePixmapSurface)(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list);
+    pfnCreatePixmapSurface fCreatePixmapSurface;
+    typedef EGLBoolean (*pfnBindAPI)(EGLenum api);
+    pfnBindAPI fBindAPI;
+    typedef EGLBoolean (*pfnInitialize)(EGLDisplay dpy, EGLint *major, EGLint *minor);
+    pfnInitialize fInitialize;
+    typedef EGLBoolean (*pfnChooseConfig)(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config);
+    pfnChooseConfig fChooseConfig;
+    typedef EGLint (*pfnGetError)(void);
+    pfnGetError fGetError;
+    typedef EGLBoolean (*pfnGetConfigAttrib)(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value);
+    pfnGetConfigAttrib fGetConfigAttrib;
+    typedef EGLBoolean (*pfnGetConfigs)(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config);
+    pfnGetConfigs fGetConfigs;
+    typedef EGLBoolean (*pfnWaitNative)(EGLint engine);
+    pfnWaitNative fWaitNative;
+};
+
+bool
+EGLWrap::Init()
+{
+    if (fGetDisplay)
+        return true;
+
+    SymLoadStruct symbols[] = {
+        { (PRFuncPtr*) &fGetDisplay, { "eglGetDisplay", NULL } },
+        { (PRFuncPtr*) &fGetCurrentContext, { "eglGetCurrentContext", NULL } },
+        { (PRFuncPtr*) &fMakeCurrent, { "eglMakeCurrent", NULL } },
+        { (PRFuncPtr*) &fDestroyContext, { "eglDestroyContext", NULL } },
+        { (PRFuncPtr*) &fCreateContext, { "eglCreateContext", NULL } },
+        { (PRFuncPtr*) &fDestroySurface, { "eglDestroySurface", NULL } },
+        { (PRFuncPtr*) &fCreatePbufferSurface, { "eglCreatePbufferSurface", NULL } },
+        { (PRFuncPtr*) &fCreatePixmapSurface, { "eglCreatePixmapSurface", NULL } },
+        { (PRFuncPtr*) &fBindAPI, { "eglBindAPI", NULL } },
+        { (PRFuncPtr*) &fInitialize, { "eglInitialize", NULL } },
+        { (PRFuncPtr*) &fChooseConfig, { "eglChooseConfig", NULL } },
+        { (PRFuncPtr*) &fGetError, { "eglGetError", NULL } },
+        { (PRFuncPtr*) &fGetConfigs, { "eglGetConfigs", NULL } },
+        { (PRFuncPtr*) &fGetConfigAttrib, { "eglGetConfigAttrib", NULL } },
+        { (PRFuncPtr*) &fWaitNative, { "eglWaitNative", NULL } },
+        { NULL, { NULL } }
+    };
+
+    return LoadSymbols(&symbols[0], true);
+}
+
+static EGLWrap gEGLWrap;
+
+nsGLPbufferEGL::nsGLPbufferEGL()
+    : mDisplay(0), mConfig(0), mSurface(0)
+{
+    gActiveBuffers++;
+}
+
+#ifdef WINCE
+// XXX wrong
+#define EGL_LIB "\\windows\\libEGL.dll"
+#define GLES2_LIB "\\windows\\libGLESv2.dll"
+#else
+#define EGL_LIB "/usr/lib/libEGL.so"
+#define GLES2_LIB "/usr/lib/libGLESv2.so"
+#endif
+
+PRBool
+nsGLPbufferEGL::Init(mozilla::WebGLContext *priv)
+{
+    mPriv = priv;
+
+#ifdef NS_OSSO
+    // Maemo has missing DSO dependencies on their OpenGL libraries;
+    // so ensure that the prerequisite libs are loaded in the process
+    // before loading GL.  An alternate approach is to use LD_PRELOAD.
+
+    // We'll just leak these libs; pvr_um.so seems to have been
+    // present on an older OS image, and now pvr2d.so is used.
+    PRLibSpec lspec;
+    lspec.type = PR_LibSpec_Pathname;
+
+    lspec.value.pathname = "/usr/lib/libpvr_um.so";
+    PR_LoadLibraryWithFlags(lspec, PR_LD_LAZY | PR_LD_GLOBAL);
+
+    lspec.value.pathname = "/usr/lib/libpvr2d.so";
+    PR_LoadLibraryWithFlags(lspec, PR_LD_LAZY | PR_LD_GLOBAL);
+#endif
+
+    if (!gEGLWrap.OpenLibrary(EGL_LIB)) {
+        LogMessage("egl OpenLibrary failed");
+        return PR_FALSE;
+    }
+
+    if (!gEGLWrap.Init()) {
+        LogMessage("eglWrap init failed");
+        return PR_FALSE;
+    }
+
+    mDisplay = gEGLWrap.fGetDisplay(0);
+
+    if (!gEGLWrap.fInitialize(mDisplay, NULL, NULL)) {
+        LogMessage("egl init failed");
+        return PR_FALSE;
+    }
+
+    gEGLWrap.fBindAPI (EGL_OPENGL_ES_API);
+
+#if defined(MOZ_X11) && defined(NS_OSSO)
+    EGLint attribs[] = {
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_SURFACE_TYPE, EGL_PIXMAP_BIT,
+        EGL_RED_SIZE, 3,
+        EGL_GREEN_SIZE, 3,
+        EGL_BLUE_SIZE, 3,
+        EGL_ALPHA_SIZE, 3,
+        EGL_DEPTH_SIZE, 1,
+        EGL_NONE
+    };
+
+    
+    EGLint ncfg = 0;
+    EGLConfig cfg;
+
+    if (!gEGLWrap.fChooseConfig(mDisplay, attribs, &cfg, 1, &ncfg) ||
+        ncfg < 1)
+    {
+        LogMessage("Canvas 3D: eglChooseConfig failed (ncfg: %d err: 0x%04x)", ncfg, gEGLWrap.fGetError());
+        return PR_FALSE;
+    }
+
+    EGLint visid;
+
+    gEGLWrap.fGetConfigAttrib(mDisplay, cfg, EGL_NATIVE_VISUAL_ID, &visid);
+
+    XVisualInfo vinfo;
+    vinfo.visualid = visid;
+    int pad;
+
+    LogMessage("Visual ID: %d\n", visid);
+
+    XVisualInfo *vf = XGetVisualInfo(gdk_x11_get_default_xdisplay(), VisualIDMask, &vinfo, &pad);
+
+    if (!vf) {
+        LogMessage("Null VisualInfo!");
+        return PR_FALSE;
+    }
+
+    LogMessage("Visual: 0x%08x\n", vf->visual);
+
+    mVisual = vf->visual;
+    mConfig = cfg;
+#elif defined(WINCE)
+#define MAX_CONFIGS 32
+    EGLConfig configs[MAX_CONFIGS];
+    EGLint numConfigs;
+
+    gEGLWrap.fGetConfigs(mDisplay, configs, MAX_CONFIGS, &numConfigs);
+
+    mConfig = 0;
+
+    for (int i = 0; i < numConfigs; ++i) {
+        EGLint id;
+        EGLint surfaces, renderables;
+        EGLint rsize, gsize, bsize, asize, dsize;
+
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_CONFIG_ID, &id);
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_SURFACE_TYPE, &surfaces);
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_RENDERABLE_TYPE, &renderables);
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_RED_SIZE, &rsize);
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_GREEN_SIZE, &gsize);
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_BLUE_SIZE, &bsize);
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_ALPHA_SIZE, &asize);
+        gEGLWrap.fGetConfigAttrib(mDisplay, configs[i], EGL_DEPTH_SIZE, &dsize);
+
+#ifdef DEBUG_vladimir
+        fprintf(stderr, "config 0x%02x: s %x api %x rgba %d %d %d %d d %d\n", id, surfaces, renderables, rsize, gsize, bsize, asize, dsize);
+#endif
+
+        if ((surfaces & EGL_PBUFFER_BIT) &&
+            (renderables & EGL_OPENGL_ES2_BIT) &&
+            (rsize > 3) &&
+            (gsize > 3) &&
+            (bsize > 3) &&
+            (asize > 3) &&
+            (dsize > 1))
+        {
+            mConfig = configs[i];
+            break;
+        }
+    }
+
+    if (mConfig == 0) {
+        LogMessage("Failed to find config!");
+        return PR_FALSE;
+    }
+#else
+#error need some boilerplate code for EGL
+#endif
+
+    LogMessage("Resize 2,2");
+    Resize(2, 2);
+
+    LogMessage("OpenLibrary");
+    if (!mGLWrap.OpenLibrary(GLES2_LIB)) {
+        LogMessage("Canvas 3D: Couldn't open EGL lib [1]");
+        return PR_FALSE;
+    }
+
+    LogMessage("GLWrap.Init");
+    if (!mGLWrap.Init(GLES20Wrap::TRY_NATIVE_GL)) {
+        LogMessage("Canvas 3D: GLWrap init failed");
+        return PR_FALSE;
+    }
+    LogMessage("Init done");
+    return PR_TRUE;
+}
+
+PRBool
+nsGLPbufferEGL::Resize(PRInt32 width, PRInt32 height)
+{
+    if (mWidth == width &&
+        mHeight == height)
+    {
+        return PR_TRUE;
+    }
+
+    LogMessage("Resize %d %d start", width, height);
+
+    Destroy();
+
+    LogMessage("Destroyed");
+
+#ifdef XP_WIN
+    mWindowsSurface = new gfxWindowsSurface(gfxIntSize(width, height),
+                                            gfxASurface::ImageFormatARGB32);
+    if (mWindowsSurface->CairoStatus() != 0) {
+#ifdef DEBUG_vladimir
+        fprintf (stderr, "image surface failed\n");
+#endif
+        return PR_FALSE;
+    }
+
+    mThebesSurface = mWindowsSurface->GetImageSurface();
+
+    EGLint attrs[] = {
+        EGL_WIDTH, width,
+        EGL_HEIGHT, height,
+        EGL_NONE
+    };
+
+    mSurface = gEGLWrap.fCreatePbufferSurface(mDisplay, mConfig, attrs);
+    if (!mSurface) {
+        LogMessage("Canvas 3D: eglCreatePbufferSurface failed");
+        return PR_FALSE;
+    }
+#else
+
+    mXlibSurface = new gfxXlibSurface(gdk_x11_get_default_xdisplay(),
+                                        mVisual,
+                                        gfxIntSize(width, height),
+                                        32);
+    if (!mXlibSurface || mXlibSurface->CairoStatus() != 0) {
+#ifdef DEBUG_vladimir
+        fprintf (stderr, "Failed to create gfxXlibSurface");
+#endif
+        return PR_FALSE;
+    }
+
+    LogMessage("Created gfxXlibSurface, Drawable: 0x%08x", mXlibSurface->XDrawable());
+
+    // we need to XSync to ensure that the Pixmap is created on the server side,
+    // otherwise eglCreatePixmapSurface will fail (because it isn't part of the normal
+    // X protocol).
+    XSync(gdk_x11_get_default_xdisplay(), 0);
+
+    EGLint attrs[] = {
+        EGL_NONE
+    };
+
+    Pixmap px = (Pixmap) mXlibSurface->XDrawable();
+
+    mSurface = gEGLWrap.fCreatePixmapSurface(mDisplay, mConfig, (EGLNativePixmapType) px, attrs);
+    if (!mSurface) {
+#ifdef DEBUG_vladimir
+        fprintf (stderr, "Failed to create Pixmap EGLSurface\n");
+#endif
+        return PR_FALSE;
+    }
+
+    LogMessage("mSurface: %p", mSurface);
+#endif
+
+    gEGLWrap.fBindAPI(EGL_OPENGL_ES_API);
+
+    EGLint cxattrs[] = {
+        EGL_CONTEXT_CLIENT_VERSION, 2,
+        EGL_NONE
+    };
+
+    mContext = gEGLWrap.fCreateContext(mDisplay, mConfig, EGL_NO_CONTEXT, cxattrs);
+    if (!mContext) {
+        Destroy();
+        return PR_FALSE;
+    }
+
+    mWidth = width;
+    mHeight = height;
+
+#ifdef MOZ_X11
+    mThebesSurface = new gfxImageSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
+#endif
+
+    return PR_TRUE;
+}
+
+void
+nsGLPbufferEGL::Destroy()
+{
+    if (mContext) {
+        gEGLWrap.fDestroyContext(mDisplay, mContext);
+        mContext = 0;
+    }
+
+    if (mSurface) {
+        gEGLWrap.fDestroySurface(mDisplay, mSurface);
+        mSurface = 0;
+    }
+
+    sCurrentContextToken = nsnull;
+
+    // leak this
+#ifdef MOZ_X11
+    NS_IF_ADDREF(mXlibSurface.get());
+    mXlibSurface = nsnull;
+#else
+    mWindowsSurface = nsnull;
+#endif
+
+    mThebesSurface = nsnull;
+
+}
+
+nsGLPbufferEGL::~nsGLPbufferEGL()
+{
+    Destroy();
+
+    gActiveBuffers--;
+    fflush (stderr);
+}
+
+void
+nsGLPbufferEGL::MakeContextCurrent()
+{
+    if (gEGLWrap.fGetCurrentContext() == mContext)
+        return;
+
+    gEGLWrap.fMakeCurrent(mDisplay, mSurface, mSurface, mContext);
+}
+
+void
+nsGLPbufferEGL::SwapBuffers()
+{
+    //    eglCopyBuffers(mDisplay, mSurface, mWindowsSurface->GetDC());
+    MakeContextCurrent();
+
+    //printf ("SwapBuffers0: %04x\n", mGLWrap.fGetError());
+
+    // this is wrong, we need to figure out a way to swap this, but we don't do anything here
+    mGLWrap.fFinish ();
+
+    mGLWrap.fReadPixels (0, 0, mWidth, mHeight, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, mThebesSurface->Data());
+
+    //printf ("SwapBuffers: %04x\n", mGLWrap.fGetError());
+
+#if 0
+    // premultiply the image
+    int len = mWidth*mHeight*4;
+    unsigned char *src = mThebesSurface->Data();
+    Premultiply(src, len);
+#endif
+}
+
+gfxASurface*
+nsGLPbufferEGL::ThebesSurface()
+{
+#if defined(MOZ_X11) && defined(NS_OSSO)
+    if (getenv("IMAGE"))
+        return mThebesSurface;
+    return mXlibSurface;
+#elif defined(WINCE)
+    return mThebesSurface;
+#endif
+}
diff -r 5b1fe1bf3872 content/canvas/src/nsGLPbufferGLX.cpp
--- a/content/canvas/src/nsGLPbufferGLX.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/nsGLPbufferGLX.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -37,15 +37,20 @@
  * ***** END LICENSE BLOCK ***** */
 
 // this must be first, else windows.h breaks us
-#include "nsICanvasRenderingContextGL.h"
+#include "nsICanvasRenderingContextWebGL.h"
 
 #include "nsIPrefService.h"
+#include "nsServiceManagerUtils.h"
+
+#include "glwrap.h"
 
 #include "nsGLPbuffer.h"
-#include "nsCanvasRenderingContextGL.h"
+#include "WebGLContext.h"
 
 #include "gfxContext.h"
 
+using namespace mozilla;
+
 #if defined(MOZ_WIDGET_GTK2) && defined(MOZ_X11)
 #include <gdk/gdkx.h>
 #endif
@@ -127,18 +132,18 @@ nsGLPbufferGLX::nsGLPbufferGLX()
 }
 
 PRBool
-nsGLPbufferGLX::Init(nsCanvasRenderingContextGLPrivate *priv)
+nsGLPbufferGLX::Init(WebGLContext *priv)
 {
     nsresult rv;
     const char *s;
 
     if (!gGLXWrap.OpenLibrary("libGL.so.1")) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Couldn't find libGL.so.1"));
+        LogMessage("Canvas 3D: Couldn't find libGL.so.1");
         return PR_FALSE;
     }
 
     if (!gGLXWrap.Init()) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: gGLXWrap.Init() failed"));
+        LogMessage("Canvas 3D: gGLXWrap.Init() failed");
         return PR_FALSE;
     }
 
@@ -148,20 +153,20 @@ nsGLPbufferGLX::Init(nsCanvasRenderingCo
     mDisplay = XOpenDisplay(NULL);
 #endif
     if (!mDisplay) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: XOpenDisplay failed"));
+        LogMessage("Canvas 3D: XOpenDisplay failed");
         return PR_FALSE;
     }
 
     // Make sure that everyone agrees that pbuffers are supported
     s = gGLXWrap.fQueryExtensionsString(mDisplay, DefaultScreen(mDisplay));
     if (strstr(s, "GLX_SGIX_pbuffer") == NULL) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GLX_SGIX_pbuffer not supported"));
+        LogMessage("Canvas 3D: GLX_SGIX_pbuffer not supported");
         return PR_FALSE;
     }
 
     s = gGLXWrap.fQueryServerString(mDisplay, DefaultScreen(mDisplay), GLX_EXTENSIONS);
     if (strstr(s, "GLX_SGIX_pbuffer") == NULL) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GLX_SGIX_pbuffer not supported by server"));
+        LogMessage("Canvas 3D: GLX_SGIX_pbuffer not supported by server");
         return PR_FALSE;
     }
 
@@ -197,7 +202,7 @@ nsGLPbufferGLX::Init(nsCanvasRenderingCo
 
     fprintf(stderr, "CANVAS3D FBCONFIG: %d %p\n", num, (void*) configs);
     if (!configs) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: No GLXFBConfig found"));
+        LogMessage("Canvas 3D: No GLXFBConfig found");
         return PR_FALSE;
     }
 
@@ -219,14 +224,14 @@ nsGLPbufferGLX::Init(nsCanvasRenderingCo
     fprintf (stderr, "nsGLPbufferGLX::Init!\n");
 
     if (!mGLWrap.OpenLibrary("libGL.so.1")) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GLWrap init failed, couldn't find libGL.so.1"));
+        LogMessage("Canvas 3D: GLWrap init failed, couldn't find libGL.so.1");
         return PR_FALSE;
     }
 
     mGLWrap.SetLookupFunc((LibrarySymbolLoader::PlatformLookupFunction) gGLXWrap.fGetProcAddress);
 
     if (!mGLWrap.Init(GLES20Wrap::TRY_NATIVE_GL)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GLWrap init failed"));
+        LogMessage("Canvas 3D: GLWrap init failed");
         return PR_FALSE;
     }
 
@@ -250,7 +255,7 @@ nsGLPbufferGLX::Resize(PRInt32 width, PR
 
     Destroy();
 
-    mThebesSurface = CanvasGLThebes::CreateImageSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
+    mThebesSurface = new gfxImageSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
     if (mThebesSurface->CairoStatus() != 0) {
         fprintf (stderr, "image surface failed\n");
         return PR_FALSE;
@@ -323,7 +328,7 @@ void
 nsGLPbufferGLX::SwapBuffers()
 {
     MakeContextCurrent();
-    mGLWrap.fReadPixels (0, 0, mWidth, mHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, mThebesSurface->Data());
+    mGLWrap.fReadPixels (0, 0, mWidth, mHeight, LOCAL_GL_BGRA, LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV, mThebesSurface->Data());
     unsigned int len = mWidth*mHeight*4;
     unsigned char *src = mThebesSurface->Data();
     // Premultiply the image
diff -r 5b1fe1bf3872 content/canvas/src/nsGLPbufferOSMesa.cpp
--- a/content/canvas/src/nsGLPbufferOSMesa.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/nsGLPbufferOSMesa.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -37,18 +37,18 @@
  * ***** END LICENSE BLOCK ***** */
 
 // this must be first, else windows.h breaks us
-#include "nsICanvasRenderingContextGL.h"
-
 #include "nsDirectoryServiceUtils.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsIPrefService.h"
 
+#include "glwrap.h"
+
 #include "nsGLPbuffer.h"
-#include "nsCanvasRenderingContextGL.h"
 
 #include "gfxContext.h"
+#include "gfxImageSurface.h"
 
-#include "glwrap.h"
+using namespace mozilla;
 
 #if 0
 #include <GL/osmesa.h>
@@ -71,7 +71,7 @@ nsGLPbufferOSMESA::nsGLPbufferOSMESA()
 }
 
 PRBool
-nsGLPbufferOSMESA::Init(nsCanvasRenderingContextGLPrivate *priv)
+nsGLPbufferOSMESA::Init(WebGLContext *priv)
 {
     mPriv = priv;
     nsresult rv;
@@ -80,12 +80,14 @@ nsGLPbufferOSMESA::Init(nsCanvasRenderin
     NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
     nsCOMPtr<nsIPrefBranch> prefBranch;
-    rv = prefService->GetBranch("extensions.canvas3d.", getter_AddRefs(prefBranch));
+    rv = prefService->GetBranch("webgl.", getter_AddRefs(prefBranch));
     NS_ENSURE_SUCCESS(rv, PR_FALSE);
 
     nsCString osmesalib;
 
     rv = prefBranch->GetCharPref("osmesalib", getter_Copies(osmesalib));
+
+#if 0
     if (NS_FAILED(rv)) {
         osmesalib.Truncate();
 
@@ -113,7 +115,7 @@ nsGLPbufferOSMESA::Init(nsCanvasRenderin
         rv |= libfile->Append(NS_LITERAL_STRING("libOSMesa.so.7"));
 #else
 #warning No default osmesa library path available
-        LogMessage(NS_LITERAL_STRING("Canvas 3D: No default OSMesa lib path available -- please set the extensions.canvas3d.osmesalib pref to the full path to the OSMesa shared library"));
+        LogMessage("Canvas 3D: No default OSMesa lib path available -- please set the extensions.canvas3d.osmesalib pref to the full path to the OSMesa shared library");
         rv = NS_ERROR_FAILURE;
 #endif
 
@@ -123,20 +125,23 @@ nsGLPbufferOSMESA::Init(nsCanvasRenderin
         PRBool exists = PR_FALSE;
         rv = libfile->Exists(&exists);
         if (NS_FAILED(rv) || !exists) {
-            LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Couldn't find OSMesa lib -- either default or extension.canvas3d.osmesalib path is incorrect"));
+            LogMessage("Canvas 3D: Couldn't find OSMesa lib -- either default or extension.canvas3d.osmesalib path is incorrect");
             return PR_FALSE;
         }
 
         // I'm told by the comments in nsIFile that I'm not supposed to do this.  Noted.
         rv = libfile->GetNativeTarget(osmesalib);
         if (NS_FAILED(rv)) {
-            LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Couldn't find OSMesa lib"));
+            LogMessage("Canvas 3D: Couldn't find OSMesa lib");
             return PR_FALSE;
         }
     }
-
-    if (!gMesaWrap.OpenLibrary(osmesalib.get())) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Couldn't open OSMesa lib -- either default or extension.canvas3d.osmesalib path is incorrect, or not a valid shared library"));
+#endif
+    if (NS_FAILED(rv) ||
+        osmesalib.Length() == 0 ||
+        !gMesaWrap.OpenLibrary(osmesalib.get()))
+    {
+        LogMessage("Canvas 3D: Couldn't open OSMesa lib -- webgl.osmesalib path is incorrect, or not a valid shared library");
         return PR_FALSE;
     }
 
@@ -151,14 +156,14 @@ nsGLPbufferOSMESA::Init(nsCanvasRenderin
     Resize (2, 2);
 
     if (!mGLWrap.OpenLibrary(osmesalib.get())) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Couldn't open OSMesa lib [1]"));
+        LogMessage("Canvas 3D: Couldn't open OSMesa lib [1]");
         return PR_FALSE;
     }
 
     mGLWrap.SetLookupFunc((LibrarySymbolLoader::PlatformLookupFunction) gMesaWrap.fGetProcAddress);
 
     if (!mGLWrap.Init(GLES20Wrap::TRY_SOFTWARE_GL)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GLWrap init failed"));
+        LogMessage("Canvas 3D: GLWrap init failed");
         return PR_FALSE;
     }
 
@@ -176,8 +181,8 @@ nsGLPbufferOSMESA::Resize(PRInt32 width,
 
     Destroy();
 
-    mThebesSurface = CanvasGLThebes::CreateImageSurface(gfxIntSize(width, height),
-                                                        gfxASurface::ImageFormatARGB32);
+    mThebesSurface = new gfxImageSurface(gfxIntSize(width, height),
+                                         gfxASurface::ImageFormatARGB32);
     if (mThebesSurface->CairoStatus() != 0) {
         fprintf (stderr, "image surface failed\n");
         return PR_FALSE;
@@ -191,7 +196,7 @@ nsGLPbufferOSMESA::Resize(PRInt32 width,
 
     fprintf (stderr, "Surface: %p\n", mThebesSurface->Data());
 
-    if (!gMesaWrap.fMakeCurrent (mMesaContext, mThebesSurface->Data(), GL_UNSIGNED_BYTE, width, height))
+    if (!gMesaWrap.fMakeCurrent (mMesaContext, mThebesSurface->Data(), LOCAL_GL_UNSIGNED_BYTE, width, height))
     {
         fprintf (stderr, "OSMesaMakeCurrent failed!\n");
         return PR_FALSE;
@@ -233,7 +238,7 @@ nsGLPbufferOSMESA::MakeContextCurrent()
     if (gMesaWrap.fGetCurrentContext() == mMesaContext)
         return;
 
-    gMesaWrap.fMakeCurrent (mMesaContext, mThebesSurface->Data(), GL_UNSIGNED_BYTE, mWidth, mHeight);
+    gMesaWrap.fMakeCurrent (mMesaContext, mThebesSurface->Data(), LOCAL_GL_UNSIGNED_BYTE, mWidth, mHeight);
 }
 
 void
diff -r 5b1fe1bf3872 content/canvas/src/nsGLPbufferWGL.cpp
--- a/content/canvas/src/nsGLPbufferWGL.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/canvas/src/nsGLPbufferWGL.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -36,15 +36,16 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
-// this must be first, else windows.h breaks us
-#include "nsICanvasRenderingContextGL.h"
+#include "nsIPrefService.h"
+#include "nsServiceManagerUtils.h"
 
-#include "nsIPrefService.h"
-
+#include "WebGLContext.h"
 #include "nsGLPbuffer.h"
-#include "nsCanvasRenderingContextGL.h"
 
 #include "gfxContext.h"
+#include "gfxImageSurface.h"
+
+using namespace mozilla;
 
 static PRUint32 gActiveBuffers = 0;
 
@@ -54,9 +55,20 @@ class WGLWrap
 public:
     WGLWrap() : fCreatePbuffer(0) { }
 
+    bool InitEarly();
     bool Init();
 
 public:
+    // early init
+    typedef HANDLE (WINAPI * PFNWGLCREATECONTEXTPROC) (HDC hDC);
+    PFNWGLCREATECONTEXTPROC fCreateContext;
+    typedef BOOL (WINAPI * PFNWGLMAKECURRENTPROC) (HDC hDC, HANDLE hglrc);
+    PFNWGLMAKECURRENTPROC fMakeCurrent;
+    typedef PROC (WINAPI * PFNWGLGETPROCADDRESSPROC) (LPCSTR proc);
+    PFNWGLGETPROCADDRESSPROC fGetProcAddress;
+    typedef BOOL (WINAPI * PFNWGLDELETECONTEXTPROC) (HANDLE hglrc);
+    PFNWGLDELETECONTEXTPROC fDeleteContext;
+
     typedef HANDLE (WINAPI * PFNWGLCREATEPBUFFERPROC) (HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int* piAttribList);
     PFNWGLCREATEPBUFFERPROC fCreatePbuffer;
     typedef BOOL (WINAPI * PFNWGLDESTROYPBUFFERPROC) (HANDLE hPbuffer);
@@ -71,6 +83,23 @@ public:
 };
 
 bool
+WGLWrap::InitEarly()
+{
+    if (fCreateContext)
+        return true;
+
+    SymLoadStruct symbols[] = {
+        { (PRFuncPtr*) &fCreateContext, { "wglCreateContext", NULL } },
+        { (PRFuncPtr*) &fMakeCurrent, { "wglMakeCurrent", NULL } },
+        { (PRFuncPtr*) &fGetProcAddress, { "wglGetProcAddress", NULL } },
+        { (PRFuncPtr*) &fDeleteContext, { "wglDeleteContext", NULL } },
+        { NULL, { NULL } }
+    };
+
+    return LoadSymbols(&symbols[0], false);
+}
+
+bool
 WGLWrap::Init()
 {
     if (fCreatePbuffer)
@@ -99,7 +128,7 @@ nsGLPbufferWGL::nsGLPbufferWGL()
 }
 
 PRBool
-nsGLPbufferWGL::Init(nsCanvasRenderingContextGLPrivate *priv)
+nsGLPbufferWGL::Init(WebGLContext *priv)
 {
     // XXX lookup SYSTEM32 path!
     char *opengl32 = "C:\\WINDOWS\\SYSTEM32\\OPENGL32.DLL";
@@ -107,37 +136,40 @@ nsGLPbufferWGL::Init(nsCanvasRenderingCo
     if (!gWGLWrap.OpenLibrary(opengl32))
         return PR_FALSE;
 
-    gWGLWrap.SetLookupFunc((LibrarySymbolLoader::PlatformLookupFunction) wglGetProcAddress);
+    if (!gWGLWrap.InitEarly())
+        return PR_FALSE;
+
+    gWGLWrap.SetLookupFunc((LibrarySymbolLoader::PlatformLookupFunction) gWGLWrap.fGetProcAddress);
 
     mPriv = priv;
     
-    WNDCLASS wc;
+    WNDCLASSW wc;
     PIXELFORMATDESCRIPTOR pfd;
 
-    if (!GetClassInfo(GetModuleHandle(NULL), "GLEW", &wc)) {
+    if (!GetClassInfoW(GetModuleHandle(NULL), L"GLEW", &wc)) {
         ZeroMemory(&wc, sizeof(WNDCLASS));
         wc.hInstance = GetModuleHandle(NULL);
         wc.lpfnWndProc = DefWindowProc;
-        wc.lpszClassName = "GLEW";
+        wc.lpszClassName = L"GLEW";
 
-        if (!RegisterClass(&wc)) {
-            LogMessage(NS_LITERAL_CSTRING("Canvas 3D: RegisterClass failed"));
+        if (!RegisterClassW(&wc)) {
+            LogMessage("Canvas 3D: RegisterClass failed");
             return PR_FALSE;
         }
     }
 
     // create window
-    mGlewWindow = CreateWindow("GLEW", "GLEW", 0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
-                               CW_USEDEFAULT, NULL, NULL, GetModuleHandle(NULL), NULL);
+    mGlewWindow = CreateWindowW(L"GLEW", L"GLEW", 0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
+                                CW_USEDEFAULT, NULL, NULL, GetModuleHandle(NULL), NULL);
     if (!mGlewWindow) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: CreateWindow failed"));
+        LogMessage("Canvas 3D: CreateWindow failed");
         return PR_FALSE;
     }
 
     // get the device context
     mGlewDC = GetDC(mGlewWindow);
     if (!mGlewDC) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GetDC failed"));
+        LogMessage("Canvas 3D: GetDC failed");
         return PR_FALSE;
     }
 
@@ -150,19 +182,19 @@ nsGLPbufferWGL::Init(nsCanvasRenderingCo
 
     // set the pixel format for the dc
     if (!SetPixelFormat(mGlewDC, pixelformat, &pfd)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: SetPixelFormat failed"));
+        LogMessage("Canvas 3D: SetPixelFormat failed");
         return PR_FALSE;
     }
 
     // create rendering context
-    mGlewWglContext = wglCreateContext(mGlewDC);
+    mGlewWglContext = gWGLWrap.fCreateContext(mGlewDC);
     if (!mGlewWglContext) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: wglCreateContext failed"));
+        LogMessage("Canvas 3D: wglCreateContext failed");
         return PR_FALSE;
     }
 
-    if (!wglMakeCurrent(mGlewDC, (HGLRC) mGlewWglContext)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: wglMakeCurrent failed"));
+    if (!gWGLWrap.fMakeCurrent(mGlewDC, (HGLRC) mGlewWglContext)) {
+        LogMessage("Canvas 3D: wglMakeCurrent failed");
         return PR_FALSE;
     }
 
@@ -173,14 +205,14 @@ nsGLPbufferWGL::Init(nsCanvasRenderingCo
 
     // XXX look up system32 dir
     if (!mGLWrap.OpenLibrary(opengl32)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Failed to open opengl32.dll (only looked in c:\\windows\\system32, fixme)"));
+        LogMessage("Canvas 3D: Failed to open opengl32.dll (only looked in c:\\windows\\system32, fixme)");
         return PR_FALSE;
     }
 
-    mGLWrap.SetLookupFunc((LibrarySymbolLoader::PlatformLookupFunction) wglGetProcAddress);
+    mGLWrap.SetLookupFunc((LibrarySymbolLoader::PlatformLookupFunction) gWGLWrap.fGetProcAddress);
 
     if (!mGLWrap.Init(GLES20Wrap::TRY_NATIVE_GL)) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: GLWrap init failed"));
+        LogMessage("Canvas 3D: GLWrap init failed");
         return PR_FALSE;
     }
 
@@ -212,7 +244,7 @@ nsGLPbufferWGL::Resize(PRInt32 width, PR
     if (NS_FAILED(rv))
         prefAntialiasing = 0;
 
-    mThebesSurface = CanvasGLThebes::CreateImageSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
+    mThebesSurface = new gfxImageSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
     if (mThebesSurface->CairoStatus() != 0) {
         fprintf (stderr, "image surface failed\n");
         return PR_FALSE;
@@ -223,17 +255,17 @@ nsGLPbufferWGL::Resize(PRInt32 width, PR
             0,
             height * mThebesSurface->Stride());
 
-    if (!wglMakeCurrent(mGlewDC, (HGLRC) mGlewWglContext)) {
+    if (!gWGLWrap.fMakeCurrent(mGlewDC, (HGLRC) mGlewWglContext)) {
         fprintf (stderr, "Error: %d\n", GetLastError());
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: wglMakeCurrent failed"));
+        LogMessage("Canvas 3D: wglMakeCurrent failed");
         return PR_FALSE;
     }
 
     PRBool ignoreAA = PR_FALSE;
     int attribs[] = {
-        WGL_SUPPORT_OPENGL_ARB, GL_TRUE,
-        WGL_DRAW_TO_PBUFFER_ARB, GL_TRUE,
-        WGL_DOUBLE_BUFFER_ARB, GL_FALSE,
+        WGL_SUPPORT_OPENGL_ARB, LOCAL_GL_TRUE,
+        WGL_DRAW_TO_PBUFFER_ARB, LOCAL_GL_TRUE,
+        WGL_DOUBLE_BUFFER_ARB, LOCAL_GL_FALSE,
 
         WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,
 
@@ -255,7 +287,7 @@ nsGLPbufferWGL::Resize(PRInt32 width, PR
     // matching formats; so just allocate room for a lot.
 #define MAX_NUM_FORMATS 256
     UINT numFormats = MAX_NUM_FORMATS;
-    nsAutoArrayPtr<int> formats = new int[numFormats];
+    int formats[MAX_NUM_FORMATS];
 
     //fprintf (stderr, "EXT: %p ARB: %p rest: %s\n", wglewGetContext()->__wglewChoosePixelFormatEXT, wglewGetContext()->__wglewChoosePixelFormatARB, wglGetExtensionsStringARB(mGlewDC));
 
@@ -282,7 +314,7 @@ TRY_FIND_AGAIN:
             goto TRY_FIND_AGAIN;
         }
 
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: wglChoosePixelFormat failed (or couldn't find any matching formats)."));
+        LogMessage("Canvas 3D: wglChoosePixelFormat failed (or couldn't find any matching formats).");
         ReleaseDC(NULL, mGlewDC);
         return PR_FALSE;
     }
@@ -334,7 +366,7 @@ TRY_FIND_AGAIN:
     }
 
     if (chosenFormat == -1) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Couldn't find a suitable pixel format!"));
+        LogMessage("Canvas 3D: Couldn't find a suitable pixel format!");
         return PR_FALSE;
     }
     
@@ -344,12 +376,12 @@ TRY_FIND_AGAIN:
     int pbattribs = 0;
     mPbuffer = gWGLWrap.fCreatePbuffer(mGlewDC, chosenFormat, width, height, &pbattribs);
     if (!mPbuffer) {
-        LogMessage(NS_LITERAL_CSTRING("Canvas 3D: Failed to create pbuffer"));
+        LogMessage("Canvas 3D: Failed to create pbuffer");
         return PR_FALSE;
     }
 
     mPbufferDC = gWGLWrap.fGetPbufferDC(mPbuffer);
-    mPbufferContext = wglCreateContext(mPbufferDC);
+    mPbufferContext = gWGLWrap.fCreateContext(mPbufferDC);
 
     mWindowsSurface = new gfxWindowsSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
     if (mWindowsSurface && mWindowsSurface->CairoStatus() == 0)
@@ -369,7 +401,7 @@ nsGLPbufferWGL::Destroy()
     mThebesSurface = nsnull;
 
     if (mPbuffer) {
-        wglDeleteContext((HGLRC) mPbufferContext);
+        gWGLWrap.fDeleteContext((HGLRC) mPbufferContext);
         gWGLWrap.fDestroyPbuffer(mPbuffer);
         mPbuffer = nsnull;
     }
@@ -380,7 +412,7 @@ nsGLPbufferWGL::~nsGLPbufferWGL()
     Destroy();
 
     if (mGlewWglContext) {
-        wglDeleteContext((HGLRC) mGlewWglContext);
+        gWGLWrap.fDeleteContext((HGLRC) mGlewWglContext);
         mGlewWglContext = nsnull;
     }
 
@@ -400,7 +432,7 @@ nsGLPbufferWGL::MakeContextCurrent()
     if (sCurrentContextToken == mPbufferContext)
         return;
 
-    wglMakeCurrent (mPbufferDC, (HGLRC) mPbufferContext);
+    gWGLWrap.fMakeCurrent (mPbufferDC, (HGLRC) mPbufferContext);
     sCurrentContextToken = mPbufferContext;
 }
 
@@ -408,7 +440,7 @@ void
 nsGLPbufferWGL::SwapBuffers()
 {
     MakeContextCurrent();
-    mGLWrap.fReadPixels (0, 0, mWidth, mHeight, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, mThebesSurface->Data());
+    mGLWrap.fReadPixels (0, 0, mWidth, mHeight, LOCAL_GL_BGRA, LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV, mThebesSurface->Data());
 
     // premultiply the image
     int len = mWidth*mHeight*4;
diff -r 5b1fe1bf3872 content/xbl/builtin/Makefile.in
--- a/content/xbl/builtin/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/content/xbl/builtin/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -45,7 +45,7 @@ include $(DEPTH)/config/autoconf.mk
 ifneq (,$(filter OS2 WINNT WINCE,$(OS_ARCH)))
 DIRS	= win
 else
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 DIRS	= mac
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT),gtk2)
diff -r 5b1fe1bf3872 docshell/build/Makefile.in
--- a/docshell/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/docshell/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -122,7 +122,7 @@ LOCAL_INCLUDES	= \
 		-I$(topsrcdir)/uriloader/exthandler \
 		$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LOCAL_INCLUDES += -I$(topsrcdir)/uriloader/exthandler/mac
 EXTRA_DSO_LDOPTS += \
         $(TK_LIBS) \
diff -r 5b1fe1bf3872 dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/dom/base/nsDOMClassInfo.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -439,12 +439,9 @@
 #include "nsIDOMSVGZoomEvent.h"
 #endif // MOZ_SVG
 
-#ifdef MOZ_ENABLE_CANVAS
 #include "nsIDOMCanvasRenderingContext2D.h"
-#ifdef MOZ_ENABLE_CANVAS3D
-#include "nsICanvasRenderingContextGLWeb20.h"
-#endif
-#endif
+#include "nsICanvasRenderingContextWebGL.h"
+#include "WebGLArray.h"
 
 #include "nsIImageDocument.h"
 
@@ -1160,7 +1157,6 @@ static nsDOMClassInfoData sClassInfoData
 
   NS_DEFINE_CLASSINFO_DATA(HTMLCanvasElement, nsHTMLElementSH,
                            ELEMENT_SCRIPTABLE_FLAGS)
-#ifdef MOZ_ENABLE_CANVAS
   NS_DEFINE_CLASSINFO_DATA(CanvasRenderingContext2D, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(CanvasGradient, nsDOMGenericSH,
@@ -1169,7 +1165,6 @@ static nsDOMClassInfoData sClassInfoData
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(TextMetrics, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
-#endif // MOZ_ENABLE_CANVAS
 
   NS_DEFINE_CLASSINFO_DATA(SmartCardEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
@@ -1339,10 +1334,43 @@ static nsDOMClassInfoData sClassInfoData
   NS_DEFINE_CLASSINFO_DATA(PaintRequestList, nsPaintRequestListSH,
                            ARRAY_SCRIPTABLE_FLAGS)
 
-#ifdef MOZ_ENABLE_CANVAS3D
-  NS_DEFINE_CLASSINFO_DATA(CanvasRenderingContextGLWeb20, nsDOMGenericSH,
-                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
-#endif
+  NS_DEFINE_CLASSINFO_DATA(CanvasRenderingContextWebGL, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLBuffer, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLTexture, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLProgram, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLShader, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLFramebuffer, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLRenderbuffer, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLArrayBuffer, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(WebGLFloatArray, nsDOMGenericSH,
+                           nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE |
+                           nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
+  NS_DEFINE_CLASSINFO_DATA(WebGLByteArray, nsDOMGenericSH,
+                           nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE |
+                           nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
+  NS_DEFINE_CLASSINFO_DATA(WebGLUnsignedByteArray, nsDOMGenericSH,
+                           nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE |
+                           nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
+  NS_DEFINE_CLASSINFO_DATA(WebGLShortArray, nsDOMGenericSH,
+                           nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE |
+                           nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
+  NS_DEFINE_CLASSINFO_DATA(WebGLUnsignedShortArray, nsDOMGenericSH,
+                           nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE |
+                           nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
+  NS_DEFINE_CLASSINFO_DATA(WebGLIntArray, nsDOMGenericSH,
+                           nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE |
+                           nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
+  NS_DEFINE_CLASSINFO_DATA(WebGLUnsignedIntArray, nsDOMGenericSH,
+                           nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE |
+                           nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY)
 
   NS_DEFINE_CLASSINFO_DATA(ScrollAreaEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
@@ -1383,6 +1411,16 @@ struct nsConstructorFuncMapData
 static const nsConstructorFuncMapData kConstructorFuncMap[] =
 {
   NS_DEFINE_CONSTRUCTOR_FUNC_DATA(Worker, nsDOMWorker::NewWorker)
+
+  // WebGL Array Types
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLArrayBuffer, NS_NewWebGLArrayBuffer)
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLFloatArray, NS_NewWebGLFloatArray)
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLByteArray, NS_NewWebGLByteArray)
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLUnsignedByteArray, NS_NewWebGLUnsignedByteArray)
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLShortArray, NS_NewWebGLShortArray)
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLUnsignedShortArray, NS_NewWebGLUnsignedShortArray)
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLIntArray, NS_NewWebGLIntArray)
+  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(WebGLUnsignedIntArray, NS_NewWebGLUnsignedIntArray)
 };
 
 nsIXPConnect *nsDOMClassInfo::sXPConnect = nsnull;
@@ -3431,7 +3469,6 @@ nsDOMClassInfo::Init()
     DOM_CLASSINFO_GENERIC_HTML_MAP_ENTRIES
   DOM_CLASSINFO_MAP_END
 
-#ifdef MOZ_ENABLE_CANVAS
   DOM_CLASSINFO_MAP_BEGIN(CanvasRenderingContext2D, nsIDOMCanvasRenderingContext2D)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMCanvasRenderingContext2D)
   DOM_CLASSINFO_MAP_END
@@ -3447,7 +3484,6 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_BEGIN(TextMetrics, nsIDOMTextMetrics)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMTextMetrics)
   DOM_CLASSINFO_MAP_END
-#endif // MOZ_ENABLE_CANVAS
 
   DOM_CLASSINFO_MAP_BEGIN(XSLTProcessor, nsIXSLTProcessor)
     DOM_CLASSINFO_MAP_ENTRY(nsIXSLTProcessor)
@@ -3700,12 +3736,65 @@ nsDOMClassInfo::Init()
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMPaintRequestList)
   DOM_CLASSINFO_MAP_END
 
-#ifdef MOZ_ENABLE_CANVAS3D
-  DOM_CLASSINFO_MAP_BEGIN(CanvasRenderingContextGLWeb20, nsICanvasRenderingContextGLWeb20)
-    DOM_CLASSINFO_MAP_ENTRY(nsICanvasRenderingContextGLWeb20)
-    DOM_CLASSINFO_MAP_ENTRY(nsICanvasRenderingContextGL)
-  DOM_CLASSINFO_MAP_END
-#endif
+  DOM_CLASSINFO_MAP_BEGIN(CanvasRenderingContextWebGL, nsICanvasRenderingContextWebGL)
+    DOM_CLASSINFO_MAP_ENTRY(nsICanvasRenderingContextWebGL)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLBuffer, nsIWebGLBuffer)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLBuffer)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLTexture, nsIWebGLTexture)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLTexture)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLProgram, nsIWebGLProgram)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLProgram)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLShader, nsIWebGLShader)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLShader)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLFramebuffer, nsIWebGLFramebuffer)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLFramebuffer)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLRenderbuffer, nsIWebGLRenderbuffer)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLRenderbuffer)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLArrayBuffer, nsIWebGLArrayBuffer)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLArrayBuffer)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLFloatArray, nsIWebGLFloatArray)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLFloatArray)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLByteArray, nsIWebGLByteArray)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLByteArray)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLUnsignedByteArray, nsIWebGLUnsignedByteArray)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLUnsignedByteArray)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLShortArray, nsIWebGLShortArray)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLShortArray)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLUnsignedShortArray, nsIWebGLUnsignedShortArray)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLUnsignedShortArray)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLIntArray, nsIWebGLIntArray)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLIntArray)
+  DOM_CLASSINFO_MAP_END
+
+  DOM_CLASSINFO_MAP_BEGIN(WebGLUnsignedIntArray, nsIWebGLUnsignedIntArray)
+    DOM_CLASSINFO_MAP_ENTRY(nsIWebGLUnsignedIntArray)
+  DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(ScrollAreaEvent, nsIDOMScrollAreaEvent)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMScrollAreaEvent)
diff -r 5b1fe1bf3872 dom/base/nsDOMClassInfoID.h
--- a/dom/base/nsDOMClassInfoID.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/dom/base/nsDOMClassInfoID.h	Fri Dec 11 07:09:00 2009 +0200
@@ -354,12 +354,10 @@ enum nsDOMClassInfoID {
 
   // Canvas
   eDOMClassInfo_HTMLCanvasElement_id,
-#ifdef MOZ_ENABLE_CANVAS
   eDOMClassInfo_CanvasRenderingContext2D_id,
   eDOMClassInfo_CanvasGradient_id,
   eDOMClassInfo_CanvasPattern_id,
   eDOMClassInfo_TextMetrics_id,
-#endif
 
   // SmartCard Events
   eDOMClassInfo_SmartCardEvent_id,
@@ -468,9 +466,24 @@ enum nsDOMClassInfoID {
   eDOMClassInfo_PaintRequest_id,
   eDOMClassInfo_PaintRequestList_id,
 
-#ifdef MOZ_ENABLE_CANVAS3D
-  eDOMClassInfo_CanvasRenderingContextGLWeb20_id,
-#endif
+  // WebGL
+  eDOMClassInfo_CanvasRenderingContextWebGL_id,
+  eDOMClassInfo_WebGLBuffer_id,
+  eDOMClassInfo_WebGLTexture_id,
+  eDOMClassInfo_WebGLProgram_id,
+  eDOMClassInfo_WebGLShader_id,
+  eDOMClassInfo_WebGLFramebuffer_id,
+  eDOMClassInfo_WebGLRenderbuffer_id,
+
+  // WebGL Buffers
+  eDOMClassInfo_WebGLArrayBuffer_id,
+  eDOMClassInfo_WebGLFloatArray_id,
+  eDOMClassInfo_WebGLByteArray_id,
+  eDOMClassInfo_WebGLUnsignedByteArray_id,
+  eDOMClassInfo_WebGLShortArray_id,
+  eDOMClassInfo_WebGLUnsignedShortArray_id,
+  eDOMClassInfo_WebGLIntArray_id,
+  eDOMClassInfo_WebGLUnsignedIntArray_id,
 
   eDOMClassInfo_ScrollAreaEvent_id,
 
diff -r 5b1fe1bf3872 dom/interfaces/canvas/Makefile.in
--- a/dom/interfaces/canvas/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/dom/interfaces/canvas/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -46,14 +46,9 @@ MODULE		= dom
 XPIDL_MODULE	= dom_canvas
 GRE_MODULE	= 1
 
-XPIDLSRCS = nsIDOMCanvasRenderingContext2D.idl
-
-ifdef MOZ_ENABLE_CANVAS3D
-XPIDLSRCS += \
-	nsICanvasRenderingContextGL.idl		\
-	nsICanvasRenderingContextGLBuffer.idl	\
-	nsICanvasRenderingContextGLWeb20.idl	\
+XPIDLSRCS = \
+	nsIDOMCanvasRenderingContext2D.idl \
+	nsICanvasRenderingContextWebGL.idl \
 	$(NULL)
-endif
 
 include $(topsrcdir)/config/rules.mk
diff -r 5b1fe1bf3872 dom/interfaces/canvas/nsICanvasRenderingContextWebGL.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/interfaces/canvas/nsICanvasRenderingContextWebGL.idl	Fri Dec 11 07:09:00 2009 +0200
@@ -0,0 +1,942 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is canvas 3D.
+ *
+ * The Initial Developer of the Original Code is
+ *   Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Vladimir Vukicevic <vladimir@pobox.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsISupports.idl"
+
+interface nsIDOMHTMLCanvasElement;
+
+// XXX should we comment out these typedefs in the C++ header?
+
+typedef unsigned long  GLenum;
+typedef octet  GLboolean;
+typedef unsigned long  GLbitfield;
+typedef short          GLshort;
+typedef long           GLint;
+typedef long           GLsizei;
+typedef octet          GLubyte;
+typedef unsigned short GLushort;
+typedef unsigned long  GLuint;
+typedef float          GLfloat;
+typedef float          GLclampf;
+typedef long           GLfixed;
+
+// XPIDL doesn't have a signed byte?
+//typedef signed octet GLbyte;
+
+//typedef unsigned long  GLintptr;
+typedef long  GLsizeiptr;
+
+%{C++
+namespace mozilla {
+    class WebGLArrayBuffer;
+}
+%}
+[ptr] native WebGLArrayBufferPtr (mozilla::WebGLArrayBuffer);
+//
+// Array types
+//
+[scriptable, uuid(34b6cf8e-47da-458e-ab42-0451a3533ee5)]
+interface nsIWebGLArrayBuffer : nsISupports
+{
+  readonly attribute unsigned long byteLength;
+
+  [noscript, notxpcom] WebGLArrayBufferPtr GetNativeArrayBuffer();
+  [noscript, notxpcom] voidPtr nativePointer();
+  [noscript, notxpcom] unsigned long nativeSize();
+};
+
+[scriptable, uuid(84ba4e98-8173-7c10-dca0-b5ba7809fcf3)]
+interface nsIWebGLArray : nsISupports
+{
+  readonly attribute nsIWebGLArrayBuffer buffer;
+  readonly attribute unsigned long byteOffset;
+  readonly attribute unsigned long byteLength;
+  readonly attribute unsigned long length;
+
+  // XXX kill this.
+  unsigned long alignedSizeInBytes();
+
+  nsIWebGLArray slice(in unsigned long offset, in unsigned long length);
+
+  [noscript, notxpcom] unsigned long nativeType();
+  [noscript, notxpcom] voidPtr nativePointer();
+  [noscript, notxpcom] unsigned long nativeSize();
+  [noscript, notxpcom] unsigned long nativeElementSize();
+  [noscript, notxpcom] unsigned long nativeCount();
+};
+
+[scriptable, Uuid(0f6d0e7b-bcfc-9305-6a1d-a9653b5e8c80)]
+interface nsIWebGLFloatArray : nsIWebGLArray
+{
+  [IndexGetter] float get(in unsigned long index);
+  //[IndexSetter] void set(in unsigned long index, in float value);
+  //void set(in CanvasFloatArray array, [Optional] in unsigned long offset);
+  //void set(in sequence<float> array, [Optional] in unsigned long offset);
+  void set();
+};
+
+[scriptable, uuid(b29db7cf-fa58-435f-8d45-611cc50979ad)]
+interface nsIWebGLByteArray : nsIWebGLArray
+{
+  [IndexGetter] long get(in unsigned long index);
+  //[IndexSetter] void set(in unsigned long index, in long value);
+  //void set(in nsIWebGLByteArray array, [Optional] in unsigned long offset);
+  //void set(in sequence<long> array, [Optional] in unsigned long offset);
+  void set();
+};
+
+[scriptable, uuid(3daa67fa-e743-2cbd-a212-805c2fc520cc)]
+interface nsIWebGLUnsignedByteArray : nsIWebGLArray
+{
+  [IndexGetter] unsigned long get(in unsigned long index);
+  //[IndexSetter] void set(in unsigned long index, in unsigned long value);
+  //void set(in CanvasUnsignedByteArray array, [Optional] in unsigned long offset);
+  //void set(in sequence<unsigned long> array, [Optional] in unsigned long offset);
+  void set();
+};
+
+[scriptable, uuid(a8a982e3-3977-7364-f012-c497a5ab7681)]
+interface nsIWebGLShortArray : nsIWebGLArray
+{
+  [IndexGetter] long get(in unsigned long index);
+  //[IndexSetter] void set(in unsigned long index, in long value);
+  //void set(in CanvasShortArray array, [Optional] in unsigned long offset);
+  //void set(in sequence<long> array, [Optional] in unsigned long offset);
+  void set();
+};
+
+[scriptable, uuid(8b9c67cc-c7be-a062-84b0-76a910a5c1e6)]
+interface nsIWebGLUnsignedShortArray : nsIWebGLArray
+{
+  [IndexGetter] unsigned long get(in unsigned long index);
+  //[IndexSetter] void set(in unsigned long index, in unsigned long value);
+  //void set(in CanvasUnsignedShortArray array, [Optional] in unsigned long offset);
+  //void set(in sequence<unsigned long> array, [Optional] in unsigned long offset);
+  void set();
+};
+
+[scriptable, uuid(b9b2e861-3a28-4311-993c-799e4f77dcba)]
+interface nsIWebGLIntArray : nsIWebGLArray
+{
+  [IndexGetter] long get(in unsigned long index);
+  //[IndexSetter] void set(in unsigned long index, in long value);
+  //void set(in CanvasIntArray array, [Optional] in unsigned long offset);
+  //void set(in sequence<long> array, [Optional] in unsigned long offset);
+  void set();
+};
+
+[scriptable, uuid(0d6ee3f8-71b6-460d-b05a-d579cc55edbe)]
+interface nsIWebGLUnsignedIntArray : nsIWebGLArray
+{
+  [IndexGetter] unsigned long get(in unsigned long index);
+  //[IndexSetter] void set(in unsigned long index, in unsigned long value);
+  //void set(in CanvasUnsignedIntArray array, [Optional] in unsigned long offset);
+  //void set(in sequence<unsigned long> array, [Optional] in unsigned long offset);
+  void set();
+};
+
+//
+// OpenGL object wrappers
+//
+
+[scriptable, uuid(3b43762a-8305-11de-98ab-000c29206271)]
+interface nsIWebGLTexture : nsISupports
+{
+  [noscript] attribute GLuint name;
+};
+
+[scriptable, uuid(9eca9c32-8305-11de-b89b-000c29206271)]
+interface nsIWebGLBuffer : nsISupports
+{
+  [noscript] attribute GLuint name;
+};
+
+[scriptable, uuid(a6a19e74-8305-11de-9ce9-000c29206271)]
+interface nsIWebGLProgram : nsISupports
+{
+  [noscript] attribute GLuint name;
+};
+
+[scriptable, uuid(ac7440a4-8305-11de-807b-000c29206271)]
+interface nsIWebGLShader : nsISupports
+{
+  [noscript] attribute GLuint name;
+};
+
+[scriptable, uuid(beea4b38-3094-4e8d-b6e6-8b21d07e8994)]
+interface nsIWebGLShaderArray {
+    readonly attribute unsigned long length;
+    nsIWebGLShader item(in unsigned long index);
+};
+
+[scriptable, uuid(bce8be60-8305-11de-9f3c-000c29206271)]
+interface nsIWebGLFramebuffer : nsISupports
+{
+  [noscript] attribute GLuint name;
+};
+
+[scriptable, uuid(c82eacd0-8305-11de-9de9-000c29206271)]
+interface nsIWebGLRenderbuffer : nsISupports
+{
+  [noscript] attribute GLuint name;
+};
+
+[scriptable, uuid(a85d4fd0-5b9f-4cb8-aeee-5a2c5c5bad76)]
+interface nsIWebGLActiveInfo {
+    readonly attribute GLint size;
+    readonly attribute GLenum type;
+    readonly attribute DOMString name;
+};
+
+
+[scriptable, uuid(f02c85e0-8305-11de-abe2-000c29206271)]
+interface nsICanvasRenderingContextWebGL : nsISupports
+{
+  //
+  //  ARRAY CONSTRUCTORS
+  //
+
+  nsIWebGLFloatArray createFloatArray();
+  nsIWebGLByteArray createByteArray();
+  nsIWebGLUnsignedByteArray createUnsignedByteArray();
+  nsIWebGLShortArray createShortArray();
+  nsIWebGLUnsignedShortArray createUnsignedShortArray();
+  nsIWebGLIntArray createIntArray();
+  nsIWebGLUnsignedIntArray createUnsignedIntArray();
+
+  //
+  //  CONSTANTS
+  //
+
+  /* ClearBufferMask */
+  const unsigned long DEPTH_BUFFER_BIT               = 0x00000100;
+  const unsigned long STENCIL_BUFFER_BIT             = 0x00000400;
+  const unsigned long COLOR_BUFFER_BIT               = 0x00004000;
+
+  /* Boolean */
+  // XXX are these legal?
+  const unsigned long GL_FALSE                          = 0;
+  const unsigned long GL_TRUE                           = 1;
+
+  /* BeginMode */
+  const unsigned long POINTS                         = 0x0000;
+  const unsigned long LINES                          = 0x0001;
+  const unsigned long LINE_LOOP                      = 0x0002;
+  const unsigned long LINE_STRIP                     = 0x0003;
+  const unsigned long TRIANGLES                      = 0x0004;
+  const unsigned long TRIANGLE_STRIP                 = 0x0005;
+  const unsigned long TRIANGLE_FAN                   = 0x0006;
+
+  /* AlphaFunction (not supported in ES20) */
+  /*      GL_NEVER */
+  /*      GL_LESS */
+  /*      GL_EQUAL */
+  /*      GL_LEQUAL */
+  /*      GL_GREATER */
+  /*      GL_NOTEQUAL */
+  /*      GL_GEQUAL */
+  /*      GL_ALWAYS */
+
+  /* BlendingFactorDest */
+  const unsigned long ZERO                           = 0;
+  const unsigned long ONE                            = 1;
+  const unsigned long SRC_COLOR                      = 0x0300;
+  const unsigned long ONE_MINUS_SRC_COLOR            = 0x0301;
+  const unsigned long SRC_ALPHA                      = 0x0302;
+  const unsigned long ONE_MINUS_SRC_ALPHA            = 0x0303;
+  const unsigned long DST_ALPHA                      = 0x0304;
+  const unsigned long ONE_MINUS_DST_ALPHA            = 0x0305;
+
+  /* BlendingFactorSrc */
+  /*      GL_ZERO */
+  /*      GL_ONE */
+  const unsigned long DST_COLOR                      = 0x0306;
+  const unsigned long ONE_MINUS_DST_COLOR            = 0x0307;
+  const unsigned long SRC_ALPHA_SATURATE             = 0x0308;
+  /*      GL_SRC_ALPHA */
+  /*      GL_ONE_MINUS_SRC_ALPHA */
+  /*      GL_DST_ALPHA */
+  /*      GL_ONE_MINUS_DST_ALPHA */
+
+  /* BlendEquationSeparate */
+  const unsigned long FUNC_ADD                       = 0x8006;
+  const unsigned long BLEND_EQUATION                 = 0x8009;
+  const unsigned long BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
+  const unsigned long BLEND_EQUATION_ALPHA           = 0x883D;
+
+  /* BlendSubtract */
+  const unsigned long FUNC_SUBTRACT                  = 0x800A;
+  const unsigned long FUNC_REVERSE_SUBTRACT          = 0x800B;
+
+  /* Separate Blend Functions */
+  const unsigned long BLEND_DST_RGB                  = 0x80C8;
+  const unsigned long BLEND_SRC_RGB                  = 0x80C9;
+  const unsigned long BLEND_DST_ALPHA                = 0x80CA;
+  const unsigned long BLEND_SRC_ALPHA                = 0x80CB;
+  const unsigned long CONSTANT_COLOR                 = 0x8001;
+  const unsigned long ONE_MINUS_CONSTANT_COLOR       = 0x8002;
+  const unsigned long CONSTANT_ALPHA                 = 0x8003;
+  const unsigned long ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
+  const unsigned long BLEND_COLOR                    = 0x8005;
+
+  /* Buffer Objects */
+  const unsigned long ARRAY_BUFFER                   = 0x8892;
+  const unsigned long ELEMENT_ARRAY_BUFFER           = 0x8893;
+  const unsigned long ARRAY_BUFFER_BINDING           = 0x8894;
+  const unsigned long ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;
+
+  const unsigned long STREAM_DRAW                    = 0x88E0;
+  const unsigned long STATIC_DRAW                    = 0x88E4;
+  const unsigned long DYNAMIC_DRAW                   = 0x88E8;
+
+  const unsigned long BUFFER_SIZE                    = 0x8764;
+  const unsigned long BUFFER_USAGE                   = 0x8765;
+
+  const unsigned long CURRENT_VERTEX_ATTRIB          = 0x8626;
+
+  /* CullFaceMode */
+  const unsigned long FRONT                          = 0x0404;
+  const unsigned long BACK                           = 0x0405;
+  const unsigned long FRONT_AND_BACK                 = 0x0408;
+
+  /* DepthFunction */
+  /*      GL_NEVER */
+  /*      GL_LESS */
+  /*      GL_EQUAL */
+  /*      GL_LEQUAL */
+  /*      GL_GREATER */
+  /*      GL_NOTEQUAL */
+  /*      GL_GEQUAL */
+  /*      GL_ALWAYS */
+
+  /* EnableCap */
+  const unsigned long TEXTURE_2D                     = 0x0DE1;
+  const unsigned long CULL_FACE                      = 0x0B44;
+  const unsigned long BLEND                          = 0x0BE2;
+  const unsigned long DITHER                         = 0x0BD0;
+  const unsigned long STENCIL_TEST                   = 0x0B90;
+  const unsigned long DEPTH_TEST                     = 0x0B71;
+  const unsigned long SCISSOR_TEST                   = 0x0C11;
+  const unsigned long POLYGON_OFFSET_FILL            = 0x8037;
+  const unsigned long SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
+  const unsigned long SAMPLE_COVERAGE                = 0x80A0;
+
+  /* ErrorCode */
+%{C++
+/* Avoid conflict with WinAPI */
+#undef NO_ERROR
+%}
+  const unsigned long NO_ERROR                       = 0;
+  const unsigned long INVALID_ENUM                   = 0x0500;
+  const unsigned long INVALID_VALUE                  = 0x0501;
+  const unsigned long INVALID_OPERATION              = 0x0502;
+  const unsigned long OUT_OF_MEMORY                  = 0x0505;
+
+  /* FrontFaceDirection */
+  const unsigned long CW                             = 0x0900;
+  const unsigned long CCW                            = 0x0901;
+
+  /* GetPName */
+  const unsigned long LINE_WIDTH                     = 0x0B21;
+  const unsigned long ALIASED_POINT_SIZE_RANGE       = 0x846D;
+  const unsigned long ALIASED_LINE_WIDTH_RANGE       = 0x846E;
+  const unsigned long CULL_FACE_MODE                 = 0x0B45;
+  const unsigned long FRONT_FACE                     = 0x0B46;
+  const unsigned long DEPTH_RANGE                    = 0x0B70;
+  const unsigned long DEPTH_WRITEMASK                = 0x0B72;
+  const unsigned long DEPTH_CLEAR_VALUE              = 0x0B73;
+  const unsigned long DEPTH_FUNC                     = 0x0B74;
+  const unsigned long STENCIL_CLEAR_VALUE            = 0x0B91;
+  const unsigned long STENCIL_FUNC                   = 0x0B92;
+  const unsigned long STENCIL_FAIL                   = 0x0B94;
+  const unsigned long STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
+  const unsigned long STENCIL_PASS_DEPTH_PASS        = 0x0B96;
+  const unsigned long STENCIL_REF                    = 0x0B97;
+  const unsigned long STENCIL_VALUE_MASK             = 0x0B93;
+  const unsigned long STENCIL_WRITEMASK              = 0x0B98;
+  const unsigned long STENCIL_BACK_FUNC              = 0x8800;
+  const unsigned long STENCIL_BACK_FAIL              = 0x8801;
+  const unsigned long STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
+  const unsigned long STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
+  const unsigned long STENCIL_BACK_REF               = 0x8CA3;
+  const unsigned long STENCIL_BACK_VALUE_MASK        = 0x8CA4;
+  const unsigned long STENCIL_BACK_WRITEMASK         = 0x8CA5;
+  const unsigned long VIEWPORT_RECT                  = 0x0BA2;
+  const unsigned long SCISSOR_BOX                    = 0x0C10;
+  /*      GL_SCISSOR_TEST */
+  const unsigned long COLOR_CLEAR_VALUE              = 0x0C22;
+  const unsigned long COLOR_WRITEMASK                = 0x0C23;
+  const unsigned long UNPACK_ALIGNMENT               = 0x0CF5;
+  const unsigned long PACK_ALIGNMENT                 = 0x0D05;
+  const unsigned long MAX_TEXTURE_SIZE               = 0x0D33;
+  const unsigned long MAX_VIEWPORT_DIMS              = 0x0D3A;
+  const unsigned long SUBPIXEL_BITS                  = 0x0D50;
+  const unsigned long RED_BITS                       = 0x0D52;
+  const unsigned long GREEN_BITS                     = 0x0D53;
+  const unsigned long BLUE_BITS                      = 0x0D54;
+  const unsigned long ALPHA_BITS                     = 0x0D55;
+  const unsigned long DEPTH_BITS                     = 0x0D56;
+  const unsigned long STENCIL_BITS                   = 0x0D57;
+  const unsigned long POLYGON_OFFSET_UNITS           = 0x2A00;
+  /*      GL_POLYGON_OFFSET_FILL */
+  const unsigned long POLYGON_OFFSET_FACTOR          = 0x8038;
+  const unsigned long TEXTURE_BINDING_2D             = 0x8069;
+  const unsigned long SAMPLE_BUFFERS                 = 0x80A8;
+  const unsigned long SAMPLES                        = 0x80A9;
+  const unsigned long SAMPLE_COVERAGE_VALUE          = 0x80AA;
+  const unsigned long SAMPLE_COVERAGE_INVERT         = 0x80AB;
+
+  /* GetTextureParameter */
+  /*      GL_TEXTURE_MAG_FILTER */
+  /*      GL_TEXTURE_MIN_FILTER */
+  /*      GL_TEXTURE_WRAP_S */
+  /*      GL_TEXTURE_WRAP_T */
+
+  const unsigned long NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
+  const unsigned long COMPRESSED_TEXTURE_FORMATS     = 0x86A3;
+
+  /* HintMode */
+  const unsigned long DONT_CARE                      = 0x1100;
+  const unsigned long FASTEST                        = 0x1101;
+  const unsigned long NICEST                         = 0x1102;
+
+  /* HintTarget */
+  const unsigned long GENERATE_MIPMAP_HINT            = 0x8192;
+
+  /* DataType */
+  const unsigned long BYTE                           = 0x1400;
+  const unsigned long UNSIGNED_BYTE                  = 0x1401;
+  const unsigned long SHORT                          = 0x1402;
+  const unsigned long UNSIGNED_SHORT                 = 0x1403;
+  const unsigned long INT                            = 0x1404;
+  const unsigned long UNSIGNED_INT                   = 0x1405;
+  const unsigned long FLOAT                          = 0x1406;
+  const unsigned long FIXED                          = 0x140C;
+
+  /* PixelFormat */
+  const unsigned long DEPTH_COMPONENT                = 0x1902;
+  const unsigned long ALPHA                          = 0x1906;
+  const unsigned long RGB                            = 0x1907;
+  const unsigned long RGBA                           = 0x1908;
+  const unsigned long LUMINANCE                      = 0x1909;
+  const unsigned long LUMINANCE_ALPHA                = 0x190A;
+
+  /* PixelType */
+  /*      GL_UNSIGNED_BYTE */
+  const unsigned long UNSIGNED_SHORT_4_4_4_4         = 0x8033;
+  const unsigned long UNSIGNED_SHORT_5_5_5_1         = 0x8034;
+  const unsigned long UNSIGNED_SHORT_5_6_5           = 0x8363;
+
+  /* Shaders */
+  const unsigned long FRAGMENT_SHADER                  = 0x8B30;
+  const unsigned long VERTEX_SHADER                    = 0x8B31;
+  const unsigned long MAX_VERTEX_ATTRIBS               = 0x8869;
+  const unsigned long MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
+  const unsigned long MAX_VARYING_VECTORS              = 0x8DFC;
+  const unsigned long MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
+  const unsigned long MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
+  const unsigned long MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
+  const unsigned long MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
+  const unsigned long SHADER_TYPE                      = 0x8B4F;
+  const unsigned long DELETE_STATUS                    = 0x8B80;
+  const unsigned long LINK_STATUS                      = 0x8B82;
+  const unsigned long VALIDATE_STATUS                  = 0x8B83;
+  const unsigned long ATTACHED_SHADERS                 = 0x8B85;
+  const unsigned long ACTIVE_UNIFORMS                  = 0x8B86;
+  const unsigned long ACTIVE_UNIFORM_MAX_LENGTH        = 0x8B87;
+  const unsigned long ACTIVE_ATTRIBUTES                = 0x8B89;
+  const unsigned long ACTIVE_ATTRIBUTE_MAX_LENGTH      = 0x8B8A;
+  const unsigned long SHADING_LANGUAGE_VERSION         = 0x8B8C;
+  const unsigned long CURRENT_PROGRAM                  = 0x8B8D;
+
+  /* StencilFunction */
+  const unsigned long NEVER                          = 0x0200;
+  const unsigned long LESS                           = 0x0201;
+  const unsigned long EQUAL                          = 0x0202;
+  const unsigned long LEQUAL                         = 0x0203;
+  const unsigned long GREATER                        = 0x0204;
+  const unsigned long NOTEQUAL                       = 0x0205;
+  const unsigned long GEQUAL                         = 0x0206;
+  const unsigned long ALWAYS                         = 0x0207;
+
+  /* StencilOp */
+  /*      GL_ZERO */
+  const unsigned long KEEP                           = 0x1E00;
+  const unsigned long REPLACE                        = 0x1E01;
+  const unsigned long INCR                           = 0x1E02;
+  const unsigned long DECR                           = 0x1E03;
+  const unsigned long INVERT                         = 0x150A;
+  const unsigned long INCR_WRAP                      = 0x8507;
+  const unsigned long DECR_WRAP                      = 0x8508;
+
+  /* StringName */
+  const unsigned long VENDOR                         = 0x1F00;
+  const unsigned long RENDERER                       = 0x1F01;
+  const unsigned long VERSION                        = 0x1F02;
+  const unsigned long EXTENSIONS                     = 0x1F03;
+
+  /* TextureMagFilter */
+  const unsigned long NEAREST                        = 0x2600;
+  const unsigned long LINEAR                         = 0x2601;
+
+  /* TextureMinFilter */
+  /*      GL_NEAREST */
+  /*      GL_LINEAR */
+  const unsigned long NEAREST_MIPMAP_NEAREST         = 0x2700;
+  const unsigned long LINEAR_MIPMAP_NEAREST          = 0x2701;
+  const unsigned long NEAREST_MIPMAP_LINEAR          = 0x2702;
+  const unsigned long LINEAR_MIPMAP_LINEAR           = 0x2703;
+
+  /* TextureParameterName */
+  const unsigned long TEXTURE_MAG_FILTER             = 0x2800;
+  const unsigned long TEXTURE_MIN_FILTER             = 0x2801;
+  const unsigned long TEXTURE_WRAP_S                 = 0x2802;
+  const unsigned long TEXTURE_WRAP_T                 = 0x2803;
+
+  /* TextureTarget */
+  /*      GL_TEXTURE_2D */
+  const unsigned long TEXTURE                        = 0x1702;
+
+  const unsigned long TEXTURE_CUBE_MAP               = 0x8513;
+  const unsigned long TEXTURE_BINDING_CUBE_MAP       = 0x8514;
+  const unsigned long TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
+  const unsigned long TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
+  const unsigned long TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
+  const unsigned long TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
+  const unsigned long TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
+  const unsigned long TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
+  const unsigned long MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;
+
+  /* TextureUnit */
+  const unsigned long TEXTURE0                       = 0x84C0;
+  const unsigned long TEXTURE1                       = 0x84C1;
+  const unsigned long TEXTURE2                       = 0x84C2;
+  const unsigned long TEXTURE3                       = 0x84C3;
+  const unsigned long TEXTURE4                       = 0x84C4;
+  const unsigned long TEXTURE5                       = 0x84C5;
+  const unsigned long TEXTURE6                       = 0x84C6;
+  const unsigned long TEXTURE7                       = 0x84C7;
+  const unsigned long TEXTURE8                       = 0x84C8;
+  const unsigned long TEXTURE9                       = 0x84C9;
+  const unsigned long TEXTURE10                      = 0x84CA;
+  const unsigned long TEXTURE11                      = 0x84CB;
+  const unsigned long TEXTURE12                      = 0x84CC;
+  const unsigned long TEXTURE13                      = 0x84CD;
+  const unsigned long TEXTURE14                      = 0x84CE;
+  const unsigned long TEXTURE15                      = 0x84CF;
+  const unsigned long TEXTURE16                      = 0x84D0;
+  const unsigned long TEXTURE17                      = 0x84D1;
+  const unsigned long TEXTURE18                      = 0x84D2;
+  const unsigned long TEXTURE19                      = 0x84D3;
+  const unsigned long TEXTURE20                      = 0x84D4;
+  const unsigned long TEXTURE21                      = 0x84D5;
+  const unsigned long TEXTURE22                      = 0x84D6;
+  const unsigned long TEXTURE23                      = 0x84D7;
+  const unsigned long TEXTURE24                      = 0x84D8;
+  const unsigned long TEXTURE25                      = 0x84D9;
+  const unsigned long TEXTURE26                      = 0x84DA;
+  const unsigned long TEXTURE27                      = 0x84DB;
+  const unsigned long TEXTURE28                      = 0x84DC;
+  const unsigned long TEXTURE29                      = 0x84DD;
+  const unsigned long TEXTURE30                      = 0x84DE;
+  const unsigned long TEXTURE31                      = 0x84DF;
+  const unsigned long ACTIVE_TEXTURE                 = 0x84E0;
+
+  /* TextureWrapMode */
+  const unsigned long REPEAT                         = 0x2901;
+  const unsigned long CLAMP_TO_EDGE                  = 0x812F;
+  const unsigned long MIRRORED_REPEAT                = 0x8370;
+
+  /* Uniform Types */
+  const unsigned long FLOAT_VEC2                     = 0x8B50;
+  const unsigned long FLOAT_VEC3                     = 0x8B51;
+  const unsigned long FLOAT_VEC4                     = 0x8B52;
+  const unsigned long INT_VEC2                       = 0x8B53;
+  const unsigned long INT_VEC3                       = 0x8B54;
+  const unsigned long INT_VEC4                       = 0x8B55;
+  const unsigned long BOOL                           = 0x8B56;
+  const unsigned long BOOL_VEC2                      = 0x8B57;
+  const unsigned long BOOL_VEC3                      = 0x8B58;
+  const unsigned long BOOL_VEC4                      = 0x8B59;
+  const unsigned long FLOAT_MAT2                     = 0x8B5A;
+  const unsigned long FLOAT_MAT3                     = 0x8B5B;
+  const unsigned long FLOAT_MAT4                     = 0x8B5C;
+  const unsigned long SAMPLER_2D                     = 0x8B5E;
+  const unsigned long SAMPLER_CUBE                   = 0x8B60;
+
+  /* Vertex Arrays */
+  const unsigned long VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
+  const unsigned long VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
+  const unsigned long VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
+  const unsigned long VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
+  const unsigned long VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
+  const unsigned long VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
+  const unsigned long VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
+
+  /* Read Format */
+  const unsigned long IMPLEMENTATION_COLOR_READ_TYPE   = 0x8B9A;
+  const unsigned long IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;
+
+  /* Shader Source */
+  const unsigned long COMPILE_STATUS                 = 0x8B81;
+  const unsigned long INFO_LOG_LENGTH                = 0x8B84;
+  const unsigned long SHADER_SOURCE_LENGTH           = 0x8B88;
+  const unsigned long SHADER_COMPILER                = 0x8DFA;
+
+  /* Shader Precision-Specified Types */
+  const unsigned long LOW_FLOAT                      = 0x8DF0;
+  const unsigned long MEDIUM_FLOAT                   = 0x8DF1;
+  const unsigned long HIGH_FLOAT                     = 0x8DF2;
+  const unsigned long LOW_INT                        = 0x8DF3;
+  const unsigned long MEDIUM_INT                     = 0x8DF4;
+  const unsigned long HIGH_INT                       = 0x8DF5;
+
+  /* Framebuffer Object. */
+  const unsigned long FRAMEBUFFER                    = 0x8D40;
+  const unsigned long RENDERBUFFER                   = 0x8D41;
+
+  const unsigned long RGBA4                          = 0x8056;
+  const unsigned long RGB5_A1                        = 0x8057;
+  const unsigned long RGB565                         = 0x8D62;
+  const unsigned long DEPTH_COMPONENT16              = 0x81A5;
+  const unsigned long STENCIL_INDEX                  = 0x1901;
+  const unsigned long STENCIL_INDEX8                 = 0x8D48;
+
+  const unsigned long RENDERBUFFER_WIDTH             = 0x8D42;
+  const unsigned long RENDERBUFFER_HEIGHT            = 0x8D43;
+  const unsigned long RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
+  const unsigned long RENDERBUFFER_RED_SIZE          = 0x8D50;
+  const unsigned long RENDERBUFFER_GREEN_SIZE        = 0x8D51;
+  const unsigned long RENDERBUFFER_BLUE_SIZE         = 0x8D52;
+  const unsigned long RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
+  const unsigned long RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
+  const unsigned long RENDERBUFFER_STENCIL_SIZE      = 0x8D55;
+
+  const unsigned long FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
+  const unsigned long FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
+  const unsigned long FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
+  const unsigned long FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
+
+  const unsigned long COLOR_ATTACHMENT0              = 0x8CE0;
+  const unsigned long DEPTH_ATTACHMENT               = 0x8D00;
+  const unsigned long STENCIL_ATTACHMENT             = 0x8D20;
+
+  const unsigned long NONE                           = 0;
+
+  const unsigned long FRAMEBUFFER_COMPLETE                      = 0x8CD5;
+  const unsigned long FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
+  const unsigned long FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
+  const unsigned long FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
+  const unsigned long FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;
+
+  const unsigned long FRAMEBUFFER_BINDING            = 0x8CA6;
+  const unsigned long RENDERBUFFER_BINDING           = 0x8CA7;
+  const unsigned long MAX_RENDERBUFFER_SIZE          = 0x84E8;
+
+  const unsigned long INVALID_FRAMEBUFFER_OPERATION  = 0x0506;
+
+  //
+  //  ATTRIBUTES
+  //
+  readonly attribute nsIDOMHTMLCanvasElement canvas;
+
+  //
+  //  METHODS
+  //
+  void present();
+  long sizeInBytes(in GLenum type);
+
+  void activeTexture (in GLenum texture);
+  void attachShader (in nsIWebGLProgram program, in nsIWebGLShader shader);
+  void bindAttribLocation (in nsIWebGLProgram program, in GLuint index, in DOMString name);
+  void bindBuffer (in GLenum target, in nsIWebGLBuffer buffer);
+  void bindFramebuffer (in GLenum target, in nsIWebGLFramebuffer framebuffer);
+  void bindRenderbuffer (in GLenum target, in nsIWebGLRenderbuffer renderbuffer);
+  void bindTexture (in GLenum target, in nsIWebGLTexture texture);
+  void blendColor (in GLclampf red, in GLclampf green, in GLclampf blue, in GLclampf alpha);
+  void blendEquation (in GLenum mode);
+  void blendEquationSeparate (in GLenum modeRGB, in GLenum modeAlpha);
+  void blendFunc (in GLenum sfactor, in GLenum dfactor);
+  void blendFuncSeparate (in GLenum srcRGB, in GLenum dstRGB, in GLenum srcAlpha, in GLenum dstAlpha);
+
+  // Modified: void glBufferData (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
+  // void bufferData (in GLenum target, in GLsizei size, in GLenum usage);
+  // void bufferData (in GLenum target, in nsIWebGLArray data, in GLenum usage);
+  // void bufferData (in GLenum target, in nsIWebGLArrayBuffer data, in GLenum usage);
+  void bufferData (in GLenum target);
+
+  // Modified: void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
+  // void bufferSubData (in GLenum target, in GLsizeiptr offset, in nsIWebGLArray data);
+  // void bufferSubData (in GLenum target, in GLsizeiptr offset, in CanvasArrayBuffer data);
+  void bufferSubData (in GLenum target, in GLsizeiptr offset);
+
+  GLenum checkFramebufferStatus (in GLenum target);
+  void clear (in GLbitfield mask);
+  void clearColor (in GLclampf red, in GLclampf green, in GLclampf blue, in GLclampf alpha);
+  void clearDepth (in GLclampf depth);
+  void clearStencil (in GLint s);
+  void colorMask (in GLboolean red, in GLboolean green, in GLboolean blue, in GLboolean alpha);
+  void compileShader (in nsIWebGLShader shader);
+
+  //void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
+  //void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
+
+  void copyTexImage2D (in GLenum target, in GLint level, in GLenum internalformat, 
+                         in GLint x, in GLint y, in GLsizei width, in GLsizei height, in GLint border);
+  void copyTexSubImage2D (in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, 
+                            in GLint x, in GLint y, in GLsizei width, in GLsizei height);
+
+  nsIWebGLBuffer createBuffer();
+  nsIWebGLProgram createProgram ();
+  nsIWebGLFramebuffer createFramebuffer();
+  nsIWebGLRenderbuffer createRenderbuffer();
+  nsIWebGLShader createShader (in GLenum type);
+  nsIWebGLTexture createTexture();
+
+  void cullFace (in GLenum mode);
+
+  void deleteBuffer (in nsIWebGLBuffer buffer);
+  void deleteProgram (in nsIWebGLProgram program);
+  void deleteFramebuffer (in nsIWebGLFramebuffer framebuffer);
+  void deleteRenderbuffer (in nsIWebGLRenderbuffer renderbuffer);
+  void deleteShader (in nsIWebGLShader shader);
+  void deleteTexture (in nsIWebGLTexture texture);
+
+  void depthFunc (in GLenum func);
+  void depthMask (in GLboolean flag);
+  void depthRange (in GLclampf zNear, in GLclampf zFar);
+  void detachShader (in nsIWebGLProgram program, in nsIWebGLShader shader);
+  void disable (in GLenum cap);
+  void disableVertexAttribArray (in GLuint index);
+  void drawArrays (in GLenum mode, in GLint first, in GLsizei count);
+
+  // Modified: void glDrawElements (GLenum mode, GLsizei count, GLenum type, const void* indices);
+  void drawElements (in GLenum mode, in GLuint count, in GLenum type, in GLuint offset);
+
+  void enable (in GLenum cap);
+  void enableVertexAttribArray (in GLuint index);
+  void finish ();
+  void flush ();
+  void framebufferRenderbuffer (in GLenum target, in GLenum attachment, in GLenum renderbuffertarget, 
+                                  in nsIWebGLRenderbuffer renderbuffer);
+  void framebufferTexture2D (in GLenum target, in GLenum attachment, in GLenum textarget, 
+                               in nsIWebGLTexture texture, in GLint level);
+  void frontFace (in GLenum mode);
+
+  void generateMipmap (in GLenum target);
+
+  nsIWebGLActiveInfo getActiveAttrib(in nsIWebGLProgram program, in PRUint32 index);
+  nsIWebGLActiveInfo getActiveUniform(in nsIWebGLProgram program, in PRUint32 index);
+
+  // TBD
+  // void glGetAttachedShaders (GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);
+  //nsIWebGLShaderArray glGetAttachedShaders(in GLuint program);
+
+  GLint getAttribLocation (in nsIWebGLProgram program, in DOMString name);
+
+  // Modified
+  //GLboolean getBoolean(in GLenum pname);
+  // NOTYET nsIWebGLBooleanArray getBooleanv(in GLenum pname);
+  //GLfloat getFloat(in GLenum pname);
+  //nsIWebGLArray getFloatv(in GLenum pname);
+  //GLint getInteger(in GLenum pname);
+  //nsIWebGLIntArray getIntegerv(in GLenum pname);
+  // js only
+  void getParameter (in GLenum pname);
+
+  // Modified: void glGetBufferParameteriv (GLenum target, GLenum pname, GLint* params);
+  GLint getBufferParameteri (in GLenum target, in GLenum pname); // XXX remove
+  void getBufferParameter (in GLenum target, in GLenum pname);
+
+  GLenum getError ();
+
+  // Modified: void glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint* params);
+  GLint getFramebufferAttachmentParameteri (in GLenum target, in GLenum attachment, in GLenum pname); // XXX remove
+  void getFramebufferAttachmentParameter (in GLenum target, in GLenum attachment, in GLenum pname);
+
+  // Modified: void glGetProgramiv (nsIWebGLProgram program, GLenum pname, GLint* params);
+  GLint getProgrami (in nsIWebGLProgram program, in GLenum pname); // XXX remove
+  void getProgramParameter (in nsIWebGLProgram program, in GLenum pname);
+
+  // Modified: void glGetProgramInfoLog (GLuint program, GLsizei bufsize, GLsizei* length, char* infolog);
+  DOMString getProgramInfoLog (in nsIWebGLProgram program);
+
+  // Modified: void glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint* params);
+  //nsIWebGLIntArray getRenderbufferParameteriv (in GLenum target, in GLenum pname);
+  GLint getRenderbufferParameteri (in GLenum target, in GLenum pname); // XXX remove
+  void getRenderbufferParameter (in GLenum target, in GLenum pname);
+
+  GLint getShaderi (in nsIWebGLShader shader, in GLenum pname); // XXX remove
+  void getShaderParameter (in nsIWebGLShader shader, in GLenum pname);
+
+  // Modified: void glGetShaderInfoLog (GLuint shader, GLsizei bufsize, GLsizei* length, char* infolog);
+  DOMString getShaderInfoLog (in nsIWebGLShader shader);
+
+  // TBD
+  //void glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
+
+  DOMString getShaderSource (in nsIWebGLShader shader);
+  DOMString getString (in GLenum name);
+
+  GLfloat getTexParameterf (in GLenum target, in GLenum pname);         // XXX remove
+  GLint getTexParameteri (in GLenum target, in GLenum pname);           // XXX remove
+  void getTexParameter (in GLenum target, in GLenum pname);
+
+  // FIXME: This is problematic. We don't implicitly know how big the returned data buffer
+  // needs to be like in the other glGet* calls. The only way to find out is to iterate 
+  // through all the active uniforms with glGetActiveUniform() looking for the corresponding
+  // 'location'. This will give us the type and size of the data. Since this is a get call
+  // maybe that's ok?
+  void getUniform (in nsIWebGLProgram program, in GLint location);
+
+  GLint getUniformLocation (in nsIWebGLProgram program, in DOMString name);
+
+  void getVertexAttrib (in GLuint index, in GLenum pname);
+
+  // TBD
+  // void glGetVertexAttribPointerv (GLuint index, GLenum pname, void** pointer);
+  GLuint getVertexAttribOffset(in GLuint index, in GLenum pname);
+
+  void hint (in GLenum target, in GLenum mode);
+
+  GLboolean isBuffer (in nsIWebGLBuffer buffer);
+  GLboolean isFramebuffer (in nsIWebGLFramebuffer framebuffer);
+  GLboolean isProgram (in nsIWebGLProgram program);
+  GLboolean isRenderbuffer (in nsIWebGLRenderbuffer renderbuffer);
+  GLboolean isShader (in nsIWebGLShader shader);
+  GLboolean isTexture (in nsIWebGLTexture texture);
+
+  GLboolean isEnabled (in GLenum cap);
+  void lineWidth (in GLfloat width);
+  void linkProgram (in nsIWebGLProgram program);
+  void pixelStorei (in GLenum pname, in GLint param);
+  void polygonOffset (in GLfloat factor, in GLfloat units);
+
+  // TBD
+  //ZZ void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
+  void readPixels (in GLint x, in GLint y, in GLsizei width, in GLsizei height, in GLenum format, in GLenum type);
+
+  //void glReleaseShaderCompiler ();
+
+  void renderbufferStorage (in GLenum target, in GLenum internalformat, in GLsizei width, in GLsizei height);
+  void sampleCoverage (in GLclampf value, in GLboolean invert);
+  void scissor (in GLint x, in GLint y, in GLsizei width, in GLsizei height);
+
+  // Modified: void glShaderSource (GLuint shader, GLsizei count, const char** string, const GLint* length);
+  void shaderSource (in nsIWebGLShader shader, in DOMString source);
+
+  void stencilFunc (in GLenum func, in GLint ref, in GLuint mask);
+  void stencilFuncSeparate (in GLenum face, in GLenum func, in GLint ref, in GLuint mask);
+  void stencilMask (in GLuint mask);
+  void stencilMaskSeparate (in GLenum face, in GLuint mask);
+  void stencilOp (in GLenum fail, in GLenum zfail, in GLenum zpass);
+  void stencilOpSeparate (in GLenum face, in GLenum fail, in GLenum zfail, in GLenum zpass);
+
+  // Modified: glTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, 
+  // GLint border, GLenum format, GLenum type, const void* pixels);
+  //void glTexImage2D (in GLenum target, in GLint level, in GLenum internalformat, in GLsizei width, in GLsizei height, in GLint border, in GLenum format, in GLenum type, nsIWebGLArray pixels);
+  //void glTexImage2D (in GLenum target, in GLint level, in HTMLImageElement image);
+  //void glTexImage2D (in GLenum target, in GLint level, in HTMLnsIWebGLElement canvas);
+  //void glTexImage2D (in GLenum target, in GLint level, in HTMLVideoElement video);
+  void texImage2D ();
+
+
+  // Modified: This replaces glTexParameterf, glTexParameterfv, glTexParameteri and glTexParameteriv
+  void texParameterf (in GLenum target, in GLenum pname, in GLfloat param);
+  void texParameteri (in GLenum target, in GLenum pname, in GLint param);
+  //void glTexParameter (in GLenum target, in GLenum pname, in nsIWebGLArray params);
+
+  // Modified: void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
+  //void glTexSubImage2D (in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, in GLsizei width, in GLsizei height, in GLenum format, in GLenum type, nsIWebGLArray pixels);
+  //void glTexSubImage2D (in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, in GLsizei width, in GLsizei height, in HTMLImageElement image);
+  //void glTexSubImage2D (in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, in GLsizei width, in GLsizei height, in HTMLnsIWebGLElement canvas);
+  //void glTexSubImage2D (in GLenum target, in GLint level, in GLint xoffset, in GLint yoffset, in GLsizei width, in GLsizei height, in HTMLVideoElement video);
+
+  void texSubImage2D ();
+
+  // Modified: All the glUniform*v forms below are modified by replacing 'count' and 'v' with a nsIWebGLArray
+  void uniform1f (in GLint location, in GLfloat x);
+  void uniform1i (in GLint location, in GLint x);
+  void uniform2f (in GLint location, in GLfloat x, in GLfloat y);
+  void uniform2i (in GLint location, in GLint x, in GLint y);
+  void uniform3f (in GLint location, in GLfloat x, in GLfloat y, in GLfloat z);
+  void uniform3i (in GLint location, in GLint x, in GLint y, in GLint z);
+  void uniform4f (in GLint location, in GLfloat x, in GLfloat y, in GLfloat z, in GLfloat w);
+  void uniform4i (in GLint location, in GLint x, in GLint y, in GLint z, in GLint w);
+
+  void uniform1fv (in GLint location, in nsIWebGLArray v);
+  void uniform1iv (in GLint location, in nsIWebGLArray v);
+  void uniform2fv (in GLint location, in nsIWebGLArray v);
+  void uniform2iv (in GLint location, in nsIWebGLArray v);
+  void uniform3fv (in GLint location, in nsIWebGLArray v);
+  void uniform3iv (in GLint location, in nsIWebGLArray v);
+  void uniform4fv (in GLint location, in nsIWebGLArray v);
+  void uniform4iv (in GLint location, in nsIWebGLArray v);
+
+  // Modified. These are modified by replacing 'count' and 'value' with a nsIWebGLArray
+  void uniformMatrix2fv (in GLint location, in GLboolean transpose, in nsIWebGLArray value);
+  void uniformMatrix3fv (in GLint location, in GLboolean transpose, in nsIWebGLArray value);
+  void uniformMatrix4fv (in GLint location, in GLboolean transpose, in nsIWebGLArray value);
+
+  // Added API using top entry from the passed nsIWebGLMatrixStack
+  //ZZ void glUniformMatrix (in GLint location, in GLboolean transpose, in nsIWebGLMatrixStack value);
+
+  void useProgram (in nsIWebGLProgram program);
+  void validateProgram (in nsIWebGLProgram program);
+
+  // Modified: All the glVertexAttrib*v forms below are modified by replacing 'values' with a nsIWebGLArray
+  void vertexAttrib1f (in GLuint indx, in GLfloat x);
+  void vertexAttrib2f (in GLuint indx, in GLfloat x, in GLfloat y);
+  void vertexAttrib3f (in GLuint indx, in GLfloat x, in GLfloat y, in GLfloat z);
+  void vertexAttrib4f (in GLuint indx, in GLfloat x, in GLfloat y, in GLfloat z, in GLfloat w);
+
+  void vertexAttrib1fv (in GLuint indx, in nsIWebGLArray values);
+  void vertexAttrib2fv (in GLuint indx, in nsIWebGLArray values);
+  void vertexAttrib3fv (in GLuint indx, in nsIWebGLArray values);
+  void vertexAttrib4fv (in GLuint indx, in nsIWebGLArray values);
+
+  // TBD
+  //void glVertexAttribPointer (in GLuint indx, GLint size, GLenum type, GLboolean normalized, 
+  // GLsizei stride, const void* ptr);
+
+  // size is number of elements; type must match the bound vbo type; offset is in elements
+  void vertexAttribPointer (in GLuint idx, in GLint size, in GLenum type, in GLboolean normalized, in GLuint stride, in GLuint offset);
+
+  void viewport (in GLint x, in GLint y, in GLsizei width, in GLsizei height);
+
+};
diff -r 5b1fe1bf3872 embedding/browser/build/Makefile.in
--- a/embedding/browser/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/embedding/browser/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -85,7 +85,7 @@ EXTRA_DSO_LDOPTS= \
 		$(MOZ_COMPONENT_LIBS) \
 		$(NULL)
 
-ifeq (mac,$(MOZ_WIDGET_TOOLKIT))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
diff -r 5b1fe1bf3872 embedding/components/build/Makefile.in
--- a/embedding/components/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/embedding/components/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -121,7 +121,7 @@ OS_LIBS	+= $(call EXPAND_LIBNAME,winspoo
 endif
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LOCAL_INCLUDES += -I$(srcdir)/../printingui/src/mac
 endif
 
@@ -135,7 +135,7 @@ EXTRA_DSO_LDOPTS = \
 	$(MOZ_JS_LIBS) \
 	$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += \
         $(TK_LIBS) \
         $(NULL)
diff -r 5b1fe1bf3872 embedding/components/printingui/src/Makefile.in
--- a/embedding/components/printingui/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/embedding/components/printingui/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -54,7 +54,7 @@ ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
 PLATFORM_DIR = win
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 PLATFORM_DIR = mac
 endif
 
diff -r 5b1fe1bf3872 embedding/config/Makefile.in
--- a/embedding/config/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/embedding/config/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -43,7 +43,7 @@ VPATH           = @srcdir@
 include $(DEPTH)/config/autoconf.mk
 include $(topsrcdir)/config/rules.mk
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
   BASEBROWSER = basebrowser-mac-macho
   CLIENTMANIFEST = client-mac-macho
   _PLATFORM = unix
diff -r 5b1fe1bf3872 extensions/java/xpcom/glue/Makefile.in
--- a/extensions/java/xpcom/glue/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/extensions/java/xpcom/glue/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -84,7 +84,7 @@ EXTRA_DSO_LDOPTS = \
 	$(NULL)
 
 # Need to link with CoreFoundation on Mac
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
diff -r 5b1fe1bf3872 extensions/pref/autoconfig/src/Makefile.in
--- a/extensions/pref/autoconfig/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/extensions/pref/autoconfig/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -91,7 +91,7 @@ AUTOCFG_JS_EXPORTS = \
 		$(srcdir)/prefcalls.js \
 		$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 AUTOCFG_JS_EXPORTS += $(srcdir)/mac/platform.js
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT), windows)
diff -r 5b1fe1bf3872 gfx/cairo/cairo/src/Makefile.in
--- a/gfx/cairo/cairo/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/gfx/cairo/cairo/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -186,7 +186,7 @@ CSRCS   += $(PSPDF_BASE_CSRCS) $(PDF_CSR
 EXPORTS_cairo += $(PDF_EXPORTS)
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CSRCS   += cairo-quartz-surface.c cairo-quartz-image-surface.c cairo-quartz-font.c
 EXPORTS_cairo += cairo-quartz.h cairo-quartz-image.h
 endif
diff -r 5b1fe1bf3872 gfx/thebes/public/Makefile.in
--- a/gfx/thebes/public/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/gfx/thebes/public/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -99,7 +99,7 @@ EXPORTS +=  gfxFT2FontBase.h
 EXPORTS +=	gfxPDFSurface.h
 endif
 
-ifneq (,$(filter $(MOZ_WIDGET_TOOLKIT),mac cocoa))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXPORTS +=	gfxPlatformMac.h \
 		gfxQuartzSurface.h \
 		gfxQuartzImageSurface.h \
diff -r 5b1fe1bf3872 gfx/thebes/public/gfxXlibSurface.h
--- a/gfx/thebes/public/gfxXlibSurface.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/gfx/thebes/public/gfxXlibSurface.h	Fri Dec 11 07:09:00 2009 +0200
@@ -54,10 +54,12 @@ public:
     // with explicitly provided width/height.
     gfxXlibSurface(Display *dpy, Drawable drawable, Visual *visual, const gfxIntSize& size);
 
-    // create a new Pixmap on the display dpy, with
-    // the root window as the parent and the default depth
-    // for the default screen, and attach the given visual
-    gfxXlibSurface(Display *dpy, Visual *visual, const gfxIntSize& size);
+    // create a new Pixmap on the display dpy, with the root window as
+    // the parent and the default depth for the default screen, and
+    // attach the given visual.  The depth argument is optional, and
+    // if not specified (or 0), the default depth of the default
+    // screen of dpy is used.
+    gfxXlibSurface(Display *dpy, Visual *visual, const gfxIntSize& size, int depth = 0);
 
     gfxXlibSurface(Display* dpy, Drawable drawable, XRenderPictFormat *format,
                    const gfxIntSize& size);
diff -r 5b1fe1bf3872 gfx/thebes/src/gfxXlibSurface.cpp
--- a/gfx/thebes/src/gfxXlibSurface.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/gfx/thebes/src/gfxXlibSurface.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -71,7 +71,7 @@ gfxXlibSurface::gfxXlibSurface(Display *
     Init(surf);
 }
 
-gfxXlibSurface::gfxXlibSurface(Display *dpy, Visual *visual, const gfxIntSize& size)
+gfxXlibSurface::gfxXlibSurface(Display *dpy, Visual *visual, const gfxIntSize& size, int depth)
     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mSize(size)
 
 {
@@ -81,7 +81,7 @@ gfxXlibSurface::gfxXlibSurface(Display *
     mDrawable = (Drawable)XCreatePixmap(dpy,
                                         RootWindow(dpy, DefaultScreen(dpy)),
                                         mSize.width, mSize.height,
-                                        DefaultDepth(dpy, DefaultScreen(dpy)));
+                                        depth ? depth : DefaultDepth(dpy, DefaultScreen(dpy)));
 
     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, mDrawable, visual, mSize.width, mSize.height);
 
diff -r 5b1fe1bf3872 intl/build/Makefile.in
--- a/intl/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/intl/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -63,7 +63,7 @@ CPPSRCS		= \
 			$(NULL)
 
 # see also intl/locale/src/Makefile.in
-ifneq (,$(filter mac os2 windows, $(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter os2 windows, $(MOZ_WIDGET_TOOLKIT)))
 LOCALE_DIR		= $(MOZ_WIDGET_TOOLKIT)
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT), cocoa)
@@ -94,7 +94,7 @@ EXTRA_DSO_LDOPTS = \
 	$(MOZ_COMPONENT_LIBS) \
 	$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += \
         $(TK_LIBS) \
         $(NULL)
diff -r 5b1fe1bf3872 intl/locale/Makefile.in
--- a/intl/locale/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/intl/locale/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -49,7 +49,7 @@ DIRS		= public idl src
 
 ifdef ENABLE_TESTS
 DIRS		+= tests
-ifneq (,$(filter mac cocoa windows, $(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter cocoa windows, $(MOZ_WIDGET_TOOLKIT)))
 DIRS		+= tests_multilocale
 endif
 endif
diff -r 5b1fe1bf3872 intl/locale/src/Makefile.in
--- a/intl/locale/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/intl/locale/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -53,7 +53,7 @@ REQUIRES	= xpcom \
 		  intl \
 		  $(NULL)
 
-ifneq (,$(filter mac os2 windows, $(MOZ_WIDGET_TOOLKIT)))
+ifneq (,$(filter os2 windows, $(MOZ_WIDGET_TOOLKIT)))
 DIRS		= $(MOZ_WIDGET_TOOLKIT)
 else
 ifeq ($(MOZ_WIDGET_TOOLKIT), cocoa)
diff -r 5b1fe1bf3872 intl/uconv/src/Makefile.in
--- a/intl/uconv/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/intl/uconv/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -103,7 +103,7 @@ ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
 CPPSRCS			+= nsWinCharset.cpp
 EXPORT_RESOURCE		+= wincharset.properties
 else
-ifneq (,$(filter cocoa mac, $(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CPPSRCS			+= nsMacCharset.cpp
 EXPORT_RESOURCE		+= maccharset.properties
 else
@@ -130,7 +130,7 @@ EXTRA_DSO_LDOPTS = \
 
 LOCAL_INCLUDES	= -I$(srcdir)/../util
 
-ifneq (,$(filter cocoa mac, $(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
diff -r 5b1fe1bf3872 js/src/xpconnect/shell/Makefile.in
--- a/js/src/xpconnect/shell/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/js/src/xpconnect/shell/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -55,7 +55,7 @@ REQUIRES	= xpconnect \
 
 CPPSRCS		= xpcshell.cpp
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CMMSRCS += xpcshellMacUtils.mm
 endif
 
diff -r 5b1fe1bf3872 layout/build/Makefile.in
--- a/layout/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/layout/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -136,7 +136,7 @@ SHARED_LIBRARY_LIBS = \
 	$(DEPTH)/dom/src/jsurl/$(LIB_PREFIX)jsurl_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/storage/$(LIB_PREFIX)jsdomstorage_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/offline/$(LIB_PREFIX)jsdomoffline_s.$(LIB_SUFFIX) \
- 	$(DEPTH)/dom/src/geolocation/$(LIB_PREFIX)jsdomgeolocation_s.$(LIB_SUFFIX) \
+	$(DEPTH)/dom/src/geolocation/$(LIB_PREFIX)jsdomgeolocation_s.$(LIB_SUFFIX) \
 	$(DEPTH)/dom/src/threads/$(LIB_PREFIX)domthreads_s.$(LIB_SUFFIX) \
 	$(DEPTH)/editor/libeditor/text/$(LIB_PREFIX)texteditor_s.$(LIB_SUFFIX) \
 	$(DEPTH)/editor/libeditor/base/$(LIB_PREFIX)editorbase_s.$(LIB_SUFFIX) \
@@ -270,12 +270,9 @@ EXTRA_DSO_LDOPTS += $(MOZ_QT_LIBS) \
 		    $(NULL)
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
-
-ifdef MOZ_ENABLE_CANVAS3D
-EXTRA_DSO_LDOPTS += -framework OpenGL
-endif
+OS_LIBS += -framework OpenGL
 endif
 
 # Add explicit X11 dependency when building against X11 toolkits
diff -r 5b1fe1bf3872 layout/build/nsLayoutCID.h
--- a/layout/build/nsLayoutCID.h	Fri Dec 11 07:02:35 2009 +0200
+++ b/layout/build/nsLayoutCID.h	Fri Dec 11 07:09:00 2009 +0200
@@ -214,9 +214,9 @@
 #define NS_CANVASRENDERINGCONTEXT2D_CID \
 { 0xa35d1cd4, 0xc505, 0x4d2d, { 0xa0, 0xf9, 0xae, 0xf0, 0x0b, 0x7c, 0xe5, 0xa5 } }
 
-// {2fe88332-31c6-4829-b247-a07d8a73e80e}
-#define NS_CANVASRENDERINGCONTEXTGLWEB20_CID \
-{ 0x2fe88332, 0x31c6, 0x4829, { 0xb2, 0x47, 0xa0, 0x7d, 0x8a, 0x7e, 0xe8, 0x0e } }
+// {2fe88332-31c6-4829-b247-a07d8a73e80f}
+#define NS_CANVASRENDERINGCONTEXTWEBGL_CID \
+{ 0x2fe88332, 0x31c6, 0x4829, { 0xb2, 0x47, 0xa0, 0x7d, 0x8a, 0x7e, 0xe8, 0x0fe } }
 
 // {8b449142-1eab-4bfa-9830-fab6ebb09774}
 #define NS_DOMSTORAGE_CID \
diff -r 5b1fe1bf3872 layout/build/nsLayoutModule.cpp
--- a/layout/build/nsLayoutModule.cpp	Fri Dec 11 07:02:35 2009 +0200
+++ b/layout/build/nsLayoutModule.cpp	Fri Dec 11 07:09:00 2009 +0200
@@ -208,12 +208,8 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(nsHTMLEdi
 
 #include "nsHTMLCanvasFrame.h"
 
-#ifdef MOZ_ENABLE_CANVAS
 #include "nsIDOMCanvasRenderingContext2D.h"
-#ifdef MOZ_ENABLE_CANVAS3D
-#include "nsICanvasRenderingContextGLWeb20.h"
-#endif
-#endif
+#include "nsICanvasRenderingContextWebGL.h"
 
 class nsIDocumentLoaderFactory;
 
@@ -406,12 +402,8 @@ nsresult NS_NewContainerBoxObject(nsIBox
 nsresult NS_NewTreeBoxObject(nsIBoxObject** aResult);
 #endif
 
-#ifdef MOZ_ENABLE_CANVAS
 nsresult NS_NewCanvasRenderingContext2D(nsIDOMCanvasRenderingContext2D** aResult);
-#ifdef MOZ_ENABLE_CANVAS3D
-nsresult NS_NewCanvasRenderingContextGLWeb20(nsICanvasRenderingContextGLWeb20** aResult);
-#endif
-#endif
+nsresult NS_NewCanvasRenderingContextWebGL(nsICanvasRenderingContextWebGL** aResult);
 
 nsresult NS_CreateFrameTraversal(nsIFrameTraversal** aResult);
 
@@ -546,12 +538,8 @@ MAKE_CTOR(CreateVideoDocument,          
 #endif
 MAKE_CTOR(CreateFocusManager,             nsIFocusManager,      NS_NewFocusManager)
 
-#ifdef MOZ_ENABLE_CANVAS
 MAKE_CTOR(CreateCanvasRenderingContext2D, nsIDOMCanvasRenderingContext2D, NS_NewCanvasRenderingContext2D)
-#ifdef MOZ_ENABLE_CANVAS3D
-MAKE_CTOR(CreateCanvasRenderingContextGLWeb20, nsICanvasRenderingContextGLWeb20, NS_NewCanvasRenderingContextGLWeb20)
-#endif
-#endif
+MAKE_CTOR(CreateCanvasRenderingContextWebGL, nsICanvasRenderingContextWebGL, NS_NewCanvasRenderingContextWebGL)
 
 NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsStyleSheetService, Init)
 
@@ -1086,18 +1074,19 @@ static const nsModuleComponentInfo gComp
     UnregisterHTMLAudioElement },
 #endif
 
-#ifdef MOZ_ENABLE_CANVAS
   { "Canvas 2D Rendering Context",
     NS_CANVASRENDERINGCONTEXT2D_CID,
     "@mozilla.org/content/canvas-rendering-context;1?id=2d",
     CreateCanvasRenderingContext2D },
-#ifdef MOZ_ENABLE_CANVAS3D
-  { "Canvas OpenGL Web 2.0 Rendering Context",
-    NS_CANVASRENDERINGCONTEXTGLWEB20_CID,
-    "@mozilla.org/content/canvas-rendering-context;1?id=moz-glweb20",
-    CreateCanvasRenderingContextGLWeb20 },
-#endif
-#endif
+  { "Canvas WebGL Rendering Context",
+    NS_CANVASRENDERINGCONTEXTWEBGL_CID,
+    "@mozilla.org/content/canvas-rendering-context;1?id=moz-webgl",
+    CreateCanvasRenderingContextWebGL },
+  { "Canvas WebGL Rendering Context",
+    NS_CANVASRENDERINGCONTEXTWEBGL_CID,
+    "@mozilla.org/content/canvas-rendering-context;1?id=experimental-webgl",
+    CreateCanvasRenderingContextWebGL },
+
 
   { "XML document encoder",
     NS_TEXT_ENCODER_CID,
diff -r 5b1fe1bf3872 modules/libpr0n/decoders/Makefile.in
--- a/modules/libpr0n/decoders/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/modules/libpr0n/decoders/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -58,7 +58,7 @@ endif
 ifeq ($(OS_ARCH),BeOS)
 DIRS = icon/beos icon
 endif
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 DIRS = icon/mac icon
 endif
 endif # icon
diff -r 5b1fe1bf3872 modules/libpref/src/init/all.js
--- a/modules/libpref/src/init/all.js	Fri Dec 11 07:02:35 2009 +0200
+++ b/modules/libpref/src/init/all.js	Fri Dec 11 07:09:00 2009 +0200
@@ -2796,6 +2796,11 @@ pref("image.cache.timeweight", 500);
 // The default Accept header sent for images loaded over HTTP(S)
 pref("image.http.accept", "image/png,image/*;q=0.8,*/*;q=0.5");
 
+// WebGL prefs
+pref("webgl.enabled_for_all_sites", false);
+pref("webgl.software_render", false);
+pref("webgl.osmesalib", "");
+
 #ifdef XP_WIN
 #ifndef WINCE
 // The default TCP send window on Windows is too small, and autotuning only occurs on receive
diff -r 5b1fe1bf3872 modules/plugin/base/src/Makefile.in
--- a/modules/plugin/base/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/modules/plugin/base/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -109,7 +109,7 @@ ifeq ($(MOZ_WIDGET_TOOLKIT),os2)
 	CPPSRCS += nsPluginsDirOS2.cpp
 	CPPSRCS += nsPluginNativeWindowOS2.cpp
 else
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 	CPPSRCS += nsPluginsDirDarwin.cpp
 	CPPSRCS += nsPluginNativeWindow.cpp
 else
@@ -138,7 +138,7 @@ EXTRA_DSO_LDOPTS = \
 		$(MOZ_JS_LIBS) \
 		$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
diff -r 5b1fe1bf3872 netwerk/base/src/Makefile.in
--- a/netwerk/base/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/netwerk/base/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -113,7 +113,7 @@ else
 	CPPSRCS += nsAutodialWinCE.cpp
 endif
 else
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 	CPPSRCS += nsURLHelperOSX.cpp
 else
 	CPPSRCS += nsURLHelperUnix.cpp
diff -r 5b1fe1bf3872 netwerk/build/Makefile.in
--- a/netwerk/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/netwerk/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -155,7 +155,7 @@ EXTRA_DSO_LDOPTS = \
 		$(ZLIB_LIBS) \
 		$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT)))
 EXTRA_DSO_LDOPTS += \
 		-framework SystemConfiguration \
 		$(TK_LIBS) \
diff -r 5b1fe1bf3872 netwerk/streamconv/converters/Makefile.in
--- a/netwerk/streamconv/converters/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/netwerk/streamconv/converters/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -85,7 +85,7 @@ CPPSRCS += \
         $(NULL)
 endif
 
-ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CPPSRCS += \
 		nsBinHexDecoder.cpp \
 		$(NULL)
diff -r 5b1fe1bf3872 toolkit/components/build/Makefile.in
--- a/toolkit/components/build/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/components/build/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -156,7 +156,7 @@ EXTRA_DSO_LDOPTS += \
 	$(MOZ_JS_LIBS) \
 	$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
diff -r 5b1fe1bf3872 toolkit/components/commandlines/src/Makefile.in
--- a/toolkit/components/commandlines/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/components/commandlines/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -70,7 +70,7 @@ EXTRA_DSO_LDOPTS += \
 	$(MOZ_COMPONENT_LIBS) \
 	$(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(TK_LIBS)
 endif
 
diff -r 5b1fe1bf3872 toolkit/components/filepicker/Makefile.in
--- a/toolkit/components/filepicker/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/components/filepicker/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -44,7 +44,7 @@ VPATH     = @srcdir@
 include $(DEPTH)/config/autoconf.mk
 
 ifdef MOZ_XUL
-ifeq (,$(filter qt beos os2 mac photon cocoa windows,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (,$(filter qt beos os2 photon cocoa windows,$(MOZ_WIDGET_TOOLKIT)))
 DIRS = public src
 endif
 endif
diff -r 5b1fe1bf3872 toolkit/components/startup/src/Makefile.in
--- a/toolkit/components/startup/src/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/components/startup/src/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -73,7 +73,7 @@ else
 ifeq (,$(filter-out WINCE WINNT,$(OS_ARCH)))
 CPPSRCS += nsUserInfoWin.cpp
 else
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CMMSRCS += nsUserInfoMac.mm
 else
 CPPSRCS += nsUserInfoUnix.cpp
diff -r 5b1fe1bf3872 toolkit/content/tests/chrome/Makefile.in
--- a/toolkit/content/tests/chrome/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/content/tests/chrome/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -96,7 +96,7 @@ _TEST_FILES = 	findbar_window.xul \
 
 # test_panel_focus.xul won't work if the Full Keyboard Access preference is set to
 # textboxes and lists only, so skip this test on Mac
-ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 _TEST_FILES += test_panel_focus.xul \
                window_panel_focus.xul \
                test_dialogfocus.xul \
diff -r 5b1fe1bf3872 toolkit/content/tests/widgets/Makefile.in
--- a/toolkit/content/tests/widgets/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/content/tests/widgets/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -131,7 +131,7 @@ _TEST_FILES = 	test_bug360220.xul \
 		videomask.css \
 		$(NULL)
 
-ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 _TEST_FILES += test_menubar.xul \
                window_menubar.xul
 endif
diff -r 5b1fe1bf3872 toolkit/library/libxul-config.mk
--- a/toolkit/library/libxul-config.mk	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/library/libxul-config.mk	Fri Dec 11 07:09:00 2009 +0200
@@ -252,7 +252,7 @@ COMPONENT_LIBS += \
 endif
 endif
 
-ifeq (,$(filter qt beos os2 mac photon cocoa windows,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (,$(filter qt beos os2 photon cocoa windows,$(MOZ_WIDGET_TOOLKIT)))
 ifdef MOZ_XUL
 ifdef MOZ_XPFE_COMPONENTS
 COMPONENT_LIBS += fileview
@@ -331,7 +331,7 @@ endif
 ifeq (os2,$(MOZ_WIDGET_TOOLKIT))
 COMPONENT_LIBS += wdgtos2
 endif
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 COMPONENT_LIBS += widget_mac
 endif
 ifeq (qt,$(MOZ_WIDGET_TOOLKIT))
@@ -373,9 +373,6 @@ ifdef GC_LEAK_DETECTOR
 EXTRA_DSO_LIBS += boehm
 endif
 
-ifdef MOZ_ENABLE_CANVAS3D
 ifeq ($(MOZ_WIDGET_TOOLKIT),cocoa)
 EXTRA_DSO_LDOPTS += -framework OpenGL
 endif
-endif
-
diff -r 5b1fe1bf3872 toolkit/library/libxul-rules.mk
--- a/toolkit/library/libxul-rules.mk	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/library/libxul-rules.mk	Fri Dec 11 07:09:00 2009 +0200
@@ -79,7 +79,7 @@ ifneq ($(OS_ARCH),WINCE)
 OS_LIBS += $(call EXPAND_LIBNAME,usp10 oleaut32)
 endif
 endif
-ifneq (,$(filter $(MOZ_WIDGET_TOOLKIT),mac cocoa))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += -lcups
 endif
 
diff -r 5b1fe1bf3872 toolkit/locales/Makefile.in
--- a/toolkit/locales/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/locales/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -85,7 +85,7 @@ endif
 
 ifdef MOZ_CRASHREPORTER
 libs:: crashreporter.ini
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 	$(SYSINSTALL) $(IFLAGS1) $^ $(FINAL_TARGET)/crashreporter.app/Contents/MacOS
 else
 	$(SYSINSTALL) $(IFLAGS1) $^ $(FINAL_TARGET)
diff -r 5b1fe1bf3872 toolkit/locales/l10n.mk
--- a/toolkit/locales/l10n.mk	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/locales/l10n.mk	Fri Dec 11 07:09:00 2009 +0200
@@ -98,7 +98,7 @@ PACKAGER_NO_LIBS = 1
 include $(topsrcdir)/toolkit/mozapps/installer/packager.mk
 
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 STAGEDIST = $(_ABS_DIST)/l10n-stage/$(MOZ_PKG_APPNAME)/$(_APPNAME)/Contents/MacOS
 else
 STAGEDIST = $(_ABS_DIST)/l10n-stage/$(MOZ_PKG_DIR)
@@ -108,7 +108,7 @@ endif
 $(STAGEDIST): UNPACKAGE=$(ZIP_IN)
 $(STAGEDIST): $(ZIP_IN)
 # only mac needs to remove the parent of STAGEDIST...
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 	$(RM) -r -v $(DIST)/l10n-stage
 else
 # ... and windows doesn't like removing STAGEDIST itself, remove all children
@@ -133,7 +133,7 @@ repackage-zip:
 	cd $(DIST)/xpi-stage/locale-$(AB_CD) && \
 	  tar --exclude=install.rdf --exclude=chrome.manifest $(TAR_CREATE_FLAGS) - * | ( cd $(STAGEDIST) && tar -xf - )
 ifneq (en,$(AB))
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 	mv $(_ABS_DIST)/l10n-stage/$(MOZ_PKG_APPNAME)/$(_APPNAME)/Contents/Resources/en.lproj $(_ABS_DIST)/l10n-stage/$(MOZ_PKG_APPNAME)/$(_APPNAME)/Contents/Resources/$(AB).lproj
 endif
 endif
@@ -152,7 +152,7 @@ ifdef MOZ_MAKE_COMPLETE_MAR
 endif
 # packaging done, undo l10n stuff
 ifneq (en,$(AB))
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 	mv $(_ABS_DIST)/l10n-stage/$(MOZ_PKG_APPNAME)/$(_APPNAME)/Contents/Resources/$(AB).lproj $(_ABS_DIST)/l10n-stage/$(MOZ_PKG_APPNAME)/$(_APPNAME)/Contents/Resources/en.lproj
 endif
 endif
diff -r 5b1fe1bf3872 toolkit/mozapps/installer/packager.mk
--- a/toolkit/mozapps/installer/packager.mk	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/mozapps/installer/packager.mk	Fri Dec 11 07:09:00 2009 +0200
@@ -43,7 +43,7 @@ include $(MOZILLA_DIR)/toolkit/mozapps/i
 # This is how we create the binary packages we release to the public.
 
 ifndef MOZ_PKG_FORMAT
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 MOZ_PKG_FORMAT  = DMG
 else
 ifeq (,$(filter-out OS2 WINNT WINCE BeOS, $(OS_ARCH)))
diff -r 5b1fe1bf3872 toolkit/mozapps/update/src/updater/Makefile.in
--- a/toolkit/mozapps/update/src/updater/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/mozapps/update/src/updater/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -112,7 +112,7 @@ OS_CXXFLAGS += $(TK_CFLAGS)
 OS_LIBS += $(TK_LIBS)
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 HAVE_PROGRESSUI = 1
 CMMSRCS += progressui_osx.mm launchchild_osx.mm
 OS_LIBS += -framework Cocoa
@@ -148,7 +148,7 @@ libs:: updater.png
 	$(INSTALL) $(IFLAGS1) $^ $(DIST)/bin/icons
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 libs::
 	$(NSINSTALL) -D $(DIST)/bin/updater.app
 	rsync -a -C --exclude "*.in" $(srcdir)/macbuild/Contents $(DIST)/bin/updater.app 
diff -r 5b1fe1bf3872 toolkit/profile/Makefile.in
--- a/toolkit/profile/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/profile/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -45,7 +45,7 @@ include $(DEPTH)/config/autoconf.mk
 DIRS = public src
 
 # Use Qute for non-Mac non-Phoenix apps
-ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (cocoa,$(MOZ_WIDGET_TOOLKIT)))
 ifndef MOZ_PHOENIX
 DIRS += skin
 endif
diff -r 5b1fe1bf3872 toolkit/themes/Makefile.in
--- a/toolkit/themes/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/toolkit/themes/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -52,7 +52,7 @@ include $(DEPTH)/config/autoconf.mk
 #                         PMStripe overrides (toolkit/themes/pmstripe)
 # faststripe              Winstripe + faststripe (no native theme components)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 DIRS	= pinstripe
 else
 
diff -r 5b1fe1bf3872 tools/trace-malloc/Makefile.in
--- a/tools/trace-malloc/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/tools/trace-malloc/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -81,7 +81,7 @@ endif
 include $(topsrcdir)/config/config.mk
 
 ifdef MOZ_ENABLE_LIBXUL
-ifeq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifneq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LIBS	= xul
 endif
 endif
@@ -96,7 +96,7 @@ LIBS		+= \
 		$(NULL)
 
 ifdef MOZ_ENABLE_LIBXUL
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LIBS += $(DIST)/bin/XUL
 endif
 endif
diff -r 5b1fe1bf3872 tools/update-packaging/Makefile.in
--- a/tools/update-packaging/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/tools/update-packaging/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -53,7 +53,7 @@ PACKAGE_BASE_DIR	= $(DIST)
 # Default output location for update archive
 STAGE_DIR	= $(DIST)/$(PKG_UPDATE_PATH)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 ifdef UNIVERSAL_BINARY
 ifneq (,$(filter %/l10n-stage,$(PACKAGE_BASE_DIR)))
 PACKAGE_DIR	= $(PACKAGE_BASE_DIR)/$(MOZ_PKG_APPNAME)/$(MOZ_APP_DISPLAYNAME).app
diff -r 5b1fe1bf3872 xpcom/base/Makefile.in
--- a/xpcom/base/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/xpcom/base/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -75,7 +75,7 @@ CPPSRCS += nsLeakDetector.cpp
 REQUIRES	+= boehm
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 CPPSRCS		+= nsMacUtilsImpl.cpp
 endif
 
@@ -136,7 +136,7 @@ ifdef GC_LEAK_DETECTOR
 XPIDLSRCS       += nsILeakDetector.idl
 endif
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 XPIDLSRCS	+= nsIMacUtils.idl
 endif
 
diff -r 5b1fe1bf3872 xpcom/sample/Makefile.in
--- a/xpcom/sample/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/xpcom/sample/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -95,7 +95,7 @@ EXTRA_DSO_LDOPTS = \
 		$(NULL)
 
 # Need to link with CoreFoundation on Mac
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += \
 		$(TK_LIBS) \
 		$(NULL)
diff -r 5b1fe1bf3872 xpcom/sample/program/Makefile.in
--- a/xpcom/sample/program/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/xpcom/sample/program/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -61,7 +61,7 @@ LIBS            = \
 		$(NULL)
 
 # Need to link with CoreFoundation on Mac
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LIBS            += \
 		$(TK_LIBS) \
 		$(NULL)
diff -r 5b1fe1bf3872 xpcom/tools/registry/Makefile.in
--- a/xpcom/tools/registry/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/xpcom/tools/registry/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -58,7 +58,7 @@ LIBS            = \
 		$(NULL)
 
 # Need to link with CoreFoundation on Mac
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LIBS            += \
 		$(TK_LIBS) \
 		$(NULL)
diff -r 5b1fe1bf3872 xulrunner/app/Makefile.in
--- a/xulrunner/app/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/xulrunner/app/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -103,7 +103,7 @@ LOCAL_INCLUDES += \
         -I$(topsrcdir)/toolkit/profile/src \
         $(NULL)
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 TK_LIBS := -framework Cocoa $(TK_LIBS)
 endif
 
@@ -275,7 +275,7 @@ endif
 libs::
 	touch $(DIST)/bin/.autoreg
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 
 FRAMEWORK_NAME = XUL
 FRAMEWORK_VERSION = $(MOZILLA_VERSION)
diff -r 5b1fe1bf3872 xulrunner/installer/Makefile.in
--- a/xulrunner/installer/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/xulrunner/installer/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -53,7 +53,7 @@ NO_PKG_FILES = \
 # If we're on mac, we want to make the .pkg first, in the mac/
 # directory. Then packager.mk can put it into a DMG
 
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 DIRS += mac
 _APPNAME = $(PKG_BASENAME).pkg
 PKG_SKIP_STRIP = 1
diff -r 5b1fe1bf3872 xulrunner/stub/Makefile.in
--- a/xulrunner/stub/Makefile.in	Fri Dec 11 07:02:35 2009 +0200
+++ b/xulrunner/stub/Makefile.in	Fri Dec 11 07:09:00 2009 +0200
@@ -67,7 +67,7 @@ LIBS = \
   $(NULL)
 
 # Need to link with CoreFoundation on Mac
-ifneq (,$(filter mac cocoa,$(MOZ_WIDGET_TOOLKIT)))
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
 LIBS            += \
 		$(TK_LIBS) \
 		$(NULL)
