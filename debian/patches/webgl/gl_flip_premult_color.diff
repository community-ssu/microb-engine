Index: mozilla/content/canvas/src/Makefile.in
===================================================================
--- mozilla.orig/content/canvas/src/Makefile.in
+++ mozilla/content/canvas/src/Makefile.in
@@ -91,16 +91,19 @@ CPPSRCS += \
 	nsGLPbufferOSMesa.cpp \
 	SimpleBuffer.cpp \
 	$(NULL)
 
 ifdef MOZ_X11
 ifdef MOZ_PLATFORM_MAEMO
   WEBGL_PLATFORM = EGL
   DEFINES += -DUSE_GLES2
+ifeq (1,$(HAVE_ARM_NEON))
+ASFILES := gl_to_pixman_convert.s
+endif
 else
   WEBGL_PLATFORM = GLX
   EXTRA_DSO_LIBS += X11
 endif
 endif
 
 ifeq ($(MOZ_WIDGET_TOOLKIT),windows)
 CPPSRCS += nsGLPbufferWGL.cpp
Index: mozilla/content/canvas/src/WebGLContext.cpp
===================================================================
--- mozilla.orig/content/canvas/src/WebGLContext.cpp
+++ mozilla/content/canvas/src/WebGLContext.cpp
@@ -246,24 +246,34 @@ WebGLContext::Render(gfxContext *ctx, gf
         glDeleteTextures(1, &tex);
 
         mCanvasElement->GLWidgetSwapBuffers();
         mCanvasElement->GLWidgetEndDrawing();
     } else
 #endif
     {
         nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
+        if (surf->GetType() == gfxASurface::SurfaceTypeImage) {
+            // For image surface we use special trick, wich allow us to make cheap vertical flip
+            nsRefPtr<gfxImageSurface> img = static_cast<gfxImageSurface*>(mGLPbuffer->ThebesSurface());
+            nsRefPtr<gfxImageSurface> imgSwap =
+                new gfxImageSurface(img->Data() + img->GetDataSize() - img->Stride(),
+                                    gfxIntSize(img->Width(), img->Height()),
+                                    -img->Stride(), gfxASurface::ImageFormatARGB32);
+            surf = imgSwap;
+        }
         if (!surf)
             return NS_OK;
         // XXX we can optimize this on win32 at least, by creating an upside-down
         // DIB.
         nsRefPtr<gfxPattern> pat = new gfxPattern(surf);
 
 #if defined(USE_EGL) && defined(MOZ_X11)
-        if (getenv("IMAGE")) {
+        // Don't do translate + scale if it is imageSurface, pixman not doing it with optimized function
+        if (surf->GetType() != gfxASurface::SurfaceTypeImage) {
 #endif
         gfxMatrix m;
         m.Translate(gfxPoint(0.0, mGLPbuffer->Height()));
         m.Scale(1.0, -1.0);
         pat->SetMatrix(m);
 #if defined(USE_EGL) && defined(MOZ_X11)
         }
 #endif
Index: mozilla/content/canvas/src/gl_to_pixman_convert.s
===================================================================
--- /dev/null
+++ mozilla/content/canvas/src/gl_to_pixman_convert.s
@@ -0,0 +1,270 @@
+/*
+ * Copyright Â© 2009 Nokia Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Nokia Corporation not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Nokia Corporation makes no
+ * representations about the suitability of this software for any purpose.
+ * It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Author:  Siarhei Siamashka (siarhei.siamashka@nokia.com)
+ *
+ * WARNING: This file is automatically generated from a macro template.
+ * Sources are maintained as part of pixman library.
+ */
+
+/* Prevent the stack from becoming executable for no reason... */
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
+
+.text
+.fpu neon
+.syntax unified
+
+.global pixman_composite_src_pixbuf_8888_asm_neon
+pixman_composite_src_pixbuf_8888_asm_neon:
+	push	{r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
+	ldr	r4, [sp, #40]
+	mov	sl, #0
+	ldr	r5, [sp, #44]
+	mov	r6, r2
+	mov	fp, r4
+	mov	ip, r6
+	mov	lr, r7
+	lsl	r9, r1, #4
+	sub	r9, r9, #6
+	subs	r1, r1, #1
+	mov	r7, r0
+	blt	0f
+	cmp	r0, #16
+	blt	1f
+15:	tst	r6, #15
+	beq	2f
+	tst	r6, #4
+	beq	3f
+	vld1.32	{d0[1]}, [r4]!
+	add	r6, r6, #4
+	add	sl, sl, #1
+	sub	r0, r0, #1
+3:	tst	r6, #8
+	beq	4f
+	vld1.32	{d1}, [r4]!
+	add	r6, r6, #8
+	add	sl, sl, #2
+	sub	r0, r0, #2
+4:	vld1.32	{d2-d3}, [r4]!
+	add	r6, r6, #16
+	add	sl, sl, #4
+	sub	r0, r0, #4
+	vuzp.8	d0, d1
+	vuzp.8	d2, d3
+	vuzp.8	d1, d3
+	vuzp.8	d0, d2
+	vmull.u8	q8, d3, d0
+	vmull.u8	q9, d3, d1
+	vmull.u8	q10, d3, d2
+	tst	r9, #15
+	addne	sl, sl, #8
+	subne	r9, r9, #1
+	cmp	sl, r7
+	pld	[fp, sl, lsl #2]
+	subge	sl, sl, r7
+	subsge	r9, r9, #16
+	ldrbge	r8, [fp, r5, lsl #2]!
+	vrshr.u16	q11, q8, #8
+	vswp	d3, d31
+	vrshr.u16	q12, q9, #8
+	vrshr.u16	q13, q10, #8
+	vraddhn.i16	d30, q11, q8
+	vraddhn.i16	d29, q12, q9
+	vraddhn.i16	d28, q13, q10
+	vzip.8	d28, d30
+	vzip.8	d29, d31
+	vzip.8	d30, d31
+	vzip.8	d28, d29
+	tst	r2, #4
+	beq	5f
+	vst1.32	{d28[1]}, [r2]!
+5:	tst	r2, #8
+	beq	6f
+	vst1.32	{d29}, [r2, :64]!
+6:	vst1.32	{d30-d31}, [r2, :128]!
+2:	vld4.8	{d0-d3}, [r4]!
+	add	sl, sl, #8
+	vmull.u8	q8, d3, d0
+	vmull.u8	q9, d3, d1
+	vmull.u8	q10, d3, d2
+	tst	r9, #15
+	addne	sl, sl, #8
+	subne	r9, r9, #1
+	cmp	sl, r7
+	pld	[fp, sl, lsl #2]
+	subge	sl, sl, r7
+	subsge	r9, r9, #16
+	ldrbge	r8, [fp, r5, lsl #2]!
+	subs	r0, r0, #16
+	blt	7f
+8:	vrshr.u16	q11, q8, #8
+	vswp	d3, d31
+	vrshr.u16	q12, q9, #8
+	vrshr.u16	q13, q10, #8
+	vld4.8	{d0-d3}, [r4]!
+	vraddhn.i16	d30, q11, q8
+	add	sl, sl, #8
+	tst	r9, #15
+	addne	sl, sl, #8
+	subne	r9, r9, #1
+	vraddhn.i16	d29, q12, q9
+	vraddhn.i16	d28, q13, q10
+	vmull.u8	q8, d3, d0
+	vmull.u8	q9, d3, d1
+	vmull.u8	q10, d3, d2
+	vst4.8	{d28-d31}, [r2, :128]!
+	cmp	sl, r7
+	pld	[fp, sl, lsl #2]
+	subge	sl, sl, r7
+	subsge	r9, r9, #16
+	ldrbge	r8, [fp, r5, lsl #2]!
+	subs	r0, r0, #8
+	bge	8b
+7:	vrshr.u16	q11, q8, #8
+	vswp	d3, d31
+	vrshr.u16	q12, q9, #8
+	vrshr.u16	q13, q10, #8
+	vraddhn.i16	d30, q11, q8
+	vraddhn.i16	d29, q12, q9
+	vraddhn.i16	d28, q13, q10
+	vst4.8	{d28-d31}, [r2, :128]!
+	tst	r0, #7
+	beq	9f
+	tst	r0, #4
+	beq	10f
+	vld1.32	{d2-d3}, [r4]!
+	add	sl, sl, #4
+10:	tst	r0, #2
+	beq	11f
+	vld1.32	{d1}, [r4]!
+	add	sl, sl, #2
+11:	tst	r0, #1
+	beq	12f
+	vld1.32	{d0[1]}, [r4]!
+	add	sl, sl, #1
+12:	vuzp.8	d0, d1
+	vuzp.8	d2, d3
+	vuzp.8	d1, d3
+	vuzp.8	d0, d2
+	vmull.u8	q8, d3, d0
+	vmull.u8	q9, d3, d1
+	vmull.u8	q10, d3, d2
+	tst	r9, #15
+	addne	sl, sl, #8
+	subne	r9, r9, #1
+	cmp	sl, r7
+	pld	[fp, sl, lsl #2]
+	subge	sl, sl, r7
+	subsge	r9, r9, #16
+	ldrbge	r8, [fp, r5, lsl #2]!
+	vrshr.u16	q11, q8, #8
+	vswp	d3, d31
+	vrshr.u16	q12, q9, #8
+	vrshr.u16	q13, q10, #8
+	vraddhn.i16	d30, q11, q8
+	vraddhn.i16	d29, q12, q9
+	vraddhn.i16	d28, q13, q10
+	vzip.8	d28, d30
+	vzip.8	d29, d31
+	vzip.8	d30, d31
+	vzip.8	d28, d29
+	tst	r0, #4
+	beq	13f
+	vst1.32	{d30-d31}, [r2, :128]!
+13:	tst	r0, #2
+	beq	14f
+	vst1.32	{d29}, [r2, :64]!
+14:	tst	r0, #1
+	beq	9f
+	vst1.32	{d28[1]}, [r2]!
+9:	mov	r0, r7
+	add	r2, r2, r3, lsl #2
+	add	r4, r4, r5, lsl #2
+	sub	r2, r2, r0, lsl #2
+	sub	r4, r4, r0, lsl #2
+	subs	r1, r1, #1
+	mov	r6, r2
+	bge	15b
+	pop	{r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
+1:	tst	r0, #8
+	beq	16f
+	vld4.8	{d0-d3}, [r4]!
+	vmull.u8	q8, d3, d0
+	vmull.u8	q9, d3, d1
+	vmull.u8	q10, d3, d2
+	vrshr.u16	q11, q8, #8
+	vswp	d3, d31
+	vrshr.u16	q12, q9, #8
+	vrshr.u16	q13, q10, #8
+	vraddhn.i16	d30, q11, q8
+	vraddhn.i16	d29, q12, q9
+	vraddhn.i16	d28, q13, q10
+	vst4.8	{d28-d31}, [r2]!
+16:	tst	r0, #7
+	beq	17f
+	tst	r0, #4
+	beq	18f
+	vld1.32	{d2-d3}, [r4]!
+18:	tst	r0, #2
+	beq	19f
+	vld1.32	{d1}, [r4]!
+19:	tst	r0, #1
+	beq	20f
+	vld1.32	{d0[1]}, [r4]!
+20:	vuzp.8	d0, d1
+	vuzp.8	d2, d3
+	vuzp.8	d1, d3
+	vuzp.8	d0, d2
+	vmull.u8	q8, d3, d0
+	vmull.u8	q9, d3, d1
+	vmull.u8	q10, d3, d2
+	vrshr.u16	q11, q8, #8
+	vswp	d3, d31
+	vrshr.u16	q12, q9, #8
+	vrshr.u16	q13, q10, #8
+	vraddhn.i16	d30, q11, q8
+	vraddhn.i16	d29, q12, q9
+	vraddhn.i16	d28, q13, q10
+	vzip.8	d28, d30
+	vzip.8	d29, d31
+	vzip.8	d30, d31
+	vzip.8	d28, d29
+	tst	r0, #4
+	beq	21f
+	vst1.32	{d30-d31}, [r2]!
+21:	tst	r0, #2
+	beq	22f
+	vst1.32	{d29}, [r2]!
+22:	tst	r0, #1
+	beq	17f
+	vst1.32	{d28[1]}, [r2]!
+17:	mov	r0, r7
+	add	r2, r2, r3, lsl #2
+	add	r4, r4, r5, lsl #2
+	sub	r2, r2, r0, lsl #2
+	sub	r4, r4, r0, lsl #2
+	subs	r1, r1, #1
+	mov	r6, r2
+	bge	1b
+0:	pop	{r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}
Index: mozilla/content/canvas/src/nsGLPbufferEGL.cpp
===================================================================
--- mozilla.orig/content/canvas/src/nsGLPbufferEGL.cpp
+++ mozilla/content/canvas/src/nsGLPbufferEGL.cpp
@@ -51,31 +51,38 @@
 #ifdef MOZ_X11
 #include <gdk/gdkx.h>
 
 typedef Display* EGLNativeDisplayType;
 typedef Window EGLNativeWindowType;
 typedef Pixmap EGLNativePixmapType;
 #endif
 
+#ifdef HAVE_ARM_NEON
+extern "C" {
+void pixman_composite_src_pixbuf_8888_asm_neon(int width, int height, uint32_t *dst, int dst_stride, uint32_t *src, int src_stride);
+}
+#endif
+
 #ifdef WINCE
 typedef HDC EGLNativeDisplayType;
 typedef HWND EGLNativeWindowType;
 typedef HDC EGLNativePixmapType;
 #endif
 
 // some EGL defines
 #define EGL_DEFAULT_DISPLAY             ((EGLNativeDisplayType)0)
 #define EGL_NO_CONTEXT                  ((EGLContext)0)
 #define EGL_NO_DISPLAY                  ((EGLDisplay)0)
 #define EGL_NO_SURFACE                  ((EGLSurface)0)
 
 using namespace mozilla;
 
 static PRUint32 gActiveBuffers = 0;
+static PRBool gImageRender = PR_FALSE;
 
 class EGLWrap
     : public LibrarySymbolLoader
 {
 public:
     EGLWrap() : fGetCurrentContext(0) { }
 
     bool Init();
@@ -300,16 +307,27 @@ nsGLPbufferEGL::Init(mozilla::WebGLConte
         return PR_FALSE;
     }
 
     LogMessage("GLWrap.Init");
     if (!mGLWrap.Init(GLES20Wrap::TRY_NATIVE_GL)) {
         LogMessage("Canvas 3D: GLWrap init failed");
         return PR_FALSE;
     }
+
+    // first check our global pref
+    nsresult rv;
+    nsCOMPtr<nsIPrefBranch> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, PR_FALSE);
+
+    PRBool var = PR_FALSE;
+    rv = prefService->GetBoolPref("webgl.render_image", &var);
+    if (NS_SUCCEEDED(rv) && var)
+        gImageRender = PR_TRUE;
+
     LogMessage("Init done");
     return PR_TRUE;
 }
 
 PRBool
 nsGLPbufferEGL::Resize(PRInt32 width, PRInt32 height)
 {
     if (mWidth == width &&
@@ -458,30 +476,39 @@ nsGLPbufferEGL::SwapBuffers()
     MakeContextCurrent();
 
     //printf ("SwapBuffers0: %04x\n", mGLWrap.fGetError());
 
     // this is wrong, we need to figure out a way to swap this, but we don't do anything here
     mGLWrap.fFinish ();
 
     mGLWrap.fReadPixels (0, 0, mWidth, mHeight, LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE, mThebesSurface->Data());
+#ifdef HAVE_ARM_NEON
+    // premultiply the image and convert from RGBA->BGRA
+    pixman_composite_src_pixbuf_8888_asm_neon(mThebesSurface->Width(),
+                                              mThebesSurface->Height(),
+                                              (uint32_t*)mThebesSurface->Data(),
+                                              mThebesSurface->Stride()/4,
+                                              (uint32_t*)mThebesSurface->Data(),
+                                              mThebesSurface->Stride()/4);
+#endif
 
     //printf ("SwapBuffers: %04x\n", mGLWrap.fGetError());
 
 #if 0
     // premultiply the image
     int len = mWidth*mHeight*4;
     unsigned char *src = mThebesSurface->Data();
     Premultiply(src, len);
 #endif
 }
 
 gfxASurface*
 nsGLPbufferEGL::ThebesSurface()
 {
 #if defined(MOZ_X11) && defined(MOZ_PLATFORM_MAEMO)
-    if (getenv("IMAGE"))
+    if (gImageRender)
         return mThebesSurface;
     return mXlibSurface;
 #elif defined(WINCE)
     return mThebesSurface;
 #endif
 }
