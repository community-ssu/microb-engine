#https://bugzilla.mozilla.org/show_bug.cgi?id=422540 
# gstreamer html5 support
Index: mozilla/config/autoconf.mk.in
===================================================================
--- mozilla.orig/config/autoconf.mk.in
+++ mozilla/config/autoconf.mk.in
@@ -176,16 +176,17 @@ MOZ_NO_DOWNLOADMGR = @MOZ_NO_DOWNLOADMGR
 MOZ_ZIPWRITER = @MOZ_ZIPWRITER@
 MOZ_MORK = @MOZ_MORK@
 MOZ_MORKREADER = @MOZ_MORKREADER@
 MOZ_NO_XPCOM_OBSOLETE = @MOZ_NO_XPCOM_OBSOLETE@
 MOZ_NO_FAST_LOAD = @MOZ_NO_FAST_LOAD@
 MOZ_OGG = @MOZ_OGG@
 MOZ_SYDNEYAUDIO = @MOZ_SYDNEYAUDIO@
 MOZ_WAVE = @MOZ_WAVE@
+MOZ_GSTREAMER = @MOZ_GSTREAMER@
 MOZ_MEDIA = @MOZ_MEDIA@
 NS_PRINTING = @NS_PRINTING@
 MOZ_CRASHREPORTER = @MOZ_CRASHREPORTER@
 MOZ_HELP_VIEWER = @MOZ_HELP_VIEWER@
 MOC= @MOC@
 
 MOZ_JAVAXPCOM = @MOZ_JAVAXPCOM@
 JAVA_INCLUDE_PATH="@JAVA_INCLUDE_PATH@"
@@ -638,16 +639,19 @@ OGLES_SDK_DIR   = @OGLES_SDK_DIR@
 
 WINCE_WINDOWS_MOBILE = @WINCE_WINDOWS_MOBILE@
 
 HAS_OGLES = @HAS_OGLES@
 
 MOZ_DISTRIBUTION_ID = @MOZ_DISTRIBUTION_ID@
 
 NS_OSSO 	= @NS_OSSO@
+
+GSTREAMER_CFLAGS = @GSTREAMER_CFLAGS@
+GSTREAMER_LIBS   = @GSTREAMER_LIBS@
 MOZ_PLATFORM_HILDON = @MOZ_PLATFORM_HILDON@
 
 LIBHILDONMIME_CFLAGS	= @LIBHILDONMIME_CFLAGS@
 LIBHILDONMIME_LIBS	= @LIBHILDONMIME_LIBS@
 LIBOSSO_CFLAGS 	= @LIBOSSO_CFLAGS@
 LIBOSSO_LIBS 	= @LIBOSSO_LIBS@
 LIBHILDONFM_CFLAGS	= @LIBHILDONFM_CFLAGS@
 LIBHILDONFM_LIBS	= @LIBHILDONFM_LIBS@
Index: mozilla/config/system-headers
===================================================================
--- mozilla.orig/config/system-headers
+++ mozilla/config/system-headers
@@ -292,16 +292,66 @@ glib-object.h
 gmodule.h
 gnome.h
 gnu/libc-version.h
 grp.h
 gssapi_generic.h
 gssapi/gssapi_generic.h
 gssapi/gssapi.h
 gssapi.h
+gst/gst.h
+gst/app/gstappsrc.h
+gst/base/gstpushsrc.h
+gst/base/gstbasesink.h
+gst/base/gstbasesrc.h
+gst/glib-compat.h
+gst/gstenumtypes.h
+gst/gstversion.h
+gst/gstbin.h
+gst/gstbuffer.h
+gst/gstcaps.h
+gst/gstchildproxy.h
+gst/gstclock.h
+gst/gstelement.h
+gst/gsterror.h
+gst/gstevent.h
+gst/gstghostpad.h
+gst/gstindex.h
+gst/gstindexfactory.h
+gst/gstinfo.h
+gst/gstinterface.h
+gst/gstiterator.h
+gst/gstmarshal.h
+gst/gstmessage.h
+gst/gstminiobject.h
+gst/gstobject.h
+gst/gstpad.h
+gst/gstparamspecs.h
+gst/gstpipeline.h
+gst/gstplugin.h
+gst/gstquery.h
+gst/gstregistry.h
+gst/gstsegment.h
+gst/gststructure.h
+gst/gstsystemclock.h
+gst/gsttaglist.h
+gst/gsttagsetter.h
+gst/gsttask.h
+gst/gsttrace.h
+gst/gsttypefind.h
+gst/gsttypefindfactory.h
+gst/gsturi.h
+gst/gstutils.h
+gst/gstvalue.h
+gst/gstxml.h
+gst/gstparse.h
+gst/gstcompat.h
+gst/video/gstvideosink.h
+gst/video/video.h
+gst/video/video-enumtypes.h
 gtk/gtk.h
 gtk/gtkprinter.h
 gtk/gtkprintjob.h
 gtk/gtkprintunixdialog.h
 HIToolbox/HIToolbox.h
 hlink.h
 htiface.h
 ia64/sys/inline.h
Index: mozilla/configure.in
===================================================================
--- mozilla.orig/configure.in
+++ mozilla/configure.in
@@ -5578,16 +5578,49 @@ dnl = Handle dependent SYDNEYAUDIO and M
 dnl ========================================================
 
 AC_SUBST(MOZ_SYDNEYAUDIO)
 
 if test -n "$MOZ_SYDNEYAUDIO"; then
     AC_DEFINE(MOZ_SYDNEYAUDIO)
 fi
 
+dnl ========================================================
+dnl = Enable GStreamer
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(gstreamer,
+[  --enable-gstreamer           Enable GStreamer support],
+MOZ_GSTREAMER=1,
+MOZ_GSTREAMER=)
+
+PKG_CHECK_MODULES(GSTREAMER,
+                  gstreamer-base-0.10 gstreamer-0.10 gstreamer-plugins-base-0.10)
+if test -n "$GSTREAMER_LIBS"; then
+   _SAVE_LDFLAGS=$LDFLAGS
+   LDFLAGS="$LDFLAGS -lgstvideo-0.10"
+   AC_TRY_LINK(,[return 0;],_HAVE_LIBGSTVIDEO=1,_HAVE_LIBGSTVIDEO=)
+   if test -n "$_HAVE_LIBGSTVIDEO" ; then
+      GSTREAMER_LIBS="$GSTREAMER_LIBS -lgstvideo-0.10"
+   else
+      AC_MSG_ERROR([gstreamer video backend requires libgstvideo])
+   fi
+   LDFLAGS=$_SAVE_LDFLAGS
+else
+   AC_MSG_ERROR([gstreamer backend requires the gstreamer packages])
+fi
+
+AC_SUBST(GSTREAMER_CFLAGS)
+AC_SUBST(GSTREAMER_LIBS)
+AC_SUBST(MOZ_GSTREAMER)
+
+if test -n "$MOZ_GSTREAMER"; then
+   AC_DEFINE(MOZ_GSTREAMER)
+   MOZ_MEDIA=1
+fi
+
 AC_SUBST(MOZ_MEDIA)
 
 if test -n "$MOZ_MEDIA"; then
     AC_DEFINE(MOZ_MEDIA)
 fi
 
 dnl ========================================================
 dnl = Check alsa availability on Linux if using sydneyaudio
Index: mozilla/content/canvas/src/nsCanvasRenderingContext2D.cpp
===================================================================
--- mozilla.orig/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ mozilla/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -3363,16 +3363,17 @@ nsCanvasRenderingContext2D::DrawWindow(n
 
     nsIPresShell* presShell = presContext->PresShell();
     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 
     nsRect r(nsPresContext::CSSPixelsToAppUnits(aX),
              nsPresContext::CSSPixelsToAppUnits(aY),
              nsPresContext::CSSPixelsToAppUnits(aW),
              nsPresContext::CSSPixelsToAppUnits(aH));
+
     PRUint32 renderDocFlags = nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_CARET) {
         renderDocFlags |= nsIPresShell::RENDER_CARET;
     }
     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_VIEW) {
         renderDocFlags &= ~nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
     }
 
Index: mozilla/content/html/content/public/nsHTMLMediaElement.h
===================================================================
--- mozilla.orig/content/html/content/public/nsHTMLMediaElement.h
+++ mozilla/content/html/content/public/nsHTMLMediaElement.h
@@ -30,16 +30,20 @@
  * under the terms of either the GPL or the LGPL, and not to allow others to
  * use your version of this file under the terms of the MPL, indicate your
  * decision by deleting the provisions above and replace them with the notice
  * and other provisions required by the GPL or the LGPL. If you do not delete
  * the provisions above, a recipient may use your version of this file under
  * the terms of any one of the MPL, the GPL or the LGPL.
  *
  * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsHTMLMediaElement_h__
+#define nsHTMLMediaElement_h__
+
 #include "nsIDOMHTMLMediaElement.h"
 #include "nsGenericHTMLElement.h"
 #include "nsMediaDecoder.h"
 #include "nsIChannel.h"
 #include "nsThreadUtils.h"
 #include "nsIDOMRange.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsILoadGroup.h"
@@ -515,8 +519,11 @@ protected:
   // when the poster frame should be shown.
   PRPackedBool mHasPlayedOrSeeked;
 
   // PR_TRUE if we've added a reference to ourselves to keep the element
   // alive while no-one is referencing it but the element may still fire
   // events of its own accord.
   PRPackedBool mHasSelfReference;
 };
+
+#endif
+
Index: mozilla/content/html/content/src/nsHTMLMediaElement.cpp
===================================================================
--- mozilla.orig/content/html/content/src/nsHTMLMediaElement.cpp
+++ mozilla/content/html/content/src/nsHTMLMediaElement.cpp
@@ -77,16 +77,19 @@
 #include "nsContentPolicyUtils.h"
 #include "nsContentErrors.h"
 #include "nsCrossSiteListenerProxy.h"
 #include "nsCycleCollectionParticipant.h"
 
 #ifdef MOZ_OGG
 #include "nsOggDecoder.h"
 #endif
+#ifdef MOZ_GSTREAMER
+#include "nsGStreamerDecoder.h"
+#endif
 #ifdef MOZ_WAVE
 #include "nsWaveDecoder.h"
 #endif
 
 #ifdef PR_LOGGING
 static PRLogModuleInfo* gMediaElementLog;
 static PRLogModuleInfo* gMediaElementEventsLog;
 #define LOG(type, msg) PR_LOG(gMediaElementLog, type, msg)
@@ -1224,24 +1227,36 @@ enum CanPlayStatus {
   CANPLAY_YES
 };
 
 static CanPlayStatus GetCanPlay(const nsAString& aType)
 {
   nsContentTypeParser parser(aType);
   nsAutoString mimeType;
   nsresult rv = parser.GetType(mimeType);
+
+  // Fail if we couldn't get the mimetype
   if (NS_FAILED(rv))
     return CANPLAY_NO;
 
   NS_ConvertUTF16toUTF8 mimeTypeUTF8(mimeType);
   const char** supportedCodecs;
+
+  // Check if any decoders knows about the mime type
   if (!nsHTMLMediaElement::CanHandleMediaType(mimeTypeUTF8.get(),
-                                              &supportedCodecs))
+                                              &supportedCodecs)) {
+    // We can always fall back to the GStreamer library
+    // if it is installed - but we don't know if it can
+    // handle it, until we actually try
+#ifdef MOZ_GSTREAMER
+    return CANPLAY_MAYBE;
+#else
     return CANPLAY_NO;
+#endif
+  }
 
   nsAutoString codecs;
   rv = parser.GetParameter("codecs", codecs);
   if (NS_FAILED(rv))
     // Parameter not found or whatever
     return CANPLAY_MAYBE;
 
   CanPlayStatus result = CANPLAY_YES;
@@ -1312,32 +1327,46 @@ void nsHTMLMediaElement::ShutdownMediaTy
     }
 #endif
   }
 }
 
 already_AddRefed<nsMediaDecoder>
 nsHTMLMediaElement::CreateDecoder(const nsACString& aType)
 {
+  // We have not found a decoder yet, so make sure we don't think so
+  mDecoder = nsnull;
+
 #ifdef MOZ_OGG
-  if (IsOggType(aType)) {
+  if (!mDecoder && IsOggType(aType)) {
     nsRefPtr<nsOggDecoder> decoder = new nsOggDecoder();
     if (decoder && decoder->Init(this)) {
       return decoder.forget().get();
     }
   }
 #endif
 #ifdef MOZ_WAVE
-  if (IsWaveType(aType)) {
+  if (!mDecoder && IsWaveType(aType)) {
     nsRefPtr<nsWaveDecoder> decoder = new nsWaveDecoder();
     if (decoder && decoder->Init(this)) {
       return decoder.forget().get();
     }
   }
 #endif
+
+#ifdef MOZ_GSTREAMER
+  // If enabled, use GStreamer as fall back decoder
+  if (!mDecoder) {
+    mDecoder = nsGStreamerDecoder::makeNewInstance();
+    if (mDecoder && !mDecoder->Init(this)) {
+      mDecoder = nsnull;
+    }
+  }
+#endif
+
   return nsnull;
 }
 
 nsresult nsHTMLMediaElement::InitializeDecoderAsClone(nsMediaDecoder* aOriginal)
 {
   nsMediaStream* originalStream = aOriginal->GetCurrentStream();
   if (!originalStream)
     return NS_ERROR_FAILURE;
Index: mozilla/content/media/Makefile.in
===================================================================
--- mozilla.orig/content/media/Makefile.in
+++ mozilla/content/media/Makefile.in
@@ -104,16 +104,20 @@ DIRS =
 ifdef MOZ_OGG
 DIRS += ogg
 endif
 
 ifdef MOZ_WAVE
 DIRS += wave
 endif
 
+ifdef MOZ_GSTREAMER
+DIRS += gstreamer
+endif
+
 ifdef ENABLE_TESTS
 DIRS += test
 endif
 
 FORCE_STATIC_LIB = 1
 
 include $(topsrcdir)/config/rules.mk
 
Index: mozilla/content/media/gstreamer/Makefile.in
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/Makefile.in
@@ -0,0 +1,111 @@
+# ***** BEGIN LICENSE BLOCK *****
+# Version: MPL 1.1/GPL 2.0/LGPL 2.1
+#
+# The contents of this file are subject to the Mozilla Public License Version
+# 1.1 (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+# http://www.mozilla.org/MPL/
+#
+# Software distributed under the License is distributed on an "AS IS" basis,
+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+# for the specific language governing rights and limitations under the
+# License.
+#
+# The Original Code is Mozilla code.
+#
+# The Initial Developer of the Original Code is the Mozilla Corporation.
+# Portions created by the Initial Developer are Copyright (C) 2007
+# the Initial Developer. All Rights Reserved.
+#
+# Contributor(s):
+#  Chris Double <chris.double@double.co.nz>
+#
+# Alternatively, the contents of this file may be used under the terms of
+# either the GNU General Public License Version 2 or later (the "GPL"), or
+# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+# in which case the provisions of the GPL or the LGPL are applicable instead
+# of those above. If you wish to allow use of your version of this file only
+# under the terms of either the GPL or the LGPL, and not to allow others to
+# use your version of this file under the terms of the MPL, indicate your
+# decision by deleting the provisions above and replace them with the notice
+# and other provisions required by the GPL or the LGPL. If you do not delete
+# the provisions above, a recipient may use your version of this file under
+# the terms of any one of the MPL, the GPL or the LGPL.
+#
+# ***** END LICENSE BLOCK *****
+
+DEPTH		= ../../..
+topsrcdir	= @top_srcdir@
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+
+include $(DEPTH)/config/autoconf.mk
+
+MODULE		= content
+LIBRARY_NAME	= gkcongstreamer_s
+LIBXUL_LIBRARY 	= 1
+
+REQUIRES	= \
+		xpcom \
+		string \
+		gfx \
+		content \
+		thebes \
+		layout \
+		widget \
+		dom \
+		js \
+		locale \
+		unicharutil \
+		webshell \
+		uriloader \
+		htmlparser \
+		necko \
+		view \
+		pref \
+		docshell \
+		xpconnect \
+		xuldoc \
+		caps \
+		editor \
+		imglib2 \
+		mimetype \
+		exthandler \
+		uconv \
+		intl \
+		plugin \
+		cairo \
+		libpixman \
+		$(NULL)
+
+EXPORTS		+= \
+		nsGStreamerDecoder.h \
+		$(NULL)
+
+CPPSRCS		= \
+		nsGStreamerDecoder.cpp \
+		nsGStreamerAudioBin.cpp \
+		nsGStreamerDecodeBin.cpp \
+		nsGStreamerElementWrapper.cpp \
+		nsGStreamerInputBin.cpp \
+		nsGStreamerLib.cpp \
+		nsGStreamerLink.cpp \
+		nsGStreamerLog.cpp \
+		nsGStreamerPipeline.cpp \
+		nsGStreamerPipelineState.cpp \
+		nsGStreamerVideoBin.cpp \
+		nsGstStreamSrc.cpp \
+		nsGstVideoSink.cpp \
+		$(NULL)
+
+FORCE_STATIC_LIB = 1
+
+include $(topsrcdir)/config/rules.mk
+
+CFLAGS		+= $(GSTREAMER_CFLAGS)
+CXXFLAGS	+= $(GSTREAMER_CFLAGS)
+
+INCLUDES	+= \
+		-I$(srcdir)/../../base/src \
+		-I$(srcdir)/../../html/content/src \
+		$(NULL)
Index: mozilla/content/media/gstreamer/nsGStreamerAudioBin.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerAudioBin.cpp
@@ -0,0 +1,316 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nscore.h"
+#include "nsGStreamerAudioBin.h"
+#include "nsGStreamerLog.h"
+
+
+nsGStreamerAudioBin::nsGStreamerAudioBin()
+  : mAudioBin(nsnull),
+    mAudioSink(nsnull),
+    mAudioConvert(nsnull),
+    mAudioBuffer(nsnull),
+    mAudioVolume(nsnull),
+    mDelayLinkage(PR_FALSE)
+{
+}
+
+nsGStreamerAudioBin::~nsGStreamerAudioBin()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerAudioBin\n"));
+  // Ensure we have released all our resources
+  Destroy();
+}
+
+PRBool nsGStreamerAudioBin::Create()
+{
+  // Make sure we don't have something hanging around that we shouldn't
+  Destroy();
+
+  // We assume a fail until we have proven success
+  PRBool isSuccess = PR_FALSE;
+
+  mAudioBin = GST_BIN_CAST(gst_bin_new("mAudioBin"));
+
+  // Create a buffer for the audio => Running in separate thread
+  mAudioBuffer = gst_element_factory_make("queue", "mAudioBuffer");
+
+  // Create the audio converter
+  mAudioConvert = gst_element_factory_make("audioconvert", "mAudioConvert");
+
+  // Find the best possible sink
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("gconfaudiosink", "mAudioSink");
+  }
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("pulsesink", "mAudioSink");
+  }
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("alsasink", "mAudioSink");
+  }
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("osssink", "mAudioSink");
+  }
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("oss4sink", "mAudioSink");
+  }
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("sdlaudiosink", "mAudioSink");
+  }
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("esdsink", "mAudioSink");
+  }
+  if (!mAudioSink) {
+    mAudioSink = gst_element_factory_make("autoaudiosink", "mAudioSink");
+    // We don't wan't to add this, or link it
+    mDelayLinkage = PR_TRUE;
+  }
+
+  // Now stuff gets a little complicated - cause on the N810 our only choice for
+  // audio sink is the "autoaudiosink" which we at this time can't add to
+  // our bin, as we need to set it's filter property before we enter the pause
+  // state.
+  //
+  // So that's the reason we in the below code treat mAudioSink a litle special
+
+  mAudioVolume = gst_element_factory_make("volume", "mAudioVolume");
+
+  // Take ownership of the elements
+  gst_object_sink(gst_object_ref(GST_OBJECT(mAudioBin)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mAudioBuffer)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mAudioConvert)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mAudioSink)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mAudioVolume)));
+
+  // Note: the below if-statement is not inline with the Mozilla coding-standard
+  // but it is also an exceptional if statement, I haven't been able to find
+  // another layout that as clearly supports the meaning of what is done
+  if (
+      // Check that we got all of our components
+         mAudioBin
+      && mAudioBuffer
+      && mAudioConvert
+      && mAudioSink
+      && mAudioVolume
+      //  Add the elements to the audio bin
+      && gst_bin_add(mAudioBin, mAudioBuffer)
+      // Only add the elements if we are sure we can use them
+      && (mDelayLinkage || gst_bin_add(mAudioBin, mAudioConvert))
+      && (mDelayLinkage || gst_bin_add(mAudioBin, mAudioSink))
+      && (mDelayLinkage || gst_bin_add(mAudioBin, mAudioVolume))
+      // Link the elements, being carefull about the audioSink
+      // we can't have volume control etc. if we use the autobuffer on N810
+      && (mDelayLinkage || (   gst_element_link_pads( mAudioBuffer,
+                                                      "src",
+                                                      mAudioConvert,
+                                                      "sink")
+                            && gst_element_link_pads( mAudioConvert,
+                                                      "src",
+                                                      mAudioVolume,
+                                                      "sink")
+                            && gst_element_link_pads( mAudioVolume,
+                                                      "src",
+                                                      mAudioSink,
+                                                      nsnull))))
+  {
+    const guint max_buffer_buffers = 0;
+    const guint max_buffer_size_in_bytes = 0;
+          guint64 max_buffer_time_in_ns   = 10;     // 10 seconds
+                  max_buffer_time_in_ns  *= 1000;
+                  max_buffer_time_in_ns  *= 1000;
+                  max_buffer_time_in_ns  *= 1000;
+    const guint min_threshold_in_bytes = 0;
+          guint64 min_threshold_in_ns   = 2;        // 2 seconds
+//                  min_threshold_in_ns  *= 1000;
+//                  min_threshold_in_ns  *= 1000;
+//                  min_threshold_in_ns  *= 1000;
+    const guint min_threshold_buffers = 0;
+
+    g_object_set( // Object we are setting a property on
+                  G_OBJECT(mAudioBuffer),
+                  // Max no of buffers
+                  "max-size-buffers",
+                  max_buffer_buffers,
+                  // Max buffer size
+                  "max-size-bytes",
+                  max_buffer_size_in_bytes,
+                  // Max time in nanoseconds (1 sec = 1,000,000,000 ns)
+                  "max-size-time",
+                  max_buffer_time_in_ns,
+                  // Min number of bytes before data
+                  // is sent from buffer
+                  "min-threshold-bytes",
+                  min_threshold_in_bytes,
+                  // Min time before data is sent from buffer in ns
+                  "min-threshold-time",
+                  min_threshold_in_ns,
+                  //Min number of buffers to hold
+                  "min-threshold-buffers",
+                  min_threshold_buffers,
+                  //Indicate this was the last property
+                  NULL);
+
+    // If all went well this far then we can create
+    // a ghost pad and add it to the bin
+    GstPad *pad = gst_element_get_static_pad(mAudioBuffer, "sink");
+//    GstPad *pad = gst_element_get_static_pad(mAudioConvert, "sink");
+
+    isSuccess = gst_element_add_pad(GST_ELEMENT_CAST(mAudioBin),
+                                       gst_ghost_pad_new("sink", pad));
+    gst_object_unref(GST_OBJECT(pad));
+  } else {
+    // TODO: Do error handling / cleanup
+  }
+
+  return isSuccess;
+}
+
+void nsGStreamerAudioBin::Destroy()
+{
+  if (mAudioBin) {
+    gst_object_unref(GST_OBJECT(mAudioBin));
+  }
+  if (mAudioSink) {
+    gst_object_unref(GST_OBJECT(mAudioSink));
+  }
+  if (mAudioConvert) {
+    gst_object_unref(GST_OBJECT(mAudioConvert));
+  }
+  if (mAudioBuffer) {
+    gst_object_unref(GST_OBJECT(mAudioBuffer));
+  }
+  if (mAudioVolume) {
+    gst_object_unref(GST_OBJECT(mAudioVolume));
+  }
+
+  mAudioConvert = mAudioSink = mAudioBuffer = mAudioVolume = nsnull;
+  mAudioBin = nsnull;
+}
+
+PRBool nsGStreamerAudioBin::Link(GstPad *aSrc)
+{
+  GstPad *audioPad = gst_element_get_static_pad(*this, "sink");
+
+  // Check that we have an audio sink pad, and that it isn't linked already
+  if (!audioPad || GST_PAD_IS_LINKED(audioPad)) {
+    // Do cleanup
+    gst_object_unref(GST_OBJECT(audioPad));
+    return PR_FALSE;
+  }
+
+  // We have one thing to remember from our create function, if
+  // we didn't link our audio sink, now is the time to do it
+
+  if (mDelayLinkage) {
+    NS_GSTREAMER_LOG(("Attempting late audio linkage\n"));
+    // Get the caps of our audio source
+    GstCaps *caps =  gst_pad_get_caps(aSrc);
+
+    // Make the caps into a gpointer
+    gpointer gvAudioCaps = caps;
+
+    NS_GSTREAMER_LOG(("<<Configuring mAudioSink>>\n"));
+    // Set the Media Stream
+    g_object_set(// Object we are setting a property on
+               G_OBJECT(mAudioSink),
+               // Name of the property
+               "filter-caps",
+               //The value to store in the property
+               gvAudioCaps,
+               //Indicate this was the last property
+               NULL);
+    NS_GSTREAMER_LOG(("filter-caps set\n"));
+
+    // Add the sink to the bin
+    if (gst_bin_add(mAudioBin, mAudioSink)) {
+      NS_GSTREAMER_LOG(("audio sink added\n"));
+    }
+    // Link the mAudioSink
+    if(gst_element_link_pads(mAudioBuffer, "src", mAudioSink,nsnull)) {
+      NS_GSTREAMER_LOG(("AudioBuffer linked with audio sink\n"));
+    }
+
+    // Try to move the audio sink into the ready state
+    gst_element_set_state(mAudioSink, GST_STATE_PAUSED);
+  }
+
+  GstCaps *caps =  gst_pad_get_caps(audioPad);
+  gchar *capsstr = gst_caps_to_string(caps);
+
+  NS_GSTREAMER_LOG(("Trying to link to %s\n", capsstr));
+
+  g_free(capsstr);
+  gst_caps_unref(caps);
+
+  GstPadLinkReturn linkResult = gst_pad_link(aSrc, audioPad);
+  NS_GSTREAMER_LOG(("+++Audio Link Result = %i (0=Up)\n", linkResult));
+
+  return (GST_PAD_LINK_OK == linkResult);
+}
+
+nsGStreamerAudioBin::operator  GstElement *()
+{
+  return GST_ELEMENT_CAST(mAudioBin);
+}
+
+void nsGStreamerAudioBin::SetVolume(float aNewVolume)
+{
+  // Ensure the value is within acceptable range
+  if (aNewVolume > 1) {
+    aNewVolume = 1;
+  }
+  if (aNewVolume < 0) {
+    aNewVolume = 0;
+  }
+
+  // Set the volume if we have a volume element
+  if (mAudioVolume) {
+    gdouble volume = aNewVolume;
+    g_object_set(// Object we are setting a property on
+                 G_OBJECT(mAudioVolume),
+                 // Name of the property
+                 "volume",
+                 //The value to store in the property
+                 volume,
+                 //Indicate this was the last property
+                 NULL);
+  }
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerAudioBin.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerAudioBin.h
@@ -0,0 +1,99 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerAudioBin_h__
+#define nsGStreamerAudioBin_h__
+
+#include "nsGStreamerAudioPropertiesInterface.h"
+
+#include "gst/gst.h"
+#include "prtypes.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that takes care of the audio bin
+
+class nsGStreamerAudioBin
+  : public nsGStreamerAudioPropertiesInterface
+{
+  public:
+    // Constructor
+    nsGStreamerAudioBin();
+
+    // Destructor
+    ~nsGStreamerAudioBin();
+
+    // Function to create an input buffer
+    PRBool Create();
+
+    // Releases all resources allocated
+    void Destroy();
+
+    // Links the audio sink pad to the src pad
+    // Returns: PR_TRUE if link was succesfull
+    // Returns: PR_FALSE if link failed
+    PRBool Link(GstPad *aSrc);
+
+    // Easy way to get the element pointer
+    operator GstElement *();
+
+  private:
+    // Collector bin for the audio stuff
+    GstBin *mAudioBin;
+
+    // Actuall audio sink
+    GstElement *mAudioSink;
+
+    // Audio converter (sample rate etc.)
+    GstElement *mAudioConvert;
+
+    // Audio buffer (to keep everything in sync)
+    GstElement *mAudioBuffer;
+
+    // Element that can modify audio volume
+    GstElement *mAudioVolume;
+
+    // Depending on the audio sink used, we might need to
+    // delay adding it to the bin (as we don't want to change
+    // its state)
+    PRPackedBool mDelayLinkage;
+
+    // Sets the volume of the audio stream (0..1)
+    void SetVolume(float aNewVolume);
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerAudioPropertiesInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerAudioPropertiesInterface.h
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerAudioPropertiesInterface_h__
+#define nsGStreamerAudioPropertiesInterface_h__
+
+////////////////////////////////////////////////////////////////////////////////
+// Interface class to modify audio properties
+
+class nsGStreamerAudioPropertiesInterface
+{
+  public:
+    // Sets the volume of the audio stream (0..1)
+    virtual void SetVolume(float aNewVolume) = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerConfig.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerConfig.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#ifndef nsGStreamerConfig_h__
+#define nsGStreamerConfig_h__
+
+// This file contains compile time configurations for the gstreamer integration
+
+// Define the max size of video elements in pixels
+#define MAX_VIDEO_WIDTH 1024
+#define MAX_VIDEO_HEIGHT 1024
+
+// Define how much data we should try to read at a time
+#define GST_BUFFER_READ_CHUNK_SIZE 1024*16
+
+
+#endif
+
Index: mozilla/content/media/gstreamer/nsGStreamerDecodeBin.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerDecodeBin.cpp
@@ -0,0 +1,146 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+#include "nsGStreamerDecodeBin.h"
+#include "nsGStreamerLog.h"
+#include "nsGStreamerPipelineState.h"
+
+
+nsGStreamerDecodeBin::nsGStreamerDecodeBin()
+  : mDecodeBin(nsnull)
+{
+}
+
+nsGStreamerDecodeBin::~nsGStreamerDecodeBin()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerDecodeBin\n"));
+  // Ensure we have released all our resources
+  Destroy();
+}
+
+PRBool nsGStreamerDecodeBin::Create(nsGStreamerDecodeBinPadInterface *aPadDest)
+{
+  // Save the interface we communicate pad adds/removes with
+  mPadDest = aPadDest;
+
+  // Create the decode bin
+  mDecodeBin = gst_element_factory_make("decodebin2", "mDecodeBin2");
+//  mDecodeBin = gst_element_factory_make("autoconvert", "mDecodeBin2");
+
+  gst_object_sink(gst_object_ref(GST_OBJECT(mDecodeBin)));
+
+  // If we got the decode bin, then configure it
+  if (mDecodeBin) {
+    // The decodebin won't make any output pads, until it knows something about
+    // it's input data since it only at that time can determine the kind of
+    // output, if any, it can generate
+    g_signal_connect(mDecodeBin,
+                     "new-decoded-pad",
+                     G_CALLBACK(DecodeBinNewPadAdded),
+                     this);
+    // Get notified when an unknown type/type that can't be
+    // decoded is added to the autoDecoder
+    g_signal_connect(mDecodeBin,
+                     "unknown-type",
+                     G_CALLBACK(DecodeBinUnknownType),
+                     this);
+    // Get notified when a pad is removed
+    g_signal_connect(mDecodeBin,
+                     "removed-decoded-pad",
+                     G_CALLBACK(DecodeBinRemovePad),
+                     this);
+    // Get notified when the last pad has been found
+    g_signal_connect(mDecodeBin,
+                     "no-more-pads",
+                     G_CALLBACK(DecodeBinNoMorePads),
+                     this);
+  }
+
+  return (mDecodeBin && mPadDest);
+}
+
+
+void nsGStreamerDecodeBin::Destroy()
+{
+  if (mDecodeBin) {
+    gst_object_unref(GST_OBJECT(mDecodeBin));
+  }
+  mDecodeBin = nsnull;
+}
+
+nsGStreamerDecodeBin::operator GstElement *()
+{
+  return GST_ELEMENT_CAST(mDecodeBin);
+}
+
+void nsGStreamerDecodeBin::DecodeBinNewPadAdded(void *,
+                                                GstPad * aPad,
+                                                gboolean aIsLast,
+                                                nsGStreamerDecodeBin * aMe)
+{
+  // Forward call to someone who cares
+  aMe->mPadDest->DecodeBinNewPadAdded(aMe->mDecodeBin,aPad, aIsLast);
+}
+
+void nsGStreamerDecodeBin::DecodeBinUnknownType(void *,
+                                                GstPad * aPad,
+                                                GstCaps * aCaps,
+                                                nsGStreamerDecodeBin * aMe)
+{
+  // Forward call to someone who cares
+  aMe->mPadDest->DecodeBinUnknownType(aMe->mDecodeBin, aPad, aCaps);
+}
+
+void nsGStreamerDecodeBin::DecodeBinRemovePad(void *,
+                                              GstPad *aPad,
+                                              nsGStreamerDecodeBin *aMe)
+{
+  // Forward call to someone who cares
+  aMe->mPadDest->DecodeBinRemovePad(aMe->mDecodeBin, aPad);
+}
+
+void nsGStreamerDecodeBin::DecodeBinNoMorePads(void *,
+                                               nsGStreamerDecodeBin * aMe)
+{
+  NS_GSTREAMER_LOG(("++++event-NoMorePads\n"));
+  // Forward call to someone who cares
+  aMe->mPadDest->DecodeBinNoMorePads(aMe->mDecodeBin);
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerDecodeBin.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerDecodeBin.h
@@ -0,0 +1,91 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerDecodeBin_h__
+#define nsGStreamerDecodeBin_h__
+
+#include "nsGStreamerDecodeBinPadInterface.h"
+
+#include "prtypes.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that takes care of the decode bin
+
+class nsGStreamerDecodeBin
+{
+  public:
+    // Constructor
+    nsGStreamerDecodeBin();
+
+    // Destructor
+    ~nsGStreamerDecodeBin();
+
+    // Function to create the decode bin
+    PRBool Create(nsGStreamerDecodeBinPadInterface *aPadDest);
+
+    // Releases all resources allocated
+    void Destroy();
+
+    // Easy way to get the element pointer
+    operator GstElement *();
+
+  private:
+    GstElement *mDecodeBin;
+
+    nsGStreamerDecodeBinPadInterface *mPadDest;
+
+    // Callbacks
+    static void DecodeBinNewPadAdded(void *,
+                                     GstPad *aPad,
+                                     gboolean aIsLast,
+                                     nsGStreamerDecodeBin *aMe);
+
+    static void DecodeBinUnknownType(void *,
+                                     GstPad *aPad,
+                                     GstCaps * aCaps,
+                                     nsGStreamerDecodeBin *aMe);
+
+    static void DecodeBinRemovePad(void *,
+                                   GstPad *aPad,
+                                   nsGStreamerDecodeBin *aMe);
+
+    static void DecodeBinNoMorePads(void *,
+                                    nsGStreamerDecodeBin *aMe);
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerDecodeBinPadInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerDecodeBinPadInterface.h
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerDecodeBinPadInterface_h__
+#define nsGStreamerDecodeBinPadInterface_h__
+
+#include "gst/gst.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Interface to inform about pads being added and/or removed from the decoder
+class nsGStreamerDecodeBinPadInterface
+{
+  public:
+    virtual void DecodeBinNewPadAdded(void *aDecodebin2,
+                                      GstPad *aPad,
+                                      gboolean aIsLast)=0;
+
+    virtual void DecodeBinUnknownType(void *aDecodebin2,
+                                      GstPad *aPad,
+                                      GstCaps *aCaps)=0;
+
+    virtual void DecodeBinRemovePad(void *aDecodebin2,
+                                    GstPad *aPad)=0;
+
+    virtual void DecodeBinNoMorePads(void *aDecodebin2)=0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerDecoder.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerDecoder.cpp
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#include <new>
+#include "nsGStreamerLink.h"
+#include "nsGStreamerLog.h"
+#include "nsGStreamerDecoder.h"
+
+
+////////////////////////////////////////////////////////////////////////////////
+// nsGStreamerDecoder functions
+
+nsGStreamerDecoder *nsGStreamerDecoder::makeNewInstance()
+{
+
+  NS_GSTREAMER_LOG(("DATE: " __DATE__ " TIME: " __TIME__ "\n"));
+
+  return new nsGStreamerLink();
+}
+
+NS_IMETHODIMP nsGStreamerDecoder::Observe(nsISupports *aSubjet,
+                                      const char *aTopic,
+                                      const PRUnichar *someData)
+{
+#if 0
+  // TODO: This causes a crash on shutdown. Fix.
+  if (strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
+    Shutdown();
+  }
+#endif
+  return NS_OK;
+}
Index: mozilla/content/media/gstreamer/nsGStreamerDecoder.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerDecoder.h
@@ -0,0 +1,93 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerDecoder_h__
+#define nsGStreamerDecoder_h__
+
+#include "nsISupports.h"
+#include "nsMediaDecoder.h"
+
+class nsGStreamerDecoder : public nsMediaDecoder
+{
+  // ISupports
+  NS_DECL_ISUPPORTS
+
+  // nsIObserver
+  NS_DECL_NSIOBSERVER
+
+  // Private constructor to prevent the object from being instantiated
+  // as if it being virtual wasn't enough :)
+  nsGStreamerDecoder(){};
+public:
+  virtual ~nsGStreamerDecoder(){};
+
+  // Function to create "new" an instance
+  // It's done in this way to allow GStreamer data types in the "real" class
+  static nsGStreamerDecoder *makeNewInstance();
+
+  // Create a new decoder of the same type as this one.
+  virtual nsMediaDecoder* Clone() {return makeNewInstance();};
+
+  // Forwarder function to enable access to a protected member of the base class
+  void SetRGBData(PRInt32 aWidth,
+                  PRInt32 aHeight,
+                  float aFramerate,
+                  float aAspectRatio,
+                  unsigned char* aRGBBuffer)
+                  {
+#if 0
+                  // TODO: Remove this code
+                    static char c = 0;
+                    for(int i=0;i<aWidth*aHeight&&aRGBBuffer;i++) aRGBBuffer[i]=c;
+                    c = c ^ 0xFF;
+                  // TODO: End of code that should be removed
+#endif
+                    nsMediaDecoder::SetRGBData(
+                                                                aWidth,
+                                                                aHeight,
+                                                                aFramerate,
+                                                                aAspectRatio,
+                                                                aRGBBuffer);
+                  };
+
+  // Dummy function to forward invalidate calls
+  // the return type doesn't mean anything, but the
+  // template function used for the call needs it
+  virtual PRBool ForwardInvalidate() = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerElementWrapper.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerElementWrapper.cpp
@@ -0,0 +1,215 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsGStreamerElementWrapper.h"
+
+NS_IMPL_THREADSAFE_ISUPPORTS0(nsGStreamerElementWrapper)
+
+nsGStreamerElementWrapper::nsGStreamerElementWrapper()
+  : mElement(nsnull)
+{
+}
+
+void nsGStreamerElementWrapper::Configure(nsHTMLMediaElement* aElement)
+{
+  mElement = aElement;
+}
+
+void nsGStreamerElementWrapper::MetadataLoaded()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper,
+                           this,
+                           CallMetadataLoaded);
+
+    NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallMetadataLoaded()
+{
+  // Do the real call
+  if (mElement) {
+    mElement->MetadataLoaded();
+  }
+}
+
+void nsGStreamerElementWrapper::FirstFrameLoaded(PRBool aResourceFullyLoaded)
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper,
+                           this,
+                           CallFirstFrameLoaded);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallFirstFrameLoaded()
+{
+  // Do the real call
+  if (mElement) {
+    mElement->FirstFrameLoaded(PR_FALSE);
+  }
+}
+
+void nsGStreamerElementWrapper::ResourceLoaded()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper, this, CallResourceLoaded);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallResourceLoaded()
+{
+  if (mElement) {
+    // Do the real call
+    mElement->ResourceLoaded();
+    // TODO: Call stop progress from here, or from the place this is called
+
+// TODO: Call start when we start to read data from the stream
+// TODO: Call stop when we stop reading data for the streame (ex. when seeking)
+//  StopProgress();
+  }
+}
+
+void nsGStreamerElementWrapper::NetworkError()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper, this, CallNetworkError);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallNetworkError()
+{
+  if (mElement) {
+    // Do the real call
+    mElement->NetworkError();
+  }
+}
+
+void nsGStreamerElementWrapper::PlaybackEnded()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper, this, CallPlaybackEnded);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallPlaybackEnded()
+{
+  // Do the real call
+  if (mElement) {
+    mElement->PlaybackEnded();
+  }
+}
+
+void nsGStreamerElementWrapper::SeekStarted()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper, this, CallSeekStarted);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallSeekStarted()
+{
+  // Do the real call
+  if (mElement) {
+    mElement->SeekStarted();
+  }
+}
+
+void nsGStreamerElementWrapper::SeekCompleted()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper, this, CallSeekCompleted);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallSeekCompleted()
+{
+  // Do the real call
+  if (mElement) {
+    mElement->SeekCompleted();
+  }
+}
+
+void nsGStreamerElementWrapper::NotifyAutoplayDataReady()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper,
+                           this,
+                           CallNotifyAutoplayDataReady);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+void nsGStreamerElementWrapper::CallNotifyAutoplayDataReady()
+{
+  // Do the real call
+  if (mElement) {
+    mElement->NotifyAutoplayDataReady();
+  }
+}
+
+// Function that should be called when the current position has changed
+void nsGStreamerElementWrapper::DispatchTimeUpdated()
+{
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerElementWrapper,
+                           this,
+                           CallDispatchTimeUpdated);
+
+  NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+}
+
+// Function doing the call
+void nsGStreamerElementWrapper::CallDispatchTimeUpdated()
+{
+  // TODO: Check with nsOggDecoder::PlaybackPositionChanged
+  // that this is the right thing to do
+//  NS_GSTREAMER_LOG(("+"));
+  if (mElement) {
+// TODO: Use DispatchAsyncSimpleEvent, and don't do it from the main thread
+    mElement->DispatchSimpleEvent(NS_LITERAL_STRING("timeupdate"));
+  }
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerElementWrapper.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerElementWrapper.h
@@ -0,0 +1,172 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsGStreamerElementWrapper_H__
+#define nsGStreamerElementWrapper_H__
+
+#include "nsHTMLMediaElement.h"
+#include "nsISupportsBase.h"
+#include "nsISupportsImpl.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that takes care of communication with the media element
+class nsGStreamerElementWrapper : nsISupports
+{
+  public:
+    NS_DECL_ISUPPORTS
+
+    // Constructor
+    nsGStreamerElementWrapper();
+
+    // Virtual destructor
+    virtual ~nsGStreamerElementWrapper() {};
+
+    // Configure the wrapper with a pointer to the element
+    // that should be comunicated with
+    void Configure(nsHTMLMediaElement* aElement);
+
+    // Called by the video decoder object, on the main thread,
+    // when it has read the metadata containing video dimensions,
+    // etc.
+    void MetadataLoaded();
+
+  private:
+    // Function doing the call
+    void CallMetadataLoaded();
+
+  public:
+    // Called by the video decoder object, on the main thread,
+    // when it has read the first frame of the video
+    // aResourceFullyLoaded should be true if the resource has been
+    // fully loaded and the caller will call ResourceLoaded next.
+    void FirstFrameLoaded(PRBool aResourceFullyLoaded);
+
+  private:
+    // Function doing the call
+    void CallFirstFrameLoaded();
+
+  public:
+    // Called by the video decoder object, on the main thread,
+    // when the resource has completed downloading.
+    void ResourceLoaded();
+
+  private:
+    // Function doing the call
+    void CallResourceLoaded();
+
+  public:
+    // Called by the video decoder object, on the main thread,
+    // when the resource has a network error during loading.
+    void NetworkError();
+
+  private:
+    // Function doing the call
+    void CallNetworkError();
+
+  public:
+    // Called by the video decoder object, on the main thread,
+    // when the video playback has ended.
+    void PlaybackEnded();
+
+  private:
+    // Function doing the call
+    void CallPlaybackEnded();
+
+  public:
+    // Called by the video decoder object, on the main thread,
+    // when the resource has started seeking.
+    void SeekStarted();
+
+  private:
+    // Function doing the call
+    void CallSeekStarted();
+
+  public:
+    // Called by the video decoder object, on the main thread,
+    // when the resource has completed seeking.
+    void SeekCompleted();
+
+  private:
+    // Function doing the call
+    void CallSeekCompleted();
+
+  public:
+    // Notify that enough data has arrived to start autoplaying.
+    // If the element is 'autoplay' and is ready to play back (not paused,
+    // autoplay pref enabled, etc), it should start playing back.
+    void NotifyAutoplayDataReady();
+
+  private:
+    // Function doing the call
+    void CallNotifyAutoplayDataReady();
+
+  public:
+    // Function that should be called when the current position has changed
+    void DispatchTimeUpdated();
+
+  private:
+    // Function doing the call
+    void CallDispatchTimeUpdated();
+
+#if 0  // Not called by the video decoder
+    // Called by the media stream, on the main thread, when the download
+    // has been suspended by the cache or because the element itself
+    // asked the decoder to suspend the download.
+    void DownloadSuspended();
+
+    // Called by the media stream, on the main thread, when the download
+    // has been resumed by the cache or because the element itself
+    // asked the decoder to resumed the download.
+    void DownloadResumed();
+
+    // Called by the media decoder to indicate that the download has stalled
+    // (no data has arrived for a while).
+    void DownloadStalled();
+
+    // Draw the latest video data. See nsMediaDecoder for
+    // details.
+    void Paint(gfxContext* aContext,
+               gfxPattern::GraphicsFilter aFilter,
+               const gfxRect& aRect);
+#endif
+  private:
+    nsHTMLMediaElement* mElement;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerInputBin.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerInputBin.cpp
@@ -0,0 +1,268 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#include "nsGStreamerInputBin.h"
+#include "nsGStreamerLog.h"
+
+nsGStreamerInputBin::nsGStreamerInputBin()
+  : mInputBin(nsnull),
+    mStreamSrc(nsnull),
+    mInputBuffer(nsnull),
+    mElementWrapper(nsnull)
+{
+}
+
+nsGStreamerInputBin::~nsGStreamerInputBin()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerInputBin"));
+  // Ensure we have released all our resources
+  Destroy();
+}
+
+PRBool nsGStreamerInputBin::Create(nsMediaStream *aMediaStream,
+    nsGStreamerInputBufferStatusInterface* aBufStatusInterface)
+{
+  // Make sure we don't have something laying around we shouldn't
+  Destroy();
+
+  // We assume failure
+  PRBool isSuccess = PR_FALSE;
+
+  // Save the status interface pointer
+  mBufStatusInterface = aBufStatusInterface;
+
+  mInputBin = GST_BIN_CAST(gst_bin_new("mInputBin"));
+
+  // Create source element
+  mStreamSrc = gst_element_factory_make("nsGStreamSource", "mpStreamerSource");
+
+  // Create a queue for the data read from input stream
+  mInputBuffer = gst_element_factory_make("queue", "streamQueue");
+
+  gst_object_sink(gst_object_ref(GST_OBJECT(mInputBin)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mStreamSrc)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mInputBuffer)));
+
+  // Note: the below if-statement is not inline with the Mozilla coding-standard
+  // but it is also an exceptional if statement, I haven't been able to find
+  // another layout that as clearly supports the meaning of what is done
+  if (// Check that we got all of our components
+         mInputBin
+      && mStreamSrc
+      && mStreamSrc
+      // Add the elements to the audio bin
+      && gst_bin_add(mInputBin, mStreamSrc)
+      && gst_bin_add(mInputBin, mInputBuffer)
+      // Link the elements
+      && gst_element_link_pads(mStreamSrc, "src", mInputBuffer, "sink"))
+  {
+    NS_GSTREAMER_LOG(("<<Configuring input bin>>\n"));
+
+    // If all went well this far then we can
+    // create a ghost pad and add it to the bin
+    GstPad *pad = gst_element_get_static_pad(mInputBuffer, "src");
+//    GstPad *pad = gst_element_get_static_pad(mStreamSrc, "src");
+
+    isSuccess = gst_element_add_pad(GST_ELEMENT_CAST(mInputBin),
+                                       gst_ghost_pad_new("src", pad));
+    gst_object_unref(GST_OBJECT(pad));
+
+    // Configure our elements
+#if 0
+    const guint max_buffer_buffers = 0;
+    const guint max_buffer_size_in_bytes = 1024*1024;  // 512*1024
+    const guint64 max_buffer_time_in_ns  = 0;
+    const guint min_threshold_in_bytes = 64*1024;      // 512*1024
+    const guint64 min_threshold_in_ns = 0;
+    const guint min_threshold_buffers = 0;
+#else
+    const guint max_buffer_buffers = 0;
+    const guint max_buffer_size_in_bytes = 16*1024;   // 512*1024
+    const guint64 max_buffer_time_in_ns  = 0;
+    const guint min_threshold_in_bytes = 0;           // 512*1024
+    const guint64 min_threshold_in_ns = 0;
+    const guint min_threshold_buffers = 0;
+#endif
+
+
+    g_object_set(// Object we are setting a property on
+                 G_OBJECT(mInputBuffer),
+                 // Max no of buffers
+                 "max-size-buffers",
+                 max_buffer_buffers,
+                 // Max buffer size
+                 "max-size-bytes",
+                 max_buffer_size_in_bytes,
+                 // Max time in nanoseconds (1 sec = 1,000,000,000 ns)
+                 "max-size-time",
+                 max_buffer_time_in_ns,
+                 // Min number of bytes before data
+                 // is sent from buffer
+                 "min-threshold-bytes",
+                 min_threshold_in_bytes,
+                 // Min time before data is sent from buffer in ns
+                 "min-threshold-time",
+                 min_threshold_in_ns,
+                 //Min number of buffers to hold
+                 "min-threshold-buffers",
+                 min_threshold_buffers,
+                 //Indicate this was the last property
+                 NULL);
+
+    g_signal_connect(mInputBuffer,
+                     "overrun",
+                     G_CALLBACK(InputBufferOverrun),
+                     this);
+    g_signal_connect(mInputBuffer,
+                     "running",
+                     G_CALLBACK(InputBufferRunning),
+                     this);
+    g_signal_connect(mInputBuffer,
+                     "underrun",
+                     G_CALLBACK(InputBufferUnderrun),
+                     this);
+    g_signal_connect(mInputBuffer,
+                     "pushing",
+                     G_CALLBACK(InputBufferPushing),
+                     this);
+
+    // Make the channel pointer into a GValue
+    gpointer gvMediaStream = aMediaStream;
+    gpointer gvStatusInterface = (nsGStreamerStreamStatusInterface *)this;
+
+    // Set the Media Stream and the status interface for the stream
+    g_object_set(// Object we are setting a property on
+                 G_OBJECT(mStreamSrc),
+                 // Name of the property
+                 "MediaStream",
+                 //The value to store in the property
+                 gvMediaStream,
+                 // Name of the property
+                 "StatusProperty",
+                 //The value to store in the property
+                 gvStatusInterface,
+                 //Indicate this was the last property
+                 NULL);
+
+    NS_GSTREAMER_LOG(("<<Configuring input bin done>>\n"));
+  } else {
+    // TODO: Error handling
+  }
+
+
+  return isSuccess;
+}
+
+void nsGStreamerInputBin::Destroy()
+{
+  if(mStreamSrc) {
+    // Make sure there are no more callbacks on the status property interface
+    g_object_set(// Object we are setting a property on
+                 G_OBJECT(mStreamSrc),
+                 // Name of the property
+                 "StatusProperty",
+                 //The value to store in the property
+                 NULL,
+                 //Indicate this was the last property
+                 NULL);
+  }
+
+  // Unref what we have gotten
+  if (mInputBin) {
+    gst_object_unref(GST_OBJECT(mInputBin));
+  }
+  if (mStreamSrc) {
+    gst_object_unref(GST_OBJECT(mStreamSrc));
+  }
+  if (mInputBuffer) {
+    gst_object_unref(GST_OBJECT(mInputBuffer));
+  }
+  // Set all our pointers to nsnull
+  mInputBin = nsnull;
+  mStreamSrc = mInputBuffer = nsnull;
+}
+
+
+nsGStreamerInputBin::operator GstElement*()
+{
+  return GST_ELEMENT_CAST(mInputBin);
+}
+
+void nsGStreamerInputBin::SetElementWrapper(
+                                    nsGStreamerElementWrapper *aElementWrapper)
+{
+  mElementWrapper = aElementWrapper;
+}
+
+void nsGStreamerInputBin::EOFReached()
+{
+  if (mElementWrapper) {
+    mElementWrapper->ResourceLoaded();
+  }
+}
+
+void nsGStreamerInputBin::InputBufferOverrun(void *,
+                                             nsGStreamerInputBin * /*aMe*/)
+{
+//  NS_GSTREAMER_LOG(("-BO-"));
+}
+
+void nsGStreamerInputBin::InputBufferRunning(void *,
+                                             nsGStreamerInputBin * aMe)
+{
+//  NS_GSTREAMER_LOG(("-BR-"));
+  if (aMe->mBufStatusInterface) {
+    aMe->mBufStatusInterface->BufferHasEnoughData(PR_TRUE);
+  }
+}
+
+void nsGStreamerInputBin::InputBufferUnderrun(void *,
+                                              nsGStreamerInputBin * aMe)
+{
+//  NS_GSTREAMER_LOG(("-BU-"));
+  if (aMe->mBufStatusInterface) {
+    aMe->mBufStatusInterface->BufferHasEnoughData(PR_FALSE);
+  }
+}
+
+void nsGStreamerInputBin::InputBufferPushing(void *,
+                                             nsGStreamerInputBin * /*aMe*/)
+{
+//  NS_GSTREAMER_LOG(("-BP-"));
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerInputBin.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerInputBin.h
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerInputBin_h__
+#define nsGStreamerInputBin_h__
+
+#include "gst/gst.h"
+#include "nsGStreamerElementWrapper.h"
+#include "nsGStreamerStreamStatusInterface.h"
+#include "nsGStreamerInputBufferStatusInterface.h"
+#include "nsMediaStream.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that takes care of the input buffer
+
+class nsGStreamerInputBin : private nsGStreamerStreamStatusInterface
+{
+  public:
+    // Constructor
+    nsGStreamerInputBin();
+
+    // Destructor
+    ~nsGStreamerInputBin();
+
+    // Function to create an inputbuffer
+    // aChannel [in]: channel for incoming data
+    // aStreamListener [out]: pointer to IStreamListener
+    PRBool Create(nsMediaStream *aMediaStream,
+                  nsGStreamerInputBufferStatusInterface* aBufStatusInterface);
+
+    // Releases all resources allocated
+    void Destroy();
+
+    // Easy way to get the element pointer
+    operator GstElement *();
+
+    void SetElementWrapper(nsGStreamerElementWrapper *aElementWrapper);
+
+  private:
+    // Collector bin for the input src
+    GstBin *mInputBin;
+
+    // Source of data
+    GstElement *mStreamSrc;
+
+    // Input buffer
+    GstElement *mInputBuffer;
+
+    nsGStreamerInputBufferStatusInterface* mBufStatusInterface;
+
+    //Takes care of element com.
+    nsRefPtr<nsGStreamerElementWrapper> mElementWrapper;
+
+    // Called to inform that EOF has been reached
+    virtual void EOFReached();
+
+    // Callbacks
+
+    // Called when the buffer (queue) overflows and stop to accept more data
+    static void InputBufferOverrun(void * aQueue, nsGStreamerInputBin *aMe);
+
+    // Called when the buffer (queue) is running, fetching data
+    static void InputBufferRunning(void * aQueue, nsGStreamerInputBin *aMe);
+
+    // Called when the buffer (queue) runs dry of data
+    static void InputBufferUnderrun(void *aQueue, nsGStreamerInputBin *aMe);
+
+    // Called when the buffer (queue) starts to push data in the pipeline
+    static void InputBufferPushing(void * aQueue, nsGStreamerInputBin *aMe);
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerInputBufferStatusInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerInputBufferStatusInterface.h
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerInputBufferStatusInterface_h__
+#define nsGStreamerInputBufferStatusInterface_h__
+
+#include "prtypes.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Interface class for the input buffer
+class nsGStreamerInputBufferStatusInterface
+{
+  public:
+    // Called to inform state machine of buffer status
+    // arg = PR_TRUE: Enough Data has been buffered to start playback
+    // arg = PR_FALSE: Buffer is empty or don't have
+    //                 enough data to continue playback
+    virtual void BufferHasEnoughData(PRBool aIsEnough) = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerLib.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerLib.cpp
@@ -0,0 +1,243 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "gst/gst.h"
+#include "nsGStreamerLib.h"
+#include "nsGStreamerLog.h"
+#include "nsGstStreamSrc.h"
+#include "nsGstVideoSink.h"
+#include "prlog.h"
+
+ // Static members
+GStaticMutex nsGStreamerLib::mGStreamerMutex = G_STATIC_MUTEX_INIT;
+nsGStreamerLib::GStreamerStatusEnum nsGStreamerLib::mGStreamerLibStatus =
+     nsGStreamerLib::GSTREAM_NOT_RUNNING;
+PRUint32 nsGStreamerLib::mNumberOfInstances = 0;
+nsGStreamerLib::Terminator nsGStreamerLib::terminator;
+
+nsGStreamerLib::nsGStreamerLib()
+{
+  // Take mutex lock
+  g_static_mutex_lock(&mGStreamerMutex);
+
+  // Increase count
+  mNumberOfInstances++;
+
+  // If GStreamer is not running, bring it up
+  if (GSTREAM_NOT_RUNNING == mGStreamerLibStatus) {
+    GError *gstreamerErrorText;
+    // See if we can initialize the lib
+    if (gst_init_check(0, 0, &gstreamerErrorText)) {
+      mGStreamerLibStatus = GSTREAM_GUP_LIB_UP;
+
+      // Check version
+      guint major, minor, micro, nano;
+      gst_version(&major, &minor, &micro, &nano);
+      NS_GSTREAMER_LOG(("GStreamer version: %d %d %d %d",
+                        major,
+                        minor,
+                        micro,
+                        nano));
+
+      if (0 == major && 10 == minor) {
+        mGStreamerLibStatus = GSTREAM_GUP_VERSION_OK;
+
+        //Register plug-in
+#if 0
+         // The register static function is only available
+         // in GStreamer versions >= 0.10.16
+
+         // Initialize our own plug-in for retrieving data
+         if (gst_plugin_register_static(// gint major_version
+                                        0,
+                                        // gint minor_version
+                                        10,
+                                        // const gchar *name
+                                        "nsGStreamSource",
+                                        // gchar *description
+                                        "Necko stream source",
+                                        // GstPluginInitFunc init_func
+                                        nsgst_stream_src_plugin_init,
+                                        // const gchar *version
+                                        "Initial version 0.0",
+                                        // const gchar *license
+                                        "MPL",
+                                        // const gchar *source
+                                        "nsGStreamerDecoder",
+                                        // const gchar *package
+                                        "Mozilla",
+                                        // const gchar *origin
+                                        "http://www.mozilla.com"))
+#else
+        static GstPluginDesc plugin_desc_necko_source = {
+          // major
+          0,
+          // minor
+          10,
+          // name
+          "nsGStreamSource",
+          //description
+          "Necko stream source" ,
+          // init
+          nsgst_stream_src_plugin_init ,
+          // version
+          "Initial version 0.0",
+          // license
+          "MPL",
+          // PACKAGE
+          "Mozilla",
+          // package
+          "Mozilla",
+          // origin
+          "http://www.mozilla.org" ,
+          GST_PADDING_INIT
+        };
+        _gst_plugin_register_static(&plugin_desc_necko_source);
+
+        static GstPluginDesc plugin_desc_video_sink = {
+          // major
+          0,
+          // minor
+          10,
+          // name
+          "gstFennecVideoSink",
+          //description
+          "Fennec vide sink",
+          // init
+          nsgst_fennecvideosink_plugin_init,
+          // version
+          "Initial version 0.0",
+          // license
+          "MPL",
+          // PACKAGE
+          "Mozilla",
+          // package
+          "Mozilla",
+          // origin
+          "http://mediamagictechnologies.com" ,
+          GST_PADDING_INIT
+        };
+        _gst_plugin_register_static(&plugin_desc_video_sink);
+
+
+#endif
+        {
+          mGStreamerLibStatus = GSTREAM_GUP_SRC_PLUGIN_REGISTERED;
+        }
+      }
+    }
+  }
+
+  // Check if lib is up, if not, bring it down
+  if (GSTREAM_READY != mGStreamerLibStatus) {
+    BringGStreamerDown();
+    // Since this is an error condition we remain in the error state
+    mGStreamerLibStatus = GSTREAM_FATAL_FAIL;
+    // Log an error
+    NS_ERROR("GStreamer lib failed to initialise or has the wrong version");
+  }
+
+  // Release lock
+  g_static_mutex_unlock(&mGStreamerMutex);
+}
+
+nsGStreamerLib::~nsGStreamerLib()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerLib\n"));
+  // Take mutex lock
+  g_static_mutex_lock(&mGStreamerMutex);
+
+  // Decrease count
+  mNumberOfInstances--;
+
+  // Release lock
+  g_static_mutex_unlock(&mGStreamerMutex);
+}
+
+PRBool nsGStreamerLib::CheckGStreamerLib()
+{
+  // Take mutex lock
+  g_static_mutex_lock(&mGStreamerMutex);
+
+  PRBool isSuccess = (mGStreamerLibStatus == GSTREAM_READY);
+
+  // Release lock
+  g_static_mutex_unlock(&mGStreamerMutex);
+
+  // Return the state
+  return isSuccess;
+}
+
+void nsGStreamerLib::BringGStreamerDown()
+{
+  switch (mGStreamerLibStatus)
+  {
+    case GSTREAM_GUP_LIB_UP:
+      // Check if we have anyone still expecting GStreamer to be up
+      if (mNumberOfInstances){
+        NS_ERROR("GStreamer lib going down with users connected");
+        NS_GSTREAMER_LOG(("GStreamer lib going down with users connected\n"));
+      }
+      /* falling through */
+    case GSTREAM_GUP_VERSION_OK:
+      /* falling through */
+    case GSTREAM_GUP_SRC_PLUGIN_REGISTERED:
+      // Bring GStreamer down
+      NS_GSTREAMER_LOG(("Bringing GStreamer lib down\n"));
+      gst_deinit();
+      break;
+    default:
+      // We are not doing anything
+      ;
+  }
+  // The gstreamer lib is now down
+  mGStreamerLibStatus = GSTREAM_GDOWN_LIB_DOWN;
+
+}
+
+nsGStreamerLib::Terminator::~Terminator()
+{
+  // Take mutex lock
+  g_static_mutex_lock(&mGStreamerMutex);
+  // Terminate
+  BringGStreamerDown();
+  // Release lock
+  g_static_mutex_unlock(&mGStreamerMutex);
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerLib.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerLib.h
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsGStreamerLib_h__
+#define nsGStreamerLib_h__
+
+#include "prtypes.h"
+#include "glib.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that handels the GStreamer library,
+// registration of plugins etc. MT safe
+class nsGStreamerLib
+{
+  public:
+    // Constructor
+    nsGStreamerLib();
+
+    // Destructor
+    ~nsGStreamerLib();
+
+    // Check if GStreamer lib is up and running
+    // (returns PR_TRUE, PR_FALSE otherwise)
+    PRBool CheckGStreamerLib();
+
+  private:
+    // Mutex to protect the static variables
+    static GStaticMutex mGStreamerMutex;
+
+    // Enum to contain the state
+    static  enum GStreamerStatusEnum {
+      // The library is down
+      GSTREAM_NOT_RUNNING,
+      // We had a fatal failure, don't retry init
+      GSTREAM_FATAL_FAIL,
+      //Going up, GStreamer library initialized
+      GSTREAM_GUP_LIB_UP,
+      // Going up, GStreamer version OK
+      GSTREAM_GUP_VERSION_OK,
+      // Our source stream plugin is registered
+      GSTREAM_GUP_SRC_PLUGIN_REGISTERED,
+      // We are ready when our plug-in is registered
+      GSTREAM_READY = GSTREAM_GUP_SRC_PLUGIN_REGISTERED,
+      // When the lib is down, it can't come alive again
+      GSTREAM_GDOWN_LIB_DOWN
+    } mGStreamerLibStatus;
+
+    // Counter for how many instances we have
+    static PRUint32 mNumberOfInstances;
+
+    // Clean up the GStreamer library
+    static void BringGStreamerDown();
+
+    // The last thing we should do, befor termination of the program
+    // is to terminate the GStreamer library
+    class Terminator
+    {
+      public:
+        ~Terminator();
+    };
+
+    static Terminator terminator;
+};
+
+
+
+#endif
+
Index: mozilla/content/media/gstreamer/nsGStreamerLink.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerLink.cpp
@@ -0,0 +1,529 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsGStreamerLink.h"
+#include "nsGStreamerLog.h"
+#include "nsNetUtil.h"
+
+NS_IMPL_THREADSAFE_ISUPPORTS1(nsGStreamerDecoder, nsIObserver)
+
+nsGStreamerLink::nsGStreamerLink()
+  : mIsShutdownObserverRegistered(PR_FALSE),
+    mIsBaseClassInitialised(PR_FALSE),
+    mSuspendCount(0),
+    mElementWrapper(nsnull)
+{
+  // Create the pipeline object
+  mPipeline = new nsGStreamerPipeline();
+  // Broadcast who we are
+  if (mPipeline) {
+    SetStreamerDecoder();
+  }
+  // Don't worry about sending an error here if we didn't get the pipeline
+  // object we will signal the error as soon as Init is called
+}
+
+nsGStreamerLink::~nsGStreamerLink()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerLink\n"));
+  // Ensure shutdown has been called to release everything
+  Shutdown();
+}
+
+PRBool nsGStreamerLink::Init(nsHTMLMediaElement* aElement)
+{
+  NS_GSTREAMER_LOG(("\n!!!!!!!!! nsGStreamerLink::Init !!!!!!!!!!!!\n"));
+  PRBool isSuccess = PR_FALSE;  // Assume failure
+  // Check if the GStreamer lib is OK and we got a pipeline object
+  if (mGStreamerLib.CheckGStreamerLib() && mPipeline) {
+    // Try to allocate an element wrapper
+
+    SetElementWrapper(new nsGStreamerElementWrapper);
+    // Check if got the element wrapper
+    if (GetElementWrapper()) {
+      // Save the element pointer
+      GetElementWrapper()->Configure(aElement);
+
+      // Register for shutdown events
+      nsCOMPtr<nsIObserverService> observerService =
+        do_GetService("@mozilla.org/observer-service;1");
+      if (observerService) {
+        observerService->AddObserver(this,
+                                     NS_XPCOM_SHUTDOWN_OBSERVER_ID,
+                                     PR_FALSE);
+        mIsShutdownObserverRegistered = PR_TRUE;
+      } else {
+        NS_WARNING("Could not get an observer service. "
+                   "Video decoding events may not shutdown cleanly.");
+      }
+      // Init base class
+      isSuccess = nsMediaDecoder::Init(aElement);
+      mIsBaseClassInitialised = PR_TRUE;
+    }
+  }
+
+  // If something went wrong, then abandon everything
+  if (!isSuccess) {
+    Shutdown();
+  }
+
+  return isSuccess;
+}
+
+void nsGStreamerLink::Shutdown()
+{
+  NS_GSTREAMER_LOG(("\n!!!!!!!!! nsGStreamerLink::Shutdown !!!!!!!!!!!!\n"));
+
+  // Tell pipeline, this is the end
+  if (mPipeline) {
+    mPipeline->Shutdown();
+  }
+
+  // Close the media stream, it's important this is done after the pipeline
+  // shutdown, as the stream might still be accessed by the pipeline until the
+  // pipeline is shut down
+  if (mStream) {
+    mStream->Close();
+    mStream = nsnull;
+  }
+
+  if (GetElementWrapper()) {
+    // It's no longer safe to communicate with the element
+    GetElementWrapper()->Configure(nsnull);
+    // We no longer have a use for the wrapper (might still be alive after this
+    // thou - due to ref counting
+    SetElementWrapper(nsnull);
+  }
+  // Drop reference to pipeline
+  mPipeline = nsnull;
+
+
+  // If we need to unregister as a shutdown observer
+  if (mIsShutdownObserverRegistered) {
+    // Get the observer service
+    nsCOMPtr<nsIObserverService> observerService =
+      do_GetService("@mozilla.org/observer-service;1");
+
+    // We might have added an observer, so we better remove it again
+    if (observerService) {
+      observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
+    }
+    // Only shut it down ones
+    mIsShutdownObserverRegistered = PR_FALSE;
+  }
+
+  // If we called init on our base class, we better un-init it
+  if (mIsBaseClassInitialised) {
+    // Shut down base class
+    nsMediaDecoder::Shutdown();
+    // Only shut it down ones
+    mIsBaseClassInitialised = PR_FALSE;
+  }
+
+  if (mURI) {
+    mURI = nsnull;
+  }
+}
+
+void nsGStreamerLink::GetCurrentURI(nsIURI** aURI)
+{
+  NS_IF_ADDREF(*aURI = mURI);
+}
+
+// Get the current nsMediaStream being used. Its URI will be returned
+// by currentSrc.
+nsMediaStream* nsGStreamerLink::GetCurrentStream()
+{
+  return mStream;
+}
+
+nsresult nsGStreamerLink::Load(nsMediaStream* aStream,
+                      nsIStreamListener **aListener)
+{
+  nsresult rv = NS_ERROR_UNEXPECTED;
+  mStream = aStream;
+
+  // Create the decode pipeline (and implicit start it loading data)
+  // NOTE: It is known that the below if statement does not fit Mozilla coding
+  // standards, this is intentional - as following it would decrease readability
+  if (   mStream
+      && NS_SUCCEEDED(mStream->Open(aListener))
+      && mPipeline->Create(mStream))
+  {
+    StartProgress();
+    rv = NS_OK;
+  } else {
+    *aListener = nsnull;
+  }
+
+  return rv;
+}
+
+float nsGStreamerLink::GetCurrentTime()
+{
+  return mPipeline ? mPipeline->GetCurrentTime() : 0.0;
+}
+
+nsresult nsGStreamerLink::Seek(float time)
+{
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::Seek(%f)\n", time));
+  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO: Add code
+}
+
+nsresult nsGStreamerLink::PlaybackRateChanged()
+{
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::PlaybackRateChanged\n"));
+
+  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO: Add code to change speed of play (like Fast forward)
+}
+
+float nsGStreamerLink::GetDuration()
+{
+  return mPipeline->GetDuration();
+}
+
+void nsGStreamerLink::Pause()
+{
+  NS_GSTREAMER_LOG(("+++Asked to pause\n"));
+  // Check if we have a pipeline
+  if (mPipeline) {
+    // Ask pipeline to pause
+    mPipeline->GetPlayPauseInterface()->PlayWhenPossible(PR_FALSE);
+  }
+}
+
+void nsGStreamerLink::SetVolume(float aNewVolume)
+{
+  if (mPipeline) {
+    mPipeline->GetAudioPropertyInterface()->SetVolume(aNewVolume);
+  }
+}
+
+nsresult nsGStreamerLink::Play()
+{
+  // Assume failure
+  nsresult rv = NS_ERROR_FAILURE;
+
+  NS_GSTREAMER_LOG(("+++Asked to play\n"));
+  // Check if we have a pipeline
+  if (mPipeline) {
+    // Ask pipeline to play
+    mPipeline->GetPlayPauseInterface()->PlayWhenPossible(PR_TRUE);
+    rv = NS_OK;
+  }
+
+  return rv;
+}
+
+void nsGStreamerLink::ResourceLoaded()
+{
+  // Intentionally left blank
+}
+
+void nsGStreamerLink::NetworkError()
+{
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::NetworkError\n"));
+
+  // TODO: Add code to stop download or something like that
+  // TODO: Call mElement->NetworkError()
+}
+
+nsGStreamerDecoder::Statistics nsGStreamerLink::GetStatistics()
+{
+  // TODO: We can do better than this and give more information
+  GstFormat fmt = GST_FORMAT_BYTES;
+
+  Statistics retStruct;
+
+  memset(&retStruct, 0, sizeof(Statistics));
+
+  if (mStream) {
+    // Ask the stream if it knows the length of the stream
+    retStruct.mTotalBytes = mStream->GetLength();
+
+    // Check if it did, or ask the pipeline if it didn't
+    if (-1 != retStruct.mTotalBytes &&
+        !gst_element_query_duration(*mPipeline, &fmt, &retStruct.mTotalBytes))
+    {
+      // Total length of media stream in bytes; -1 if not known
+      retStruct.mTotalBytes = -1;
+    }
+
+    // Current position of the download, in bytes. This position (and
+    // the other positions) should only increase unless the current
+    // playback position is explicitly changed. This may require
+    // some fudging by the decoder if operations like seeking or finding the
+    // duration require seeks in the underlying stream.
+    fmt = GST_FORMAT_BYTES;
+    gst_element_query_position(*mPipeline, &fmt, &retStruct.mDownloadPosition);
+
+    // Current position of decoding, in bytes (how much of the stream
+    // has been consumed)
+    fmt = GST_FORMAT_BYTES;
+    gst_element_query_position(*mPipeline, &fmt, &retStruct.mDecoderPosition);
+
+    // Current position of playback, in bytes
+    fmt = GST_FORMAT_BYTES;
+    gst_element_query_position(*mPipeline, &fmt, &retStruct.mPlaybackPosition);
+
+
+    retStruct.mDownloadRate =
+      mStream->GetDownloadRate(&retStruct.mDownloadRateReliable);
+
+    // If false, then mPlaybackRate cannot be considered a reliable
+    // estimate (probably because playback has only been running
+    // a short time).
+    retStruct.mPlaybackRateReliable = PR_FALSE;
+
+    // TODO: MIKEK fill out the elements with the correct values
+    // Estimate of the current playback rate (bytes/second).
+    retStruct.mPlaybackRate = 200.0;
+
+    // Estimate of the current download rate (bytes/second)
+  //  retStruct.mDownloadRate = 224.0;
+  }
+
+  return retStruct;
+}
+
+already_AddRefed<nsIPrincipal> nsGStreamerLink::GetCurrentPrincipal()
+{
+  // TODO: call get current principal on the stream (something about security)
+
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::GetCurrentPrincipal\n"));
+
+  // TODO: What is a principal? - can we support it?
+  NS_ASSERTION(PR_FALSE,
+               "GStreamer backend does not support GetCurrentPrincipal");
+  return nsnull;
+}
+
+void nsGStreamerLink::SetDuration(PRInt64 aDuration)
+{
+  // Should be cached and forwarded to the element on request, if gstreamer don't have a better value
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::SetDuration(%i)\n", (int)aDuration));
+
+  // TODO: Add code
+}
+
+void nsGStreamerLink::SetSeekable(PRBool aSeekable)
+{
+  // If this one is set to true, you can seek in the underlying media stream
+
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::SetSeekable (%i)\n", aSeekable));
+
+  // TODO: Add code
+}
+
+PRBool nsGStreamerLink::GetSeekable()
+{
+  // IF GStreamer thinks it ok, and set seekable was true you can seek
+
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::GetSeekable\n"));
+
+  // TODO: Add real code
+  return PR_FALSE;
+}
+
+void nsGStreamerLink::NotifyDownloadEnded(nsresult aStatus)
+{
+  // if status is not ok - then call network error
+  // otherwise call resourceloaded
+
+
+  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::NotifyDownloadEnded\n"));
+
+  // TODO: Add code
+
+  // TODO: Remove below debug code
+//  NS_GSTREAMER_LOG(("\nPipeline as when data has downloaded:\n"));
+//  DumpGStreamerElement(*mPipeline);
+}
+
+void nsGStreamerLink::NotifySuspendedStatusChanged()
+{
+  // Do as it says nsMediaDecoder.h
+
+  NS_GSTREAMER_LOG((
+              "Unimplemented nsGStreamerLink::NotifySuspendedStatusChanged\n"));
+
+  // TODO: Add code
+}
+
+void nsGStreamerLink::NotifyBytesDownloaded()
+{
+  // We don't need to care about this one, as we are actively waiting
+  // for data whenever we are not processing the data we already got
+}
+
+void nsGStreamerLink::Suspend()
+{
+  NS_GSTREAMER_LOG(("+++Asked to suspend\n"));
+
+//  DumpGStreamerElement(*mPipeline);
+
+  // Check if we have a pipeline
+  if(mPipeline && !mSuspendCount) {
+    // Ask pipeline to suspend
+    mPipeline->GetSuspendResumeInterface()->Suspend();
+  }
+
+//  if(mStream && !mSuspendCount) {
+    NS_GSTREAMER_LOG(("stream->Suspend()\n"));
+    mStream->Suspend(PR_TRUE);
+//  }
+
+  // We have one more call to suspend
+  mSuspendCount++;
+
+  // Check that we are using enough bits to store the counter
+  if(0 >= mSuspendCount) {
+    NS_WARNING("mSuspendCount rolled over, increase its width");
+  }
+
+}
+
+void nsGStreamerLink::Resume()
+{
+  NS_GSTREAMER_LOG(("+++Asked to resume\n"));
+
+  // Do sanity check of counter
+  if(!mSuspendCount) {
+    // If the counter is 0, we don't want it to roll over
+    mSuspendCount = 1;
+    NS_WARNING("Resume called more times than suspend on GStreamer, "
+               "counter has been set to 0");
+  }
+
+  // We have one less call to suspend
+  mSuspendCount--;
+
+  // Check if we have a pipeline
+  if(mPipeline && !mSuspendCount) {
+    // Ask pipeline to resume
+    mPipeline->GetSuspendResumeInterface()->Resume();
+  }
+
+//  if(mStream && !mSuspendCount) {
+    NS_GSTREAMER_LOG(("stream->Resume()\n"));
+    mStream->Resume();
+//  }
+}
+
+void nsGStreamerLink::MoveLoadsToBackground()
+{
+  if (mStream) {
+    mStream->MoveLoadsToBackground();
+  }
+}
+
+PRBool nsGStreamerLink::IsSeeking() const
+{
+  // Only when actually seeking
+
+  // TODO: Really add some code here
+  // TODO: Uncommented as it is being called a zillion times
+//  NS_GSTREAMER_LOG(("Unimplemented nsGStreamerLink::IsSeeking\n"));
+
+// Remove below code
+  if(mPipeline) {
+    // This is an aproximation of an aproximation, to get a real result, we
+    // could check the state of the decodebin (if we want to keep the assumption
+    // that if we aren't playing then we are seeking - this is not true
+    // if we are paused or have come to the end of the video (or maybe if we
+    // are buffering - I'm not aware if IsSeeking should return true or false
+    // during the buffering).
+    return !mPipeline->GetPlayPauseInterface()->IsPlaying();
+  }
+
+  // TODO: Add real code, so TRUE is returned when we are actually seeking
+  return PR_FALSE;
+}
+
+PRBool nsGStreamerLink::IsEnded() const
+{
+  // We assume we havn't reached an end if aren't set up yet
+  PRBool isSuccess = PR_FALSE;
+  if (mPipeline) {
+    // Check if we have reached the end
+    isSuccess = mPipeline->GetPlayPauseInterface()->IsAtEOF();
+  }
+
+  return isSuccess;
+}
+
+void nsGStreamerLink::SetElementWrapper(
+    nsGStreamerElementWrapper *aElementWrapper)
+{
+  mElementWrapper = aElementWrapper;
+  mPipeline->SetElementWrapper(aElementWrapper);
+}
+
+void nsGStreamerLink::SetStreamerDecoder()
+{
+  mPipeline->SetStreamerDecoder(this);
+}
+
+PRBool nsGStreamerLink::ForwardInvalidate()
+{
+  NS_GSTREAMER_LOG(("[>]"));
+  Invalidate();
+
+  // TODO: Search in ogg decoder for dispatch event, and look at: http://www.w3.org/TR/html5/video.html#mediaevents when to fire them
+  if (mElement) {
+      mElement->DispatchSimpleEvent(NS_LITERAL_STRING("timeupdate"));
+    }
+
+  // We need to check for the values of the pointers, as this function is called
+  // async, and we might be in the process of shutting down
+  if (mPipeline) {
+    mPipeline->GetScreenInvalidatedInterface()->ScreenHasBeenInvalidated();
+  }
+//  if (mElement) {
+//    mElement->DispatchSimpleEvent(NS_LITERAL_STRING("timeupdate"));
+//  }
+
+  NS_GSTREAMER_LOG(("[<]"));
+
+  return PR_TRUE;
+}
+
+
Index: mozilla/content/media/gstreamer/nsGStreamerLink.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerLink.h
@@ -0,0 +1,231 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsGStreamerLink_h__
+#define nsGStreamerLink_h__
+
+#include "nsGStreamerDecoder.h"
+#include "nsGStreamerElementWrapper.h"
+#include "nsGStreamerLib.h"
+#include "nsGStreamerPipeline.h"
+#include "nsMediaStream.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that links everything GStreamer related together
+
+class nsGStreamerLink : public nsGStreamerDecoder
+{
+  friend class nsHTMLVideoElement;
+
+  public:
+    nsGStreamerLink();
+
+    virtual ~nsGStreamerLink();
+
+    virtual PRBool Init(nsHTMLMediaElement* aElement);
+
+    virtual void Shutdown();
+
+    // Interface functions from nsMediaDecoder
+    virtual  void GetCurrentURI(nsIURI** aURI);
+
+    // Get the current nsMediaStream being used. Its URI will be returned
+    // by currentSrc.
+    virtual nsMediaStream* GetCurrentStream();
+
+    // Start downloading the media. Decode the downloaded data up to the
+    // point of the first frame of data.
+    // aStream is the media stream to use. Ownership of aStream passes to
+    // the decoder, even if Load returns an error.
+    // This is called at most once per decoder, after Init().
+    virtual nsresult Load(nsMediaStream* aStream,
+                          nsIStreamListener **aListener);
+
+    // Get current position of playback in seconds
+    virtual float GetCurrentTime();
+
+    // Seek to a given position in the stream
+    virtual nsresult Seek(float time);
+
+    // Called by the element when the playback rate has been changed.
+    // Adjust the speed of the playback, optionally with pitch correction,
+    // when this is called.
+    virtual nsresult PlaybackRateChanged();
+
+    // Return the duration of the video in seconds.
+    virtual float GetDuration();
+
+    // Pause video playback.
+    virtual void Pause();
+
+    // Pause video playback.
+    virtual void SetVolume(float aNewVolume);
+
+    // Start playback of a video. 'Load' must have previously been called
+    virtual nsresult Play();
+
+    // Called when the video file has completed downloading.
+    virtual void ResourceLoaded();
+
+    // Called if the media file encounters a network error.
+    virtual void NetworkError();
+
+    // Return statistics. This is used for progress events and other things.
+    // This can be called from any thread. It's only a snapshot of the
+    // current state, since other threads might be changing the state
+    // at any time.
+    virtual Statistics GetStatistics();
+
+    // Return the principal of the current URI being played or downloaded.
+    virtual already_AddRefed<nsIPrincipal> GetCurrentPrincipal();
+
+    // Set the duration of the media resource in units of milliseconds.
+    // This is called via a channel listener if it can pick up the duration
+    // from a content header. Must be called from the main thread only.
+    virtual void SetDuration(PRInt64 aDuration);
+
+    // Set a flag indicating whether seeking is supported
+    virtual void SetSeekable(PRBool aSeekable);
+
+    // Return PR_TRUE if seeking is supported.
+    virtual PRBool GetSeekable();
+
+    // Called by nsChannelToPipeListener or nsMediaStream when the
+    // download has ended. Called on the main thread only. aStatus is
+    // the result from OnStopRequest.
+    virtual void NotifyDownloadEnded(nsresult aStatus);
+
+    // Called by nsMediaStream when the "cache suspended" status changes.
+    // If nsMediaStream::IsSuspendedByCache returns true, then the decoder
+    // should stop buffering or otherwise waiting for download progress and
+    // start consuming data, if possible, because the cache is full.
+    virtual void NotifySuspendedStatusChanged();
+
+    // Called by nsMediaStream when some data has been received.
+    // Call on the main thread only.
+    virtual void NotifyBytesDownloaded();
+
+    // Suspend any media downloads that are in progress. Called by the
+    // media element when it is sent to the bfcache, or when we need
+    // to throttle the download. Call on the main thread only. This can
+    // be called multiple times, there's an internal "suspend count".
+    virtual void Suspend();
+
+    // Resume any media downloads that have been suspended. Called by the
+    // media element when it is restored from the bfcache, or when we need
+    // to stop throttling the download. Call on the main thread only.
+    // The download will only actually resume once as many Resume calls
+    // have been made as Suspend calls.
+    virtual void Resume();
+
+    // Moves any existing channel loads into the background, so that they don't
+    // block the load event. This is called when we stop delaying the load
+    // event. Any new loads initiated (for example to seek) will also be in the
+    // background. Implementations of this must call MoveLoadsToBackground() on
+    // their nsMediaStream.
+    virtual void MoveLoadsToBackground();
+
+    // Call from any thread safely. Return PR_TRUE if we are currently
+    // seeking in the media resource.
+    virtual PRBool IsSeeking() const;
+
+    // Return PR_TRUE if the decoder has reached the end of playback.
+    // Call in the main thread only.
+    virtual PRBool IsEnded() const;
+
+#if 0
+  // Draw the latest video data. This is done
+  // here instead of in nsVideoFrame so that the lock around the
+  // RGB buffer doesn't have to be exposed publicly.
+  // The current video frame is drawn to fill aRect.
+  // Called in the main thread only.
+  virtual void Paint(gfxContext* aContext,
+                     gfxPattern::GraphicsFilter aFilter,
+                     const gfxRect& aRect);
+
+  // Fire progress events if needed according to the time and byte
+  // constraints outlined in the specification. aTimer is PR_TRUE
+  // if the method is called as a result of the progress timer rather
+  // than the result of downloaded data.
+  virtual void Progress(PRBool aTimer);
+
+  // Returns a weak reference to the media element we're decoding for,
+  // if it's available.
+  nsHTMLMediaElement* GetMediaElement();
+
+#endif
+
+    // Broadcast the element wrapper
+    void SetElementWrapper(nsGStreamerElementWrapper *aElementWrapper);
+
+    // Broadcast the streamer deocoder
+    void SetStreamerDecoder();
+
+  private:
+    // Controls the GStreamer library
+    nsGStreamerLib mGStreamerLib;
+
+    // The pipeline that takes care of decoding
+    nsRefPtr<nsGStreamerPipeline> mPipeline;
+
+    // Wrapper class taking care of communication with the media element
+    nsRefPtr<nsGStreamerElementWrapper> mElementWrapper;
+
+    // URI of stream we are handling now
+    nsCOMPtr<nsIURI> mURI;
+
+    // The media stream used for getting data
+    nsAutoPtr<nsMediaStream> mStream;
+
+    // Set to TRUE if we have registered for the shutdown event
+    PRPackedBool mIsShutdownObserverRegistered;
+
+    // Set to TRUE if the base class is successfully initialized
+    PRPackedBool mIsBaseClassInitialised;
+
+    // Contains the number of times the decoder has been requested to suspend
+    PRInt32 mSuspendCount;
+
+    nsGStreamerElementWrapper *GetElementWrapper() {return mElementWrapper;};
+
+    virtual PRBool ForwardInvalidate();
+};
+
+#endif
+
Index: mozilla/content/media/gstreamer/nsGStreamerLog.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerLog.cpp
@@ -0,0 +1,233 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsGStreamerLog.h"
+
+// TODO:  Remove the below static variables, they are for debug only
+int sSetRGBCalled = 0;
+int sDraws = 0;
+
+#ifdef PR_LOGGING
+PRLogModuleInfo *gGStreamerLog = PR_NewLogModule("GStreamer");
+#endif /* PR_LOGGING */
+
+
+
+// Debug function
+void DumpGStreamerElement(GstElement*aEleToDump)
+{
+#if defined(PR_LOGGING) || defined(NS_GSTREAMER_PRINTF_LOGGING)
+  {
+    gint spaces=0;
+    GstElement*element = aEleToDump;
+    GstIterator*binIterator = 0;
+    // If we got a null pointer we just return
+    if (!element) {
+      NS_GSTREAMER_LOG(("Can't dump null\n"));
+      return;
+    }
+  // Macro to make spaces, for pretty output
+#define SPC {gint c;for(c=spaces;c-- >0;)NS_GSTREAMER_LOG(("   "));};
+#define IN spaces++;
+#define OUT spaces--;
+#define FACTORY_ELE_NAME(ELE) \
+  gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(gst_element_get_factory(ELE)))
+#define FACTORY_NAME(ELE) \
+  gst_element_factory_get_longname(gst_element_get_factory(ELE))
+#define FACTORY_KLASS(ELE) \
+  gst_element_factory_get_klass(gst_element_get_factory(ELE))
+#define FACTORY_DESC(ELE) \
+  gst_element_factory_get_description(gst_element_get_factory(ELE))
+#define ELE_INFO(ELE) \
+  NS_GSTREAMER_LOG(("name: %s," \
+         " element: %s," \
+         " longName: %s," \
+         " klass: %s,"\
+         " desc: %s", \
+         FACTORY_ELE_NAME(ELE), \
+         gst_element_get_name(ELE), \
+         FACTORY_NAME(ELE), \
+         FACTORY_KLASS(ELE), \
+         FACTORY_DESC(ELE)))
+
+    // Write name of element
+    NS_GSTREAMER_LOG(("\\/ Dumping "));
+    ELE_INFO(aEleToDump);
+    NS_GSTREAMER_LOG(("\n"));
+    IN
+    // Check if the element is a bin, so we need to do a recursive search
+    if (GST_IS_BIN(element)) {
+      // Create iterator
+      binIterator =  gst_bin_iterate_recurse(GST_BIN_CAST(element));
+    }
+
+    while (element) {
+      GstIterator *iterator = gst_element_iterate_pads(element);
+      SPC
+      NS_GSTREAMER_LOG(("pads on "));
+      ELE_INFO(element);
+      NS_GSTREAMER_LOG(("\n"));
+      IN
+      if (iterator) {
+          GstPad *pad;
+          GstState state;
+          GstState pending;
+
+          gst_element_get_state(element, &state, &pending, 1000000000);
+
+          SPC
+          NS_GSTREAMER_LOG(("Is in state : "));
+          switch(state)
+          {
+            case GST_STATE_VOID_PENDING:
+              NS_GSTREAMER_LOG(("pending"));
+              break;
+            case GST_STATE_NULL:
+              NS_GSTREAMER_LOG(("null"));
+              break;
+            case GST_STATE_READY:
+              NS_GSTREAMER_LOG(("ready"));
+              break;
+            case GST_STATE_PAUSED:
+              NS_GSTREAMER_LOG(("pause"));
+              break;
+            case GST_STATE_PLAYING:
+              NS_GSTREAMER_LOG(("playing"));
+              break;
+          }
+
+
+          switch(pending)
+          {
+            case GST_STATE_VOID_PENDING:
+              // ntf("pending");
+              break;
+            case GST_STATE_NULL:
+              NS_GSTREAMER_LOG((" ( null )"));
+              break;
+            case GST_STATE_READY:
+              NS_GSTREAMER_LOG((" ( ready )"));
+              break;
+            case GST_STATE_PAUSED:
+              NS_GSTREAMER_LOG((" ( pause )"));
+              break;
+            case GST_STATE_PLAYING:
+              NS_GSTREAMER_LOG((" ( playing )"));
+              break;
+          }
+          NS_GSTREAMER_LOG(("\n"));
+          while (1) {
+            switch (gst_iterator_next(iterator, (gpointer*) & pad)) {
+              case GST_ITERATOR_OK:{
+                SPC
+                if (GST_PAD_SRC ==  gst_pad_get_direction(pad)) {
+                  NS_GSTREAMER_LOG(("SourcePad  "));
+                }
+                else {
+                  NS_GSTREAMER_LOG(("SinkPad "));
+                }
+
+                gchar *padstr = gst_pad_get_name(pad);
+                NS_GSTREAMER_LOG(("(%s):",padstr));
+                g_free(padstr);
+
+                GstCaps *caps =  gst_pad_get_caps(pad);
+                gchar *capsstr = gst_caps_to_string(caps);
+                gchar *stringToFree = capsstr;
+
+                IN
+                  NS_GSTREAMER_LOG(("\n"));
+                  SPC
+                  NS_GSTREAMER_LOG((" ")); // <- Stupid way to fix CRT-allignment issue
+                  while(*capsstr)
+                  {
+                    if(';' == *capsstr)
+                    {
+                      NS_GSTREAMER_LOG(("\n"));
+                      SPC
+                    }
+                    else
+                    {
+                      putchar(*capsstr);
+                    }
+                    capsstr++;
+                  }
+                  NS_GSTREAMER_LOG(("\n"));
+
+                OUT
+                 g_free(stringToFree);
+                 gst_caps_unref(caps);
+
+                gst_object_unref(GST_OBJECT(pad));
+                continue;
+              }
+              case GST_ITERATOR_RESYNC:
+                gst_iterator_resync(iterator);
+                continue;
+              case GST_ITERATOR_ERROR:
+              case GST_ITERATOR_DONE:
+                break;
+            }
+            break;
+          }
+       }
+      OUT
+      // If we are iterating then goto next element
+      if (binIterator) {
+        switch (gst_iterator_next(binIterator, (gpointer*)&element)) {
+          case GST_ITERATOR_OK:
+            continue;
+          case GST_ITERATOR_RESYNC:
+            gst_iterator_resync(binIterator);
+            continue;
+          case GST_ITERATOR_ERROR:
+          case GST_ITERATOR_DONE:
+          default:
+            break;
+          }
+      }
+      // End the while loop
+      break;
+    };
+
+    OUT NS_GSTREAMER_LOG(("/\\Dumping End\n"));
+  }
+#endif
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerLog.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerLog.h
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsGStreamerLog_h__
+#define nsGStreamerLog_h__
+
+#include "gst/gst.h"
+
+#define NS_GSTREAMER_PRINTF_LOGGING
+
+#ifdef NS_GSTREAMER_PRINTF_LOGGING
+#define NS_GSTREAMER_LOG(msg) printf msg ;fflush(stdout)
+#else
+#ifdef PR_LOGGING
+extern PRLogModuleInfo* gVideoDecoderLog;
+#define NS_GSTREAMER_LOG(msg) PR_LOG(gVideoDecoderLog, PR_LOG_DEBUG, msg)
+#else
+#define NS_GSTREAMER_LOG(msg)
+#endif
+#endif
+
+// Function that can be called at any time after the gstreamer library has been
+// initialized to dump all info about an element, it's sub-components and state
+void DumpGStreamerElement(GstElement*aEleToDump);
+
+// TODO:  Remove the below static variables, they are for debug only
+extern int sSetRGBCalled;
+extern int sDraws;
+
+#endif
+
Index: mozilla/content/media/gstreamer/nsGStreamerPipeline.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerPipeline.cpp
@@ -0,0 +1,506 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#include "nsGStreamerPipeline.h"
+#include "nsGStreamerLog.h"
+
+NS_IMPL_THREADSAFE_ISUPPORTS0(nsGStreamerPipeline)
+
+nsGStreamerPipeline::nsGStreamerPipeline()
+  : mStreamPipeline(nsnull),
+    mAudioPadSource(nsnull),
+    mAudioPadSink(nsnull),
+    mVideoPadSource(nsnull),
+    mVideoPadSink(nsnull)
+{
+}
+
+nsGStreamerPipeline::~nsGStreamerPipeline()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerPipeline\n"));
+
+  // Ensure we have released all our resources
+  Destroy();
+}
+
+PRBool nsGStreamerPipeline::Create(nsMediaStream *aMediaStream)
+{
+  // Make sure we have a clean starting point
+  Destroy();
+
+  // Create pipeline
+  mStreamPipeline = gst_pipeline_new("mStreamPipeline");
+
+  // Take ownership
+  gst_object_sink(gst_object_ref(GST_OBJECT(mStreamPipeline)));
+
+  NS_GSTREAMER_LOG(("++++Creating pipeline..."));
+
+  // Note: the below if-statement is not inline with the Mozilla coding-
+  // standard but it is also an exceptional if statement, I haven't been able
+  // to find another layout that as clearly supports the meaning of what is
+  // done
+  if (// Create/Check elements
+         mStreamPipeline
+      && mInputBin.Create(aMediaStream, &mGStreamerState)
+      && mDecodeBin.Create(this)
+      // Add elements to pipeline
+      && gst_bin_add(GST_BIN_CAST(mStreamPipeline),
+                     GST_ELEMENT_CAST(mInputBin))
+      && gst_bin_add(GST_BIN_CAST(mStreamPipeline),
+                     GST_ELEMENT_CAST(mDecodeBin))
+      // Link what we can
+      && gst_element_link(mInputBin, mDecodeBin))
+  {
+    // If all is well we can continue to monitor
+    // the messages on the bus of the pipeline
+
+    GstBus* bus = gst_pipeline_get_bus(GST_PIPELINE(mStreamPipeline));
+    gst_bus_add_watch(bus, (GstBusFunc)BusCallBack, this);
+    gst_object_unref(GST_OBJECT(bus));
+    gst_pipeline_set_auto_flush_bus(GST_PIPELINE(mStreamPipeline),  false);
+
+    mGStreamerState.Init(mStreamPipeline);
+
+    NS_GSTREAMER_LOG(("....ok\n"));
+    return PR_TRUE;
+  } else {
+   // TODO: some kind of error clean-up might be in order here?
+   return PR_FALSE;
+  }
+}
+
+void nsGStreamerPipeline::Shutdown()
+{
+  mGStreamerState.Shutdown();
+}
+
+void nsGStreamerPipeline::Destroy()
+{
+  NS_GSTREAMER_LOG(("----Pipeline going down----\n"));
+
+  // Ensure pipeline has moved to the NULL state etc.
+  Shutdown();
+
+  if (mStreamPipeline) {
+    gst_object_unref(GST_OBJECT(mStreamPipeline));
+  }
+  mStreamPipeline = nsnull;
+
+  mInputBin.Destroy();
+  mDecodeBin.Destroy();
+  mAudioBin.Destroy();
+  mVideoBin.Destroy();
+}
+
+nsGStreamerPipeline::operator GstElement *()
+{
+  return GST_ELEMENT_CAST(mStreamPipeline);
+}
+
+void nsGStreamerPipeline::SetElementWrapper(
+    nsGStreamerElementWrapper *aElementWrapper)
+{
+  mElementWrapper = aElementWrapper;
+  mInputBin.SetElementWrapper(aElementWrapper);
+  mVideoBin.SetElementWrapper(aElementWrapper);
+  mGStreamerState.SetElementWrapper(aElementWrapper);
+}
+
+void nsGStreamerPipeline::SetStreamerDecoder(
+    nsGStreamerDecoder *aStreamerDecoder)
+{
+  mStreamerDecoder = aStreamerDecoder;
+  mVideoBin.SetStreamerDecoder(aStreamerDecoder);
+}
+
+float nsGStreamerPipeline::GetCurrentTime()
+{
+  if (!mStreamPipeline) {
+    return 0.0;
+  }
+
+  GstFormat format = GST_FORMAT_TIME;
+  gint64 position = 0;
+  gst_element_query_position(mStreamPipeline, &format, &position);
+
+  return ((double)position / GST_SECOND);
+}
+
+float nsGStreamerPipeline::GetDuration()
+{
+  if (!mStreamPipeline) {
+    return 0.0;
+  }
+
+  GstFormat format = GST_FORMAT_TIME;
+  gint64 length = 0;
+  gst_element_query_duration(mStreamPipeline, &format, &length);
+
+  return ((double)length / GST_SECOND);
+}
+
+nsGStreamerAudioPropertiesInterface *nsGStreamerPipeline::GetAudioPropertyInterface()
+{
+  // Return the audio property interface
+  return &mAudioBin;
+}
+
+nsGStreamerPlayPauseInterface *nsGStreamerPipeline::GetPlayPauseInterface()
+{
+  // Return the play pause interface
+  return &mGStreamerState;
+}
+
+nsGStreamerScreenInvalidatedInterface *
+    nsGStreamerPipeline::GetScreenInvalidatedInterface()
+{
+  // Return the screen invalidated interface
+  return &mVideoBin;
+}
+
+nsGStreamerSuspendResumeInterface *
+    nsGStreamerPipeline::GetSuspendResumeInterface()
+{
+  return &mGStreamerState;
+}
+
+
+gboolean nsGStreamerPipeline::BusCallBack(GstBus *aBus,
+                                          GstMessage *aMessage,
+                                          nsGStreamerPipeline *aMe)
+{
+  //  NS_GSTREAMER_LOG(("GStreamerBusCallBack (0x%X) : ", aMsg->type));
+  switch (aMessage->type)
+  {
+    case GST_MESSAGE_STATE_CHANGED: {
+#if 0
+      GstState oldState;
+      GstState newState;
+      GstState pendingState;
+
+      gst_message_parse_state_changed(aMessage,
+                                      &oldState,
+                                      &newState,
+                                      &pendingState);
+
+      NS_GSTREAMER_LOG((
+                        "GStreamer StateChange: %s to %s pending %s\n",
+                        gst_element_state_get_name(oldState),
+                        gst_element_state_get_name(newState),
+                        gst_element_state_get_name(pendingState)));
+#endif
+      break;
+    }
+
+    case GST_MESSAGE_TAG: {
+      NS_GSTREAMER_LOG((
+            "GStreamer tag: <use 'gst_message_parse_tag' to get output>\n"));
+      break;
+    }
+
+    case GST_MESSAGE_ERROR: {
+      GError* err;
+      gchar *debug;
+      gst_message_parse_error(aMessage, &err, &debug);
+      NS_GSTREAMER_LOG(("----GStreamer Error: %s,%s, %s\n",
+             g_quark_to_string(err->domain),
+             err->message,
+             debug));
+      g_error_free(err);
+      // TODO: End playback
+      break;
+    }
+
+    case GST_MESSAGE_WARNING: {
+      GError* err;
+      gchar *debug;
+      gst_message_parse_warning(aMessage, &err, &debug);
+      NS_GSTREAMER_LOG(("----GStreamer Warning: %s,%s, %s\n",
+             g_quark_to_string(err->domain),
+             err->message,
+             debug));
+      g_error_free(err);
+      break;
+    }
+
+    case GST_MESSAGE_CLOCK_LOST: {
+      NS_GSTREAMER_LOG(("GStreamer clock lost:\n"));
+      break;
+    }
+
+    case GST_MESSAGE_CLOCK_PROVIDE:{
+      NS_GSTREAMER_LOG(("GStreamer clock provide:\n"));
+      break;
+    }
+
+    case GST_MESSAGE_NEW_CLOCK: {
+//        NS_GSTREAMER_LOG(("GStreamer new clock:\n"));
+      break;
+    }
+
+    case GST_MESSAGE_ASYNC_START: {
+      NS_GSTREAMER_LOG(("GStreamer async start:\n"));
+      break;
+    }
+
+    case GST_MESSAGE_ASYNC_DONE: {
+      NS_GSTREAMER_LOG(("GStreamer async done:\n"));
+      break;
+    }
+
+    case GST_MESSAGE_EOS: {
+      NS_GSTREAMER_LOG(("GStreamer EOS\n"));
+      aMe->mElementWrapper->PlaybackEnded();
+      aMe->mGStreamerState.PositionAtEOF();
+      break;
+    }
+
+    case GST_MESSAGE_BUFFERING: {
+      // This message should not be called any more
+      gint percent = 0;
+      gst_message_parse_buffering(aMessage, &percent);
+      NS_GSTREAMER_LOG(("Buffering...%i\n", percent));
+      break;
+    }
+
+    case GST_MESSAGE_DURATION: {
+      GstFormat format;
+      gint64 duration;
+      gst_message_parse_duration(aMessage,
+      &format,
+      &duration);
+
+      NS_GSTREAMER_LOG(("GStreamer duration: %s, %li",
+                        gst_format_get_name(format),
+                        duration));
+
+      break;
+    }
+
+    default: {
+      PRInt32 i = 0;
+      PRInt32 j = 1;
+      while (j > aMessage->type) {j <<= 1;if (i++ > 64)break;};
+      NS_GSTREAMER_LOG(("GStreamerBusCallBack(0x%X - 1<<%i) : ",
+                                  aMessage->type, i));
+      NS_GSTREAMER_LOG(("Unknown\n"));
+    }
+  }
+
+  return true;
+}
+
+void nsGStreamerPipeline::DecodeBinNewPadAdded(void *,
+                                               GstPad *aPad,
+                                               gboolean aIsLast)
+{
+  // Check if it is an audio pad that has been added
+  GstCaps *caps = gst_pad_get_caps(aPad);
+  GstStructure *str = gst_caps_get_structure(caps, 0);
+
+  NS_GSTREAMER_LOG(("+++New  pad added :"));
+  gchar *capsstr = gst_caps_to_string(caps);
+
+  NS_GSTREAMER_LOG(("%s\n", capsstr));
+
+  g_free(capsstr);
+
+  // Could there be an issue with multiple audio streams in one stream?
+  if (g_strrstr(gst_structure_get_name(str), "audio")) {
+    NS_GSTREAMER_LOG(("...setting up audio bin\n"));
+    if (   !mAudioBin.Create()
+        || !gst_bin_add(GST_BIN_CAST(mStreamPipeline),
+                        GST_ELEMENT_CAST(mAudioBin))
+        || !mAudioBin.Link(aPad)
+        || !gst_element_set_state(mAudioBin, GST_STATE_PAUSED))
+    {
+      NS_GSTREAMER_LOG(("... ^ audio bin creation failed\n"));
+      // Do cleanup (wether needed or not)
+      gst_bin_remove(GST_BIN_CAST(mStreamPipeline),
+                     GST_ELEMENT_CAST(mAudioBin));
+      mAudioBin.Destroy();
+      // In case of failure, direct pad to black hole
+      BlackHole(aPad);
+    }
+  }
+  // If it wasn't an audio pad, then check for a video pad
+  else if (g_strrstr(gst_structure_get_name(str), "video")) {
+    NS_GSTREAMER_LOG(("...setting up video bin\n"));
+    if(   !mVideoBin.Create(&mGStreamerState)
+       || !gst_bin_add(GST_BIN_CAST(mStreamPipeline),
+                       GST_ELEMENT_CAST(mVideoBin))
+       || !mVideoBin.Link(aPad)
+       || !gst_element_set_state(mVideoBin, GST_STATE_PAUSED))
+    {
+      NS_GSTREAMER_LOG(("... ^ audio bin creation failed\n"));
+      // Do cleanup (wether needed or not)
+      gst_bin_remove(GST_BIN_CAST(mStreamPipeline),
+                     GST_ELEMENT_CAST(mVideoBin));
+      mVideoBin.Destroy();
+
+      // In case of failure, direct pad to black hole
+      BlackHole(aPad);
+    }
+  } else {
+    // In case of failure, direct pad to black hole
+    BlackHole(aPad);
+  }
+
+  // Clean up, note this can't be done until we are done with the 'str' above
+  gst_caps_unref(caps);
+
+  if (aIsLast) {
+    NS_GSTREAMER_LOG(("----No more pads\n"));
+    nsCOMPtr<nsIRunnable> event =
+      NS_NEW_RUNNABLE_METHOD(nsGStreamerPipeline, this, DoNoMorePads);
+
+    NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+    NS_GSTREAMER_LOG(
+      ("+++Dispatched async event about no more pads\n"));
+
+  }
+}
+
+void nsGStreamerPipeline::DecodeBinUnknownType(void *,
+                                               GstPad *aPad,
+                                               GstCaps * aCaps)
+{
+  // TODO: Signal error to user
+  NS_GSTREAMER_LOG(("----DecodeBinUnknownType\n"));
+
+  GstCaps *pcaps = gst_pad_get_caps(aPad);
+  gchar *capsstr = gst_caps_to_string(pcaps);
+
+  NS_GSTREAMER_LOG(("%s\n", capsstr));
+
+#if 1
+///////////////
+
+  GstPad* newPad = gst_ghost_pad_new(capsstr, aPad);
+
+  PRBool isSuccess;
+
+  isSuccess = gst_element_add_pad(GST_ELEMENT_CAST(mDecodeBin), newPad);
+
+  NS_GSTREAMER_LOG(("---- PAD (0x%.8X) ADD was %s\n", newPad, isSuccess?"good":"fail"));
+
+  DecodeBinNewPadAdded(nsnull, newPad, FALSE);
+
+///////////////
+#endif
+
+  g_free(capsstr);
+  gst_caps_unref(pcaps);
+}
+
+void nsGStreamerPipeline::DecodeBinRemovePad(void *,
+                                             GstPad *aPad)
+{
+  // TODO: Anything sensible to do here?
+  NS_GSTREAMER_LOG(("----DecodeBinRemovePad\n"));
+}
+
+void nsGStreamerPipeline::DecodeBinNoMorePads(void *)
+{
+  // TODO: Add code that handles this with intelligence
+
+  nsCOMPtr<nsIRunnable> event =
+    NS_NEW_RUNNABLE_METHOD(nsGStreamerPipeline, this, DoNoMorePads);
+  if (event) {
+    NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+    NS_GSTREAMER_LOG(
+                            ("+++Dispatched async event about no more pads\n"));
+  }
+
+  NS_GSTREAMER_LOG(("+++No more pads pending...\n"));
+}
+
+PRBool nsGStreamerPipeline::BlackHole(GstPad *aPad)
+{
+  GstElement *blackHole = gst_element_factory_make("fakesink", "BlackHole");
+
+  // Note: We don't take ownership of the black hole, as we will never
+  // store a pointer to it, beyond this function
+
+  if (
+         blackHole
+      && gst_bin_add(GST_BIN_CAST(static_cast<GstElement *>(*this)), blackHole)
+      && gst_pad_link(aPad, gst_element_get_static_pad(blackHole, "sink"))
+      // Note GST_STATE_CHANGE_FAILURE = 0, hence a failure to change
+      // state will be a logic false
+      && gst_element_set_state(blackHole, GST_STATE_PAUSED)
+     )
+  {
+    // All went well - return success
+    return TRUE;
+  }
+
+  // Clean up
+
+  // If we never got a black hole then abort
+  if (!blackHole) return FALSE;
+
+  // If pad is linked, unlink it
+  if (GST_PAD_IS_LINKED(aPad) &&
+      !gst_pad_unlink(aPad, gst_element_get_static_pad(blackHole, "sink"))){
+    NS_GSTREAMER_LOG(("Unable to unlink black hole"));
+  }
+
+  // Check if pad was added
+  if (static_cast<GstElement*>(*this) == GST_ELEMENT_CAST(gst_element_get_parent(blackHole))) {
+    if(!gst_bin_remove(GST_BIN_CAST(static_cast<GstElement *>(*this)),
+                       blackHole)) {
+      NS_GSTREAMER_LOG(("Unable to remove black hole from pipeline"));
+    }
+  } else {
+    // Black hole was created, but never added - release it
+    gst_object_ref(GST_OBJECT(blackHole));
+    gst_object_unref(GST_OBJECT(blackHole));
+  }
+
+  // Anyway if we get here then return an error
+  return FALSE;
+}
+
+void nsGStreamerPipeline::DoNoMorePads()
+{
+  NS_GSTREAMER_LOG(("\"no more pads\"\n"));
+  mGStreamerState.AllPadsLinked();
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerPipeline.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerPipeline.h
@@ -0,0 +1,179 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerPipeline_h__
+#define nsGStreamerPipeline_h__
+
+#include "gst/gst.h"
+#include "nsGStreamerDecodeBinPadInterface.h"
+#include "nsGStreamerAudioPropertiesInterface.h"
+#include "nsGStreamerPlayPauseInterface.h"
+#include "nsGStreamerScreenInvalidatedInterface.h"
+#include "nsGStreamerInputBin.h"
+#include "nsGStreamerDecodeBin.h"
+#include "nsGStreamerAudioBin.h"
+#include "nsGStreamerVideoBin.h"
+#include "nsGStreamerPipelineState.h"
+
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that takes care of the GStreamer pipeline
+
+class nsGStreamerPipeline :
+  private nsGStreamerDecodeBinPadInterface,
+  public nsISupports
+{
+  public:
+    NS_DECL_ISUPPORTS
+
+    // Constructor
+    nsGStreamerPipeline();
+
+    // Destructor
+    ~nsGStreamerPipeline();
+
+    // Builds a bin, holding all the elements for processing an AV stream
+    PRBool Create(nsMediaStream *aMediaStream);
+
+    // Terminates everything GStreamer related
+    void Shutdown();
+
+    // Releases all resources allocated
+    void Destroy();
+
+    // Easy way to get the element pointer
+    operator GstElement *();
+
+    // Set the element wrapper
+    void SetElementWrapper(nsGStreamerElementWrapper *aElementWrapper);
+
+    // Set the streamer decoder
+    void SetStreamerDecoder(nsGStreamerDecoder *aStreamerDecoder);
+
+    // Get current position of playback in seconds
+    float GetCurrentTime();
+
+    // Get the lenght of the stream (if available)
+    float GetDuration();
+
+    // Get the audio property interface
+    nsGStreamerAudioPropertiesInterface *GetAudioPropertyInterface();
+
+    // Get the play pause interface
+    nsGStreamerPlayPauseInterface *GetPlayPauseInterface();
+
+    // Get the screen invalidated interface
+    nsGStreamerScreenInvalidatedInterface *GetScreenInvalidatedInterface();
+
+    // Get the interface to suspend and resume the playback
+    nsGStreamerSuspendResumeInterface *GetSuspendResumeInterface();
+
+  private:
+    GstElement *mStreamPipeline;
+
+    // Input buffer (data in)
+    nsGStreamerInputBin mInputBin;
+
+    // Decode bin (does the actuall decoding)
+    nsGStreamerDecodeBin mDecodeBin;
+
+    // Audio bin (audio out)
+    nsGStreamerAudioBin mAudioBin;
+
+    // Video bin (video out)
+    nsGStreamerVideoBin mVideoBin;
+
+    //Takes care of element com.
+    nsRefPtr<nsGStreamerElementWrapper> mElementWrapper;
+
+    // Pointer back to the streamer decoder
+    nsGStreamerDecoder *mStreamerDecoder;
+
+    // Set for async pad linking
+
+    // Audio source
+    GstPad *mAudioPadSource;
+
+    // Audio sink
+    GstPad *mAudioPadSink;
+
+    // Video source
+    GstPad *mVideoPadSource;
+
+    // Video sink
+    GstPad *mVideoPadSink;
+
+    // Class keeping the GStreamer state machine
+    nsGStreamerPipelineState mGStreamerState;
+
+    nsGStreamerElementWrapper *GetElementWrapper() {return mElementWrapper;};
+
+    nsGStreamerDecoder *GetStreamerDecoder() {return mStreamerDecoder;};
+
+    static  gboolean  BusCallBack(GstBus *aBus,
+                                  GstMessage *aMessage,
+                                  nsGStreamerPipeline *aMe);
+
+    // Functions from the  nsGStreamerDecodeBinPadInterface interface
+    virtual void DecodeBinNewPadAdded(void *aDecodebin2,
+                                      GstPad *aPad,
+                                      gboolean aIsLast);
+
+    virtual void DecodeBinUnknownType(void *aDecodebin2,
+                                      GstPad *aPad,
+                                      GstCaps *aCaps);
+
+    virtual void DecodeBinRemovePad(void *aDecodebin2,
+                                    GstPad *aPad);
+
+    virtual void DecodeBinNoMorePads(void *aDecodebin2);
+
+    // Creates a black hole that takes all kinds of streams and directs them
+    // to null
+    // Returns TRUE if the black hole was created and linked to the pad
+    // Guess what FALSE means :)
+    PRBool BlackHole(GstPad *);
+
+    // Functions to do the manipulation from nsGStreamerDecodeBinPadInterface
+    // in the main thread
+    void DoNoMorePads();
+};
+
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerPipelineState.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerPipelineState.cpp
@@ -0,0 +1,205 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsGStreamerLog.h"
+#include "nsGStreamerPipelineState.h"
+
+nsGStreamerPipelineState::nsGStreamerPipelineState()
+  : mPipelineToControl(nsnull),
+    mElementWrapper(nsnull),
+    mCurrentState(GST_STATE_NULL),
+    mIsSuspended(PR_FALSE),
+    mShouldPlayWhenPossible(PR_FALSE),
+    mDoesBufferHaveEnoughData(PR_FALSE),
+    mAreAllPadsLinked(PR_FALSE),
+    mAreWeAtEOF(PR_FALSE),
+    mIsPrerollPending(PR_FALSE)
+{
+}
+
+nsGStreamerPipelineState::~nsGStreamerPipelineState()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerPipelineState\n"));
+}
+
+void nsGStreamerPipelineState::Init(GstElement *aPipelineToControl)
+{
+  mPipelineToControl = aPipelineToControl;
+  UpdateState();
+}
+
+void nsGStreamerPipelineState::Shutdown()
+{
+  // If we have a stream, we must put it into the NULL state
+  SwitchState(GST_STATE_NULL);
+  // We can't touch the pipeline anymore
+  mPipelineToControl=nsnull;
+}
+
+void nsGStreamerPipelineState::Suspend()
+{
+  mIsSuspended = PR_TRUE;
+  UpdateState();
+}
+
+void nsGStreamerPipelineState::Resume()
+{
+  mIsSuspended = PR_FALSE;
+  UpdateState();
+}
+
+
+void nsGStreamerPipelineState::PlayWhenPossible(PRBool aShouldPlay)
+{
+  mShouldPlayWhenPossible = aShouldPlay;
+  UpdateState();
+}
+
+PRBool nsGStreamerPipelineState::IsPlaying()
+{
+  // While this is technically not correct all the time, it is close enough
+  // e.g. stream could be "paused" due to empty input buffer
+  return (GST_STATE_PLAYING == mCurrentState);
+}
+
+PRBool nsGStreamerPipelineState::IsAtEOF()
+{
+  return mAreWeAtEOF;
+}
+
+void nsGStreamerPipelineState::BufferHasEnoughData(PRBool aIsEnough)
+{
+  if (aIsEnough) {
+   // Will it hurt to call this too often?
+    mElementWrapper->NotifyAutoplayDataReady();
+  }
+  mDoesBufferHaveEnoughData = aIsEnough;
+  UpdateState();
+}
+
+void nsGStreamerPipelineState::AllPadsLinked()
+{
+  mAreAllPadsLinked = PR_TRUE,
+  UpdateState();
+}
+
+void nsGStreamerPipelineState::PositionAtEOF()
+{
+  mAreWeAtEOF = PR_TRUE;
+  UpdateState();
+}
+
+void nsGStreamerPipelineState::VideoStreamDetected()
+{
+  mIsPrerollPending = PR_TRUE;
+  UpdateState();
+}
+
+void nsGStreamerPipelineState::VideoPrerollComplete()
+{
+  mIsPrerollPending = PR_FALSE;
+  UpdateState();
+}
+
+void nsGStreamerPipelineState::SetElementWrapper(
+    nsGStreamerElementWrapper *aElementWrapper)
+{
+  mElementWrapper = aElementWrapper;
+}
+
+
+void nsGStreamerPipelineState::UnconditionalPlay()
+{
+  SwitchState(GST_STATE_PLAYING);
+}
+
+void nsGStreamerPipelineState::UnconditionalReady()
+{
+  SwitchState(GST_STATE_READY);
+}
+
+void nsGStreamerPipelineState::UnconditionalNull()
+{
+  SwitchState(GST_STATE_NULL);
+}
+
+void nsGStreamerPipelineState::UpdateState()
+{
+  // Check if we should move to the play state
+  if ( mAreAllPadsLinked &&
+//      mShouldPlayWhenPossible &&
+//      mDoesBufferHaveEnoughData &&
+      !mIsSuspended &&
+      !mAreWeAtEOF &&
+      !mIsPrerollPending)
+  {
+    SwitchState(GST_STATE_PLAYING);
+  } else {
+    // Otherwise we move to the pause state
+    SwitchState(GST_STATE_PAUSED);
+  }
+}
+
+void nsGStreamerPipelineState::SwitchState(GstState aNewState)
+{
+  // If we have a pipeline and the new state is different than the old one
+  if (mPipelineToControl && aNewState != mCurrentState) {
+    NS_GSTREAMER_LOG(
+      ("Attempting to move to %s..", gst_element_state_get_name(aNewState)));
+    switch ( gst_element_set_state(mPipelineToControl, aNewState)) {
+      case GST_STATE_CHANGE_FAILURE:
+        NS_GSTREAMER_LOG(("State change failure\n"));
+        break;
+      case GST_STATE_CHANGE_SUCCESS:
+        NS_GSTREAMER_LOG(("State change success\n"));
+        mCurrentState = aNewState;
+        break;
+      case GST_STATE_CHANGE_ASYNC:
+        NS_GSTREAMER_LOG(("State change async\n"));
+        mCurrentState = aNewState;
+        break;
+      case GST_STATE_CHANGE_NO_PREROLL:
+        NS_GSTREAMER_LOG(("State change no preroll\n"));
+        break;
+      default:
+        NS_GSTREAMER_LOG(("Unknown error\n"));
+      }
+    }
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerPipelineState.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerPipelineState.h
@@ -0,0 +1,160 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerPipelineState_h__
+#define nsGStreamerPipelineState_h__
+
+#include "gst/gst.h"
+#include "nsGStreamerElementWrapper.h"
+#include "nsGStreamerInputBufferStatusInterface.h"
+#include "nsGStreamerPlayPauseInterface.h"
+#include "nsGStreamerSuspendResumeInterface.h"
+#include "nsGStreamerVideoPrerollCompleteInterface.h"
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that takes care of the GStreamer pipeline state
+class nsGStreamerPipelineState
+  : public nsGStreamerInputBufferStatusInterface,
+    public nsGStreamerPlayPauseInterface,
+    public nsGStreamerSuspendResumeInterface,
+    public nsGStreamerVideoPrerollCompleteInterface
+{
+  public:
+    // Constructor
+    nsGStreamerPipelineState();
+
+    // Destructor
+    ~nsGStreamerPipelineState();
+
+    // Initializing function
+    void Init(GstElement *aPipelineToControl);
+
+    // Terminates everything GStreamer related
+    void Shutdown();
+
+    // Tell the state machine that playback should be suspended
+    virtual void Suspend();
+
+    // Tell the state machine that playback should be resumed
+    virtual void Resume();
+
+    // Tell state machine if it should play or stop(pause)
+    // bPlay = PR_TRUE => playback starts when conditions are right
+    // bPlay = PR_FALSE => playback is paused and will not start
+    virtual void PlayWhenPossible(PRBool aShouldPlay);
+
+    // Retrieve current state
+    // returns PR_TRUE => playback is running
+    // returns PR_FALSE => playback is paused
+    virtual PRBool IsPlaying();
+
+    // Used to retrieve the EOF state
+    // returns PR_TRUE => playback is at EOF
+    // returns PR_FALSE => still more to playback !EOF
+    virtual PRBool IsAtEOF();
+
+    // Called to inform state machine of buffer status
+    // arg = PR_TRUE: Enough Data has been buffered to start playback
+    // arg = PR_FALSE: Buffer is empty or don't have enough data
+    //                 to continue playback
+    virtual void BufferHasEnoughData(PRBool aIsEnough);
+
+    // Tell state machine that all pads are linked
+    void AllPadsLinked();
+
+    // Called when playback has completed (e.g. position is at EOF)
+    void PositionAtEOF();
+
+    // Call when a video stream has been detected
+    void VideoStreamDetected();
+
+    // Call when preroll is complete for a video stream
+    virtual void VideoPrerollComplete();
+
+    // Set the element wrapper
+    void SetElementWrapper(nsGStreamerElementWrapper *aElementWrapper);
+
+
+    // Below functions are for debug/test purposes should
+    // not be called directly from production code
+
+    // Unconditionally attempt to move to the play state
+    void UnconditionalPlay();
+
+    // Unconditionally attempt to move to the ready state
+    void UnconditionalReady();
+
+    // Unconditionally attempt to move to the null state
+    void UnconditionalNull();
+
+  private:
+    GstElement *mPipelineToControl;
+
+    //Takes care of element com.
+    nsRefPtr<nsGStreamerElementWrapper> mElementWrapper;
+
+    // Keeps the last state we requested
+    GstState mCurrentState;
+
+    // Value indicating if stream currently is suspended
+    PRPackedBool mIsSuspended;
+
+    // Value set by last call to PlayWhenPossible(...)
+    PRPackedBool mShouldPlayWhenPossible;
+
+    // Value set by last call to BufferHasEnoughData(...)
+    PRPackedBool mDoesBufferHaveEnoughData;
+
+    // Value set to true byAllPadsLinked()
+    PRPackedBool mAreAllPadsLinked;
+
+    // Value set to true by PositionAtEOF()
+    PRPackedBool mAreWeAtEOF;
+
+    // It's a video and we have not done preroll yet
+    PRPackedBool mIsPrerollPending;
+
+    // Update the GStreamer state depending on the currently set states
+    void UpdateState();
+
+    // Switch state to specific state
+    void SwitchState(GstState aNewState);
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerPlayPauseInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerPlayPauseInterface.h
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerPlayPauseInterface_h__
+#define nsGStreamerPlayPauseInterface_h__
+
+#include "prtypes.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Interface class for starting and stopping play
+class nsGStreamerPlayPauseInterface
+{
+  public:
+    // Tell state machine if it should play or stop(pause)
+    // aShouldPlay = PR_TRUE => playback starts when conditions are right
+    // aShouldPlay = PR_FALSE => playback is paused and will not start
+    virtual void PlayWhenPossible(PRBool aShouldPlay) = 0;
+
+    // Retrieve current state
+    // returns PR_TRUE => playback is running
+    // returns PR_FALSE => playback is paused
+    virtual PRBool IsPlaying() = 0;
+
+    // Used to retrieve the EOF state
+    // returns PR_TRUE => playback is at EOF
+    // returns PR_FALSE => still more to play back !EOF
+    virtual PRBool IsAtEOF() = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerScreenInvalidatedInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerScreenInvalidatedInterface.h
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerScreenInvalidatedInterface_h__
+#define nsGStreamerScreenInvalidatedInterface_h__
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that holds the interface that should be called
+// when the screen has been updated
+class nsGStreamerScreenInvalidatedInterface
+{
+  public:
+    // Call back when screen has actually been invalidated
+    virtual void ScreenHasBeenInvalidated() = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerStreamStatusInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerStreamStatusInterface.h
@@ -0,0 +1,51 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerStreamStatusInterface_h__
+#define nsGStreamerStreamStatusInterface_h__
+
+////////////////////////////////////////////////////////////////////////////////
+// Interface class for feeding stream statuses back into "object land"
+class nsGStreamerStreamStatusInterface
+{
+  public:
+    // Called to inform that EOF has been reached
+    virtual void EOFReached() = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerSuspendResumeInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerSuspendResumeInterface.h
@@ -0,0 +1,53 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerSuspendResumeInterface_h__
+#define nsGStreamerSuspendResumeInterface_h__
+
+////////////////////////////////////////////////////////////////////////////////
+// Interface class for starting and stopping play
+class nsGStreamerSuspendResumeInterface
+{
+  public:
+    // Tell the state machine that playback should be suspended
+    virtual void Suspend() = 0;
+
+    // Tell the state machine that playback should be resumed
+    virtual void Resume() = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerVideoBin.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerVideoBin.cpp
@@ -0,0 +1,525 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsGStreamerConfig.h"
+#include "nsGStreamerLog.h"
+#include "nsGStreamerVideoBin.h"
+#include "string.h"
+
+
+
+
+
+nsGStreamerVideoBin::nsGStreamerVideoBin() :
+    mVideoBin(nsnull),
+    mColorConverter(nsnull),
+    mFakeSink(nsnull),
+    mVideoSink(nsnull),
+    mVideoBuffer(nsnull),
+    mElementWrapper(nsnull),
+    mStreamerDecoder(nsnull),
+    mVideoPrerollComplete(nsnull),
+    mIsScreenPreviouslyInvalidated(PR_TRUE),
+    mScreenInvalidMutex(nsnull),
+    mScreenInvalidatedCond(nsnull),
+    mWidth(0),
+    mHeight(0),
+    mAspect(0),
+    mFramerate(0)
+{
+}
+
+nsGStreamerVideoBin::~nsGStreamerVideoBin()
+{
+  NS_GSTREAMER_LOG(("~nsGStreamerVideoBin\n"));
+  // Ensure we have released all our resources
+  Destroy();
+}
+
+PRBool nsGStreamerVideoBin::Create(
+    nsGStreamerVideoPrerollCompleteInterface *aVideoPrerollComplete)
+{
+  // Be sure to clean up, before we start something new
+  Destroy();
+
+  PRBool isSuccess = PR_FALSE; // Assume failure
+
+  // Save the preroll complete interface
+  mVideoPrerollComplete = aVideoPrerollComplete;
+
+  // The bin to collect everything
+  mVideoBin = GST_BIN_CAST(gst_bin_new("mVideoBin"));
+  // The color converter
+  mColorConverter = gst_element_factory_make("ffmpegcolorspace",
+                                              "mColorConverter");
+  // The fake sink to receive the data
+//  mFakeSink = gst_element_factory_make("fakesink", "mFakeSink");
+  // Create a buffer for the video => Running in seperate thead
+  mVideoBuffer = gst_element_factory_make("queue", "mVideoBuffer");
+  // Try to make a sink for displaying
+  mVideoSink = gst_element_factory_make("gstFennecVideoSink", "mVideoSink");
+//  mVideoSink = gst_element_factory_make("xvimagesink", "mVideoSink");
+
+
+  // Take ownership of the elements
+  gst_object_sink(gst_object_ref(GST_OBJECT(mVideoBin)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mColorConverter)));
+//  gst_object_sink(gst_object_ref(GST_OBJECT(mFakeSink)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mVideoBuffer)));
+  gst_object_sink(gst_object_ref(GST_OBJECT(mVideoSink)));
+
+  // Note: the below if-statement is not inline with the Mozilla coding-standard
+  // but it is also an exceptional if statement, I haven't been able to find
+  // another layout that as clearly supports the meaning of what is done
+  if (
+      // Check we got the elements
+         mVideoBin
+      && mColorConverter
+//      && mFakeSink
+      && mVideoBuffer
+      && mVideoSink
+      // Add the elements to the pipeline
+      && gst_bin_add(mVideoBin, mColorConverter)
+//      && gst_bin_add(mVideoBin, mFakeSink)
+//      && gst_bin_add(mVideoBin, mVideoBuffer)
+      && gst_bin_add(mVideoBin, mVideoSink)
+      // Link the elements, ensuring the right conversion takes place
+//      && gst_element_link_pads(mVideoBuffer, "src", mColorConverter, "sink")
+// Below #if chooses between the new video sink or the old fake sink
+#if 1
+      // I know this is wrong, as it will link against a 24 bpp instead of 32
+      && gst_element_link_pads(mColorConverter, "src", mVideoSink, nsnull)
+#if 0
+      && gst_element_link_filtered(mColorConverter,
+                                   mVideoSink,
+                                   gst_caps_new_simple("video/x-raw-rgb",
+                                   "bpp",
+                                   G_TYPE_INT,
+                                   32,
+                                   "depth",
+                                   G_TYPE_INT,
+                                   24,
+                                   NULL))
+#endif
+#else
+      && gst_element_link_filtered(mColorConverter,
+                                   mFakeSink,
+                                   gst_caps_new_simple("video/x-raw-rgb",
+                                   "bpp",
+                                   G_TYPE_INT,
+                                   32,
+                                   "depth",
+                                   G_TYPE_INT,
+                                   24,
+                                   NULL))
+#endif
+     )
+  {
+    // If all went well we can now pipe the sink from the
+    // color converter to the video bin
+//    GstPad *pad = gst_element_get_static_pad(mVideoBuffer, "sink");
+    GstPad *pad = gst_element_get_static_pad(mColorConverter, "sink");
+
+    isSuccess = gst_element_add_pad(GST_ELEMENT_CAST(mVideoBin),
+                                       gst_ghost_pad_new("sink", pad));
+    gst_object_unref(GST_OBJECT(pad));
+
+    NS_GSTREAMER_LOG(("<<Configuring video bin>>\n"));
+
+#if 0
+    // Configure the fake sink
+    g_object_set(G_OBJECT(mFakeSink),
+                 "signal-handoffs",
+                 true,
+                 "sync",
+                 true,
+                 NULL);
+    // Listen to signals from the fake sink
+    g_signal_connect(G_OBJECT(mFakeSink),
+                     "preroll-handoff",
+                     G_CALLBACK(FakeSinkPreRoll),
+                     this);
+    g_signal_connect(G_OBJECT(mFakeSink),
+                     "handoff",
+                     G_CALLBACK(FakeSinkHandoff),
+                     this);
+#endif
+    // Configure the video sink
+    gpointer gvVideoInterface = (nsGStreamerVideoSinkInterface*)this;
+    g_object_set(G_OBJECT(mVideoSink),
+                 "VideoSinkInterface",
+                 gvVideoInterface,
+                 NULL);
+
+    gboolean scaling = false;
+    g_object_set(G_OBJECT(mVideoSink),
+                 "force-aspect-ratio",
+                 scaling,
+                 NULL);
+
+    // Create mutexes for syncronization
+    mScreenInvalidMutex = g_mutex_new();
+    mScreenInvalidatedCond = g_cond_new();
+
+    if (isSuccess) {
+       NS_GSTREAMER_LOG(("<<VIDEO BIN CREATE OK>>\n"));
+    } else {
+      NS_GSTREAMER_LOG(("<<VIDEO BIN CREATE FAIL>>\n"));
+    }
+  } else {
+    NS_GSTREAMER_LOG(("--- Video init failed\n"));
+    // TODO: cleanup if failed
+  }
+
+  // Return success or failure
+  return isSuccess;
+}
+
+void nsGStreamerVideoBin::Destroy()
+{
+  if (mVideoBin) {
+    gst_object_unref(GST_OBJECT(mVideoBin));
+  }
+  if (mColorConverter) {
+    gst_object_unref(GST_OBJECT(mColorConverter));
+  }
+  if (mFakeSink) {
+    gst_object_unref(GST_OBJECT(mFakeSink));
+  }
+  if (mVideoBuffer) {
+    gst_object_unref(GST_OBJECT(mVideoBuffer));
+  }
+  if (mVideoSink) {
+    gst_object_unref(GST_OBJECT(mVideoSink));
+  }
+  if (mScreenInvalidMutex) {
+    g_mutex_free(mScreenInvalidMutex);
+  }
+  if (mScreenInvalidatedCond) {
+    g_cond_free(mScreenInvalidatedCond);
+  }
+
+  mFakeSink = mColorConverter = mVideoBuffer = mVideoSink = nsnull;
+  mVideoBin = nsnull;
+  mScreenInvalidMutex = nsnull;
+  mScreenInvalidatedCond = nsnull;
+}
+
+PRBool nsGStreamerVideoBin::Link(GstPad *aSrc)
+{
+  GstPad *videoPad = gst_element_get_static_pad(*this, "sink");
+
+  // Check that we have an audio sink pad, and that it isn't linked already
+  if (!videoPad || GST_PAD_IS_LINKED(videoPad)) {
+    // Do cleanup
+    gst_object_unref(GST_OBJECT(videoPad));
+    return PR_FALSE;
+  }
+
+  GstCaps *caps =  gst_pad_get_caps(videoPad);
+  gchar *capsstr = gst_caps_to_string(caps);
+
+  NS_GSTREAMER_LOG(("Trying to link to %s\n", capsstr));
+
+  g_free(capsstr);
+  gst_caps_unref(caps);
+
+  GstPadLinkReturn linkResult = gst_pad_link(aSrc, videoPad);
+  NS_GSTREAMER_LOG(("+++Video Link Result = %i (0=Up)\n", linkResult));
+
+  return (GST_PAD_LINK_OK == linkResult);
+}
+
+
+nsGStreamerVideoBin::operator GstElement *()
+{
+  return GST_ELEMENT_CAST(mVideoBin);
+}
+
+void nsGStreamerVideoBin::SetElementWrapper(
+    nsGStreamerElementWrapper *aElementWrapper)
+{
+  mElementWrapper = aElementWrapper;
+}
+
+void nsGStreamerVideoBin::SetStreamerDecoder(
+    nsGStreamerDecoder *aStreamerDecoder)
+{
+  mStreamerDecoder = aStreamerDecoder;
+}
+
+void nsGStreamerVideoBin::ScreenHasBeenInvalidated()
+{
+  // Protect access to mIsScreenPreviouslyInvalidated
+  g_mutex_lock(mScreenInvalidMutex);
+
+  // Screen has now been invalidated
+  mIsScreenPreviouslyInvalidated = PR_TRUE;
+
+  // Wake the waiting thread
+  g_cond_signal(mScreenInvalidatedCond);
+
+  // Unlock the mutex again
+  g_mutex_unlock(mScreenInvalidMutex);
+}
+
+void nsGStreamerVideoBin::FakeSinkPreRoll(void *,
+                                          GstBuffer * aBuffer,
+                                          GstPad *aPad,
+                                          nsGStreamerVideoBin *aMe)
+{
+  // TODO: Obsolete should not be called any more
+
+  gint   pixel_aspect[2] = {0, 0};
+
+  NS_GSTREAMER_LOG(("<<FakeSinkPreRoll>>\n"));
+
+  GstCaps* caps = gst_pad_get_negotiated_caps(aPad);
+  if (caps) {
+    GstStructure* structure = gst_caps_get_structure(caps, 0);
+    gst_structure_get_int(structure, "width", &aMe->mWidth);
+    gst_structure_get_int(structure, "height", &aMe->mHeight);
+
+    // If the video has a size to big or too small, abort decoding
+    if (MAX_VIDEO_WIDTH < aMe->mWidth ||
+        MAX_VIDEO_HEIGHT < aMe->mHeight ||
+        1 > aMe->mWidth  ||
+        1 > aMe->mHeight) {
+      aMe->mWidth = 0;
+      aMe->mHeight = 0;
+      // TODO: Add some proper handling here
+      NS_GSTREAMER_LOG(("Video size failed sanity check"));
+      return;
+    }
+
+    gst_structure_get_fraction(structure,
+                               "pixel-aspect-ratio",
+                               &pixel_aspect[0],
+                               &pixel_aspect[1]);
+    aMe->mAspect = (pixel_aspect[0] == 0) ?
+      ((gdouble)aMe->mWidth/(gdouble)aMe->mHeight) :
+      ((gdouble)pixel_aspect[0] /
+       (gdouble)pixel_aspect[1] *
+       (gdouble)aMe->mWidth/(gdouble)aMe->mHeight);
+    gst_structure_get_fraction(structure,
+                               "framerate",
+                               &pixel_aspect[0],
+                               &pixel_aspect[1]);
+    aMe->mFramerate = (gdouble)pixel_aspect[0]/(gdouble)pixel_aspect[1];
+
+    //Transfer first frame of the video
+    FakeSinkHandoff(nsnull, aBuffer, aPad, aMe);
+  } else {
+    NS_GSTREAMER_LOG(("Could not get caps"));
+  }
+
+  // Tell the element that the meta data has been loaded
+  aMe->GetElementWrapper()->MetadataLoaded();
+  // Tell the element that the first frame has been loaded
+  aMe->GetElementWrapper()->FirstFrameLoaded(PR_FALSE);
+  // Tell the statemachine that the preroll is complete
+  aMe->mVideoPrerollComplete->VideoPrerollComplete();
+}
+
+void nsGStreamerVideoBin::FakeSinkHandoff(void *,
+                                          GstBuffer *aBuffer,
+                                          GstPad * /*pad*/,
+                                          nsGStreamerVideoBin * aMe)
+{
+  // TODO: Obsolete should not be called any more
+  NS_GSTREAMER_LOG(("<FAKE SINK HANDOFF>"));
+  NS_GSTREAMER_LOG(("."));
+
+  // Tell who ever is concerned that the time has been updated
+  // (we are now further ahead than we used to be
+  aMe->GetElementWrapper()->DispatchTimeUpdated();
+
+  // Protect access to mIsScreenPreviouslyInvalidated
+  g_mutex_lock(aMe->mScreenInvalidMutex);
+
+  // TODO: MikeK - can we avoid this copy of data?
+  // Copy new frame
+  unsigned char *transp = new unsigned char [aMe->mWidth * aMe->mHeight * 4];
+  if (transp) {
+    memcpy(transp, GST_BUFFER_DATA(aBuffer), aMe->mWidth * aMe->mHeight * 4);
+    aMe->GetStreamerDecoder()->SetRGBData(aMe->mWidth,
+                                          aMe->mHeight,
+                                          aMe->mFramerate,
+                                          1.0 /* mAspect */,
+                                          transp);
+  }
+
+  // Check if screen has been invalidated
+  if (aMe->mIsScreenPreviouslyInvalidated) {
+    // Screen needs to be invalidated, but hasn't
+    aMe->mIsScreenPreviouslyInvalidated = PR_FALSE;
+
+    // If it has been invalidated, it's time for a new invalidation
+    // (as we have a new frame)
+    nsCOMPtr<nsIRunnable> event =
+      NS_NEW_RUNNABLE_METHOD(nsGStreamerDecoder,
+                             aMe->GetStreamerDecoder(),
+                             nsGStreamerDecoder::ForwardInvalidate);
+
+    NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+  }
+
+  // Now wait for the invalidation to be picked up
+#if 0
+  // Our timeout value is 1 s  -
+  // after this time we will allow the next frame to be decoded
+  GTimeVal waitTime;
+  g_get_current_time(&waitTime);
+  g_time_val_add(&waitTime, 100*1000); // cur time + 0.1s
+
+  // Wait for data (will unlock mScreenInvalidMutex while it wait)
+  g_cond_timed_wait(aMe->mScreenInvalidatedCond,
+                    aMe->mScreenInvalidMutex,
+                    &waitTime);
+#endif
+  // Unlock the mutex again
+  g_mutex_unlock(aMe->mScreenInvalidMutex);
+}
+
+void nsGStreamerVideoBin::SetRGBData( PRInt32 aWidth,
+                                      PRInt32 aHeight,
+                                      float aFramerate,
+                                      float aAspectRatio,
+                                      unsigned char* aRGBBuffer)
+{
+  PRBool firstFrame =    0   == mWidth
+                      && 0   == mHeight
+                      && 0.0 == mAspect
+                      && 0.0 == mFramerate;
+
+
+  // Check if this is the first frame
+  if (firstFrame) {
+    // Check if we got sane parameters
+    if (   MAX_VIDEO_WIDTH < aWidth
+        || MAX_VIDEO_HEIGHT < aHeight
+        || 1 > aWidth
+        || 1 > aHeight)
+    {
+      NS_GSTREAMER_LOG(("---- ERROR: Bailing out\n"));
+      // TODO: Indicate some error, and enable code to handle the missing data
+      return;
+    }
+
+    mWidth = aWidth;
+    mHeight = aHeight;
+    mAspect = aAspectRatio;
+    mFramerate = aFramerate;
+  }
+
+//  NS_GSTREAMER_LOG(("."));
+
+  // Tell who ever is concerned that the time has been updated
+  // (we are now further ahead than we used to be
+  GetElementWrapper()->DispatchTimeUpdated();
+
+  NS_GSTREAMER_LOG(("-"));
+
+  // Protect access to mIsScreenPreviouslyInvalidated
+  g_mutex_lock(mScreenInvalidMutex);
+
+// Enable below to take copy of data, disable to use original buffer
+#if 0
+  unsigned char *transp = new unsigned char [mWidth * mHeight * 4];
+  if (transp) {
+    memcpy(transp, aRGBBuffer, mWidth * mHeight * 4);
+    GetStreamerDecoder()->SetRGBData(mWidth,
+                                     mHeight,
+                                     mFramerate,
+                                     1.0 /* mAspect */,
+                                     transp);
+  }
+#else
+
+  sSetRGBCalled++;
+
+  // Transfer data
+  GetStreamerDecoder()->SetRGBData(mWidth,
+                                   mHeight,
+                                   mFramerate,
+                                   1.0 /* mAspect */,
+                                   aRGBBuffer);
+#endif
+// Check if screen has been invalidated
+  /*  if (mIsScreenPreviouslyInvalidated) */ {
+    // Screen needs to be invalidated, but hasn't
+    mIsScreenPreviouslyInvalidated = PR_FALSE;
+    NS_GSTREAMER_LOG(("."));
+
+    // If it has been invalidated, it's time for a new invalidation
+    // (as we have a new frame)
+    nsCOMPtr<nsIRunnable> event =
+      NS_NEW_RUNNABLE_METHOD(nsGStreamerDecoder,
+                             GetStreamerDecoder(),
+                             nsGStreamerDecoder::ForwardInvalidate);
+
+    NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
+  }
+
+  // Now wait for the invalidation to be picked up
+#if 0
+  // Our timeout value is 1 s  -
+  // after this time we will allow the next frame to be decoded
+  GTimeVal waitTime;
+  g_get_current_time(&waitTime);
+  g_time_val_add(&waitTime, 1000*1000); // cur time + 1s
+
+  // Wait for data (will unlock mScreenInvalidMutex while it wait)
+  g_cond_timed_wait(mScreenInvalidatedCond,
+                    mScreenInvalidMutex,
+                    &waitTime);
+#endif
+  // Unlock the mutex again
+  g_mutex_unlock(mScreenInvalidMutex);
+
+  if (firstFrame) {
+    // Tell the element that the first frame has been loaded
+    GetElementWrapper()->FirstFrameLoaded(PR_FALSE);
+    // Tell the statemachine that the preroll is complete
+    mVideoPrerollComplete->VideoPrerollComplete();
+    // Tell the element that the meta data has been loaded
+    GetElementWrapper()->MetadataLoaded();
+  }
+}
+
Index: mozilla/content/media/gstreamer/nsGStreamerVideoBin.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerVideoBin.h
@@ -0,0 +1,167 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsGStreamerVideoBin_h__
+#define nsgstreamervideobin_h__
+
+#include "gst/gst.h"
+#include "nsGStreamerDecoder.h"
+#include "nsGStreamerElementWrapper.h"
+#include "nsGStreamerScreenInvalidatedInterface.h"
+#include "nsGStreamerVideoSinkInterface.h"
+#include "nsGStreamerVideoPrerollCompleteInterface.h"
+
+
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that takes care of the video sink bin
+
+class nsGStreamerVideoBin : public nsGStreamerScreenInvalidatedInterface,
+                            private nsGStreamerVideoSinkInterface
+{
+  public:
+    // Constructor
+    nsGStreamerVideoBin();
+
+    // Destructor
+    ~nsGStreamerVideoBin();
+
+    // Function to create the decode bin
+    PRBool Create(
+      nsGStreamerVideoPrerollCompleteInterface *aVideoPrerollComplete);
+
+    // Releases all resources allocated
+    void Destroy();
+
+    // Links the video sink with the pad given in the paramters
+    // Returns PR_TRUE  : if the link succedded
+    // Returns PR_FALSE : if the link failed
+    PRBool Link(GstPad *aSrc);
+
+    // Easy way to get the element pointer
+    operator GstElement *();
+
+    // Set the element wrapper
+    void SetElementWrapper(nsGStreamerElementWrapper *aElementWrapper);
+
+    void SetStreamerDecoder(nsGStreamerDecoder *aStreamerDecoder);
+
+    // Call back when screen has actually been invalidated
+    virtual void ScreenHasBeenInvalidated();
+
+  private:
+    // Bin to collect the video elements
+    GstBin *mVideoBin;
+
+    // Color converter element (transform between color spaces)
+    GstElement *mColorConverter;
+
+    // Fake sink to pull data out of the pipeline
+    GstElement *mFakeSink;
+
+    // Vide sink element to bring video frames from GStreamer and back into
+    // our code base
+    GstElement *mVideoSink;
+
+    // Video buffer (to keep everything in sync)
+    GstElement *mVideoBuffer;
+
+    //Takes care of element com.
+    nsRefPtr<nsGStreamerElementWrapper> mElementWrapper;
+
+    // Pointer back to the streamer decoder,
+    // Note this is not ref-counted as it points to an object
+    // that this class is a member of
+    nsGStreamerDecoder *mStreamerDecoder;
+
+    // Holds the interface
+    // to call when video preroll is complete
+    nsGStreamerVideoPrerollCompleteInterface *mVideoPrerollComplete;
+
+    // The following are done to prevent decoding of more frames than we need
+
+    // Set to false when a new frame is decoded,
+    // true when screen has been invalidated
+    PRPackedBool mIsScreenPreviouslyInvalidated;
+
+    // Mutex to control the access to mIsScreenPreviouslyInvalidated
+    GMutex *mScreenInvalidMutex;
+
+    // Condition that is set when screen has been invalidated
+    GCond *mScreenInvalidatedCond;
+
+
+    // Width of the video
+    gint mWidth;
+
+    // Height of the video
+    gint mHeight;
+
+    // Aspect ratio of the video
+    gdouble mAspect;
+
+    // Framerate of the video
+    gdouble mFramerate;
+
+    // Function to get the element wrapper
+    nsGStreamerElementWrapper *GetElementWrapper() {return mElementWrapper;};
+
+    // Function to get the streamer decoder
+    nsGStreamerDecoder *GetStreamerDecoder() {return mStreamerDecoder;};
+
+    // Callbacks
+    static void FakeSinkPreRoll(void *,
+                                GstBuffer *buffer,
+                                GstPad *aPad,
+                                nsGStreamerVideoBin *aMe);
+
+    static void FakeSinkHandoff(void *,
+                                GstBuffer *buffer,
+                                GstPad *pad,
+                                nsGStreamerVideoBin *aMe);
+
+
+    virtual void SetRGBData(PRInt32 aWidth,
+                            PRInt32 aHeight,
+                            float aFramerate,
+                            float aAspectRatio,
+                            unsigned char* aRGBBuffer);
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerVideoPrerollCompleteInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerVideoPrerollCompleteInterface.h
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+#ifndef nsGStreamerVideoPrerollCompleteInterface_h__
+#define nsGStreamerVideoPrerollCompleteInterface_h__
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that holds the interface that should be called
+// when the preroll has been done
+class nsGStreamerVideoPrerollCompleteInterface
+{
+  public:
+    // Call when preroll is complete for a video stream
+    virtual void VideoPrerollComplete() = 0;
+};
+
+#endif
Index: mozilla/content/media/gstreamer/nsGStreamerVideoSinkInterface.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGStreamerVideoSinkInterface.h
@@ -0,0 +1,58 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsGStreamerVideoSinkInterface_h___
+#define nsGStreamerVideoSinkInterface_h___
+
+#include<prtypes.h>
+
+////////////////////////////////////////////////////////////////////////////////
+// Class that holds the interface that is called by the video sink element
+class nsGStreamerVideoSinkInterface
+{
+  public:
+    // Called when a frame is decoded
+    virtual void SetRGBData(PRInt32 aWidth,
+                            PRInt32 aHeight,
+                            float aFramerate,
+                            float aAspectRatio,
+                            unsigned char* aRGBBuffer) = 0;
+};
+
+#endif
+
Index: mozilla/content/media/gstreamer/nsGstStreamSrc.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGstStreamSrc.cpp
@@ -0,0 +1,430 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#include "nsGStreamerConfig.h"
+#include "nsGStreamerLog.h"
+#include "nsGstStreamSrc.h"
+
+////////////////////////////////////////////////////////////////////////////////
+//                                                                            //
+// WARNING:                                                                   //
+//                                                                            //
+//   In this file you will see references the NULL instead of nsnull when we  //
+//   are dealing with var-arg calls to the GStreamer libs - this is           //
+//   intentional, and not an error! If you change them it will be an error!   //
+////////////////////////////////////////////////////////////////////////////////
+
+
+// This strange #if is due to GStreamer code and the compiler sometimes need a ;
+// at the end, and sometimes not, depending on the compiler flags
+// See: http://bugzilla.gnome.org/show_bug.cgi?id=589173 for the corresponding
+// GStreamer bug
+#if (!defined(G_HAVE_GNUC_VARARGS) && !defined(G_HAVE_ISO_VARARGS)) || \
+     !defined(GST_DISABLE_GST_DEBUG)
+GST_DEBUG_CATEGORY_STATIC(streamsrc_debug);
+#else
+GST_DEBUG_CATEGORY_STATIC(streamsrc_debug);
+#endif
+
+#define GST_CAT_DEFAULT streamsrc_debug
+
+static const GstElementDetails nsgst_stream_src_details =
+    GST_ELEMENT_DETAILS("Necko stream source",
+    "Source/Network",
+    "Receive data as from a stream",
+    "Mike Kristoffersen <mkristoffersen at mozilla dot com>");
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+// We have properties to store the channel,
+// and to get the streamer interface back
+
+enum
+{
+  // Unused
+  NS_GSTREAM_PROP_0,
+  // Sets the media stream
+  NS_GSTREAM_PROP_MEDIA_STREAM,
+  // Sets the stream status interface
+  NS_GSTREAM_PROP_STREAM_STATUS
+};
+
+// This macro can provoke link errors, if this happens to you, then try to touch
+// this file and recompile
+// See: https://bugzilla.mozilla.org/show_bug.cgi?id=497411
+GST_BOILERPLATE(nsGstStreamSrc, nsgst_stream_src, GstPushSrc,
+    GST_TYPE_PUSH_SRC)
+
+// NOTE: Note naming convention below is from GStreamer land
+static void nsgst_stream_src_finalize(GObject * gobject);
+
+static GstFlowReturn nsgst_stream_src_create(GstPushSrc * psrc,
+                                             GstBuffer ** outbuf);
+static gboolean nsgst_stream_src_stop(GstBaseSrc * bsrc);
+static gboolean nsgst_stream_src_start(GstBaseSrc * bsrc);
+static gboolean nsgst_stream_src_unlock(GstBaseSrc * bsrc);
+
+static void nsgst_stream_src_set_property(GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void nsgst_stream_src_get_property(GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+// Function to register our source plug-in - (element)
+gboolean nsgst_stream_src_plugin_init(GstPlugin *plugin)
+{
+  return gst_element_register(plugin, "nsGStreamSource",
+                              GST_RANK_NONE,
+                              nsGST_TYPE_STREAM_SRC);
+}
+
+// Function to initialize class and child class properties when a
+// child class is created
+static void nsgst_stream_src_base_init(gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS(g_class);
+
+  gst_element_class_add_pad_template(element_class,
+    gst_static_pad_template_get(&src_template));
+
+  gst_element_class_set_details(element_class, &nsgst_stream_src_details);
+}
+
+// Only called once to initialize/setup the class with signals used, arguments
+// and virtual functions and to setup any global state
+static void nsgst_stream_src_class_init(nsGstStreamSrcClass *me)
+{
+  NS_GSTREAMER_LOG(("*** nsgst_stream_src_class_init called \n"));
+
+  GObjectClass *gobject_class;
+  GstBaseSrcClass *gstbasesrc_class;
+  GstPushSrcClass *gstpush_src_class;
+
+  gobject_class = (GObjectClass *) me;
+  gstbasesrc_class = (GstBaseSrcClass *) me;
+  gstpush_src_class = (GstPushSrcClass *) me;
+
+  gobject_class->set_property = nsgst_stream_src_set_property;
+  gobject_class->get_property = nsgst_stream_src_get_property;
+  gobject_class->finalize = nsgst_stream_src_finalize;
+
+  // Setup properties
+
+  // Setup Channel property
+  GParamSpec* channelProperty = g_param_spec_pointer(
+    // Canonical name
+    "MediaStream",
+    // Nick name (short form of the canonical name)
+    "mediastream",
+    // Long description for humans
+    "The media stream, stream data can be read from",
+    // Flags telling this is only for writing and that the strings in the first
+    // 3 parameters are const, and won't be modified
+    // The explicit type cast is due to C++ not being designed
+    // for doing binary operation on enumerations
+    (GParamFlags)(G_PARAM_WRITABLE |
+                  G_PARAM_STATIC_NAME |
+                  G_PARAM_STATIC_NICK |
+                  G_PARAM_STATIC_BLURB));
+
+  if (channelProperty) {
+    g_object_class_install_property(gobject_class,
+                                    NS_GSTREAM_PROP_MEDIA_STREAM,
+                                    // The property to install
+                                    channelProperty);
+  }
+
+  // Setup Channel property
+  GParamSpec* streamStatusProperty = g_param_spec_pointer(
+    // Canonical name
+    "StatusProperty",
+    // Nick name (short form of the canonical name)
+    "statusprop",
+    // Long description for humans
+    "The interface that should be informed about stream events",
+    // Flags telling this is only for writing and the strings in the first
+    // 3 parameters are const, and won't be modified
+    // The explicit type cast is due to C++ not being designed
+    // for doing binary operation on enumerations
+    (GParamFlags)(G_PARAM_WRITABLE |
+                  G_PARAM_STATIC_NAME |
+                  G_PARAM_STATIC_NICK |
+                  G_PARAM_STATIC_BLURB));
+
+  if (streamStatusProperty) {
+    g_object_class_install_property(gobject_class,
+                                    NS_GSTREAM_PROP_STREAM_STATUS,
+                                    // The property to install
+                                    streamStatusProperty);
+  }
+
+  // Save pointer to base class start function
+  me->start = gstbasesrc_class->start;
+  // Set our start function
+  gstbasesrc_class->start = nsgst_stream_src_start;
+  // Save pointer to base class stop function
+  me->stop = gstbasesrc_class->stop;
+  // Set our stop function
+  gstbasesrc_class->stop = nsgst_stream_src_stop;
+  gstbasesrc_class->unlock = nsgst_stream_src_unlock;
+
+  gstpush_src_class->create = nsgst_stream_src_create;
+
+  GST_DEBUG_CATEGORY_INIT(streamsrc_debug, "streamsrc", 0,
+    "nsGStreamer streame source");
+}
+
+// Init function to initialize a specific instance of this type
+static void
+nsgst_stream_src_init(nsGstStreamSrc * aMe, nsGstStreamSrcClass * g_class)
+{
+
+  // Set default values in the struct "me"
+  // me->istream = nsnull;
+  aMe->mCaps = nsnull;
+  // No source class yet
+  aMe->mSrcStream = nsnull;
+  // We default to read from the beginning of the stream
+  aMe->mOffsetOfNextRead = 0;
+  aMe->mStreamStatus = nsnull;
+
+  // Set live to TRUE if it doesn't make sense to "cache" the stream
+  // - e.g. live view from camera
+  // as:  gst_base_src_set_live(GST_BASE_SRC(me), TRUE);
+
+  // Clear our open flag to remember that we aren't in the open state
+  GST_OBJECT_FLAG_UNSET(aMe, nsGST_STREAM_SRC_OPEN);
+}
+
+static void nsgst_stream_src_finalize(GObject * gobject)
+{
+  // Typecast the object to one of the right type
+  //  nsGstStreamSrc *me = nsGST_STREAM_SRC(gobject);
+
+  // Cleanup allocated objects etc...
+  // g_free(me->myString)
+
+  // Call the parent class so it can do it's cleanup
+  G_OBJECT_CLASS(parent_class)->finalize(gobject);
+}
+
+// Create function used for filling a buffer (generate data)
+static GstFlowReturn
+nsgst_stream_src_create(GstPushSrc * psrc, GstBuffer ** outbuf)
+{
+  // pointer to our data struct
+  nsGstStreamSrc *me;
+
+  // do type cast
+  me = nsGST_STREAM_SRC(psrc);
+
+  // Check if we have an open connection that can feed us data
+  if (!GST_OBJECT_FLAG_IS_SET(me, nsGST_STREAM_SRC_OPEN)) {
+    // if not, return
+    GST_DEBUG_OBJECT(me, "connection closed, cannot read data");
+    return GST_FLOW_WRONG_STATE;
+  }
+
+  // Check that we got somewhere to read from
+  if (!me || !me->mSrcStream)  {
+    // if not, return
+    g_warning("If you get here, you probably forgot to set the media stream");
+    *outbuf = nsnull;
+    return GST_FLOW_ERROR;
+  }
+
+  // Create an output buffer
+  GstBuffer* gstBuffer =
+      gst_buffer_try_new_and_alloc(GST_BUFFER_READ_CHUNK_SIZE);
+
+  // Check that we got a buffer and that it's useful
+  if (!gstBuffer || !GST_BUFFER_DATA(gstBuffer)) {
+    // if not, return
+    g_warning("Not enough memory to continue loading stream");
+    return GST_FLOW_ERROR;
+  }
+
+  PRUint32 actuallyRead = 0;
+  PRUint32 remainsToBeRead = GST_BUFFER_READ_CHUNK_SIZE;
+  PRUint32 readSoFar = 0;
+
+  // While we have something to read
+  while (remainsToBeRead) {
+    // Try to fill the buffer
+    // TODO: Check for error return here (LOG output if on error)
+    me->mSrcStream->Read(((char*)GST_BUFFER_DATA(gstBuffer))+readSoFar,
+                          remainsToBeRead,
+                          &actuallyRead);
+    // Check if we are at EOF
+    if (!actuallyRead) {
+      break;
+    }
+    // Decrease the amount of data that remains to be read
+    remainsToBeRead -= actuallyRead;
+    readSoFar += actuallyRead;
+  }
+
+  // Check if we are at EOF and didn't read anything
+  if (!readSoFar) {
+    // Delete the buffer we got, to minimize memory leaks
+    // The below ref-unref calls are intentional for deleting
+    gst_buffer_ref(gstBuffer);
+    gst_buffer_unref(gstBuffer);
+    // Make sure we return a nsnull
+    *outbuf = nsnull;
+    // Signal EOF
+    if (me->mStreamStatus) {
+      me->mStreamStatus->EOFReached();
+    }
+
+    return GST_FLOW_UNEXPECTED;
+  }
+
+  // by logic we must actually have read some data, so send that back
+
+  // Position of first byte in buffer
+  GST_BUFFER_OFFSET(gstBuffer) = me->mOffsetOfNextRead;
+  // Size of the buffer (might be bigger than what we have data for,
+  // if we reached EOF)
+  GST_BUFFER_SIZE(gstBuffer) = readSoFar;
+  // Send this buffer back
+  *outbuf = gstBuffer;
+  // Remember where we will read from
+  me->mOffsetOfNextRead += readSoFar;
+
+  // Even we hit EOF, this buffer is still good
+  return  GST_FLOW_OK;
+}
+
+// Used to set the properties of the element
+static void nsgst_stream_src_set_property(GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+//  NS_GSTREAMER_LOG(("****nsgst_stream_src_set_property called\n"));
+  nsGstStreamSrc *me = nsGST_STREAM_SRC(object);
+
+  switch (prop_id) {
+    case NS_GSTREAM_PROP_MEDIA_STREAM:
+      me->mSrcStream = (nsMediaStream*)g_value_get_pointer(value);
+      break;
+    case NS_GSTREAM_PROP_STREAM_STATUS:
+      me->mStreamStatus =
+        (nsGStreamerStreamStatusInterface*)g_value_get_pointer(value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
+      break;
+  }
+}
+
+// Used to get the properties of the element
+static void
+nsgst_stream_src_get_property(GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  // We don't have any properties that can be gotten
+  G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
+}
+
+// Start the data transfer
+static gboolean nsgst_stream_src_start(GstBaseSrc *bsrc)
+{
+  //  NS_GSTREAMER_LOG(("\n***Stream src start***\n"));
+  // pointer to the data for this object
+  nsGstStreamSrc *me = nsGST_STREAM_SRC(bsrc);
+  // Pointer to this class
+  nsGstStreamSrcClass *meClass = nsGST_BASE_SRC_GET_CLASS(bsrc);
+
+  // Return value of the base class start function
+  gboolean ret = meClass->start ? meClass->start(bsrc) : true;
+
+  // When we are ready to start, then set the open flag
+  GST_OBJECT_FLAG_SET(me, nsGST_STREAM_SRC_OPEN);
+
+  return ret;
+}
+
+//Stop the data transfer, and return to the initial state
+static gboolean
+nsgst_stream_src_stop(GstBaseSrc * bsrc)
+{
+//  NS_GSTREAMER_LOG(("\n***Stream src stop***\n"));
+
+  // Typecast the incoming pointer to the type
+  // of the data pointer for this object
+  nsGstStreamSrc *me = nsGST_STREAM_SRC(bsrc);
+
+  // Pointer to this class
+  nsGstStreamSrcClass *meClass = nsGST_BASE_SRC_GET_CLASS(bsrc);
+
+
+  // Kill our reference to the source stream
+  if (me->mSrcStream) {
+    me->mSrcStream = nsnull;
+  }
+
+  // Our caps are no longer valid
+  me->mCaps_received = PR_FALSE;
+
+  // Check if we had some caps
+  if (me->mCaps) {
+    // if we did then unref them
+    gst_caps_unref(me->mCaps);
+    // and forget about them
+    me->mCaps = nsnull;
+  }
+
+  // clear our flag that indicates that we have an open connection
+  GST_OBJECT_FLAG_UNSET(me, nsGST_STREAM_SRC_OPEN);
+
+  return meClass->stop ? meClass->stop(bsrc) : true;
+}
+
+// Will be called only between calls to start() and stop(),
+// hmmm what to do with this one???
+static gboolean
+nsgst_stream_src_unlock(GstBaseSrc * /* bsrc */)
+{
+//  nsGstStreamSrc *src = nsGST_STREAM_SRC(bsrc);
+
+  return true;
+}
+
Index: mozilla/content/media/gstreamer/nsGstStreamSrc.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGstStreamSrc.h
@@ -0,0 +1,120 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Chris Double <chris.double@double.co.nz>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsGstStreamSrc_h__
+#define nsGstStreamSrc_h__
+
+#include "gst/gst.h"
+#include "gst/base/gstpushsrc.h"
+#include "nsGStreamerStreamStatusInterface.h"
+#include "nsMediaStream.h"
+
+
+////////////////////////////////////////////////////////////////////////////////
+//Our GStreamer element is used to feed data into the pipeline
+
+typedef struct _nsGstStreamSrc nsGstStreamSrc;
+typedef struct _nsGstStreamSrcClass nsGstStreamSrcClass;
+
+G_BEGIN_DECLS
+
+#define nsGST_TYPE_STREAM_SRC \
+  (nsgst_stream_src_get_type())
+#define nsGST_STREAM_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj), nsGST_TYPE_STREAM_SRC, nsGstStreamSrc))
+#define nsGST_STREAM_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass), \
+   nsGST_TYPE_STREAM_SRC, \
+   nsGstStreamSrcClass))
+#define nsGST_IS_STREAM_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj), nsGST_TYPE_STREAM_SRC))
+#define nsGST_IS_STREAM_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass), nsGST_TYPE_STREAM_SRC))
+#define nsGST_BASE_SRC_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj), \
+   nsGST_TYPE_STREAM_SRC, \
+   nsGstStreamSrcClass))
+
+
+typedef enum {
+  nsGST_STREAM_SRC_OPEN       = (GST_ELEMENT_FLAG_LAST << 0),
+  nsGST_STREAM_SRC_FLAG_LAST  = (GST_ELEMENT_FLAG_LAST << 2)
+} nsGstStreamSrcFlags;
+
+// Structure to store the state of a given instance of this class, each instance
+// has its own copy of this struct
+struct _nsGstStreamSrc {
+  GstPushSrc element;
+
+  // Offset of the next read (e.g. current position)
+  guint64 mOffsetOfNextRead;
+
+  // Interface to communicate events about the stream
+  nsGStreamerStreamStatusInterface *mStreamStatus;
+
+  // Stream data should be read from (note: this object does not _own_ the media
+  // stream object
+  nsMediaStream* mSrcStream;
+
+  // The capabilities
+  GstCaps *mCaps;
+
+  // If we have received capabilities yet
+  gboolean mCaps_received;
+};
+
+// Only one instance of this struct per class, child classes have their own copy
+// so functions can be overwritten etc.; so it mostly contains function pointers
+struct _nsGstStreamSrcClass {
+  GstPushSrcClass parent_class;
+
+  /* start and stop processing, ideal for opening/closing the resource */
+  gboolean (*start)(GstBaseSrc *src);
+  gboolean (*stop)(GstBaseSrc *src);
+};
+
+GType nsgst_stream_src_get_type(void);
+
+// Function to initialise the plugin (and lets the linker pull the object code)
+gboolean nsgst_stream_src_plugin_init(GstPlugin *plugin);
+
+G_END_DECLS
+
+#endif
+
Index: mozilla/content/media/gstreamer/nsGstVideoSink.cpp
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGstVideoSink.cpp
@@ -0,0 +1,553 @@
+/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Kapil Trimbak Agrawal <kapil@mediamagictechnologies.com>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * SECTION:element-fennecvideosink
+ */
+
+#include <new>
+#include "gst/base/gstpushsrc.h"
+#include "gst/video/video.h"
+
+/* Object header */
+#include "nsGstVideoSink.h"
+
+/* Debugging category */
+#include "gst/gstinfo.h"
+
+// We need to different versions of the below, depending on the debug
+// mode gstreamer is in - as some times the ; at the end is needed
+// and sometimes it becomes an empty line with an ; which isn't allowed
+// by some of the compilers - like the one we use for meamo to the N810
+#if 0
+#ifdef GST_DISABLE_GST_DEBUG
+  GST_DEBUG_CATEGORY_EXTERN(gst_debug_fennecvideosink);
+#else
+  GST_DEBUG_CATEGORY_EXTERN(gst_debug_fennecvideosink);
+#endif
+#endif
+
+// We need to different versions of the below, depending on the debug
+// mode gstreamer is in - as some times the ; at the end is needed
+// and sometimes it becomes an empty line with an ; which isn't allowed
+// by some of the compilers - like the one we use for meamo to the N810
+#ifdef GST_DISABLE_GST_DEBUG
+  GST_DEBUG_CATEGORY_STATIC(gst_debug_fennecvideosink);
+#else
+  GST_DEBUG_CATEGORY_STATIC(gst_debug_fennecvideosink);
+#endif
+
+
+#define GST_CAT_DEFAULT gst_debug_fennecvideosink
+
+// Function to register our sink plug-in - (element)
+gboolean nsgst_fennecvideosink_plugin_init(GstPlugin *aPlugin)
+{
+  return gst_element_register(aPlugin,
+                              "gstFennecVideoSink",
+                              GST_RANK_NONE,
+                              GST_TYPE_FENNECVIDEOSINK);
+}
+
+static void gst_fennecvideosink_reset(GstFennecVideoSink* aFennecvideosink);
+
+/* ElementFactory information */
+static const GstElementDetails gst_fennecvideosink_details =
+GST_ELEMENT_DETAILS("Video sink",
+                    "Sink/Video",
+                    "videosink for firefox fennec",
+                    "Kapil Agrawal <kapil@mediamagictechnologies.com>");
+
+enum
+{
+  PROP_0,
+  PROP_VIDEO_SINK_INTERFACE
+};
+
+static GstVideoSinkClass *parent_class = NULL;
+
+
+/* ============================================================= */
+/*                                                               */
+/*                       Private Methods                         */
+/*                                                               */
+/* ============================================================= */
+
+/* This function puts a GstBuffer on a GstFennecVideoSink's window */
+static gboolean gst_fennecvideosink_put(GstFennecVideoSink* aFennecvideosink,
+                                        GstBuffer* aFennecvideo)
+{
+  g_return_val_if_fail(GST_IS_FENNECVIDEOSINK(aFennecvideosink), FALSE);
+
+  /* We take the mFlowLock. If expose is in there we don't want to run
+     concurrently from the data flow thread */
+  g_mutex_lock(aFennecvideosink->mFlowLock);
+
+  if (aFennecvideo) {
+    GST_LOG_OBJECT(aFennecvideosink,
+                   "XPutImage of size %d x %d",
+                   GST_VIDEO_SINK_WIDTH(aFennecvideosink),
+                   GST_VIDEO_SINK_HEIGHT(aFennecvideosink));
+
+    if (aFennecvideosink->mVideoSinkInterface) {
+      aFennecvideosink->mVideoSinkInterface->SetRGBData(
+          GST_VIDEO_SINK_WIDTH(aFennecvideosink),
+          GST_VIDEO_SINK_HEIGHT(aFennecvideosink),
+          aFennecvideosink->mFpsN / aFennecvideosink->mFpsD,
+          1.0,
+          aFennecvideosink->mNextFrameData);
+      // After the data has been handed off above - it is "dead" don't touch it
+      // not even by mistake
+      aFennecvideosink->mNextFrameData = NULL;
+      gst_buffer_ref(aFennecvideo);
+      gst_buffer_unref(aFennecvideo);
+    }
+  }
+
+  g_mutex_unlock(aFennecvideosink->mFlowLock);
+
+  return TRUE;
+}
+
+/* Element stuff */
+
+static GstCaps *gst_fennecvideosink_getcaps(GstBaseSink* aBsink)
+{
+  GstFennecVideoSink *fennecvideosink;
+  GstCaps *caps;
+  int i;
+
+  fennecvideosink = GST_FENNECVIDEOSINK(aBsink);
+
+  /* get a template copy and add the pixel aspect ratio */
+  caps = gst_caps_copy(
+            gst_pad_get_pad_template_caps(
+                GST_BASE_SINK(fennecvideosink)->sinkpad));
+
+  for (i = 0; i < gst_caps_get_size(caps); ++i) {
+    GstStructure *structure = gst_caps_get_structure(caps, i);
+  }
+
+  return caps;
+}
+
+static gboolean gst_fennecvideosink_setcaps(GstBaseSink* aBsink, GstCaps* aCaps)
+{
+  GstFennecVideoSink* fennecvideosink;
+  gboolean ret = TRUE;
+  GstStructure* structure;
+  const GValue* par;
+  gint new_width, new_height;
+  const GValue* fps;
+
+  fennecvideosink = GST_FENNECVIDEOSINK(aBsink);
+
+  structure = gst_caps_get_structure(aCaps, 0);
+
+  ret &= gst_structure_get_int(structure, "width", &new_width);
+  ret &= gst_structure_get_int(structure, "height", &new_height);
+  fps = gst_structure_get_value(structure, "framerate");
+  ret &= (fps != NULL);
+  if (!ret) {
+    return FALSE;
+  }
+
+  /* if the caps contain pixel-aspect-ratio, they have to match ours,
+   * otherwise linking should fail */
+  par = gst_structure_get_value(structure, "pixel-aspect-ratio");
+
+  GST_VIDEO_SINK_WIDTH(fennecvideosink) = new_width;
+  GST_VIDEO_SINK_HEIGHT(fennecvideosink) = new_height;
+  fennecvideosink->mFpsN = gst_value_get_fraction_numerator(fps);
+  fennecvideosink->mFpsD = gst_value_get_fraction_denominator(fps);
+
+  if (GST_VIDEO_SINK_WIDTH(fennecvideosink) <= 0 ||
+      GST_VIDEO_SINK_HEIGHT(fennecvideosink) <= 0) {
+    GST_ELEMENT_ERROR(fennecvideosink, CORE, NEGOTIATION, (NULL),
+        ("Invalid image size."));
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static GstStateChangeReturn gst_fennecvideosink_change_state(
+                                  GstElement* aElement,
+                                  GstStateChange aTransition)
+{
+  GstFennecVideoSink* fennecvideosink = GST_FENNECVIDEOSINK(aElement);
+
+  GstStateChangeReturn ret = GST_ELEMENT_CLASS(parent_class)->
+                                           change_state(aElement, aTransition);
+
+  switch (aTransition) {
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      fennecvideosink->mFpsN = 0;
+      fennecvideosink->mFpsD = 1;
+      GST_VIDEO_SINK_WIDTH(fennecvideosink) = 0;
+      GST_VIDEO_SINK_HEIGHT(fennecvideosink) = 0;
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      gst_fennecvideosink_reset(fennecvideosink);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static void gst_fennecvideosink_get_times(GstBaseSink* aBsink,
+                                          GstBuffer* aBuf,
+                                          GstClockTime* aStart,
+                                          GstClockTime* aEnd)
+{
+  GstFennecVideoSink* fennecvideosink;
+
+  fennecvideosink = GST_FENNECVIDEOSINK(aBsink);
+
+  if (GST_BUFFER_TIMESTAMP_IS_VALID(aBuf)) {
+    *aStart = GST_BUFFER_TIMESTAMP(aBuf);
+    if (GST_BUFFER_DURATION_IS_VALID(aBuf)) {
+      *aEnd = *aStart + GST_BUFFER_DURATION(aBuf);
+    } else {
+      if (fennecvideosink->mFpsN > 0) {
+        *aEnd = *aStart +
+            gst_util_uint64_scale_int(GST_SECOND, fennecvideosink->mFpsD,
+            fennecvideosink->mFpsN);
+      }
+    }
+  }
+}
+
+static GstFlowReturn gst_fennecvideosink_preroll_frame(GstBaseSink* aBsink,
+                                                       GstBuffer* aBuf)
+{
+  g_return_val_if_fail(aBuf != NULL, GST_FLOW_ERROR);
+
+  GstFennecVideoSink* fennecvideosink = GST_FENNECVIDEOSINK(aBsink);
+
+  /* If this buffer has been allocated using our buffer management we simply
+     put the fennecvideo which is in the PRIVATE pointer */
+  GST_LOG_OBJECT(fennecvideosink, "buffer from our pool, writing directly");
+
+  if (!gst_fennecvideosink_put(fennecvideosink, aBuf)) {
+    GST_WARNING_OBJECT(fennecvideosink, "could not output image - no window");
+    return GST_FLOW_ERROR;
+  }
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn gst_fennecvideosink_show_frame(GstBaseSink* aBsink,
+                                                    GstBuffer* aBuf)
+{
+  GstFennecVideoSink* fennecvideosink;
+
+  g_return_val_if_fail(aBuf != NULL, GST_FLOW_ERROR);
+
+  fennecvideosink = GST_FENNECVIDEOSINK(aBsink);
+
+  /* If this buffer has been allocated using our buffer management we simply
+     put the fennecvideo which is in the PRIVATE pointer */
+  GST_LOG_OBJECT(fennecvideosink, "buffer from our pool, writing directly");
+  if (gst_fennecvideosink_put(fennecvideosink, aBuf)) {
+    return GST_FLOW_OK;
+  }
+
+  /* No Window available to put our image into */
+  GST_WARNING_OBJECT(fennecvideosink, "could not output image - no window");
+  return GST_FLOW_ERROR;
+}
+
+/* Buffer management
+ *
+ * The buffer_alloc function must either return a buffer with given size and
+ * caps or create a buffer with different caps attached to the buffer. This
+ * last option is called reverse negotiation, ie, where the sink suggests a
+ * different format from the upstream peer.
+ *
+ * We try to do reverse negotiation when our geometry changes and we like a
+ * resized buffer.
+ */
+static GstFlowReturn gst_fennecvideosink_buffer_alloc(GstBaseSink* aBsink,
+                                                      guint64 aOffset,
+                                                      guint aSize,
+                                                      GstCaps* aCaps,
+                                                      GstBuffer** aBuf)
+{
+  GstFennecVideoSink* fennecvideosink;
+  GstBuffer* fennecvideo = NULL;
+  GstStructure* structure = NULL;
+  GstCaps* alloc_caps;
+  gboolean alloc_unref = FALSE;
+  gint width, height;
+
+  fennecvideosink = GST_FENNECVIDEOSINK(aBsink);
+
+  GST_LOG_OBJECT(fennecvideosink,
+      "a buffer of %d bytes was requested with caps %" GST_PTR_FORMAT
+      " and offset %" G_GUINT64_FORMAT, aSize, aCaps, aOffset);
+
+  /* assume we're going to alloc what was requested, keep track of
+   * wheter we need to unref or not. When we suggest a new format
+   * upstream we will create a new caps that we need to unref. */
+  alloc_caps = aCaps;
+  alloc_unref = FALSE;
+
+  /* get struct to see what is requested */
+  structure = gst_caps_get_structure(aCaps, 0);
+
+  if (!gst_structure_get_int(structure, "width", &width) ||
+      !gst_structure_get_int(structure, "height", &height)) {
+    GST_WARNING_OBJECT(fennecvideosink,
+                       "invalid caps for buffer allocation %"
+                       GST_PTR_FORMAT,
+                       aCaps);
+    return GST_FLOW_NOT_NEGOTIATED;
+  }
+
+// The problem with having a "manual" allocation here is that the memory isn't
+// being released if we are skipping frames => memory leaks
+
+// Actually we might be able to do it this way if we "cheat" a little - we might
+// safly assume that if we havn't send to buffer to Fennec, then we can reuse it
+
+  /* creating a new one */
+  fennecvideo = gst_buffer_new();
+  /* Now we should have a fennecvideo, set appropriate caps on it */
+  if (fennecvideo) {
+    /* Make sure the buffer is cleared of any previously used flags */
+    gst_buffer_set_caps(fennecvideo, alloc_caps);
+    if (!fennecvideosink->mNextFrameData) {
+      fennecvideosink->mNextFrameData = new unsigned char [width * height * 4];
+
+      if (fennecvideosink->mNextFrameData == NULL) {
+        GST_WARNING("Unable to allocate data of size - %d",
+                    width * height * 4);
+        return GST_FLOW_ERROR;
+      }
+    }
+
+    gst_buffer_set_data(fennecvideo,
+                        fennecvideosink->mNextFrameData,
+                        width * height * 4);
+  }
+
+  /* could be our new reffed suggestion or the original unreffed caps */
+  if (alloc_unref) {
+    gst_caps_unref(alloc_caps);
+  }
+
+  *aBuf = fennecvideo;
+
+  return GST_FLOW_OK;
+}
+
+// Used to set the properties of the element
+static void gst_fennecvideosink_set_property(GObject* aObject,
+                                             guint aPropId,
+                                             const GValue* aValue,
+                                             GParamSpec* aPspec)
+{
+  GstFennecVideoSink* me = GST_FENNECVIDEOSINK(aObject);
+
+  switch (aPropId) {
+    case PROP_VIDEO_SINK_INTERFACE:
+      me->mVideoSinkInterface =
+        (nsGStreamerVideoSinkInterface*)g_value_get_pointer(aValue);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID(aObject, aPropId, aPspec);
+      break;
+  }
+}
+
+static void gst_fennecvideosink_reset(GstFennecVideoSink* aFennecvideosink)
+{
+  if (aFennecvideosink->mNextFrameData) {
+    delete [] aFennecvideosink->mNextFrameData;
+    aFennecvideosink->mNextFrameData = NULL;
+  }
+}
+
+static void gst_fennecvideosink_finalize(GObject* aObject)
+{
+  GstFennecVideoSink* fennecvideosink;
+
+  fennecvideosink = GST_FENNECVIDEOSINK(aObject);
+
+  gst_fennecvideosink_reset(fennecvideosink);
+
+  if (fennecvideosink->mFlowLock) {
+    g_mutex_free(fennecvideosink->mFlowLock);
+    fennecvideosink->mFlowLock = NULL;
+  }
+
+  G_OBJECT_CLASS(parent_class)->finalize(aObject);
+}
+
+static void gst_fennecvideosink_init(GstFennecVideoSink* aFennecvideosink)
+{
+  aFennecvideosink->mFpsN = 0;
+  aFennecvideosink->mFpsD = 1;
+  aFennecvideosink->mFlowLock = g_mutex_new();
+  aFennecvideosink->mVideoSinkInterface = NULL;
+  aFennecvideosink->mNextFrameData = NULL;
+}
+
+static void gst_fennecvideosink_base_init(gpointer aGClass)
+{
+  static GstStaticPadTemplate gst_fennecvideosink_sink_template_factory =
+  GST_STATIC_PAD_TEMPLATE("sink",
+      GST_PAD_SINK,
+      GST_PAD_ALWAYS,
+      GST_STATIC_CAPS(GST_VIDEO_CAPS_BGRx)
+      );
+
+  GstElementClass *element_class = GST_ELEMENT_CLASS(aGClass);
+
+  gst_element_class_set_details(element_class, &gst_fennecvideosink_details);
+
+  gst_element_class_add_pad_template(element_class,
+      gst_static_pad_template_get(&gst_fennecvideosink_sink_template_factory));
+}
+
+static void gst_fennecvideosink_class_init(GstFennecVideoSinkClass* aKlass)
+{
+  GObjectClass* gobject_class;
+  GstElementClass* gstelement_class;
+  GstBaseSinkClass* gstbasesink_class;
+
+  gobject_class = (GObjectClass*)aKlass;
+  gstelement_class = (GstElementClass*)aKlass;
+  gstbasesink_class = (GstBaseSinkClass*)aKlass;
+
+  parent_class = (GstVideoSinkClass*)g_type_class_peek_parent(aKlass);
+
+  gobject_class->finalize = gst_fennecvideosink_finalize;
+
+  gstelement_class->change_state = gst_fennecvideosink_change_state;
+
+  gstbasesink_class->get_caps =
+      GST_DEBUG_FUNCPTR(gst_fennecvideosink_getcaps);
+  gstbasesink_class->set_caps =
+      GST_DEBUG_FUNCPTR(gst_fennecvideosink_setcaps);
+  gstbasesink_class->buffer_alloc =
+      GST_DEBUG_FUNCPTR(gst_fennecvideosink_buffer_alloc);
+  gstbasesink_class->get_times =
+      GST_DEBUG_FUNCPTR(gst_fennecvideosink_get_times);
+  gstbasesink_class->preroll =
+      GST_DEBUG_FUNCPTR(gst_fennecvideosink_preroll_frame);
+  gstbasesink_class->render =
+      GST_DEBUG_FUNCPTR(gst_fennecvideosink_show_frame);
+
+  gobject_class->set_property = gst_fennecvideosink_set_property;
+
+  // Setup properties
+
+  // Setup Channel property
+  GParamSpec* channelProperty = g_param_spec_pointer(
+    // Canonical name
+    "VideoSinkInterface",
+    // Nick name (short form of the canonical name)
+    "videosinkinterface",
+    // Long description for humans
+    "Interface allowing communication out of the GStreamer world",
+    // Flags telling this is only for writing and that the strings in the first
+    // 3 parameters are const, and won't be modified
+    // The explicit type cast is due to C++ not being designed
+    // for doing binary operation on enumerations
+    (GParamFlags)(G_PARAM_WRITABLE |
+                  G_PARAM_STATIC_NAME |
+                  G_PARAM_STATIC_NICK |
+                  G_PARAM_STATIC_BLURB));
+
+  if (channelProperty) {
+    g_object_class_install_property(gobject_class,
+                                    PROP_VIDEO_SINK_INTERFACE,
+                                    // The property to install
+                                    channelProperty);
+  }
+}
+
+/* ============================================================= */
+/*                                                               */
+/*                       Public Methods                          */
+/*                                                               */
+/* ============================================================= */
+
+/* =========================================== */
+/*                                             */
+/*          Object typing & Creation           */
+/*                                             */
+/* =========================================== */
+
+GType gst_fennecvideosink_get_type(void)
+{
+  static GType fennecvideosink_type = 0;
+
+  if (!fennecvideosink_type) {
+    static const GTypeInfo fennecvideosink_info = {
+      sizeof(GstFennecVideoSinkClass),
+      gst_fennecvideosink_base_init,
+      NULL,
+      (GClassInitFunc) gst_fennecvideosink_class_init,
+      NULL,
+      NULL,
+      sizeof(GstFennecVideoSink),
+      0,
+      (GInstanceInitFunc) gst_fennecvideosink_init,
+    };
+
+    fennecvideosink_type = g_type_register_static(GST_TYPE_VIDEO_SINK,
+                                                  "GstFennecVideoSink",
+                                                  &fennecvideosink_info,
+                                                  (GTypeFlags)0);
+
+    /* TODO: This should really be moved!!!!! */
+    /* register type and create class in a more safe place instead of at
+     * runtime since the type registration and class creation is not
+     * threadsafe. */
+  }
+
+  return fennecvideosink_type;
+}
Index: mozilla/content/media/gstreamer/nsGstVideoSink.h
===================================================================
--- /dev/null
+++ mozilla/content/media/gstreamer/nsGstVideoSink.h
@@ -0,0 +1,113 @@
+/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: ML 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla code.
+ *
+ * The Initial Developer of the Original Code is the Mozilla Corporation.
+ * Portions created by the Initial Developer are Copyright (C) 2007
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *  Kapil Trimbak Agrawal <kapil@mediamagictechnologies.com>
+ *  Mike Kristoffersen <mkristoffersen@mozilla.com>
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/* NOTE: This file and the .cpp file are in GStreamer land, hence it's using
+         the GStreamer recomended types, and not the Mozilla ones */
+
+#ifndef nsGstVideoSink_h__
+#define nsGstVideoSink_h__
+
+#include "gst/video/gstvideosink.h"
+#include "math.h"
+#include "nsGStreamerVideoSinkInterface.h"
+#include "string.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_FENNECVIDEOSINK (gst_fennecvideosink_get_type())
+
+#define GST_FENNECVIDEOSINK(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), \
+                                  GST_TYPE_FENNECVIDEOSINK, \
+                                  GstFennecVideoSink))
+
+#define GST_FENNECVIDEOSINK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), \
+                                          GST_TYPE_FENNECVIDEOSINK, \
+                                          GstFennecVideoSinkClass))
+
+#define GST_IS_FENNECVIDEOSINK(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), \
+                                     GST_TYPE_FENNECVIDEOSINK))
+
+#define GST_IS_FENNECVIDEOSINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), \
+                                             GST_TYPE_FENNECVIDEOSINK))
+
+typedef struct _GstXContext GstXContext;
+typedef struct _GstXWindow GstXWindow;
+
+typedef struct _GstFennecVideoSink GstFennecVideoSink;
+typedef struct _GstFennecVideoSinkClass GstFennecVideoSinkClass;
+
+
+/**
+ * GstFennecVideoSink:
+ * @mFpsN: the framerate fraction numerator
+ * @mFpsD: the framerate fraction denominator
+ * @mFlowLock: used to protect data flow routines from external calls
+ * @handle_events: used to know if we should handle select XEvents or not
+ *
+ * The #GstFennecVideoSink data structure.
+ */
+struct _GstFennecVideoSink {
+  /* Our element stuff */
+  GstVideoSink videosink;
+
+  /* Framerate numerator and denominator */
+  gint mFpsN;
+  gint mFpsD;
+
+  GMutex *mFlowLock;
+
+  /* Pointer to interface used for communicate out of the GStreamer world */
+  nsGStreamerVideoSinkInterface *mVideoSinkInterface;
+
+  /* Pointer to hold the next frame that's going to be displayed */
+  guint8 *mNextFrameData;
+};
+
+struct _GstFennecVideoSinkClass {
+  GstVideoSinkClass parent_class;
+};
+
+GType gst_fennecvideosink_get_type(void);
+
+// Function to initialise the plugin (and lets the linker pull the object code)
+gboolean nsgst_fennecvideosink_plugin_init(GstPlugin* aPlugin);
+
+G_END_DECLS
+
+#endif
Index: mozilla/content/media/nsMediaDecoder.h
===================================================================
--- mozilla.orig/content/media/nsMediaDecoder.h
+++ mozilla/content/media/nsMediaDecoder.h
@@ -40,16 +40,17 @@
 
 #include "mozilla/XPCOM.h"
 
 #include "nsIPrincipal.h"
 #include "nsSize.h"
 #include "prlog.h"
 #include "gfxContext.h"
 #include "gfxRect.h"
+#include "nsIChannel.h"
 #include "nsITimer.h"
 
 class nsHTMLMediaElement;
 class nsMediaStream;
 class nsIStreamListener;
 
 // All methods of nsMediaDecoder must be called from the main thread only
 // with the exception of SetRGBData and GetStatistics, which can be
Index: mozilla/layout/base/nsPresContext.cpp
===================================================================
--- mozilla.orig/layout/base/nsPresContext.cpp
+++ mozilla/layout/base/nsPresContext.cpp
@@ -1941,19 +1941,23 @@ nsPresContext::UserFontSetUpdated()
   //      reuse of cached data even when no style rules have changed.
 
   PostRebuildAllStyleDataEvent(NS_STYLE_HINT_REFLOW);
 }
 
 void
 nsPresContext::FireDOMPaintEvent()
 {
+  // Clear the paint pending flag, as we are now doing it
+  mDOMPaintEventPending = PR_FALSE;
+
   nsPIDOMWindow* ourWindow = mDocument->GetWindow();
-  if (!ourWindow)
+  if (!ourWindow) {
     return;
+  }
 
   nsCOMPtr<nsIDOMEventTarget> dispatchTarget = do_QueryInterface(ourWindow);
   nsCOMPtr<nsIDOMEventTarget> eventTarget = dispatchTarget;
   if (!IsChrome()) {
     PRBool isCrossDocOnly = PR_TRUE;
     for (PRUint32 i = 0; i < mInvalidateRequests.mRequests.Length(); ++i) {
       if (!(mInvalidateRequests.mRequests[i].mFlags & nsIFrame::INVALIDATE_CROSS_DOC)) {
         isCrossDocOnly = PR_FALSE;
@@ -1961,16 +1965,18 @@ nsPresContext::FireDOMPaintEvent()
     }
     if (isCrossDocOnly) {
       // Don't tell the window about this event, it should not know that
       // something happened in a subdocument. Tell only the chrome event handler.
       // (Events sent to the window get propagated to the chrome event handler
       // automatically.)
       dispatchTarget = do_QueryInterface(ourWindow->GetChromeEventHandler());
       if (!dispatchTarget) {
+        // We didn't need to send an event, so pretend we never tried
+        ClearMozAfterPaintEvents();
         return;
       }
     }
   }
   // Events sent to the window get propagated to the chrome event handler
   // automatically.
   nsCOMPtr<nsIDOMEvent> event;
   // This will empty our list in case dispatching the event causes more damage
@@ -2022,39 +2028,51 @@ PRBool
 nsPresContext::MayHavePaintEventListener()
 {
   return ::MayHavePaintEventListener(mDocument->GetInnerWindow());
 }
 
 void
 nsPresContext::NotifyInvalidation(const nsRect& aRect, PRUint32 aFlags)
 {
+
+NS_ASSERTION((mDocument &&
+              mDocument->GetInnerWindow() &&
+              !mDocument->GetInnerWindow()->IsFrozen()),"Invalidation called from frozen doc");
+
   // If there is no paint event listener, then we don't need to fire
   // the asynchronous event. We don't even need to record invalidation.
   // MayHavePaintEventListener is pretty cheap and we could make it
   // even cheaper by providing a more efficient
   // nsPIDOMWindow::GetListenerManager.
   if (aRect.IsEmpty() || !MayHavePaintEventListener())
     return;
 
-  if (!IsDOMPaintEventPending()) {
-    // No event is pending. Dispatch one now.
-    nsCOMPtr<nsIRunnable> ev =
-      new nsRunnableMethod<nsPresContext>(this,
-                                          &nsPresContext::FireDOMPaintEvent);
-    NS_DispatchToCurrentThread(ev);
-  }
-
   nsInvalidateRequestList::Request* request =
     mInvalidateRequests.mRequests.AppendElement();
   if (!request)
     return;
 
   request->mRect = aRect;
   request->mFlags = aFlags;
+
+  // We only forward a new call to send the event, if we have just added
+  // something to the list and we haven't allready got a pending call
+  if (!IsDOMPaintEventPending()) {
+    // No event is pending. Dispatch one now.
+    nsCOMPtr<nsIRunnable> ev =
+      new nsRunnableMethod<nsPresContext>(this,
+                                          &nsPresContext::FireDOMPaintEvent);
+
+    if(NS_SUCCEEDED(NS_DispatchToCurrentThread(ev))) {
+      // We now have an event pending on the queue
+      mDOMPaintEventPending = PR_TRUE;
+    }
+  }
+
 }
 
 PRBool
 nsPresContext::HasCachedStyleData()
 {
   return mShell && mShell->StyleSet()->HasCachedStyleData();
 }
 
Index: mozilla/layout/base/nsPresContext.h
===================================================================
--- mozilla.orig/layout/base/nsPresContext.h
+++ mozilla/layout/base/nsPresContext.h
@@ -819,17 +819,17 @@ public:
   // font set changes (e.g., because a new font loads, or because the
   // user font set is changed and fonts become unavailable).
   void UserFontSetUpdated();
 
   PRBool MayHavePaintEventListener();
   void NotifyInvalidation(const nsRect& aRect, PRUint32 aFlags);
   void FireDOMPaintEvent();
   PRBool IsDOMPaintEventPending() {
-    return !mInvalidateRequests.mRequests.IsEmpty();
+    return mDOMPaintEventPending;
   }
 
   void ClearMozAfterPaintEvents() {
     mInvalidateRequests.mRequests.Clear();
   }
 
   /**
    * Notify the prescontext that the presshell is about to reflow a reflow root.
@@ -1044,16 +1044,19 @@ protected:
 #ifdef IBMBIDI
   unsigned              mIsVisual : 1;
 
 #endif
 #ifdef DEBUG
   PRBool                mInitialized;
 #endif
 
+private:
+  PRPackedBool          mDOMPaintEventPending;
+
   unsigned              mResizeEventSuspended : 1;
 
 protected:
 
   virtual ~nsPresContext() NS_HIDDEN;
 
   // these are private, use the list in nsFont.h if you want a public list
   enum {
Index: mozilla/layout/build/Makefile.in
===================================================================
--- mozilla.orig/layout/build/Makefile.in
+++ mozilla/layout/build/Makefile.in
@@ -173,16 +173,22 @@ SHARED_LIBRARY_LIBS 	+= \
 endif
 
 ifdef MOZ_WAVE
 SHARED_LIBRARY_LIBS 	+= \
 	$(DEPTH)/content/media/wave/$(LIB_PREFIX)gkconwave_s.$(LIB_SUFFIX) \
 	$(NULL)
 endif
 
+ifdef MOZ_GSTREAMER
+SHARED_LIBRARY_LIBS 	+= \
+	$(DEPTH)/content/media/gstreamer/$(LIB_PREFIX)gkcongstreamer_s.$(LIB_SUFFIX) \
+	$(NULL)
+endif
+
 ifdef MOZ_SYDNEYAUDIO
 SHARED_LIBRARY_LIBS 	+= \
 	$(DEPTH)/media/libsydneyaudio/src/$(LIB_PREFIX)sydneyaudio.$(LIB_SUFFIX) \
 	$(NULL)
 LOCAL_INCLUDES += -I$(DEPTH)/content/html/content/src
 endif
 
 ifdef NS_PRINTING
@@ -289,16 +295,20 @@ EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS)
 endif
 
 ifdef MOZ_SYDNEYAUDIO
 ifeq ($(OS_ARCH),Darwin)
 OS_LIBS += -framework CoreAudio -framework AudioToolbox -framework AudioUnit -framework Carbon
 endif
 endif
 
+ifdef MOZ_GSTREAMER
+EXTRA_DSO_LDOPTS += $(GSTREAMER_LIBS)
+endif
+
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES	+= -I$(srcdir)/../base \
 		   -I$(srcdir)/../generic \
 		   -I$(srcdir)/../forms \
 		   -I$(srcdir)/../tables \
 		   -I$(srcdir)/../style \
 		   -I$(srcdir)/../xul/content/src \
Index: mozilla/toolkit/library/Makefile.in
===================================================================
--- mozilla.orig/toolkit/library/Makefile.in
+++ mozilla/toolkit/library/Makefile.in
@@ -243,16 +243,18 @@ ifeq (qt,$(MOZ_WIDGET_TOOLKIT))
 EXTRA_DSO_LDOPTS += $(XLDFLAGS) $(XLIBS) $(XT_LIBS) $(MOZ_QT_LIBS) -lgthread-2.0
 EXTRA_DSO_LDOPTS += $(FT2_LIBS)
 endif
 
 ifdef MOZ_TREE_FREETYPE
 EXTRA_DSO_LDOPTS += $(FT2_LIBS)
 endif
 
+EXTRA_DSO_LDOPTS += $(GSTREAMER_LIBS)
+
 ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
 EXTRA_DSO_LDOPTS += $(MOZ_STARTUP_NOTIFICATION_LIBS)
 endif
 
 ifeq ($(OS_ARCH),BeOS)
 EXTRA_DSO_LDOPTS += -lbe -ltracker
 endif
 
